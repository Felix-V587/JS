<!DOCTYPE html>
<!-- Created by pdf2htmlEX (https://github.com/coolwanglu/pdf2htmlex) -->
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta charset="utf-8"/>
<title></title>
</head>
<body>
<div id="page-container">
<div id="pf64" class="pf w0 h0" data-page-no="64"><div class="pc pc64 w0 h0"><div class="t m0 x0 h2 y1 ff1 fs0 fc0 sc0 ls7 ws0">82  第4章 变量、作用域和内存问题 </div><div class="t m0 x0 h3 y2 ff1 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ff3 fs1 fc0 sc0 ls2"> 确定一个值是哪种基本类型可以使用typeof操作符，而确定一个值是哪种引用类型可以使用</div><div class="t m0 x0 h5 y4 ff6 fs1 fc0 sc0 ls9 ws2">instanceof操作符。 </div><div class="t m0 x0 h4 y5 ff5 fs2 fc0 sc0 ls4 ws3">所有变量（包括基本类型和引用类型）都存在于一个执行环境（也称为作用域）当中，这个执</div><div class="t m0 x0 h4 y6 ff5 fs2 fc0 sc0 ls4 ws3">行环境决定了变量的生命周期，以及哪一部分代码可以访问其中的变量。以下是关于执行环境的几</div><div class="t m0 x0 h5 y7 ff5 fs2 fc0 sc0 lsa">点总结： </div><div class="t m0 x0 h5 y8 ff3 fs1 fc0 sc0 ls2"> 执行环境有全局执行环境（也称为全局环境）和函数执行环境之分； </div><div class="t m0 x0 h5 y9 ff3 fs1 fc0 sc0 ls2"> 每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链； </div><div class="t m0 x0 h4 ya ff3 fs1 fc0 sc0 ls2"> 函数的局部环境不仅有权访问函数作用域中的变量，而且有权访问其包含（父）环境，乃至全</div><div class="t m0 x0 h5 yb ff5 fs2 fc0 sc0 ls8">局环境； </div><div class="t m0 x0 h5 yc ff3 fs1 fc0 sc0 ls2"> 全局环境只能访问在全局环境中定义的变量和函数，而不能直接访问局部环境中的任何数据； </div><div class="t m0 x0 h5 yd ff3 fs1 fc0 sc0 ls2"> 变量的执行环境有助于确定应该何时释放内存。 </div><div class="t m0 x0 h5 ye ff1 fs2 fc0 sc0 lsb ws5">JavaScript是一门具有自动垃圾收集机制的编程语言，开发人员不必关心内存分配和回收问题。可</div><div class="t m0 x0 h5 yf ff5 fs2 fc0 sc0 ls8 ws1">以对JavaScript的垃圾收集例程作如下总结。 </div><div class="t m0 x0 h5 y10 ff3 fs1 fc0 sc0 ls2"> 离开作用域的值将被自动标记为可以回收，因此将在垃圾收集期间被删除。 </div><div class="t m0 x0 h4 y11 ff3 fs1 fc0 sc0 ls2"> “标记清除”是目前主流的垃圾收集算法，这种算法的思想是给当前不使用的值加上标记，然</div><div class="t m0 x0 h5 y12 ff5 fs2 fc0 sc0 ls8 ws1">后再回收其内存。 </div><div class="t m0 x0 h5 y13 ff3 fs1 fc0 sc0 ls2"> 另一种垃圾收集算法是“引用计数”，这种算法的思想是跟踪记录所有值被引用的次数。JavaScript</div><div class="t m0 x0 h5 y14 ff5 fs2 fc0 sc0 ls8 ws1">引擎目前都不再使用这种算法；但在IE中访问非原生JavaScript对象（如DOM元素）时，这种</div><div class="t m0 x0 h5 y15 ff5 fs2 fc0 sc0 ls8 ws1">算法仍然可能会导致问题。 </div><div class="t m0 x0 h5 y16 ff3 fs1 fc0 sc0 ls2"> 当代码中存在循环引用现象时，“引用计数”算法就会导致问题。 </div><div class="t m0 x0 h4 y17 ff3 fs1 fc0 sc0 ls2"> 解除变量的引用不仅有助于消除循环引用现象，而且对垃圾收集也有好处。为了确保有效地回</div><div class="t m0 x0 h5 y18 ff5 fs2 fc0 sc0 ls8 ws1">收内存，应该及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用。 </div><div class="t m0 x0 h5 y19 ff1 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1a ff1 fs2 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf65" class="pf w0 h0" data-page-no="65"><div class="pc pc65 w0 h0"><div class="t m0 x2 h2 y1 ff8 fs0 fc0 sc0 ls10 wsc">5.1 Object类型   83 </div><div class="t m0 x0 h3 y2 ff8 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffa fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ffa fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffa fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffa fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffa fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffa fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffa fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffa fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffa fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffa fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffa fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffa fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ffa fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h9 y2a ffb fs5 fc0 sc0 ls12 wsb">引 用 类 型 </div><div class="t m0 x0 h5 y2b ffc fs2 fc0 sc0 ls8">本章内容 </div><div class="t m0 x0 h5 y2c ffd fs1 fc0 sc0 ls2"> 使用对象 </div><div class="t m0 x0 h5 y2d ffd fs1 fc0 sc0 ls2"> 创建并操作数组 </div><div class="t m0 x0 h5 y2e ffd fs1 fc0 sc0 ls2"> 理解基本的JavaScript类型 </div><div class="t m0 x0 h5 y2f ffd fs1 fc0 sc0 ls2"> 使用基本类型和基本包装类型 </div><div class="t m0 x0 h5 y30 ff8 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x1 h5 y31 fff fs2 fc0 sc0 ls8 ws1">用类型的值（对象）是引用类型的一个实例。在ECMAScript中，引用类型是一种数据结构，</div><div class="t m0 x1 h5 y32 fff fs2 fc0 sc0 ls5 ws4">用于将数据和功能组织在一起。它也常被称为类，但这种称呼并不妥当。尽管ECMAScript</div><div class="t m0 x0 h4 y33 fff fs2 fc0 sc0 ls8 ws1">从技术上讲是一门面向对象的语言，但它不具备传统的面向对象语言所支持的类和接口等基本结构。引</div><div class="t m0 x0 h5 y34 fff fs2 fc0 sc0 ls8 ws1">用类型有时候也被称为对象定义，因为它们描述的是一类对象所具有的属性和方法。 </div><div class="t m0 x1 ha y35 ff9 fs2 fc0 sc0 ls8 ws14">虽然引用类型与类看起来相似，但它们并不是相同的概念。为避免混淆，本书将</div><div class="t m0 x1 h5 y36 ff9 fs2 fc0 sc0 ls8 ws14">不使用类这个概念。 </div><div class="t m0 x0 h4 y37 fff fs2 fc0 sc0 ls1f">如前所述，对象是某个特定引用类型的实例。新对象是使用new操作符后跟一个构造函数来创建的。</div><div class="t m0 x0 h5 y38 fff fs2 fc0 sc0 ls1f">构造函数本身就是一个函数，只不过该函数是出于创建新对象的目的而定义的。请看下面这行代码： </div><div class="t m0 x1 hb y39 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3a ff10 fs6 fc0 sc0 ls21 wsb">var person = new Object();  </div><div class="t m0 x1 hb y3b ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3c fff fs2 fc0 sc0 ls5 ws4">这行代码创建了Object引用类型的一个新实例，然后把该实例保存在了变量person 中。使用</div><div class="t m0 x0 hc y3d fff fs2 fc0 sc0 ls5 ws4">的构造函数是Object，它只为新对象定义了默认的属性和方法。ECMAScript提供了很多原生引用类</div><div class="t m0 x0 h5 y3e fff fs2 fc0 sc0 ls5 ws4">型（例如Object），以便开发人员用以实现常见的计算任务。 </div><div class="t m0 x0 hd y3f ffe fs7 fc0 sc0 ls22">5.1 Object类型 </div><div class="t m0 x0 h4 y40 fff fs2 fc0 sc0 ls19 ws1b">到目前为止，我们看到的大多数引用类型值都是Object类型的实例；而且，Object 也是</div><div class="t m0 x0 h5 y41 ff8 fs2 fc0 sc0 ls1a ws1c">ECMAScript中使用最多的一个类型。虽然Object的实例不具备多少功能，但对于在应用程序中存储</div><div class="t m0 x0 h5 y42 fff fs2 fc0 sc0 ls8 ws1">和传输数据而言，它们确实是非常理想的选择。 </div><div class="t m0 x0 he y43 fff fs2 fc0 sc0 ls8 ws1">创建Object实例的方式有两种。第一种是使用new操作符后跟 Object构造函数，如下所示： </div><div class="t m0 x1 hb y44 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y45 ff10 fs6 fc0 sc0 ls21 wsb">var person = new Object(); </div><div class="t m0 x0 hb y46 ff10 fs6 fc0 sc0 ls21 wsb">person.name = &quot;Nicholas&quot;; </div><div class="t m0 x0 hb y47 ff10 fs6 fc0 sc0 ls21 wsb">person.age = 29; </div><div class="t m0 x1 hb y48 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y49 ff12 fs2 fc0 sc0 ls1b wsb">ObjectTypeExample01.htm </div><div class="t m0 x0 h10 y4a ffc fs9 fc0 sc0 ls8">引</div><div class="t m0 x0 h11 y4b ff13 fsa fc0 sc0 ls8">第</div><div class="t m1 x0 h12 y4b ff14 fsb fc3 sc0 ls8">5</div><div class="t m0 x1 h11 y4b ff13 fsa fc0 sc0 ls8 ws1d">章 </div></div></div>
<div id="pf66" class="pf w0 h0" data-page-no="66"><div class="pc pc66 w0 h0"><div class="t m0 x0 h2 y1 ff8 fs0 fc0 sc0 ls7 ws0">84  第5章 引用类型 </div><div class="t m0 x0 h3 y2 ff8 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 fff fs2 fc0 sc0 ls8 ws1">另一种方式是使用对象字面量表示法。对象字面量是对象定义的一种简写形式，目的在于简化创建</div><div class="t m0 x0 h4 y4d fff fs2 fc0 sc0 ls24 ws1e">包含大量属性的对象的过程。下面这个例子就使用了对象字面量语法定义了与前面那个例子中相同的</div><div class="t m0 x0 h5 y4e ff10 fs1 fc0 sc0 ls9 ws2">person对象： </div><div class="t m0 x0 hb y4f ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y50 ff10 fs6 fc0 sc0 ls21 wsb">var person = { </div><div class="t m0 x0 hb y51 ff10 fs6 fc0 sc0 ls21 wsb">    name : &quot;Nicholas&quot;, </div><div class="t m0 x0 hb y52 ff10 fs6 fc0 sc0 ls21 wsb">    age : 29 </div><div class="t m0 x0 hb y53 ff10 fs6 fc0 sc0 ls21 wsb">};  </div><div class="t m0 x2 hf y54 ff12 fs2 fc0 sc0 ls25 wsb">ObjectTypeExample02.htm </div><div class="t m0 x0 h4 y55 fff fs2 fc0 sc0 ls26 ws1f">在这个例子中，左边的花括号（{）表示对象字面量的开始，因为它出现在了表达式上下文</div><div class="t m0 x0 h5 y56 fff fs2 fc0 sc0 ls14">（expression context）中。ECMAScript中的表达式上下文指的是能够返回一个值（表达式）。赋值操作</div><div class="t m0 x0 h4 y57 fff fs2 fc0 sc0 ls24">符表示后面是一个值，所以左花括号在这里表示一个表达式的开始。同样的花括号，如果出现在一个</div><div class="t m0 x0 h14 y58 fff fs2 fc0 sc0 ls5">语句上下文（statement context）中，例如跟在if语句条件的后面，则表示一个语句块的开始。 </div><div class="t m0 x0 h4 y59 fff fs2 fc0 sc0 ls8 ws1">然后，我们定义了name属性，之后是一个冒号，再后面是这个属性的值。在对象字面量中，使用</div><div class="t m0 x0 hc y5a fff fs2 fc0 sc0 ls8 ws1">逗号来分隔不同的属性，因此&quot;Nicholas&quot;后面是一个逗号。但是，在age属性的值29 的后面不能添</div><div class="t m0 x0 hc y5b fff fs2 fc0 sc0 ls8 ws1">加逗号，因为age是这个对象的最后一个属性。在最后一个属性后面添加逗号，会在IE7及更早版本和</div><div class="t m0 x0 h5 y5c ff8 fs2 fc0 sc0 ls2b ws22">Opera中导致错误。 </div><div class="t m0 x0 h5 y5d fff fs2 fc0 sc0 ls8 ws1">在使用对象字面量语法时，属性名也可以使用字符串，如下面这个例子所示。 </div><div class="t m0 x0 hb y5e ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y5f ff10 fs6 fc0 sc0 ls21 wsb">var person = { </div><div class="t m0 x0 h15 y60 ff11 fs6 fc0 sc0 ls21 wsb">    &quot;name&quot; : &quot;Nicholas&quot;, </div><div class="t m0 x0 h15 y61 ff11 fs6 fc0 sc0 ls21 wsb">    &quot;age&quot; : 29, </div><div class="t m0 x0 h15 y62 ff11 fs6 fc0 sc0 ls21 wsb">    5 : true </div><div class="t m0 x0 hb y63 ff10 fs6 fc0 sc0 ls21 wsb">};  </div><div class="t m0 x0 h4 y64 fff fs2 fc0 sc0 ls8 ws1">这个例子会创建一个对象，包含三个属性：name、age和5。但这里的数值属性名会自动转换为字</div><div class="t m0 x0 h5 y65 fff fs2 fc0 sc0 ls8">符串。 </div><div class="t m0 x0 h4 y66 fff fs2 fc0 sc0 ls8 ws1">另外，使用对象字面量语法时，如果留空其花括号，则可以定义只包含默认属性和方法的对象，如</div><div class="t m0 x0 h5 y67 fff fs2 fc0 sc0 ls8">下所示： </div><div class="t m0 x0 hb y68 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y69 ff11 fs6 fc0 sc0 ls21 wsb">var person = {};         //与new Object()相同 </div><div class="t m0 x0 hb y6a ff10 fs6 fc0 sc0 ls21 wsb">person.name = &quot;Nicholas&quot;; </div><div class="t m0 x0 hb y6b ff10 fs6 fc0 sc0 ls21 wsb">person.age = 29; </div><div class="t m0 x0 hb y6c ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y6d fff fs2 fc0 sc0 ls8 ws1">这个例子与本节前面的例子是等价的，只不过看起来似乎有点奇怪。关于对象字面量语法，我们推</div><div class="t m0 x0 h5 y6e fff fs2 fc0 sc0 ls8 ws1">荐只在考虑对象属性名的可读性时使用。 </div><div class="t m0 x1 h17 y6f ff9 fs2 fc0 sc0 ls8 ws14">在通过对象字面量定义对象时，实际上不会调用Object构造函数（Firefox 2及</div><div class="t m0 x0 h18 y70 ff9 fs2 fc0 sc0 ls8 ws14">更早版本会调用Object构造函数；但Firefox 3之后就不会了）。 </div><div class="t m0 x0 h4 y71 fff fs2 fc0 sc0 ls8 ws1">虽然可以使用前面介绍的任何一种方法来定义对象，但开发人员更青睐对象字面量语法，因为这种</div><div class="t m0 x0 h4 y72 fff fs2 fc0 sc0 ls8 ws1">语法要求的代码量少，而且能够给人封装数据的感觉。实际上，对象字面量也是向函数传递大量可选参</div><div class="t m0 x0 h5 y73 fff fs2 fc0 sc0 ls8 ws1">数的首选方式，例如： </div><div class="t m0 x0 hb y74 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y75 ff10 fs6 fc0 sc0 ls21 wsb">function displayInfo(args) { </div><div class="t m0 x0 hb y76 ff10 fs6 fc0 sc0 ls21 wsb">    var output = &quot;&quot;; </div><div class="t m0 x0 hb y77 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y78 ff10 fs6 fc0 sc0 ls21 wsb">    if (typeof args.name == &quot;string&quot;){ </div></div></div>
<div id="pf67" class="pf w0 h0" data-page-no="67"><div class="pc pc67 w0 h0"><div class="t m0 x2 h2 y1 ff8 fs0 fc0 sc0 ls10 wsc">5.1 Object类型   85 </div><div class="t m0 x0 h3 y2 ff8 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffa fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ffa fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffa fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffa fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffa fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffa fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffa fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffa fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffa fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffa fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffa fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffa fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ffa fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y79 ff10 fs6 fc0 sc0 ls21 wsb">        output += &quot;Name: &quot; + args.name + &quot;\n&quot;; </div><div class="t m0 x0 hb y7a ff10 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y7b ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y7c ff10 fs6 fc0 sc0 ls21 wsb">    if (typeof args.age == &quot;number&quot;) { </div><div class="t m0 x0 hb y7d ff10 fs6 fc0 sc0 ls21 wsb">        output += &quot;Age: &quot; + args.age + &quot;\n&quot;; </div><div class="t m0 x0 hb y7e ff10 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y7f ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y80 ff10 fs6 fc0 sc0 ls21 wsb">    alert(output); </div><div class="t m0 x0 hb y81 ff10 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y82 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y83 ff10 fs6 fc0 sc0 ls21 wsb">displayInfo({  </div><div class="t m0 x0 hb y84 ff10 fs6 fc0 sc0 ls21 wsb">    name: &quot;Nicholas&quot;,  </div><div class="t m0 x0 hb y85 ff10 fs6 fc0 sc0 ls21 wsb">    age: 29 </div><div class="t m0 x0 hb y86 ff10 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 hb y87 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y88 ff10 fs6 fc0 sc0 ls21 wsb">displayInfo({ </div><div class="t m0 x0 hb y89 ff10 fs6 fc0 sc0 ls21 wsb">    name: &quot;Greg&quot; </div><div class="t m0 x0 hb y8a ff10 fs6 fc0 sc0 ls21 wsb">});  </div><div class="t m0 x2 hf y8b ff12 fs2 fc0 sc0 ls1b wsb">ObjectTypeExample04.htm </div><div class="t m0 x0 h4 y8c fff fs2 fc0 sc0 ls8 ws1">在这个例子中，函数displayInfo()接受一个名为args的参数。这个参数可能带有一个名为name</div><div class="t m0 x0 h4 y8d fff fs2 fc0 sc0 ls2c">或age的属性，也可能这两个属性都有或者都没有。在这个函数内部，我们通过typeof操作符来检测</div><div class="t m0 x0 h4 y8e fff fs2 fc0 sc0 ls8 ws1">每个属性是否存在，然后再基于相应的属性来构建一条要显示的消息。然后，我们调用了两次这个函数，</div><div class="t m0 x0 h5 y8f fff fs2 fc0 sc0 ls8 ws1">每次都使用一个对象字面量来指定不同的数据。这两次调用传递的参数虽然不同，但函数都能正常执行。 </div><div class="t m0 x1 ha y90 ff9 fs2 fc0 sc0 ls8 ws14">这种传递参数的模式最适合需要向函数传入大量可选参数的情形。一般来讲，命</div><div class="t m0 x1 ha y91 ff9 fs2 fc0 sc0 ls8 ws14">名参数虽然容易处理，但在有多个可选参数的情况下就会显示不够灵活。最好的做法</div><div class="t m0 x1 h5 y92 ff9 fs2 fc0 sc0 ls8 ws14">是对那些必需值使用命名参数，而使用对象字面量来封装多个可选参数。 </div><div class="t m0 x0 h4 y93 fff fs2 fc0 sc0 ls8 ws1">一般来说，访问对象属性时使用的都是点表示法，这也是很多面向对象语言中通用的语法。不过，</div><div class="t m0 x0 h5 y94 fff fs2 fc0 sc0 ls32">在JavaScript也可以使用方括号表示法来访问对象的属性。在使用方括号语法时，应该将要访问的属性</div><div class="t m0 x0 h5 y95 fff fs2 fc0 sc0 ls8 ws1">以字符串的形式放在方括号中，如下面的例子所示。 </div><div class="t m0 x1 hb y96 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y97 ff10 fs6 fc0 sc0 ls21 wsb">alert(person[&quot;name&quot;]);       //&quot;Nicholas&quot; </div><div class="t m0 x0 hb y98 ff10 fs6 fc0 sc0 ls21 wsb">alert(person.name);          //&quot;Nicholas&quot; </div><div class="t m0 x1 hb y99 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y9a fff fs2 fc0 sc0 ls8 ws1">从功能上看，这两种访问对象属性的方法没有任何区别。但方括号语法的主要优点是可以通过变量</div><div class="t m0 x0 h5 y9b fff fs2 fc0 sc0 ls8 ws1">来访问属性，例如： </div><div class="t m0 x1 hb y9c ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y9d ff10 fs6 fc0 sc0 ls21 wsb">var propertyName = &quot;name&quot;; </div><div class="t m0 x0 hb y9e ff10 fs6 fc0 sc0 ls21 wsb">alert(person[propertyName]);  //&quot;Nicholas&quot; </div><div class="t m0 x1 hb y9f ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 ya0 fff fs2 fc0 sc0 ls8 ws1">如果属性名中包含会导致语法错误的字符，或者属性名使用的是关键字或保留字，也可以使用方括</div><div class="t m0 x0 h5 ya1 fff fs2 fc0 sc0 ls8 ws1">号表示法。例如： </div><div class="t m0 x0 hb ya2 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ya3 ff10 fs6 fc0 sc0 ls21 wsb">person[&quot;first name&quot;] = &quot;Nicholas&quot;; </div><div class="t m0 x0 hb ya4 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 ya5 fff fs2 fc0 sc0 ls8 ws1">由于&quot;first name&quot;中包含一个空格，所以不能使用点表示法来访问它。然而，属性名中是可以包</div><div class="t m0 x0 h5 ya6 fff fs2 fc0 sc0 ls8 ws1">含非字母非数字的，这时候就可以使用方括号表示法来访问它们。 </div><div class="t m0 x0 h5 ya7 fff fs2 fc0 sc0 ls8 ws1">通常，除非必须使用变量来访问属性，否则我们建议使用点表示法。 </div></div></div>
<div id="pf68" class="pf w0 h0" data-page-no="68"><div class="pc pc68 w0 h0"><div class="t m0 x0 h2 y1 ff8 fs0 fc0 sc0 ls7 ws0">86  第5章 引用类型 </div><div class="t m0 x0 h3 y2 ff8 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hd ya9 ffe fs7 fc0 sc0 ls22">5.2 Array类型 </div><div class="t m0 x0 h5 yaa fff fs2 fc0 sc0 ls30 ws2a">除了Object之外，Array类型恐怕是 ECMAScript中最常用的类型了。而且，ECMAScript中</div><div class="t m0 x0 h5 yab fff fs2 fc0 sc0 ls30 ws2a">的数组与其他多数语言中的数组有着相当大的区别。虽然ECMAScript数组与其他语言中的数组都是</div><div class="t m0 x0 h5 yac fff fs2 fc0 sc0 ls30 ws2a">数据的有序列表，但与其他语言不同的是，ECMAScript数组的每一项可以保存任何类型的数据。也</div><div class="t m0 x0 h4 yad fff fs2 fc0 sc0 ls30 ws2a">就是说，可以用数组的第一个位置来保存字符串，用第二位置来保存数值，用第三个位置来保存对象，</div><div class="t m0 x0 h5 yae fff fs2 fc0 sc0 ls30 ws2a">以此类推。而且，ECMAScript数组的大小是可以动态调整的，即可以随着数据的添加自动增长以容</div><div class="t m0 x0 h5 yaf fff fs2 fc0 sc0 ls30 ws2a">纳新增数据。 </div><div class="t m0 x0 h1b yb0 fff fs2 fc0 sc0 ls8 ws1">创建数组的基本方式有两种。第一种是使用Array构造函数，如下面的代码所示。 </div><div class="t m0 x0 hb yb1 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yb2 ff10 fs6 fc0 sc0 ls21 wsb">var colors = new Array(); </div><div class="t m0 x0 hb yb3 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 yb4 fff fs2 fc0 sc0 ls8 ws1">如果预先知道数组要保存的项目数量，也可以给构造函数传递该数量，而该数量会自动变成length</div><div class="t m0 x0 h5 yb5 fff fs2 fc0 sc0 ls8 ws1">属性的值。例如，下面的代码将创建length值为20的数组。 </div><div class="t m0 x0 hb yb6 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yb7 ff10 fs6 fc0 sc0 ls21 wsb">var colors = new Array(20); </div><div class="t m0 x0 hb yb8 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 yb9 fff fs2 fc0 sc0 ls42 ws30">也可以向Array构造函数传递数组中应该包含的项。以下代码创建了一个包含3个字符串值的数组： </div><div class="t m0 x0 hb yba ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ybb ff10 fs6 fc0 sc0 ls21 wsb">var colors = new Array(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;); </div><div class="t m0 x0 hb ybc ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 ybd fff fs2 fc0 sc0 ls8 ws1">当然，给构造函数传递一个值也可以创建数组。但这时候问题就复杂一点了，因为如果传递的是数</div><div class="t m0 x0 h4 ybe fff fs2 fc0 sc0 ls8 ws1">值，则会按照该数值创建包含给定项数的数组；而如果传递的是其他类型的参数，则会创建包含那个值</div><div class="t m0 x0 h5 ybf fff fs2 fc0 sc0 ls8 ws1">的只有一项的数组。下面就两个例子： </div><div class="t m0 x0 hb yc0 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 yc1 ff10 fs6 fc0 sc0 ls21 wsb">var colors = new Array(3);       // 创建一个包含 3项的数组 </div><div class="t m0 x0 h16 yc2 ff10 fs6 fc0 sc0 ls21 wsb">var names = new Array(&quot;Greg&quot;);     // 创建一个包含1项，即字符串&quot;Greg&quot;的数组 </div><div class="t m0 x0 hb yc3 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf yc4 ff12 fs2 fc0 sc0 ls8 wsb">ArrayTypeExample01.htm </div><div class="t m0 x0 h4 yc5 fff fs2 fc0 sc0 ls8 ws1">另外，在使用Array构造函数时也可以省略new操作符。如下面的例子所示，省略new 操作符的</div><div class="t m0 x0 h5 yc6 fff fs2 fc0 sc0 ls8 ws1">结果相同： </div><div class="t m0 x0 hb yc7 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 yc8 ff10 fs6 fc0 sc0 ls21 wsb">var colors = Array(3);             // 创建一个包含3项的数组 </div><div class="t m0 x0 h16 yc9 ff10 fs6 fc0 sc0 ls21 wsb">var names = Array(&quot;Greg&quot;);     // 创建一个包含1项，即字符串&quot;Greg&quot;的数组 </div><div class="t m0 x0 hb yca ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 ycb fff fs2 fc0 sc0 ls24 ws1e">创建数组的第二种基本方式是使用数组字面量表示法。数组字面量由一对包含数组项的方括号表</div><div class="t m0 x0 h5 ycc fff fs2 fc0 sc0 ls8 ws1">示，多个数组项之间以逗号隔开，如下所示： </div><div class="t m0 x0 hb ycd ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 yce ff10 fs6 fc0 sc0 ls21 wsb">var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; // 创建一个包含3个字符串的数组 </div><div class="t m0 x0 h16 ycf ff10 fs6 fc0 sc0 ls21 wsb">var names = [];                       // 创建一个空数组 </div><div class="t m0 x0 h16 yd0 ff10 fs6 fc0 sc0 ls21 wsb">var values = [1,2,];                  // 不要这样！这样会创建一个包含2或3项的数组 </div><div class="t m0 x0 h16 yd1 ff10 fs6 fc0 sc0 ls21 wsb">var options = [,,,,,];                  // 不要这样！这样会创建一个包含5或6项的数组 </div><div class="t m0 x0 hb yd2 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf yd3 ff12 fs2 fc0 sc0 ls8 wsb">ArrayTypeExample02.htm </div><div class="t m0 x0 h5 yd4 fff fs2 fc0 sc0 ls8 ws1">以上代码的第一行创建了一个包含3个字符串的数组。第二行使用一对空方括号创建了一个空数组。</div><div class="t m0 x0 h5 yd5 fff fs2 fc0 sc0 ls8 ws1">第三行展示了在数组字面量的最后一项添加逗号的结果：在IE中，values会成为一个包含3个项且每</div><div class="t m0 x0 hc yd6 fff fs2 fc0 sc0 ls8 ws1">项的值分别为1、2和undefined的数组；在其他浏览器中，values会成为一个包含2项且值分别为</div><div class="t m0 x0 h5 yd7 ff8 fs2 fc0 sc0 ls38">1和2的数组。原因是IE8及之前版本中的ECMAScript实现在数组字面量方面存在bug。由于这个 bug</div></div></div>
<div id="pf69" class="pf w0 h0" data-page-no="69"><div class="pc pc69 w0 h0"><div class="t m0 x2 h2 y1 ff8 fs0 fc0 sc0 ls10 wsc">5.2 Array类型   87 </div><div class="t m0 x0 h3 y2 ff8 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffa fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ffa fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffa fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffa fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffa fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffa fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffa fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffa fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffa fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffa fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffa fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffa fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ffa fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 fff fs2 fc0 sc0 ls8 ws1">导致的另一种情况如最后一行代码所示，该行代码可能会创建包含5项的数组（在IE9+、Firefox、Opera、</div><div class="t m0 x0 h5 y4d ff8 fs2 fc0 sc0 ls48 ws39">Safari和Chrome中），也可能会创建包含6项的数组（在IE8及更早版本中）。在像这种省略值的情况下，</div><div class="t m0 x0 h1c yd8 fff fs2 fc0 sc0 ls8 ws1">每一项都将获得undefined值；这个结果与调用Array构造函数时传递项数在逻辑上是相同的。但是</div><div class="t m0 x0 h5 yd9 fff fs2 fc0 sc0 ls8 ws1">由于IE的实现与其他浏览器不一致，因此我们强烈建议不要使用这种语法。 </div><div class="t m0 x1 h1d yda ff9 fs2 fc0 sc0 ls1f ws3b">与对象一样，在使用数组字面量表示法时，也不会调用Array构造函数（Firefox 3</div><div class="t m0 x1 h5 ydb ff9 fs2 fc0 sc0 ls8 ws14">及更早版本除外）。 </div><div class="t m0 x0 h5 ydc fff fs2 fc0 sc0 ls8 ws1">在读取和设置数组的值时，要使用方括号并提供相应值的基于0的数字索引，如下所示： </div><div class="t m0 x1 hb ydd ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 yde ff10 fs6 fc0 sc0 ls21 wsb">var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];  // 定义一个字符串数组 </div><div class="t m0 x0 h16 ydf ff10 fs6 fc0 sc0 ls21 wsb">alert(colors[0]);                    // 显示第一项 </div><div class="t m0 x0 h16 ye0 ff10 fs6 fc0 sc0 ls21 wsb">colors[2] = &quot;black&quot;;                  // 修改第三项 </div><div class="t m0 x0 h16 ye1 ff10 fs6 fc0 sc0 ls21 wsb">colors[3] = &quot;brown&quot;;                  // 新增第四项 </div><div class="t m0 x1 hb ye2 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 ye3 fff fs2 fc0 sc0 ls8 ws1">方括号中的索引表示要访问的值。如果索引小于数组中的项数，则返回对应项的值，就像这个例子</div><div class="t m0 x0 h4 ye4 fff fs2 fc0 sc0 ls8 ws1">中的colors[0]会显示&quot;red&quot;一样。设置数组的值也使用相同的语法，但会替换指定位置的值。如果设</div><div class="t m0 x0 h1e ye5 fff fs2 fc0 sc0 ls6 ws6">置某个值的索引超过了数组现有项数，如这个例子中的colors[3]所示，数组就会自动增加到该索引</div><div class="t m0 x0 h5 ye6 fff fs2 fc0 sc0 ls8 ws1">值加1的长度（就这个例子而言，索引是3，因此数组长度就是4）。 </div><div class="t m0 x0 he ye7 fff fs2 fc0 sc0 ls8 ws1">数组的项数保存在其length属性中，这个属性始终会返回0或更大的值，如下面这个例子所示： </div><div class="t m0 x1 hb ye8 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 ye9 ff10 fs6 fc0 sc0 ls21 wsb">var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];    // 创建一个包含3个字符串的数组 </div><div class="t m0 x0 h16 yea ff10 fs6 fc0 sc0 ls21 wsb">var names = [];                         // 创建一个空数组 </div><div class="t m0 x0 hb yeb ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 yec ff11 fs6 fc0 sc0 ls21 wsb">alert(colors.length);            //3 </div><div class="t m0 x0 h15 yed ff11 fs6 fc0 sc0 ls21 wsb">alert(names.length);             //0 </div><div class="t m0 x1 hb yee ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 yef fff fs2 fc0 sc0 ls8 ws1">数组的length属性很有特点——它不是只读的。因此，通过设置这个属性，可以从数组的末尾移</div><div class="t m0 x0 h5 yf0 fff fs2 fc0 sc0 ls8 ws1">除项或向数组中添加新项。请看下面的例子： </div><div class="t m0 x1 hb yf1 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 yf2 ff10 fs6 fc0 sc0 ls21 wsb">var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];     // 创建一个包含3个字符串的数组 </div><div class="t m0 x0 h15 yf3 ff11 fs6 fc0 sc0 ls21 wsb">colors.length = 2; </div><div class="t m0 x0 h15 yf4 ff11 fs6 fc0 sc0 ls21 wsb">alert(colors[2]);                 //undefined </div><div class="t m0 x1 hb yf5 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf yf6 ff12 fs2 fc0 sc0 ls8 wsb">ArrayTypeExample03.htm </div><div class="t m0 x0 h5 yf7 fff fs2 fc0 sc0 ls8 ws1">这个例子中的数组colors一开始有3个值。将其length属性设置为 2会移除最后一项（位置为</div><div class="t m0 x0 h5 yf8 ff8 fs2 fc0 sc0 ls38">2的那一项），结果再访问colors[2]就会显示undefined了。如果将其length属性设置为大于数组</div><div class="t m0 x0 hc yf9 fff fs2 fc0 sc0 ls8 ws1">项数的值，则新增的每一项都会取得undefined值，如下所示： </div><div class="t m0 x1 hb yfa ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 yfb ff10 fs6 fc0 sc0 ls21 wsb">var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];    // 创建一个包含3个字符串的数组 </div><div class="t m0 x0 h15 yfc ff11 fs6 fc0 sc0 ls21 wsb">colors.length = 4; </div><div class="t m0 x0 h15 yfd ff11 fs6 fc0 sc0 ls21 wsb">alert(colors[3]);                 //undefined </div><div class="t m0 x1 h15 yfe ff11 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf yff ff12 fs2 fc0 sc0 ls8 wsb">ArrayTypeExample04.htm </div><div class="t m0 x0 h5 y100 fff fs2 fc0 sc0 ls8 ws1">在此，虽然colors数组包含3个项，但把它的length属性设置成了 4。这个数组不存在位置3，</div><div class="t m0 x0 hc y101 fff fs2 fc0 sc0 ls8 ws1">所以访问这个位置的值就得到了特殊值undefined。 </div><div class="t m0 x0 hc y102 fff fs2 fc0 sc0 ls8 ws1">利用length属性也可以方便地在数组末尾添加新项，如下所示： </div><div class="t m0 x1 hb y103 ff10 fs6 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf6a" class="pf w0 h0" data-page-no="6a"><div class="pc pc6a w0 h0"><div class="t m0 x0 h2 y1 ff8 fs0 fc0 sc0 ls7 ws0">88  第5章 引用类型 </div><div class="t m0 x0 h3 y2 ff8 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y79 ff10 fs6 fc0 sc0 ls21 wsb">var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];    // 创建一个包含3个字符串的数组 </div><div class="t m0 x0 h16 y7a ff11 fs6 fc0 sc0 ls21 wsb">colors[colors.length] = &quot;black&quot;;            //（在位置3）添加一种颜色 </div><div class="t m0 x0 h16 y7b ff11 fs6 fc0 sc0 ls21 wsb">colors[colors.length] = &quot;brown&quot;;            //（在位置4）再添加一种颜色 </div><div class="t m0 x0 hb y105 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y106 ff12 fs2 fc0 sc0 ls8 wsb">ArrayTypeExample05.htm </div><div class="t m0 x0 h4 y107 fff fs2 fc0 sc0 ls8 ws1">由于数组最后一项的索引始终是length-1，因此下一个新项的位置就是length。每当在数组末</div><div class="t m0 x0 h1e y108 fff fs2 fc0 sc0 ls4c ws3e">尾添加一项后，其length属性都会自动更新以反应这一变化。换句话说，上面例子第二行中的</div><div class="t m0 x0 h5 y109 ff10 fs1 fc0 sc0 ls9 ws2">colors[colors.length]为位置3添加了一个值，最后一行的colors[colors.length]则为位置4</div><div class="t m0 x0 h4 y10a fff fs2 fc0 sc0 ls8 ws1">添加了一个值。当把一个值放在超出当前数组大小的位置上时，数组就会重新计算其长度值，即长度值</div><div class="t m0 x0 h5 y10b fff fs2 fc0 sc0 ls8 ws1">等于最后一项的索引加1，如下面的例子所示： </div><div class="t m0 x0 hb y10c ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y10d ff10 fs6 fc0 sc0 ls21 wsb">var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];     // 创建一个包含3个字符串的数组 </div><div class="t m0 x0 h15 y10e ff11 fs6 fc0 sc0 ls21 wsb">colors[99] = &quot;black&quot;;                     //</div><div class="t m2 x4 h15 y10f ff11 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 h16 y10f ff15 fs6 fc0 sc1 ls31 ws24">（在位置99）添加一种颜色 </div><div class="t m0 x0 h15 y110 ff11 fs6 fc0 sc0 ls21 ws43">alert(colors.length); // 100 </div><div class="t m0 x0 hb y111 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y112 ff12 fs2 fc0 sc0 ls8 wsb">ArrayTypeExample06.htm </div><div class="t m0 x0 h5 y113 fff fs2 fc0 sc0 ls8 ws1">在这个例子中，我们向colors数组的位置99插入了一个值，结果数组新长度（length）就是100</div><div class="t m0 x0 hc y114 fff fs2 fc0 sc0 ls8">（99+1）。而位置3到位置98实际上都是不存在的，所以访问它们都将返回undefined。 </div><div class="t m0 x1 h5 y115 ff9 fs2 fc0 sc0 ls8 ws14">数组最多可以包含4 294 967 295个项，这几乎已经能够满足任何编程需求了。如</div><div class="t m0 x0 ha y116 ff9 fs2 fc0 sc0 ls8 ws14">果想添加的项数超过这个上限值，就会发生异常。而创建一个初始大小与这个上限值</div><div class="t m0 x0 h5 y117 ff9 fs2 fc0 sc0 ls8 ws14">接近的数组，则可能会导致运行时间超长的脚本错误。 </div><div class="t m0 x0 h20 y118 ffe fs3 fc0 sc0 ls4d ws40">5.2.1 检测数组 </div><div class="t m0 x0 h5 y119 fff fs2 fc0 sc0 ls8 ws1">自从ECMAScript 3做出规定以后，就出现了确定某个对象是不是数组的经典问题。对于一个网页，</div><div class="t m0 x0 hc y11a fff fs2 fc0 sc0 ls8 ws1">或者一个全局作用域而言，使用instanceof操作符就能得到满意的结果： </div><div class="t m0 x0 hb y11b ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y11c ff10 fs6 fc0 sc0 ls21 wsb">if (value instanceof Array){  </div><div class="t m0 x0 h16 y11d ff10 fs6 fc0 sc0 ls21 wsb">    //对数组执行某些操作 </div><div class="t m0 x0 hb y11e ff10 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y11f ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y120 ff10 fs1 fc0 sc0 ls9 ws2">instanceof操作符的问题在于，它假定只有一个全局执行环境。如果网页中包含多个框架，那实</div><div class="t m0 x0 h1e y121 fff fs2 fc0 sc0 ls8 ws1">际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的Array构造函数。如果你从</div><div class="t m0 x0 h4 y122 fff fs2 fc0 sc0 ls8 ws1">一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自</div><div class="t m0 x0 h5 y123 fff fs2 fc0 sc0 ls8 ws1">不同的构造函数。 </div><div class="t m0 x0 h5 y124 fff fs2 fc0 sc0 ls8 ws1">为了解决这个问题，ECMAScript 5新增了Array.isArray()方法。这个方法的目的是最终确定某</div><div class="t m0 x0 h5 y125 fff fs2 fc0 sc0 ls8 ws1">个值到底是不是数组，而不管它是在哪个全局执行环境中创建的。这个方法的用法如下。 </div><div class="t m0 x0 hb y126 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y127 ff10 fs6 fc0 sc0 ls21 wsb">if (Array.isArray(value)){ </div><div class="t m0 x0 h16 y128 ff10 fs6 fc0 sc0 ls21 wsb">    //对数组执行某些操作 </div><div class="t m0 x0 hb y129 ff10 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y12a ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y12b fff fs2 fc0 sc0 ls8 ws1">支持Array.isArray()方法的浏览器有IE9+、Firefox 4+、Safari 5+、Opera 10.5+和Chrome。要</div><div class="t m0 x0 h5 y12c fff fs2 fc0 sc0 ls8 ws1">在尚未实现这个方法中的浏览器中准确检测数组，请参考22.1.1节。 </div></div></div>
<div id="pf6b" class="pf w0 h0" data-page-no="6b"><div class="pc pc6b w0 h0"><div class="t m0 x2 h2 y1 ff8 fs0 fc0 sc0 ls10 wsc">5.2 Array类型   89 </div><div class="t m0 x0 h3 y2 ff8 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffa fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ffa fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffa fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffa fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffa fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffa fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffa fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffa fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffa fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffa fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffa fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffa fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ffa fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h20 y12d ffe fs3 fc0 sc0 ls4d ws40">5.2.2 转换方法 </div><div class="t m0 x0 h4 y12e fff fs2 fc0 sc0 ls8 ws1">如前所述，所有对象都具有toLocaleString()、toString()和valueOf()方法。其中，调用</div><div class="t m0 x0 h4 y12f fff fs2 fc0 sc0 ls8 ws1">数组的toString()方法会返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。而</div><div class="t m0 x0 h1e y130 fff fs2 fc0 sc0 ls8 ws1">调用valueOf()返回的还是数组。实际上，为了创建这个字符串会调用数组每一项的toString()方</div><div class="t m0 x0 h5 y131 fff fs2 fc0 sc0 ls8 ws1">法。来看下面这个例子。 </div><div class="t m0 x1 hb y132 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y133 ff10 fs6 fc0 sc0 ls21 wsb">var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];    // 创建一个包含3个字符串的数组 </div><div class="t m0 x0 h15 y134 ff11 fs6 fc0 sc0 ls21 wsb">alert(colors.toString());     // red,blue,green </div><div class="t m0 x0 h15 y135 ff11 fs6 fc0 sc0 ls21 wsb">alert(colors.valueOf());      // red,blue,green </div><div class="t m0 x0 h15 y136 ff11 fs6 fc0 sc0 ls21 wsb">alert(colors);                // red,blue,green </div><div class="t m0 x1 hb y137 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y138 ff12 fs2 fc0 sc0 ls8 wsb">ArrayTypeExample07.htm </div><div class="t m0 x0 h4 y139 fff fs2 fc0 sc0 ls8 ws1">在这里，我们首先显式地调用了toString()方法，以便返回数组的字符串表示，每个值的字符串</div><div class="t m0 x0 h1e y13a fff fs2 fc0 sc0 ls6 ws6">表示拼接成了一个字符串，中间以逗号分隔。接着调用valueOf()方法，而最后一行代码直接将数组</div><div class="t m0 x0 h4 y13b fff fs2 fc0 sc0 ls8 ws1">传递给了alert()。由于alert()要接收字符串参数，所以它会在后台调用toString()方法，由此</div><div class="t m0 x0 hc y13c fff fs2 fc0 sc0 ls8 ws1">会得到与直接调用toString()方法相同的结果。 </div><div class="t m0 x0 h1e y13d fff fs2 fc0 sc0 ls8 ws1">另外，toLocaleString()方法经常也会返回与toString()和valueOf()方法相同的值，但也</div><div class="t m0 x0 h1e y13e fff fs2 fc0 sc0 ls6 ws6">不总是如此。当调用数组的toLocaleString()方法时，它也会创建一个数组值的以逗号分隔的字符</div><div class="t m0 x0 h4 y13f fff fs2 fc0 sc0 ls8 ws1">串。而与前两个方法唯一的不同之处在于，这一次为了取得每一项的值，调用的是每一项的toLocale- </div><div class="t m0 x0 h21 y140 ff10 fs1 fc0 sc0 ls9 ws2">String()方法，而不是toString()方法。请看下面这个例子。 </div><div class="t m0 x1 hb y141 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y142 ff10 fs6 fc0 sc0 ls21 wsb">var person1 = { </div><div class="t m0 x0 hb y143 ff10 fs6 fc0 sc0 ls21 wsb">    toLocaleString : function () { </div><div class="t m0 x0 hb y144 ff10 fs6 fc0 sc0 ls21 wsb">        return &quot;Nikolaos&quot;; </div><div class="t m0 x0 hb y145 ff10 fs6 fc0 sc0 ls21 wsb">    }, </div><div class="t m0 x0 hb y146 ff10 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 hb y147 ff10 fs6 fc0 sc0 ls21 wsb">    toString : function() { </div><div class="t m0 x0 hb y148 ff10 fs6 fc0 sc0 ls21 wsb">        return &quot;Nicholas&quot;; </div><div class="t m0 x0 hb y149 ff10 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y14a ff10 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y14b ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y14c ff10 fs6 fc0 sc0 ls21 wsb">var person2 = { </div><div class="t m0 x0 hb y14d ff10 fs6 fc0 sc0 ls21 wsb">    toLocaleString : function () { </div><div class="t m0 x0 hb y14e ff10 fs6 fc0 sc0 ls21 wsb">        return &quot;Grigorios&quot;; </div><div class="t m0 x0 hb y14f ff10 fs6 fc0 sc0 ls21 wsb">    }, </div><div class="t m0 x0 hb y150 ff10 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 hb y151 ff10 fs6 fc0 sc0 ls21 wsb">    toString : function() { </div><div class="t m0 x0 hb y152 ff10 fs6 fc0 sc0 ls21 wsb">        return &quot;Greg&quot;; </div><div class="t m0 x0 hb y153 ff10 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y154 ff10 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y155 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y156 ff10 fs6 fc0 sc0 ls21 wsb">var people = [person1, person2]; </div><div class="t m0 x0 hb y157 ff10 fs6 fc0 sc0 ls21 wsb">alert(people);                        //Nicholas,Greg </div><div class="t m0 x0 hb y158 ff10 fs6 fc0 sc0 ls21 wsb">alert(people.toString());              //Nicholas,Greg </div><div class="t m0 x0 hb y159 ff10 fs6 fc0 sc0 ls21 wsb">alert(people.toLocaleString());        //Nikolaos,Grigorios </div><div class="t m0 x1 hb y15a ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y15b ff12 fs2 fc0 sc0 ls8 wsb">ArrayTypeExample08.htm </div></div></div>
<div id="pf6c" class="pf w0 h0" data-page-no="6c"><div class="pc pc6c w0 h0"><div class="t m0 x0 h2 y1 ff8 fs0 fc0 sc0 ls7 ws0">90  第5章 引用类型 </div><div class="t m0 x0 h3 y2 ff8 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 fff fs2 fc0 sc0 ls42 ws30">我们在这里定义了两个对象：person1和person2。而且还分别为每个对象定义了一个toString()</div><div class="t m0 x0 h4 y4 fff fs2 fc0 sc0 ls6 ws6">方法和一个toLocaleString()方法，这两个方法返回不同的值。然后，创建一个包含前面定义的两</div><div class="t m0 x0 h1e y5 fff fs2 fc0 sc0 ls8 ws1">个对象的数组。在将数组传递给alert()时，输出结果是&quot;Nicholas,Greg&quot;，因为调用了数组每一项</div><div class="t m0 x0 h4 yd9 fff fs2 fc0 sc0 ls53">的toString()方法（同样，这与下一行显式调用toString()方法得到的结果相同）。而当调用数组</div><div class="t m0 x0 h1e y15d fff fs2 fc0 sc0 ls54">的toLocaleString()方法时，输出结果是&quot;Nikolaos,Grigorios&quot;，原因是调用了数组每一项的</div><div class="t m0 x0 h5 y8 ff10 fs1 fc0 sc0 ls9 ws2">toLocaleString()方法。 </div><div class="t m0 x0 h1e y15e fff fs2 fc0 sc0 ls5c ws4a">数组继承的toLocaleString()、toString()和valueOf()方法，在默认情况下都会以逗号分隔的字</div><div class="t m0 x0 h1e y15f fff fs2 fc0 sc0 ls5c ws4a">符串的形式返回数组项。而如果使用join()方法，则可以使用不同的分隔符来构建这个字符串。join()方</div><div class="t m0 x0 h5 yb fff fs2 fc0 sc0 ls5c ws4a">法只接收一个参数，即用作分隔符的字符串，然后返回包含所有数组项的字符串。请看下面的例子： </div><div class="t m0 x0 hb y160 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y161 ff10 fs6 fc0 sc0 ls21 wsb">var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]; </div><div class="t m0 x0 hb y162 ff10 fs6 fc0 sc0 ls21 wsb">alert(colors.join(&quot;,&quot;));       //red,green,blue </div><div class="t m0 x0 hb y163 ff10 fs6 fc0 sc0 ls21 wsb">alert(colors.join(&quot;||&quot;));      //red||green||blue </div><div class="t m0 x0 hb y164 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y165 ff12 fs2 fc0 sc0 ls5e wsb">ArrayTypeJoinExample01.htm </div><div class="t m0 x0 h4 y166 fff fs2 fc0 sc0 ls8 ws1">在这里，我们使用join()方法重现了toString()方法的输出。在传递逗号的情况下，得到了以</div><div class="t m0 x0 h4 y167 fff fs2 fc0 sc0 ls4c ws3e">逗号分隔的数组值。而在最后一行代码中，我们传递了双竖线符号，结果就得到了字符串&quot;red|| </div><div class="t m0 x0 h4 y168 ff10 fs1 fc0 sc0 ls9 ws2">green||blue&quot;。如果不给join()方法传入任何值，或者给它传入undefined，则使用逗号作为分隔</div><div class="t m0 x0 hc y169 fff fs2 fc0 sc0 ls8">符。IE7及更早版本会错误的使用字符串&quot;undefined&quot;作为分隔符。 </div><div class="t m0 x1 ha y16a ff9 fs2 fc0 sc0 ls57 ws4d">如果数组中的某一项的值是null或者 undefined，那么该值在join()、</div><div class="t m0 x0 h5 y16b ff10 fs1 fc0 sc0 ls20 ws16">toLocaleString()、toString()和valueOf()方法返回的结果中以空字符串表示。 </div><div class="t m0 x0 h20 y16c ffe fs3 fc0 sc0 ls4d ws40">5.2.3 栈方法 </div><div class="t m0 x0 h5 y16d ff8 fs2 fc0 sc0 ls1a ws1c">ECMAScript数组也提供了一种让数组的行为类似于其他数据结构的方法。具体说来，数组可以表</div><div class="t m0 x0 h5 y16e fff fs2 fc0 sc0 ls6 ws6">现得就像栈一样，后者是一种可以限制插入和删除项的数据结构。栈是一种LIFO（Last-In-First-Out，</div><div class="t m0 x0 h4 y16f fff fs2 fc0 sc0 ls8 ws1">后进先出）的数据结构，也就是最新添加的项最早被移除。而栈中项的插入（叫做推入）和移除（叫做</div><div class="t m0 x0 h5 y170 ffc fs2 fc0 sc0 ls8">弹出），只发生在一个位置——栈的顶部。ECMAScript为数组专门提供了push()和pop()方法，以便</div><div class="t m0 x0 h5 y171 fff fs2 fc0 sc0 ls8 ws1">实现类似栈的行为。 </div><div class="t m0 x0 h4 y172 ff10 fs1 fc0 sc0 ls43 ws31">push()方法可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。而</div><div class="t m0 x0 h5 y173 ff10 fs1 fc0 sc0 ls43 ws31">pop()方法则从数组末尾移除最后一项，减少数组的length值，然后返回移除的项。请看下面的例子： </div><div class="t m0 x0 hb y174 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y175 ff10 fs6 fc0 sc0 ls21 wsb">var colors = new Array();                  // 创建一个数组 </div><div class="t m0 x0 h16 y176 ff10 fs6 fc0 sc0 ls21 wsb">var count = colors.push(&quot;red&quot;, &quot;green&quot;);   // 推入两项 </div><div class="t m0 x0 hb y177 ff10 fs6 fc0 sc0 ls21 ws50">alert(count);  //2 </div><div class="t m0 x0 hb y178 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y179 ff10 fs6 fc0 sc0 ls21 wsb">count = colors.push(&quot;black&quot;);              // 推入另一项 </div><div class="t m0 x0 hb y17a ff10 fs6 fc0 sc0 ls21 wsb">alert(count);     //3 </div><div class="t m0 x0 hb y17b ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y17c ff10 fs6 fc0 sc0 ls21 wsb">var item = colors.pop();                  // 取得最后一项 </div><div class="t m0 x0 hb y17d ff10 fs6 fc0 sc0 ls21 wsb">alert(item);      //&quot;black&quot; </div><div class="t m0 x0 hb y17e ff10 fs6 fc0 sc0 ls21 wsb">alert(colors.length);   //2 </div><div class="t m0 x0 hb y17f ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y180 ff12 fs2 fc0 sc0 ls8 wsb">ArrayTypeExample09.htm </div></div></div>
<div id="pf6d" class="pf w0 h0" data-page-no="6d"><div class="pc pc6d w0 h0"><div class="t m0 x2 h2 y1 ff8 fs0 fc0 sc0 ls10 wsc">5.2 Array类型   91 </div><div class="t m0 x0 h3 y2 ff8 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffa fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ffa fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffa fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffa fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffa fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffa fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffa fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffa fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffa fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffa fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffa fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffa fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ffa fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h4 y3 fff fs2 fc0 sc0 ls8 ws1">以上代码中的数组可以看成是栈（代码本身没有任何区别，而push()和pop()都是数组默认的方</div><div class="t m0 x0 h1e y4d fff fs2 fc0 sc0 ls8 ws1">法）。首先，我们使用push()将两个字符串推入数组的末尾，并将返回的结果保存在变量count中（值</div><div class="t m0 x0 hc y5 fff fs2 fc0 sc0 ls61">为2）。然后，再推入一个值，而结果仍然保存在count中。因为此时数组中包含3项，所以push()</div><div class="t m0 x0 h5 yd9 fff fs2 fc0 sc0 ls8 ws1">返回3。在调用pop()时，它会返回数组的最后一项，即字符串&quot;black&quot;。此后，数组中仅剩两项。 </div><div class="t m0 x0 h5 y15d fff fs2 fc0 sc0 ls8 ws1">可以将栈方法与其他数组方法连用，像下面这个例子一样。 </div><div class="t m0 x1 hb y181 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y182 ff10 fs6 fc0 sc0 ls21 wsb">var colors = [&quot;red&quot;, &quot;blue&quot;]; </div><div class="t m0 x0 h16 y183 ff10 fs6 fc0 sc0 ls21 wsb">colors.push(&quot;brown&quot;);               // 添加另一项 </div><div class="t m0 x0 h16 y184 ff10 fs6 fc0 sc0 ls21 wsb">colors[3] = &quot;black&quot;;                // 添加一项 </div><div class="t m0 x0 hb y185 ff10 fs6 fc0 sc0 ls21 wsb">alert(colors.length);   // 4 </div><div class="t m0 x0 hb y186 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y187 ff10 fs6 fc0 sc0 ls21 wsb">var item = colors.pop();            // 取得最后一项 </div><div class="t m0 x0 hb y188 ff10 fs6 fc0 sc0 ls21 wsb">alert(item);  //&quot;black&quot; </div><div class="t m0 x1 hb y189 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y18a ff12 fs2 fc0 sc0 ls8 wsb">ArrayTypeExample10.htm </div><div class="t m0 x0 h4 y18b fff fs2 fc0 sc0 ls8 ws1">在此，我们首先用两个值来初始化一个数组。然后，使用push()添加第三个值，再通过直接在位</div><div class="t m0 x0 h5 y18c fff fs2 fc0 sc0 ls3b">置3上赋值来添加第四个值。而在调用pop()时，该方法返回了字符串&quot;black&quot;，即最后一个添加到数</div><div class="t m0 x0 h5 y18d fff fs2 fc0 sc0 ls8">组的值。 </div><div class="t m0 x0 h20 y18e ffe fs3 fc0 sc0 ls4d ws40">5.2.4 队列方法 </div><div class="t m0 x0 h5 y18f fff fs2 fc0 sc0 ls8 ws1">栈数据结构的访问规则是LIFO（后进先出），而队列数据结构的访问规则是FIFO（First-In-First-Out，</div><div class="t m0 x0 h1e y190 fff fs2 fc0 sc0 ls8 ws1">先进先出）。队列在列表的末端添加项，从列表的前端移除项。由于push()是向数组末端添加项的方法，</div><div class="t m0 x0 h1e y191 fff fs2 fc0 sc0 ls8 ws1">因此要模拟队列只需一个从数组前端取得项的方法。实现这一操作的数组方法就是shift()，它能够移</div><div class="t m0 x0 h5 y192 fff fs2 fc0 sc0 ls8 ws1">除数组中的第一个项并返回该项，同时将数组长度减1。结合使用shift()和push()方法，可以像使</div><div class="t m0 x0 h5 y193 fff fs2 fc0 sc0 ls8 ws1">用队列一样使用数组。 </div><div class="t m0 x1 hb y194 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y195 ff10 fs6 fc0 sc0 ls21 wsb">var colors = new Array();                   //创建一个数组 </div><div class="t m0 x0 h16 y196 ff10 fs6 fc0 sc0 ls21 wsb">var count = colors.push(&quot;red&quot;, &quot;green&quot;);    //推入两项 </div><div class="t m0 x0 hb y197 ff10 fs6 fc0 sc0 ls21 ws50">alert(count);  //2 </div><div class="t m0 x0 hb y198 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y199 ff10 fs6 fc0 sc0 ls21 wsb">count = colors.push(&quot;black&quot;);               //推入另一项 </div><div class="t m0 x0 hb y19a ff10 fs6 fc0 sc0 ls21 wsb">alert(count);     //3 </div><div class="t m0 x0 hb y19b ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y19c ff11 fs6 fc0 sc0 ls21 wsb">var item = colors.shift();                  //取得第一项 </div><div class="t m0 x0 hb y19d ff10 fs6 fc0 sc0 ls21 wsb">alert(item);      //&quot;red&quot; </div><div class="t m0 x0 hb y19e ff10 fs6 fc0 sc0 ls21 ws43">alert(colors.length); //2 </div><div class="t m0 x2 hf y19f ff12 fs2 fc0 sc0 ls25 wsb">ArrayTypeExample11.htm </div><div class="t m0 x0 h5 y1a0 fff fs2 fc0 sc0 ls5 ws4">这个例子首先使用push()方法创建了一个包含3种颜色名称的数组。代码中加粗的那一行使用</div><div class="t m0 x0 h4 y1a1 ff10 fs1 fc0 sc0 ls9 ws2">shift()方法从数组中取得了第一项，即&quot;red&quot;。在移除第一项之后，&quot;green&quot;就变成了第一项，而</div><div class="t m0 x0 h5 y1a2 ff10 fs1 fc0 sc0 ls9 ws2">&quot;black&quot;则变成了第二项，数组也只包含两项了。 </div><div class="t m0 x0 h5 y1a3 ff8 fs2 fc0 sc0 ls1a ws1c">ECMAScript还为数组提供了一个unshift()方法。顾名思义，unshift()与shift()的用途相反：</div><div class="t m0 x0 h4 y1a4 fff fs2 fc0 sc0 ls8 ws1">它能在数组前端添加任意个项并返回新数组的长度。因此，同时使用unshift()和pop()方法，可以</div><div class="t m0 x0 h5 y1a5 fff fs2 fc0 sc0 ls8 ws1">从相反的方向来模拟队列，即在数组的前端添加项，从数组末端移除项，如下面的例子所示。 </div><div class="t m0 x1 hb y1a6 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1a7 ff10 fs6 fc0 sc0 ls21 wsb">var colors = new Array();                     //创建一个数组 </div><div class="t m0 x0 h16 y1a8 ff11 fs6 fc0 sc0 ls21 wsb">var count = colors.unshift(&quot;red&quot;, &quot;green&quot;);      //推入两项 </div><div class="t m0 x0 hb y1a9 ff10 fs6 fc0 sc0 ls21 wsb">alert(count);   //2 </div></div></div>
<div id="pf6e" class="pf w0 h0" data-page-no="6e"><div class="pc pc6e w0 h0"><div class="t m0 x0 h2 y1 ff8 fs0 fc0 sc0 ls7 ws0">92  第5章 引用类型 </div><div class="t m0 x0 h3 y2 ff8 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y7a ff11 fs6 fc0 sc0 ls21 wsb">count = colors.unshift(&quot;black&quot;);                //推入另一项 </div><div class="t m0 x0 hb y7b ff10 fs6 fc0 sc0 ls21 wsb">alert(count);   //3 </div><div class="t m0 x0 h15 y7c ff11 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y7d ff11 fs6 fc0 sc0 ls21 wsb">var item = colors.pop();                       //取得最后一项 </div><div class="t m0 x0 hb y7e ff10 fs6 fc0 sc0 ls21 wsb">alert(item);    //&quot;green&quot; </div><div class="t m0 x0 hb y7f ff10 fs6 fc0 sc0 ls21 wsb">alert(colors.length); //2 </div><div class="t m0 x0 hb y1ab ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1ac ff12 fs2 fc0 sc0 ls8 wsb">ArrayTypeExample12.htm </div><div class="t m0 x0 h5 y1ad fff fs2 fc0 sc0 ls8 ws1">这个例子创建了一个数组并使用unshift()方法先后推入了3个值。首先是&quot;red&quot;和&quot;green&quot;，然</div><div class="t m0 x0 h1e y1ae fff fs2 fc0 sc0 ls8 ws1">后是&quot;black&quot;，数组中各项的顺序为&quot;black&quot;、&quot;red&quot;、&quot;green&quot;。在调用pop()方法时，移除并返回</div><div class="t m0 x0 h5 y1af fff fs2 fc0 sc0 ls8 ws1">的是最后一项，即&quot;green&quot;。 </div><div class="t m0 x1 h5 y1b0 ff8 fs2 fc0 sc0 ls2a ws21">IE7及更早版本对JavaScript的实现中存在一个偏差，其unshift()方法总是返</div><div class="t m0 x0 h18 y1b1 ff9 fs2 fc0 sc0 ls68">回undefined而不是数组的新长度。IE8在非兼容模式下会返回正确的长度值。 </div><div class="t m0 x0 h20 y1b2 ffe fs3 fc0 sc0 ls4d ws40">5.2.5 重排序方法 </div><div class="t m0 x0 h4 y1b3 fff fs2 fc0 sc0 ls30 ws2a">数组中已经存在两个可以直接用来重排序的方法：reverse()和sort()。有读者可能猜到了，</div><div class="t m0 x0 h5 y1b4 ff10 fs1 fc0 sc0 ls9 ws2">reverse()方法会反转数组项的顺序。请看下面这个例子。 </div><div class="t m0 x0 hb y1b5 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1b6 ff10 fs6 fc0 sc0 ls21 wsb">var values = [1, 2, 3, 4, 5]; </div><div class="t m0 x0 hb y1b7 ff10 fs6 fc0 sc0 ls21 wsb">values.reverse(); </div><div class="t m0 x0 hb y1b8 ff10 fs6 fc0 sc0 ls21 wsb">alert(values);        //5,4,3,2,1 </div><div class="t m0 x0 hb y1b9 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1ba ff12 fs2 fc0 sc0 ls8 wsb">ArrayTypeExample13.htm </div><div class="t m0 x0 h5 y1bb fff fs2 fc0 sc0 ls8 ws1">这里数组的初始值及顺序是1、2、3、4、5。而调用数组的reverse()方法后，其值的顺序变成了</div><div class="t m0 x0 hc y1bc ff8 fs2 fc0 sc0 ls8">5、4、3、2、1。这个方法的作用相当直观明了，但不够灵活，因此才有了sort()方法。 </div><div class="t m0 x0 h1e y1bd fff fs2 fc0 sc0 ls8 ws1">在默认情况下，sort()方法按升序排列数组项——即最小的值位于最前面，最大的值排在最后面。</div><div class="t m0 x0 h1e y1be fff fs2 fc0 sc0 ls6 ws6">为了实现排序，sort()方法会调用每个数组项的toString()转型方法，然后比较得到的字符串，以</div><div class="t m0 x0 hc y1bf fff fs2 fc0 sc0 ls8 ws1">确定如何排序。即使数组中的每一项都是数值，sort()方法比较的也是字符串，如下所示。 </div><div class="t m0 x0 hb y1c0 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1c1 ff10 fs6 fc0 sc0 ls21 wsb">var values = [0, 1, 5, 10, 15]; </div><div class="t m0 x0 hb y1c2 ff10 fs6 fc0 sc0 ls21 wsb">values.sort(); </div><div class="t m0 x0 hb y1c3 ff10 fs6 fc0 sc0 ls21 wsb">alert(values);   //0,1,10,15,5 </div><div class="t m0 x0 hb y1c4 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1c5 ff12 fs2 fc0 sc0 ls8 wsb">ArrayTypeExample14.htm </div><div class="t m0 x0 h4 y1c6 fff fs2 fc0 sc0 ls8 ws1">可见，即使例子中值的顺序没有问题，但sort()方法也会根据测试字符串的结果改变原来的顺序。</div><div class="t m0 x0 h5 y1c7 fff fs2 fc0 sc0 ls8 ws1">因为数值5虽然小于10，但在进行字符串比较时，&quot;10&quot;则位于&quot;5&quot;的前面，于是数组的顺序就被修改了。</div><div class="t m0 x0 h1e y1c8 fff fs2 fc0 sc0 ls8 ws1">不用说，这种排序方式在很多情况下都不是最佳方案。因此sort()方法可以接收一个比较函数作为参</div><div class="t m0 x0 h5 y1c9 fff fs2 fc0 sc0 ls8 ws1">数，以便我们指定哪个值位于哪个值的前面。 </div><div class="t m0 x0 h4 y1ca fff fs2 fc0 sc0 ls8 ws1">比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等</div><div class="t m0 x0 h5 y1cb fff fs2 fc0 sc0 ls8 ws1">则返回0，如果第一个参数应该位于第二个之后则返回一个正数。以下就是一个简单的比较函数： </div><div class="t m0 x0 hb y1cc ff10 fs6 fc0 sc0 ls8 wsb">  </div></div></div>
<div id="pf6f" class="pf w0 h0" data-page-no="6f"><div class="pc pc6f w0 h0"><div class="t m0 x2 h2 y1 ff8 fs0 fc0 sc0 ls10 wsc">5.2 Array类型   93 </div><div class="t m0 x0 h3 y2 ff8 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffa fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ffa fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffa fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffa fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffa fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffa fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffa fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffa fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffa fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffa fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffa fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffa fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ffa fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y79 ff10 fs6 fc0 sc0 ls21 wsb">function compare(value1, value2) { </div><div class="t m0 x0 hb y7a ff10 fs6 fc0 sc0 ls21 wsb">    if (value1 &lt; value2) { </div><div class="t m0 x0 hb y7b ff10 fs6 fc0 sc0 ls21 wsb">        return -1; </div><div class="t m0 x0 hb y7c ff10 fs6 fc0 sc0 ls21 wsb">    } else if (value1 &gt; value2) { </div><div class="t m0 x0 hb y7d ff10 fs6 fc0 sc0 ls21 wsb">        return 1; </div><div class="t m0 x0 hb y7e ff10 fs6 fc0 sc0 ls21 wsb">    } else { </div><div class="t m0 x0 hb y7f ff10 fs6 fc0 sc0 ls21 wsb">        return 0; </div><div class="t m0 x0 hb y80 ff10 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y81 ff10 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x2 hf y1cd ff12 fs2 fc0 sc0 ls8 wsb">ArrayTypeExample15.htm </div><div class="t m0 x0 h4 y1ce fff fs2 fc0 sc0 ls8 ws1">这个比较函数可以适用于大多数数据类型，只要将其作为参数传递给sort()方法即可，如下面这</div><div class="t m0 x0 h5 y1cf fff fs2 fc0 sc0 ls8 ws1">个例子所示。 </div><div class="t m0 x1 hb y1d0 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1d1 ff10 fs6 fc0 sc0 ls21 wsb">var values = [0, 1, 5, 10, 15]; </div><div class="t m0 x0 h24 y1d2 ff11 fs6 fc0 sc0 ls21 ws34">values.sort(compare); </div><div class="t m0 x0 hb y1d3 ff10 fs6 fc0 sc0 ls21 wsb">alert(values);  //0,1,5,10,15 </div><div class="t m0 x1 hb y1d4 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1d5 fff fs2 fc0 sc0 ls8 ws1">在将比较函数传递到sort()方法之后，数值仍然保持了正确的升序。当然，也可以通过比较函数</div><div class="t m0 x0 h5 y1d6 fff fs2 fc0 sc0 ls8 ws1">产生降序排序的结果，只要交换比较函数返回的值即可。 </div><div class="t m0 x1 hb y1d7 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1d8 ff10 fs6 fc0 sc0 ls21 wsb">function compare(value1, value2) { </div><div class="t m0 x0 hb y1d9 ff10 fs6 fc0 sc0 ls21 wsb">    if (value1 &lt; value2) { </div><div class="t m0 x0 h15 y1da ff11 fs6 fc0 sc0 ls21 wsb">        return 1; </div><div class="t m0 x0 hb y1db ff10 fs6 fc0 sc0 ls21 wsb">    } else if (value1 &gt; value2) { </div><div class="t m0 x0 h15 y1dc ff11 fs6 fc0 sc0 ls21 wsb">        return -1; </div><div class="t m0 x0 hb y1dd ff10 fs6 fc0 sc0 ls21 wsb">    } else { </div><div class="t m0 x0 hb y1de ff10 fs6 fc0 sc0 ls21 wsb">        return 0; </div><div class="t m0 x0 hb y1df ff10 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y1e0 ff10 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y1e1 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1e2 ff10 fs6 fc0 sc0 ls21 wsb">var values = [0, 1, 5, 10, 15]; </div><div class="t m0 x0 hb y1e3 ff10 fs6 fc0 sc0 ls21 wsb">values.sort(compare); </div><div class="t m0 x0 hb y1e4 ff10 fs6 fc0 sc0 ls21 wsb">alert(values);    // 15,10,5,1,0 </div><div class="t m0 x1 hb y1e5 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1e6 ff12 fs2 fc0 sc0 ls8 wsb">ArrayTypeExample16.htm </div><div class="t m0 x0 h5 y1e7 fff fs2 fc0 sc0 ls8 ws1">在这个修改后的例子中，比较函数在第一个值应该位于第二个之后的情况下返回1，而在第一个值</div><div class="t m0 x0 h25 y1e8 fff fs2 fc0 sc0 ls8 ws1">应该在第二个之前的情况下返回1。交换返回值的意思是让更大的值排位更靠前，也就是对数组按照降</div><div class="t m0 x0 hc y1e9 fff fs2 fc0 sc0 ls8 ws1">序排序。当然，如果只想反转数组原来的顺序，使用reverse()方法要更快一些。 </div><div class="t m0 x1 h5 y1ea ff10 fs1 fc0 sc0 ls9 ws2">reverse()和sort()方法的返回值是经过排序之后的数组。 </div><div class="t m0 x0 h4 y1eb fff fs2 fc0 sc0 ls6 ws6">对于数值类型或者其valueOf()方法会返回数值类型的对象类型，可以使用一个更简单的比较函</div><div class="t m0 x0 h5 y1ec fff fs2 fc0 sc0 ls8 ws1">数。这个函数只要用第二个值减第一个值即可。 </div><div class="t m0 x1 hb y1ed ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1ee ff10 fs6 fc0 sc0 ls21 wsb">function compare(value1, value2){ </div><div class="t m0 x0 hb y1ef ff10 fs6 fc0 sc0 ls21 wsb">    return value2 - value1; </div><div class="t m0 x0 hb y1f0 ff10 fs6 fc0 sc0 ls21 wsb">}  </div></div></div>
<div id="pf70" class="pf w0 h0" data-page-no="70"><div class="pc pc70 w0 h0"><div class="t m0 x0 h2 y1 ff8 fs0 fc0 sc0 ls7 ws0">94  第5章 引用类型 </div><div class="t m0 x0 h3 y2 ff8 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 fff fs2 fc0 sc0 ls8 ws1">由于比较函数通过返回一个小于零、等于零或大于零的值来影响排序结果，因此减法操作就可以适</div><div class="t m0 x0 h5 y4d fff fs2 fc0 sc0 ls8 ws1">当地处理所有这些情况。 </div><div class="t m0 x0 h20 y1f2 ffe fs3 fc0 sc0 ls4d ws40">5.2.6 操作方法 </div><div class="t m0 x0 h5 y1f3 ff8 fs2 fc0 sc0 ls1a ws1c">ECMAScript为操作已经包含在数组中的项提供了很多方法。其中，concat()方法可以基于当前数</div><div class="t m0 x0 h4 y1f4 fff fs2 fc0 sc0 ls8 ws1">组中的所有项创建一个新数组。具体来说，这个方法会先创建当前数组一个副本，然后将接收到的参数</div><div class="t m0 x0 h1e y1f5 fff fs2 fc0 sc0 ls8 ws1">添加到这个副本的末尾，最后返回新构建的数组。在没有给concat()方法传递参数的情况下，它只是</div><div class="t m0 x0 h1e y1f6 fff fs2 fc0 sc0 ls8 ws1">复制当前数组并返回副本。如果传递给concat()方法的是一或多个数组，则该方法会将这些数组中的</div><div class="t m0 x0 h4 y1f7 fff fs2 fc0 sc0 ls8 ws1">每一项都添加到结果数组中。如果传递的值不是数组，这些值就会被简单地添加到结果数组的末尾。下</div><div class="t m0 x0 h5 y1f8 fff fs2 fc0 sc0 ls8 ws1">面来看一个例子。 </div><div class="t m0 x0 hb y1f9 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1fa ff10 fs6 fc0 sc0 ls21 wsb">var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]; </div><div class="t m0 x0 hb y1fb ff10 fs6 fc0 sc0 ls21 wsb">var colors2 = colors.concat(&quot;yellow&quot;, [&quot;black&quot;, &quot;brown&quot;]); </div><div class="t m0 x0 hb y1fc ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1fd ff10 fs6 fc0 sc0 ls21 wsb">alert(colors);     //red,green,blue         </div><div class="t m0 x0 hb y1fe ff10 fs6 fc0 sc0 ls21 wsb">alert(colors2);    //red,green,blue,yellow,black,brown </div><div class="t m0 x0 hb y1ff ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y200 ff12 fs2 fc0 sc0 ls8 wsb">ArrayTypeConcatExample01.htm </div><div class="t m0 x0 h5 y201 fff fs2 fc0 sc0 ls8 ws1">以上代码开始定义了一个包含3个值的数组colors。然后，基于colors调用了concat()方法，</div><div class="t m0 x0 h4 y202 fff fs2 fc0 sc0 ls6 ws6">并传入字符串&quot;yellow&quot;和一个包含&quot;black&quot;和&quot;brown&quot;的数组。最终，结果数组colors2中包含了</div><div class="t m0 x0 h4 y203 ff10 fs1 fc0 sc0 ls9 ws2">&quot;red&quot;、&quot;green&quot;、&quot;blue&quot;、&quot;yellow&quot;、&quot;black&quot;和&quot;brown&quot;。至于原来的数组colors，其值仍然</div><div class="t m0 x0 h5 y204 fff fs2 fc0 sc0 ls8 ws1">保持不变。 </div><div class="t m0 x0 h1c y205 fff fs2 fc0 sc0 ls8 ws1">下一个方法是slice()，它能够基于当前数组中的一或多个项创建一个新数组。slice()方法可以</div><div class="t m0 x0 h4 y206 fff fs2 fc0 sc0 ls8 ws1">接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下，slice()方法返回从该</div><div class="t m0 x0 h4 y207 fff fs2 fc0 sc0 ls8 ws1">参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项—</div><div class="t m0 x0 he y208 fff fs2 fc0 sc0 ls8 ws1">—但不包括结束位置的项。注意，slice()方法不会影响原始数组。请看下面的例子。 </div><div class="t m0 x0 hb y209 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y20a ff10 fs6 fc0 sc0 ls21 wsb">var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;purple&quot;]; </div><div class="t m0 x0 hb y20b ff10 fs6 fc0 sc0 ls21 wsb">var colors2 = colors.slice(1); </div><div class="t m0 x0 hb y20c ff10 fs6 fc0 sc0 ls21 wsb">var colors3 = colors.slice(1,4); </div><div class="t m0 x0 hb y20d ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y20e ff10 fs6 fc0 sc0 ls21 wsb">alert(colors2);   //green,blue,yellow,purple </div><div class="t m0 x0 hb y20f ff10 fs6 fc0 sc0 ls21 wsb">alert(colors3);   //green,blue,yellow </div><div class="t m0 x0 hb y210 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y211 ff12 fs2 fc0 sc0 ls25 wsb">ArrayTypeSliceExample01.htm </div><div class="t m0 x0 h5 y212 fff fs2 fc0 sc0 ls8 ws1">在这个例子中，开始定义的数组colors包含5项。调用slice()并传入1会得到一个包含 4项的</div><div class="t m0 x0 h5 y213 fff fs2 fc0 sc0 ls8 ws1">新数组；因为是从位置1开始复制，所以会包含&quot;green&quot;而不会包含&quot;red&quot;。这个新数组colors2中</div><div class="t m0 x0 hc y214 fff fs2 fc0 sc0 ls8 ws1">包含的是&quot;green&quot;、&quot;blue&quot;、&quot;yellow&quot;和&quot;purple&quot;。接着，我们再次调用slice()并传入了1和4，</div><div class="t m0 x0 hc y215 fff fs2 fc0 sc0 ls8 ws1">表示复制从位置1开始，到位置3结束。结果数组colors3中包含了&quot;green&quot;、&quot;blue&quot;和&quot;yellow&quot;。 </div><div class="t m0 x1 ha y216 ff9 fs2 fc0 sc0 ls8 ws14">如果slice()方法的参数中有一个负数，则用数组长度加上该数来确定相应的位</div><div class="t m0 x0 h5 y217 ff9 fs2 fc0 sc0 ls8 ws14">置。例如，在一个包含5项的数组上调用slice(-2,-1)与调用slice(3,4)得到的</div><div class="t m0 x0 h5 y218 ff9 fs2 fc0 sc0 ls8 ws14">结果相同。如果结束位置小于起始位置，则返回空数组。 </div></div></div>
<div id="pf71" class="pf w0 h0" data-page-no="71"><div class="pc pc71 w0 h0"><div class="t m0 x2 h2 y1 ff8 fs0 fc0 sc0 ls10 wsc">5.2 Array类型   95 </div><div class="t m0 x0 h3 y2 ff8 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffa fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ffa fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffa fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffa fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffa fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffa fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffa fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffa fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffa fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffa fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffa fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffa fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ffa fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h4 y3 fff fs2 fc0 sc0 ls24 ws1e">下面我们来介绍splice()方法，这个方法恐怕要算是最强大的数组方法了，它有很多种用法。</div><div class="t m0 x0 h5 y4 ff10 fs1 fc0 sc0 ls9 ws2">splice()的主要用途是向数组的中部插入项，但使用这种方法的方式则有如下3种。 </div><div class="t m0 x0 h5 y4e ffd fs1 fc0 sc0 ls2"> 删除：可以删除任意数量的项，只需指定2个参数：要删除的第一项的位置和要删除的项数。</div><div class="t m0 x5 h5 yd9 fff fs2 fc0 sc0 ls8 ws1">例如，splice(0,2)会删除数组中的前两项。 </div><div class="t m0 x0 h5 y219 ffd fs1 fc0 sc0 ls2"> 插入：可以向指定位置插入任意数量的项，只需提供3个参数：起始位置、0（要删除的项数）</div><div class="t m0 x5 h4 y21a fff fs2 fc0 sc0 ls6f ws54">和要插入的项。如果要插入多个项，可以再传入第四、第五，以至任意多个项。例如，</div><div class="t m0 x5 h5 y9 ff10 fs1 fc0 sc0 ls9 ws2">splice(2,0,&quot;red&quot;,&quot;green&quot;)会从当前数组的位置2开始插入字符串&quot;red&quot;和&quot;green&quot;。 </div><div class="t m0 x0 h5 ya ffd fs1 fc0 sc0 ls2"> 替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定3个参数：起</div><div class="t m0 x5 h4 yb fff fs2 fc0 sc0 ls5 ws4">始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如，</div><div class="t m0 x5 h5 yc ff10 fs1 fc0 sc0 ls9 wsb">splice (2,1,&quot;red&quot;,&quot;green&quot;)会删除当前数组位置2的项，然后再从位置2开始插入字符串</div><div class="t m0 x5 h5 yd ff10 fs1 fc0 sc0 ls20 ws16">&quot;red&quot;和&quot;green&quot;。 </div><div class="t m0 x0 h4 y21b ff10 fs1 fc0 sc0 ls9 ws2">splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项（如果没有删除任何</div><div class="t m0 x0 h5 y21c fff fs2 fc0 sc0 ls8 ws1">项，则返回一个空数组）。下面的代码展示了上述3种使用splice()方法的方式。 </div><div class="t m0 x5 hb y21d ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y21e ff10 fs6 fc0 sc0 ls21 wsb">var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]; </div><div class="t m0 x0 h16 y21f ff10 fs6 fc0 sc0 ls21 wsb">var removed = colors.splice(0,1);                 // 删除第一项 </div><div class="t m0 x0 hb y220 ff10 fs6 fc0 sc0 ls21 wsb">alert(colors);     // green,blue </div><div class="t m0 x0 h16 y221 ff10 fs6 fc0 sc0 ls21 wsb">alert(removed);    // red，返回的数组中只包含一项 </div><div class="t m0 x0 hb y222 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y223 ff10 fs6 fc0 sc0 ls21 wsb">removed = colors.splice(1, 0, &quot;yellow&quot;, &quot;orange&quot;);   // 从位置1开始插入两项 </div><div class="t m0 x0 hb y224 ff10 fs6 fc0 sc0 ls21 wsb">alert(colors);     // green,yellow,orange,blue </div><div class="t m0 x0 h16 y225 ff10 fs6 fc0 sc0 ls21 wsb">alert(removed);    // 返回的是一个空数组 </div><div class="t m0 x0 hb y226 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y227 ff10 fs6 fc0 sc0 ls21 wsb">removed = colors.splice(1, 1, &quot;red&quot;, &quot;purple&quot;);      // 插入两项，删除一项 </div><div class="t m0 x0 hb y228 ff10 fs6 fc0 sc0 ls21 wsb">alert(colors);     // green,red,purple,orange,blue </div><div class="t m0 x0 h16 y229 ff10 fs6 fc0 sc0 ls21 wsb">alert(removed);    // yellow，返回的数组中只包含一项 </div><div class="t m0 x5 hb y22a ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y22b ff12 fs2 fc0 sc0 ls25 wsb">ArrayTypeSpliceExample01.htm </div><div class="t m0 x0 h5 y22c fff fs2 fc0 sc0 ls5c ws4a">上面的例子首先定义了一个包含3项的数组colors。第一次调用splice()方法只是删除了这个数组的</div><div class="t m0 x0 hc y22d fff fs2 fc0 sc0 ls5c ws4a">第一项，之后colors还包含&quot;green&quot;和&quot;blue&quot;两项。第二次调用splice()方法时在位置1插入了两项，</div><div class="t m0 x0 h1e y22e fff fs2 fc0 sc0 ls75 ws56">结果colors中包含&quot;green&quot;、&quot;yellow&quot;、&quot;orange&quot;和&quot;blue&quot;。这一次操作没有删除项，因此返回了一个</div><div class="t m0 x0 h5 y22f fff fs2 fc0 sc0 ls5c ws4a">空数组。最后一次调用splice()方法删除了位置1处的一项，然后又插入了&quot;red&quot;和&quot;purple&quot;。在完成以</div><div class="t m0 x0 hc y230 fff fs2 fc0 sc0 ls5c ws4a">上操作之后，数组colors中包含的是&quot;green&quot;、&quot;red&quot;、&quot;purple&quot;、&quot;orange&quot;和&quot;blue&quot;。 </div><div class="t m0 x0 h20 y231 ffe fs3 fc0 sc0 ls4d ws40">5.2.7 位置方法 </div><div class="t m0 x0 h5 y232 ff8 fs2 fc0 sc0 ls25 ws57">ECMAScript 5为数组实例添加了两个位置方法：indexOf()和lastIndexOf()。这两个方法都接收</div><div class="t m0 x0 h1e y233 fff fs2 fc0 sc0 ls8 ws1">两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中，indexOf()方法从数组的开头（位</div><div class="t m0 x0 h5 y234 fff fs2 fc0 sc0 ls3b">置0）开始向后查找，lastIndexOf()方法则从数组的末尾开始向前查找。 </div><div class="t m0 x0 h25 y235 fff fs2 fc0 sc0 ls8 ws1">这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回1。在比较第一个参数</div><div class="t m0 x0 h5 y236 fff fs2 fc0 sc0 ls8 ws1">与数组中的每一项时，会使用全等操作符；也就是说，要求查找的项必须严格相等（就像使用===一样）。</div><div class="t m0 x0 h5 y237 fff fs2 fc0 sc0 ls8 ws1">以下是几个例子。 </div><div class="t m0 x0 hb y238 ff10 fs6 fc0 sc0 ls21 wsb">var numbers = [1,2,3,4,5,4,3,2,1]; </div><div class="t m0 x0 hb y239 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y23a ff10 fs6 fc0 sc0 ls21 wsb">alert(numbers.indexOf(4));        //3 </div></div></div>
<div id="pf72" class="pf w0 h0" data-page-no="72"><div class="pc pc72 w0 h0"><div class="t m0 x0 h2 y1 ff8 fs0 fc0 sc0 ls7 ws0">96  第5章 引用类型 </div><div class="t m0 x0 h3 y2 ff8 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 ff10 fs6 fc0 sc0 ls21 wsb">alert(numbers.lastIndexOf(4));    //5 </div><div class="t m0 x0 hb y7a ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y7b ff10 fs6 fc0 sc0 ls21 wsb">alert(numbers.indexOf(4, 4));     //5 </div><div class="t m0 x0 hb y7c ff10 fs6 fc0 sc0 ls21 wsb">alert(numbers.lastIndexOf(4, 4)); //3 </div><div class="t m0 x0 hb y7d ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y7e ff10 fs6 fc0 sc0 ls21 wsb">var person = { name: &quot;Nicholas&quot; }; </div><div class="t m0 x0 hb y7f ff10 fs6 fc0 sc0 ls21 wsb">var people = [{ name: &quot;Nicholas&quot; }]; </div><div class="t m0 x0 h5 y23c ff8 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y23d ff10 fs6 fc0 sc0 ls21 wsb">var morePeople = [person]; </div><div class="t m0 x0 hb y23e ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y23f ff10 fs6 fc0 sc0 ls21 wsb">alert(people.indexOf(person));     //-1 </div><div class="t m0 x0 hb y240 ff10 fs6 fc0 sc0 ls21 wsb">alert(morePeople.indexOf(person)); //0 </div><div class="t m0 x0 hb y241 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y242 ff12 fs2 fc0 sc0 ls8 wsb">ArrayIndexOfExample01.htm </div><div class="t m0 x0 h4 y243 fff fs2 fc0 sc0 ls8 ws1">使用indexOf()和lastIndexOf()方法查找特定项在数组中的位置非常简单，支持它们的浏览器包</div><div class="t m0 x0 h5 y244 fff fs2 fc0 sc0 ls3b">括IE9+、Firefox 2+、Safari 3+、Opera 9.5+和Chrome。 </div><div class="t m0 x0 h20 y245 ffe fs3 fc0 sc0 ls4d ws40">5.2.8 迭代方法 </div><div class="t m0 x0 h5 y246 ff8 fs2 fc0 sc0 ls25 ws57">ECMAScript 5为数组定义了5个迭代方法。每个方法都接收两个参数：要在每一项上运行的函数和</div><div class="t m0 x0 h4 y247 fff fs2 fc0 sc0 ls8 ws1">（可选的）运行该函数的作用域对象——影响this的值。传入这些方法中的函数会接收三个参数：数</div><div class="t m0 x0 h4 y248 fff fs2 fc0 sc0 ls8 ws1">组项的值、该项在数组中的位置和数组对象本身。根据使用的方法不同，这个函数执行后的返回值可能</div><div class="t m0 x0 h5 y249 fff fs2 fc0 sc0 ls8 ws1">会也可能不会影响方法的返回值。以下是这5个迭代方法的作用。 </div><div class="t m0 x0 h5 y24a ffd fs1 fc0 sc0 ls2"> every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true。 </div><div class="t m0 x0 h5 y24b ffd fs1 fc0 sc0 ls2"> filter()：对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组。 </div><div class="t m0 x0 h5 y24c ffd fs1 fc0 sc0 ls2"> forEach()：对数组中的每一项运行给定函数。这个方法没有返回值。 </div><div class="t m0 x0 h5 y24d ffd fs1 fc0 sc0 ls2"> map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。 </div><div class="t m0 x0 h5 y24e ffd fs1 fc0 sc0 ls2"> some()：对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true。 </div><div class="t m0 x0 h5 y24f fff fs2 fc0 sc0 ls8 ws1">以上方法都不会修改数组中的包含的值。 </div><div class="t m0 x0 h1e y250 fff fs2 fc0 sc0 ls5 ws4">在这些方法中，最相似的是every()和some()，它们都用于查询数组中的项是否满足某个条件。</div><div class="t m0 x0 h1e y251 fff fs2 fc0 sc0 ls78">对every()来说，传入的函数必须对每一项都返回true，这个方法才返回true；否则，它就返回</div><div class="t m0 x0 h4 y252 ff10 fs1 fc0 sc0 ls16 ws17">false。而some()方法则是只要传入的函数对数组中的某一项返回true，就会返回true。请看以下</div><div class="t m0 x0 h5 y253 fff fs2 fc0 sc0 ls5">例子。 </div><div class="t m0 x0 hb y254 ff10 fs6 fc0 sc0 ls21 wsb">var numbers = [1,2,3,4,5,4,3,2,1]; </div><div class="t m0 x0 hb y255 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y256 ff10 fs6 fc0 sc0 ls21 wsb">var everyResult = numbers.every(function(item, index, array){ </div><div class="t m0 x0 hb y257 ff10 fs6 fc0 sc0 ls21 wsb">    return (item &gt; 2);  </div><div class="t m0 x0 hb y258 ff10 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 hb y259 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y25a ff10 fs6 fc0 sc0 ls21 wsb">alert(everyResult);    //false </div><div class="t m0 x0 hb y25b ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y25c ff10 fs6 fc0 sc0 ls21 wsb">var someResult = numbers.some(function(item, index, array){ </div><div class="t m0 x0 hb y25d ff10 fs6 fc0 sc0 ls21 wsb">    return (item &gt; 2); </div><div class="t m0 x0 hb y25e ff10 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 hb y25f ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y260 ff10 fs6 fc0 sc0 ls21 wsb">alert(someResult);     //true </div><div class="t m0 x0 hb y261 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf y262 ff12 fs2 fc0 sc0 ls79 wsb">ArrayEveryAndSomeExample01.htm </div></div></div>
<div id="pf73" class="pf w0 h0" data-page-no="73"><div class="pc pc73 w0 h0"><div class="t m0 x2 h2 y1 ff8 fs0 fc0 sc0 ls10 wsc">5.2 Array类型   97 </div><div class="t m0 x0 h3 y2 ff8 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffa fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ffa fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffa fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffa fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffa fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffa fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffa fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffa fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffa fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffa fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffa fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffa fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ffa fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 fff fs2 fc0 sc0 ls8 ws1">以上代码调用了every()和some()，传入的函数只要给定项大于2就会返回true。对于every()，</div><div class="t m0 x0 h1e y4d fff fs2 fc0 sc0 ls8 ws1">它返回的是false，因为只有部分数组项符合条件。对于some()，结果就是true，因为至少有一项</div><div class="t m0 x0 h5 y5 fff fs2 fc0 sc0 ls8 ws1">是大于2的。 </div><div class="t m0 x0 h1e y6 fff fs2 fc0 sc0 ls8 ws1">下面再看一看filter()函数，它利用指定的函数确定是否在返回的数组中包含某一项。例如，要</div><div class="t m0 x0 h5 y15d fff fs2 fc0 sc0 ls8 ws1">返回一个所有数值都大于2的数组，可以使用以下代码。 </div><div class="t m0 x0 hb y263 ff10 fs6 fc0 sc0 ls21 wsb">var numbers = [1,2,3,4,5,4,3,2,1]; </div><div class="t m0 x0 hb y264 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y265 ff10 fs6 fc0 sc0 ls21 wsb">var filterResult = numbers.filter(function(item, index, array){ </div><div class="t m0 x0 hb y266 ff10 fs6 fc0 sc0 ls21 wsb">    return (item &gt; 2); </div><div class="t m0 x0 hb y267 ff10 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 hb y268 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y269 ff10 fs6 fc0 sc0 ls21 ws5f">alert(filterResult);  //[3,4,5,4,3] </div><div class="t m0 x0 hb y26a ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y26b ff12 fs2 fc0 sc0 ls81 wsb">ArrayFilterExample01.htm </div><div class="t m0 x0 h5 y26c fff fs2 fc0 sc0 ls8 ws1">这里，通过调用filter()方法创建并返回了包含3、4、5、4、3的数组，因为传入的函数对它们</div><div class="t m0 x0 hc y26d fff fs2 fc0 sc0 ls8 ws1">每一项都返回true。这个方法对查询符合某些条件的所有数组项非常有用。 </div><div class="t m0 x0 h4 y26e ff10 fs1 fc0 sc0 ls9 ws2">map()也返回一个数组，而这个数组的每一项都是在原始数组中的对应项上运行传入函数的结果。</div><div class="t m0 x0 h5 y26f fff fs2 fc0 sc0 ls8 ws1">例如，可以给数组中的每一项乘以2，然后返回这些乘积组成的数组，如下所示。 </div><div class="t m0 x0 hb y270 ff10 fs6 fc0 sc0 ls21 wsb">var numbers = [1,2,3,4,5,4,3,2,1]; </div><div class="t m0 x0 hb y271 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y272 ff10 fs6 fc0 sc0 ls21 wsb">var mapResult = numbers.map(function(item, index, array){ </div><div class="t m0 x0 hb y273 ff10 fs6 fc0 sc0 ls21 wsb">    return item * 2; </div><div class="t m0 x0 hb y274 ff10 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 hb y275 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y276 ff10 fs6 fc0 sc0 ls21 wsb">alert(mapResult);  //[2,4,6,8,10,8,6,4,2] </div><div class="t m0 x0 hb y277 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y278 ff12 fs2 fc0 sc0 ls1b wsb">ArrayMapExample01.htm </div><div class="t m0 x0 h5 y279 fff fs2 fc0 sc0 ls8 ws1">以上代码返回的数组中包含给每个数乘以2之后的结果。这个方法适合创建包含的项与另一个数组</div><div class="t m0 x0 h5 y27a fff fs2 fc0 sc0 ls8 ws1">一一对应的数组。 </div><div class="t m0 x0 h1e y27b fff fs2 fc0 sc0 ls6 ws6">最后一个方法是forEach()，它只是对数组中的每一项运行传入的函数。这个方法没有返回值，</div><div class="t m0 x0 hc y27c fff fs2 fc0 sc0 ls8 ws1">本质上与使用for循环迭代数组一样。来看一个例子。 </div><div class="t m0 x0 hb y27d ff10 fs6 fc0 sc0 ls21 wsb">var numbers = [1,2,3,4,5,4,3,2,1]; </div><div class="t m0 x0 hb y27e ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y27f ff10 fs6 fc0 sc0 ls21 wsb">numbers.forEach(function(item, index, array){ </div><div class="t m0 x0 h16 y280 ff10 fs6 fc0 sc0 ls21 wsb">    //执行某些操作  </div><div class="t m0 x0 hb y281 ff10 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 h28 y282 ff10 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y283 fff fs2 fc0 sc0 ls8 ws1">这些数组方法通过执行不同的操作，可以大大方便处理数组的任务。支持这些迭代方法的浏览器有</div><div class="t m0 x0 h5 y284 ff8 fs2 fc0 sc0 ls46 ws37">IE9+、Firefox 2+、Safari 3+、Opera 9.5+和Chrome。 </div><div class="t m0 x0 h20 y285 ffe fs3 fc0 sc0 ls4d ws40">5.2.9 归并方法 </div><div class="t m0 x0 h5 y286 ff8 fs2 fc0 sc0 ls25 ws61">ECMAScript 5还新增了两个归并数组的方法：reduce()和reduceRight()。这两个方法都会迭</div><div class="t m0 x0 h1e y287 fff fs2 fc0 sc0 ls6 ws6">代数组的所有项，然后构建一个最终返回的值。其中，reduce()方法从数组的第一项开始，逐个遍历</div><div class="t m0 x0 hc y288 fff fs2 fc0 sc0 ls8 ws1">到最后。而reduceRight()则从数组的最后一项开始，向前遍历到第一项。 </div><div class="t m0 x0 h4 y289 fff fs2 fc0 sc0 ls8 ws1">这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。传</div></div></div>
<div id="pf74" class="pf w0 h0" data-page-no="74"><div class="pc pc74 w0 h0"><div class="t m0 x0 h2 y1 ff8 fs0 fc0 sc0 ls7 ws0">98  第5章 引用类型 </div><div class="t m0 x0 h3 y2 ff8 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 fff fs2 fc0 sc0 ls82">给reduce()和reduceRight()的函数接收4个参数：前一个值、当前值、项的索引和数组对象。这</div><div class="t m0 x0 h4 y4d fff fs2 fc0 sc0 ls8 ws1">个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第</div><div class="t m0 x0 h5 yd8 fff fs2 fc0 sc0 ls8 ws1">一个参数是数组的第一项，第二个参数就是数组的第二项。 </div><div class="t m0 x0 he y28b fff fs2 fc0 sc0 ls8 ws1">使用reduce()方法可以执行求数组中所有值之和的操作，比如： </div><div class="t m0 x0 hb y28c ff10 fs6 fc0 sc0 ls21 wsb">var values = [1,2,3,4,5]; </div><div class="t m0 x0 hb y28d ff10 fs6 fc0 sc0 ls21 wsb">var sum = values.reduce(function(prev, cur, index, array){ </div><div class="t m0 x0 hb y28e ff10 fs6 fc0 sc0 ls21 wsb">    return prev + cur;  </div><div class="t m0 x0 hb y28f ff10 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 hb y290 ff10 fs6 fc0 sc0 ls21 wsb">alert(sum); //15 </div><div class="t m0 x0 hb y291 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y292 ff12 fs2 fc0 sc0 ls25 wsb">ArrayReductionExample01.htm </div><div class="t m0 x0 h5 y293 fff fs2 fc0 sc0 ls8 ws1">第一次执行回调函数，prev是1，cur是2。第二次，prev是3（1加2的结果），cur是3（数组</div><div class="t m0 x0 h5 y294 fff fs2 fc0 sc0 ls8 ws1">的第三项）。这个过程会持续到把数组中的每一项都访问一遍，最后返回结果。 </div><div class="t m0 x0 h5 y295 ff10 fs1 fc0 sc0 ls9 ws2">reduceRight()的作用类似，只不过方向相反而已。来看下面这个例子。 </div><div class="t m0 x0 h28 y296 ff10 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y297 ff10 fs6 fc0 sc0 ls21 wsb">var values = [1,2,3,4,5]; </div><div class="t m0 x0 hb y298 ff10 fs6 fc0 sc0 ls21 wsb">var sum = values.reduceRight(function(prev, cur, index, array){ </div><div class="t m0 x0 hb y299 ff10 fs6 fc0 sc0 ls21 wsb">    return prev + cur; </div><div class="t m0 x0 hb y29a ff10 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 hb y29b ff10 fs6 fc0 sc0 ls21 wsb">alert(sum); //15 </div><div class="t m0 x0 h5 y29c ff8 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h2a y29d fff fs2 fc0 sc0 ls8 ws1">在这个例子中，第一次执行回调函数，prev是5，cur是4。当然，最终结果相同，因为执行的都</div><div class="t m0 x0 h5 y29e fff fs2 fc0 sc0 ls8 ws1">是简单相加的操作。 </div><div class="t m0 x0 h1c y29f fff fs2 fc0 sc0 ls8 ws1">使用reduce()还是reduceRight()，主要取决于要从哪头开始遍历数组。除此之外，它们完全</div><div class="t m0 x0 h5 y2a0 fff fs2 fc0 sc0 ls8">相同。 </div><div class="t m0 x0 h5 y2a1 fff fs2 fc0 sc0 ls8 ws1">支持这两个归并函数的浏览器有IE9+、Firefox 3+、Safari 4+、Opera 10.5和Chrome。 </div><div class="t m0 x0 hd y2a2 ffe fs7 fc0 sc0 ls22">5.3 Date类型 </div><div class="t m0 x0 h5 y2a3 ff8 fs2 fc0 sc0 ls1a ws1c">ECMAScript中的Date类型是在早期Java 中的java.util.Date类基础上构建的。为此，Date</div><div class="t m0 x0 h5 y2a4 fff fs2 fc0 sc0 ls8 ws1">类型使用自UTC（Coordinated Universal Time，国际协调时间）1970年1月1日午夜（零时）开始经过</div><div class="t m0 x0 hc y2a5 fff fs2 fc0 sc0 ls8 ws1">的毫秒数来保存日期。在使用这种数据存储格式的条件下，Date类型保存的日期能够精确到1970年1</div><div class="t m0 x0 h5 y2a6 fff fs2 fc0 sc0 ls3b">月1日之前或之后的285 616年。 </div><div class="t m0 x0 hc y2a7 fff fs2 fc0 sc0 ls8 ws1">要创建一个日期对象，使用new操作符和Date构造函数即可，如下所示。 </div><div class="t m0 x0 hb y2a8 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2a9 ff10 fs6 fc0 sc0 ls21 wsb">var now = new Date(); </div><div class="t m0 x0 hb y2aa ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y2ab ff12 fs2 fc0 sc0 ls1b wsb">DateTypeExample01.htm </div><div class="t m0 x0 h4 y2ac fff fs2 fc0 sc0 ls8 ws1">在调用Date构造函数而不传递参数的情况下，新创建的对象自动获得当前日期和时间。如果想根</div><div class="t m0 x0 h5 y2ad fff fs2 fc0 sc0 ls8 ws1">据特定的日期和时间创建日期对象，必须传入表示该日期的毫秒数（即从UTC时间1970年1月1日午</div><div class="t m0 x0 h5 y2ae fff fs2 fc0 sc0 ls1f ws15">夜起至该日期止经过的毫秒数）。为了简化这一计算过程，ECMAScript提供了两个方法：Date.parse()</div><div class="t m0 x0 h5 y2af fff fs2 fc0 sc0 ls2c">和Date.UTC()。 </div><div class="t m0 x0 h4 y2b0 fff fs2 fc0 sc0 ls8 ws1">其中，Date.parse()方法接收一个表示日期的字符串参数，然后尝试根据这个字符串返回相应日</div><div class="t m0 x0 h5 y2b1 fff fs2 fc0 sc0 ls8 ws1">期的毫秒数。ECMA-262没有定义Date.parse()应该支持哪种日期格式，因此这个方法的行为因实现</div><div class="t m0 x0 h5 y2b2 fff fs2 fc0 sc0 ls8 ws1">而异，而且通常是因地区而异。将地区设置为美国的浏览器通常都接受下列日期格式： </div></div></div>
<div id="pf75" class="pf w0 h0" data-page-no="75"><div class="pc pc75 w0 h0"><div class="t m0 x2 h2 y1 ff8 fs0 fc0 sc0 ls10 wsc">5.3 Date类型   99 </div><div class="t m0 x0 h3 y2 ff8 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffa fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ffa fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffa fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffa fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffa fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffa fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffa fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffa fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffa fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffa fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffa fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffa fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ffa fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ffd fs1 fc0 sc0 ls2"> “月/日/年”，如6/13/2004； </div><div class="t m0 x0 h5 y4 ffd fs1 fc0 sc0 ls2"> “英文月名 日,年”，如January 12,2004； </div><div class="t m0 x0 h5 y4e ffd fs1 fc0 sc0 ls2"> “英文星期几 英文月名 日 年 时:分:秒 时区”，如Tue May 25 2004 00:00:00 GMT-0700。 </div><div class="t m0 x0 h5 yd9 ffd fs1 fc0 sc0 ls2"> ISO 8601扩展格式YYYY-MM-DDTHH:mm:ss.sssZ（例如 2004-05-25T00:00:00）。只有兼容</div><div class="t m0 x5 h5 y15d ff8 fs2 fc0 sc0 ls79 ws73">ECMAScript 5的实现支持这种格式。 </div><div class="t m0 x0 h5 y2b3 fff fs2 fc0 sc0 ls8 ws1">例如，要为2004年5月25日创建一个日期对象，可以使用下面的代码： </div><div class="t m0 x5 hb y2b4 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2b5 ff10 fs6 fc0 sc0 ls21 wsb">var someDate = new Date(Date.parse(&quot;May 25, 2004&quot;)); </div><div class="t m0 x0 hb y2b6 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y2b7 ff12 fs2 fc0 sc0 ls1b wsb">DateTypeExample01.htm </div><div class="t m0 x0 h4 y2b8 fff fs2 fc0 sc0 ls8 ws1">如果传入Date.parse()方法的字符串不能表示日期，那么它会返回NaN。实际上，如果直接将表</div><div class="t m0 x0 h4 y2b9 fff fs2 fc0 sc0 ls8 ws1">示日期的字符串传递给Date构造函数，也会在后台调用Date.parse()。换句话说，下面的代码与前</div><div class="t m0 x0 h5 y2ba fff fs2 fc0 sc0 ls8 ws1">面的例子是等价的： </div><div class="t m0 x5 hb y2bb ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2f ff10 fs6 fc0 sc0 ls21 wsb">var someDate = new Date(&quot;May 25, 2004&quot;); </div><div class="t m0 x5 hb y2bc ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y2bd fff fs2 fc0 sc0 ls8 ws1">这行代码将会得到与前面相同的日期对象。 </div><div class="t m0 x5 ha y2be ff9 fs2 fc0 sc0 ls8 ws14">日期对象及其在不同浏览器中的实现有许多奇怪的行为。其中有一种倾向是将超</div><div class="t m0 x5 ha y2bf ff9 fs2 fc0 sc0 ls24 ws6d">出范围的值替换成当前的值，以便生成输出。例如，在解析&quot;January 32, 2007&quot;</div><div class="t m0 x5 h5 y2c0 ff9 fs2 fc0 sc0 ls8 ws14">时，有的浏览器会将其解释为&quot;February 1, 2007&quot;。而Opera则倾向于插入当前月</div><div class="t m0 x5 h18 y2c1 ff9 fs2 fc0 sc0 ls8 ws14">份的当前日期，返回&quot;January当前日期，2007&quot;。也就是说，如果在2007年9月</div><div class="t m0 x5 h5 y2c2 ff8 fs2 fc0 sc0 ls8 ws20">21日运行前面的代码，将会得到&quot;January 21, 2007&quot;（都是21日）。 </div><div class="t m0 x0 h4 y2c3 ff10 fs1 fc0 sc0 ls9 ws2">Date.UTC()方法同样也返回表示日期的毫秒数，但它与Date.parse()在构建值时使用不同的信</div><div class="t m0 x0 hc y2c4 fff fs2 fc0 sc0 ls8 ws1">息。Date.UTC()的参数分别是年份、基于0的月份（一月是0，二月是1，以此类推）、月中的哪一天</div><div class="t m0 x0 h5 y2c5 fff fs2 fc0 sc0 ls8">（1到31）、小时数（0到23）、分钟、秒以及毫秒数。在这些参数中，只有前两个参数（年和月）是必</div><div class="t m0 x0 h5 y2c6 fff fs2 fc0 sc0 ls8 ws1">需的。如果没有提供月中的天数，则假设天数为1；如果省略其他参数，则统统假设为0。以下是两个</div><div class="t m0 x0 he y2c7 fff fs2 fc0 sc0 ls8 ws1">使用Date.UTC()方法的例子： </div><div class="t m0 x5 hb y2c8 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2c9 ff10 fs6 fc0 sc0 ls21 wsb">// GMT时间2000年1月1日午夜零时 </div><div class="t m0 x0 hb y2ca ff10 fs6 fc0 sc0 ls21 wsb">var y2k = new Date(Date.UTC(2000, 0)); </div><div class="t m0 x0 hb y2cb ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2cc ff10 fs6 fc0 sc0 ls21 wsb">// GMT时间2005年5月5日下午5:55:55 </div><div class="t m0 x0 hb y2cd ff10 fs6 fc0 sc0 ls21 wsb">var allFives = new Date(Date.UTC(2005, 4, 5, 17, 55, 55)); </div><div class="t m0 x5 hb y2ce ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y2cf ff12 fs2 fc0 sc0 lsb wsb">DateTypeUTCExample01.htm </div><div class="t m0 x0 h5 y2d0 fff fs2 fc0 sc0 ls8 ws1">这个例子创建了两个日期对象。第一个对象表示GMT时间2000年1月1日午夜零时，传入的值一</div><div class="t m0 x0 h5 y2d1 fff fs2 fc0 sc0 ls8 ws1">个是表示年份的2000，一个是表示月份的0（即一月份）。因为其他参数是自动填充的（即月中的天数</div><div class="t m0 x0 h5 y2d2 fff fs2 fc0 sc0 ls8e">为1，其他所有参数均为0），所以结果就是该月第一天的午夜零时。第二个对象表示GMT时间2005</div><div class="t m0 x0 h5 y2d3 fff fs2 fc0 sc0 ls6d">年5月5日下午5:55:55，即使日期和时间中只包含5，也需要传入不一样的参数：月份必须是4（因为</div><div class="t m0 x0 h5 y2d4 fff fs2 fc0 sc0 ls8 ws1">月份是基于0的）、小时必须设置为17（因为小时以0到23表示），剩下的参数就很直观了。 </div><div class="t m0 x0 h2b y2d5 fff fs2 fc0 sc0 ls8 ws1">如同模仿Date.parse()一样，Date构造函数也会模仿Date.UTC()，但有一点明显不同：日期</div><div class="t m0 x0 h5 y2d6 fff fs2 fc0 sc0 ls8 ws1">和时间都基于本地时区而非GMT来创建。不过，Date构造函数接收的参数仍然与Date.UTC()相同。</div></div></div>
<div id="pf76" class="pf w0 h0" data-page-no="76"><div class="pc pc76 w0 h0"><div class="t m0 x0 h2 y1 ff8 fs0 fc0 sc0 ls7 ws0">100  第5章 引用类型 </div><div class="t m0 x0 h3 y2 ff8 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 fff fs2 fc0 sc0 ls8 ws1">因此，如果第一个参数是数值，Date构造函数就会假设该值是日期中的年份，而第二个参数是月份，</div><div class="t m0 x0 h5 y4d fff fs2 fc0 sc0 ls8 ws1">以此类推。据此，可以将前面的例子重写如下。 </div><div class="t m0 x0 hb y2d8 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2d9 ff10 fs6 fc0 sc0 ls21 wsb">// 本地时间2000年1月1日午夜零时 </div><div class="t m0 x0 hb y2da ff10 fs6 fc0 sc0 ls21 wsb">var y2k = new Date(2000, 0); </div><div class="t m0 x0 hb y2db ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2dc ff10 fs6 fc0 sc0 ls21 wsb">// 本地时间2005年5月5日下午5:55:55 </div><div class="t m0 x0 hb y2dd ff10 fs6 fc0 sc0 ls21 wsb">var allFives = new Date(2005, 4, 5, 17, 55, 55); </div><div class="t m0 x0 hb y2de ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf y2df ff12 fs2 fc0 sc0 ls8 wsb">DateTypeConstructorExample01.htm </div><div class="t m0 x0 h4 y2e0 fff fs2 fc0 sc0 ls8 ws1">以上代码创建了与前面例子中相同的两个日期对象，只不过这次的日期都是基于系统设置的本地时</div><div class="t m0 x0 h5 y2e1 fff fs2 fc0 sc0 ls8 ws1">区创建的。 </div><div class="t m0 x0 h5 y2e2 ff8 fs2 fc0 sc0 ls25 ws57">ECMAScript 5添加了Data.now()方法，返回表示调用这个方法时的日期和时间的毫秒数。这个方</div><div class="t m0 x0 hc y2e3 fff fs2 fc0 sc0 ls8 ws1">法简化了使用Data对象分析代码的工作。例如： </div><div class="t m0 x0 hb y2e4 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2e5 ff10 fs6 fc0 sc0 ls21">//取得开始时间 </div><div class="t m0 x0 hb y2e6 ff10 fs6 fc0 sc0 ls21 wsb">var start = Date.now(); </div><div class="t m0 x0 hb y2e7 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2e8 ff10 fs6 fc0 sc0 ls21">//调用函数 </div><div class="t m0 x0 hb y2e9 ff10 fs6 fc0 sc0 ls21 wsb">doSomething(); </div><div class="t m0 x0 hb y2ea ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2eb ff10 fs6 fc0 sc0 ls21">//取得停止时间 </div><div class="t m0 x0 hb y2ec ff10 fs6 fc0 sc0 ls21 wsb">var stop = Date.now(), </div><div class="t m0 x0 h2d y2ed ff10 fs6 fc0 sc0 ls21 wsb">    result = stop – start; </div><div class="t m0 x0 h5 y2ee ff8 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h2e y2ef fff fs2 fc0 sc0 ls8 ws1">支持Data.now()方法的浏览器包括IE9+、Firefox 3+、Safari 3+、Opera 10.5和Chrome。在不支</div><div class="t m0 x0 hc y2f0 fff fs2 fc0 sc0 ls8 ws1">持它的浏览器中，使用+操作符把Data对象转换成字符串，也可以达到同样的目的。 </div><div class="t m0 x0 hb y2f1 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2f2 ff10 fs6 fc0 sc0 ls21">//取得开始时间 </div><div class="t m0 x0 h15 y2f3 ff11 fs6 fc0 sc0 ls21 wsb">var start = +new Date(); </div><div class="t m0 x0 hb y2f4 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2f5 ff10 fs6 fc0 sc0 ls21">//调用函数 </div><div class="t m0 x0 hb y2f6 ff10 fs6 fc0 sc0 ls21 wsb">doSomething(); </div><div class="t m0 x0 h16 y2f7 ff10 fs6 fc0 sc0 ls21">//取得停止时间 </div><div class="t m0 x0 h15 y2f8 ff11 fs6 fc0 sc0 ls21 wsb">var stop = +new Date(), </div><div class="t m0 x0 hb y2f9 ff10 fs6 fc0 sc0 ls21 wsb">    result = stop - start; </div><div class="t m0 x0 hb y2fa ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h20 y2fb ffe fs3 fc0 sc0 ls4d ws40">5.3.1 继承的方法 </div><div class="t m0 x0 h4 y2fc fff fs2 fc0 sc0 ls8 ws1">与其他引用类型一样，Date类型也重写了toLocaleString()、toString()和valueOf()方法；</div><div class="t m0 x0 h4 y2fd fff fs2 fc0 sc0 ls8 ws1">但这些方法返回的值与其他类型中的方法不同。Date类型的toLocaleString()方法会按照与浏览器</div><div class="t m0 x0 h5 y2fe fff fs2 fc0 sc0 ls8 ws1">设置的地区相适应的格式返回日期和时间。这大致意味着时间格式中会包含AM或PM，但不会包含时</div><div class="t m0 x0 h1c y2ff fff fs2 fc0 sc0 ls6 ws6">区信息（当然，具体的格式会因浏览器而异）。而toString()方法则通常返回带有时区信息的日期和</div><div class="t m0 x0 h5 y300 fff fs2 fc0 sc0 ls24 ws1e">时间，其中时间一般以军用时间（即小时的范围是0到23）表示。下面给出了在不同浏览器中调用</div><div class="t m0 x0 h5 y301 ff10 fs1 fc0 sc0 ls9 ws2">toLocaleString()和toString()方法，输出PST（Pacific Standard Time，太平洋标准时间）时间2007</div><div class="t m0 x0 h5 y302 fff fs2 fc0 sc0 ls3b">年2月1日午夜零时的结果。 </div><div class="t m0 x0 h2f y303 ffe fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h2f y304 ffe fs2 fc0 sc0 ls5a ws7b">Internet Explorer 8 </div><div class="t m0 x0 h16 y305 ff10 fs6 fc0 sc0 ls21 wsb">toLocaleString() — Thursday, February 01, 2007 12:00:00 AM </div><div class="t m0 x0 h16 y306 ff10 fs6 fc0 sc0 ls21 wsb">toString() — Thu Feb 1 00:00:00 PST 2007 </div></div></div>
<div id="pf77" class="pf w0 h0" data-page-no="77"><div class="pc pc77 w0 h0"><div class="t m0 x2 h2 y1 ff8 fs0 fc0 sc0 ls10 wsc">5.3 Date类型   101 </div><div class="t m0 x0 h3 y2 ff8 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffa fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ffa fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffa fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffa fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffa fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffa fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffa fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffa fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffa fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffa fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffa fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffa fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ffa fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h2f y307 ffe fs2 fc0 sc0 ls96 ws7d">Firefox 3.5 </div><div class="t m0 x0 h16 y308 ff10 fs6 fc0 sc0 ls21 wsb">toLocaleString() — Thursday, February 01, 2007 12:00:00 AM </div><div class="t m0 x0 h16 y309 ff10 fs6 fc0 sc0 ls21 wsb">toString() — Thu Feb 01 2007 00:00:00 GMT-0800 (Pacific Standard Time) </div><div class="t m0 x0 h2f y4b ffe fs2 fc0 sc0 ls79 ws7e">Safari 4 </div><div class="t m0 x0 h16 y30a ff10 fs6 fc0 sc0 ls21 wsb">toLocaleString() — Thursday, February 01, 2007 00:00:00 </div><div class="t m0 x0 h16 y30b ff10 fs6 fc0 sc0 ls21 wsb">toString() — Thu Feb 01 2007 00:00:00 GMT-0800 (Pacific Standard Time) </div><div class="t m0 x0 h2f y30c ffe fs2 fc0 sc0 ls96 ws7d">Chrome 4 </div><div class="t m0 x0 h16 y30d ff10 fs6 fc0 sc0 ls21 wsb">toLocaleString() — Thu Feb 01 2007 00:00:00 GMT-0800 (Pacific Standard Time) </div><div class="t m0 x0 h16 y30e ff10 fs6 fc0 sc0 ls21 wsb">toString() — Thu Feb 01 2007 00:00:00 GMT-0800 (Pacific Standard Time) </div><div class="t m0 x0 h2f y30f ffe fs2 fc0 sc0 ls96 ws7d">Opera 10 </div><div class="t m0 x0 h16 y310 ff10 fs6 fc0 sc0 ls21 wsb">toLocaleString() — 2/1/2007 12:00:00 AM </div><div class="t m0 x0 h16 y311 ff10 fs6 fc0 sc0 ls21 wsb">toString() — Thu, 01 Feb 2007 00:00:00 GMT-0800 </div><div class="t m0 x0 h2f y312 ffe fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y313 fff fs2 fc0 sc0 ls97 ws7c">显然，这两个方法在不同的浏览器中返回的日期和时间格式可谓大相径庭。事实上， </div><div class="t m0 x0 h4 y2bb ff10 fs1 fc0 sc0 ls9 ws2">toLocaleString()和toString()的这一差别仅在调试代码时比较有用，而在显示日期和时间时没有</div><div class="t m0 x0 h5 y314 fff fs2 fc0 sc0 ls8 ws1">什么价值。 </div><div class="t m0 x0 h1e y315 fff fs2 fc0 sc0 ls8 ws1">至于Date类型的valueOf()方法，则根本不返回字符串，而是返回日期的毫秒表示。因此，可以</div><div class="t m0 x0 h5 y316 fff fs2 fc0 sc0 ls8 ws1">方便使用比较操作符（小于或大于）来比较日期值。请看下面的例子。 </div><div class="t m0 x5 hb y317 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y318 ff10 fs6 fc0 sc0 ls21 wsb">var date1 = new Date(2007, 0, 1);      //&quot;January 1, 2007&quot; </div><div class="t m0 x0 hb y319 ff10 fs6 fc0 sc0 ls21 wsb">var date2 = new Date(2007, 1, 1);      //&quot;February 1, 2007&quot; </div><div class="t m0 x0 hb y31a ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y31b ff10 fs6 fc0 sc0 ls21 wsb">alert(date1 &lt; date2); //true </div><div class="t m0 x0 hb y31c ff10 fs6 fc0 sc0 ls21 wsb">alert(date1 &gt; date2); //false </div><div class="t m0 x5 hb y31d ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y31e ff12 fs2 fc0 sc0 ls7a wsb">DateTypeValueOfExample01.htm </div><div class="t m0 x0 h5 y31f fff fs2 fc0 sc0 ls8 ws1">从逻辑上讲，2007年1月1日要早于2007年2月1日，此时如果我们说前者小于后者比较符合常</div><div class="t m0 x0 h5 y320 fff fs2 fc0 sc0 ls8 ws1">理。而表示2007年1月1日的毫秒值小于表示2007年2月1日的毫秒值，因此在首先使用小于操作符</div><div class="t m0 x0 he y321 fff fs2 fc0 sc0 ls8 ws1">比较日期时，返回的结果是true。这样，就为我们比较日期提供了极大方便。 </div><div class="t m0 x0 h20 y322 ffe fs3 fc0 sc0 ls4d ws40">5.3.2 日期格式化方法 </div><div class="t m0 x0 h5 y323 ff10 fs1 fc0 sc0 ls9 ws2">Date类型还有一些专门用于将日期格式化为字符串的方法，这些方法如下。 </div><div class="t m0 x0 h5 y324 ffd fs1 fc0 sc0 ls2"> toDateString()——以特定于实现的格式显示星期几、月、日和年； </div><div class="t m0 x0 h5 y325 ffd fs1 fc0 sc0 ls2"> toTimeString()——以特定于实现的格式显示时、分、秒和时区； </div><div class="t m0 x0 h5 y326 ffd fs1 fc0 sc0 ls2"> toLocaleDateString()——以特定于地区的格式显示星期几、月、日和年； </div><div class="t m0 x0 h5 y327 ffd fs1 fc0 sc0 ls2"> toLocaleTimeString()——以特定于实现的格式显示时、分、秒； </div><div class="t m0 x0 h5 y328 ffd fs1 fc0 sc0 ls2"> toUTCString()——以特定于实现的格式完整的UTC日期。 </div><div class="t m0 x0 h4 y329 fff fs2 fc0 sc0 ls9b">与toLocaleString()和toString()方法一样，以上这些字符串格式方法的输出也是因浏览器</div><div class="t m0 x0 h5 y32a fff fs2 fc0 sc0 ls8 ws1">而异的，因此没有哪一个方法能够用来在用户界面中显示一致的日期信息。 </div><div class="t m0 x5 ha y32b ff9 fs2 fc0 sc0 ls8 ws14">除了前面介绍的方法之外，还有一个名叫toGMTString()的方法，这是一个与</div><div class="t m0 x5 h5 y32c ff10 fs1 fc0 sc0 ls9 ws2">toUTCString()等价的方法，其存在目的在于确保向后兼容。不过，ECMAScript推</div><div class="t m0 x5 h18 y32d ff9 fs2 fc0 sc0 ls8 ws14">荐现在编写的代码一律使用toUTCString()方法。 </div></div></div>
<div id="pf78" class="pf w0 h0" data-page-no="78"><div class="pc pc78 w0 h0"><div class="t m0 x0 h2 y1 ff8 fs0 fc0 sc0 ls7 ws0">102  第5章 引用类型 </div><div class="t m0 x0 h3 y2 ff8 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h20 y12d ffe fs3 fc0 sc0 ls4d ws40">5.3.3 日期/时间组件方法 </div><div class="t m0 x0 h4 y12e fff fs2 fc0 sc0 ls8 ws1">到目前为止，剩下还未介绍的Date类型的方法（如下表所示），都是直接取得和设置日期值中特</div><div class="t m0 x0 h5 y12f fff fs2 fc0 sc0 ls8 ws1">定部分的方法了。需要注意的是，UTC日期指的是在没有时区偏差的情况下（将日期转换为GMT时间）</div><div class="t m0 x0 h5 y130 fff fs2 fc0 sc0 ls8 ws1">的日期值。 </div><div class="t m0 x0 hb y32f ff10 fs6 fc0 sc0 ls8 wsb">  </div><div class="t m0 x0 h31 y330 ffc fs6 fc0 sc0 lsa7 wsb">方  法 说  明 </div><div class="t m0 x0 h32 y331 ff10 fsc fc0 sc0 lsa8 wsb">getTime()  返回表示日期的毫秒数；与valueOf()方法返回的值相同 </div><div class="t m0 x0 h33 y332 ff10 fsc fc0 sc0 lsa8 ws80">setTime(毫秒)  以毫秒数设置日期，会改变整个日期 </div><div class="t m0 x0 h32 y333 ff10 fsc fc0 sc0 lsa8 wsb">getFullYear()  取得4位数的年份（如2007而非仅07） </div><div class="t m0 x0 h32 y334 ff10 fsc fc0 sc0 lsa8 wsb">getUTCFullYear()  返回UTC日期的4位数年份 </div><div class="t m0 x0 h33 y335 ff10 fsc fc0 sc0 lsa8 ws80">setFullYear(年)  设置日期的年份。传入的年份值必须是4位数字（如2007而非仅07） </div><div class="t m0 x0 h33 y336 ff10 fsc fc0 sc0 lsa8 ws80">setUTCFullYear(年)  设置UTC日期的年份。传入的年份值必须是4位数字（如2007而非仅07） </div><div class="t m0 x0 h32 y337 ff10 fsc fc0 sc0 lsa8 wsb">getMonth()  返回日期中的月份，其中0表示一月，11表示十二月 </div><div class="t m0 x0 h32 y338 ff10 fsc fc0 sc0 lsa8 wsb">getUTCMonth()  返回UTC日期中的月份，其中0表示一月，11表示十二月 </div><div class="t m0 x0 h33 y339 ff10 fsc fc0 sc0 lsa8 ws80">setMonth(月)  设置日期的月份。传入的月份值必须大于0，超过11则增加年份 </div><div class="t m0 x0 h33 y33a ff10 fsc fc0 sc0 lsa8 ws80">setUTCMonth(月)  设置UTC日期的月份。传入的月份值必须大于0，超过11则增加年份 </div><div class="t m0 x0 h32 y33b ff10 fsc fc0 sc0 lsa8 wsb">getDate()  返回日期月份中的天数（1到31） </div><div class="t m0 x0 h32 y33c ff10 fsc fc0 sc0 lsa8 wsb">getUTCDate()  返回UTC日期月份中的天数（1到31） </div><div class="t m0 x0 h33 y33d ff10 fsc fc0 sc0 lsa8 ws80">setDate(日)  设置日期月份中的天数。如果传入的值超过了该月中应有的天数，则增加月份 </div><div class="t m0 x0 h33 y33e ff10 fsc fc0 sc0 lsa8 ws80">setUTCDate(日)  设置UTC日期月份中的天数。如果传入的值超过了该月中应有的天数，则增加月份 </div><div class="t m0 x0 h32 y33f ff10 fsc fc0 sc0 lsa8 wsb">getDay()  返回日期中星期的星期几（其中0表示星期日，6表示星期六） </div><div class="t m0 x0 h32 y340 ff10 fsc fc0 sc0 lsa8 wsb">getUTCDay()  返回UTC日期中星期的星期几（其中0表示星期日，6表示星期六） </div><div class="t m0 x0 h32 y341 ff10 fsc fc0 sc0 lsa8 wsb">getHours()  返回日期中的小时数（0到23） </div><div class="t m0 x0 h32 y342 ff10 fsc fc0 sc0 lsa8 wsb">getUTCHours()  返回UTC日期中的小时数（0到23） </div><div class="t m0 x0 h33 y343 ff10 fsc fc0 sc0 lsa8 ws80">setHours(时)  设置日期中的小时数。传入的值超过了23则增加月份中的天数 </div><div class="t m0 x0 h33 y344 ff10 fsc fc0 sc0 lsa8 ws80">setUTCHours(时)  设置UTC日期中的小时数。传入的值超过了23则增加月份中的天数 </div><div class="t m0 x0 h32 y345 ff10 fsc fc0 sc0 lsa8 wsb">getMinutes()  返回日期中的分钟数（0到59） </div><div class="t m0 x0 h32 y1e8 ff10 fsc fc0 sc0 lsa8 wsb">getUTCMinutes()  返回UTC日期中的分钟数（0到59） </div><div class="t m0 x0 h33 y346 ff10 fsc fc0 sc0 lsa8 ws80">setMinutes(分)  设置日期中的分钟数。传入的值超过59则增加小时数 </div><div class="t m0 x0 h33 y347 ff10 fsc fc0 sc0 lsa8 ws80">setUTCMinutes(分)  设置UTC日期中的分钟数。传入的值超过59则增加小时数 </div><div class="t m0 x0 h32 y348 ff10 fsc fc0 sc0 lsa8 wsb">getSeconds()  返回日期中的秒数（0到59） </div><div class="t m0 x0 h32 y349 ff10 fsc fc0 sc0 lsa8 wsb">getUTCSeconds()  返回UTC日期中的秒数（0到59） </div><div class="t m0 x0 h33 y34a ff10 fsc fc0 sc0 lsa8 ws80">setSeconds(秒)  设置日期中的秒数。传入的值超过了59会增加分钟数 </div><div class="t m0 x0 h33 y34b ff10 fsc fc0 sc0 lsa8 ws80">setUTCSeconds(秒)  设置UTC日期中的秒数。传入的值超过了59会增加分钟数 </div><div class="t m0 x0 h32 y34c ff10 fsc fc0 sc0 lsa8 wsb">getMilliseconds()  返回日期中的毫秒数 </div><div class="t m0 x0 h32 y34d ff10 fsc fc0 sc0 lsa8 wsb">getUTCMilliseconds()  返回UTC日期中的毫秒数 </div><div class="t m0 x0 h33 y34e ff10 fsc fc0 sc0 lsa8 ws80">setMilliseconds(毫秒)  设置日期中的毫秒数 </div></div></div>
<div id="pf79" class="pf w0 h0" data-page-no="79"><div class="pc pc79 w0 h0"><div class="t m0 x2 h2 y1 ff8 fs0 fc0 sc0 ls10 wsc">5.4 RegExp类型   103 </div><div class="t m0 x0 h3 y2 ff8 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffa fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ffa fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffa fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffa fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffa fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffa fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffa fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffa fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffa fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffa fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffa fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffa fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ffa fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x6 h3 y34f fff fs1 fc0 sc0 ls8">（续） </div><div class="t m0 x5 h31 y350 ffc fs6 fc0 sc0 lsa7 wsb">方  法 说  明 </div><div class="t m0 x0 h34 y351 ff10 fsc fc0 sc0 lsa8 ws80">setUTCMilliseconds(毫秒)</div><div class="c x1 y352 wc h35"><div class="t m0 x0 h32 y353 ff10 fsc fc0 sc0 ls8 wsb"> </div></div><div class="t m0 x1 h36 y354 fff fs6 fc0 sc0 ls31">设置UTC日期中的毫秒数 </div><div class="t m0 x0 h32 y355 ff10 fsc fc0 sc0 lsa8 wsb">getTimezoneOffset()  返回本地时间与UTC时间相差的分钟数。例如，美国东部标准时间返回300。在某</div><div class="t m0 x1 h36 y356 fff fs6 fc0 sc0 ls8 ws33">地进入夏令时的情况下，这个值会有所变化 </div><div class="t m0 x5 hb y357 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hd y358 ffe fs7 fc0 sc0 ls22">5.4 RegExp类型 </div><div class="t m0 x0 h5 y359 ff8 fs2 fc0 sc0 ls1a ws1c">ECMAScript通过RegExp类型来支持正则表达式。使用下面类似Perl 的语法，就可以创建一个正</div><div class="t m0 x0 h5 y35a fff fs2 fc0 sc0 ls8 ws1">则表达式。 </div><div class="t m0 x5 hb y35b ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y35c ff10 fs6 fc0 sc0 ls21 wsb">var expression = / pattern / flags ; </div><div class="t m0 x5 hb y35d ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y35e fff fs2 fc0 sc0 ls8 ws1">其中的模式（pattern）部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、</div><div class="t m0 x0 h5 y35f fff fs2 fc0 sc0 ls8 ws1">向前查找以及反向引用。每个正则表达式都可带有一或多个标志（flags），用以标明正则表达式的行为。</div><div class="t m0 x0 h5 y360 fff fs2 fc0 sc0 ls8 ws1">正则表达式的匹配模式支持下列3个标志。 </div><div class="t m0 x0 h5 y361 ffd fs1 fc0 sc0 ls2"> g：表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即</div><div class="t m0 x5 h5 y362 fff fs2 fc0 sc0 ls8">停止； </div><div class="t m0 x0 h5 y363 ffd fs1 fc0 sc0 ls2"> i：表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写； </div><div class="t m0 x0 h5 y364 ffd fs1 fc0 sc0 ls2"> m：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模</div><div class="t m0 x5 h5 y365 fff fs2 fc0 sc0 ls8 ws1">式匹配的项。 </div><div class="t m0 x0 h5 y366 fff fs2 fc0 sc0 ls8 ws1">因此，一个正则表达式就是一个模式与上述3个标志的组合体。不同组合产生不同结果，如下面的</div><div class="t m0 x0 h5 y367 fff fs2 fc0 sc0 ls8 ws1">例子所示。 </div><div class="t m0 x5 hb y368 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y369 ff10 fs6 fc0 sc0 ls21 wsb">/* </div><div class="t m0 x0 h16 y36a ff10 fs6 fc0 sc0 ls21 wsb">* 匹配字符串中所有&quot;at&quot;的实例 </div><div class="t m0 x0 hb y36b ff10 fs6 fc0 sc0 ls21 wsb">*/ </div><div class="t m0 x0 hb y36c ff10 fs6 fc0 sc0 ls21 wsb">var pattern1 = /at/g; </div><div class="t m0 x0 hb y36d ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y36e ff10 fs6 fc0 sc0 ls21 wsb">/* </div><div class="t m0 x0 h16 y36f ff10 fs6 fc0 sc0 ls21 wsb">* 匹配第一个&quot;bat&quot;或&quot;cat&quot;，不区分大小写 </div><div class="t m0 x0 hb y370 ff10 fs6 fc0 sc0 ls21 wsb">*/ </div><div class="t m0 x0 hb y371 ff10 fs6 fc0 sc0 ls21 wsb">var pattern2 = /[bc]at/i; </div><div class="t m0 x0 hb y372 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y373 ff10 fs6 fc0 sc0 ls21 wsb">/* </div><div class="t m0 x0 h16 y374 ff10 fs6 fc0 sc0 ls21 wsb">* 匹配所有以&quot;at&quot;结尾的3个字符的组合，不区分大小写 </div><div class="t m0 x0 hb y375 ff10 fs6 fc0 sc0 ls21 wsb">*/ </div><div class="t m0 x0 hb y376 ff10 fs6 fc0 sc0 ls21 wsb">var pattern3 = /.at/gi; </div><div class="t m0 x5 hb y377 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y378 fff fs2 fc0 sc0 ls1f ws15">与其他语言中的正则表达式类似，模式中使用的所有元字符都必须转义。正则表达式中的元字符包括： </div><div class="t m0 x5 hb y379 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y37a ff10 fs6 fc0 sc0 ls21 wsb">( [ { \ ^ $ | ) ? * + .]} </div><div class="t m0 x5 hb y37b ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y37c fff fs2 fc0 sc0 ls8 ws1">这些元字符在正则表达式中都有一或多种特殊用途，因此如果想要匹配字符串中包含的这些字符，</div><div class="t m0 x0 h5 y37d fff fs2 fc0 sc0 ls8 ws1">就必须对它们进行转义。下面给出几个例子。 </div><div class="t m0 x5 hb y37e ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y37f ff10 fs6 fc0 sc0 ls21 wsb">/* </div><div class="t m0 x0 h16 y380 ff10 fs6 fc0 sc0 ls21 wsb">* 匹配第一个&quot;bat&quot;或&quot;cat&quot;，不区分大小写 </div><div class="t m0 x0 hb y381 ff10 fs6 fc0 sc0 ls21 wsb">*/ </div></div></div>
<div id="pf7a" class="pf w0 h0" data-page-no="7a"><div class="pc pc7a w0 h0"><div class="t m0 x0 h2 y1 ff8 fs0 fc0 sc0 ls7 ws0">104  第5章 引用类型 </div><div class="t m0 x0 h3 y2 ff8 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 ff10 fs6 fc0 sc0 ls21 wsb">var pattern1 = /[bc]at/i; </div><div class="t m0 x0 hb y7a ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y7b ff10 fs6 fc0 sc0 ls21 wsb">/* </div><div class="t m0 x0 h16 y7c ff10 fs6 fc0 sc0 ls21 wsb">* 匹配第一个&quot; [bc]at&quot;，不区分大小写 </div><div class="t m0 x0 hb y7d ff10 fs6 fc0 sc0 ls21 wsb">*/ </div><div class="t m0 x0 hb y7e ff10 fs6 fc0 sc0 ls21 wsb">var pattern2 = /\[bc\]at/i; </div><div class="t m0 x0 hb y7f ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y80 ff10 fs6 fc0 sc0 ls21 wsb">/* </div><div class="t m0 x0 h16 y81 ff10 fs6 fc0 sc0 ls21 wsb">* 匹配所有以&quot;at&quot;结尾的3个字符的组合，不区分大小写 </div><div class="t m0 x0 hb y82 ff10 fs6 fc0 sc0 ls21 wsb">*/ </div><div class="t m0 x0 hb y83 ff10 fs6 fc0 sc0 ls21 wsb">var pattern3 = /.at/gi; </div><div class="t m0 x0 hb y84 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y85 ff10 fs6 fc0 sc0 ls21 wsb">/* </div><div class="t m0 x0 h16 y86 ff10 fs6 fc0 sc0 ls21 wsb">* 匹配所有&quot;.at&quot;，不区分大小写 </div><div class="t m0 x0 hb y87 ff10 fs6 fc0 sc0 ls21 wsb">*/ </div><div class="t m0 x0 hb y88 ff10 fs6 fc0 sc0 ls21 wsb">var pattern4 = /\.at/gi; </div><div class="t m0 x0 hb y383 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y384 fff fs2 fc0 sc0 ls8 ws1">在上面的例子中，pattern1匹配第一个&quot;bat&quot;或&quot;cat&quot;，不区分大小写。而要想直接匹配&quot;[bc]at&quot;</div><div class="t m0 x0 h4 y385 fff fs2 fc0 sc0 ls8 ws1">的话，就需要像定义pattern2一样，对其中的两个方括号进行转义。对于pattern3来说，句点表示</div><div class="t m0 x0 h4 y386 fff fs2 fc0 sc0 ls8 ws1">位于&quot;at&quot;之前的任意一个可以构成匹配项的字符。但如果想匹配&quot;.at&quot;，则必须对句点本身进行转义，</div><div class="t m0 x0 hc y5b fff fs2 fc0 sc0 lsb1">如pattern4所示。 </div><div class="t m0 x0 h4 y5c fff fs2 fc0 sc0 ls24 ws1e">前面举的这些例子都是以字面量形式来定义的正则表达式。另一种创建正则表达式的方式是使用</div><div class="t m0 x0 h4 y387 ff10 fs1 fc0 sc0 ls9 ws2">RegExp构造函数，它接收两个参数：一个是要匹配的字符串模式，另一个是可选的标志字符串。可以</div><div class="t m0 x0 h5 y388 fff fs2 fc0 sc0 ls8 ws1">使用字面量定义的任何表达式，都可以使用构造函数来定义，如下面的例子所示。 </div><div class="t m0 x0 hb y389 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y38a ff10 fs6 fc0 sc0 ls21 wsb">/* </div><div class="t m0 x0 h16 y38b ff10 fs6 fc0 sc0 ls21 wsb">* 匹配第一个&quot;bat&quot;或&quot;cat&quot;，不区分大小写 </div><div class="t m0 x0 hb y38c ff10 fs6 fc0 sc0 ls21 wsb">*/ </div><div class="t m0 x0 hb y38d ff10 fs6 fc0 sc0 ls21 wsb">var pattern1 = /[bc]at/i; </div><div class="t m0 x0 hb y38e ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y38f ff10 fs6 fc0 sc0 ls21 wsb">/* </div><div class="t m0 x0 h16 y390 ff10 fs6 fc0 sc0 ls21 wsb">* 与pattern1相同，只不过是使用构造函数创建的 </div><div class="t m0 x0 hb y391 ff10 fs6 fc0 sc0 ls21 wsb">*/ </div><div class="t m0 x0 hb y392 ff10 fs6 fc0 sc0 ls21 wsb">var pattern2 = new RegExp(&quot;[bc]at&quot;, &quot;i&quot;); </div><div class="t m0 x0 hb y393 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y394 fff fs2 fc0 sc0 ls8 ws1">在此，pattern1和pattern2是两个完全等价的正则表达式。要注意的是，传递给RegExp构造</div><div class="t m0 x0 h1e y395 fff fs2 fc0 sc0 ls8 ws1">函数的两个参数都是字符串（不能把正则表达式字面量传递给RegExp构造函数）。由于RegExp构造</div><div class="t m0 x0 h4 y396 fff fs2 fc0 sc0 ls8 ws1">函数的模式参数是字符串，所以在某些情况下要对字符进行双重转义。所有元字符都必须双重转义，那</div><div class="t m0 x0 hc y397 fff fs2 fc0 sc0 ls8 ws1">些已经转义过的字符也是如此，例如\n（字符\在字符串中通常被转义为\\，而在正则表达式字符串中就</div><div class="t m0 x0 h5 y398 fff fs2 fc0 sc0 ls8">会变成\\\\）。下表给出了一些模式，左边是这些模式的字面量形式，右边是使用RegExp构造函数定义</div><div class="t m0 x0 h5 y399 fff fs2 fc0 sc0 ls8 ws1">相同模式时使用的字符串。 </div><div class="t m0 x0 hb y39a ff10 fs6 fc0 sc0 ls8 wsb">  </div><div class="t m0 x5 h31 y39b ffc fs6 fc0 sc0 ls8 ws8b">字面量模式 等价的字符串 </div><div class="t m0 x5 h32 y39c ff10 fsc fc0 sc0 lsa8 ws8d">/\[bc\]at/ &quot;\\[bc\\]at&quot; </div><div class="t m0 x5 h32 y39d ff10 fsc fc0 sc0 lsa8 ws8e">/\.at/ &quot;\\.at&quot; </div><div class="t m0 x5 h32 y39e ff10 fsc fc0 sc0 lsa8 ws8f">/name\/age/ &quot;name\\/age&quot; </div><div class="t m0 x5 h32 y39f ff10 fsc fc0 sc0 lsa8 ws90">/\d.\d{1,2}/ &quot;\\d.\\d{1,2}&quot; </div><div class="t m0 x5 h32 y3a0 ff10 fsc fc0 sc0 lsa8 ws91">/\w\\hello\\123/ &quot;\\w\\\\hello\\\\123&quot; </div><div class="t m0 x0 hb y3a1 ff10 fs6 fc0 sc0 ls8 wsb">  </div><div class="t m0 x0 h5 y3a2 fff fs2 fc0 sc0 ls8 ws1">使用正则表达式字面量和使用RegExp构造函数创建的正则表达式不一样。在ECMAScript 3中，</div><div class="t m0 x0 h1e y3a3 fff fs2 fc0 sc0 ls8 ws1">正则表达式字面量始终会共享同一个RegExp实例，而使用构造函数创建的每一个新RegExp实例都是</div></div></div>
<div id="pf7b" class="pf w0 h0" data-page-no="7b"><div class="pc pc7b w0 h0"><div class="t m0 x2 h2 y1 ff8 fs0 fc0 sc0 ls10 wsc">5.4 RegExp类型   105 </div><div class="t m0 x0 h3 y2 ff8 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffa fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ffa fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffa fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffa fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffa fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffa fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffa fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffa fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffa fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffa fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffa fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffa fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ffa fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 fff fs2 fc0 sc0 ls8 ws1">一个新实例。来看下面的例子。 </div><div class="t m0 x0 hb y3a5 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3a6 ff10 fs6 fc0 sc0 ls21 wsb">var re = null, </div><div class="t m0 x0 hb y3a7 ff10 fs6 fc0 sc0 ls21 wsb">    i;  </div><div class="t m0 x0 hb y3a8 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3a9 ff10 fs6 fc0 sc0 ls21 wsb">for (i=0; i &lt; 10; i++){ </div><div class="t m0 x0 hb y3aa ff10 fs6 fc0 sc0 ls21 wsb">    re = /cat/g; </div><div class="t m0 x0 hb y3ab ff10 fs6 fc0 sc0 ls21 wsb">    re.test(&quot;catastrophe&quot;); </div><div class="t m0 x0 hb y3ac ff10 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y3ad ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3ae ff10 fs6 fc0 sc0 ls21 wsb">for (i=0; i &lt; 10; i++){ </div><div class="t m0 x0 hb y3af ff10 fs6 fc0 sc0 ls21 wsb">    re = new RegExp(&quot;cat&quot;, &quot;g&quot;); </div><div class="t m0 x0 hb y3b0 ff10 fs6 fc0 sc0 ls21 wsb">    re.test(&quot;catastrophe&quot;); </div><div class="t m0 x0 hb y3b1 ff10 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y3b2 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3b3 fff fs2 fc0 sc0 ls8 ws1">在第一个循环中，即使是循环体中指定的，但实际上只为/cat/创建了一个RegExp实例。由于实</div><div class="t m0 x0 h1e y3b4 fff fs2 fc0 sc0 ls8 ws1">例属性（下一节介绍实例属性）不会重置，所以在循环中再次调用test()方法会失败。这是因为第一</div><div class="t m0 x0 hc y3b5 fff fs2 fc0 sc0 ls8 ws1">次调用test()找到了&quot;cat&quot;，但第二次调用是从索引为3的字符（上一次匹配的末尾）开始的，所以</div><div class="t m0 x0 hc y3b6 fff fs2 fc0 sc0 ls8 ws1">就找不到它了。由于会测试到字符串末尾，所以下一次再调用test()就又从开头开始了。 </div><div class="t m0 x0 h4 y3b7 fff fs2 fc0 sc0 ls8 ws1">第二个循环使用RegExp构造函数在每次循环中创建正则表达式。因为每次迭代都会创建一个新的</div><div class="t m0 x0 h5 y3b8 ff10 fs1 fc0 sc0 ls9 ws2">RegExp实例，所以每次调用test()都会返回true。 </div><div class="t m0 x0 h5 y3b9 ff8 fs2 fc0 sc0 ls25 ws57">ECMAScript 5明确规定，使用正则表达式字面量必须像直接调用RegExp构造函数一样，每次都创</div><div class="t m0 x0 h5 y3ba fff fs2 fc0 sc0 ls8 ws1">建新的RegExp实例。IE9+、Firefox 4+和Chrome都据此做出了修改。 </div><div class="t m0 x0 h20 y3bb ffe fs3 fc0 sc0 ls4d ws40">5.4.1 RegExp实例属性 </div><div class="t m0 x0 h5 y3bc ff10 fs1 fc0 sc0 ls9 ws2">RegExp的每个实例都具有下列属性，通过这些属性可以取得有关模式的各种信息。 </div><div class="t m0 x0 h5 y3bd ffd fs1 fc0 sc0 ls2"> global：布尔值，表示是否设置了g标志。 </div><div class="t m0 x0 h5 y3be ffd fs1 fc0 sc0 ls2"> ignoreCase：布尔值，表示是否设置了i标志。 </div><div class="t m0 x0 h5 y3bf ffd fs1 fc0 sc0 ls2"> lastIndex：整数，表示开始搜索下一个匹配项的字符位置，从0算起。 </div><div class="t m0 x0 h5 y3c0 ffd fs1 fc0 sc0 ls2"> multiline：布尔值，表示是否设置了m标志。 </div><div class="t m0 x0 h5 y3c1 ffd fs1 fc0 sc0 ls2"> source：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。 </div><div class="t m0 x0 h4 y3c2 fff fs2 fc0 sc0 ls8 ws1">通过这些属性可以获知一个正则表达式的各方面信息，但却没有多大用处，因为这些信息全都包含</div><div class="t m0 x0 h5 y3c3 fff fs2 fc0 sc0 ls8 ws1">在模式声明中。例如： </div><div class="t m0 x0 hb y3c4 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3c5 ff10 fs6 fc0 sc0 ls21 wsb">var pattern1 = /\[bc\]at/i; </div><div class="t m0 x0 hb y3c6 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3c7 ff10 fs6 fc0 sc0 ls21 wsb">alert(pattern1.global);         //false </div><div class="t m0 x0 hb y3c8 ff10 fs6 fc0 sc0 ls21 wsb">alert(pattern1.ignoreCase);     //true </div><div class="t m0 x0 hb y3c9 ff10 fs6 fc0 sc0 ls21 wsb">alert(pattern1.multiline);      //false </div><div class="t m0 x0 hb y3ca ff10 fs6 fc0 sc0 ls21 wsb">alert(pattern1.lastIndex);      //0 </div><div class="t m0 x0 hb y3cb ff10 fs6 fc0 sc0 ls21 wsb">alert(pattern1.source);         //&quot;\[bc\]at&quot; </div><div class="t m0 x0 hb y3cc ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3cd ff10 fs6 fc0 sc0 ls21 wsb">var pattern2 = new RegExp(&quot;\\[bc\\]at&quot;, &quot;i&quot;); </div><div class="t m0 x0 hb y3ce ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3cf ff10 fs6 fc0 sc0 ls21 wsb">alert(pattern2.global);         //false </div><div class="t m0 x0 hb y3d0 ff10 fs6 fc0 sc0 ls21 wsb">alert(pattern2.ignoreCase);     //true </div><div class="t m0 x0 hb y3d1 ff10 fs6 fc0 sc0 ls21 wsb">alert(pattern2.multiline);      //false </div><div class="t m0 x0 hb y3d2 ff10 fs6 fc0 sc0 ls21 wsb">alert(pattern2.lastIndex);      //0 </div><div class="t m0 x0 hb y3d3 ff10 fs6 fc0 sc0 ls21 wsb">alert(pattern2.source);         //&quot;\[bc\]at&quot; </div><div class="t m0 x5 hb y3d4 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf y3d5 ff12 fs2 fc0 sc0 ls1b wsb">RegExpInstancePropertiesExample01.htm </div></div></div>
<div id="pf7c" class="pf w0 h0" data-page-no="7c"><div class="pc pc7c w0 h0"><div class="t m0 x0 h2 y1 ff8 fs0 fc0 sc0 ls7 ws0">106  第5章 引用类型 </div><div class="t m0 x0 h3 y2 ff8 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 fff fs2 fc0 sc0 ls6 ws6">我们注意到，尽管第一个模式使用的是字面量，第二个模式使用了RegExp构造函数，但它们的</div><div class="t m0 x0 h5 y4 ff10 fs1 fc0 sc0 ls9 ws2">source属性是相同的。可见，source属性保存的是规范形式的字符串，即字面量形式所用的字符串。 </div><div class="t m0 x0 h20 y1f2 ffe fs3 fc0 sc0 ls4d ws40">5.4.2 RegExp实例方法 </div><div class="t m0 x0 h4 y1f3 ff10 fs1 fc0 sc0 ls9 ws2">RegExp对象的主要方法是exec()，该方法是专门为捕获组而设计的。exec()接受一个参数，即</div><div class="t m0 x0 h4 y1f4 fff fs2 fc0 sc0 ls8 ws1">要应用模式的字符串，然后返回包含第一个匹配项信息的数组；或者在没有匹配项的情况下返回null。</div><div class="t m0 x0 h1e y1f5 fff fs2 fc0 sc0 ls8 ws1">返回的数组虽然是Array的实例，但包含两个额外的属性：index和input。其中，index表示匹配</div><div class="t m0 x0 h1e y1f6 fff fs2 fc0 sc0 ls8 ws1">项在字符串中的位置，而input表示应用正则表达式的字符串。在数组中，第一项是与整个模式匹配</div><div class="t m0 x0 h4 y1f7 fff fs2 fc0 sc0 ls8 ws1">的字符串，其他项是与模式中的捕获组匹配的字符串（如果模式中没有捕获组，则该数组只包含一项）。</div><div class="t m0 x0 h5 y1f8 fff fs2 fc0 sc0 ls8 ws1">请看下面的例子。 </div><div class="t m0 x0 hb y3d7 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3d8 ff10 fs6 fc0 sc0 ls21 wsb">var text = &quot;mom and dad and baby&quot;; </div><div class="t m0 x0 hb y3d9 ff10 fs6 fc0 sc0 ls21 wsb">var pattern = /mom( and dad( and baby)?)?/gi; </div><div class="t m0 x0 hb y3da ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3db ff10 fs6 fc0 sc0 ls21 wsb">var matches = pattern.exec(text); </div><div class="t m0 x0 hb y3dc ff10 fs6 fc0 sc0 ls21 wsb">alert(matches.index);     // 0 </div><div class="t m0 x0 hb y3dd ff10 fs6 fc0 sc0 ls21 wsb">alert(matches.input);     // &quot;mom and dad and baby&quot; </div><div class="t m0 x0 hb y3de ff10 fs6 fc0 sc0 ls21 wsb">alert(matches[0]);        // &quot;mom and dad and baby&quot; </div><div class="t m0 x0 hb y3df ff10 fs6 fc0 sc0 ls21 wsb">alert(matches[1]);        // &quot; and dad and baby&quot; </div><div class="t m0 x0 hb y3e0 ff10 fs6 fc0 sc0 ls21 wsb">alert(matches[2]);        // &quot; and baby&quot; </div><div class="t m0 x0 hb y3e1 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1b4 ff12 fs2 fc0 sc0 ls7a wsb">RegExpExecExample01.htm </div><div class="t m0 x0 h4 y3e2 fff fs2 fc0 sc0 ls8 ws1">这个例子中的模式包含两个捕获组。最内部的捕获组匹配&quot;and baby&quot;，而包含它的捕获组匹配&quot;and </div><div class="t m0 x0 h4 y3e3 ff10 fs1 fc0 sc0 ls9 ws2">dad&quot;或者&quot;and dad and baby&quot;。当把字符串传入exec()方法中之后，发现了一个匹配项。因为整个</div><div class="t m0 x0 hc y3e4 fff fs2 fc0 sc0 ls8 ws1">字符串本身与模式匹配，所以返回的数组matchs的index属性值为0。数组中的第一项是匹配的整个</div><div class="t m0 x0 h5 y3e5 fff fs2 fc0 sc0 ls8 ws1">字符串，第二项包含与第一个捕获组匹配的内容，第三项包含与第二个捕获组匹配的内容。 </div><div class="t m0 x0 h1c y3e6 fff fs2 fc0 sc0 ls8 ws1">对于exec()方法而言，即使在模式中设置了全局标志（g），它每次也只会返回一个匹配项。在不</div><div class="t m0 x0 h4 y3e7 fff fs2 fc0 sc0 ls8 ws1">设置全局标志的情况下，在同一个字符串上多次调用exec()将始终返回第一个匹配项的信息。而在设</div><div class="t m0 x0 hc y3e8 fff fs2 fc0 sc0 ls1f ws15">置全局标志的情况下，每次调用exec()则都会在字符串中继续查找新匹配项，如下面的例子所示。 </div><div class="t m0 x0 hb y394 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3e9 ff10 fs6 fc0 sc0 ls21 wsb">var text = &quot;cat, bat, sat, fat&quot;; </div><div class="t m0 x0 hb y3ea ff10 fs6 fc0 sc0 ls21 wsb">var pattern1 = /.at/; </div><div class="t m0 x0 hb y3eb ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3ec ff10 fs6 fc0 sc0 ls21 wsb">var matches = pattern1.exec(text); </div><div class="t m0 x0 hb y3ed ff10 fs6 fc0 sc0 ls21 wsb">alert(matches.index);        //0 </div><div class="t m0 x0 hb y3ee ff10 fs6 fc0 sc0 ls21 wsb">alert(matches[0]);           //cat </div><div class="t m0 x0 hb y3ef ff10 fs6 fc0 sc0 ls21 wsb">alert(pattern1.lastIndex);   //0 </div><div class="t m0 x0 hb y3f0 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3f1 ff10 fs6 fc0 sc0 ls21 wsb">matches = pattern1.exec(text); </div><div class="t m0 x0 hb y3f2 ff10 fs6 fc0 sc0 ls21 wsb">alert(matches.index);        //0 </div><div class="t m0 x0 hb y3f3 ff10 fs6 fc0 sc0 ls21 wsb">alert(matches[0]);           //cat </div><div class="t m0 x0 hb y3f4 ff10 fs6 fc0 sc0 ls21 wsb">alert(pattern1.lastIndex);   //0 </div><div class="t m0 x0 hb y3f5 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3f6 ff10 fs6 fc0 sc0 ls21 wsb">var pattern2 = /.at/g; </div><div class="t m0 x0 hb y3f7 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3f8 ff10 fs6 fc0 sc0 ls21 wsb">var matches = pattern2.exec(text); </div><div class="t m0 x0 hb y3f9 ff10 fs6 fc0 sc0 ls21 wsb">alert(matches.index);       //0 </div><div class="t m0 x0 hb y3fa ff10 fs6 fc0 sc0 ls21 wsb">alert(matches[0]);           //cat </div><div class="t m0 x0 hb y3fb ff10 fs6 fc0 sc0 ls21 wsb">alert(pattern2.lastIndex);   //3 </div></div></div>
<div id="pf7d" class="pf w0 h0" data-page-no="7d"><div class="pc pc7d w0 h0"><div class="t m0 x2 h2 y1 ff8 fs0 fc0 sc0 ls10 wsc">5.4 RegExp类型   107 </div><div class="t m0 x0 h3 y2 ff8 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffa fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ffa fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffa fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffa fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffa fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffa fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffa fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffa fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffa fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffa fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffa fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffa fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ffa fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y79 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y7a ff10 fs6 fc0 sc0 ls21 wsb">matches = pattern2.exec(text); </div><div class="t m0 x0 hb y7b ff10 fs6 fc0 sc0 ls21 wsb">alert(matches.index);        //5 </div><div class="t m0 x0 hb y7c ff10 fs6 fc0 sc0 ls21 wsb">alert(matches[0]);           //bat </div><div class="t m0 x0 hb y7d ff10 fs6 fc0 sc0 ls21 wsb">alert(pattern2.lastIndex);   //8 </div><div class="t m0 x5 hb y3fc ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y3fd ff12 fs2 fc0 sc0 ls7a wsb">RegExpExecExample02.htm </div><div class="t m0 x0 h4 y3fe fff fs2 fc0 sc0 ls8 ws1">这个例子中的第一个模式pattern1不是全局模式，因此每次调用exec()返回的都是第一个匹配</div><div class="t m0 x0 h1e y3ff fff fs2 fc0 sc0 lsb8 ws96">项（&quot;cat&quot;）。而第二个模式pattern2是全局模式，因此每次调用exec()都会返回字符串中的下一个</div><div class="t m0 x0 h1e y400 fff fs2 fc0 sc0 ls8 ws1">匹配项，直至搜索到字符串末尾为止。此外，还应该注意模式的lastIndex属性的变化情况。在全局</div><div class="t m0 x0 hc y401 fff fs2 fc0 sc0 ls8 ws1">匹配模式下，lastIndex的值在每次调用exec()后都会增加，而在非全局模式下则始终保持不变。 </div><div class="t m0 x5 h5 y402 ff8 fs2 fc0 sc0 lse ws9">IE的JavaScript实现在 lastIndex属性上存在偏差，即使在非全局模式下，</div><div class="t m0 x5 h5 y403 ff10 fs1 fc0 sc0 ls9 ws2">lastIndex属性每次也会变化。 </div><div class="t m0 x0 h4 y404 fff fs2 fc0 sc0 ls8 ws1">正则表达式的第二个方法是test()，它接受一个字符串参数。在模式与该参数匹配的情况下返回</div><div class="t m0 x0 h4 y405 ff10 fs1 fc0 sc0 ls9 ws2">true；否则，返回false。在只想知道目标字符串与某个模式是否匹配，但不需要知道其文本内容的</div><div class="t m0 x0 hc y406 fff fs2 fc0 sc0 ls8 ws1">情况下，使用这个方法非常方便。因此，test()方法经常被用在if语句中，如下面的例子所示。 </div><div class="t m0 x5 hb y407 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y408 ff10 fs6 fc0 sc0 ls21 wsb">var text = &quot;000-00-0000&quot;; </div><div class="t m0 x0 hb y409 ff10 fs6 fc0 sc0 ls21 wsb">var pattern = /\d{3}-\d{2}-\d{4}/; </div><div class="t m0 x0 hb y40a ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y40b ff10 fs6 fc0 sc0 ls21 wsb">if (pattern.test(text)){ </div><div class="t m0 x0 hb y40c ff10 fs6 fc0 sc0 ls21 wsb">    alert(&quot;The pattern was matched.&quot;); </div><div class="t m0 x0 hb y40d ff10 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h4 y40e fff fs2 fc0 sc0 ls8 ws1">在这个例子中，我们使用正则表达式来测试了一个数字序列。如果输入的文本与模式匹配，则显示</div><div class="t m0 x0 h4 y40f fff fs2 fc0 sc0 ls8 ws1">一条消息。这种用法经常出现在验证用户输入的情况下，因为我们只想知道输入是不是有效，至于它为</div><div class="t m0 x0 h5 y410 fff fs2 fc0 sc0 ls8 ws1">什么无效就无关紧要了。 </div><div class="t m0 x0 h4 y411 ff10 fs1 fc0 sc0 ls9 ws2">RegExp实例继承的toLocaleString()和toString()方法都会返回正则表达式的字面量，与创</div><div class="t m0 x0 h5 y412 fff fs2 fc0 sc0 ls8 ws1">建正则表达式的方式无关。例如： </div><div class="t m0 x5 hb y413 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y414 ff10 fs6 fc0 sc0 ls21 wsb">var pattern = new RegExp(&quot;\\[bc\\]at&quot;, &quot;gi&quot;); </div><div class="t m0 x0 hb y415 ff10 fs6 fc0 sc0 ls21 wsb">alert(pattern.toString());             // /\[bc\]at/gi </div><div class="t m0 x0 hb y416 ff10 fs6 fc0 sc0 ls21 wsb">alert(pattern.toLocaleString());       // /\[bc\]at/gi </div><div class="t m0 x5 hb y417 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y418 ff12 fs2 fc0 sc0 ls25 wsb">RegExpToStringExample01.htm </div><div class="t m0 x0 h4 y419 fff fs2 fc0 sc0 ls8 ws1">即使上例中的模式是通过调用RegExp构造函数创建的，但toLocaleString()和toString()</div><div class="t m0 x0 h5 y41a fff fs2 fc0 sc0 ls8 ws1">方法仍然会像它是以字面量形式创建的一样显示其字符串表示。 </div><div class="t m0 x5 h1d y41b ff9 fs2 fc0 sc0 ls8 ws14">正则表达式的valueOf()方法返回正则表达式本身。 </div><div class="t m0 x0 h20 y41c ffe fs3 fc0 sc0 ls4d ws40">5.4.3 RegExp构造函数属性 </div><div class="t m0 x0 h4 y41d ff10 fs1 fc0 sc0 ls9 ws2">RegExp构造函数包含一些属性（这些属性在其他语言中被看成是静态属性）。这些属性适用于作用</div></div></div>
<div id="pf7e" class="pf w0 h0" data-page-no="7e"><div class="pc pc7e w0 h0"><div class="t m0 x0 h2 y1 ff8 fs0 fc0 sc0 ls7 ws0">108  第5章 引用类型 </div><div class="t m0 x0 h3 y2 ff8 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 fff fs2 fc0 sc0 ls8 ws1">域中的所有正则表达式，并且基于所执行的最近一次正则表达式操作而变化。关于这些属性的另一个独</div><div class="t m0 x0 h4 y4d fff fs2 fc0 sc0 ls24 ws1e">特之处，就是可以通过两种方式访问它们。换句话说，这些属性分别有一个长属性名和一个短属性名</div><div class="t m0 x0 he yd8 fff fs2 fc0 sc0 ls8">（Opera是例外，它不支持短属性名）。下表列出了RegExp构造函数的属性。 </div><div class="t m0 x0 hb y41f ff10 fs6 fc0 sc0 ls8 wsb">  </div><div class="t m0 x0 h31 y420 ffc fs6 fc0 sc0 ls8">长属性名 短属性名 说  明 </div><div class="t m0 x0 h32 y421 ff10 fsc fc0 sc0 lsa8 ws9a">input $_ </div><div class="t m0 x7 h36 y422 fff fs6 fc0 sc0 ls8 ws33">最近一次要匹配的字符串。Opera未实现此属性 </div><div class="t m0 x0 h32 y423 ff10 fsc fc0 sc0 lsa8 ws9b">lastMatch $&amp; </div><div class="t m0 x7 h36 y424 fff fs6 fc0 sc0 ls8 ws33">最近一次的匹配项。Opera未实现此属性 </div><div class="t m0 x0 h32 y425 ff10 fsc fc0 sc0 lsa8 ws9b">lastParen $+ </div><div class="t m0 x7 h36 y426 fff fs6 fc0 sc0 ls8 ws33">最近一次匹配的捕获组。Opera未实现此属性 </div><div class="t m0 x0 h32 y427 ff10 fsc fc0 sc0 lsa8 ws9c">leftContext $` input字符串中lastMatch之前的文本 </div><div class="t m0 x0 h32 y428 ff10 fsc fc0 sc0 lsa8 ws9b">multiline $* </div><div class="t m0 x7 h36 y429 fff fs6 fc0 sc0 ls8 ws33">布尔值，表示是否所有表达式都使用多行模式。IE和Opera未实现此属性 </div><div class="t m0 x0 h32 y42a ff10 fsc fc0 sc0 lsa8 ws9d">rightContext $&apos; Input字符串中lastMatch之后的文本 </div><div class="t m0 x0 hb y42b ff10 fs6 fc0 sc0 ls8 wsb">  </div><div class="t m0 x0 h5 y42c fff fs2 fc0 sc0 ls8 ws1">使用这些属性可以从exec()或test()执行的操作中提取出更具体的信息。请看下面的例子。 </div><div class="t m0 x0 hb y42d ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y42e ff10 fs6 fc0 sc0 ls21 wsb">var text = &quot;this has been a short summer&quot;; </div><div class="t m0 x0 hb y42f ff10 fs6 fc0 sc0 ls21 wsb">var pattern = /(.)hort/g; </div><div class="t m0 x0 hb y430 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y431 ff10 fs6 fc0 sc0 ls21 wsb">/* </div><div class="t m0 x0 h16 y432 ff10 fs6 fc0 sc0 ls21 wsb"> * 注意：Opera不支持input、lastMatch、lastParen和multiline属性 </div><div class="t m0 x0 h16 y433 ff10 fs6 fc0 sc0 ls21 wsb"> * Internet Explorer不支持multiline属性 </div><div class="t m0 x0 hb y434 ff10 fs6 fc0 sc0 ls21 wsb"> */         </div><div class="t m0 x0 hb y435 ff10 fs6 fc0 sc0 ls21 wsb">if (pattern.test(text)){ </div><div class="t m0 x0 hb y436 ff10 fs6 fc0 sc0 ls21 wsb">    alert(RegExp.input);            // this has been a short summer </div><div class="t m0 x0 hb y437 ff10 fs6 fc0 sc0 ls21 wsb">    alert(RegExp.leftContext);      // this has been a             </div><div class="t m0 x0 hb y438 ff10 fs6 fc0 sc0 ls21 wsb">    alert(RegExp.rightContext);     // summer </div><div class="t m0 x0 hb y439 ff10 fs6 fc0 sc0 ls21 wsb">    alert(RegExp.lastMatch);        // short </div><div class="t m0 x0 hb y43a ff10 fs6 fc0 sc0 ls21 wsb">    alert(RegExp.lastParen);        // s </div><div class="t m0 x0 hb y43b ff10 fs6 fc0 sc0 ls21 wsb">    alert(RegExp.multiline);        // false </div><div class="t m0 x0 hb y43c ff10 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y43d ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf y43e ff12 fs2 fc0 sc0 ls81 wsb">RegExpConstructorPropertiesExample01.htm </div><div class="t m0 x0 h4 y43f fff fs2 fc0 sc0 ls8 ws1">以上代码创建了一个模式，匹配任何一个字符后跟hort，而且把第一个字符放在了一个捕获组中。</div><div class="t m0 x0 h5 y440 ff10 fs1 fc0 sc0 ls9 ws2">RegExp构造函数的各个属性返回了下列值： </div><div class="t m0 x0 h5 y3e ffd fs1 fc0 sc0 ls2"> input属性返回了原始字符串； </div><div class="t m0 x0 h4 y441 ffd fs1 fc0 sc0 ls2"> leftContext属性返回了单词short之前的字符串，而rightContext 属性则返回了short</div><div class="t m0 x0 h5 y442 fff fs2 fc0 sc0 ls8 ws1">之后的字符串； </div><div class="t m0 x0 h5 y443 ffd fs1 fc0 sc0 ls2"> lastMatch属性返回最近一次与整个正则表达式匹配的字符串，即short； </div><div class="t m0 x0 h5 y444 ffd fs1 fc0 sc0 ls2"> lastParen属性返回最近一次匹配的捕获组，即例子中的s。 </div><div class="t m0 x0 h4 y445 fff fs2 fc0 sc0 ls8 ws1">如前所述，例子使用的长属性名都可以用相应的短属性名来代替。只不过，由于这些短属性名大都</div><div class="t m0 x0 h5 y446 fff fs2 fc0 sc0 ls8 ws1">不是有效的ECMAScript标识符，因此必须通过方括号语法来访问它们，如下所示。 </div><div class="t m0 x0 hb y447 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y448 ff10 fs6 fc0 sc0 ls21 wsb">var text = &quot;this has been a short summer&quot;; </div><div class="t m0 x0 hb y449 ff10 fs6 fc0 sc0 ls21 wsb">var pattern = /(.)hort/g; </div><div class="t m0 x0 hb y44a ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y44b ff10 fs6 fc0 sc0 ls21 wsb">/* </div><div class="t m0 x0 h16 y44c ff10 fs6 fc0 sc0 ls21 wsb"> * 注意：Opera不支持input、lastMatch、lastParen和multiline属性 </div><div class="t m0 x0 h16 y44d ff10 fs6 fc0 sc0 ls21 wsb"> * Internet Explorer不支持multiline属性 </div><div class="t m0 x0 hb y44e ff10 fs6 fc0 sc0 ls21 wsb"> */         </div></div></div>
<div id="pf7f" class="pf w0 h0" data-page-no="7f"><div class="pc pc7f w0 h0"><div class="t m0 x2 h2 y1 ff8 fs0 fc0 sc0 ls10 wsc">5.4 RegExp类型   109 </div><div class="t m0 x0 h3 y2 ff8 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffa fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ffa fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffa fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffa fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffa fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffa fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffa fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffa fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffa fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffa fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffa fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffa fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ffa fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y44f ff10 fs6 fc0 sc0 ls21 wsb">if (pattern.test(text)){ </div><div class="t m0 x0 hb y450 ff10 fs6 fc0 sc0 ls21 wsb">    alert(RegExp.$_);              // this has been a short summer </div><div class="t m0 x0 h15 y451 ff11 fs6 fc0 sc0 ls21 wsb">    alert(RegExp[&quot;$`&quot;]);           // this has been a             </div><div class="t m0 x0 h15 y452 ff11 fs6 fc0 sc0 ls21 wsb">    alert(RegExp[&quot;$&apos;&quot;]);           // summer </div><div class="t m0 x0 h15 y453 ff11 fs6 fc0 sc0 ls21 wsb">    alert(RegExp[&quot;$&amp;&quot;]);           // short </div><div class="t m0 x0 h15 y454 ff11 fs6 fc0 sc0 ls21 wsb">    alert(RegExp[&quot;$+&quot;]);           // s </div><div class="t m0 x0 h15 y455 ff11 fs6 fc0 sc0 ls21 wsb">    alert(RegExp[&quot;$*&quot;]);           // false </div><div class="t m0 x0 hb y456 ff10 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x4 hf y457 ff12 fs2 fc0 sc0 lsc0 wsb">RegExpConstructorPropertiesExample02.htm </div><div class="t m0 x0 h5 y458 fff fs2 fc0 sc0 ls8 ws1">除了上面介绍的几个属性之外，还有多达9个用于存储捕获组的构造函数属性。访问这些属性的语</div><div class="t m0 x0 h4 y459 fff fs2 fc0 sc0 ls8 ws1">法是RegExp.$1、RegExp.$2…RegExp.$9，分别用于存储第一、第二……第九个匹配的捕获组。在</div><div class="t m0 x0 hc y45a fff fs2 fc0 sc0 ls8 ws1">调用exec()或test()方法时，这些属性会被自动填充。然后，我们就可以像下面这样来使用它们。 </div><div class="t m0 x5 hb y1f9 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y45b ff10 fs6 fc0 sc0 ls21 wsb">var text = &quot;this has been a short summer&quot;; </div><div class="t m0 x0 hb y45c ff10 fs6 fc0 sc0 ls21 wsb">var pattern = /(..)or(.)/g; </div><div class="t m0 x0 hb y45d ff10 fs6 fc0 sc0 ls21 wsb">       </div><div class="t m0 x0 hb y45e ff10 fs6 fc0 sc0 ls21 wsb">if (pattern.test(text)){ </div><div class="t m0 x0 hb y45f ff10 fs6 fc0 sc0 ls21 wsb">    alert(RegExp.$1);       //sh </div><div class="t m0 x0 hb y460 ff10 fs6 fc0 sc0 ls21 wsb">    alert(RegExp.$2);       //t </div><div class="t m0 x0 hb y461 ff10 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x4 hf y462 ff12 fs2 fc0 sc0 lsc0 wsb">RegExpConstructorPropertiesExample03.htm </div><div class="t m0 x0 h4 y463 fff fs2 fc0 sc0 ls8 ws1">这里创建了一个包含两个捕获组的模式，并用该模式测试了一个字符串。即使test()方法只返回</div><div class="t m0 x0 hc y464 fff fs2 fc0 sc0 ls8 ws1">一个布尔值，但RegExp构造函数的属性$1和$2也会被匹配相应捕获组的字符串自动填充。 </div><div class="t m0 x0 h20 y465 ffe fs3 fc0 sc0 ls4d ws40">5.4.4 模式的局限性 </div><div class="t m0 x0 h5 y466 fff fs2 fc0 sc0 ls8 ws1">尽管ECMAScript中的正则表达式功能还是比较完备的，但仍然缺少某些语言（特别是Perl）所支</div><div class="t m0 x0 h5 y467 fff fs2 fc0 sc0 ls8 ws1">持的高级正则表达式特性。下面列出了ECMAScript正则表达式不支持的特性（要了解更多相关信息，</div><div class="t m0 x0 h5 y468 fff fs2 fc0 sc0 ls8 ws1">请访问www.regular-expressions.info）。 </div><div class="t m0 x0 h3b y469 ffd fs1 fc0 sc0 ls2"> 匹配字符串开始和结尾的\A和\Z锚① </div><div class="t m0 x0 h3b y46a ffd fs1 fc0 sc0 ls2"> 向后查找（lookbehind）② </div><div class="t m0 x0 h5 y46b ffd fs1 fc0 sc0 ls2"> 并集和交集类 </div><div class="t m0 x0 h5 y46c ffd fs1 fc0 sc0 ls2"> 原子组（atomic grouping） </div><div class="t m0 x0 h5 y2a8 ffd fs1 fc0 sc0 ls2"> Unicode支持（单个字符除外，如\uFFFF） </div><div class="t m0 x0 h3b y46d ffd fs1 fc0 sc0 ls2"> 命名的捕获组③ </div><div class="t m0 x0 h5 y46e ffd fs1 fc0 sc0 ls2"> s（single，单行）和x（free-spacing，无间隔）匹配模式 </div><div class="t m0 x0 h5 y46f ffd fs1 fc0 sc0 ls2"> 条件匹配 </div><div class="t m0 x0 h5 y470 ffd fs1 fc0 sc0 ls2"> 正则表达式注释 </div><div class="t m0 x0 h5 y471 fff fs2 fc0 sc0 ls6 ws6">即使存在这些限制，ECMAScript正则表达式仍然是非常强大的，能够帮我们完成绝大多数模式匹</div><div class="t m0 x0 h5 y472 fff fs2 fc0 sc0 ls8">配任务。 </div><div class="t m0 x0 h3c y473 ffc fs2 fc0 sc0 ls7b wsb">—————————— </div><div class="t m0 x0 h36 y474 fff fs6 fc0 sc0 ls95">① 但支持以插入符号（^）和美元符号（$）来匹配字符串的开始和结尾。 </div><div class="t m0 x0 h36 y475 fff fs6 fc0 sc0 ls95">② 但完全支持向前查找（lookahead）。 </div><div class="t m0 x0 h36 y476 fff fs6 fc0 sc0 ls95">③ 但支持编号的捕获组。 </div></div></div>
<div id="pf80" class="pf w0 h0" data-page-no="80"><div class="pc pc80 w0 h0"><div class="t m0 x0 h2 y1 ff8 fs0 fc0 sc0 lsc2 wsa0">110  第5章 引用类型 </div><div class="t m0 x0 h3 y2 ff8 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hd ya9 ffe fs7 fc0 sc0 ls22">5.5 Function类型 </div><div class="t m0 x0 h5 yaa fff fs2 fc0 sc0 ls8 ws1">说起来ECMAScript中什么最有意思，我想那莫过于函数了——而有意思的根源，则在于函数实际</div><div class="t m0 x0 h4 yab fff fs2 fc0 sc0 ls8 ws1">上是对象。每个函数都是Function类型的实例，而且都与其他引用类型一样具有属性和方法。由于函</div><div class="t m0 x0 h4 yac fff fs2 fc0 sc0 ls8 ws1">数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。函数通常是使用函</div><div class="t m0 x0 h5 yad fff fs2 fc0 sc0 ls8 ws1">数声明语法定义的，如下面的例子所示。 </div><div class="t m0 x0 hb y478 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y479 ff10 fs6 fc0 sc0 ls21 wsb">function sum (num1, num2) { </div><div class="t m0 x0 hb y47a ff10 fs6 fc0 sc0 ls21 wsb">    return num1 + num2; </div><div class="t m0 x0 hb y47b ff10 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 h5 y459 fff fs2 fc0 sc0 ls8 ws1">这与下面使用函数表达式定义函数的方式几乎相差无几。 </div><div class="t m0 x0 hb y47c ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y47d ff10 fs6 fc0 sc0 ls21 wsb">var sum = function(num1, num2){ </div><div class="t m0 x0 hb y47e ff10 fs6 fc0 sc0 ls21 wsb">    return num1 + num2; </div><div class="t m0 x0 hb y47f ff10 fs6 fc0 sc0 ls21 wsb">};  </div><div class="t m0 x0 h4 y480 fff fs2 fc0 sc0 ls8 ws1">以上代码定义了变量sum并将其初始化为一个函数。有读者可能会注意到，function关键字后面</div><div class="t m0 x0 h1e y481 fff fs2 fc0 sc0 ls8 ws1">没有函数名。这是因为在使用函数表达式定义函数时，没有必要使用函数名——通过变量sum即可以引</div><div class="t m0 x0 h5 y482 fff fs2 fc0 sc0 ls8 ws1">用函数。另外，还要注意函数末尾有一个分号，就像声明其他变量时一样。 </div><div class="t m0 x0 h1c y483 fff fs2 fc0 sc0 ls1f ws15">最后一种定义函数的方式是使用Function构造函数。Function构造函数可以接收任意数量的参数，</div><div class="t m0 x0 h5 y484 fff fs2 fc0 sc0 ls1f">但最后一个参数始终都被看成是函数体，而前面的参数则枚举出了新函数的参数。来看下面的例子： </div><div class="t m0 x0 hb y485 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y486 ff10 fs6 fc0 sc0 ls21 wsb">var sum = new Function(&quot;num1&quot;, &quot;num2&quot;, &quot;return num1 + num2&quot;); // 不推荐 </div><div class="t m0 x0 hb y487 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y488 fff fs2 fc0 sc0 ls42 ws30">从技术角度讲，这是一个函数表达式。但是，我们不推荐读者使用这种方法定义函数，因为这种语</div><div class="t m0 x0 h5 y489 fff fs2 fc0 sc0 ls42 ws30">法会导致解析两次代码（第一次是解析常规ECMAScript代码，第二次是解析传入构造函数中的字符串），</div><div class="t m0 x0 h5 y48a fff fs2 fc0 sc0 ls42 ws30">从而影响性能。不过，这种语法对于理解“函数是对象，函数名是指针”的概念倒是非常直观的。 </div><div class="t m0 x0 h4 y48b fff fs2 fc0 sc0 ls8 ws1">由于函数名仅仅是指向函数的指针，因此函数名与包含对象指针的其他变量没有什么不同。换句话</div><div class="t m0 x0 h5 y48c fff fs2 fc0 sc0 ls8 ws1">说，一个函数可能会有多个名字，如下面的例子所示。 </div><div class="t m0 x0 hb y3e7 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y48d ff10 fs6 fc0 sc0 ls21 wsb">function sum(num1, num2){ </div><div class="t m0 x0 hb y48e ff10 fs6 fc0 sc0 ls21 wsb">    return num1 + num2; </div><div class="t m0 x0 hb y48f ff10 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y490 ff10 fs6 fc0 sc0 ls21 wsb">alert(sum(10,10));        //20 </div><div class="t m0 x0 hb y491 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y492 ff10 fs6 fc0 sc0 ls21 wsb">var anotherSum = sum; </div><div class="t m0 x0 hb y493 ff10 fs6 fc0 sc0 ls21 wsb">alert(anotherSum(10,10)); //20 </div><div class="t m0 x0 hb y494 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y495 ff10 fs6 fc0 sc0 ls21 wsb">sum = null; </div><div class="t m0 x0 hb y496 ff10 fs6 fc0 sc0 ls21 wsb">alert(anotherSum(10,10)); //20 </div><div class="t m0 x0 hb y497 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y498 ff12 fs2 fc0 sc0 ls25 wsb">FunctionTypeExample01.htm </div><div class="t m0 x0 h4 y499 fff fs2 fc0 sc0 ls5f ws4c">以上代码首先定义了一个名为sum()的函数，用于求两个值的和。然后，又声明了变量anotherSum，</div><div class="t m0 x0 h1e y49a fff fs2 fc0 sc0 ls8 ws1">并将其设置为与sum相等（将sum的值赋给anotherSum）。注意，使用不带圆括号的函数名是访问函</div><div class="t m0 x0 h1e y49b fff fs2 fc0 sc0 ls8 ws1">数指针，而非调用函数。此时，anotherSum和sum就都指向了同一个函数，因此anotherSum()也</div><div class="t m0 x0 h1e y49c fff fs2 fc0 sc0 ls24 ws1e">可以被调用并返回结果。即使将sum设置为 null，让它与函数“断绝关系”，但仍然可以正常调用</div><div class="t m0 x0 h5 y49d ff10 fs1 fc0 sc0 ls9 ws2">anotherSum()。 </div></div></div>
<div id="pf81" class="pf w0 h0" data-page-no="81"><div class="pc pc81 w0 h0"><div class="t m0 x2 h2 y1 ff8 fs0 fc0 sc0 ls10 wsc">5.5 Function类型   111 </div><div class="t m0 x0 h3 y2 ff8 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffa fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ffa fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffa fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffa fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffa fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffa fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffa fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffa fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffa fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffa fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffa fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffa fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ffa fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h20 y12d ffe fs3 fc0 sc0 ls4d ws40">5.5.1 没有重载（深入理解） </div><div class="t m0 x0 h5 y12e fff fs2 fc0 sc0 ls8 ws1">将函数名想象为指针，也有助于理解为什么ECMAScript中没有函数重载的概念。以下是曾在第3</div><div class="t m0 x0 h5 y12f fff fs2 fc0 sc0 ls8 ws1">章使用过的例子。 </div><div class="t m0 x5 hb y49e ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y49f ff10 fs6 fc0 sc0 ls21 wsb">function addSomeNumber(num){ </div><div class="t m0 x0 hb y4a0 ff10 fs6 fc0 sc0 ls21 wsb">    return num + 100; </div><div class="t m0 x0 hb y4a1 ff10 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y4a2 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4a3 ff10 fs6 fc0 sc0 ls21 wsb">function addSomeNumber(num) { </div><div class="t m0 x0 hb y4a4 ff10 fs6 fc0 sc0 ls21 wsb">    return num + 200; </div><div class="t m0 x0 hb y4a5 ff10 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y4a6 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4a7 ff10 fs6 fc0 sc0 ls21 wsb">var result = addSomeNumber(100); //300 </div><div class="t m0 x5 hb y4a8 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y4a9 fff fs2 fc0 sc0 ls8 ws1">显然，这个例子中声明了两个同名函数，而结果则是后面的函数覆盖了前面的函数。以上代码实际</div><div class="t m0 x0 h5 y4aa fff fs2 fc0 sc0 ls8 ws1">上与下面的代码没有什么区别。 </div><div class="t m0 x5 hb y4ab ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y4ac ff11 fs6 fc0 sc0 ls21 wsb">var addSomeNumber = function (num){ </div><div class="t m0 x0 hb y4ad ff10 fs6 fc0 sc0 ls21 wsb">    return num + 100; </div><div class="t m0 x0 hb y4ae ff10 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y4af ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y4b0 ff11 fs6 fc0 sc0 ls21 wsb">addSomeNumber = function (num) { </div><div class="t m0 x0 hb y4b1 ff10 fs6 fc0 sc0 ls21 wsb">    return num + 200; </div><div class="t m0 x0 hb y4b2 ff10 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y4b3 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4b4 ff10 fs6 fc0 sc0 ls21 wsb">var result = addSomeNumber(100); //300 </div><div class="t m0 x5 hb y4b5 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y4b6 fff fs2 fc0 sc0 ls8 ws1">通过观察重写之后的代码，很容易看清楚到底是怎么回事儿——在创建第二个函数时，实际上覆盖</div><div class="t m0 x0 h5 y4b7 fff fs2 fc0 sc0 ls8 ws1">了引用第一个函数的变量addSomeNumber。 </div><div class="t m0 x0 h20 y4b8 ffe fs3 fc0 sc0 ls4d ws40">5.5.2 函数声明与函数表达式 </div><div class="t m0 x0 h4 y4b9 fff fs2 fc0 sc0 ls8 ws1">本节到目前为止，我们一直没有对函数声明和函数表达式加以区别。而实际上，解析器在向执行环</div><div class="t m0 x0 h4 y4ba fff fs2 fc0 sc0 ls8 ws1">境中加载数据时，对函数声明和函数表达式并非一视同仁。解析器会率先读取函数声明，并使其在执行</div><div class="t m0 x0 h4 y4bb fff fs2 fc0 sc0 ls6 ws6">任何代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真</div><div class="t m0 x0 h5 y4bc fff fs2 fc0 sc0 ls8 ws1">正被解释执行。请看下面的例子。 </div><div class="t m0 x0 hb y4bd ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4be ff10 fs6 fc0 sc0 ls21 wsb">alert(sum(10,10)); </div><div class="t m0 x0 hb y4bf ff10 fs6 fc0 sc0 ls21 wsb">function sum(num1, num2){ </div><div class="t m0 x0 hb y4c0 ff10 fs6 fc0 sc0 ls21 wsb">    return num1 + num2; </div><div class="t m0 x0 hb y4c1 ff10 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x2 hf y4c2 ff12 fs2 fc0 sc0 ls7a wsb">FunctionDeclarationExample01.htm </div><div class="t m0 x0 h4 y4c3 fff fs2 fc0 sc0 ls8 ws1">以上代码完全可以正常运行。因为在代码开始执行之前，解析器就已经通过一个名为函数声明提升</div><div class="t m0 x0 h5 y4c4 fff fs2 fc0 sc0 ls8">（function declaration hoisting）的过程，读取并将函数声明添加到执行环境中。对代码求值时，JavaScript</div><div class="t m0 x0 h4 y4c5 fff fs2 fc0 sc0 ls8 ws1">引擎在第一遍会声明函数并将它们放到源代码树的顶部。所以，即使声明函数的代码在调用它的代码后</div><div class="t m0 x0 h5 y4c6 fff fs2 fc0 sc0 ls6">面，JavaScript引擎也能把函数声明提升到顶部。如果像下面例子所示的，把上面的函数声明改为等价</div><div class="t m0 x0 h5 y4c7 fff fs2 fc0 sc0 ls8 ws1">的函数表达式，就会在执行期间导致错误。 </div></div></div>
<div id="pf82" class="pf w0 h0" data-page-no="82"><div class="pc pc82 w0 h0"><div class="t m0 x0 h2 y1 ff8 fs0 fc0 sc0 lsc2 wsa0">112  第5章 引用类型 </div><div class="t m0 x0 h3 y2 ff8 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 ff10 fs6 fc0 sc0 ls21 wsb">alert(sum(10,10)); </div><div class="t m0 x0 h15 y7a ff11 fs6 fc0 sc0 ls21 wsb">var sum = function(num1, num2){ </div><div class="t m0 x0 hb y7b ff10 fs6 fc0 sc0 ls21 wsb">    return num1 + num2; </div><div class="t m0 x0 hb y7c ff10 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x4 hf y4c9 ff12 fs2 fc0 sc0 ls2b wsb">FunctionInitializationExample01.htm </div><div class="t m0 x0 hb y4ca ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y4cb fff fs2 fc0 sc0 ls8 ws1">以上代码之所以会在运行期间产生错误，原因在于函数位于一个初始化语句中，而不是一个函数声</div><div class="t m0 x0 h1e y4cc fff fs2 fc0 sc0 ls8 ws1">明。换句话说，在执行到函数所在的语句之前，变量sum中不会保存有对函数的引用；而且，由于第一</div><div class="t m0 x0 h5 y4cd fff fs2 fc0 sc0 ls8 ws1">行代码就会导致“unexpected identifier”（意外标识符）错误，实际上也不会执行到下一行。 </div><div class="t m0 x0 h5 y4ce fff fs2 fc0 sc0 ls5f ws4c">除了什么时候可以通过变量访问函数这一点区别之外，函数声明与函数表达式的语法其实是等价的。 </div><div class="t m0 x5 ha y4cf ff9 fs2 fc0 sc0 ls8 ws14">也可以同时使用函数声明和函数表达式，例如var sum = function sum(){}。</div><div class="t m0 x0 h5 y4d0 ff9 fs2 fc0 sc0 ls8 ws14">不过，这种语法在Safari中会导致错误。 </div><div class="t m0 x0 h20 y4d1 ffe fs3 fc0 sc0 ls4d ws40">5.5.3 作为值的函数 </div><div class="t m0 x0 h5 y4d2 fff fs2 fc0 sc0 ls8 ws1">因为ECMAScript中的函数名本身就是变量，所以函数也可以作为值来使用。也就是说，不仅可以</div><div class="t m0 x0 h4 y4d3 fff fs2 fc0 sc0 ls8 ws1">像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回。来看</div><div class="t m0 x0 h5 y4d4 fff fs2 fc0 sc0 ls8 ws1">一看下面的函数。 </div><div class="t m0 x0 hb y4d5 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4d6 ff10 fs6 fc0 sc0 ls21 wsb">function callSomeFunction(someFunction, someArgument){ </div><div class="t m0 x0 hb y4d7 ff10 fs6 fc0 sc0 ls21 wsb">    return someFunction(someArgument); </div><div class="t m0 x0 hb y4d8 ff10 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h4 y4d9 fff fs2 fc0 sc0 ls8 ws1">这个函数接受两个参数。第一个参数应该是一个函数，第二个参数应该是要传递给该函数的一个值。</div><div class="t m0 x0 h5 y4da fff fs2 fc0 sc0 ls8 ws1">然后，就可以像下面的例子一样传递函数了。 </div><div class="t m0 x0 hb y4db ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4dc ff10 fs6 fc0 sc0 ls21 wsb">function add10(num){ </div><div class="t m0 x0 hb y4dd ff10 fs6 fc0 sc0 ls21 wsb">    return num + 10; </div><div class="t m0 x0 hb y4de ff10 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y4df ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4e0 ff10 fs6 fc0 sc0 ls21 wsb">var result1 = callSomeFunction(add10, 10); </div><div class="t m0 x0 hb y4e1 ff10 fs6 fc0 sc0 ls21 wsb">alert(result1);   //20 </div><div class="t m0 x0 hb y4e2 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4e3 ff10 fs6 fc0 sc0 ls21 wsb">function getGreeting(name){ </div><div class="t m0 x0 hb y4e4 ff10 fs6 fc0 sc0 ls21 wsb">    return &quot;Hello, &quot; + name; </div><div class="t m0 x0 hb y4e5 ff10 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y4e6 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4e7 ff10 fs6 fc0 sc0 ls21 wsb">var result2 = callSomeFunction(getGreeting, &quot;Nicholas&quot;); </div><div class="t m0 x0 hb y4e8 ff10 fs6 fc0 sc0 ls21 wsb">alert(result2);   //&quot;Hello, Nicholas&quot; </div><div class="t m0 x4 hf y4e9 ff12 fs2 fc0 sc0 ls79 wsb">FunctionAsAnArgumentExample01.htm </div><div class="t m0 x6 hb y4ea ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y4eb fff fs2 fc0 sc0 ls8 ws1">这里的callSomeFunction()函数是通用的，即无论第一个参数中传递进来的是什么函数，它都</div><div class="t m0 x0 h4 y4ec fff fs2 fc0 sc0 ls8 ws1">会返回执行第一个参数后的结果。还记得吧，要访问函数的指针而不执行函数的话，必须去掉函数名后</div><div class="t m0 x0 h3f y4ed fff fs2 fc0 sc0 ls8 ws1">面的那对圆括号。因此上面例子中传递给callSomeFunction()的是add10和getGreeting，而不</div><div class="t m0 x0 h5 y4ee fff fs2 fc0 sc0 ls8 ws1">是执行它们之后的结果。 </div></div></div>
<div id="pf83" class="pf w0 h0" data-page-no="83"><div class="pc pc83 w0 h0"><div class="t m0 x2 h2 y1 ff8 fs0 fc0 sc0 ls10 wsc">5.5 Function类型   113 </div><div class="t m0 x0 h3 y2 ff8 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffa fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ffa fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffa fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffa fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffa fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffa fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffa fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffa fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffa fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffa fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffa fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffa fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ffa fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h4 y3 fff fs2 fc0 sc0 ls24 ws1e">当然，可以从一个函数中返回另一个函数，而且这也是极为有用的一种技术。例如，假设有一个</div><div class="t m0 x0 h1e y4d fff fs2 fc0 sc0 ls5 ws4">对象数组，我们想要根据某个对象属性对数组进行排序。而传递给数组sort()方法的比较函数要接收</div><div class="t m0 x0 h4 y5 fff fs2 fc0 sc0 ls24">两个参数，即要比较的值。可是，我们需要一种方式来指明按照哪个属性来排序。要解决这个问题，</div><div class="t m0 x0 h4 y6 fff fs2 fc0 sc0 ls24">可以定义一个函数，它接收一个属性名，然后根据这个属性名来创建一个比较函数，下面就是这个函</div><div class="t m0 x0 h5 y7 fff fs2 fc0 sc0 ls5">数的定义。 </div><div class="t m0 x5 hb y4ef ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4f0 ff10 fs6 fc0 sc0 ls21 wsb">function createComparisonFunction(propertyName) { </div><div class="t m0 x0 hb y4f1 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4f2 ff10 fs6 fc0 sc0 ls21 wsb">    return function(object1, object2){ </div><div class="t m0 x0 hb y4f3 ff10 fs6 fc0 sc0 ls21 wsb">        var value1 = object1[propertyName]; </div><div class="t m0 x0 hb y4f4 ff10 fs6 fc0 sc0 ls21 wsb">        var value2 = object2[propertyName]; </div><div class="t m0 x0 hb y4f5 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4f6 ff10 fs6 fc0 sc0 ls21 wsb">        if (value1 &lt; value2){ </div><div class="t m0 x0 hb y4f7 ff10 fs6 fc0 sc0 ls21 wsb">            return -1; </div><div class="t m0 x0 hb y4f8 ff10 fs6 fc0 sc0 ls21 wsb">        } else if (value1 &gt; value2){ </div><div class="t m0 x0 hb y4f9 ff10 fs6 fc0 sc0 ls21 wsb">            return 1; </div><div class="t m0 x0 hb y4fa ff10 fs6 fc0 sc0 ls21 wsb">        } else { </div><div class="t m0 x0 hb y4fb ff10 fs6 fc0 sc0 ls21 wsb">            return 0; </div><div class="t m0 x0 hb y4fc ff10 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y4fd ff10 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 hb y4fe ff10 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x4 hf y4ff ff12 fs2 fc0 sc0 ls79 wsb">FunctionReturningFunctionExample01.htm </div><div class="t m0 x0 h4 y500 fff fs2 fc0 sc0 ls8 ws1">这个函数定义看起来有点复杂，但实际上无非就是在一个函数中嵌套了另一个函数，而且内部函数</div><div class="t m0 x0 h4 y501 fff fs2 fc0 sc0 ls8 ws1">前面加了一个return操作符。在内部函数接收到propertyName 参数后，它会使用方括号表示法来</div><div class="t m0 x0 h4 y502 fff fs2 fc0 sc0 ls8 ws1">取得给定属性的值。取得了想要的属性值之后，定义比较函数就非常简单了。上面这个函数可以像在下</div><div class="t m0 x0 h5 y503 fff fs2 fc0 sc0 ls8 ws1">面例子中这样使用。 </div><div class="t m0 x5 hb y2c3 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y504 ff10 fs6 fc0 sc0 ls21 wsb">var data = [{name: &quot;Zachary&quot;, age: 28}, {name: &quot;Nicholas&quot;, age: 29}]; </div><div class="t m0 x0 hb y505 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y506 ff10 fs6 fc0 sc0 ls21 wsb">data.sort(createComparisonFunction(&quot;name&quot;)); </div><div class="t m0 x0 hb y507 ff10 fs6 fc0 sc0 ls21 wsb">alert(data[0].name);  //Nicholas </div><div class="t m0 x0 hb y508 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y509 ff10 fs6 fc0 sc0 ls21 wsb">data.sort(createComparisonFunction(&quot;age&quot;)); </div><div class="t m0 x0 hb y50a ff10 fs6 fc0 sc0 ls21 wsb">alert(data[0].name);  //Zachary    </div><div class="t m0 x5 hb y50b ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y50c fff fs2 fc0 sc0 ls8 ws1">这里，我们创建了一个包含两个对象的数组data。其中，每个对象都包含一个name属性和一个</div><div class="t m0 x0 h4 y50d ff10 fs1 fc0 sc0 ls9 ws2">age属性。在默认情况下，sort()方法会调用每个对象的toString()方法以确定它们的次序；但得</div><div class="t m0 x0 h1e y50e fff fs2 fc0 sc0 ls6 ws6">到的结果往往并不符合人类的思维习惯。因此，我们调用createComparisonFunction(&quot;name&quot;)方</div><div class="t m0 x0 h1e y50f fff fs2 fc0 sc0 ls8 ws1">法创建了一个比较函数，以便按照每个对象的name属性值进行排序。而结果排在前面的第一项是name</div><div class="t m0 x0 h5 y510 fff fs2 fc0 sc0 ls8 ws1">为&quot;Nicholas&quot;，age是29的对象。然后，我们又使用了createComparisonFunction(&quot;age&quot;)返回</div><div class="t m0 x0 h5 y511 fff fs2 fc0 sc0 ls8 ws1">的比较函数，这次是按照对象的age属性排序。得到的结果是name值为&quot;Zachary&quot;，age 值是28的</div><div class="t m0 x0 h5 y512 fff fs2 fc0 sc0 ls8 ws1">对象排在了第一位。 </div><div class="t m0 x0 h20 y513 ffe fs3 fc0 sc0 ls4d ws40">5.5.4 函数内部属性 </div><div class="t m0 x0 h5 y514 fff fs2 fc0 sc0 ls8 ws1">在函数内部，有两个特殊的对象：arguments和this。其中，arguments在第3章曾经介绍过，</div><div class="t m0 x0 h1e y515 fff fs2 fc0 sc0 ls8 ws1">它是一个类数组对象，包含着传入函数中的所有参数。虽然arguments的主要用途是保存函数参数，</div><div class="t m0 x0 h1e y516 fff fs2 fc0 sc0 ls8 ws1">但这个对象还有一个名叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。</div><div class="t m0 x0 h5 y517 fff fs2 fc0 sc0 ls8 ws1">请看下面这个非常经典的阶乘函数。 </div></div></div>
<div id="pf84" class="pf w0 h0" data-page-no="84"><div class="pc pc84 w0 h0"><div class="t m0 x0 h2 y1 ff8 fs0 fc0 sc0 lsc2 wsa0">114  第5章 引用类型 </div><div class="t m0 x0 h3 y2 ff8 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y518 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y519 ff10 fs6 fc0 sc0 ls21 wsb">function factorial(num){ </div><div class="t m0 x0 hb y51a ff10 fs6 fc0 sc0 ls21 wsb">    if (num &lt;=1) { </div><div class="t m0 x0 hb y51b ff10 fs6 fc0 sc0 ls21 wsb">        return 1; </div><div class="t m0 x0 hb y51c ff10 fs6 fc0 sc0 ls21 wsb">    } else { </div><div class="t m0 x0 hb y51d ff10 fs6 fc0 sc0 ls21 wsb">        return num * factorial(num-1) </div><div class="t m0 x0 hb y51e ff10 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y51f ff10 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h4 y30c fff fs2 fc0 sc0 ls8 ws1">定义阶乘函数一般都要用到递归算法；如上面的代码所示，在函数有名字，而且名字以后也不会变</div><div class="t m0 x0 h1e y520 fff fs2 fc0 sc0 ls8 ws1">的情况下，这样定义没有问题。但问题是这个函数的执行与函数名factorial紧紧耦合在了一起。为</div><div class="t m0 x0 hc y521 fff fs2 fc0 sc0 ls8 ws1">了消除这种紧密耦合的现象，可以像下面这样使用arguments.callee。 </div><div class="t m0 x0 hb y522 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2e0 ff10 fs6 fc0 sc0 ls21 wsb">function factorial(num){ </div><div class="t m0 x0 hb y523 ff10 fs6 fc0 sc0 ls21 wsb">    if (num &lt;=1) { </div><div class="t m0 x0 hb y524 ff10 fs6 fc0 sc0 ls21 wsb">        return 1; </div><div class="t m0 x0 hb y525 ff10 fs6 fc0 sc0 ls21 wsb">    } else { </div><div class="t m0 x0 h15 y526 ff11 fs6 fc0 sc0 ls21 wsb">        return num * arguments.callee(num-1) </div><div class="t m0 x0 hb y527 ff10 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y528 ff10 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x4 hf y529 ff12 fs2 fc0 sc0 ls1b wsb">FunctionTypeArgumentsExample01.htm </div><div class="t m0 x0 h4 y52a fff fs2 fc0 sc0 ls8 ws1">在这个重写后的factorial()函数的函数体内，没有再引用函数名factorial。这样，无论引用</div><div class="t m0 x0 h5 y52b fff fs2 fc0 sc0 ls8 ws1">函数时使用的是什么名字，都可以保证正常完成递归调用。例如： </div><div class="t m0 x0 hb y52c ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y52d ff10 fs6 fc0 sc0 ls21 wsb">var trueFactorial = factorial; </div><div class="t m0 x0 hb y52e ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y52f ff10 fs6 fc0 sc0 ls21 wsb">factorial = function(){ </div><div class="t m0 x0 hb y530 ff10 fs6 fc0 sc0 ls21 wsb">    return 0; </div><div class="t m0 x0 hb y531 ff10 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y532 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y533 ff10 fs6 fc0 sc0 ls21 wsb">alert(trueFactorial(5));     //120 </div><div class="t m0 x0 hb y534 ff10 fs6 fc0 sc0 ls21 wsb">alert(factorial(5));         //0 </div><div class="t m0 x0 hb y535 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 yc4 fff fs2 fc0 sc0 ls8 ws1">在此，变量trueFactorial获得了factorial的值，实际上是在另一个位置上保存了一个函数</div><div class="t m0 x0 h5 y536 fff fs2 fc0 sc0 ls8 ws1">的指针。然后，我们又将一个简单地返回0的函数赋值给factorial变量。如果像原来的factorial()</div><div class="t m0 x0 h5 y537 fff fs2 fc0 sc0 ls8 ws1">那样不使用arguments.callee，调用trueFactorial()就会返回0。可是，在解除了函数体内的代</div><div class="t m0 x0 h1e y538 fff fs2 fc0 sc0 ls8 ws1">码与函数名的耦合状态之后，trueFactorial()仍然能够正常地计算阶乘；至于factorial()，它现</div><div class="t m0 x0 h5 y539 fff fs2 fc0 sc0 ls8 ws1">在只是一个返回0的函数。 </div><div class="t m0 x0 he y53a fff fs2 fc0 sc0 ls8 ws1">函数内部的另一个特殊对象是this，其行为与Java和C#中的this 大致类似。换句话说，this</div><div class="t m0 x0 h4 y53b fff fs2 fc0 sc0 ls8 ws1">引用的是函数据以执行的环境对象——或者也可以说是this值（当在网页的全局作用域中调用函数时，</div><div class="t m0 x0 h5 y53c ff10 fs1 fc0 sc0 ls9 ws2">this对象引用的就是window）。来看下面的例子。 </div><div class="t m0 x0 hb y53d ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y53e ff10 fs6 fc0 sc0 ls21 wsb">window.color = &quot;red&quot;; </div><div class="t m0 x0 hb y53f ff10 fs6 fc0 sc0 ls21 wsb">var o = { color: &quot;blue&quot; }; </div><div class="t m0 x0 hb y540 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y541 ff10 fs6 fc0 sc0 ls21 wsb">function sayColor(){ </div><div class="t m0 x0 hb y542 ff10 fs6 fc0 sc0 ls21 wsb">    alert(this.color); </div><div class="t m0 x0 hb y543 ff10 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y544 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y545 ff10 fs6 fc0 sc0 ls21 wsb">sayColor();     //&quot;red&quot; </div><div class="t m0 x0 hb y546 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y547 ff10 fs6 fc0 sc0 ls21 wsb">o.sayColor = sayColor; </div><div class="t m0 x0 hb y548 ff10 fs6 fc0 sc0 ls21 wsb">o.sayColor();   //&quot;blue&quot; </div><div class="t m0 x0 hb y549 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y54a ff12 fs2 fc0 sc0 ls25 wsb">FunctionTypeThisExample01.htm </div></div></div>
<div id="pf85" class="pf w0 h0" data-page-no="85"><div class="pc pc85 w0 h0"><div class="t m0 x2 h2 y1 ff8 fs0 fc0 sc0 ls10 wsc">5.5 Function类型   115 </div><div class="t m0 x0 h3 y2 ff8 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffa fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ffa fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffa fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffa fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffa fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffa fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffa fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffa fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffa fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffa fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffa fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffa fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ffa fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h4 y3 fff fs2 fc0 sc0 ls8 ws1">上面这个函数sayColor()是在全局作用域中定义的，它引用了this对象。由于在调用函数之前，</div><div class="t m0 x0 h4 y4 ff10 fs1 fc0 sc0 ls9 ws2">this的值并不确定，因此this 可能会在代码执行过程中引用不同的对象。当在全局作用域中调用</div><div class="t m0 x0 h4 y4e ff10 fs1 fc0 sc0 ls9 ws2">sayColor()时，this引用的是全局对象window；换句话说，对 this.color求值会转换成对</div><div class="t m0 x0 h4 yd9 ff10 fs1 fc0 sc0 ls9 ws2">window.color求值，于是结果就返回了&quot;red&quot;。而当把这个函数赋给对象o并调用o.sayColor()</div><div class="t m0 x0 h5 y219 fff fs2 fc0 sc0 ls8 ws1">时，this引用的是对象o，因此对this.color求值会转换成对o.color求值，结果就返回了&quot;blue&quot;。 </div><div class="t m0 x5 ha y54b ff9 fs2 fc0 sc0 ls8 ws14">请读者一定要牢记，函数的名字仅仅是一个包含指针的变量而已。因此，即使是</div><div class="t m0 x5 ha y54c ff9 fs2 fc0 sc0 ls8 ws14">在不同的环境中执行，全局的sayColor()函数与o.sayColor()指向的仍然是同一</div><div class="t m0 x5 h5 y54d ff9 fs2 fc0 sc0 ls8">个函数。 </div><div class="t m0 x0 h5 y54e ff8 fs2 fc0 sc0 ls25 ws61">ECMAScript 5也规范化了另一个函数对象的属性：caller。除了Opera的早期版本不支持，其他</div><div class="t m0 x0 h5 y54f fff fs2 fc0 sc0 ls8 ws1">浏览器都支持这个ECMAScript 3并没有定义的属性。这个属性中保存着调用当前函数的函数的引用，</div><div class="t m0 x0 he y550 fff fs2 fc0 sc0 ls8 ws1">如果是在全局作用域中调用当前函数，它的值为null。例如： </div><div class="t m0 x0 hb y551 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y552 ff10 fs6 fc0 sc0 ls21 wsb">function outer(){ </div><div class="t m0 x0 hb y553 ff10 fs6 fc0 sc0 ls21 wsb">    inner();  </div><div class="t m0 x0 hb y554 ff10 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y555 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y556 ff10 fs6 fc0 sc0 ls21 wsb">function inner(){ </div><div class="t m0 x0 hb y557 ff10 fs6 fc0 sc0 ls21 wsb">    alert(inner.caller); </div><div class="t m0 x0 hb y558 ff10 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y559 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y55a ff10 fs6 fc0 sc0 ls21 wsb">outer(); </div><div class="t m0 x0 hb y55b ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf y55c ff12 fs2 fc0 sc0 ls2b wsb">FunctionTypeArgumentsCallerExample01.htm </div><div class="t m0 x0 h4 y55d fff fs2 fc0 sc0 ls4 ws3">以上代码会导致警告框中显示outer()函数的源代码。因为outer()调用了 inter()，所以</div><div class="t m0 x0 h4 y55e ff10 fs1 fc0 sc0 ls9 ws2">inner.caller就指向outer()。为了实现更松散的耦合，也可以通过arguments.callee.caller</div><div class="t m0 x0 h5 y43e fff fs2 fc0 sc0 ls8 ws1">来访问相同的信息。 </div><div class="t m0 x0 hb y55f ff10 fs6 fc0 sc0 ls21 wsb">function outer(){ </div><div class="t m0 x0 hb y560 ff10 fs6 fc0 sc0 ls21 wsb">    inner(); </div><div class="t m0 x0 hb y561 ff10 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y562 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y563 ff10 fs6 fc0 sc0 ls21 wsb">function inner(){ </div><div class="t m0 x0 hb y564 ff10 fs6 fc0 sc0 ls21 wsb">    alert(arguments.callee.caller); </div><div class="t m0 x0 hb y565 ff10 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 hb y566 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y567 ff10 fs6 fc0 sc0 ls21 wsb">outer(); </div><div class="t m0 x4 hf y568 ff12 fs2 fc0 sc0 ls2b wsb">FunctionTypeArgumentsCallerExample02.htm </div><div class="t m0 x0 h5 y569 ff8 fs2 fc0 sc0 lse ws9">IE、Firefox、Chrome和Safari的所有版本以及Opera 9.6都支持caller 属性。 </div><div class="t m0 x0 hc y56a fff fs2 fc0 sc0 ls55 ws49">当函数在严格模式下运行时，访问arguments.callee会导致错误。ECMAScript 5 还定义了</div><div class="t m0 x0 h4 y56b ff10 fs1 fc0 sc0 ls9 ws2">arguments.caller属性，但在严格模式下访问它也会导致错误，而在非严格模式下这个属性始终是</div><div class="t m0 x0 h4 y56c ff10 fs1 fc0 sc0 ls9 ws2">undefined。定义这个属性是为了分清arguments.caller和函数的caller属性。以上变化都是为</div><div class="t m0 x0 h5 y56d fff fs2 fc0 sc0 ls8 ws1">了加强这门语言的安全性，这样第三方代码就不能在相同的环境里窥视其他代码了。 </div><div class="t m0 x0 he y56e fff fs2 fc0 sc0 ls8 ws1">严格模式还有一个限制：不能为函数的caller属性赋值，否则会导致错误。 </div></div></div>
<div id="pf86" class="pf w0 h0" data-page-no="86"><div class="pc pc86 w0 h0"><div class="t m0 x0 h2 y1 ff8 fs0 fc0 sc0 lsc2 wsa0">116  第5章 引用类型 </div><div class="t m0 x0 h3 y2 ff8 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h20 y56f ffe fs3 fc0 sc0 ls4d ws40">5.5.5 函数属性和方法 </div><div class="t m0 x0 h5 y12e fff fs2 fc0 sc0 ls6 ws6">前面曾经提到过，ECMAScript中的函数是对象，因此函数也有属性和方法。每个函数都包含两个</div><div class="t m0 x0 h4 y12f fff fs2 fc0 sc0 ls8 ws1">属性：length和prototype。其中，length属性表示函数希望接收的命名参数的个数，如下面的例</div><div class="t m0 x0 h5 y130 fff fs2 fc0 sc0 ls8">子所示。 </div><div class="t m0 x0 hb y570 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y571 ff10 fs6 fc0 sc0 ls21 wsb">function sayName(name){ </div><div class="t m0 x0 hb y572 ff10 fs6 fc0 sc0 ls21 wsb">    alert(name); </div><div class="t m0 x0 hb y573 ff10 fs6 fc0 sc0 ls21 wsb">}       </div><div class="t m0 x0 hb y574 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y575 ff10 fs6 fc0 sc0 ls21 wsb">function sum(num1, num2){ </div><div class="t m0 x0 hb y576 ff10 fs6 fc0 sc0 ls21 wsb">    return num1 + num2; </div><div class="t m0 x0 hb y577 ff10 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y578 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y579 ff10 fs6 fc0 sc0 ls21 wsb">function sayHi(){ </div><div class="t m0 x0 hb y57a ff10 fs6 fc0 sc0 ls21 wsb">    alert(&quot;hi&quot;); </div><div class="t m0 x0 hb y57b ff10 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y57c ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y57d ff10 fs6 fc0 sc0 ls21 wsb">alert(sayName.length);      //1 </div><div class="t m0 x0 hb y57e ff10 fs6 fc0 sc0 ls21 wsb">alert(sum.length);          //2 </div><div class="t m0 x0 hb y57f ff10 fs6 fc0 sc0 ls21 wsb">alert(sayHi.length);        //0 </div><div class="t m0 x0 hb y580 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf y581 ff12 fs2 fc0 sc0 ls5e wsb">FunctionTypeLengthPropertyExample01.htm </div><div class="t m0 x0 h5 y582 fff fs2 fc0 sc0 ls8 ws1">以上代码定义了3个函数，但每个函数接收的命名参数个数不同。首先，sayName()函数定义了一</div><div class="t m0 x0 hc y583 fff fs2 fc0 sc0 ls8 ws1">个参数，因此其length属性的值为1。类似地，sum()函数定义了两个参数，结果其length 属性中</div><div class="t m0 x0 hc y584 fff fs2 fc0 sc0 ls8 ws1">保存的值为2。而sayHi()没有命名参数，所以其length值为0。 </div><div class="t m0 x0 h5 y585 fff fs2 fc0 sc0 lscc">在ECMAScript核心所定义的全部属性中，最耐人寻味的就要数prototype 属性了。对于</div><div class="t m0 x0 h5 y586 ff8 fs2 fc0 sc0 ls1a ws1c">ECMAScript中的引用类型而言，prototype是保存它们所有实例方法的真正所在。换句话说，诸如</div><div class="t m0 x0 h4 y587 ff10 fs1 fc0 sc0 ls9 ws2">toString()和valueOf()等方法实际上都保存在prototype名下，只不过是通过各自对象的实例访</div><div class="t m0 x0 hc y588 fff fs2 fc0 sc0 ls8 ws1">问罢了。在创建自定义引用类型以及实现继承时，prototype属性的作用是极为重要的（第6章将详</div><div class="t m0 x0 h5 y589 fff fs2 fc0 sc0 ls8 ws1">细介绍）。在ECMAScript 5中，prototype属性是不可枚举的，因此使用for-in无法发现。 </div><div class="t m0 x0 h1e y58a fff fs2 fc0 sc0 ls8 ws1">每个函数都包含两个非继承而来的方法：apply()和call()。这两个方法的用途都是在特定的作</div><div class="t m0 x0 h1e y58b fff fs2 fc0 sc0 ls8 ws1">用域中调用函数，实际上等于设置函数体内this对象的值。首先，apply()方法接收两个参数：一个</div><div class="t m0 x0 h1e y58c fff fs2 fc0 sc0 ls8 ws1">是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是Array的实例，也可以是</div><div class="t m0 x0 h5 y58d ff10 fs1 fc0 sc0 ls9 ws2">arguments对象。例如： </div><div class="t m0 x0 hb y58e ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y58f ff10 fs6 fc0 sc0 ls21 wsb">function sum(num1, num2){ </div><div class="t m0 x0 hb y590 ff10 fs6 fc0 sc0 ls21 wsb">    return num1 + num2; </div><div class="t m0 x0 hb y591 ff10 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y592 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y593 ff10 fs6 fc0 sc0 ls21 wsb">function callSum1(num1, num2){ </div><div class="t m0 x0 h16 y594 ff10 fs6 fc0 sc0 ls21 wsb">    return sum.apply(this, arguments);        // 传入arguments对象 </div><div class="t m0 x0 hb y595 ff10 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y596 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y597 ff10 fs6 fc0 sc0 ls21 wsb">function callSum2(num1, num2){ </div><div class="t m0 x0 h16 y598 ff10 fs6 fc0 sc0 ls21 wsb">    return sum.apply(this, [num1, num2]);    // 传入数组 </div><div class="t m0 x0 hb y599 ff10 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y59a ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y59b ff10 fs6 fc0 sc0 ls21 wsb">alert(callSum1(10,10));   //20 </div><div class="t m0 x0 hb y59c ff10 fs6 fc0 sc0 ls21 wsb">alert(callSum2(10,10));   //20 </div><div class="t m0 x4 hf y59d ff12 fs2 fc0 sc0 ls1b wsb">FunctionTypeApplyMethodExample01.htm </div></div></div>
<div id="pf87" class="pf w0 h0" data-page-no="87"><div class="pc pc87 w0 h0"><div class="t m0 x2 h2 y1 ff8 fs0 fc0 sc0 ls10 wsc">5.5 Function类型   117 </div><div class="t m0 x0 h3 y2 ff8 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffa fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ffa fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffa fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffa fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffa fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffa fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffa fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffa fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffa fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffa fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffa fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffa fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ffa fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h4 y3 fff fs2 fc0 sc0 ls5 ws4">在上面这个例子中，callSum1()在执行sum()函数时传入了this作为this值（因为是在全局</div><div class="t m0 x0 h1e y4d fff fs2 fc0 sc0 ls5 ws4">作用域中调用的，所以传入的就是window对象）和arguments 对象。而callSum2同样也调用了</div><div class="t m0 x0 h5 y4e ff10 fs1 fc0 sc0 ls16 ws17">sum()函数，但它传入的则是this和一个参数数组。这两个函数都会正常执行并返回正确的结果。 </div><div class="t m0 x5 h40 y59e ff9 fs2 fc0 sc0 ls8 ws14">在严格模式下，未指定环境对象而调用函数，则this值不会转型为window。</div><div class="t m0 x5 ha y59f ff9 fs2 fc0 sc0 ls8 ws14">除非明确把函数添加到某个对象或者调用apply()或call()，否则this 值将是</div><div class="t m0 x5 h5 y5a0 ff10 fs1 fc0 sc0 ls9 ws2">undefined。 </div><div class="t m0 x0 h4 y5a1 ff10 fs1 fc0 sc0 ls9 ws2">call()方法与apply()方法的作用相同，它们的区别仅在于接收参数的方式不同。对于call()</div><div class="t m0 x0 h4 y5a2 fff fs2 fc0 sc0 ls8 ws1">方法而言，第一个参数是this值没有变化，变化的是其余参数都直接传递给函数。换句话说，在使用</div><div class="t m0 x0 h5 y5a3 ff10 fs1 fc0 sc0 ls9 ws2">call()方法时，传递给函数的参数必须逐个列举出来，如下面的例子所示。 </div><div class="t m0 x5 hb y5a4 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y5a5 ff10 fs6 fc0 sc0 ls21 wsb">function sum(num1, num2){ </div><div class="t m0 x0 hb y5a6 ff10 fs6 fc0 sc0 ls21 wsb">    return num1 + num2; </div><div class="t m0 x0 hb y5a7 ff10 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y5a8 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y5a9 ff10 fs6 fc0 sc0 ls21 wsb">function callSum(num1, num2){ </div><div class="t m0 x0 h15 y5aa ff11 fs6 fc0 sc0 ls21 wsb">    return sum.call(this, num1, num2); </div><div class="t m0 x0 hb y5ab ff10 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y5ac ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y5ad ff10 fs6 fc0 sc0 ls21 wsb">alert(callSum(10,10));   //20 </div><div class="t m0 x5 hb y5ae ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf y5af ff12 fs2 fc0 sc0 ls79 wsb">FunctionTypeCallMethodExample01.htm </div><div class="t m0 x0 h4 y5b0 fff fs2 fc0 sc0 ls8 ws1">在使用call()方法的情况下，callSum()必须明确地传入每一个参数。结果与使用apply()没有</div><div class="t m0 x0 h4 y5b1 fff fs2 fc0 sc0 ls8 ws1">什么不同。至于是使用apply()还是call()，完全取决于你采取哪种给函数传递参数的方式最方便。</div><div class="t m0 x0 h1e y5b2 fff fs2 fc0 sc0 ls8 ws1">如果你打算直接传入arguments对象，或者包含函数中先接收到的也是一个数组，那么使用apply()</div><div class="t m0 x0 h4 y5b3 fff fs2 fc0 sc0 ls5 ws4">肯定更方便；否则，选择call()可能更合适。（在不给函数传递参数的情况下，使用哪个方法都无所</div><div class="t m0 x0 h5 y5b4 fff fs2 fc0 sc0 ls5 ws4">谓。） </div><div class="t m0 x0 h1c y5b5 fff fs2 fc0 sc0 ls8 ws1">事实上，传递参数并非apply()和call()真正的用武之地；它们真正强大的地方是能够扩充函数</div><div class="t m0 x0 h5 y5b6 fff fs2 fc0 sc0 ls8 ws1">赖以运行的作用域。下面来看一个例子。 </div><div class="t m0 x0 hb y5b7 ff10 fs6 fc0 sc0 ls21 wsb">window.color = &quot;red&quot;; </div><div class="t m0 x0 hb y5b8 ff10 fs6 fc0 sc0 ls21 wsb">var o = { color: &quot;blue&quot; }; </div><div class="t m0 x0 hb y5b9 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y5ba ff10 fs6 fc0 sc0 ls21 wsb">function sayColor(){ </div><div class="t m0 x0 hb y5bb ff10 fs6 fc0 sc0 ls21 wsb">    alert(this.color); </div><div class="t m0 x0 hb y5bc ff10 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y5bd ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y5be ff10 fs6 fc0 sc0 ls21 wsb">sayColor();                //red </div><div class="t m0 x0 hb y5bf ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y5c0 ff11 fs6 fc0 sc0 ls21 wsb">sayColor.call(this);       //red </div><div class="t m0 x0 h15 y5c1 ff11 fs6 fc0 sc0 ls21 wsb">sayColor.call(window);     //red </div><div class="t m0 x0 h15 y5c2 ff11 fs6 fc0 sc0 ls21 wsb">sayColor.call(o);          //blue </div><div class="t m0 x5 hb y5c3 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y5c4 ff12 fs2 fc0 sc0 ls79 wsb">FunctionTypeCallExample01.htm </div><div class="t m0 x0 h4 y5c5 fff fs2 fc0 sc0 ls8 ws1">这个例子是在前面说明this对象的示例基础上修改而成的。这一次，sayColor()也是作为全局</div><div class="t m0 x0 h1e y5c6 fff fs2 fc0 sc0 ls8 ws1">函数定义的，而且当在全局作用域中调用它时，它确实会显示&quot;red&quot;——因为对this.color的求值会</div></div></div>
<div id="pf88" class="pf w0 h0" data-page-no="88"><div class="pc pc88 w0 h0"><div class="t m0 x0 h2 y1 ff8 fs0 fc0 sc0 lsc2 wsa0">118  第5章 引用类型 </div><div class="t m0 x0 h3 y2 ff8 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 fff fs2 fc0 sc0 ls8 ws1">转换成对window.color的求值。而sayColor.call(this)和sayColor.call(window)，则是两</div><div class="t m0 x0 h1e y4d fff fs2 fc0 sc0 ls8 ws1">种显式地在全局作用域中调用函数的方式，结果当然都会显示&quot;red&quot;。但是，当运行sayColor.call(o)</div><div class="t m0 x0 h5 y4e fff fs2 fc0 sc0 ls8 ws1">时，函数的执行环境就不一样了，因为此时函数体内的this对象指向了o，于是结果显示的是&quot;blue&quot;。 </div><div class="t m0 x0 h4 yd9 fff fs2 fc0 sc0 ls8 ws1">使用call()（或apply()）来扩充作用域的最大好处，就是对象不需要与方法有任何耦合关系。</div><div class="t m0 x0 h1e y15d fff fs2 fc0 sc0 ls8 ws1">在前面例子的第一个版本中，我们是先将sayColor()函数放到了对象o中，然后再通过o来调用它的；</div><div class="t m0 x0 h5 y21a fff fs2 fc0 sc0 ls8 ws1">而在这里重写的例子中，就不需要先前那个多余的步骤了。 </div><div class="t m0 x0 h5 y5c8 ff8 fs2 fc0 sc0 ls25 ws61">ECMAScript 5还定义了一个方法：bind()。这个方法会创建一个函数的实例，其this值会被绑</div><div class="t m0 x0 hc y15f fff fs2 fc0 sc0 ls8 ws1">定到传给bind()函数的值。例如： </div><div class="t m0 x0 hb y5c9 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y5ca ff10 fs6 fc0 sc0 ls21 wsb">window.color = &quot;red&quot;; </div><div class="t m0 x0 hb y5cb ff10 fs6 fc0 sc0 ls21 wsb">var o = { color: &quot;blue&quot; }; </div><div class="t m0 x0 hb y5cc ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y5cd ff10 fs6 fc0 sc0 ls21 wsb">function sayColor(){ </div><div class="t m0 x0 hb y5ce ff10 fs6 fc0 sc0 ls21 wsb">    alert(this.color); </div><div class="t m0 x0 hb y5cf ff10 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h15 y5d0 ff11 fs6 fc0 sc0 ls21 wsb">var objectSayColor = sayColor.bind(o); </div><div class="t m0 x0 h15 y5d1 ff11 fs6 fc0 sc0 ls21 wsb">objectSayColor();    //blue </div><div class="t m0 x0 h15 y5d2 ff11 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf y5d3 ff12 fs2 fc0 sc0 ls2b wsb">FunctionTypeBindMethodExample01.htm </div><div class="t m0 x0 h5 y5d4 fff fs2 fc0 sc0 ls30 ws2a">在这里，sayColor()调用bind()并传入对象o，创建了 objectSayColor()函数。object- </div><div class="t m0 x0 h42 y5d5 ff10 fs1 fc0 sc0 ls9 ws2">SayColor()函数的this值等于o，因此即使是在全局作用域中调用这个函数，也会看到&quot;blue&quot;。这</div><div class="t m0 x0 h5 y5d6 fff fs2 fc0 sc0 ls8 ws1">种技巧的优点请参考第22章。 </div><div class="t m0 x0 hc y5d7 fff fs2 fc0 sc0 ls8 ws1">支持bind()方法的浏览器有IE9+、Firefox 4+、Safari 5.1+、Opera 12+和Chrome。 </div><div class="t m0 x0 h1e y5d8 fff fs2 fc0 sc0 ls8 ws1">每个函数继承的toLocaleString()和toString()方法始终都返回函数的代码。返回代码的格</div><div class="t m0 x0 h4 y5d9 fff fs2 fc0 sc0 ls24 ws1e">式则因浏览器而异——有的返回的代码与源代码中的函数代码一样，而有的则返回函数代码的内部表</div><div class="t m0 x0 h4 y5da fff fs2 fc0 sc0 ls8 ws1">示，即由解析器删除了注释并对某些代码作了改动后的代码。由于存在这些差异，我们无法根据这两个</div><div class="t m0 x0 h4 y5db fff fs2 fc0 sc0 ls4">方法返回的结果来实现任何重要功能；不过，这些信息在调试代码时倒是很有用。另外一个继承的</div><div class="t m0 x0 h5 y5dc ff10 fs1 fc0 sc0 ls9 ws2">valueOf()方法同样也只返回函数代码。 </div><div class="t m0 x0 hd y5dd ffe fs7 fc0 sc0 ls22">5.6 基本包装类型 </div><div class="t m0 x0 h5 y5de fff fs2 fc0 sc0 ls30 ws2a">为了便于操作基本类型值，ECMAScript还提供了3个特殊的引用类型：Boolean、Number 和</div><div class="t m0 x0 h4 y5df ff10 fs1 fc0 sc0 ls9 ws2">String。这些类型与本章介绍的其他引用类型相似，但同时也具有与各自的基本类型相应的特殊行为。</div><div class="t m0 x0 h4 y5e0 fff fs2 fc0 sc0 ls8 ws1">实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们</div><div class="t m0 x0 h5 y5e1 fff fs2 fc0 sc0 ls8 ws1">能够调用一些方法来操作这些数据。来看下面的例子。 </div><div class="t m0 x0 hb y5e2 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y5e3 ff10 fs6 fc0 sc0 ls21 wsb">var s1 = &quot;some text&quot;; </div><div class="t m0 x0 hb y5e4 ff10 fs6 fc0 sc0 ls21 wsb">var s2 = s1.substring(2); </div><div class="t m0 x0 hb y5e5 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y5e6 fff fs2 fc0 sc0 ls4c ws3e">这个例子中的变量s1包含一个字符串，字符串当然是基本类型值。而下一行调用了 s1的</div><div class="t m0 x0 h4 y1a4 ff10 fs1 fc0 sc0 ls9 ws2">substring()方法，并将返回的结果保存在了s2中。我们知道，基本类型值不是对象，因而从逻辑上</div><div class="t m0 x0 h4 y1a5 fff fs2 fc0 sc0 ls6 ws6">讲它们不应该有方法（尽管如我们所愿，它们确实有方法）。其实，为了让我们实现这种直观的操作，</div><div class="t m0 x0 h3f y5e7 fff fs2 fc0 sc0 ls8 ws1">后台已经自动完成了一系列的处理。当第二行代码访问s1时，访问过程处于一种读取模式，也就是要</div><div class="t m0 x0 h5 y5e8 fff fs2 fc0 sc0 ls8 ws1">从内存中读取这个字符串的值。而在读取模式中访问字符串时，后台都会自动完成下列处理。 </div></div></div>
<div id="pf89" class="pf w0 h0" data-page-no="89"><div class="pc pc89 w0 h0"><div class="t m0 x2 h2 y1 ff8 fs0 fc0 sc0 ls10 wsc">5.6 基本包装类型    119 </div><div class="t m0 x0 h3 y2 ff8 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffa fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ffa fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffa fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffa fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffa fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffa fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffa fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffa fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffa fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffa fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffa fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffa fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ffa fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff8 fs2 fc0 sc0 ls13 wsb">(1) 创建String类型的一个实例； </div><div class="t m0 x0 h5 y4d ff8 fs2 fc0 sc0 ls13 wsb">(2) 在实例上调用指定的方法； </div><div class="t m0 x0 h5 yd8 ff8 fs2 fc0 sc0 ls13 wsb">(3) 销毁这个实例。 </div><div class="t m0 x0 h5 y28b fff fs2 fc0 sc0 ls8 ws1">可以将以上三个步骤想象成是执行了下列ECMAScript代码。 </div><div class="t m0 x5 hb y5e9 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y5ea ff10 fs6 fc0 sc0 ls21 wsb">var s1 = new String(&quot;some text&quot;); </div><div class="t m0 x0 hb y5eb ff10 fs6 fc0 sc0 ls21 wsb">var s2 = s1.substring(2); </div><div class="t m0 x0 hb y5ec ff10 fs6 fc0 sc0 ls21 wsb">s1 = null; </div><div class="t m0 x5 hb y5ed ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y5ee fff fs2 fc0 sc0 ls8 ws1">经过此番处理，基本的字符串值就变得跟对象一样了。而且，上面这三个步骤也分别适用于Boolean</div><div class="t m0 x0 h5 y5ef fff fs2 fc0 sc0 ls2c">和Number类型对应的布尔值和数字值。 </div><div class="t m0 x0 h1e y5f0 fff fs2 fc0 sc0 ls8 ws1">引用类型与基本包装类型的主要区别就是对象的生存期。使用new操作符创建的引用类型的实例，</div><div class="t m0 x0 h4 y5f1 fff fs2 fc0 sc0 ls8 ws1">在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一</div><div class="t m0 x0 h4 y5f2 fff fs2 fc0 sc0 ls8 ws1">行代码的执行瞬间，然后立即被销毁。这意味着我们不能在运行时为基本类型值添加属性和方法。来看</div><div class="t m0 x0 h5 y5f3 fff fs2 fc0 sc0 ls8 ws1">下面的例子： </div><div class="t m0 x5 hb y5f4 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y5f5 ff10 fs6 fc0 sc0 ls21 wsb">var s1 = &quot;some text&quot;; </div><div class="t m0 x0 hb y5f6 ff10 fs6 fc0 sc0 ls21 wsb">s1.color = &quot;red&quot;; </div><div class="t m0 x0 hb y5f7 ff10 fs6 fc0 sc0 ls21 wsb">alert(s1.color);  //undefined </div><div class="t m0 x5 hb y5f8 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y5f9 fff fs2 fc0 sc0 ls8 ws1">在此，第二行代码试图为字符串s1添加一个color属性。但是，当第三行代码再次访问 s1时，</div><div class="t m0 x0 h1e y5fa fff fs2 fc0 sc0 lsd6">其color属性不见了。问题的原因就是第二行创建的String对象在执行第三行代码时已经被销毁了。</div><div class="t m0 x0 hc y5fb fff fs2 fc0 sc0 ls8 ws1">第三行代码又创建自己的String对象，而该对象没有color属性。 </div><div class="t m0 x0 h4 y5fc fff fs2 fc0 sc0 ls8 ws1">当然，可以显式地调用Boolean、Number和String来创建基本包装类型的对象。不过，应该在</div><div class="t m0 x0 h4 y5fd fff fs2 fc0 sc0 ls24 ws1e">绝对必要的情况下再这样做，因为这种做法很容易让人分不清自己是在处理基本类型还是引用类型的</div><div class="t m0 x0 h1c y5fe fff fs2 fc0 sc0 ls8 ws1">值。对基本包装类型的实例调用typeof会返回&quot;object&quot;，而且所有基本包装类型的对象都会被转换</div><div class="t m0 x0 hc y5ff fff fs2 fc0 sc0 ls8 ws1">为布尔值true。 </div><div class="t m0 x0 h5 y600 ff10 fs1 fc0 sc0 ls9 ws2">Object构造函数也会像工厂方法一样，根据传入值的类型返回相应基本包装类型的实例。例如： </div><div class="t m0 x0 hb y601 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y602 ff10 fs6 fc0 sc0 ls21 wsb">var obj = new Object(&quot;some text&quot;); </div><div class="t m0 x0 hb y603 ff10 fs6 fc0 sc0 ls21 wsb">alert(obj instanceof String);   //true </div><div class="t m0 x0 hb y604 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y605 fff fs2 fc0 sc0 ls8 ws1">把字符串传给Object构造函数，就会创建String的实例；而传入数值参数会得到Number 的实</div><div class="t m0 x0 hc y606 fff fs2 fc0 sc0 ls8 ws1">例，传入布尔值参数就会得到Boolean的实例。 </div><div class="t m0 x0 h5 y607 fff fs2 fc0 sc0 ls8 ws1">要注意的是，使用new调用基本包装类型的构造函数，与直接调用同名的转型函数是不一样的。 </div><div class="t m0 x0 h5 y608 fff fs2 fc0 sc0 ls8">例如： </div><div class="t m0 x0 hb y609 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y60a ff10 fs6 fc0 sc0 ls21 wsb">var value = &quot;25&quot;; </div><div class="t m0 x0 h16 y60b ff10 fs6 fc0 sc0 ls21 wsb">var number = Number(value);  //转型函数 </div><div class="t m0 x0 hb y60c ff10 fs6 fc0 sc0 ls21 wsb">alert(typeof number);        //&quot;number&quot; </div><div class="t m0 x0 hb y60d ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y60e ff10 fs6 fc0 sc0 ls21 wsb">var obj = new Number(value); //构造函数 </div><div class="t m0 x0 hb y60f ff10 fs6 fc0 sc0 ls21 wsb">alert(typeof obj);           //&quot;object&quot; </div><div class="t m0 x0 hb y610 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y611 fff fs2 fc0 sc0 ls8 ws1">在这个例子中，变量number中保存的是基本类型的值25，而变量obj 中保存的是Number的实</div><div class="t m0 x0 h5 y612 fff fs2 fc0 sc0 ls8 ws1">例。要了解有关转型函数的更多信息，请参考第3章。 </div><div class="t m0 x0 h4 y613 fff fs2 fc0 sc0 ls8 ws1">尽管我们不建议显式地创建基本包装类型的对象，但它们操作基本类型值的能力还是相当重要的。</div><div class="t m0 x0 h5 y614 fff fs2 fc0 sc0 ls8 ws1">而每个基本包装类型都提供了操作相应值的便捷方法。 </div></div></div>
<div id="pf8a" class="pf w0 h0" data-page-no="8a"><div class="pc pc8a w0 h0"><div class="t m0 x0 h2 y1 ff8 fs0 fc0 sc0 ls7 ws0">120  第5章 引用类型 </div><div class="t m0 x0 h3 y2 ff8 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h20 y12d ffe fs3 fc0 sc0 ls4d ws40">5.6.1 Boolean类型 </div><div class="t m0 x0 h4 y12e ff10 fs1 fc0 sc0 ls9 ws2">Boolean类型是与布尔值对应的引用类型。要创建Boolean对象，可以像下面这样调用Boolean</div><div class="t m0 x0 h5 y12f fff fs2 fc0 sc0 ls8 ws1">构造函数并传入true或false值。 </div><div class="t m0 x0 hb y49e ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y616 ff10 fs6 fc0 sc0 ls21 wsb">var booleanObject = new Boolean(true); </div><div class="t m0 x0 hb y617 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y618 ff10 fs1 fc0 sc0 ls9 ws2">Boolean类型的实例重写了valueOf()方法，返回基本类型值true或false；重写了toString()</div><div class="t m0 x0 h5 y619 fff fs2 fc0 sc0 ls8 ws1">方法，返回字符串&quot;true&quot;和&quot;false&quot;。可是，Boolean对象在ECMAScript中的用处不大，因为它经</div><div class="t m0 x0 hc y61a fff fs2 fc0 sc0 ls8 ws1">常会造成人们的误解。其中最常见的问题就是在布尔表达式中使用Boolean对象，例如： </div><div class="t m0 x0 hb y61b ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y61c ff10 fs6 fc0 sc0 ls21 wsb">var falseObject = new Boolean(false); </div><div class="t m0 x0 hb y61d ff10 fs6 fc0 sc0 ls21 wsb">var result = falseObject &amp;&amp; true; </div><div class="t m0 x0 hb y61e ff10 fs6 fc0 sc0 ls21 wsb">alert(result);  //true </div><div class="t m0 x0 hb y61f ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y620 ff10 fs6 fc0 sc0 ls21 wsb">var falseValue = false; </div><div class="t m0 x0 hb y621 ff10 fs6 fc0 sc0 ls21 wsb">result = falseValue &amp;&amp; true; </div><div class="t m0 x0 hb y622 ff10 fs6 fc0 sc0 ls21 wsb">alert(result);  //false </div><div class="t m0 x0 hb y623 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y624 ff12 fs2 fc0 sc0 ls1b wsb">BooleanTypeExample01.htm </div><div class="t m0 x0 h4 y625 fff fs2 fc0 sc0 ls8 ws1">在这个例子中，我们使用false值创建了一个Boolean对象。然后，将这个对象与基本类型值true</div><div class="t m0 x0 h4 y626 fff fs2 fc0 sc0 ls5 ws4">构成了逻辑与表达式。在布尔运算中，false &amp;&amp; true等于false。可是，示例中的这行代码是对</div><div class="t m0 x0 h4 y627 ff10 fs1 fc0 sc0 ls9 ws2">falseObject而不是对它的值（false）进行求值。前面讨论过，布尔表达式中的所有对象都会被转</div><div class="t m0 x0 h1e y628 fff fs2 fc0 sc0 ls8 ws1">换为true，因此falseObject对象在布尔表达式中代表的是true。结果，true &amp;&amp; true 当然就等</div><div class="t m0 x0 h5 y629 fff fs2 fc0 sc0 lsd9">于true了。 </div><div class="t m0 x0 h1e y62a fff fs2 fc0 sc0 ls8 ws1">基本类型与引用类型的布尔值还有两个区别。首先，typeof操作符对基本类型返回&quot;boolean&quot;，</div><div class="t m0 x0 h1e y5b2 fff fs2 fc0 sc0 ls8 ws1">而对引用类型返回&quot;object&quot;。其次，由于Boolean对象是Boolean类型的实例，所以使用instanceof</div><div class="t m0 x0 h5 y5b3 fff fs2 fc0 sc0 ls8 ws1">操作符测试Boolean对象会返回true，而测试基本类型的布尔值则返回false。例如： </div><div class="t m0 x0 hb y62b ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y62c ff10 fs6 fc0 sc0 ls21 wsb">alert(typeof falseObject);   //object </div><div class="t m0 x0 hb y62d ff10 fs6 fc0 sc0 ls21 wsb">alert(typeof falseValue);    //boolean </div><div class="t m0 x0 hb y62e ff10 fs6 fc0 sc0 ls21 wsb">alert(falseObject instanceof Boolean); //true </div><div class="t m0 x0 hb y62f ff10 fs6 fc0 sc0 ls21 wsb">alert(falseValue instanceof Boolean);  //false </div><div class="t m0 x0 hb y630 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y50d fff fs2 fc0 sc0 ls8 ws1">理解基本类型的布尔值与Boolean对象之间的区别非常重要——当然，我们的建议是永远不要使</div><div class="t m0 x0 hc y50e fff fs2 fc0 sc0 lsda">用Boolean对象。 </div><div class="t m0 x0 h20 y173 ffe fs3 fc0 sc0 ls4d ws40">5.6.2 Number类型 </div><div class="t m0 x0 h4 y631 ff10 fs1 fc0 sc0 ls9 ws2">Number是与数字值对应的引用类型。要创建Number对象，可以在调用 Number构造函数时向其</div><div class="t m0 x0 h5 y632 fff fs2 fc0 sc0 ls8 ws1">中传递相应的数值。下面是一个例子。 </div><div class="t m0 x0 hb y633 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y634 ff10 fs6 fc0 sc0 ls21 wsb">var numberObject = new Number(10); </div><div class="t m0 x0 hb y635 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y636 ff12 fs2 fc0 sc0 ls8 wsb">NumberTypeExample01.htm </div><div class="t m0 x0 h4 y637 fff fs2 fc0 sc0 lsdb">与Boolean类型一样，Number类型也重写了valueOf()、toLocaleString()和toString()</div><div class="t m0 x0 h4 y638 fff fs2 fc0 sc0 ls6 ws6">方法。重写后的valueOf()方法返回对象表示的基本类型的数值，另外两个方法则返回字符串形式的</div></div></div>
<div id="pf8b" class="pf w0 h0" data-page-no="8b"><div class="pc pc8b w0 h0"><div class="t m0 x2 h2 y1 ff8 fs0 fc0 sc0 ls10 wsc">5.6 基本包装类型    121 </div><div class="t m0 x0 h3 y2 ff8 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffa fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ffa fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffa fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffa fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffa fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffa fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffa fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffa fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffa fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffa fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffa fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffa fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ffa fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 fff fs2 fc0 sc0 ls8 ws1">数值。我们在第3章还介绍过，可以为toString()方法传递一个表示基数的参数，告诉它返回几进制</div><div class="t m0 x0 h5 y4d fff fs2 fc0 sc0 ls8 ws1">数值的字符串形式，如下面的例子所示。 </div><div class="t m0 x5 hb y2d8 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y639 ff10 fs6 fc0 sc0 ls21 wsb">var num = 10; </div><div class="t m0 x0 hb y63a ff10 fs6 fc0 sc0 ls21 wsb">alert(num.toString());     //&quot;10&quot; </div><div class="t m0 x0 hb y63b ff10 fs6 fc0 sc0 ls21 wsb">alert(num.toString(2));    //&quot;1010&quot; </div><div class="t m0 x0 hb y63c ff10 fs6 fc0 sc0 ls21 wsb">alert(num.toString(8));    //&quot;12&quot; </div><div class="t m0 x0 hb y63d ff10 fs6 fc0 sc0 ls21 wsb">alert(num.toString(10));   //&quot;10&quot; </div><div class="t m0 x0 hb y63e ff10 fs6 fc0 sc0 ls21 wsb">alert(num.toString(16));   //&quot;a&quot; </div><div class="t m0 x5 hb y63f ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y640 ff12 fs2 fc0 sc0 ls8 wsb">NumberTypeExample01.htm </div><div class="t m0 x0 h5 y10c fff fs2 fc0 sc0 ls8 ws1">除了继承的方法之外，Number类型还提供了一些用于将数值格式化为字符串的方法。 </div><div class="t m0 x0 h5 y641 fff fs2 fc0 sc0 ls8 ws1">其中，toFixed()方法会按照指定的小数位返回数值的字符串表示，例如： </div><div class="t m0 x5 hb y642 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y643 ff10 fs6 fc0 sc0 ls21 wsb">var num = 10; </div><div class="t m0 x0 h15 y644 ff11 fs6 fc0 sc0 ls21 wsb">alert(num.toFixed(2));     //&quot;10.00&quot; </div><div class="t m0 x5 hb y645 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y646 ff12 fs2 fc0 sc0 ls8 wsb">NumberTypeExample01.htm </div><div class="t m0 x0 h4 y647 fff fs2 fc0 sc0 ls8 ws1">这里给toFixed()方法传入了数值2，意思是显示几位小数。于是，这个方法返回了&quot;10.00&quot;，即</div><div class="t m0 x0 h5 y648 fff fs2 fc0 sc0 ls3b">以0填补了必要的小数位。如果数值本身包含的小数位比指定的还多，那么接近指定的最大小数位的值</div><div class="t m0 x0 h5 y649 fff fs2 fc0 sc0 ls8 ws1">就会舍入，如下面的例子所示。 </div><div class="t m0 x5 hb y364 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y64a ff10 fs6 fc0 sc0 ls21 wsb">var num = 10.005; </div><div class="t m0 x0 h15 y64b ff11 fs6 fc0 sc0 ls21 wsb">alert(num.toFixed(2));     //&quot;10.01&quot; </div><div class="t m0 x5 hb y64c ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y64d fff fs2 fc0 sc0 ls6 ws6">能够自动舍入的特性，使得toFixed()方法很适合处理货币值。但需要注意的是，不同浏览器给</div><div class="t m0 x0 h5 y64e fff fs2 fc0 sc0 ls8 ws1">这个方法设定的舍入规则可能会有所不同。在给toFixed()传入0的情况下，IE8及之前版本不能正确</div><div class="t m0 x0 h25 y64f fff fs2 fc0 sc0 ls8 ws1">舍入范围在{(0.94,0.5],[0.5,0.94)}之间的值。对于这个范围内的值，IE会返回0，而不是1或1；其他</div><div class="t m0 x0 h5 y650 fff fs2 fc0 sc0 ls8 ws1">浏览器都能返回正确的值。IE9修复了这个问题。 </div><div class="t m0 x5 h5 y651 ff10 fs1 fc0 sc0 ls9 ws2">toFixed()方法可以表示带有0到20个小数位的数值。但这只是标准实现的范</div><div class="t m0 x5 h5 y652 ff9 fs2 fc0 sc0 ls8 ws14">围，有些浏览器也可能支持更多位数。 </div><div class="t m0 x0 h44 y653 fff fs2 fc0 sc0 ls8 ws1">另外可用于格式化数值的方法是toExponential()，该方法返回以指数表示法（也称e表示法）</div><div class="t m0 x0 h1e y654 fff fs2 fc0 sc0 ls8 ws1">表示的数值的字符串形式。与toFixed()一样，toExponential()也接收一个参数，而且该参数同样</div><div class="t m0 x0 h5 y510 fff fs2 fc0 sc0 ls8 ws1">也是指定输出结果中的小数位数。看下面的例子。 </div><div class="t m0 x5 hb y655 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y656 ff10 fs6 fc0 sc0 ls21 wsb">var num = 10; </div><div class="t m0 x0 h15 y657 ff11 fs6 fc0 sc0 ls21 wsb">alert(num.toExponential(1));  //&quot;1.0e+1&quot; </div><div class="t m0 x5 hb y658 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y659 fff fs2 fc0 sc0 ls8 ws1">以上代码输出了&quot;1.0e+1&quot;；不过，这么小的数值一般不必使用e表示法。如果你想得到表示某个</div><div class="t m0 x0 h5 y65a fff fs2 fc0 sc0 ls8 ws1">数值的最合适的格式，就应该使用toPrecision()方法。 </div><div class="t m0 x0 hc y65b fff fs2 fc0 sc0 ls4 ws3">对于一个数值来说，toPrecision()方法可能会返回固定大小（fixed）格式，也可能返回指数</div><div class="t m0 x0 h5 y65c fff fs2 fc0 sc0 ls8">（exponential）格式；具体规则是看哪种格式最合适。这个方法接收一个参数，即表示数值的所有数字的</div><div class="t m0 x0 h5 y65d fff fs2 fc0 sc0 ls8 ws1">位数（不包括指数部分）。请看下面的例子。 </div><div class="t m0 x0 h5 y65e ff8 fs2 fc0 sc0 lsdf wsb">   </div></div></div>
<div id="pf8c" class="pf w0 h0" data-page-no="8c"><div class="pc pc8c w0 h0"><div class="t m0 x0 h2 y1 ff8 fs0 fc0 sc0 ls7 ws0">122  第5章 引用类型 </div><div class="t m0 x0 h3 y2 ff8 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y518 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y660 ff10 fs6 fc0 sc0 ls21 wsb">var num = 99; </div><div class="t m0 x0 h15 y661 ff11 fs6 fc0 sc0 ls21 wsb">alert(num.toPrecision(1));   //&quot;1e+2&quot; </div><div class="t m0 x0 h15 y662 ff11 fs6 fc0 sc0 ls21 wsb">alert(num.toPrecision(2));   //&quot;99&quot; </div><div class="t m0 x0 h15 y663 ff11 fs6 fc0 sc0 ls21 wsb">alert(num.toPrecision(3));   //&quot;99.0&quot; </div><div class="t m0 x0 hb y664 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y665 ff12 fs2 fc0 sc0 ls8 wsb">NumberTypeExample01.htm </div><div class="t m0 x0 h5 y666 fff fs2 fc0 sc0 ls8 ws1">以上代码首先完成的任务是以一位数来表示99，结果是&quot;1e+2&quot;，即100。因为一位数无法准确地</div><div class="t m0 x0 hc y667 fff fs2 fc0 sc0 ls1f ws15">表示99，因此toPrecision()就将它向上舍入为100，这样就可以使用一位数来表示它了。而接下来的</div><div class="t m0 x0 hc y668 fff fs2 fc0 sc0 ls1f ws15">用两位数表示99，当然还是&quot;99&quot;。最后，在想以三位数表示99时，toPrecision()方法返回了&quot;99.0&quot;。</div><div class="t m0 x0 h1e y669 fff fs2 fc0 sc0 ls5f ws4c">实际上，toPrecision()会根据要处理的数值决定到底是调用toFixed()还是调用toExponential()。</div><div class="t m0 x0 h5 y66a fff fs2 fc0 sc0 ls8 ws1">而这三个方法都可以通过向上或向下舍入，做到以最准确的形式来表示带有正确小数位的值。 </div><div class="t m0 x5 h5 y66b ff10 fs1 fc0 sc0 ls9 ws2">toPrecision()方法可以表现1到21位小数。某些浏览器支持的范围更大，但</div><div class="t m0 x0 h5 y66c ff9 fs2 fc0 sc0 ls8 ws14">这是典型实现的范围。 </div><div class="t m0 x0 h4 y66d fff fs2 fc0 sc0 lse3">与Boolean对象类似，Number对象也以后台方式为数值提供了重要的功能。但与此同时，我们仍</div><div class="t m0 x0 h1e y66e fff fs2 fc0 sc0 ls6 ws6">然不建议直接实例化Number类型，而原因与显式创建 Boolean对象一样。具体来讲，就是在使用</div><div class="t m0 x0 h4 y66f ff10 fs1 fc0 sc0 ls9 ws2">typeof和instanceof操作符测试基本类型数值与引用类型数值时，得到的结果完全不同，如下面的</div><div class="t m0 x0 h5 y670 fff fs2 fc0 sc0 ls8 ws1">例子所示。 </div><div class="t m0 x0 hb y671 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y672 ff10 fs6 fc0 sc0 ls21 wsb">var numberObject = new Number(10); </div><div class="t m0 x0 hb y673 ff10 fs6 fc0 sc0 ls21 wsb">var numberValue = 10; </div><div class="t m0 x0 hb y674 ff10 fs6 fc0 sc0 ls21 wsb">alert(typeof numberObject);   //&quot;object&quot; </div><div class="t m0 x0 hb y675 ff10 fs6 fc0 sc0 ls21 wsb">alert(typeof numberValue);    //&quot;number&quot; </div><div class="t m0 x0 hb y676 ff10 fs6 fc0 sc0 ls21 wsb">alert(numberObject instanceof Number);  //true </div><div class="t m0 x0 hb y677 ff10 fs6 fc0 sc0 ls21 wsb">alert(numberValue instanceof Number);   //false </div><div class="t m0 x0 hb y678 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y679 fff fs2 fc0 sc0 ls8 ws1">在使用typeof操作符测试基本类型数值时，始终会返回&quot;number&quot;，而在测试Number 对象时，</div><div class="t m0 x0 h5 y67a fff fs2 fc0 sc0 ls8 ws1">则会返回&quot;object&quot;。类似地，Number对象是Number类型的实例，而基本类型的数值则不是。 </div><div class="t m0 x0 h20 y67b ffe fs3 fc0 sc0 ls4d ws40">5.6.3 String类型 </div><div class="t m0 x0 h5 y67c ff10 fs1 fc0 sc0 ls9 ws2">String类型是字符串的对象包装类型，可以像下面这样使用String构造函数来创建。 </div><div class="t m0 x0 h15 y67d ff11 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y67e ff11 fs6 fc0 sc0 ls21 wsb">var stringObject = new String(&quot;hello world&quot;); </div><div class="t m0 x0 hb y67f ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y680 ff12 fs2 fc0 sc0 ls5e wsb">StringTypeExample01.htm </div><div class="t m0 x0 h4 y681 ff10 fs1 fc0 sc0 ls9 ws2">String对象的方法也可以在所有基本的字符串值中访问到。其中，继承的valueOf()、toLocale- </div><div class="t m0 x0 h5 y682 ff10 fs1 fc0 sc0 ls9 ws2">String()和toString()方法，都返回对象所表示的基本字符串值。 </div><div class="t m0 x0 h5 y683 ff10 fs1 fc0 sc0 ls9 ws2">String类型的每个实例都有一个length属性，表示字符串中包含多个字符。来看下面的例子。 </div><div class="t m0 x0 hb y684 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y685 ff10 fs6 fc0 sc0 ls21 wsb">var stringValue = &quot;hello world&quot;; </div><div class="t m0 x0 h15 y686 ff11 fs6 fc0 sc0 ls21 wsb">alert(stringValue.length);     //&quot;11&quot; </div><div class="t m0 x0 hb y687 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y688 fff fs2 fc0 sc0 ls6 ws6">这个例子输出了字符串&quot;hello world&quot;中的字符数量，即&quot;11&quot;。应该注意的是，即使字符串中包</div><div class="t m0 x0 h5 y689 fff fs2 fc0 sc0 ls8 ws1">含双字节字符（不是占一个字节的ASCII字符），每个字符也仍然算一个字符。 </div><div class="t m0 x0 h5 y68a ff10 fs1 fc0 sc0 ls9 ws2">String类型提供了很多方法，用于辅助完成对ECMAScript中字符串的解析和操作。 </div></div></div>
<div id="pf8d" class="pf w0 h0" data-page-no="8d"><div class="pc pc8d w0 h0"><div class="t m0 x2 h2 y1 ff8 fs0 fc0 sc0 ls10 wsc">5.6 基本包装类型    123 </div><div class="t m0 x0 h3 y2 ff8 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffa fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ffa fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffa fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffa fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffa fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffa fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffa fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffa fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffa fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffa fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffa fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffa fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ffa fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h3c y68b ffe fs2 fc0 sc0 ls2e wsb">1. 字符方法 </div><div class="t m0 x0 h4 y68c fff fs2 fc0 sc0 ls8 ws1">两个用于访问字符串中特定字符的方法是：charAt()和charCodeAt()。这两个方法都接收一个</div><div class="t m0 x0 h5 y68d fff fs2 fc0 sc0 ls24 ws1e">参数，即基于0的字符位置。其中，charAt()方法以单字符字符串的形式返回给定位置的那个字符</div><div class="t m0 x0 h5 y68e fff fs2 fc0 sc0 ls8">（ECMAScript中没有字符类型）。例如： </div><div class="t m0 x0 hb y68f ff10 fs6 fc0 sc0 ls21 wsb">var stringValue = &quot;hello world&quot;; </div><div class="t m0 x0 h15 y690 ff11 fs6 fc0 sc0 ls21 wsb">alert(stringValue.charAt(1));   //&quot;e&quot; </div><div class="t m0 x5 h15 y691 ff11 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y692 fff fs2 fc0 sc0 ls8 ws1">字符串&quot;hello world&quot;位置1处的字符是&quot;e&quot;，因此调用charAt(1)就返回了&quot;e&quot;。如果你想得到</div><div class="t m0 x0 hc y693 fff fs2 fc0 sc0 ls8 ws1">的不是字符而是字符编码，那么就要像下面这样使用charCodeAt()了。 </div><div class="t m0 x5 hb y694 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y695 ff10 fs6 fc0 sc0 ls21 wsb">var stringValue = &quot;hello world&quot;; </div><div class="t m0 x0 h16 y696 ff11 fs6 fc0 sc0 ls21 wsb">alert(stringValue.charCodeAt(1));   //输出&quot;101&quot; </div><div class="t m0 x5 hb y697 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y698 fff fs2 fc0 sc0 ls8 ws1">这个例子输出的是&quot;101&quot;，也就是小写字母&quot;e&quot;的字符编码。 </div><div class="t m0 x0 h5 y699 ff8 fs2 fc0 sc0 ls87 wsb8">ECMAScript 5还定义了另一个访问个别字符的方法。在支持此方法的浏览器中，可以使用方括号加数</div><div class="t m0 x0 h5 y69a fff fs2 fc0 sc0 ls1f">字索引来访问字符串中的特定字符，如下面的例子所示。 </div><div class="t m0 x5 hb y69b ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y69c ff10 fs6 fc0 sc0 ls21 wsb">var stringValue = &quot;hello world&quot;; </div><div class="t m0 x0 h15 y69d ff11 fs6 fc0 sc0 ls21 wsb">alert(stringValue[1]);   //&quot;e&quot; </div><div class="t m0 x5 hb y69e ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y69f fff fs2 fc0 sc0 ls8 ws1">使用方括号表示法访问个别字符的语法得到了IE8及Firefox、Safari、Chrome和Opera所有版本的</div><div class="t m0 x0 h5 y6a0 fff fs2 fc0 sc0 ls4c ws3e">支持。如果是在IE7及更早版本中使用这种语法，会返回 undefined值（尽管根本不是特殊的</div><div class="t m0 x0 h5 y6a1 ff10 fs1 fc0 sc0 ls9 ws2">undefined值）。 </div><div class="t m0 x0 h3c y6a2 ffe fs2 fc0 sc0 ls2e wsb">2. 字符串操作方法 </div><div class="t m0 x0 h4 y6a3 fff fs2 fc0 sc0 ls8 ws1">下面介绍与操作字符串有关的几个方法。第一个就是concat()，用于将一或多个字符串拼接起来，</div><div class="t m0 x0 h5 y6a4 fff fs2 fc0 sc0 ls8 ws1">返回拼接得到的新字符串。先来看一个例子。 </div><div class="t m0 x5 hb y6a5 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y6a6 ff10 fs6 fc0 sc0 ls21 wsb">var stringValue = &quot;hello &quot;; </div><div class="t m0 x0 hb y6a7 ff10 fs6 fc0 sc0 ls21 wsb">var result = stringValue.concat(&quot;world&quot;); </div><div class="t m0 x0 hb y6a8 ff10 fs6 fc0 sc0 ls21 wsb">alert(result);          //&quot;hello world&quot; </div><div class="t m0 x0 hb y6a9 ff10 fs6 fc0 sc0 ls21 wsb">alert(stringValue);      //&quot;hello&quot; </div><div class="t m0 x5 hb y6aa ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y6ab fff fs2 fc0 sc0 ls4 ws3">在这个例子中，通过stringValue调用 concat()方法返回的结果是&quot;hello world&quot;——但</div><div class="t m0 x0 h4 y6ac ff10 fs1 fc0 sc0 ls9 ws2">stringValue的值则保持不变。实际上，concat()方法可以接受任意多个参数，也就是说可以通过它</div><div class="t m0 x0 h5 y6ad fff fs2 fc0 sc0 ls8 ws1">拼接任意多个字符串。再看一个例子： </div><div class="t m0 x5 hb y6ae ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y6af ff10 fs6 fc0 sc0 ls21 wsb">var stringValue = &quot;hello &quot;; </div><div class="t m0 x0 h15 y6b0 ff11 fs6 fc0 sc0 ls21 wsb">var result = stringValue.concat(&quot;world&quot;, &quot;!&quot;); </div><div class="t m0 x0 hb y6b1 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y6b2 ff10 fs6 fc0 sc0 ls21 wsb">alert(result);          //&quot;hello world!&quot; </div><div class="t m0 x0 hb y6b3 ff10 fs6 fc0 sc0 ls21 wsb">alert(stringValue);      //&quot;hello&quot; </div><div class="t m0 x5 hb y6b4 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y6b5 fff fs2 fc0 sc0 ls8 ws1">这个例子将&quot;world&quot;和&quot;!&quot;拼接到了&quot;hello&quot;的末尾。虽然concat()是专门用来拼接字符串的方</div><div class="t m0 x0 h5 y6b6 fff fs2 fc0 sc0 ls8 ws1">法，但实践中使用更多的还是加号操作符（+）。而且，使用加号操作符在大多数情况下都比使用concat()</div><div class="t m0 x0 h5 y6b7 fff fs2 fc0 sc0 ls8 ws1">方法要简便易行（特别是在拼接多个字符串的情况下）。 </div><div class="t m0 x0 h5 y6b8 ff8 fs2 fc0 sc0 lse6 wsb7">ECMAScript还提供了三个基于子字符串创建新字符串的方法：slice()、substr()和substring()。</div><div class="t m0 x0 h4 y6b9 fff fs2 fc0 sc0 ls8 ws1">这三个方法都会返回被操作字符串的一个子字符串，而且也都接受一或两个参数。第一个参数指定子字</div><div class="t m0 x0 h1c y6ba fff fs2 fc0 sc0 ls24 ws1e">符串的开始位置，第二个参数（在指定的情况下）表示子字符串到哪里结束。具体来说，slice()和</div><div class="t m0 x0 h4 y6bb ff10 fs1 fc0 sc0 ls9 ws2">substring()的第二个参数指定的是子字符串最后一个字符后面的位置。而substr()的第二个参数指</div></div></div>
<div id="pf8e" class="pf w0 h0" data-page-no="8e"><div class="pc pc8e w0 h0"><div class="t m0 x0 h2 y1 ff8 fs0 fc0 sc0 ls7 ws0">124  第5章 引用类型 </div><div class="t m0 x0 h3 y2 ff8 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 fff fs2 fc0 sc0 ls8 ws1">定的则是返回的字符个数。如果没有给这些方法传递第二个参数，则将字符串的长度作为结束位置。与</div><div class="t m0 x0 h4 y4 ff10 fs1 fc0 sc0 ls9 ws2">concat()方法一样，slice()、substr()和substring()也不会修改字符串本身的值——它们只是</div><div class="t m0 x0 h5 y5 fff fs2 fc0 sc0 ls8 ws1">返回一个基本类型的字符串值，对原始字符串没有任何影响。请看下面的例子。 </div><div class="t m0 x0 hb y6bd ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y6be ff10 fs6 fc0 sc0 ls21 wsb">var stringValue = &quot;hello world&quot;; </div><div class="t m0 x0 h15 y6bf ff11 fs6 fc0 sc0 ls21 wsb">alert(stringValue.slice(3));          //&quot;lo world&quot; </div><div class="t m0 x0 h15 y6c0 ff11 fs6 fc0 sc0 ls21 wsb">alert(stringValue.substring(3));     //&quot;lo world&quot; </div><div class="t m0 x0 h15 y6c1 ff11 fs6 fc0 sc0 ls21 wsb">alert(stringValue.substr(3));        //&quot;lo world&quot; </div><div class="t m0 x0 h15 y6c2 ff11 fs6 fc0 sc0 ls21 wsb">alert(stringValue.slice(3, 7));      //&quot;lo w&quot; </div><div class="t m0 x0 h15 y6c3 ff11 fs6 fc0 sc0 ls21 wsb">alert(stringValue.substring(3,7));    //&quot;lo w&quot; </div><div class="t m0 x0 h15 y6c4 ff11 fs6 fc0 sc0 ls21 wsb">alert(stringValue.substr(3, 7));      //&quot;lo worl&quot; </div><div class="t m0 x0 hb y6c5 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf y6c6 ff12 fs2 fc0 sc0 ls25 wsb">StringTypeManipulationMethodsExample01.htm </div><div class="t m0 x0 h4 y6c7 fff fs2 fc0 sc0 ls8 ws1">这个例子比较了以相同方式调用slice()、substr()和substring()得到的结果，而且多数情</div><div class="t m0 x0 h5 y6c8 fff fs2 fc0 sc0 ls8 ws1">况下的结果是相同的。在只指定一个参数3的情况下，这三个方法都返回&quot;lo world&quot;，因为&quot;hello&quot;</div><div class="t m0 x0 h5 y6c9 fff fs2 fc0 sc0 ls8 ws1">中的第二个&quot;l&quot;处于位置3。而在指定两个参数3和7的情况下，slice()和substring()返回&quot;lo w&quot;</div><div class="t m0 x0 h5 y6ca fff fs2 fc0 sc0 ls8 ws1">（&quot;world&quot;中的&quot;o&quot;处于位置7，因此结果中不包含&quot;o&quot;），但substr()返回&quot;lo worl&quot;，因为它的第二</div><div class="t m0 x0 h5 y6cb fff fs2 fc0 sc0 ls8 ws1">个参数指定的是要返回的字符个数。 </div><div class="t m0 x0 h1c y6cc fff fs2 fc0 sc0 ls8 ws1">在传递给这些方法的参数是负值的情况下，它们的行为就不尽相同了。其中，slice()方法会将传</div><div class="t m0 x0 h1e y6cd fff fs2 fc0 sc0 ls6 ws6">入的负值与字符串的长度相加，substr()方法将负的第一个参数加上字符串的长度，而将负的第二个</div><div class="t m0 x0 h5 y6ce fff fs2 fc0 sc0 ls8 ws1">参数转换为0。最后，substring()方法会把所有负值参数都转换为0。下面来看例子。 </div><div class="t m0 x0 hb y6cf ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y6d0 ff10 fs6 fc0 sc0 ls21 wsb">var stringValue = &quot;hello world&quot;; </div><div class="t m0 x0 h15 y6d1 ff11 fs6 fc0 sc0 ls21 wsb">alert(stringValue.slice(-3));          //&quot;rld&quot; </div><div class="t m0 x0 h15 y6d2 ff11 fs6 fc0 sc0 ls21 wsb">alert(stringValue.substring(-3));     //&quot;hello world&quot; </div><div class="t m0 x0 h15 y6d3 ff11 fs6 fc0 sc0 ls21 wsb">alert(stringValue.substr(-3));        //&quot;rld&quot; </div><div class="t m0 x0 h15 y6d4 ff11 fs6 fc0 sc0 ls21 wsb">alert(stringValue.slice(3, -4));       //&quot;lo w&quot; </div><div class="t m0 x0 h15 y6d5 ff11 fs6 fc0 sc0 ls21 wsb">alert(stringValue.substring(3, -4));   //&quot;hel&quot; </div><div class="t m0 x0 h16 y6d6 ff11 fs6 fc0 sc0 ls21 wsb">alert(stringValue.substr(3, -4));      //&quot;&quot;（空字符串） </div><div class="t m0 x0 hb y6d7 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf y6d8 ff12 fs2 fc0 sc0 ls25 wsb">StringTypeManipulationMethodsExample01.htm </div><div class="t m0 x0 h4 y6d9 fff fs2 fc0 sc0 ls30 ws2a">这个例子清晰地展示了上述三个方法之间的不同行为。在给slice()和substr()传递一个负值</div><div class="t m0 x0 h25 y6da fff fs2 fc0 sc0 ls30 ws2a">参数时，它们的行为相同。这是因为-3会被转换为8（字符串长度加参数11+(3)=8），实际上相当</div><div class="t m0 x0 h1e y6db fff fs2 fc0 sc0 ls24 ws1e">于调用了slice(8)和substr(8)。但substring()方法则返回了全部字符串，因为它将-3转换</div><div class="t m0 x0 hc y6dc fff fs2 fc0 sc0 ls30 ws2a">成了0。 </div><div class="t m0 x5 h5 y6dd ff8 fs2 fc0 sc0 lse ws9">IE的JavaScript实现在处理向substr()方法传递负值的情况时存在问题，它会</div><div class="t m0 x0 h5 y6de ff9 fs2 fc0 sc0 ls8 ws14">返回原始的字符串。IE9修复了这个问题。 </div><div class="t m0 x0 h44 y6df fff fs2 fc0 sc0 ls8 ws1">当第二个参数是负值时，这三个方法的行为各不相同。slice()方法会把第二个参数转换为7，这</div><div class="t m0 x0 hc y6e0 fff fs2 fc0 sc0 ls8 ws1">就相当于调用了slice(3,7)，因此返回&quot;lo w&quot;。substring()方法会把第二个参数转换为0，使调</div><div class="t m0 x0 h4 y6e1 fff fs2 fc0 sc0 ls8 ws1">用变成了substring(3,0)，而由于这个方法会将较小的数作为开始位置，将较大的数作为结束位置，</div><div class="t m0 x0 hc y6e2 fff fs2 fc0 sc0 ls8 ws1">因此最终相当于调用了substring(0,3)。substr()也会将第二个参数转换为0，这也就意味着返回</div><div class="t m0 x0 h5 y6e3 fff fs2 fc0 sc0 ls8 ws1">包含零个字符的字符串，也就是一个空字符串。 </div></div></div>
<div id="pf8f" class="pf w0 h0" data-page-no="8f"><div class="pc pc8f w0 h0"><div class="t m0 x2 h2 y1 ff8 fs0 fc0 sc0 ls10 wsc">5.6 基本包装类型    125 </div><div class="t m0 x0 h3 y2 ff8 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffa fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ffa fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffa fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffa fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffa fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffa fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffa fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffa fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffa fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffa fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffa fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffa fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ffa fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h3c y68b ffe fs2 fc0 sc0 ls2e wsb">3. 字符串位置方法 </div><div class="t m0 x0 h4 y68c fff fs2 fc0 sc0 ls8 ws1">有两个可以从字符串中查找子字符串的方法：indexOf()和lastIndexOf()。这两个方法都是从</div><div class="t m0 x0 h1e y68d fff fs2 fc0 sc0 ls6 ws6">一个字符串中搜索给定的子字符串，然后返子字符串的位置（如果没有找到该子字符串，则返回-1）。</div><div class="t m0 x0 h1e y68e fff fs2 fc0 sc0 ls8 ws1">这两个方法的区别在于：indexOf()方法从字符串的开头向后搜索子字符串，而lastIndexOf()方法</div><div class="t m0 x0 h5 y6e4 fff fs2 fc0 sc0 ls8 ws1">是从字符串的末尾向前搜索子字符串。还是来看一个例子吧。 </div><div class="t m0 x5 hb y6e5 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y6e6 ff10 fs6 fc0 sc0 ls21 wsb">var stringValue = &quot;hello world&quot;; </div><div class="t m0 x0 h15 y6e7 ff11 fs6 fc0 sc0 ls21 wsb">alert(stringValue.indexOf(&quot;o&quot;));             //4 </div><div class="t m0 x0 h15 y6e8 ff11 fs6 fc0 sc0 ls21 wsb">alert(stringValue.lastIndexOf(&quot;o&quot;));         //7 </div><div class="t m0 x5 hb y6e9 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf y6ea ff12 fs2 fc0 sc0 ls8 wsb">StringTypeLocationMethodsExample01.htm </div><div class="t m0 x0 h5 y6eb fff fs2 fc0 sc0 ls5c ws4a">子字符串&quot;o&quot;第一次出现的位置是4，即&quot;hello&quot;中的&quot;o&quot;；最后一次出现的位置是7，即&quot;world&quot;中的</div><div class="t m0 x0 h5 y6ec ff10 fs1 fc0 sc0 ls5d ws4b">&quot;o&quot;。如果&quot;o&quot;在这个字符串中仅出现了一次，那么indexOf()和lastIndexOf()会返回相同的位置值。 </div><div class="t m0 x0 h4 y6ed fff fs2 fc0 sc0 ls4 ws3">这两个方法都可以接收可选的第二个参数，表示从字符串中的哪个位置开始搜索。换句话说，</div><div class="t m0 x0 h4 y6ee ff10 fs1 fc0 sc0 ls9 ws2">indexOf()会从该参数指定的位置向后搜索，忽略该位置之前的所有字符；而lastIndexOf()则会从</div><div class="t m0 x0 h5 y6ef fff fs2 fc0 sc0 ls8 ws1">指定的位置向前搜索，忽略该位置之后的所有字符。看下面的例子。 </div><div class="t m0 x5 hb y6f0 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y6f1 ff10 fs6 fc0 sc0 ls21 wsb">var stringValue = &quot;hello world&quot;; </div><div class="t m0 x0 h15 y6f2 ff11 fs6 fc0 sc0 ls21 wsb">alert(stringValue.indexOf(&quot;o&quot;, 6));         //7 </div><div class="t m0 x0 h15 y6f3 ff11 fs6 fc0 sc0 ls21 wsb">alert(stringValue.lastIndexOf(&quot;o&quot;, 6));     //4      </div><div class="t m0 x5 hb y6f4 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y6f5 fff fs2 fc0 sc0 lsed wsbd">在将第二个参数6传递给这两个方法之后，得到了与前面例子相反的结果。这一次，由于</div><div class="t m0 x0 h5 y6f6 ff10 fs1 fc0 sc0 ls3d ws2b">indexOf()是从位置6（字母&quot;w&quot;）开始向后搜索，结果在位置7找到了&quot;o&quot;，因此它返回7。而last- </div><div class="t m0 x0 h21 y6f7 ff10 fs1 fc0 sc0 ls3d ws2b">IndexOf()是从位置6开始向前搜索。结果找到了&quot;hello&quot;中的&quot;o&quot;，因此它返回4。在使用第二个</div><div class="t m0 x0 h4 y6f8 fff fs2 fc0 sc0 ls30 ws2a">参数的情况下，可以通过循环调用indexOf()或lastIndexOf()来找到所有匹配的子字符串，如下</div><div class="t m0 x0 h5 y6f9 fff fs2 fc0 sc0 ls30 ws2a">面的例子所示： </div><div class="t m0 x5 hb y6fa ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y6fb ff10 fs6 fc0 sc0 ls21 wsb">var stringValue = &quot;Lorem ipsum dolor sit amet, consectetur adipisicing elit&quot;; </div><div class="t m0 x0 hb y6fc ff10 fs6 fc0 sc0 ls21 wsb">var positions = new Array(); </div><div class="t m0 x0 hb y6fd ff10 fs6 fc0 sc0 ls21 wsb">var pos = stringValue.indexOf(&quot;e&quot;); </div><div class="t m0 x0 hb y6fe ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y6ff ff10 fs6 fc0 sc0 ls21 wsb">while(pos &gt; -1){ </div><div class="t m0 x0 hb y700 ff10 fs6 fc0 sc0 ls21 wsb">    positions.push(pos); </div><div class="t m0 x0 hb y701 ff10 fs6 fc0 sc0 ls21 wsb">    pos = stringValue.indexOf(&quot;e&quot;, pos + 1); </div><div class="t m0 x0 hb y702 ff10 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y703 ff10 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 hb y704 ff10 fs6 fc0 sc0 ls21 wsb">alert(positions);    //&quot;3,24,32,35,52&quot; </div><div class="t m0 x5 hb y705 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf y706 ff12 fs2 fc0 sc0 ls8 wsb">StringTypeLocationMethodsExample02.htm </div><div class="t m0 x0 h4 y707 fff fs2 fc0 sc0 ls6 ws6">这个例子通过不断增加indexOf()方法开始查找的位置，遍历了一个长字符串。在循环之外，首</div><div class="t m0 x0 hc y708 fff fs2 fc0 sc0 ls8 ws1">先找到了&quot;e&quot;在字符串中的初始位置；而进入循环后，则每次都给indexOf()传递上一次的位置加1。</div><div class="t m0 x0 h4 y709 fff fs2 fc0 sc0 ls8 ws1">这样，就确保了每次新搜索都从上一次找到的子字符串的后面开始。每次搜索返回的位置依次被保存在</div><div class="t m0 x0 hc y70a fff fs2 fc0 sc0 ls8 ws1">数组positions中，以便将来使用。 </div><div class="t m0 x0 h47 y70b ffe fs2 fc0 sc0 ls2e wsb">4. trim()方法 </div><div class="t m0 x0 h5 y70c ff8 fs2 fc0 sc0 ls25 ws57">ECMAScript 5为所有字符串定义了trim()方法。这个方法会创建一个字符串的副本，删除前置及</div><div class="t m0 x0 h5 y70d fff fs2 fc0 sc0 ls8 ws1">后缀的所有空格，然后返回结果。例如： </div></div></div>
<div id="pf90" class="pf w0 h0" data-page-no="90"><div class="pc pc90 w0 h0"><div class="t m0 x0 h2 y1 ff8 fs0 fc0 sc0 ls7 ws0">126  第5章 引用类型 </div><div class="t m0 x0 h3 y2 ff8 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y70f ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y710 ff10 fs6 fc0 sc0 ls21 wsb">var stringValue = &quot;   hello world   &quot;; </div><div class="t m0 x0 hb y711 ff10 fs6 fc0 sc0 ls21 wsb">var trimmedStringValue = stringValue.trim(); </div><div class="t m0 x0 hb y712 ff10 fs6 fc0 sc0 ls21 wsb">alert(stringValue);            //&quot;   hello world   &quot; </div><div class="t m0 x0 hb y713 ff10 fs6 fc0 sc0 ls21 wsb">alert(trimmedStringValue);     //&quot;hello world&quot;  </div><div class="t m0 x0 hb y714 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y715 fff fs2 fc0 sc0 ls5 ws4">由于trim()返回的是字符串的副本，所以原始字符串中的前置及后缀空格会保持不变。支持这个</div><div class="t m0 x0 h5 y716 fff fs2 fc0 sc0 ls5 ws4">方法的浏览器有IE9+、Firefox 3.5+、Safari 5+、Opera 10.5+和Chrome。此外，Firefox 3.5+、Safari 5+</div><div class="t m0 x0 h5 y717 fff fs2 fc0 sc0 ls8d">和Chrome 8+还支持非标准的trimLeft()和trimRight()方法，分别用于删除字符串开头和末尾的</div><div class="t m0 x0 h5 y718 fff fs2 fc0 sc0 ls5">空格。 </div><div class="t m0 x0 h3c y719 ffe fs2 fc0 sc0 ls2e wsb">5. 字符串大小写转换方法 </div><div class="t m0 x0 h5 y71a fff fs2 fc0 sc0 ls6 ws6">接下来我们要介绍的是一组与大小写转换有关的方法。ECMAScript中涉及字符串大小写转换的方</div><div class="t m0 x0 h5 y71b fff fs2 fc0 sc0 ls8 ws1">法有4个：toLowerCase()、toLocaleLowerCase()、toUpperCase()和toLocaleUpperCase()。</div><div class="t m0 x0 h1e y71c fff fs2 fc0 sc0 ls8 ws1">其中，toLowerCase()和toUpperCase()是两个经典的方法，借鉴自java.lang.String中的同名</div><div class="t m0 x0 h1e y71d fff fs2 fc0 sc0 ls8 ws1">方法。而toLocaleLowerCase()和toLocaleUpperCase()方法则是针对特定地区的实现。对有些地</div><div class="t m0 x0 h5 y71e fff fs2 fc0 sc0 ls8 ws1">区来说，针对地区的方法与其通用方法得到的结果相同，但少数语言（如土耳其语）会为Unicode大小</div><div class="t m0 x0 h5 y71f fff fs2 fc0 sc0 ls8 ws1">写转换应用特殊的规则，这时候就必须使用针对地区的方法来保证实现正确的转换。以下是几个例子。 </div><div class="t m0 x0 hb y720 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y721 ff10 fs6 fc0 sc0 ls21 wsb">var stringValue = &quot;hello world&quot;; </div><div class="t m0 x0 h15 y722 ff11 fs6 fc0 sc0 ls21 wsb">alert(stringValue.toLocaleUpperCase());  //&quot;HELLO WORLD&quot; </div><div class="t m0 x0 h15 y723 ff11 fs6 fc0 sc0 ls21 wsb">alert(stringValue.toUpperCase());        //&quot;HELLO WORLD&quot; </div><div class="t m0 x0 h15 y724 ff11 fs6 fc0 sc0 ls21 wsb">alert(stringValue.toLocaleLowerCase());  //&quot;hello world&quot; </div><div class="t m0 x0 h15 y725 ff11 fs6 fc0 sc0 ls21 wsb">alert(stringValue.toLowerCase());        //&quot;hello world&quot; </div><div class="t m0 x0 hb y726 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf y727 ff12 fs2 fc0 sc0 ls8 wsb">StringTypeCaseMethodExample01.htm </div><div class="t m0 x0 h4 y728 fff fs2 fc0 sc0 ls8 ws1">以上代码调用的toLocaleUpperCase()和toUpperCase()都返回了&quot;HELLO WORLD&quot;，就像调用</div><div class="t m0 x0 h4 y55d ff10 fs1 fc0 sc0 ls9 ws2">toLocaleLowerCase()和toLowerCase()都返回&quot;hello world&quot;一样。一般来说，在不知道自己的</div><div class="t m0 x0 h5 y729 fff fs2 fc0 sc0 ls8 ws1">代码将在哪种语言环境中运行的情况下，还是使用针对地区的方法更稳妥一些。 </div><div class="t m0 x0 h3c y72a ffe fs2 fc0 sc0 ls2e wsb">6. 字符串的模式匹配方法 </div><div class="t m0 x0 h4 y72b ff10 fs1 fc0 sc0 ls9 ws2">String类型定义了几个用于在字符串中匹配模式的方法。第一个方法就是match()，在字符串上</div><div class="t m0 x0 h4 y6ac fff fs2 fc0 sc0 ls8 ws1">调用这个方法，本质上与调用RegExp的exec()方法相同。match()方法只接受一个参数，要么是一</div><div class="t m0 x0 hc y6ad fff fs2 fc0 sc0 ls8 ws1">个正则表达式，要么是一个RegExp对象。来看下面的例子。 </div><div class="t m0 x0 hb y72c ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y72d ff10 fs6 fc0 sc0 ls21 wsb">var text = &quot;cat, bat, sat, fat&quot;;  </div><div class="t m0 x0 hb y72e ff10 fs6 fc0 sc0 ls21 wsb">var pattern = /.at/; </div><div class="t m0 x0 hb y72f ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y730 ff10 fs6 fc0 sc0 ls21">//与pattern.exec(text)相同 </div><div class="t m0 x0 hb y731 ff10 fs6 fc0 sc0 ls21 wsb">var matches = text.match(pattern);         </div><div class="t m0 x0 hb y732 ff10 fs6 fc0 sc0 ls21 wsb">alert(matches.index);            //0 </div><div class="t m0 x0 hb y733 ff10 fs6 fc0 sc0 ls21 wsb">alert(matches[0]);                //&quot;cat&quot; </div><div class="t m0 x0 hb y734 ff10 fs6 fc0 sc0 ls21 wsb">alert(pattern.lastIndex);         //0 </div><div class="t m0 x0 hb y735 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf y736 ff12 fs2 fc0 sc0 ls25 wsb">StringTypePatternMatchingExample01.htm </div><div class="t m0 x0 h4 y737 fff fs2 fc0 sc0 ls8 ws1">本例中的match()方法返回了一个数组；如果是调用RegExp对象的exec()方法并传递本例中的</div><div class="t m0 x0 h4 y738 fff fs2 fc0 sc0 ls8 ws1">字符串作为参数，那么也会得到与此相同的数组：数组的第一项是与整个模式匹配的字符串，之后的每</div><div class="t m0 x0 h5 y739 fff fs2 fc0 sc0 ls8 ws1">一项（如果有）保存着与正则表达式中的捕获组匹配的字符串。 </div></div></div>
<div id="pf91" class="pf w0 h0" data-page-no="91"><div class="pc pc91 w0 h0"><div class="t m0 x2 h2 y1 ff8 fs0 fc0 sc0 ls10 wsc">5.6 基本包装类型    127 </div><div class="t m0 x0 h3 y2 ff8 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffa fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ffa fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffa fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffa fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffa fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffa fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffa fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffa fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffa fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffa fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffa fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffa fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ffa fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h4 y3 fff fs2 fc0 sc0 ls8 ws1">另一个用于查找模式的方法是search()。这个方法的唯一参数与match()方法的参数相同：由字</div><div class="t m0 x0 h1e y4d fff fs2 fc0 sc0 ls5f ws4c">符串或RegExp对象指定的一个正则表达式。search()方法返回字符串中第一个匹配项的索引；如果没</div><div class="t m0 x0 hc y5 fff fs2 fc0 sc0 ls5f ws4c">有找到匹配项，则返回-1。而且，search()方法始终是从字符串开头向后查找模式。看下面的例子。 </div><div class="t m0 x5 hb y41f ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y73a ff10 fs6 fc0 sc0 ls21 wsb">var text = &quot;cat, bat, sat, fat&quot;;  </div><div class="t m0 x0 h15 y73b ff11 fs6 fc0 sc0 ls21 wsb">var pos = text.search(/at/); </div><div class="t m0 x0 h15 y73c ff11 fs6 fc0 sc0 ls21 wsb">alert(pos);   //1 </div><div class="t m0 x5 hb y73d ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf y73e ff12 fs2 fc0 sc0 ls25 wsb">StringTypePatternMatchingExample01.htm </div><div class="t m0 x0 h5 y73f fff fs2 fc0 sc0 ls8 ws1">这个例子中的search()方法返回1，即&quot;at&quot;在字符串中第一次出现的位置。 </div><div class="t m0 x0 h5 y740 fff fs2 fc0 sc0 ls8 ws1">为了简化替换子字符串的操作，ECMAScript提供了replace()方法。这个方法接受两个参数：第</div><div class="t m0 x0 h1e y741 fff fs2 fc0 sc0 ls8 ws1">一个参数可以是一个RegExp对象或者一个字符串（这个字符串不会被转换成正则表达式），第二个参</div><div class="t m0 x0 h4 y742 fff fs2 fc0 sc0 ls8 ws1">数可以是一个字符串或者一个函数。如果第一个参数是字符串，那么只会替换第一个子字符串。要想替</div><div class="t m0 x0 hc y743 fff fs2 fc0 sc0 ls8 ws1">换所有子字符串，唯一的办法就是提供一个正则表达式，而且要指定全局（g）标志，如下所示。 </div><div class="t m0 x5 hb y744 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y745 ff10 fs6 fc0 sc0 ls21 wsb">var text = &quot;cat, bat, sat, fat&quot;;  </div><div class="t m0 x0 h15 y746 ff11 fs6 fc0 sc0 ls21 wsb">var result = text.replace(&quot;at&quot;, &quot;ond&quot;); </div><div class="t m0 x0 h15 y747 ff11 fs6 fc0 sc0 ls21 wsb">alert(result);    //&quot;cond, bat, sat, fat&quot; </div><div class="t m0 x0 h15 y748 ff11 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y749 ff11 fs6 fc0 sc0 ls21 wsb">result = text.replace(/at/g, &quot;ond&quot;); </div><div class="t m0 x0 h15 y74a ff11 fs6 fc0 sc0 ls21 wsb">alert(result);    //&quot;cond, bond, sond, fond&quot; </div><div class="t m0 x5 hb y74b ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf y74c ff12 fs2 fc0 sc0 ls25 wsb">StringTypePatternMatchingExample01.htm </div><div class="t m0 x0 h4 y74d fff fs2 fc0 sc0 ls8 ws1">在这个例子中，首先传入replace()方法的是字符串&quot;at&quot;和替换用的字符串&quot;ond&quot;。替换的结果</div><div class="t m0 x0 h1e y74e fff fs2 fc0 sc0 ls8 ws1">是把&quot;cat&quot;变成了&quot;cond&quot;，但字符串中的其他字符并没有受到影响。然后，通过将第一个参数修改为带</div><div class="t m0 x0 hc y74f fff fs2 fc0 sc0 ls8 ws1">有全局标志的正则表达式，就将全部&quot;at&quot;都替换成了&quot;ond&quot;。 </div><div class="t m0 x0 h4 y750 fff fs2 fc0 sc0 ls8 ws1">如果第二个参数是字符串，那么还可以使用一些特殊的字符序列，将正则表达式操作得到的值插入</div><div class="t m0 x0 h5 y751 fff fs2 fc0 sc0 ls8 ws1">到结果字符串中。下表列出了ECMAScript提供的这些特殊的字符序列。 </div><div class="t m0 x5 hb y752 ff10 fs6 fc0 sc0 ls8 wsb">  </div><div class="t m0 x0 h31 y753 ffc fs6 fc0 sc0 ls8">字符序列 替换文本 </div><div class="t m0 x0 h49 y754 ff10 fsc fc0 sc0 lsa8 wsb">$$  $ </div><div class="t m0 x0 h32 y755 ff10 fsc fc0 sc0 lsa8 wsb">$&amp;  匹配整个模式的子字符串。与RegExp.lastMatch的值相同 </div><div class="t m0 x0 h32 y756 ff10 fsc fc0 sc0 lsa8 wsb">$&apos;  匹配的子字符串之前的子字符串。与RegExp.leftContext的值相同 </div><div class="t m0 x0 h32 y757 ff10 fsc fc0 sc0 lsa8 wsb">$`  匹配的子字符串之后的子字符串。与RegExp.rightContext的值相同 </div><div class="t m0 x0 h32 y758 ff10 fsc fc0 sc0 lsa8 wsb">$n  匹配第n个捕获组的子字符串，其中n等于0～9。例如，$1是匹配第一个捕获组的子字符串，$2是匹配第</div><div class="t m0 x5 h36 y759 fff fs6 fc0 sc0 ls8 ws33">二个捕获组的子字符串，以此类推。如果正则表达式中没有定义捕获组，则使用空字符串 </div><div class="t m0 x0 h32 y75a ff10 fsc fc0 sc0 lsa8 wsb">$nn  匹配第nn个捕获组的子字符串，其中nn等于01～99。例如，$01是匹配第一个捕获组的子字符串，$02</div><div class="t m0 x5 h36 y75b fff fs6 fc0 sc0 ls8 ws33">是匹配第二个捕获组的子字符串，以此类推。如果正则表达式中没有定义捕获组，则使用空字符串 </div><div class="t m0 x0 h5 y75c ff8 fs2 fc0 sc0 lsf7 wsb">  </div><div class="t m0 x0 h5 y75d fff fs2 fc0 sc0 ls8 ws1">通过这些特殊的字符序列，可以使用最近一次匹配结果中的内容，如下面的例子所示。 </div><div class="t m0 x5 hb y75e ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y75f ff10 fs6 fc0 sc0 ls21 wsb">var text = &quot;cat, bat, sat, fat&quot;;  </div><div class="t m0 x0 h15 y760 ff11 fs6 fc0 sc0 ls21 wsb">result = text.replace(/(.at)/g, &quot;word ($1)&quot;); </div><div class="t m0 x0 h15 y761 ff11 fs6 fc0 sc0 ls21 wsb">alert(result);    //word (cat), word (bat), word (sat), word (fat) </div><div class="t m0 x5 hb y762 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf y763 ff12 fs2 fc0 sc0 ls25 wsb">StringTypePatternMatchingExample01.htm </div></div></div>
<div id="pf92" class="pf w0 h0" data-page-no="92"><div class="pc pc92 w0 h0"><div class="t m0 x0 h2 y1 ff8 fs0 fc0 sc0 ls7 ws0">128  第5章 引用类型 </div><div class="t m0 x0 h3 y2 ff8 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 fff fs2 fc0 sc0 ls6 ws6">在此，每个以&quot;at&quot;结尾的单词都被替换了，替换结果是&quot;word&quot;后跟一对圆括号，而圆括号中是被</div><div class="t m0 x0 hc y4d fff fs2 fc0 sc0 ls8 ws1">字符序列$1所替换的单词。 </div><div class="t m0 x0 h4 y4e ff10 fs1 fc0 sc0 ls9 ws2">replace()方法的第二个参数也可以是一个函数。在只有一个匹配项（即与模式匹配的字符串）的</div><div class="t m0 x0 h5 yd9 fff fs2 fc0 sc0 ls8 ws1">情况下，会向这个函数传递3个参数：模式的匹配项、模式匹配项在字符串中的位置和原始字符串。在</div><div class="t m0 x0 h4 y15d fff fs2 fc0 sc0 ls8 ws1">正则表达式中定义了多个捕获组的情况下，传递给函数的参数依次是模式的匹配项、第一个捕获组的匹</div><div class="t m0 x0 h4 y2b3 fff fs2 fc0 sc0 ls8 ws1">配项、第二个捕获组的匹配项……，但最后两个参数仍然分别是模式的匹配项在字符串中的位置和原始</div><div class="t m0 x0 h4b y765 fff fs2 fc0 sc0 ls6 ws6">字符串。这个函数应该返回一个字符串，表示应该被替换的匹配项使用函数作为replace()方法的第</div><div class="t m0 x0 h5 y15f fff fs2 fc0 sc0 ls8 ws1">二个参数可以实现更加精细的替换操作，请看下面这个例子。 </div><div class="t m0 x0 hb y766 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y767 ff10 fs6 fc0 sc0 ls21 wsb">function htmlEscape(text){ </div><div class="t m0 x0 hb y768 ff10 fs6 fc0 sc0 ls21 wsb">    return text.replace(/[&lt;&gt;&quot;&amp;]/g, function(match, pos, originalText){ </div><div class="t m0 x0 hb y769 ff10 fs6 fc0 sc0 ls21 wsb">        switch(match){ </div><div class="t m0 x0 hb y76a ff10 fs6 fc0 sc0 ls21 wsb">            case &quot;&lt;&quot;: </div><div class="t m0 x0 hb y76b ff10 fs6 fc0 sc0 ls21 wsb">                return &quot;&amp;lt;&quot;; </div><div class="t m0 x0 hb y76c ff10 fs6 fc0 sc0 ls21 wsb">            case &quot;&gt;&quot;: </div><div class="t m0 x0 hb y76d ff10 fs6 fc0 sc0 ls21 wsb">                return &quot;&amp;gt;&quot;; </div><div class="t m0 x0 hb y76e ff10 fs6 fc0 sc0 ls21 wsb">            case &quot;&amp;&quot;: </div><div class="t m0 x0 hb y76f ff10 fs6 fc0 sc0 ls21 wsb">                return &quot;&amp;amp;&quot;; </div><div class="t m0 x0 hb y770 ff10 fs6 fc0 sc0 ls21 wsb">            case &quot;\&quot;&quot;: </div><div class="t m0 x0 hb y771 ff10 fs6 fc0 sc0 ls21 wsb">                return &quot;&amp;quot;&quot;; </div><div class="t m0 x0 hb y772 ff10 fs6 fc0 sc0 ls21 wsb">        }              </div><div class="t m0 x0 hb y773 ff10 fs6 fc0 sc0 ls21 wsb">    }); </div><div class="t m0 x0 hb y774 ff10 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y775 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y776 ff10 fs6 fc0 sc0 ls21 wsb">alert(htmlEscape(&quot;&lt;p class=\&quot;greeting\&quot;&gt;Hello world!&lt;/p&gt;&quot;));  </div><div class="t m0 x0 hb y777 ff10 fs6 fc0 sc0 ls21 wsb">//&amp;lt;p class=&amp;quot;greeting&amp;quot;&amp;gt;Hello world!&amp;lt;/p&amp;gt; </div><div class="t m0 x0 hb y778 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf y779 ff12 fs2 fc0 sc0 ls25 wsb">StringTypePatternMatchingExample01.htm </div><div class="t m0 x0 h5 yc4 fff fs2 fc0 sc0 ls8 ws1">这里，我们为插入HTML代码定义了函数htmlEscape()，这个函数能够转义4个字符：小于号、</div><div class="t m0 x0 h4 y77a fff fs2 fc0 sc0 ls8 ws1">大于号、和号以及双引号。实现这种转义的最简单方式，就是使用正则表达式查找这几个字符，然后定</div><div class="t m0 x0 h5 y77b fff fs2 fc0 sc0 ls8 ws1">义一个能够针对每个匹配的字符返回特定HTML实体的函数。 </div><div class="t m0 x0 h1c y77c fff fs2 fc0 sc0 ls8 ws1">最后一个与模式匹配有关的方法是split()，这个方法可以基于指定的分隔符将一个字符串分割成</div><div class="t m0 x0 h1e y539 fff fs2 fc0 sc0 ls8 ws1">多个子字符串，并将结果放在一个数组中。分隔符可以是字符串，也可以是一个RegExp对象（这个方</div><div class="t m0 x0 h4 y77d fff fs2 fc0 sc0 ls6 ws6">法不会将字符串看成正则表达式）。split()方法可以接受可选的第二个参数，用于指定数组的大小，</div><div class="t m0 x0 h5 y77e fff fs2 fc0 sc0 ls8 ws1">以便确保返回的数组不会超过既定大小。请看下面的例子。 </div><div class="t m0 x0 hb y77f ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y780 ff10 fs6 fc0 sc0 ls21 wsb">var colorText = &quot;red,blue,green,yellow&quot;; </div><div class="t m0 x0 hb y781 ff10 fs6 fc0 sc0 ls21 wsb">var colors1 = colorText.split(&quot;,&quot;);          //[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;yellow&quot;] </div><div class="t m0 x0 hb y782 ff10 fs6 fc0 sc0 ls21 wsb">var colors2 = colorText.split(&quot;,&quot;, 2);       //[&quot;red&quot;, &quot;blue&quot;] </div><div class="t m0 x0 hb y783 ff10 fs6 fc0 sc0 ls21 wsb">var colors3 = colorText.split(/[^\,]+/);     //[&quot;&quot;, &quot;,&quot;, &quot;,&quot;, &quot;,&quot;, &quot;&quot;] </div><div class="t m0 x0 hb y784 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf y785 ff12 fs2 fc0 sc0 ls25 wsb">StringTypePatternMatchingExample01.htm </div><div class="t m0 x0 h4 y786 fff fs2 fc0 sc0 ls8 ws1">在这个例子中，colorText是逗号分隔的颜色名字符串。基于该字符串调用split(&quot;,&quot;)会得到</div><div class="t m0 x0 h4 y787 fff fs2 fc0 sc0 ls8 ws1">一个包含其中颜色名的数组，用于分割字符串的分隔符是逗号。为了将数组截短，让它只包含两项，可</div><div class="t m0 x0 he y788 fff fs2 fc0 sc0 ls8 ws1">以为split()方法传递第二个参数2。最后，通过使用正则表达式，还可以取得包含逗号字符的数组。</div><div class="t m0 x0 h1e y789 fff fs2 fc0 sc0 ls8 ws1">需要注意的是，在最后一次调用split()返回的数组中，第一项和最后一项是两个空字符串。之所以会</div></div></div>
<div id="pf93" class="pf w0 h0" data-page-no="93"><div class="pc pc93 w0 h0"><div class="t m0 x2 h2 y1 ff8 fs0 fc0 sc0 ls10 wsc">5.6 基本包装类型    129 </div><div class="t m0 x0 h3 y2 ff8 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffa fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ffa fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffa fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffa fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffa fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffa fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffa fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffa fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffa fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffa fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffa fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffa fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ffa fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h4 y3 fff fs2 fc0 sc0 ls8 ws1">这样，是因为通过正则表达式指定的分隔符出现在了字符串的开头（即子字符串&quot;red&quot;）和末尾（即子</div><div class="t m0 x0 hc y4d fff fs2 fc0 sc0 ls8 ws1">字符串&quot;yellow&quot;）。 </div><div class="t m0 x0 h1e y5 fff fs2 fc0 sc0 lsfb">对split()中正则表达式的支持因浏览器而异。尽管对于简单的模式没有什么差别，但对于未发现</div><div class="t m0 x0 h5 yd9 fff fs2 fc0 sc0 ls8 ws1">匹配项以及带有捕获组的模式，匹配的行为就不大相同了。以下是几种常见的差别。 </div><div class="t m0 x0 h5 y219 ffd fs1 fc0 sc0 ls2"> IE8及之前版本会忽略捕获组。ECMA-262规定应该把捕获组拼接到结果数组中。IE9能正确地</div><div class="t m0 x5 h5 y21a fff fs2 fc0 sc0 ls8 ws1">在结果中包含捕获组。 </div><div class="t m0 x0 h5 y9 ffd fs1 fc0 sc0 ls2"> Firefox 3.6及之前版本在捕获组未找到匹配项时，会在结果数组中包含空字符串；ECMA-262规</div><div class="t m0 x5 hc y15f fff fs2 fc0 sc0 ls8 ws1">定没有匹配项的捕获组在结果数组中应该用undefined表示。 </div><div class="t m0 x0 h4 yb fff fs2 fc0 sc0 ls8 ws1">在正则表达式中使用捕获组时还有其他微妙的差别。在使用这种正则表达式时，一定要在各种浏览</div><div class="t m0 x0 h5 y78a fff fs2 fc0 sc0 ls8 ws1">器下多做一些测试。 </div><div class="t m0 x5 h17 y78b ff9 fs2 fc0 sc0 ls8 ws14">要了解关于split()方法以及捕获组的跨浏览器问题的更多讨论，请参考Steven </div><div class="t m0 x5 h5 y78c ff8 fs2 fc0 sc0 ls2b ws22">Levithan的文章“JavaScript split bugs：Fixed!”（http://blog.stevenlevithan.com/archives/ </div><div class="t m0 x5 h5 y78d ff8 fs2 fc0 sc0 ls79 ws6c">cross-browser-split）。 </div><div class="t m0 x0 h4c y78e ffe fs2 fc0 sc0 ls2e wsb">7. localeCompare()方法 </div><div class="t m0 x0 h4 y78f fff fs2 fc0 sc0 ls8 ws1">与操作字符串有关的最后一个方法是localeCompare()，这个方法比较两个字符串，并返回下列</div><div class="t m0 x0 h5 y790 fff fs2 fc0 sc0 ls8 ws1">值中的一个： </div><div class="t m0 x0 h4 y791 ffd fs1 fc0 sc0 ls2"> 如果字符串在字母表中应该排在字符串参数之前，则返回一个负数（大多数情况下是-1，具体</div><div class="t m0 x5 h5 y792 fff fs2 fc0 sc0 ls8 ws1">的值要视实现而定）； </div><div class="t m0 x0 h5 y793 ffd fs1 fc0 sc0 ls2"> 如果字符串等于字符串参数，则返回0； </div><div class="t m0 x0 h4 y794 ffd fs1 fc0 sc0 ls2"> 如果字符串在字母表中应该排在字符串参数之后，则返回一个正数（大多数情况下是1，具体的</div><div class="t m0 x5 h5 y795 fff fs2 fc0 sc0 ls8 ws1">值同样要视实现而定）。 </div><div class="t m0 x0 h5 y796 fff fs2 fc0 sc0 ls8 ws1">下面是几个例子。 </div><div class="t m0 x5 hb y797 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y798 ff10 fs6 fc0 sc0 ls21 wsb">var stringValue = &quot;yellow&quot;;        </div><div class="t m0 x0 hb y799 ff10 fs6 fc0 sc0 ls21 wsb">alert(stringValue.localeCompare(&quot;brick&quot;));      //1 </div><div class="t m0 x0 hb y79a ff10 fs6 fc0 sc0 ls21 wsb">alert(stringValue.localeCompare(&quot;yellow&quot;));      //0 </div><div class="t m0 x0 hb y79b ff10 fs6 fc0 sc0 ls21 wsb">alert(stringValue.localeCompare(&quot;zoo&quot;));         //-1 </div><div class="t m0 x5 hb y79c ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf y79d ff12 fs2 fc0 sc0 lsb wsb">StringTypeLocaleCompareExample01.htm </div><div class="t m0 x0 h4 y79e fff fs2 fc0 sc0 ls8 ws1">这个例子比较了字符串&quot;yellow&quot;和另外几个值：&quot;brick&quot;、&quot;yellow&quot;和&quot;zoo&quot;。因为&quot;brick&quot;在</div><div class="t m0 x0 h1e y79f fff fs2 fc0 sc0 ls8 ws1">字母表中排在&quot;yellow&quot;之前，所以localeCompare()返回了1；而&quot;yellow&quot;等于&quot;yellow&quot;，所以</div><div class="t m0 x0 h4 y7a0 ff10 fs1 fc0 sc0 ls9 ws2">localeCompare()返回了0；最后，&quot;zoo&quot;在字母表中排在&quot;yellow&quot;后面，所以localeCompare()</div><div class="t m0 x0 h4 y7a1 fff fs2 fc0 sc0 ls8 ws1">返回了-1。再强调一次，因为localeCompare()返回的数值取决于实现，所以最好是像下面例子所示</div><div class="t m0 x0 h5 y7a2 fff fs2 fc0 sc0 ls8 ws1">的这样使用这个方法。 </div><div class="t m0 x5 hb y7a3 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y7a4 ff10 fs6 fc0 sc0 ls21 wsb">function determineOrder(value) { </div><div class="t m0 x0 hb y7a5 ff10 fs6 fc0 sc0 ls21 wsb">    var result = stringValue.localeCompare(value); </div><div class="t m0 x0 hb y7a6 ff10 fs6 fc0 sc0 ls21 wsb">    if (result &lt; 0){ </div><div class="t m0 x0 hb y7a7 ff10 fs6 fc0 sc0 ls21 wsb">        alert(&quot;The string &apos;yellow&apos; comes before the string &apos;&quot; + value + &quot;&apos;.&quot;); </div><div class="t m0 x0 hb y7a8 ff10 fs6 fc0 sc0 ls21 wsb">    } else if (result &gt; 0) { </div><div class="t m0 x0 hb y7a9 ff10 fs6 fc0 sc0 ls21 wsb">        alert(&quot;The string &apos;yellow&apos; comes after the string &apos;&quot; + value + &quot;&apos;.&quot;); </div><div class="t m0 x0 hb y7aa ff10 fs6 fc0 sc0 ls21 wsb">    } else { </div></div></div>
<div id="pf94" class="pf w0 h0" data-page-no="94"><div class="pc pc94 w0 h0"><div class="t m0 x0 h2 y1 ff8 fs0 fc0 sc0 ls7 ws0">130  第5章 引用类型 </div><div class="t m0 x0 h3 y2 ff8 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y44f ff10 fs6 fc0 sc0 ls21 wsb">        alert(&quot;The string &apos;yellow&apos; is equal to the string &apos;&quot; + value + &quot;&apos;.&quot;); </div><div class="t m0 x0 hb y450 ff10 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y451 ff10 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y7ac ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y7ad ff10 fs6 fc0 sc0 ls21 wsb">determineOrder(&quot;brick&quot;); </div><div class="t m0 x0 hb y7ae ff10 fs6 fc0 sc0 ls21 wsb">determineOrder(&quot;yellow&quot;); </div><div class="t m0 x0 hb y7af ff10 fs6 fc0 sc0 ls21 wsb">determineOrder(&quot;zoo&quot;); </div><div class="t m0 x0 hb y7b0 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf y7b1 ff12 fs2 fc0 sc0 lsb wsb">StringTypeLocaleCompareExample01.htm </div><div class="t m0 x0 h5 y426 fff fs2 fc0 sc0 ls8 ws1">使用这种结构，就可以确保自己的代码在任何实现中都可以正确地运行了。 </div><div class="t m0 x0 h4 y7b2 ff10 fs1 fc0 sc0 ls9 ws2">localeCompare()方法比较与众不同的地方，就是实现所支持的地区（国家和语言）决定了这个</div><div class="t m0 x0 h5 y7b3 fff fs2 fc0 sc0 ls8 ws1">方法的行为。比如，美国以英语作为ECMAScript实现的标准语言，因此localeCompare()就是区分</div><div class="t m0 x0 h4 y7b4 fff fs2 fc0 sc0 ls8 ws1">大小写的，于是大写字母在字母表中排在小写字母前头就成为了一项决定性的比较规则。不过，在其他</div><div class="t m0 x0 h5 y7b5 fff fs2 fc0 sc0 ls8 ws1">地区恐怕就不是这种情况了。 </div><div class="t m0 x0 h4e y7b6 ffe fs2 fc0 sc0 ls2e wsb">8. fromCharCode()方法 </div><div class="t m0 x0 h4 y7b7 fff fs2 fc0 sc0 ls8 ws1">另外，String构造函数本身还有一个静态方法：fromCharCode()。这个方法的任务是接收一或</div><div class="t m0 x0 h4 y7b8 fff fs2 fc0 sc0 ls5 ws4">多个字符编码，然后将它们转换成一个字符串。从本质上来看，这个方法与实例方法charCodeAt()</div><div class="t m0 x0 h5 y7b9 fff fs2 fc0 sc0 ls8 ws1">执行的是相反的操作。来看一个例子： </div><div class="t m0 x0 hb y7ba ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y7bb ff10 fs6 fc0 sc0 ls21 wsb">alert(String.fromCharCode(104, 101, 108, 108, 111)); //&quot;hello&quot; </div><div class="t m0 x0 hb y7bc ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf y7bd ff12 fs2 fc0 sc0 ls8 wsb">StringTypeFromCharCodeExample01.htm </div><div class="t m0 x0 h5 y7be fff fs2 fc0 sc0 ls8 ws1">在这里，我们给fromCharCode()传递的是字符串&quot;hello&quot;中每个字母的字符编码。 </div><div class="t m0 x0 h3c y7bf ffe fs2 fc0 sc0 ls4e wscd">9. HTML方法 </div><div class="t m0 x0 h5 y7c0 fff fs2 fc0 sc0 ls8 ws1">早期的Web浏览器提供商觉察到了使用JavaScript动态格式化 HTML的需求。于是，这些提供商就</div><div class="t m0 x0 h5 y7c1 fff fs2 fc0 sc0 ls8 ws1">扩展了标准，实现了一些专门用于简化常见HTML格式化任务的方法。下表列出了这些HTML方法。</div><div class="t m0 x0 h5 y7c2 fff fs2 fc0 sc0 ls8 ws1">不过，需要请读者注意的是，应该尽量不使用这些方法，因为它们创建的标记通常无法表达语义。 </div><div class="t m0 x0 hb y7c3 ff10 fs6 fc0 sc0 ls8 wsb">  </div><div class="t m0 x5 h31 y7c4 ffc fs6 fc0 sc0 lsa7 wsb">方  法 输出结果 </div><div class="t m0 x5 h32 y7c5 ff10 fsc fc0 sc0 lsa8 ws80">anchor(name)  &lt;a name= &quot;name&quot;&gt;string&lt;/a&gt; </div><div class="t m0 x5 h32 y7c6 ff10 fsc fc0 sc0 lsa8 wsce">big() &lt;big&gt;string&lt;/big&gt; </div><div class="t m0 x5 h32 yf6 ff10 fsc fc0 sc0 lsa8 wscf">bold() &lt;b&gt;string&lt;/b&gt; </div><div class="t m0 x5 h32 y7c7 ff10 fsc fc0 sc0 lsa8 wsd0">fixed() &lt;tt&gt;string&lt;/tt&gt; </div><div class="t m0 x5 h32 y7c8 ff10 fsc fc0 sc0 lsa8 ws80">fontcolor(color) &lt;font color=&quot;color&quot;&gt;string&lt;/font&gt; </div><div class="t m0 x5 h32 y7c9 ff10 fsc fc0 sc0 lsa8 ws80">fontsize(size) &lt;font size=&quot;size&quot;&gt;string&lt;/font&gt; </div><div class="t m0 x5 h32 y7ca ff10 fsc fc0 sc0 lsa8 wsd3">italics() &lt;i&gt;string&lt;/i&gt; </div><div class="t m0 x5 h32 y7cb ff10 fsc fc0 sc0 lsa8 wsd3">link(url) &lt;a href=&quot;url&quot;&gt;string&lt;/a&gt; </div><div class="t m0 x5 h32 y7cc ff10 fsc fc0 sc0 lsa8 wsd0">small() &lt;small&gt;string&lt;/small&gt; </div><div class="t m0 x5 h32 y7cd ff10 fsc fc0 sc0 lsa8 wsd4">strike() &lt;strike&gt;string&lt;/strike&gt; </div><div class="t m0 x5 h32 y7ce ff10 fsc fc0 sc0 lsa8 wsce">sub() &lt;sub&gt;string&lt;/sub&gt; </div><div class="t m0 x5 h32 y7cf ff10 fsc fc0 sc0 lsa8 wsce">sup() &lt;sup&gt;string&lt;/sup&gt; </div><div class="t m0 x0 hd y7d0 ffe fs7 fc0 sc0 ls22">5.7 单体内置对象 </div><div class="t m0 x0 h5 y7d1 ff8 fs2 fc0 sc0 ls5e ws66">ECMA-262对内置对象的定义是：“由ECMAScript实现提供的、不依赖于宿主环境的对象，这些对</div><div class="t m0 x0 h5 y7d2 fff fs2 fc0 sc0 ls8 ws1">象在ECMAScript程序执行之前就已经存在了。”意思就是说，开发人员不必显式地实例化内置对象，因</div></div></div>
<div id="pf95" class="pf w0 h0" data-page-no="95"><div class="pc pc95 w0 h0"><div class="t m0 x2 h2 y1 ff8 fs0 fc0 sc0 ls10 wsc">5.7 单体内置对象    131 </div><div class="t m0 x0 h3 y2 ff8 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffa fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ffa fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffa fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffa fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffa fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffa fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffa fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffa fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffa fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffa fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffa fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffa fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ffa fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h4 y3 fff fs2 fc0 sc0 ls4 ws3">为它们已经实例化了。前面我们已经介绍了大多数内置对象，例如Object、Array和String。</div><div class="t m0 x0 hc y4d ff8 fs2 fc0 sc0 ls5e ws66">ECMA-262还定义了两个单体内置对象：Global和Math。 </div><div class="t m0 x0 h20 y1f2 ffe fs3 fc0 sc0 ls4d ws40">5.7.1 Global对象 </div><div class="t m0 x0 h5 y1f3 ff10 fs1 fc0 sc0 ls9 ws2">Global（全局）对象可以说是ECMAScript中最特别的一个对象了，因为不管你从什么角度上看，</div><div class="t m0 x0 h5 y1f4 fff fs2 fc0 sc0 ls8 ws1">这个对象都是不存在的。ECMAScript中的Global对象在某种意义上是作为一个终极的“兜底儿对象”</div><div class="t m0 x0 h4 y1f5 fff fs2 fc0 sc0 ls8 ws1">来定义的。换句话说，不属于任何其他对象的属性和方法，最终都是它的属性和方法。事实上，没有全</div><div class="t m0 x0 h1c y7d3 fff fs2 fc0 sc0 ls8 ws1">局变量或全局函数；所有在全局作用域中定义的属性和函数，都是Global对象的属性。本书前面介绍</div><div class="t m0 x0 h1e y1f7 fff fs2 fc0 sc0 ls8 ws1">过的那些函数，诸如isNaN()、isFinite()、parseInt()以及parseFloat()，实际上全都是Global</div><div class="t m0 x0 h5 y7d4 fff fs2 fc0 sc0 ls8 ws1">对象的方法。除此之外，Global对象还包含其他一些方法。 </div><div class="t m0 x0 h3c y7d5 ffe fs2 fc0 sc0 ls8 wsd9">1. URI编码方法 </div><div class="t m0 x0 h5 y7d6 ff10 fs1 fc0 sc0 ls9 ws2">Global对象的encodeURI()和encodeURIComponent()方法可以对 URI（Uniform Resource </div><div class="t m0 x0 h5 y7d7 ff8 fs2 fc0 sc0 ls47 ws38">Identifiers，通用资源标识符）进行编码，以便发送给浏览器。有效的URI中不能包含某些字符，例如</div><div class="t m0 x0 h5 y7d8 fff fs2 fc0 sc0 ls8 ws1">空格。而这两个URI编码方法就可以对URI进行编码，它们用特殊的UTF-8编码替换所有无效的字符，</div><div class="t m0 x0 h5 y7d9 fff fs2 fc0 sc0 ls8 ws1">从而让浏览器能够接受和理解。 </div><div class="t m0 x0 h1b y7da fff fs2 fc0 sc0 ls8 ws1">其中，encodeURI()主要用于整个URI（例如，http://www.wrox.com/illegal value.htm），而encode- </div><div class="t m0 x0 h5 y7db ff10 fs1 fc0 sc0 ls9 ws2">URIComponent()主要用于对URI中的某一段（例如前面URI中的illegal value.htm）进行编码。</div><div class="t m0 x0 hc y7dc fff fs2 fc0 sc0 ls8 ws1">它们的主要区别在于，encodeURI()不会对本身属于URI的特殊字符进行编码，例如冒号、正斜杠、</div><div class="t m0 x0 hc y7dd fff fs2 fc0 sc0 ls5f ws4c">问号和井字号；而encodeURIComponent()则会对它发现的任何非标准字符进行编码。来看下面的例子。 </div><div class="t m0 x5 hb y7de ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y7df ff10 fs6 fc0 sc0 ls21 wsb">var uri = &quot;http://www.wrox.com/illegal value.htm#start&quot;; </div><div class="t m0 x0 hb y7e0 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y7e1 ff10 fs6 fc0 sc0 ls21 wsb">//&quot;http://www.wrox.com/illegal%20value.htm#start&quot; </div><div class="t m0 x0 hb y7e2 ff10 fs6 fc0 sc0 ls21 wsb">alert(encodeURI(uri)); </div><div class="t m0 x0 hb y7e3 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y7e4 ff10 fs6 fc0 sc0 ls21 wsb">//&quot;http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start&quot; </div><div class="t m0 x0 hb y7e5 ff10 fs6 fc0 sc0 ls21 wsb">alert(encodeURIComponent(uri)); </div><div class="t m0 x5 hb y7e6 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf y7e7 ff12 fs2 fc0 sc0 ls1b wsb">GlobalObjectURIEncodingExample01.htm </div><div class="t m0 x0 h4 y7e8 fff fs2 fc0 sc0 lsa ws53">使用encodeURI()编码后的结果是除了空格之外的其他字符都原封不动，只有空格被替换成了</div><div class="t m0 x0 h4 y7e9 ff10 fs1 fc0 sc0 ls9 ws2">%20。而encodeURIComponent()方法则会使用对应的编码替换所有非字母数字字符。这也正是可以</div><div class="t m0 x0 hc y7ea fff fs2 fc0 sc0 ls8 ws1">对整个URI使用encodeURI()，而只能对附加在现有URI后面的字符串使用encodeURIComponent()</div><div class="t m0 x0 h5 y7eb fff fs2 fc0 sc0 ls8 ws1">的原因所在。 </div><div class="t m0 x5 ha y7ec ff9 fs2 fc0 sc0 ls102 wsd6">一般来说，我们使用encodeURIComponent()方法的时候要比使用</div><div class="t m0 x5 h5 y7ed ff10 fs1 fc0 sc0 ls9 ws2">encodeURI()更多，因为在实践中更常见的是对查询字符串参数而不是对基础URI</div><div class="t m0 x5 h5 y7ee ff9 fs2 fc0 sc0 ls8 ws14">进行编码。 </div><div class="t m0 x0 h4 y7ef fff fs2 fc0 sc0 ls103">与encodeURI()和encodeURIComponent()方法对应的两个方法分别是decodeURI()和</div><div class="t m0 x0 h4 y7f0 ff10 fs1 fc0 sc0 ls9 ws2">decodeURIComponent()。其中，decodeURI()只能对使用encodeURI()替换的字符进行解码。例如，</div><div class="t m0 x0 h1e y7f1 fff fs2 fc0 sc0 ls8 ws1">它可将%20替换成一个空格，但不会对%23作任何处理，因为%23表示井字号（#），而井字号不是使用</div><div class="t m0 x0 h4 y517 ff10 fs1 fc0 sc0 ls9 ws2">encodeURI()替换的。同样地，decodeURIComponent()能够解码使用encodeURIComponent()编码</div></div></div>
<div id="pf96" class="pf w0 h0" data-page-no="96"><div class="pc pc96 w0 h0"><div class="t m0 x0 h2 y1 ff8 fs0 fc0 sc0 ls7 ws0">132  第5章 引用类型 </div><div class="t m0 x0 h3 y2 ff8 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 fff fs2 fc0 sc0 ls8 ws1">的所有字符，即它可以解码任何特殊字符的编码。来看下面的例子： </div><div class="t m0 x0 hb y3a5 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3a6 ff10 fs6 fc0 sc0 ls21 wsb">var uri = &quot;http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start&quot;; </div><div class="t m0 x0 hb y7f3 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y7f4 ff10 fs6 fc0 sc0 ls21 wsb">//http%3A%2F%2Fwww.wrox.com%2Fillegal value.htm%23start </div><div class="t m0 x0 hb y7f5 ff10 fs6 fc0 sc0 ls21 wsb">alert(decodeURI(uri)); </div><div class="t m0 x0 hb y7f6 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y7f7 ff10 fs6 fc0 sc0 ls21 wsb">//http://www.wrox.com/illegal value.htm#start </div><div class="t m0 x0 hb y7f8 ff10 fs6 fc0 sc0 ls21 wsb">alert(decodeURIComponent(uri)); </div><div class="t m0 x0 hb y7f9 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf y7fa ff12 fs2 fc0 sc0 ls25 wsb">GlobalObjectURIDecodingExample01.htm </div><div class="t m0 x0 h4 y61b fff fs2 fc0 sc0 ls5f ws4c">这里，变量uri包含着一个由encodeURIComponent()编码的字符串。在第一次调用decodeURI()</div><div class="t m0 x0 h4 y7fb fff fs2 fc0 sc0 ls8 ws1">输出的结果中，只有%20被替换成了空格。而在第二次调用decodeURIComponent()输出的结果中，</div><div class="t m0 x0 h4 y7fc fff fs2 fc0 sc0 ls8 ws1">所有特殊字符的编码都被替换成了原来的字符，得到了一个未经转义的字符串（但这个字符串并不是一</div><div class="t m0 x0 h5 y7fd fff fs2 fc0 sc0 ls8 ws1">个有效的URI）。 </div><div class="t m0 x5 h5 y7fe ff8 fs2 fc0 sc0 ls50 ws41">URI方法encodeURI()、encodeURIComponent()、decodeURI()和decode- </div><div class="t m0 x0 h5 y7ff ff10 fs1 fc0 sc0 ls9 ws2">URIComponent()用于替代已经被ECMA-262第3版废弃的escape()和unescape()</div><div class="t m0 x0 h5 y800 ff9 fs2 fc0 sc0 ls5f wsdd">方法。URI方法能够编码所有Unicode字符，而原来的方法只能正确地编码ASCII字符。</div><div class="t m0 x0 h5 y801 ff9 fs2 fc0 sc0 ls5f wsdd">因此在开发实践中，特别是在产品级的代码中，一定要使用URI方法，不要使用escape()</div><div class="t m0 x0 h5 y802 ff9 fs2 fc0 sc0 ls10a">和unescape()方法。 </div><div class="t m0 x0 h50 y803 ffe fs2 fc0 sc0 ls2e wsb">2. eval()方法 </div><div class="t m0 x0 h5 y804 fff fs2 fc0 sc0 ls8 ws1">现在，我们介绍最后一个——大概也是整个ECMAScript语言中最强大的一个方法：eval()。eval()</div><div class="t m0 x0 h5 y805 fff fs2 fc0 sc0 ls8 ws1">方法就像是一个完整的ECMAScript解析器，它只接受一个参数，即要执行的ECMAScript（或JavaScript）</div><div class="t m0 x0 h5 y806 fff fs2 fc0 sc0 ls8 ws1">字符串。看下面的例子： </div><div class="t m0 x0 hb y807 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y808 ff10 fs6 fc0 sc0 ls21 wsb">eval(&quot;alert(&apos;hi&apos;)&quot;); </div><div class="t m0 x0 hb y809 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y80a fff fs2 fc0 sc0 ls8 ws1">这行代码的作用等价于下面这行代码： </div><div class="t m0 x0 hb y80b ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y80c ff10 fs6 fc0 sc0 ls21 wsb">alert(&quot;hi&quot;); </div><div class="t m0 x0 hb y80d ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y80e fff fs2 fc0 sc0 ls8 ws1">当解析器发现代码中调用eval()方法时，它会将传入的参数当作实际的ECMAScript语句来解析，</div><div class="t m0 x0 h4 y6ae fff fs2 fc0 sc0 ls8 ws1">然后把执行结果插入到原位置。通过eval()执行的代码被认为是包含该次调用的执行环境的一部分，</div><div class="t m0 x0 h1e y80f fff fs2 fc0 sc0 ls8 ws1">因此被执行的代码具有与该执行环境相同的作用域链。这意味着通过eval()执行的代码可以引用在包</div><div class="t m0 x0 h5 y810 fff fs2 fc0 sc0 ls8 ws1">含环境中定义的变量，举个例子： </div><div class="t m0 x0 hb y811 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y812 ff10 fs6 fc0 sc0 ls21 wsb">var msg = &quot;hello world&quot;; </div><div class="t m0 x0 hb y813 ff10 fs6 fc0 sc0 ls21 wsb">eval(&quot;alert(msg)&quot;);    //&quot;hello world&quot; </div><div class="t m0 x0 hb y814 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y815 fff fs2 fc0 sc0 ls8 ws1">可见，变量msg是在eval()调用的环境之外定义的，但其中调用的alert()仍然能够显示&quot;hello </div><div class="t m0 x0 h42 y816 ff10 fs1 fc0 sc0 ls9 ws2">world&quot;。这是因为上面第二行代码最终被替换成了一行真正的代码。同样地，我们也可以在eval()</div><div class="t m0 x0 h5 y817 fff fs2 fc0 sc0 ls8 ws1">调用中定义一个函数，然后再在该调用的外部代码中引用这个函数： </div><div class="t m0 x0 hb y818 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y819 ff10 fs6 fc0 sc0 ls21 wsb">eval(&quot;function sayHi() { alert(&apos;hi&apos;); }&quot;); </div><div class="t m0 x0 hb y81a ff10 fs6 fc0 sc0 ls21 wsb">sayHi(); </div><div class="t m0 x0 hb y81b ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y81c fff fs2 fc0 sc0 ls8 ws1">显然，函数sayHi()是在eval()内部定义的。但由于对eval()的调用最终会被替换成定义函数</div><div class="t m0 x0 hc y81d fff fs2 fc0 sc0 ls8 ws1">的实际代码，因此可以在下一行调用sayHi()。对于变量也一样： </div></div></div>
<div id="pf97" class="pf w0 h0" data-page-no="97"><div class="pc pc97 w0 h0"><div class="t m0 x2 h2 y1 ff8 fs0 fc0 sc0 ls10 wsc">5.7 单体内置对象    133 </div><div class="t m0 x0 h3 y2 ff8 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffa fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ffa fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffa fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffa fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffa fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffa fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffa fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffa fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffa fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffa fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffa fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffa fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ffa fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y70f ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y710 ff10 fs6 fc0 sc0 ls21 wsb">eval(&quot;var msg = &apos;hello world&apos;; &quot;); </div><div class="t m0 x0 hb y711 ff10 fs6 fc0 sc0 ls21 wsb">alert(msg);     //&quot;hello world&quot; </div><div class="t m0 x0 hb y81f ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y820 fff fs2 fc0 sc0 ls110">在eval()中创建的任何变量或函数都不会被提升，因为在解析代码的时候，它们被包含在一个字</div><div class="t m0 x0 hc y821 fff fs2 fc0 sc0 ls8 ws1">符串中；它们只在eval()执行的时候创建。 </div><div class="t m0 x0 h4 y822 fff fs2 fc0 sc0 ls8 ws1">严格模式下，在外部访问不到eval()中创建的任何变量或函数，因此前面两个例子都会导致错误。</div><div class="t m0 x0 hc y823 fff fs2 fc0 sc0 ls8 ws1">同样，在严格模式下，为eval赋值也会导致错误： </div><div class="t m0 x0 hb y824 ff10 fs6 fc0 sc0 ls21 wsb">&quot;use strict&quot;; </div><div class="t m0 x0 hb y825 ff10 fs6 fc0 sc0 ls21 wsb">eval = &quot;hi&quot;;   //causes error </div><div class="t m0 x5 ha y826 ff9 fs2 fc0 sc0 ls8 ws14">能够解释代码字符串的能力非常强大，但也非常危险。因此在使用eval()时必</div><div class="t m0 x5 ha y827 ff9 fs2 fc0 sc0 ls8 ws14">须极为谨慎，特别是在用它执行用户输入数据的情况下。否则，可能会有恶意用户输</div><div class="t m0 x5 h5 y828 ff9 fs2 fc0 sc0 ls8 ws14">入威胁你的站点或应用程序安全的代码（即所谓的代码注入）。 </div><div class="t m0 x0 h4c y829 ffe fs2 fc0 sc0 ls2e wsb">3. Global对象的属性 </div><div class="t m0 x0 h4 y82a ff10 fs1 fc0 sc0 ls9 ws2">Global对象还包含一些属性，其中一部分属性已经在本书前面介绍过了。例如，特殊的值</div><div class="t m0 x0 h4 y82b ff10 fs1 fc0 sc0 ls9 ws2">undefined、NaN以及Infinity都是Global对象的属性。此外，所有原生引用类型的构造函数，像</div><div class="t m0 x0 h5 y82c ff10 fs1 fc0 sc0 ls9 ws2">Object和Function，也都是Global对象的属性。下表列出了Global 对象的所有属性。 </div><div class="t m0 x5 hb y168 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x5 h31 y82d ffc fs6 fc0 sc0 lsa7 wsb">属  性 说  明 属  性 说  明 </div><div class="t m0 x5 h32 y82e ff10 fsc fc0 sc0 lsa8 wsb">undefined  特殊值undefined Date  构造函数Date </div><div class="t m0 x5 h32 y82f ff10 fsc fc0 sc0 lsa8 wsb">NaN  特殊值NaN RegExp  构造函数RegExp </div><div class="t m0 x5 h32 y830 ff10 fsc fc0 sc0 lsa8 wsb">Infinity  特殊值Infinity Error  构造函数Error </div><div class="t m0 x5 h32 y831 ff10 fsc fc0 sc0 lsa8 wsb">Object  构造函数Object EvalError  构造函数EvalError </div><div class="t m0 x5 h32 y40e ff10 fsc fc0 sc0 lsa8 wsb">Array  构造函数Array RangeError  构造函数RangeError </div><div class="t m0 x5 h32 y832 ff10 fsc fc0 sc0 lsa8 wsb">Function  构造函数Function ReferenceError  构造函数ReferenceError </div><div class="t m0 x5 h32 y833 ff10 fsc fc0 sc0 lsa8 wsb">Boolean  构造函数Boolean SyntaxError  构造函数SyntaxError </div><div class="t m0 x5 h32 y834 ff10 fsc fc0 sc0 lsa8 wsb">String  构造函数String TypeError  构造函数TypeError </div><div class="t m0 x5 h32 y835 ff10 fsc fc0 sc0 lsa8 wsb">Number  构造函数Number URIError  构造函数URIError </div><div class="t m0 x5 hb y836 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y837 ff8 fs2 fc0 sc0 ls25 wse5">ECMAScript 5明确禁止给undefined、NaN和Infinity赋值，这样做即使在非严格模式下也会</div><div class="t m0 x0 h5 y838 fff fs2 fc0 sc0 ls8 ws1">导致错误。 </div><div class="t m0 x0 h4e y839 ffe fs2 fc0 sc0 ls2e wsb">4. window对象 </div><div class="t m0 x0 h5 y83a ff8 fs2 fc0 sc0 ls1a ws1c">ECMAScript虽然没有指出如何直接访问Global 对象，但Web浏览器都是将这个全局对象作为</div><div class="t m0 x0 h4 y83b ff10 fs1 fc0 sc0 ls9 ws2">window对象的一部分加以实现的。因此，在全局作用域中声明的所有变量和函数，就都成为了window</div><div class="t m0 x0 h5 y83c fff fs2 fc0 sc0 ls8 ws1">对象的属性。来看下面的例子。 </div><div class="t m0 x5 hb y83d ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y83e ff10 fs6 fc0 sc0 ls21 wsb">var color = &quot;red&quot;; </div><div class="t m0 x0 hb y83f ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y840 ff10 fs6 fc0 sc0 ls21 wsb">function sayColor(){ </div><div class="t m0 x0 hb y841 ff10 fs6 fc0 sc0 ls21 wsb">    alert(window.color); </div><div class="t m0 x0 hb y842 ff10 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y843 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y844 ff10 fs6 fc0 sc0 ls21 wsb">window.sayColor();  //&quot;red&quot; </div><div class="t m0 x5 hb y845 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y846 ff12 fs2 fc0 sc0 ls8 wsb">GlobalObjectWindowExample01.htm </div></div></div>
<div id="pf98" class="pf w0 h0" data-page-no="98"><div class="pc pc98 w0 h0"><div class="t m0 x0 h2 y1 ff8 fs0 fc0 sc0 ls7 ws0">134  第5章 引用类型 </div><div class="t m0 x0 h3 y2 ff8 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 fff fs2 fc0 sc0 ls8 ws1">这里定义了一个名为color的全局变量和一个名为sayColor()的全局函数。在sayColor()内部，</div><div class="t m0 x0 h1e y4d fff fs2 fc0 sc0 ls8 ws1">我们通过window.color来访问color变量，以说明全局变量是 window对象的属性。然后，又使用</div><div class="t m0 x0 h5 y4e ff10 fs1 fc0 sc0 ls9 ws2">window.sayColor()来直接通过window对象调用这个函数，结果显示在了警告框中。 </div><div class="t m0 x5 h53 y59e ff8 fs2 fc0 sc0 lsb ws5">JavaScript中的window对象除了扮演ECMAScript规定的Global对象的角色外，</div><div class="t m0 x0 h5 y59f ff9 fs2 fc0 sc0 ls8 ws14">还承担了很多别的任务。第8章在讨论浏览器对象模型时将详细介绍window对象。 </div><div class="t m0 x0 h54 y848 fff fs2 fc0 sc0 ls8 ws1">另一种取得Global对象的方法是使用以下代码： </div><div class="t m0 x0 hb y849 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y84a ff10 fs6 fc0 sc0 ls21 wsb">var global = function(){ </div><div class="t m0 x0 hb y84b ff10 fs6 fc0 sc0 ls21 wsb">    return this;  </div><div class="t m0 x0 hb y84c ff10 fs6 fc0 sc0 ls21 wsb">}(); </div><div class="t m0 x0 h5 y84d ff8 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y84e fff fs2 fc0 sc0 ls8 ws1">以上代码创建了一个立即调用的函数表达式，返回this的值。如前所述，在没有给函数明确指定</div><div class="t m0 x0 h4 y84f ff10 fs1 fc0 sc0 ls9 ws2">this值的情况下（无论是通过将函数添加为对象的方法，还是通过调用call()或apply()），this</div><div class="t m0 x0 h4 y850 fff fs2 fc0 sc0 ls8 ws1">值等于Global对象。而像这样通过简单地返回this来取得 Global对象，在任何执行环境下都是可</div><div class="t m0 x0 h5 y851 fff fs2 fc0 sc0 ls8 ws1">行的。第7章将深入讨论函数表达式。 </div><div class="t m0 x0 h20 y852 ffe fs3 fc0 sc0 ls4d ws40">5.7.2 Math对象 </div><div class="t m0 x0 h5 y853 ff8 fs2 fc0 sc0 ls1a ws1c">ECMAScript还为保存数学公式和信息提供了一个公共位置，即Math对象。与我们在JavaScript直</div><div class="t m0 x0 h4 y854 fff fs2 fc0 sc0 ls8 ws1">接编写的计算功能相比，Math对象提供的计算功能执行起来要快得多。Math对象中还提供了辅助完成</div><div class="t m0 x0 h5 y855 fff fs2 fc0 sc0 ls8 ws1">这些计算的属性和方法。 </div><div class="t m0 x0 h4e y856 ffe fs2 fc0 sc0 ls2e wsb">1. Math对象的属性 </div><div class="t m0 x0 h5 y857 ff10 fs1 fc0 sc0 ls9 ws2">Math对象包含的属性大都是数学计算中可能会用到的一些特殊值。下表列出了这些属性。 </div><div class="t m0 x0 hb y858 ff10 fs6 fc0 sc0 ls8 wsb">  </div><div class="t m0 x5 h31 y859 ffc fs6 fc0 sc0 lsa7 wsb">属  性 说  明 </div><div class="t m0 x5 h32 y85a ff10 fsc fc0 sc0 lsa8 wsb">Math.E  自然对数的底数，即常量e的值 </div><div class="t m0 x5 h32 y85b ff10 fsc fc0 sc0 lsa8 wsb">Math.LN10  10的自然对数 </div><div class="t m0 x5 h32 y85c ff10 fsc fc0 sc0 lsa8 wsb">Math.LN2  2的自然对数 </div><div class="t m0 x5 h32 y85d ff10 fsc fc0 sc0 lsa8 wsb">Math.LOG2E  以2为底e的对数 </div><div class="t m0 x5 h32 y85e ff10 fsc fc0 sc0 lsa8 wsb">Math.LOG10E  以10为底e的对数 </div><div class="t m0 x5 h32 y85f ff10 fsc fc0 sc0 lsa8 wsb">Math.PI  π的值 </div><div class="t m0 x5 h32 y283 ff10 fsc fc0 sc0 lsa8 wsb">Math.SQRT1_2  1/2的平方根（即2的平方根的倒数） </div><div class="t m0 x5 h32 y860 ff10 fsc fc0 sc0 lsa8 wsb">Math.SQRT2  2的平方根 </div><div class="t m0 x0 hb y861 ff10 fs6 fc0 sc0 ls8 wsb">  </div><div class="t m0 x0 h5 y862 fff fs2 fc0 sc0 ls8 ws1">虽然讨论这些值的含义和用途超出了本书范围，但你确实可以随时使用它们。 </div><div class="t m0 x0 h47 y863 ffe fs2 fc0 sc0 ls2e wsb">2. min()和max()方法 </div><div class="t m0 x0 h5 y688 ff10 fs1 fc0 sc0 ls9 ws2">Math对象还包含许多方法，用于辅助完成简单和复杂的数学计算。 </div><div class="t m0 x0 h1e y689 fff fs2 fc0 sc0 ls8 ws1">其中，min()和max()方法用于确定一组数值中的最小值和最大值。这两个方法都可以接收任意多</div><div class="t m0 x0 h5 y864 fff fs2 fc0 sc0 ls8 ws1">个数值参数，如下面的例子所示。 </div><div class="t m0 x0 hb y865 ff10 fs6 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf99" class="pf w0 h0" data-page-no="99"><div class="pc pc99 w0 h0"><div class="t m0 x2 h2 y1 ff8 fs0 fc0 sc0 ls10 wsc">5.7 单体内置对象    135 </div><div class="t m0 x0 h3 y2 ff8 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffa fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ffa fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffa fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffa fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffa fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffa fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffa fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffa fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffa fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffa fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffa fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffa fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ffa fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x5 hb y866 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y867 ff10 fs6 fc0 sc0 ls21 wsb">var max = Math.max(3, 54, 32, 16); </div><div class="t m0 x0 hb y868 ff10 fs6 fc0 sc0 ls21 wsb">alert(max);    //54 </div><div class="t m0 x0 hb y869 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y86a ff10 fs6 fc0 sc0 ls21 wsb">var min = Math.min(3, 54, 32, 16); </div><div class="t m0 x0 hb y86b ff10 fs6 fc0 sc0 ls21 wsb">alert(min);    //3 </div><div class="t m0 x5 hb y86c ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y86d ff12 fs2 fc0 sc0 ls1b wsb">MathObjectMinMaxExample01.htm </div><div class="t m0 x0 h5 y86e fff fs2 fc0 sc0 ls8 ws1">对于3、54、32和16，Math.max()返回54，而Math.min()返回3。这两个方法经常用于避免多</div><div class="t m0 x0 hc y86f fff fs2 fc0 sc0 ls8 ws1">余的循环和在if语句中确定一组数的最大值。 </div><div class="t m0 x0 hc y870 fff fs2 fc0 sc0 ls8 ws1">要找到数组中的最大或最小值，可以像下面这样使用apply()方法。 </div><div class="t m0 x0 hb y871 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y872 ff10 fs6 fc0 sc0 ls21 wsb">var values = [1, 2, 3, 4, 5, 6, 7, 8]; </div><div class="t m0 x0 hb y873 ff10 fs6 fc0 sc0 ls21 wsb">var max = Math.max.apply(Math, values); </div><div class="t m0 x0 hb y874 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y875 fff fs2 fc0 sc0 ls8 ws1">这个技巧的关键是把Math对象作为apply()的第一个参数，从而正确地设置this 值。然后，可</div><div class="t m0 x0 h5 y876 fff fs2 fc0 sc0 ls8 ws1">以将任何数组作为第二个参数。 </div><div class="t m0 x0 h3c y877 ffe fs2 fc0 sc0 ls2e wsb">3. 舍入方法 </div><div class="t m0 x0 h4 y878 fff fs2 fc0 sc0 ls8 ws1">下面来介绍将小数值舍入为整数的几个方法：Math.ceil()、Math.floor()和Math.round()。</div><div class="t m0 x0 h5 y879 fff fs2 fc0 sc0 ls8 ws1">这三个方法分别遵循下列舍入规则： </div><div class="t m0 x0 h5 y87a ffd fs1 fc0 sc0 ls2"> Math.ceil()执行向上舍入，即它总是将数值向上舍入为最接近的整数； </div><div class="t m0 x0 h5 y87b ffd fs1 fc0 sc0 ls2"> Math.floor()执行向下舍入，即它总是将数值向下舍入为最接近的整数； </div><div class="t m0 x0 h4 y87c ffd fs1 fc0 sc0 ls2"> Math.round()执行标准舍入，即它总是将数值四舍五入为最接近的整数（这也是我们在数学课</div><div class="t m0 x5 h5 y87d fff fs2 fc0 sc0 ls8 ws1">上学到的舍入规则）。 </div><div class="t m0 x0 h5 y87e fff fs2 fc0 sc0 ls8 ws1">下面是使用这些方法的示例： </div><div class="t m0 x5 hb y87f ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y880 ff10 fs6 fc0 sc0 ls21 wsb">alert(Math.ceil(25.9));     //26 </div><div class="t m0 x0 hb y881 ff10 fs6 fc0 sc0 ls21 wsb">alert(Math.ceil(25.5));     //26 </div><div class="t m0 x0 hb y882 ff10 fs6 fc0 sc0 ls21 wsb">alert(Math.ceil(25.1));     //26 </div><div class="t m0 x0 hb y883 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y884 ff10 fs6 fc0 sc0 ls21 wsb">alert(Math.round(25.9));    //26 </div><div class="t m0 x0 hb y885 ff10 fs6 fc0 sc0 ls21 wsb">alert(Math.round(25.5));    //26 </div><div class="t m0 x0 hb y886 ff10 fs6 fc0 sc0 ls21 wsb">alert(Math.round(25.1));    //25 </div><div class="t m0 x0 hb y887 ff10 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 hb y888 ff10 fs6 fc0 sc0 ls21 wsb">alert(Math.floor(25.9));    //25 </div><div class="t m0 x0 hb y889 ff10 fs6 fc0 sc0 ls21 wsb">alert(Math.floor(25.5));    //25 </div><div class="t m0 x0 hb y88a ff10 fs6 fc0 sc0 ls21 wsb">alert(Math.floor(25.1));    //25 </div><div class="t m0 x5 hb y88b ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y88c ff12 fs2 fc0 sc0 ls79 wsb">MathObjectRoundingExample01.htm </div><div class="t m0 x0 h5 y88d fff fs2 fc0 sc0 ls8 ws1">对于所有介于25和26（不包括26）之间的数值，Math.ceil()始终返回26，因为它执行的是向</div><div class="t m0 x0 h5 y88e fff fs2 fc0 sc0 ls8 ws1">上舍入。Math.round()方法只在数值大于等于25.5时返回26；否则返回 25。最后，Math.floor()</div><div class="t m0 x0 h5 y785 fff fs2 fc0 sc0 ls8 ws1">对所有介于25和26（不包括26）之间的数值都返回25。 </div><div class="t m0 x0 h47 y88f ffe fs2 fc0 sc0 ls2e wsb">4. random()方法 </div><div class="t m0 x0 h5 y890 ff10 fs1 fc0 sc0 ls9 ws2">Math.random()方法返回大于等于0小于1的一个随机数。对于某些站点来说，这个方法非常实用，</div><div class="t m0 x0 h4 y891 fff fs2 fc0 sc0 ls8 ws1">因为可以利用它来随机显示一些名人名言和新闻事件。套用下面的公式，就可以利用Math.random()</div><div class="t m0 x0 h5 y892 fff fs2 fc0 sc0 ls8 ws1">从某个整数范围内随机选择一个值。 </div><div class="t m0 x5 hb y893 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y894 ff15 fs6 fc0 sc0 ls95">值 = Math.floor(Math.random() * 可能值的总数 + 第一个可能的值) </div><div class="t m0 x5 hb y895 ff10 fs6 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf9a" class="pf w0 h0" data-page-no="9a"><div class="pc pc9a w0 h0"><div class="t m0 x0 h2 y1 ff8 fs0 fc0 sc0 ls7 ws0">136  第5章 引用类型 </div><div class="t m0 x0 h3 y2 ff8 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 fff fs2 fc0 sc0 ls8 ws1">公式中用到了Math.floor()方法，这是因为Math.random()总返回一个小数值。而用这个小数</div><div class="t m0 x0 h5 y4d fff fs2 fc0 sc0 ls8 ws1">值乘以一个整数，然后再加上一个整数，最终结果仍然还是一个小数。举例来说，如果你想选择一个1</div><div class="t m0 x0 h5 yd8 fff fs2 fc0 sc0 ls3b">到10之间的数值，可以像下面这样编写代码： </div><div class="t m0 x0 hb y41f ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y897 ff10 fs6 fc0 sc0 ls21 wsb">var num = Math.floor(Math.random() * 10 + 1); </div><div class="t m0 x0 hb y898 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf y899 ff12 fs2 fc0 sc0 ls1b wsb">MathObjectRandomExample01.htm </div><div class="t m0 x0 h5 y89a fff fs2 fc0 sc0 ls8 ws1">总共有10个可能的值（1到10），而第一个可能的值是1。而如果想要选择一个介于2到10之间的</div><div class="t m0 x0 h5 y89b fff fs2 fc0 sc0 ls8 ws1">值，就应该将上面的代码改成这样： </div><div class="t m0 x0 hb y89c ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y89d ff10 fs6 fc0 sc0 ls21 wsb">var num = Math.floor(Math.random() * 9 + 2); </div><div class="t m0 x0 hb y89e ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf y89f ff12 fs2 fc0 sc0 ls1b wsb">MathObjectRandomExample02.htm </div><div class="t m0 x0 h5 y8a0 fff fs2 fc0 sc0 ls3b">从2数到10要数9个数，因此可能值的总数就是9，而第一个可能的值就是2。多数情况下，其实</div><div class="t m0 x0 h5 y8a1 fff fs2 fc0 sc0 ls8 ws1">都可以通过一个函数来计算可能值的总数和第一个可能的值，例如： </div><div class="t m0 x0 hb y8a2 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y8a3 ff10 fs6 fc0 sc0 ls21 wsb">function selectFrom(lowerValue, upperValue) { </div><div class="t m0 x0 hb y8a4 ff10 fs6 fc0 sc0 ls21 wsb">    var choices = upperValue - lowerValue + 1; </div><div class="t m0 x0 hb y8a5 ff10 fs6 fc0 sc0 ls21 wsb">    return Math.floor(Math.random() * choices + lowerValue); </div><div class="t m0 x0 hb y8a6 ff10 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y8a7 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y8a8 ff10 fs6 fc0 sc0 ls21 wsb">var num = selectFrom(2, 10); </div><div class="t m0 x0 h16 y8a9 ff10 fs6 fc0 sc0 ls21 wsb">alert(num);   // 介于2和10之间（包括2和10）的一个数值 </div><div class="t m0 x0 hb y8aa ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf y8ab ff12 fs2 fc0 sc0 ls1b wsb">MathObjectRandomExample03.htm </div><div class="t m0 x0 h5 y8ac fff fs2 fc0 sc0 ls8 ws1">函数selectFrom()接受两个参数：应该返回的最小值和最大值。而用最大值减最小值再加1得到</div><div class="t m0 x0 h4 y8ad fff fs2 fc0 sc0 ls6 ws6">了可能值的总数，然后它又把这些数值套用到了前面的公式中。这样，通过调用selectFrom(2,10)</div><div class="t m0 x0 h5 y8ae fff fs2 fc0 sc0 ls8 ws1">就可以得到一个介于2和10之间（包括2和10）的数值了。利用这个函数，可以方便地从数组中随机</div><div class="t m0 x0 h5 y8af fff fs2 fc0 sc0 ls8 ws1">取出一项，例如： </div><div class="t m0 x0 hb y8b0 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y8b1 ff10 fs6 fc0 sc0 ls21 wsb">var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;purple&quot;, &quot;brown&quot;]; </div><div class="t m0 x0 hb y8b2 ff10 fs6 fc0 sc0 ls21 wsb">var color = colors[selectFrom(0, colors.length-1)]; </div><div class="t m0 x0 h16 y8b3 ff10 fs6 fc0 sc0 ls21 wsb">alert(color);  // 可能是数组中包含的任何一个字符串 </div><div class="t m0 x0 hb y8b4 ff10 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf y8b5 ff12 fs2 fc0 sc0 ls1b wsb">MathObjectRandomExample03.htm </div><div class="t m0 x0 h5 y8b6 fff fs2 fc0 sc0 ls127 wse8">在这个例子中，传递给selectFrom()的第二个参数是数组的长度减1，也就是数组中最后一项的位置。 </div><div class="t m0 x0 h3c y8b7 ffe fs2 fc0 sc0 ls2e wsb">5. 其他方法 </div><div class="t m0 x0 h4 y8b8 ff10 fs1 fc0 sc0 ls9 ws2">Math对象中还包含其他一些与完成各种简单或复杂计算有关的方法，但详细讨论其中每一个方法</div><div class="t m0 x0 h4 y8b9 fff fs2 fc0 sc0 ls8 ws1">的细节及适用情形超出了本书的范围。下面我们就给出一个表格，其中列出了这些没有介绍到的Math</div><div class="t m0 x0 h5 y8ba fff fs2 fc0 sc0 ls8 ws1">对象的方法。 </div><div class="t m0 x0 hb y8bb ff10 fs6 fc0 sc0 ls8 wsb">  </div><div class="t m0 x0 h31 y8bc ffc fs6 fc0 sc0 lsa7 wsb">方  法 说  明 方  法 说  明 </div><div class="t m0 x0 h32 y8bd ff10 fsc fc0 sc0 lsa8 ws80">Math.abs(num)  返回num</div><div class="t m3 x1 h56 y8be ff18 fsc fc0 sc0 ls8 wsb"> </div><div class="t m0 x1 h57 y8be fff fs6 fc0 sc0 ls8 ws33">的绝对值 Math.asin(x)  返回x</div><div class="t m3 x2 h32 y8be ff10 fsc fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 h36 y8be fff fs6 fc0 sc0 ls8 ws33">的反正弦值 </div><div class="t m0 x0 h32 y4ea ff10 fsc fc0 sc0 lsa8 ws80">Math.exp(num)  返回Math.E</div><div class="t m3 x7 h56 y8bf ff18 fsc fc0 sc0 ls8 wsb"> </div><div class="t m0 x7 h58 y8bf fff fs6 fc0 sc0 ls6c">的num</div><div class="t m3 x7 h56 y8bf ff18 fsc fc0 sc0 ls8 wsb"> </div><div class="t m0 x7 h57 y8bf fff fs6 fc0 sc0 ls31">次幂 Math.atan(x)  返回x</div><div class="t m3 x2 h32 y8bf ff10 fsc fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 h36 y8bf fff fs6 fc0 sc0 ls8 ws33">的反正切值 </div><div class="t m0 x0 h32 y8c0 ff10 fsc fc0 sc0 lsa8 ws80">Math.log(num)  返回num</div><div class="t m3 x1 h56 y39f ff18 fsc fc0 sc0 ls8 wsb"> </div><div class="t m0 x1 h57 y39f fff fs6 fc0 sc0 ls8 ws33">的自然对数 Math.atan2(y,x)  返回y/x</div><div class="t m3 x2 h32 y39f ff10 fsc fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 h36 y39f fff fs6 fc0 sc0 ls8 ws33">的反正切值 </div><div class="t m0 x0 h32 y8c1 ff10 fsc fc0 sc0 lsa8 ws80">Math.pow(num,power)  返回num</div><div class="t m3 x1 h56 y8c2 ff18 fsc fc0 sc0 ls8 wsb"> </div><div class="t m0 x1 h58 y8c2 fff fs6 fc0 sc0 ls6c">的power</div><div class="t m3 x7 h56 y8c2 ff18 fsc fc0 sc0 ls8 wsb"> </div><div class="t m0 x7 h57 y8c2 fff fs6 fc0 sc0 ls31">次幂 Math.cos(x)  返回x</div><div class="t m3 x2 h32 y8c2 ff10 fsc fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 h36 y8c2 fff fs6 fc0 sc0 ls8 ws33">的余弦值 </div><div class="t m0 x0 h32 y8c3 ff10 fsc fc0 sc0 lsa8 ws80">Math.sqrt(num)  返回num</div><div class="t m3 x1 h56 y8c4 ff18 fsc fc0 sc0 ls8 wsb"> </div><div class="t m0 x1 h57 y8c4 fff fs6 fc0 sc0 ls8 ws33">的平方根 Math.sin(x)  返回x</div><div class="t m3 x2 h32 y8c4 ff10 fsc fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 h36 y8c4 fff fs6 fc0 sc0 ls8 ws33">的正弦值 </div><div class="t m0 x0 h32 y8c5 ff10 fsc fc0 sc0 lsa8 ws80">Math.acos(x)  返回x</div><div class="t m3 x1 h56 y49 ff18 fsc fc0 sc0 ls8 wsb"> </div><div class="t m0 x1 h57 y49 fff fs6 fc0 sc0 ls8 ws33">的反余弦值 Math.tan(x)  返回x</div><div class="t m3 x2 h56 y49 ff18 fsc fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 h36 y49 fff fs6 fc0 sc0 ls8 ws33">的正切值 </div></div></div>
<div id="pf9b" class="pf w0 h0" data-page-no="9b"><div class="pc pc9b w0 h0"><div class="t m0 x2 h2 y1 ff8 fs0 fc0 sc0 ls10 wsc">5.8 小结  137 </div><div class="t m0 x0 h3 y2 ff8 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffa fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ffa fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffa fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffa fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffa fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffa fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffa fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffa fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffa fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffa fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffa fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffa fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ffa fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 fff fs2 fc0 sc0 ls8 ws1">虽然ECMA-262规定了这些方法，但不同实现可能会对这些方法采用不同的算法。毕竟，计算某个</div><div class="t m0 x0 h5 y4d fff fs2 fc0 sc0 ls8 ws1">值的正弦、余弦和正切的方式多种多样。也正因为如此，这些方法在不同的实现中可能会有不同的精度。 </div><div class="t m0 x0 hd y8c6 ffe fs7 fc0 sc0 ls22">5.8 小结 </div><div class="t m0 x0 h5 y8c7 fff fs2 fc0 sc0 ls8 ws1">对象在JavaScript中被称为引用类型的值，而且有一些内置的引用类型可以用来创建特定的对象，</div><div class="t m0 x0 h5 y8c8 fff fs2 fc0 sc0 ls8 ws1">现简要总结如下： </div><div class="t m0 x0 h5 y1f ffd fs1 fc0 sc0 ls2"> 引用类型与传统面向对象程序设计中的类相似，但实现不同； </div><div class="t m0 x0 h5 y8c9 ffd fs1 fc0 sc0 ls2"> Object是一个基础类型，其他所有类型都从Object继承了基本的行为； </div><div class="t m0 x0 h5 y8ca ffd fs1 fc0 sc0 ls2"> Array类型是一组值的有序列表，同时还提供了操作和转换这些值的功能； </div><div class="t m0 x0 h5 y8cb ffd fs1 fc0 sc0 ls2"> Date类型提供了有关日期和时间的信息，包括当前日期和时间以及相关的计算功能； </div><div class="t m0 x0 h5 y8cc ffd fs1 fc0 sc0 ls2"> RegExp类型是ECMAScript支持正则表达式的一个接口，提供了最基本的和一些高级的正则表</div><div class="t m0 x5 h5 y8cd fff fs2 fc0 sc0 ls8 ws1">达式功能。 </div><div class="t m0 x0 hc y8ce fff fs2 fc0 sc0 ls8 ws1">函数实际上是Function类型的实例，因此函数也是对象；而这一点正是JavaScript最有特色的地</div><div class="t m0 x0 h5 y8cf fff fs2 fc0 sc0 ls8 ws1">方。由于函数是对象，所以函数也拥有方法，可以用来增强其行为。 </div><div class="t m0 x0 h5 y8d0 fff fs2 fc0 sc0 ls8 ws1">因为有了基本包装类型，所以JavaScript中的基本类型值可以被当作对象来访问。三种基本包装类</div><div class="t m0 x0 he y8d1 fff fs2 fc0 sc0 ls8 ws1">型分别是：Boolean、Number和String。以下是它们共同的特征： </div><div class="t m0 x0 h5 y74c ffd fs1 fc0 sc0 ls2"> 每个包装类型都映射到同名的基本类型； </div><div class="t m0 x0 h4 y8d2 ffd fs1 fc0 sc0 ls2"> 在读取模式下访问基本类型值时，就会创建对应的基本包装类型的一个对象，从而方便了数据</div><div class="t m0 x5 h5 y8d3 fff fs2 fc0 sc0 ls8">操作； </div><div class="t m0 x0 h5 y31e ffd fs1 fc0 sc0 ls2"> 操作基本类型值的语句一经执行完毕，就会立即销毁新创建的包装对象。 </div><div class="t m0 x0 h5 y8d4 fff fs2 fc0 sc0 ls5 ws4">在所有代码执行之前，作用域中就已经存在两个内置对象：Global和Math。在大多数ECMAScript</div><div class="t m0 x0 hc y8d5 fff fs2 fc0 sc0 ls5 ws4">实现中都不能直接访问Global对象；不过，Web浏览器实现了承担该角色的 window对象。全局变</div><div class="t m0 x0 h1e y8d6 fff fs2 fc0 sc0 ls5 ws4">量和函数都是Global对象的属性。Math对象提供了很多属性和方法，用于辅助完成复杂的数学计算</div><div class="t m0 x0 h5 y8d7 fff fs2 fc0 sc0 ls5">任务。 </div></div></div>
<div id="pf9c" class="pf w0 h0" data-page-no="9c"><div class="pc pc9c w0 h0"><div class="t m0 x0 h2 y1 ff1a fs0 fc0 sc0 ls7 ws0">138  第6章 面向对象的程序设计 </div><div class="t m0 x0 h3 y2 ff1a fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h9 y2a ff1c fs5 fc0 sc0 ls8 wsb">面向对象的程序设计 </div><div class="t m0 x0 h3c y2b ff1d fs2 fc0 sc0 ls8">本章内容 </div><div class="t m0 x0 h5 y2c ff1f fs1 fc0 sc0 ls2"> 理解对象属性 </div><div class="t m0 x0 h5 y2d ff1f fs1 fc0 sc0 ls2"> 理解并创建对象 </div><div class="t m0 x0 h5 y2e ff1f fs1 fc0 sc0 ls2"> 理解继承 </div><div class="t m0 x0 h5 y8d9 ff1a fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y8da ff20 fs2 fc0 sc0 ls5 wsec">向对象（Object-Oriented，OO）的语言有一个标志，那就是它们都有类的概念，而通过类可</div><div class="t m0 x0 h5 y8db ff20 fs2 fc0 sc0 ls8 wseb">以创建任意多个具有相同属性和方法的对象。前面提到过，ECMAScript中没有类的概念，因</div><div class="t m0 x0 h5 y8dc ff20 fs2 fc0 sc0 ls8 wseb">此它的对象也与基于类的语言中的对象有所不同。 </div><div class="t m0 x0 h5 y8dd ff1a fs2 fc0 sc0 ls5e ws66">ECMA-262把对象定义为：“无序属性的集合，其属性可以包含基本值、对象或者函数。”严格来讲，</div><div class="t m0 x0 h4 y8de ff20 fs2 fc0 sc0 ls8 wseb">这就相当于说对象是一组没有特定顺序的值。对象的每个属性或方法都有一个名字，而每个名字都映射</div><div class="t m0 x0 h5 y8df ff20 fs2 fc0 sc0 ls8 wseb">到一个值。正因为这样（以及其他将要讨论的原因），我们可以把ECMAScript的对象想象成散列表：无</div><div class="t m0 x0 h5 y8e0 ff20 fs2 fc0 sc0 ls8 wseb">非就是一组名值对，其中值可以是数据或函数。 </div><div class="t m0 x0 h5 y8e1 ff20 fs2 fc0 sc0 ls8 wseb">每个对象都是基于一个引用类型创建的，这个引用类型可以是第5章讨论的原生类型，也可以是开</div><div class="t m0 x0 h5 y8e2 ff20 fs2 fc0 sc0 ls8 wseb">发人员定义的类型。 </div><div class="t m0 x0 hd y8e3 ff1e fs7 fc0 sc0 ls22">6.1 理解对象 </div><div class="t m0 x0 h4 y8e4 ff20 fs2 fc0 sc0 ls8 wseb">上一章曾经介绍过，创建自定义对象的最简单方式就是创建一个Object的实例，然后再为它添加</div><div class="t m0 x0 h5 y8e5 ff20 fs2 fc0 sc0 ls8 wseb">属性和方法，如下所示。 </div><div class="t m0 x0 hb y8e6 ff21 fs6 fc0 sc0 ls21 wsb">var person = new Object(); </div><div class="t m0 x0 hb y8e7 ff21 fs6 fc0 sc0 ls21 wsb">person.name = &quot;Nicholas&quot;; </div><div class="t m0 x0 hb y8e8 ff21 fs6 fc0 sc0 ls21 wsb">person.age = 29;  </div><div class="t m0 x0 hb y8e9 ff21 fs6 fc0 sc0 ls21 wsb">person.job = &quot;Software Engineer&quot;; </div><div class="t m0 x0 hb y8ea ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y8eb ff21 fs6 fc0 sc0 ls21 wsb">person.sayName = function(){ </div><div class="t m0 x0 hb y8ec ff21 fs6 fc0 sc0 ls21 wsb">    alert(this.name);  </div><div class="t m0 x0 hb y8ed ff21 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y8ee ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y7ed ff22 fs2 fc0 sc0 lsb wsb">CreatingObjectsExample01.htm </div><div class="t m0 x0 h4 y8ef ff20 fs2 fc0 sc0 ls8 wseb">上面的例子创建了一个名为person的对象，并为它添加了三个属性（name、age和job）和一个</div><div class="t m0 x0 h4 y8f0 ff20 fs2 fc0 sc0 ls8 wseb">方法（sayName()）。其中，sayName()方法用于显示this.name（将被解析为person.name）的值。</div><div class="t m0 x0 h5 y8f1 ff20 fs2 fc0 sc0 ls44 wsef">早期的JavaScript开发人员经常使用这个模式创建新对象。几年后，对象字面量成为创建这种对象的首选</div><div class="t m0 x0 h5 y8f2 ff20 fs2 fc0 sc0 ls42 wsf0">模式。前面的例子用对象字面量语法可以写成这样： </div><div class="t m0 x0 h5 y8f3 ff1a fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5a y8f4 ff1d fs5 fc0 sc0 ls8 wsb">面 </div><div class="t m0 x0 h11 y4b ff23 fsa fc0 sc0 ls8">第</div><div class="t m1 x0 h12 y4b ff24 fsb fc3 sc0 ls8">6</div><div class="t m0 x0 h11 y4b ff23 fsa fc0 sc0 ls8 ws1d">章 </div></div></div>
<div id="pf9d" class="pf w0 h0" data-page-no="9d"><div class="pc pc9d w0 h0"><div class="t m0 x2 h2 y1 ff1a fs0 fc0 sc0 ls10 wsc">6.1 理解对象    139 </div><div class="t m0 x0 h3 y2 ff1a fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff25 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff25 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff25 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff25 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff25 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff25 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff25 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff25 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff25 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff25 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff25 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff25 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff25 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y8f5 ff21 fs6 fc0 sc0 ls21 wsb">var person = { </div><div class="t m0 x0 hb y8f6 ff21 fs6 fc0 sc0 ls21 wsb">    name: &quot;Nicholas&quot;,  </div><div class="t m0 x0 hb y8f7 ff21 fs6 fc0 sc0 ls21 wsb">    age: 29, </div><div class="t m0 x0 hb y8f8 ff21 fs6 fc0 sc0 ls21 wsb">    job: &quot;Software Engineer&quot;, </div><div class="t m0 x0 hb y8f9 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y8fa ff21 fs6 fc0 sc0 ls21 wsb">    sayName: function(){ </div><div class="t m0 x0 hb y8fb ff21 fs6 fc0 sc0 ls21 wsb">        alert(this.name); </div><div class="t m0 x0 hb y8fc ff21 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y8fd ff21 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 h4 y8fe ff20 fs2 fc0 sc0 ls42 wsf0">这个例子中的person对象与前面例子中的person对象是一样的，都有相同的属性和方法。这些</div><div class="t m0 x0 h5 y8ff ff20 fs2 fc0 sc0 ls42 wsf0">属性在创建时都带有一些特征值（characteristic），JavaScript通过这些特征值来定义它们的行为。 </div><div class="t m0 x0 h20 y900 ff1e fs3 fc0 sc0 ls4d ws40">6.1.1 属性类型 </div><div class="t m0 x0 h5 y901 ff1a fs2 fc0 sc0 ls5e ws66">ECMA-262第5版在定义只有内部才用的特性（attribute）时，描述了属性（property）的各种特征。</div><div class="t m0 x0 h5 y902 ff1a fs2 fc0 sc0 ls5e ws66">ECMA-262定义这些特性是为了实现JavaScript引擎用的，因此在JavaScript中不能直接访问它们。为了</div><div class="t m0 x0 hc y903 ff20 fs2 fc0 sc0 ls24 wsf5">表示特性是内部值，该规范把它们放在了两对儿方括号中，例如[[Enumerable]]。尽管ECMA-262</div><div class="t m0 x0 h5 y904 ff20 fs2 fc0 sc0 ls3b">第3版的定义有些不同，但本书只参考第5版的描述。 </div><div class="t m0 x0 h5 y905 ff1a fs2 fc0 sc0 ls1a ws1c">ECMAScript中有两种属性：数据属性和访问器属性。 </div><div class="t m0 x0 h3c y906 ff1e fs2 fc0 sc0 ls2e wsb">1. 数据属性 </div><div class="t m0 x0 h5 y907 ff20 fs2 fc0 sc0 ls30 wsf6">数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有4个描述其行为的</div><div class="t m0 x0 h5 y908 ff20 fs2 fc0 sc0 ls24 wsf5">特性。 </div><div class="t m0 x0 h4 y909 ff1f fs1 fc0 sc0 ls2"> [[Configurable]]：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特</div><div class="t m0 x5 h4 y90a ff20 fs2 fc0 sc0 ls5 wsec">性，或者能否把属性修改为访问器属性。像前面例子中那样直接在对象上定义的属性，它们的</div><div class="t m0 x5 he y90b ff20 fs2 fc0 sc0 ls8 wseb">这个特性默认值为true。 </div><div class="t m0 x0 h4 y90c ff1f fs1 fc0 sc0 ls2"> [[Enumerable]]：表示能否通过for-in循环返回属性。像前面例子中那样直接在对象上定</div><div class="t m0 x5 h5 y90d ff20 fs2 fc0 sc0 ls8 wseb">义的属性，它们的这个特性默认值为true。 </div><div class="t m0 x0 h4 y90e ff1f fs1 fc0 sc0 ls2"> [[Writable]]：表示能否修改属性的值。像前面例子中那样直接在对象上定义的属性，它们的</div><div class="t m0 x5 hc y90f ff20 fs2 fc0 sc0 ls8 wseb">这个特性默认值为true。 </div><div class="t m0 x0 h4 y910 ff1f fs1 fc0 sc0 ls2"> [[Value]]：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候，</div><div class="t m0 x5 h5 y911 ff20 fs2 fc0 sc0 ls8 wseb">把新值保存在这个位置。这个特性的默认值为undefined。 </div><div class="t m0 x0 h1e y912 ff20 fs2 fc0 sc0 ls8 wseb">对于像前面例子中那样直接在对象上定义的属性，它们的[[Configurable]]、[[Enumerable]]</div><div class="t m0 x0 h5 y913 ff20 fs2 fc0 sc0 ls8 wseb">和[[Writable]]特性都被设置为true，而[[Value]]特性被设置为指定的值。例如： </div><div class="t m0 x0 hb y914 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y915 ff21 fs6 fc0 sc0 ls21 wsb">var person = { </div><div class="t m0 x0 hb y916 ff21 fs6 fc0 sc0 ls21 wsf8"> name: &quot;Nicholas&quot; </div><div class="t m0 x0 hb y917 ff21 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y918 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y919 ff20 fs2 fc0 sc0 ls8 wseb">这里创建了一个名为name的属性，为它指定的值是&quot;Nicholas&quot;。也就是说，[[Value]]特性将</div><div class="t m0 x0 hc y91a ff20 fs2 fc0 sc0 ls8 wseb">被设置为&quot;Nicholas&quot;，而对这个值的任何修改都将反映在这个位置。 </div><div class="t m0 x0 h5 y91b ff20 fs2 fc0 sc0 ls8 wseb">要修改属性默认的特性，必须使用ECMAScript 5的Object.defineProperty()方法。这个方法</div><div class="t m0 x0 h5 y91c ff20 fs2 fc0 sc0 ls8 wseb">接收三个参数：属性所在的对象、属性的名字和一个描述符对象。其中，描述符（descriptor）对象的属</div><div class="t m0 x0 h1e y91d ff20 fs2 fc0 sc0 ls8 wseb">性必须是：configurable、enumerable、writable和value。设置其中的一或多个值，可以修改</div><div class="t m0 x0 h5 y91e ff20 fs2 fc0 sc0 ls8 wseb">对应的特性值。例如： </div><div class="t m0 x0 h5 y91f ff1a fs2 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf9e" class="pf w0 h0" data-page-no="9e"><div class="pc pc9e w0 h0"><div class="t m0 x0 h2 y1 ff1a fs0 fc0 sc0 ls7 ws0">140  第6章 面向对象的程序设计 </div><div class="t m0 x0 h3 y2 ff1a fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 ff21 fs6 fc0 sc0 ls21 wsb">var person = {}; </div><div class="t m0 x0 hb y7a ff21 fs6 fc0 sc0 ls21 wsb">Object.defineProperty(person, &quot;name&quot;, { </div><div class="t m0 x0 hb y7b ff21 fs6 fc0 sc0 ls21 wsb">    writable: false, </div><div class="t m0 x0 hb y7c ff21 fs6 fc0 sc0 ls21 wsb">    value: &quot;Nicholas&quot;  </div><div class="t m0 x0 hb y7d ff21 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 hb y7e ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y7f ff21 fs6 fc0 sc0 ls21 wsb">alert(person.name);  //&quot;Nicholas&quot; </div><div class="t m0 x0 hb y80 ff21 fs6 fc0 sc0 ls21 wsb">person.name = &quot;Greg&quot;; </div><div class="t m0 x0 hb y81 ff21 fs6 fc0 sc0 ls21 wsb">alert(person.name);  //&quot;Nicholas&quot; </div><div class="t m0 x2 hf y1cd ff22 fs2 fc0 sc0 ls79 wsb">DataPropertiesExample01.htm </div><div class="t m0 x0 h4 y921 ff20 fs2 fc0 sc0 ls8 wseb">这个例子创建了一个名为name的属性，它的值&quot;Nicholas&quot;是只读的。这个属性的值是不可修改</div><div class="t m0 x0 h4 y922 ff20 fs2 fc0 sc0 ls8 wseb">的，如果尝试为它指定新值，则在非严格模式下，赋值操作将被忽略；在严格模式下，赋值操作将会导</div><div class="t m0 x0 h5 y923 ff20 fs2 fc0 sc0 ls8 wseb">致抛出错误。 </div><div class="t m0 x0 h5 y924 ff20 fs2 fc0 sc0 ls8 wseb">类似的规则也适用于不可配置的属性。例如： </div><div class="t m0 x0 hb y925 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y926 ff21 fs6 fc0 sc0 ls21 wsb">var person = {}; </div><div class="t m0 x0 hb y927 ff21 fs6 fc0 sc0 ls21 wsb">Object.defineProperty(person, &quot;name&quot;, { </div><div class="t m0 x0 hb y928 ff21 fs6 fc0 sc0 ls21 wsb">    configurable: false, </div><div class="t m0 x0 hb y929 ff21 fs6 fc0 sc0 ls21 wsb">    value: &quot;Nicholas&quot; </div><div class="t m0 x0 hb y92a ff21 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 hb y92b ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y92c ff21 fs6 fc0 sc0 ls21 wsb">alert(person.name);  //&quot;Nicholas&quot; </div><div class="t m0 x0 hb y92d ff21 fs6 fc0 sc0 ls21 wsb">delete person.name; </div><div class="t m0 x0 hb y92e ff21 fs6 fc0 sc0 ls21 wsb">alert(person.name);  //&quot;Nicholas&quot; </div><div class="t m0 x2 hf y365 ff22 fs2 fc0 sc0 ls79 wsb">DataPropertiesExample02.htm </div><div class="t m0 x0 h4 y92f ff20 fs2 fc0 sc0 ls2c">把configurable设置为false，表示不能从对象中删除属性。如果对这个属性调用delete，则</div><div class="t m0 x0 h4 y930 ff20 fs2 fc0 sc0 ls8 wseb">在非严格模式下什么也不会发生，而在严格模式下会导致错误。而且，一旦把属性定义为不可配置的，</div><div class="t m0 x0 h1e y931 ff20 fs2 fc0 sc0 ls8 wseb">就不能再把它变回可配置了。此时，再调用Object.defineProperty()方法修改除writable之外</div><div class="t m0 x0 h5 y932 ff20 fs2 fc0 sc0 ls8 wseb">的特性，都会导致错误： </div><div class="t m0 x0 hb y90e ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y933 ff21 fs6 fc0 sc0 ls21 wsb">var person = {}; </div><div class="t m0 x0 hb y934 ff21 fs6 fc0 sc0 ls21 wsb">Object.defineProperty(person, &quot;name&quot;, { </div><div class="t m0 x0 hb y935 ff21 fs6 fc0 sc0 ls21 wsb">    configurable: false, </div><div class="t m0 x0 hb y936 ff21 fs6 fc0 sc0 ls21 wsb">    value: &quot;Nicholas&quot; </div><div class="t m0 x0 hb y937 ff21 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 hb y938 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y939 ff21 fs6 fc0 sc0 ls21">//抛出错误 </div><div class="t m0 x0 hb y93a ff21 fs6 fc0 sc0 ls21 wsb">Object.defineProperty(person, &quot;name&quot;, { </div><div class="t m0 x0 hb y93b ff21 fs6 fc0 sc0 ls21 wsb">    configurable: true, </div><div class="t m0 x0 hb y93c ff21 fs6 fc0 sc0 ls21 wsb">    value: &quot;Nicholas&quot; </div><div class="t m0 x0 hb y93d ff21 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x2 hf y93e ff22 fs2 fc0 sc0 ls79 wsb">DataPropertiesExample03.htm </div><div class="t m0 x0 h4 y93f ff20 fs2 fc0 sc0 ls42 wsf0">也就是说，可以多次调用Object.defineProperty()方法修改同一个属性，但在把configurable</div><div class="t m0 x0 h5 y940 ff20 fs2 fc0 sc0 ls42 wsf0">特性设置为false之后就会有限制了。 </div><div class="t m0 x0 h1e y941 ff20 fs2 fc0 sc0 ls4c wsfa">在调用Object.defineProperty()方法时，如果不指定，configurable、enumerable和</div><div class="t m0 x0 h4 y942 ff21 fs1 fc0 sc0 ls9 ws2">writable特性的默认值都是false。多数情况下，可能都没有必要利用Object.defineProperty()</div><div class="t m0 x0 h5 y943 ff20 fs2 fc0 sc0 ls8 wseb">方法提供的这些高级功能。不过，理解这些概念对理解JavaScript对象却非常有用。 </div><div class="t m0 x0 h5 y944 ff1a fs2 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf9f" class="pf w0 h0" data-page-no="9f"><div class="pc pc9f w0 h0"><div class="t m0 x2 h2 y1 ff1a fs0 fc0 sc0 ls10 wsc">6.1 理解对象    141 </div><div class="t m0 x0 h3 y2 ff1a fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff25 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff25 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff25 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff25 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff25 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff25 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff25 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff25 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff25 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff25 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff25 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff25 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff25 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y70f ff1a fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x5 h5 y945 ff1a fs2 fc0 sc0 ls2a ws21">IE8是第一个实现Object.defineProperty()方法的浏览器版本。然而，这个</div><div class="t m0 x5 h5 y946 ff1b fs2 fc0 sc0 ls8 ws14">版本的实现存在诸多限制：只能在DOM对象上使用这个方法，而且只能创建访问器</div><div class="t m0 x5 h5 y947 ff1b fs2 fc0 sc0 ls8 ws14">属性。由于实现不彻底，建议读者不要在IE8中使用Object.defineProperty()</div><div class="t m0 x5 h5 y948 ff1b fs2 fc0 sc0 ls8">方法。 </div><div class="t m0 x0 h3c y949 ff1e fs2 fc0 sc0 ls2e wsb">2. 访问器属性 </div><div class="t m0 x0 h5 y94a ff20 fs2 fc0 sc0 ls8 wseb">访问器属性不包含数据值；它们包含一对儿getter和setter函数（不过，这两个函数都不是必需的）。</div><div class="t m0 x0 h5 y94b ff20 fs2 fc0 sc0 ls8 wseb">在读取访问器属性时，会调用getter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用</div><div class="t m0 x0 h5 y94c ff1a fs2 fc0 sc0 lsf wsa">setter函数并传入新值，这个函数负责决定如何处理数据。访问器属性有如下4个特性。 </div><div class="t m0 x0 h4 y94d ff1f fs1 fc0 sc0 ls2"> [[Configurable]]：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特</div><div class="t m0 x5 h4 y94e ff20 fs2 fc0 sc0 ls55 wsfc">性，或者能否把属性修改为数据属性。对于直接在对象上定义的属性，这个特性的默认值为</div><div class="t m0 x5 h5 y5f4 ff21 fs1 fc0 sc0 ls9 ws2">true。 </div><div class="t m0 x0 h4 y94f ff1f fs1 fc0 sc0 ls2"> [[Enumerable]]：表示能否通过for-in循环返回属性。对于直接在对象上定义的属性，这</div><div class="t m0 x5 h5 y950 ff20 fs2 fc0 sc0 ls8 wseb">个特性的默认值为true。 </div><div class="t m0 x0 h5 y951 ff1f fs1 fc0 sc0 ls2"> [[Get]]：在读取属性时调用的函数。默认值为undefined。 </div><div class="t m0 x0 h5 y952 ff1f fs1 fc0 sc0 ls2"> [[Set]]：在写入属性时调用的函数。默认值为undefined。 </div><div class="t m0 x0 hc y953 ff20 fs2 fc0 sc0 ls8 wseb">访问器属性不能直接定义，必须使用Object.defineProperty()来定义。请看下面的例子。 </div><div class="t m0 x0 hb y954 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y955 ff21 fs6 fc0 sc0 ls21 wsb">var book = { </div><div class="t m0 x0 hb y956 ff21 fs6 fc0 sc0 ls21 wsb">    _year: 2004,  </div><div class="t m0 x0 hb y957 ff21 fs6 fc0 sc0 ls21 wsb">    edition: 1 </div><div class="t m0 x0 hb y958 ff21 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y959 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y95a ff21 fs6 fc0 sc0 ls21 wsb">Object.defineProperty(book, &quot;year&quot;, { </div><div class="t m0 x0 hb y95b ff21 fs6 fc0 sc0 ls21 wsb">    get: function(){ </div><div class="t m0 x0 hb y95c ff21 fs6 fc0 sc0 ls21 wsb">        return this._year; </div><div class="t m0 x0 hb y95d ff21 fs6 fc0 sc0 ls21 wsb">    }, </div><div class="t m0 x0 hb y95e ff21 fs6 fc0 sc0 ls21 wsb">    set: function(newValue){ </div><div class="t m0 x0 hb y95f ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y960 ff21 fs6 fc0 sc0 ls21 wsb">        if (newValue &gt; 2004) { </div><div class="t m0 x0 hb y961 ff21 fs6 fc0 sc0 ls21 wsb">            this._year = newValue; </div><div class="t m0 x0 hb y962 ff21 fs6 fc0 sc0 ls21 wsb">            this.edition += newValue - 2004; </div><div class="t m0 x0 hb y963 ff21 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y964 ff21 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y965 ff21 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 hb y966 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y967 ff21 fs6 fc0 sc0 ls21 wsb">book.year = 2005; </div><div class="t m0 x0 hb y968 ff21 fs6 fc0 sc0 ls21 wsb">alert(book.edition);  //2 </div><div class="t m0 x2 hf y969 ff22 fs2 fc0 sc0 ls8 wsb">AccessorPropertiesExample01.htm </div><div class="t m0 x0 h4 y96a ff20 fs2 fc0 sc0 ls8 wseb">以上代码创建了一个book对象，并给它定义两个默认的属性：_year和edition。_year 前面</div><div class="t m0 x0 h1e y96b ff20 fs2 fc0 sc0 ls8 wseb">的下划线是一种常用的记号，用于表示只能通过对象方法访问的属性。而访问器属性year则包含一个</div><div class="t m0 x0 hc y96c ff1a fs2 fc0 sc0 ls5e ws66">getter函数和一个setter函数。getter函数返回_year的值，setter函数通过计算来确定正确的版本。因此，</div><div class="t m0 x0 hc y96d ff20 fs2 fc0 sc0 ls131">把year属性修改为2005会导致_year变成 2005，而edition 变为2。这是使用访问器属性的常见方</div><div class="t m0 x0 h5 y96e ff20 fs2 fc0 sc0 ls8 wseb">式，即设置一个属性的值会导致其他属性发生变化。 </div></div></div>
<div id="pfa0" class="pf w0 h0" data-page-no="a0"><div class="pc pca0 w0 h0"><div class="t m0 x0 h2 y1 ff1a fs0 fc0 sc0 ls7 ws0">142  第6章 面向对象的程序设计 </div><div class="t m0 x0 h3 y2 ff1a fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff20 fs2 fc0 sc0 ls8 wseb">不一定非要同时指定getter和setter。只指定getter意味着属性是不能写，尝试写入属性会被忽略。</div><div class="t m0 x0 h5 y4d ff20 fs2 fc0 sc0 ls8 wseb">在严格模式下，尝试写入只指定了getter函数的属性会抛出错误。类似地，只指定setter 函数的属性也</div><div class="t m0 x0 he yd8 ff20 fs2 fc0 sc0 ls8 wseb">不能读，否则在非严格模式下会返回undefined，而在严格模式下会抛出错误。 </div><div class="t m0 x0 h5 yd9 ff20 fs2 fc0 sc0 ls8 wseb">支持ECMAScript 5的这个方法的浏览器有IE9+（IE8只是部分实现）、Firefox 4+、Safari 5+、Opera </div><div class="t m0 x0 h5 y15d ff1a fs2 fc0 sc0 ls8 ws20">12+和Chrome。在这个方法之前，要创建访问器属性，一般都使用两个非标准的方法：</div><div class="t m0 x0 h5 y8 ff21 fs1 fc0 sc0 ls9 ws2">__defineGetter__()和__defineSetter__()。这两个方法最初是由Firefox引入的，后来Safari 3、</div><div class="t m0 x0 h5 y15e ff1a fs2 fc0 sc0 lsf ws7a">Chrome 1和Opera 9.5也给出了相同的实现。使用这两个遗留的方法，可以像下面这样重写前面的例子。 </div><div class="t m0 x0 hb y970 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y971 ff21 fs6 fc0 sc0 ls21 wsb">var book = { </div><div class="t m0 x0 hb y972 ff27 fs6 fc0 sc0 ls21 wsb">    _year: 2004, </div><div class="t m0 x0 hb y973 ff27 fs6 fc0 sc0 ls21 wsb">    edition: 1 </div><div class="t m0 x0 hb y974 ff21 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 h15 y975 ff27 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y976 ff27 fs6 fc0 sc0 ls21 ws34">//定义访问器的旧有方法 </div><div class="t m0 x0 h15 y977 ff27 fs6 fc0 sc0 ls21 wsb">book.__defineGetter__(&quot;year&quot;, function(){ </div><div class="t m0 x0 h15 y978 ff27 fs6 fc0 sc0 ls21 wsb">    return this._year; </div><div class="t m0 x0 h15 y979 ff27 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 h15 y97a ff27 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y97b ff27 fs6 fc0 sc0 ls21 wsb">book.__defineSetter__(&quot;year&quot;, function(newValue){ </div><div class="t m0 x0 h15 y97c ff27 fs6 fc0 sc0 ls21 wsb">    if (newValue &gt; 2004) { </div><div class="t m0 x0 h15 y97d ff27 fs6 fc0 sc0 ls21 wsb">        this._year = newValue; </div><div class="t m0 x0 h15 y97e ff27 fs6 fc0 sc0 ls21 wsb">        this.edition += newValue - 2004; </div><div class="t m0 x0 h15 y97f ff27 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 h15 y980 ff27 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 hb y981 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y982 ff21 fs6 fc0 sc0 ls21 wsb">book.year = 2005; </div><div class="t m0 x0 hb y983 ff21 fs6 fc0 sc0 ls21 wsb">alert(book.edition);  //2 </div><div class="t m0 x4 hf y984 ff22 fs2 fc0 sc0 ls8 wsb">AccessorPropertiesExample02.htm </div><div class="t m0 x0 h4 y985 ff20 fs2 fc0 sc0 ls134 wsff">在不支持Object.defineProperty()方法的浏览器中不能修改[[Configurable]]和</div><div class="t m0 x0 h5 y986 ff21 fs1 fc0 sc0 ls135 ws100">[[Enumerable]]。 </div><div class="t m0 x0 h20 y987 ff1e fs3 fc0 sc0 ls4d ws40">6.1.2 定义多个属性 </div><div class="t m0 x0 h5 y988 ff20 fs2 fc0 sc0 ls26 ws101">由于为对象定义多个属性的可能性很大，ECMAScript 5又定义了一个Object.definePro- </div><div class="t m0 x0 h42 y989 ff21 fs1 fc0 sc0 ls9 ws2">perties()方法。利用这个方法可以通过描述符一次定义多个属性。这个方法接收两个对象参数：第一</div><div class="t m0 x0 h4 y2a7 ff20 fs2 fc0 sc0 ls24 wsf5">个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对</div><div class="t m0 x0 h5 y98a ff20 fs2 fc0 sc0 ls8 wseb">应。例如： </div><div class="t m0 x0 hb y98b ff21 fs6 fc0 sc0 ls21 wsb">var book = {}; </div><div class="t m0 x0 hb y98c ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y98d ff21 fs6 fc0 sc0 ls21 wsb">Object.defineProperties(book, { </div><div class="t m0 x0 hb y98e ff21 fs6 fc0 sc0 ls21 wsb">    _year: { </div><div class="t m0 x0 hb y98f ff21 fs6 fc0 sc0 ls21 wsb">        value: 2004 </div><div class="t m0 x0 hb y990 ff21 fs6 fc0 sc0 ls21 wsb">    }, </div><div class="t m0 x0 hb y991 ff21 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 hb y992 ff21 fs6 fc0 sc0 ls21 wsb">    edition: { </div><div class="t m0 x0 hb y993 ff21 fs6 fc0 sc0 ls21 wsb">        value: 1 </div><div class="t m0 x0 hb y994 ff21 fs6 fc0 sc0 ls21 wsb">    }, </div><div class="t m0 x0 hb y995 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y996 ff21 fs6 fc0 sc0 ls21 wsb">    year: { </div><div class="t m0 x0 hb y997 ff21 fs6 fc0 sc0 ls21 wsb">        get: function(){ </div></div></div>
<div id="pfa1" class="pf w0 h0" data-page-no="a1"><div class="pc pca1 w0 h0"><div class="t m0 x2 h2 y1 ff1a fs0 fc0 sc0 ls10 wsc">6.1 理解对象    143 </div><div class="t m0 x0 h3 y2 ff1a fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff25 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff25 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff25 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff25 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff25 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff25 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff25 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff25 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff25 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff25 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff25 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff25 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff25 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y79 ff21 fs6 fc0 sc0 ls21 wsb">            return this._year; </div><div class="t m0 x0 hb y7a ff21 fs6 fc0 sc0 ls21 wsb">        }, </div><div class="t m0 x0 hb y7b ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y7c ff21 fs6 fc0 sc0 ls21 wsb">        set: function(newValue){ </div><div class="t m0 x0 hb y7d ff21 fs6 fc0 sc0 ls21 wsb">            if (newValue &gt; 2004) { </div><div class="t m0 x0 hb y7e ff21 fs6 fc0 sc0 ls21 wsb">                this._year = newValue; </div><div class="t m0 x0 hb y7f ff21 fs6 fc0 sc0 ls21 wsb">                this.edition += newValue - 2004; </div><div class="t m0 x0 hb y80 ff21 fs6 fc0 sc0 ls21 wsb">            } </div><div class="t m0 x0 hb y81 ff21 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y82 ff21 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y83 ff21 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x2 hf y998 ff22 fs2 fc0 sc0 ls25 wsb">MultiplePropertiesExample01.htm </div><div class="t m0 x0 h4 y999 ff20 fs2 fc0 sc0 ls8 wseb">以上代码在book对象上定义了两个数据属性（_year和edition）和一个访问器属性（year）。</div><div class="t m0 x0 h5 y99a ff20 fs2 fc0 sc0 ls8 wseb">最终的对象与上一节中定义的对象相同。唯一的区别是这里的属性都是在同一时间创建的。 </div><div class="t m0 x0 he y99b ff20 fs2 fc0 sc0 ls8 wseb">支持Object.defineProperties()方法的浏览器有IE9+、Firefox 4+、Safari 5+、Opera 12+和</div><div class="t m0 x0 h5 y99c ff1a fs2 fc0 sc0 ls50 ws41">Chrome。 </div><div class="t m0 x0 h20 y99d ff1e fs3 fc0 sc0 ls4d ws40">6.1.3 读取属性的特性 </div><div class="t m0 x0 h5 y99e ff20 fs2 fc0 sc0 ls8 wseb">使用ECMAScript 5的Object.getOwnPropertyDescriptor()方法，可以取得给定属性的描述</div><div class="t m0 x0 h4 y99f ff20 fs2 fc0 sc0 ls8 wseb">符。这个方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象，如果</div><div class="t m0 x0 h1c y9a0 ff20 fs2 fc0 sc0 ls8 wseb">是访问器属性，这个对象的属性有configurable、enumerable、get和set；如果是数据属性，这</div><div class="t m0 x0 hc y9a1 ff20 fs2 fc0 sc0 ls8 wseb">个对象的属性有configurable、enumerable、writable和value。例如： </div><div class="t m0 x0 hb y9a2 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y9a3 ff21 fs6 fc0 sc0 ls21 wsb">var book = {}; </div><div class="t m0 x0 hb y9a4 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y9a5 ff21 fs6 fc0 sc0 ls21 wsb">Object.defineProperties(book, { </div><div class="t m0 x0 hb y9a6 ff21 fs6 fc0 sc0 ls21 wsb">    _year: {  </div><div class="t m0 x0 hb y9a7 ff21 fs6 fc0 sc0 ls21 wsb">        value: 2004 </div><div class="t m0 x0 hb y9a8 ff21 fs6 fc0 sc0 ls21 wsb">    }, </div><div class="t m0 x0 hb y9a9 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y9aa ff21 fs6 fc0 sc0 ls21 wsb">    edition: { </div><div class="t m0 x0 hb y9ab ff21 fs6 fc0 sc0 ls21 wsb">        value: 1 </div><div class="t m0 x0 hb y9ac ff21 fs6 fc0 sc0 ls21 wsb">    }, </div><div class="t m0 x0 hb y9ad ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y9ae ff21 fs6 fc0 sc0 ls21 wsb">    year: { </div><div class="t m0 x0 hb y9af ff21 fs6 fc0 sc0 ls21 wsb">        get: function(){ </div><div class="t m0 x0 hb y9b0 ff21 fs6 fc0 sc0 ls21 wsb">            return this._year; </div><div class="t m0 x0 hb y9b1 ff21 fs6 fc0 sc0 ls21 wsb">        }, </div><div class="t m0 x0 hb y9b2 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y9b3 ff21 fs6 fc0 sc0 ls21 wsb">        set: function(newValue){ </div><div class="t m0 x0 hb y9b4 ff21 fs6 fc0 sc0 ls21 wsb">            if (newValue &gt; 2004) { </div><div class="t m0 x0 hb y9b5 ff21 fs6 fc0 sc0 ls21 wsb">                this._year = newValue; </div><div class="t m0 x0 hb y9b6 ff21 fs6 fc0 sc0 ls21 wsb">                this.edition += newValue - 2004; </div><div class="t m0 x0 hb y9b7 ff21 fs6 fc0 sc0 ls21 wsb">            } </div><div class="t m0 x0 hb y9b8 ff21 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y9b9 ff21 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y9ba ff21 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 h15 y9bb ff27 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y9bc ff27 fs6 fc0 sc0 ls21 wsb">var descriptor = Object.getOwnPropertyDescriptor(book, &quot;_year&quot;); </div><div class="t m0 x0 hb y9bd ff27 fs6 fc0 sc0 ls21 ws34">alert(descriptor.value);         //2004 </div><div class="t m0 x0 h15 y9be ff27 fs6 fc0 sc0 ls21 wsb">alert(descriptor.configurable); //false </div></div></div>
<div id="pfa2" class="pf w0 h0" data-page-no="a2"><div class="pc pca2 w0 h0"><div class="t m0 x0 h2 y1 ff1a fs0 fc0 sc0 ls7 ws0">144  第6章 面向对象的程序设计 </div><div class="t m0 x0 h3 y2 ff1a fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 ff27 fs6 fc0 sc0 ls21 wsb">alert(typeof descriptor.get);    //&quot;undefined&quot; </div><div class="t m0 x0 h15 y7a ff27 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y7b ff27 fs6 fc0 sc0 ls21 wsb">var descriptor = Object.getOwnPropertyDescriptor(book, &quot;year&quot;); </div><div class="t m0 x0 hb y7c ff27 fs6 fc0 sc0 ls21 ws34">alert(descriptor.value);        //undefined </div><div class="t m0 x0 hb y7d ff27 fs6 fc0 sc0 ls21 ws34">alert(descriptor.enumerable);   //false </div><div class="t m0 x0 hb y7e ff27 fs6 fc0 sc0 ls21 wsb">alert(typeof descriptor.get);   //&quot;function&quot; </div><div class="t m0 x4 hf y9c0 ff22 fs2 fc0 sc0 ls138 wsb">GetPropertyDescriptorExample01.htm </div><div class="t m0 x0 h4 y9c1 ff20 fs2 fc0 sc0 ls8 wseb">对于数据属性_year，value等于最初的值，configurable是false，而get等于undefined。</div><div class="t m0 x0 hc y9c2 ff20 fs2 fc0 sc0 ls8 wseb">对于访问器属性year，value等于undefined，enumerable 是false，而get是一个指向getter</div><div class="t m0 x0 h5 y9c3 ff20 fs2 fc0 sc0 ls8 wseb">函数的指针。 </div><div class="t m0 x0 h5 y9c4 ff20 fs2 fc0 sc0 ls137">在JavaScript中，可以针对任何对象——包括 DOM和BOM对象，使用Object.getOwnProperty- </div><div class="t m0 x0 h21 y9c5 ff21 fs1 fc0 sc0 ls9 ws2">Descriptor()方法。支持这个方法的浏览器有IE9+、Firefox 4+、Safari 5+、Opera 12+和Chrome。 </div><div class="t m0 x0 hd y9c6 ff1e fs7 fc0 sc0 ls22">6.2 创建对象 </div><div class="t m0 x0 h4 y9c7 ff20 fs2 fc0 sc0 ls1f ws108">虽然Object构造函数或对象字面量都可以用来创建单个对象，但这些方式有个明显的缺点：使用同</div><div class="t m0 x0 h5 y9c8 ff20 fs2 fc0 sc0 ls1f ws108">一个接口创建很多对象，会产生大量的重复代码。为解决这个问题，人们开始使用工厂模式的一种变体。 </div><div class="t m0 x0 h20 y9c9 ff1e fs3 fc0 sc0 ls4d ws40">6.2.1 工厂模式 </div><div class="t m0 x0 h4 y9ca ff20 fs2 fc0 sc0 ls8 wseb">工厂模式是软件工程领域一种广为人知的设计模式，这种模式抽象了创建具体对象的过程（本书后</div><div class="t m0 x0 h5 y9cb ff20 fs2 fc0 sc0 ls8 wseb">面还将讨论其他设计模式及其在JavaScript中的实现）。考虑到在ECMAScript中无法创建类，开发人员</div><div class="t m0 x0 h5 y9cc ff20 fs2 fc0 sc0 ls8 wseb">就发明了一种函数，用函数来封装以特定接口创建对象的细节，如下面的例子所示。 </div><div class="t m0 x0 hb y9cd ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y9ce ff21 fs6 fc0 sc0 ls21 wsb">function createPerson(name, age, job){ </div><div class="t m0 x0 hb y9cf ff21 fs6 fc0 sc0 ls21 wsb">    var o = new Object(); </div><div class="t m0 x0 hb y9d0 ff21 fs6 fc0 sc0 ls21 wsb">    o.name = name; </div><div class="t m0 x0 hb y9d1 ff21 fs6 fc0 sc0 ls21 wsb">    o.age = age; </div><div class="t m0 x0 hb y9d2 ff21 fs6 fc0 sc0 ls21 wsb">    o.job = job; </div><div class="t m0 x0 hb y9d3 ff21 fs6 fc0 sc0 ls21 wsb">    o.sayName = function(){ </div><div class="t m0 x0 hb y9d4 ff21 fs6 fc0 sc0 ls21 wsb">        alert(this.name); </div><div class="t m0 x0 hb y9d5 ff21 fs6 fc0 sc0 ls21 wsb">    };     </div><div class="t m0 x0 hb y9d6 ff21 fs6 fc0 sc0 ls21 wsb">    return o; </div><div class="t m0 x0 hb y9d7 ff21 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y9d8 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y9d9 ff21 fs6 fc0 sc0 ls21 wsb">var person1 = createPerson(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;); </div><div class="t m0 x0 hb y9da ff21 fs6 fc0 sc0 ls21 wsb">var person2 = createPerson(&quot;Greg&quot;, 27, &quot;Doctor&quot;); </div><div class="t m0 x2 hf y9db ff22 fs2 fc0 sc0 ls25 wsb">FactoryPatternExample01.htm </div><div class="t m0 x0 h4 y9dc ff20 fs2 fc0 sc0 ls8 wseb">函数createPerson()能够根据接受的参数来构建一个包含所有必要信息的Person对象。可以无</div><div class="t m0 x0 h4 y9dd ff20 fs2 fc0 sc0 ls8 wseb">数次地调用这个函数，而每次它都会返回一个包含三个属性一个方法的对象。工厂模式虽然解决了创建</div><div class="t m0 x0 h5 y9de ff20 fs2 fc0 sc0 ls24 wsf5">多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）。随着JavaScript</div><div class="t m0 x0 h5 y9df ff20 fs2 fc0 sc0 ls8 wseb">的发展，又一个新模式出现了。 </div><div class="t m0 x0 h20 y9e0 ff1e fs3 fc0 sc0 ls4d ws40">6.2.2 构造函数模式 </div><div class="t m0 x0 h5 y9e1 ff20 fs2 fc0 sc0 ls8 wseb">前几章介绍过，ECMAScript中的构造函数可用来创建特定类型的对象。像Object和Array这样</div></div></div>
<div id="pfa3" class="pf w0 h0" data-page-no="a3"><div class="pc pca3 w0 h0"><div class="t m0 x2 h2 y1 ff1a fs0 fc0 sc0 ls10 wsc">6.2 创建对象    145 </div><div class="t m0 x0 h3 y2 ff1a fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff25 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff25 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff25 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff25 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff25 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff25 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff25 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff25 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff25 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff25 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff25 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff25 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff25 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h4 y3 ff20 fs2 fc0 sc0 ls8 wseb">的原生构造函数，在运行时会自动出现在执行环境中。此外，也可以创建自定义的构造函数，从而定义</div><div class="t m0 x0 h5 y4d ff20 fs2 fc0 sc0 ls8 wseb">自定义对象类型的属性和方法。例如，可以使用构造函数模式将前面的例子重写如下。 </div><div class="t m0 x5 hb y2d8 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2d9 ff21 fs6 fc0 sc0 ls21 wsb">function Person(name, age, job){ </div><div class="t m0 x0 hb y2da ff21 fs6 fc0 sc0 ls21 wsb">    this.name = name; </div><div class="t m0 x0 hb y2db ff21 fs6 fc0 sc0 ls21 wsb">    this.age = age; </div><div class="t m0 x0 hb y2dc ff21 fs6 fc0 sc0 ls21 wsb">    this.job = job; </div><div class="t m0 x0 hb y2dd ff21 fs6 fc0 sc0 ls21 wsb">    this.sayName = function(){ </div><div class="t m0 x0 hb y9e2 ff21 fs6 fc0 sc0 ls21 wsb">        alert(this.name); </div><div class="t m0 x0 hb y9e3 ff21 fs6 fc0 sc0 ls21 wsb">    };     </div><div class="t m0 x0 hb y9e4 ff21 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y9e5 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y9e6 ff21 fs6 fc0 sc0 ls21 wsb">var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;); </div><div class="t m0 x0 hb y9e7 ff21 fs6 fc0 sc0 ls21 wsb">var person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;); </div><div class="t m0 x2 hf y9e8 ff22 fs2 fc0 sc0 lsb wsb">ConstructorPatternExample01.htm </div><div class="t m0 x0 h4 y9e9 ff20 fs2 fc0 sc0 ls6 wsf7">在这个例子中，Person()函数取代了createPerson()函数。我们注意到，Person()中的代码</div><div class="t m0 x0 hc y9ea ff20 fs2 fc0 sc0 ls8 wseb">除了与createPerson()中相同的部分外，还存在以下不同之处： </div><div class="t m0 x0 h5 y9eb ff1f fs1 fc0 sc0 ls2"> 没有显式地创建对象； </div><div class="t m0 x0 h5 y9ec ff1f fs1 fc0 sc0 ls2"> 直接将属性和方法赋给了this对象； </div><div class="t m0 x0 h5 y9ed ff1f fs1 fc0 sc0 ls2"> 没有return语句。 </div><div class="t m0 x0 h1e y9ee ff20 fs2 fc0 sc0 ls8 wseb">此外，还应该注意到函数名Person使用的是大写字母P。按照惯例，构造函数始终都应该以一个</div><div class="t m0 x0 h5 y9ef ff20 fs2 fc0 sc0 ls8 wseb">大写字母开头，而非构造函数则应该以一个小写字母开头。这个做法借鉴自其他OO语言，主要是为了</div><div class="t m0 x0 h5 y9f0 ff20 fs2 fc0 sc0 ls8 wseb">区别于ECMAScript中的其他函数；因为构造函数本身也是函数，只不过可以用来创建对象而已。 </div><div class="t m0 x0 he y9f1 ff20 fs2 fc0 sc0 ls8 wseb">要创建Person的新实例，必须使用new 操作符。以这种方式调用构造函数实际上会经历以下4</div><div class="t m0 x0 h5 y9f2 ff20 fs2 fc0 sc0 ls8">个步骤： </div><div class="t m0 x0 h5 y9f3 ff1a fs2 fc0 sc0 ls13 wsb">(1) 创建一个新对象； </div><div class="t m0 x0 he y9f4 ff1a fs2 fc0 sc0 ls13 wsb">(2) 将构造函数的作用域赋给新对象（因此this就指向了这个新对象）； </div><div class="t m0 x0 h5 y9f5 ff1a fs2 fc0 sc0 ls13 wsb">(3) 执行构造函数中的代码（为这个新对象添加属性）； </div><div class="t m0 x0 h5 y9f6 ff1a fs2 fc0 sc0 ls13 wsb">(4) 返回新对象。 </div><div class="t m0 x0 h4b y9f7 ff20 fs2 fc0 sc0 ls8 wseb">在前面例子的最后，person1和person2分别保存着Person的一个不同的实例。这两个对象都</div><div class="t m0 x0 h5 y9f8 ff20 fs2 fc0 sc0 ls8 wseb">有一个constructor（构造函数）属性，该属性指向Person，如下所示。 </div><div class="t m0 x5 hb y9f9 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y9fa ff21 fs6 fc0 sc0 ls21 wsb">alert(person1.constructor == Person);  //true </div><div class="t m0 x0 hb y9fb ff21 fs6 fc0 sc0 ls21 wsb">alert(person2.constructor == Person);  //true </div><div class="t m0 x5 hb y9fc ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y9fd ff20 fs2 fc0 sc0 ls8 wseb">对象的constructor属性最初是用来标识对象类型的。但是，提到检测对象类型，还是instan- </div><div class="t m0 x0 h42 y9fe ff21 fs1 fc0 sc0 ls16 ws17">ceof操作符要更可靠一些。我们在这个例子中创建的所有对象既是Object的实例，同时也是Person</div><div class="t m0 x0 h5 y9ff ff20 fs2 fc0 sc0 ls8 wseb">的实例，这一点通过instanceof操作符可以得到验证。 </div><div class="t m0 x5 hb ya00 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ya01 ff21 fs6 fc0 sc0 ls21 wsb">alert(person1 instanceof Object);  //true </div><div class="t m0 x0 hb ya02 ff21 fs6 fc0 sc0 ls21 wsb">alert(person1 instanceof Person);  //true </div><div class="t m0 x0 hb ya03 ff21 fs6 fc0 sc0 ls21 wsb">alert(person2 instanceof Object);  //true </div><div class="t m0 x0 hb ya04 ff21 fs6 fc0 sc0 ls21 wsb">alert(person2 instanceof Person);  //true </div><div class="t m0 x5 hb ya05 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 ya06 ff20 fs2 fc0 sc0 ls8 wseb">创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型；而这正是构造函数模式</div><div class="t m0 x0 h1e ya07 ff20 fs2 fc0 sc0 ls8 wseb">胜过工厂模式的地方。在这个例子中，person1和person2之所以同时是Object的实例，是因为所</div><div class="t m0 x0 hc ya08 ff20 fs2 fc0 sc0 ls8 wseb">有对象均继承自Object（详细内容稍后讨论）。 </div></div></div>
<div id="pfa4" class="pf w0 h0" data-page-no="a4"><div class="pc pca4 w0 h0"><div class="t m0 x0 h2 y1 ff1a fs0 fc0 sc0 ls7 ws0">146  第6章 面向对象的程序设计 </div><div class="t m0 x0 h3 y2 ff1a fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 ya0a ff1a fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x5 ha ya0b ff1b fs2 fc0 sc0 ls8 ws14">以这种方式定义的构造函数是定义在Global对象（在浏览器中是window对象）</div><div class="t m0 x0 h5 ya0c ff1b fs2 fc0 sc0 ls8 ws14">中的。第8章将详细讨论浏览器对象模型（BOM）。 </div><div class="t m0 x0 h3c ya0d ff1e fs2 fc0 sc0 ls2e wsb">1. 将构造函数当作函数 </div><div class="t m0 x0 h4 ya0e ff20 fs2 fc0 sc0 ls8 wseb">构造函数与其他函数的唯一区别，就在于调用它们的方式不同。不过，构造函数毕竟也是函数，不</div><div class="t m0 x0 h4 ya0f ff20 fs2 fc0 sc0 ls8 wseb">存在定义构造函数的特殊语法。任何函数，只要通过new操作符来调用，那它就可以作为构造函数；而</div><div class="t m0 x0 h1e ya10 ff20 fs2 fc0 sc0 ls8 wseb">任何函数，如果不通过new操作符来调用，那它跟普通函数也不会有什么两样。例如，前面例子中定义</div><div class="t m0 x0 hc ya11 ff20 fs2 fc0 sc0 ls13a">的Person()函数可以通过下列任何一种方式来调用。 </div><div class="t m0 x0 hb y310 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 ya12 ff21 fs6 fc0 sc0 ls21 wsb">// 当作构造函数使用 </div><div class="t m0 x0 hb ya13 ff21 fs6 fc0 sc0 ls21 wsb">var person = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;); </div><div class="t m0 x0 hb ya14 ff21 fs6 fc0 sc0 ls21 wsb">person.sayName(); //&quot;Nicholas&quot; </div><div class="t m0 x0 hb ya15 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 ya16 ff21 fs6 fc0 sc0 ls21 wsb">// 作为普通函数调用 </div><div class="t m0 x0 h16 ya17 ff21 fs6 fc0 sc0 ls21 wsb">Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;); // 添加到window </div><div class="t m0 x0 hb ya18 ff21 fs6 fc0 sc0 ls21 wsb">window.sayName(); //&quot;Greg&quot; </div><div class="t m0 x0 hb ya19 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 ya1a ff21 fs6 fc0 sc0 ls21 wsb">// 在另一个对象的作用域中调用 </div><div class="t m0 x0 hb ya1b ff21 fs6 fc0 sc0 ls21 wsb">var o = new Object(); </div><div class="t m0 x0 hb ya1c ff21 fs6 fc0 sc0 ls21 wsb">Person.call(o, &quot;Kristen&quot;, 25, &quot;Nurse&quot;); </div><div class="t m0 x0 hb ya1d ff21 fs6 fc0 sc0 ls21 wsb">o.sayName(); //&quot;Kristen&quot; </div><div class="t m0 x0 hb ya1e ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf ya1f ff22 fs2 fc0 sc0 lsb wsb">ConstructorPatternExample02.htm </div><div class="t m0 x0 h4 ya20 ff20 fs2 fc0 sc0 ls8 wseb">这个例子中的前两行代码展示了构造函数的典型用法，即使用new操作符来创建一个新对象。接下</div><div class="t m0 x0 h1e ya21 ff20 fs2 fc0 sc0 ls8 wseb">来的两行代码展示了不使用new操作符调用Person()会出现什么结果：属性和方法都被添加给window</div><div class="t m0 x0 h4 ya22 ff20 fs2 fc0 sc0 ls8 wseb">对象了。有读者可能还记得，当在全局作用域中调用一个函数时，this对象总是指向Global对象（在</div><div class="t m0 x0 h1e ya23 ff20 fs2 fc0 sc0 ls8 wseb">浏览器中就是window对象）。因此，在调用完函数之后，可以通过window对象来调用sayName()方</div><div class="t m0 x0 h4 y601 ff20 fs2 fc0 sc0 ls8 wseb">法，并且还返回了&quot;Greg&quot;。最后，也可以使用call()（或者apply()）在某个特殊对象的作用域中</div><div class="t m0 x0 h1e ya24 ff20 fs2 fc0 sc0 ls8 wseb">调用Person()函数。这里是在对象o的作用域中调用的，因此调用后o就拥有了所有属性和sayName()</div><div class="t m0 x0 h5 y987 ff20 fs2 fc0 sc0 ls8">方法。 </div><div class="t m0 x0 h3c ya25 ff1e fs2 fc0 sc0 ls2e wsb">2. 构造函数的问题 </div><div class="t m0 x0 h4 ya26 ff20 fs2 fc0 sc0 ls8 wseb">构造函数模式虽然好用，但也并非没有缺点。使用构造函数的主要问题，就是每个方法都要在每个</div><div class="t m0 x0 h4 ya27 ff20 fs2 fc0 sc0 ls8 wseb">实例上重新创建一遍。在前面的例子中，person1和person2都有一个名为sayName()的方法，但那</div><div class="t m0 x0 h5 y913 ff20 fs2 fc0 sc0 ls8 wseb">两个方法不是同一个Function的实例。不要忘了——ECMAScript中的函数是对象，因此每定义一个</div><div class="t m0 x0 h5 ya28 ff20 fs2 fc0 sc0 ls8 wseb">函数，也就是实例化了一个对象。从逻辑角度讲，此时的构造函数也可以这样定义。 </div><div class="t m0 x0 hb ya29 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ya2a ff21 fs6 fc0 sc0 ls21 wsb">function Person(name, age, job){ </div><div class="t m0 x0 hb ya2b ff21 fs6 fc0 sc0 ls21 wsb">    this.name = name; </div><div class="t m0 x0 hb ya2c ff21 fs6 fc0 sc0 ls21 wsb">    this.age = age; </div><div class="t m0 x0 hb ya2d ff21 fs6 fc0 sc0 ls21 wsb">    this.job = job; </div><div class="t m0 x0 h16 ya2e ff27 fs6 fc0 sc0 ls21 wsb">    this.sayName = new Function(&quot;alert(this.name)&quot;); // 与声明函数在逻辑上是等价的 </div><div class="t m0 x0 hb ya2f ff21 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h4 ya30 ff20 fs2 fc0 sc0 ls8 wseb">从这个角度上来看构造函数，更容易明白每个Person实例都包含一个不同的Function实例（以</div><div class="t m0 x0 h1e ya31 ff20 fs2 fc0 sc0 ls8 wseb">显示name属性）的本质。说明白些，以这种方式创建函数，会导致不同的作用域链和标识符解析，但</div><div class="t m0 x0 h4 ya32 ff20 fs2 fc0 sc0 ls8 wseb">创建Function新实例的机制仍然是相同的。因此，不同实例上的同名函数是不相等的，以下代码可以</div><div class="t m0 x0 h5 ya33 ff20 fs2 fc0 sc0 ls8 wseb">证明这一点。 </div></div></div>
<div id="pfa5" class="pf w0 h0" data-page-no="a5"><div class="pc pca5 w0 h0"><div class="t m0 x2 h2 y1 ff1a fs0 fc0 sc0 ls10 wsc">6.2 创建对象    147 </div><div class="t m0 x0 h3 y2 ff1a fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff25 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff25 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff25 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff25 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff25 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff25 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff25 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff25 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff25 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff25 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff25 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff25 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff25 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x5 hb y866 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y867 ff21 fs6 fc0 sc0 ls21 wsb">alert(person1.sayName == person2.sayName);  //false   </div><div class="t m0 x5 hb ya34 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 ya35 ff20 fs2 fc0 sc0 ls8 wseb">然而，创建两个完成同样任务的Function实例的确没有必要；况且有this对象在，根本不用在</div><div class="t m0 x0 h4 ya36 ff20 fs2 fc0 sc0 ls8 wseb">执行代码前就把函数绑定到特定对象上面。因此，大可像下面这样，通过把函数定义转移到构造函数外</div><div class="t m0 x0 h5 ya37 ff20 fs2 fc0 sc0 ls8 wseb">部来解决这个问题。 </div><div class="t m0 x5 hb ya38 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ya39 ff21 fs6 fc0 sc0 ls21 wsb">function Person(name, age, job){ </div><div class="t m0 x0 hb ya3a ff21 fs6 fc0 sc0 ls21 wsb">    this.name = name; </div><div class="t m0 x0 hb ya3b ff21 fs6 fc0 sc0 ls21 wsb">    this.age = age; </div><div class="t m0 x0 hb ya3c ff21 fs6 fc0 sc0 ls21 wsb">    this.job = job; </div><div class="t m0 x0 h15 ya3d ff27 fs6 fc0 sc0 ls21 wsb">    this.sayName = sayName; </div><div class="t m0 x0 hb ya3e ff21 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb ya3f ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 ya40 ff27 fs6 fc0 sc0 ls21 wsb">function sayName(){ </div><div class="t m0 x0 h15 ya41 ff27 fs6 fc0 sc0 ls21 wsb">    alert(this.name); </div><div class="t m0 x0 h15 ya42 ff27 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb ya43 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ya44 ff21 fs6 fc0 sc0 ls21 wsb">var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;); </div><div class="t m0 x0 hb ya45 ff21 fs6 fc0 sc0 ls21 wsb">var person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;); </div><div class="t m0 x0 hb ya46 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf ya47 ff22 fs2 fc0 sc0 lsb wsb">ConstructorPatternExample03.htm </div><div class="t m0 x0 h4 ya48 ff20 fs2 fc0 sc0 ls6 wsf7">在这个例子中，我们把sayName()函数的定义转移到了构造函数外部。而在构造函数内部，我们</div><div class="t m0 x0 h1e ya49 ff20 fs2 fc0 sc0 ls13d">将sayName属性设置成等于全局的sayName函数。这样一来，由于sayName 包含的是一个指向函数</div><div class="t m0 x0 h1e ya4a ff20 fs2 fc0 sc0 ls8 wseb">的指针，因此person1和person2对象就共享了在全局作用域中定义的同一个 sayName()函数。这</div><div class="t m0 x0 h4 ya4b ff20 fs2 fc0 sc0 ls8 wseb">样做确实解决了两个函数做同一件事的问题，可是新问题又来了：在全局作用域中定义的函数实际上只</div><div class="t m0 x0 h4 ya4c ff20 fs2 fc0 sc0 ls8 wseb">能被某个对象调用，这让全局作用域有点名不副实。而更让人无法接受的是：如果对象需要定义很多方</div><div class="t m0 x0 h4 ya4d ff20 fs2 fc0 sc0 ls8 wseb">法，那么就要定义很多个全局函数，于是我们这个自定义的引用类型就丝毫没有封装性可言了。好在，</div><div class="t m0 x0 h5 ya4e ff20 fs2 fc0 sc0 ls8 wseb">这些问题可以通过使用原型模式来解决。 </div><div class="t m0 x0 h20 ya4f ff1e fs3 fc0 sc0 ls4d ws40">6.2.3 原型模式 </div><div class="t m0 x0 h4 ya50 ff20 fs2 fc0 sc0 ls6 wsf7">我们创建的每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，</div><div class="t m0 x0 h4 ya51 ff20 fs2 fc0 sc0 ls8 wseb">而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。如果按照字面意思来理解，那</div><div class="t m0 x0 h1e ya52 ff20 fs2 fc0 sc0 ls13f">么prototype就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以</div><div class="t m0 x0 h4 ya53 ff20 fs2 fc0 sc0 ls8 wseb">让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是</div><div class="t m0 x0 h5 ya54 ff20 fs2 fc0 sc0 ls8 wseb">可以将这些信息直接添加到原型对象中，如下面的例子所示。 </div><div class="t m0 x5 hb y53d ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ya55 ff21 fs6 fc0 sc0 ls21 wsb">function Person(){ </div><div class="t m0 x0 hb ya56 ff21 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb ya57 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ya58 ff21 fs6 fc0 sc0 ls21 wsb">Person.prototype.name = &quot;Nicholas&quot;; </div><div class="t m0 x0 hb ya59 ff21 fs6 fc0 sc0 ls21 wsb">Person.prototype.age = 29; </div><div class="t m0 x0 hb ya5a ff21 fs6 fc0 sc0 ls21 wsb">Person.prototype.job = &quot;Software Engineer&quot;; </div><div class="t m0 x0 hb ya5b ff21 fs6 fc0 sc0 ls21 wsb">Person.prototype.sayName = function(){ </div><div class="t m0 x0 hb ya5c ff21 fs6 fc0 sc0 ls21 wsb">    alert(this.name); </div><div class="t m0 x0 hb ya5d ff21 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb ya5e ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ya5f ff21 fs6 fc0 sc0 ls21 wsb">var person1 = new Person(); </div><div class="t m0 x0 hb ya60 ff21 fs6 fc0 sc0 ls21 wsb">person1.sayName();   //&quot;Nicholas&quot; </div><div class="t m0 x0 hb ya61 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ya62 ff21 fs6 fc0 sc0 ls21 wsb">var person2 = new Person(); </div></div></div>
<div id="pfa6" class="pf w0 h0" data-page-no="a6"><div class="pc pca6 w0 h0"><div class="t m0 x0 h2 y1 ff1a fs0 fc0 sc0 ls7 ws0">148  第6章 面向对象的程序设计 </div><div class="t m0 x0 h3 y2 ff1a fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ya64 ff21 fs6 fc0 sc0 ls21 wsb">person2.sayName();   //&quot;Nicholas&quot; </div><div class="t m0 x0 hb ya65 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ya66 ff21 fs6 fc0 sc0 ls21 wsb">alert(person1.sayName == person2.sayName);  //true </div><div class="t m0 x0 hb ya67 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf ya68 ff22 fs2 fc0 sc0 ls7a wsb">PrototypePatternExample01.htm </div><div class="t m0 x0 h4 ya69 ff20 fs2 fc0 sc0 ls8 wseb">在此，我们将sayName()方法和所有属性直接添加到了Person的prototype属性中，构造函数</div><div class="t m0 x0 h4 ya6a ff20 fs2 fc0 sc0 ls8 wseb">变成了空函数。即使如此，也仍然可以通过调用构造函数来创建新对象，而且新对象还会具有相同的属</div><div class="t m0 x0 h4 ya6b ff20 fs2 fc0 sc0 ls24 wsf5">性和方法。但与构造函数模式不同的是，新对象的这些属性和方法是由所有实例共享的。换句话说，</div><div class="t m0 x0 h4 ya6c ff21 fs1 fc0 sc0 ls9 ws2">person1和person2访问的都是同一组属性和同一个sayName()函数。要理解原型模式的工作原理，</div><div class="t m0 x0 h5 ya6d ff20 fs2 fc0 sc0 ls8 wseb">必须先理解ECMAScript中原型对象的性质。 </div><div class="t m0 x0 h3c ya6e ff1e fs2 fc0 sc0 ls2e wsb">1. 理解原型对象 </div><div class="t m0 x0 h4 ya6f ff20 fs2 fc0 sc0 ls6 wsf7">无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype</div><div class="t m0 x0 h4 ya70 ff20 fs2 fc0 sc0 ls8 wseb">属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个constructor</div><div class="t m0 x0 h4 y26c ff20 fs2 fc0 sc0 ls6 wsf7">（构造函数）属性，这个属性包含一个指向prototype属性所在函数的指针。就拿前面的例子来说，</div><div class="t m0 x0 h4 ya71 ff21 fs1 fc0 sc0 ls9 wsb">Person.prototype. constructor指向Person。而通过这个构造函数，我们还可继续为原型对象</div><div class="t m0 x0 h5 ya72 ff20 fs2 fc0 sc0 ls8 wseb">添加其他属性和方法。 </div><div class="t m0 x0 h1c ya73 ff20 fs2 fc0 sc0 ls8 wseb">创建了自定义的构造函数之后，其原型对象默认只会取得constructor属性；至于其他方法，则</div><div class="t m0 x0 h4 ya74 ff20 fs2 fc0 sc0 ls8 wseb">都是从Object继承而来的。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部</div><div class="t m0 x0 h5 ya75 ff20 fs2 fc0 sc0 ls8 wseb">属性），指向构造函数的原型对象。ECMA-262第5版中管这个指针叫[[Prototype]]。虽然在脚本中</div><div class="t m0 x0 hc ya76 ff20 fs2 fc0 sc0 ls55 wsfc">没有标准的方式访问[[Prototype]]，但Firefox、Safari和Chrome 在每个对象上都支持一个属性</div><div class="t m0 x0 h4 y33d ff21 fs1 fc0 sc0 ls9 ws2">__proto__；而在其他实现中，这个属性对脚本则是完全不可见的。不过，要明确的真正重要的一点就</div><div class="t m0 x0 h5 ya77 ff20 fs2 fc0 sc0 ls8 wseb">是，这个连接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间。 </div><div class="t m0 x0 hc ya78 ff20 fs2 fc0 sc0 ls8 wseb">以前面使用Person构造函数和Person.prototype 创建实例的代码为例，图6-1展示了各个对</div><div class="t m0 x0 h5 ya79 ff20 fs2 fc0 sc0 ls8 wseb">象之间的关系。 </div><div class="t m0 x2 h5 ya7a ff1a fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x7 h3 ya7b ff20 fs1 fc0 sc0 ls8 wsb">图 6-1 </div><div class="t m0 x0 h5 ya7c ff20 fs2 fc0 sc0 ls141">图6-1展示了Person构造函数、Person的原型属性以及 Person现有的两个实例之间的关系。</div><div class="t m0 x0 h1e ya7d ff20 fs2 fc0 sc0 ls8 wseb">在此，Person.prototype指向了原型对象，而Person.prototype.constructor又指回了Person。</div><div class="t m0 x0 h1e ya7e ff20 fs2 fc0 sc0 ls8 wseb">原型对象中除了包含constructor属性之外，还包括后来添加的其他属性。Person的每个实例——</div><div class="t m0 x0 h4 ya7f ff21 fs1 fc0 sc0 ls9 ws2">person1和person2都包含一个内部属性，该属性仅仅指向了Person.prototype；换句话说，它们</div><div class="t m0 x0 h4 ya80 ff20 fs2 fc0 sc0 ls8 wseb">与构造函数没有直接的关系。此外，要格外注意的是，虽然这两个实例都不包含属性和方法，但我们却</div></div></div>
<div id="pfa7" class="pf w0 h0" data-page-no="a7"><div class="pc pca7 w0 h0"><div class="t m0 x2 h2 y1 ff1a fs0 fc0 sc0 ls10 wsc">6.2 创建对象    149 </div><div class="t m0 x0 h3 y2 ff1a fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff25 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff25 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff25 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff25 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff25 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff25 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff25 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff25 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff25 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff25 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff25 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff25 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff25 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff20 fs2 fc0 sc0 ls8 wseb">可以调用person1.sayName()。这是通过查找对象属性的过程来实现的。 </div><div class="t m0 x0 h1e y4d ff20 fs2 fc0 sc0 ls5f ws10b">虽然在所有实现中都无法访问到[[Prototype]]，但可以通过isPrototypeOf()方法来确定对象之</div><div class="t m0 x0 h1e y5 ff20 fs2 fc0 sc0 ls4 ws10d">间是否存在这种关系。从本质上讲，如果[[Prototype]]指向调用isPrototypeOf()方法的对象</div><div class="t m0 x0 h5 yd9 ff20 fs2 fc0 sc0 ls144">（Person.prototype），那么这个方法就返回true，如下所示： </div><div class="t m0 x5 hb ya81 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ya82 ff21 fs6 fc0 sc0 ls21 wsb">alert(Person.prototype.isPrototypeOf(person1));  //true </div><div class="t m0 x0 hb ya83 ff21 fs6 fc0 sc0 ls21 wsb">alert(Person.prototype.isPrototypeOf(person2));  //true </div><div class="t m0 x5 hb ya84 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 ya85 ff20 fs2 fc0 sc0 ls8 wseb">这里，我们用原型对象的isPrototypeOf()方法测试了person1和person2。因为它们内部都</div><div class="t m0 x0 h5 ya86 ff20 fs2 fc0 sc0 ls8 wseb">有一个指向Person.prototype的指针，因此都返回了true。 </div><div class="t m0 x0 h5 ya87 ff1a fs2 fc0 sc0 ls25 ws61">ECMAScript 5增加了一个新方法，叫Object.getPrototypeOf()，在所有支持的实现中，这个</div><div class="t m0 x0 hc ya88 ff20 fs2 fc0 sc0 ls8 wseb">方法返回[[Prototype]]的值。例如： </div><div class="t m0 x0 hb ya89 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ya8a ff21 fs6 fc0 sc0 ls21 wsb">alert(Object.getPrototypeOf(person1) == Person.prototype); //true </div><div class="t m0 x0 hb ya8b ff21 fs6 fc0 sc0 ls21 wsb">alert(Object.getPrototypeOf(person1).name); //&quot;Nicholas&quot; </div><div class="t m0 x0 hb ya8c ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 ya8d ff20 fs2 fc0 sc0 ls6 wsf7">这里的第一行代码只是确定Object.getPrototypeOf()返回的对象实际就是这个对象的原型。</div><div class="t m0 x0 h1e ya8e ff20 fs2 fc0 sc0 ls8 wseb">第二行代码取得了原型对象中name属性的值，也就是&quot;Nicholas&quot;。使用Object.getPrototypeOf()</div><div class="t m0 x0 h4 ya8f ff20 fs2 fc0 sc0 ls8 wseb">可以方便地取得一个对象的原型，而这在利用原型实现继承（本章稍后会讨论）的情况下是非常重要的。</div><div class="t m0 x0 h5 ya90 ff20 fs2 fc0 sc0 ls8 wseb">支持这个方法的浏览器有IE9+、Firefox 3.5+、Safari 5+、Opera 12+和Chrome。 </div><div class="t m0 x0 h4 ya91 ff20 fs2 fc0 sc0 ls8 wseb">每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先</div><div class="t m0 x0 h4 ya92 ff20 fs2 fc0 sc0 ls8 wseb">从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到，</div><div class="t m0 x0 h4 ya93 ff20 fs2 fc0 sc0 ls8 wseb">则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这</div><div class="t m0 x0 h2b ya94 ff20 fs2 fc0 sc0 ls8 wseb">个属性，则返回该属性的值。也就是说，在我们调用person1.sayName()的时候，会先后执行两次搜</div><div class="t m0 x0 h4 ya95 ff20 fs2 fc0 sc0 ls8 wseb">索。首先，解析器会问：“实例person1有sayName属性吗？”答：“没有。”然后，它继续搜索，再</div><div class="t m0 x0 h1e ya96 ff20 fs2 fc0 sc0 ls8 wseb">问：“person1的原型有sayName属性吗？”答：“有。”于是，它就读取那个保存在原型对象中的函</div><div class="t m0 x0 h1e ya97 ff20 fs2 fc0 sc0 ls8 wseb">数。当我们调用person2.sayName()时，将会重现相同的搜索过程，得到相同的结果。而这正是多个</div><div class="t m0 x0 h5 ya98 ff20 fs2 fc0 sc0 ls8 wseb">对象实例共享原型所保存的属性和方法的基本原理。 </div><div class="t m0 x5 h60 ya99 ff1b fs2 fc0 sc0 ls8 ws14">前面提到过，原型最初只包含constructor属性，而该属性也是共享的，因此</div><div class="t m0 x5 h5 ya9a ff1b fs2 fc0 sc0 ls8 ws14">可以通过对象实例访问。 </div><div class="t m0 x0 h4 ya9b ff20 fs2 fc0 sc0 ls8 wseb">虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。如果我们</div><div class="t m0 x0 h4 ya9c ff20 fs2 fc0 sc0 ls8 wseb">在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那我们就在实例中创建该属性，该</div><div class="t m0 x0 h5 ya9d ff20 fs2 fc0 sc0 ls8 wseb">属性将会屏蔽原型中的那个属性。来看下面的例子。 </div><div class="t m0 x5 hb ya9e ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ya9f ff21 fs6 fc0 sc0 ls21 wsb">function Person(){ </div><div class="t m0 x0 hb yaa0 ff21 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb yaa1 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yaa2 ff21 fs6 fc0 sc0 ls21 wsb">Person.prototype.name = &quot;Nicholas&quot;; </div><div class="t m0 x0 hb yaa3 ff21 fs6 fc0 sc0 ls21 wsb">Person.prototype.age = 29; </div><div class="t m0 x0 hb yaa4 ff21 fs6 fc0 sc0 ls21 wsb">Person.prototype.job = &quot;Software Engineer&quot;; </div><div class="t m0 x0 hb yaa5 ff21 fs6 fc0 sc0 ls21 wsb">Person.prototype.sayName = function(){ </div><div class="t m0 x0 hb yaa6 ff21 fs6 fc0 sc0 ls21 wsb">    alert(this.name); </div><div class="t m0 x0 hb yaa7 ff21 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb yaa8 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yaa9 ff21 fs6 fc0 sc0 ls21 wsb">var person1 = new Person(); </div></div></div>
<div id="pfa8" class="pf w0 h0" data-page-no="a8"><div class="pc pca8 w0 h0"><div class="t m0 x0 h2 y1 ff1a fs0 fc0 sc0 ls7 ws0">150  第6章 面向对象的程序设计 </div><div class="t m0 x0 h3 y2 ff1a fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 ff21 fs6 fc0 sc0 ls21 wsb">var person2 = new Person(); </div><div class="t m0 x0 hb y7a ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y7b ff27 fs6 fc0 sc0 ls21 wsb">person1.name = &quot;Greg&quot;; </div><div class="t m0 x0 h16 y7c ff27 fs6 fc0 sc0 ls21 wsb">alert(person1.name);     //&quot;Greg&quot;——来自实例 </div><div class="t m0 x0 h16 y7d ff27 fs6 fc0 sc0 ls21 wsb">alert(person2.name);     //&quot;Nicholas&quot;——来自原型 </div><div class="t m0 x0 h15 yaab ff27 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf yaac ff22 fs2 fc0 sc0 ls7a wsb">PrototypePatternExample02.htm </div><div class="t m0 x0 h4 yaad ff20 fs2 fc0 sc0 ls8 wseb">在这个例子中，person1的name被一个新值给屏蔽了。但无论访问 person1.name还是访问</div><div class="t m0 x0 h4 yaae ff21 fs1 fc0 sc0 ls9 ws2">person2.name都能够正常地返回值，即分别是&quot;Greg&quot;（来自对象实例）和&quot;Nicholas&quot;（来自原型）。</div><div class="t m0 x0 h1e yaaf ff20 fs2 fc0 sc0 ls8 wseb">当在alert()中访问person1.name时，需要读取它的值，因此就会在这个实例上搜索一个名为name</div><div class="t m0 x0 h4 yab0 ff20 fs2 fc0 sc0 ls8 wseb">的属性。这个属性确实存在，于是就返回它的值而不必再搜索原型了。当以同样的方式访问person2. </div><div class="t m0 x0 h21 yab1 ff21 fs1 fc0 sc0 ls9 ws2">name时，并没有在实例上发现该属性，因此就会继续搜索原型，结果在那里找到了name属性。 </div><div class="t m0 x0 h4 y294 ff20 fs2 fc0 sc0 ls8 wseb">当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性；换句话说，添加这</div><div class="t m0 x0 h1c yab2 ff20 fs2 fc0 sc0 ls8 wseb">个属性只会阻止我们访问原型中的那个属性，但不会修改那个属性。即使将这个属性设置为null，也</div><div class="t m0 x0 h4 y69b ff20 fs2 fc0 sc0 ls8 wseb">只会在实例中设置这个属性，而不会恢复其指向原型的连接。不过，使用delete操作符则可以完全删</div><div class="t m0 x0 h5 yab3 ff20 fs2 fc0 sc0 ls8 wseb">除实例属性，从而让我们能够重新访问原型中的属性，如下所示。 </div><div class="t m0 x0 hb yab4 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yab5 ff21 fs6 fc0 sc0 ls21 wsb">function Person(){ </div><div class="t m0 x0 hb yab6 ff21 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb yab7 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yab8 ff21 fs6 fc0 sc0 ls21 wsb">Person.prototype.name = &quot;Nicholas&quot;; </div><div class="t m0 x0 hb yab9 ff21 fs6 fc0 sc0 ls21 wsb">Person.prototype.age = 29; </div><div class="t m0 x0 hb yaba ff21 fs6 fc0 sc0 ls21 wsb">Person.prototype.job = &quot;Software Engineer&quot;; </div><div class="t m0 x0 hb yabb ff21 fs6 fc0 sc0 ls21 wsb">Person.prototype.sayName = function(){ </div><div class="t m0 x0 hb yabc ff21 fs6 fc0 sc0 ls21 wsb">    alert(this.name); </div><div class="t m0 x0 hb yabd ff21 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb yabe ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yabf ff21 fs6 fc0 sc0 ls21 wsb">var person1 = new Person(); </div><div class="t m0 x0 hb yac0 ff21 fs6 fc0 sc0 ls21 wsb">var person2 = new Person(); </div><div class="t m0 x0 hb yac1 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yac2 ff21 fs6 fc0 sc0 ls21 wsb">person1.name = &quot;Greg&quot;; </div><div class="t m0 x0 h16 yac3 ff21 fs6 fc0 sc0 ls21 wsb">alert(person1.name);     //&quot;Greg&quot;——来自实例 </div><div class="t m0 x0 h16 yac4 ff21 fs6 fc0 sc0 ls21 wsb">alert(person2.name);     //&quot;Nicholas&quot;——来自原型 </div><div class="t m0 x0 hb yac5 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 yac6 ff27 fs6 fc0 sc0 ls21 wsb">delete person1.name; </div><div class="t m0 x0 h16 yac7 ff27 fs6 fc0 sc0 ls21 wsb">alert(person1.name);     //&quot;Nicholas&quot;——来自原型 </div><div class="t m0 x0 h15 yac8 ff27 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf yac9 ff22 fs2 fc0 sc0 ls7a wsb">PrototypePatternExample03.htm </div><div class="t m0 x0 h4 yaca ff20 fs2 fc0 sc0 ls8 wseb">在这个修改后的例子中，我们使用delete操作符删除了person1.name，之前它保存的&quot;Greg&quot;</div><div class="t m0 x0 h4 yacb ff20 fs2 fc0 sc0 ls8 wseb">值屏蔽了同名的原型属性。把它删除以后，就恢复了对原型中name属性的连接。因此，接下来再调用</div><div class="t m0 x0 h5 yacc ff21 fs1 fc0 sc0 ls9 ws2">person1.name时，返回的就是原型中name属性的值了。 </div><div class="t m0 x0 h1e yacd ff20 fs2 fc0 sc0 ls1f ws108">使用hasOwnProperty()方法可以检测一个属性是存在于实例中，还是存在于原型中。这个方法（不</div><div class="t m0 x0 hc yace ff20 fs2 fc0 sc0 ls5c ws10f">要忘了它是从Object继承来的）只在给定属性存在于对象实例中时，才会返回true。来看下面这个例子。 </div><div class="t m0 x0 hb y8bf ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yacf ff21 fs6 fc0 sc0 ls21 wsb">function Person(){ </div><div class="t m0 x0 hb yad0 ff21 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb yad1 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yad2 ff21 fs6 fc0 sc0 ls21 wsb">Person.prototype.name = &quot;Nicholas&quot;; </div><div class="t m0 x0 hb yad3 ff21 fs6 fc0 sc0 ls21 wsb">Person.prototype.age = 29; </div><div class="t m0 x0 hb yad4 ff21 fs6 fc0 sc0 ls21 wsb">Person.prototype.job = &quot;Software Engineer&quot;; </div><div class="t m0 x0 hb yad5 ff21 fs6 fc0 sc0 ls21 wsb">Person.prototype.sayName = function(){ </div></div></div>
<div id="pfa9" class="pf w0 h0" data-page-no="a9"><div class="pc pca9 w0 h0"><div class="t m0 x2 h2 y1 ff1a fs0 fc0 sc0 ls10 wsc">6.2 创建对象    151 </div><div class="t m0 x0 h3 y2 ff1a fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff25 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff25 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff25 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff25 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff25 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff25 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff25 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff25 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff25 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff25 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff25 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff25 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff25 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb yad6 ff21 fs6 fc0 sc0 ls21 wsb">    alert(this.name); </div><div class="t m0 x0 hb yad7 ff21 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb yad8 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yad9 ff21 fs6 fc0 sc0 ls21 wsb">var person1 = new Person(); </div><div class="t m0 x0 hb yada ff21 fs6 fc0 sc0 ls21 wsb">var person2 = new Person(); </div><div class="t m0 x0 hb yadb ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 yadc ff27 fs6 fc0 sc0 ls21 wsb">alert(person1.hasOwnProperty(&quot;name&quot;));  //false </div><div class="t m0 x0 hb yadd ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yade ff21 fs6 fc0 sc0 ls21 wsb">person1.name = &quot;Greg&quot;; </div><div class="t m0 x0 h16 yadf ff21 fs6 fc0 sc0 ls21 wsb">alert(person1.name);     //&quot;Greg&quot;——来自实例 </div><div class="t m0 x0 h15 yae0 ff27 fs6 fc0 sc0 ls21 wsb">alert(person1.hasOwnProperty(&quot;name&quot;));  //true </div><div class="t m0 x0 hb yae1 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 yae2 ff21 fs6 fc0 sc0 ls21 wsb">alert(person2.name);     //&quot;Nicholas&quot;——来自原型 </div><div class="t m0 x0 h15 yae3 ff27 fs6 fc0 sc0 ls21 wsb">alert(person2.hasOwnProperty(&quot;name&quot;));  //false </div><div class="t m0 x0 hb yae4 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yae5 ff21 fs6 fc0 sc0 ls21 wsb">delete person1.name; </div><div class="t m0 x0 h16 yae6 ff21 fs6 fc0 sc0 ls21 wsb">alert(person1.name);     //&quot;Nicholas&quot;——来自原型 </div><div class="t m0 x0 h15 yae7 ff27 fs6 fc0 sc0 ls21 wsb">alert(person1.hasOwnProperty(&quot;name&quot;));  //false </div><div class="t m0 x5 hb yae8 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 yb6 ff20 fs2 fc0 sc0 ls6 wsf7">通过使用hasOwnProperty()方法，什么时候访问的是实例属性，什么时候访问的是原型属性就</div><div class="t m0 x0 h1e yae9 ff20 fs2 fc0 sc0 ls8 wseb">一清二楚了。调用person1.hasOwnProperty( &quot;name&quot;)时，只有当person1重写name属性后才会</div><div class="t m0 x0 hc yaea ff20 fs2 fc0 sc0 ls8 wseb">返回true，因为只有这时候name才是一个实例属性，而非原型属性。图6-2展示了上面例子在不同情</div><div class="t m0 x0 hc yaeb ff20 fs2 fc0 sc0 ls8 wseb">况下的实现与原型的关系（为了简单起见，图中省略了与Person构造函数的关系）。 </div><div class="t m0 x6 h5 y2b0 ff1a fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 h3 yaec ff20 fs1 fc0 sc0 ls8 wsb">图 6-2 </div></div></div>
<div id="pfaa" class="pf w0 h0" data-page-no="aa"><div class="pc pcaa w0 h0"><div class="t m0 x0 h2 y1 ff1a fs0 fc0 sc0 ls7 ws0">152  第6章 面向对象的程序设计 </div><div class="t m0 x0 h3 y2 ff1a fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 ya0a ff1a fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x5 h5 ya0b ff1a fs2 fc0 sc0 ls87 ws111">ECMAScript 5的Object.getOwnPropertyDescriptor()方法只能用于实例属</div><div class="t m0 x0 ha ya0c ff1b fs2 fc0 sc0 ls1f ws3b">性，要取得原型属性的描述符，必须直接在原型对象上调用Object.getOwnProperty- </div><div class="t m0 x0 h5 yaee ff21 fs1 fc0 sc0 ls9 ws2">Descriptor()方法。 </div><div class="t m0 x0 h3c yaef ff1e fs2 fc0 sc0 ls2e wsb">2. 原型与in操作符 </div><div class="t m0 x0 h4 yaf0 ff20 fs2 fc0 sc0 ls8 wseb">有两种方式使用in操作符：单独使用和在for-in循环中使用。在单独使用时，in操作符会在通</div><div class="t m0 x0 hc yaf1 ff20 fs2 fc0 sc0 ls8 wseb">过对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中。看一看下面的例子。 </div><div class="t m0 x0 hb yaf2 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yaf3 ff21 fs6 fc0 sc0 ls21 wsb">function Person(){ </div><div class="t m0 x0 hb yaf4 ff21 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb yaf5 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yaf6 ff21 fs6 fc0 sc0 ls21 wsb">Person.prototype.name = &quot;Nicholas&quot;; </div><div class="t m0 x0 hb yaf7 ff21 fs6 fc0 sc0 ls21 wsb">Person.prototype.age = 29; </div><div class="t m0 x0 hb yaf8 ff21 fs6 fc0 sc0 ls21 wsb">Person.prototype.job = &quot;Software Engineer&quot;; </div><div class="t m0 x0 hb yaf9 ff21 fs6 fc0 sc0 ls21 wsb">Person.prototype.sayName = function(){ </div><div class="t m0 x0 hb yafa ff21 fs6 fc0 sc0 ls21 wsb">    alert(this.name); </div><div class="t m0 x0 hb yafb ff21 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb yafc ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yafd ff21 fs6 fc0 sc0 ls21 wsb">var person1 = new Person(); </div><div class="t m0 x0 hb yafe ff21 fs6 fc0 sc0 ls21 wsb">var person2 = new Person(); </div><div class="t m0 x0 hb yaff ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yb00 ff21 fs6 fc0 sc0 ls21 wsb">alert(person1.hasOwnProperty(&quot;name&quot;));  //false </div><div class="t m0 x0 h15 yb01 ff27 fs6 fc0 sc0 ls21 wsb">alert(&quot;name&quot; in person1);  //true </div><div class="t m0 x0 hb yb02 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yb03 ff21 fs6 fc0 sc0 ls21 wsb">person1.name = &quot;Greg&quot;; </div><div class="t m0 x0 h16 yb04 ff21 fs6 fc0 sc0 ls21 wsb">alert(person1.name);   //&quot;Greg&quot; ——来自实例 </div><div class="t m0 x0 hb yb05 ff21 fs6 fc0 sc0 ls21 wsb">alert(person1.hasOwnProperty(&quot;name&quot;));  //true </div><div class="t m0 x0 h15 yb06 ff27 fs6 fc0 sc0 ls21 wsb">alert(&quot;name&quot; in person1);  //true </div><div class="t m0 x0 hb yb07 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 yb08 ff21 fs6 fc0 sc0 ls21 wsb">alert(person2.name);   //&quot;Nicholas&quot; ——来自原型 </div><div class="t m0 x0 hb yb09 ff21 fs6 fc0 sc0 ls21 wsb">alert(person2.hasOwnProperty(&quot;name&quot;));  //false </div><div class="t m0 x0 h15 yb0a ff27 fs6 fc0 sc0 ls21 wsb">alert(&quot;name&quot; in person2);  //true </div><div class="t m0 x0 hb yb0b ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yb0c ff21 fs6 fc0 sc0 ls21 wsb">delete person1.name; </div><div class="t m0 x0 h16 yb0d ff21 fs6 fc0 sc0 ls21 wsb">alert(person1.name);   //&quot;Nicholas&quot; ——来自原型 </div><div class="t m0 x0 hb yb0e ff21 fs6 fc0 sc0 ls21 wsb">alert(person1.hasOwnProperty(&quot;name&quot;));  //false </div><div class="t m0 x0 h15 yb0f ff27 fs6 fc0 sc0 ls21 wsb">alert(&quot;name&quot; in person1);  //true </div><div class="t m0 x2 hf yb10 ff22 fs2 fc0 sc0 ls7a wsb">PrototypePatternExample04.htm </div><div class="t m0 x0 h4 y88c ff20 fs2 fc0 sc0 ls8 wseb">在以上代码执行的整个过程中，name属性要么是直接在对象上访问到的，要么是通过原型访问到</div><div class="t m0 x0 h1e yb11 ff20 fs2 fc0 sc0 ls8 wseb">的。因此，调用&quot;name&quot; in person1始终都返回true，无论该属性存在于实例中还是存在于原型中。</div><div class="t m0 x0 h1e yb12 ff20 fs2 fc0 sc0 ls8 wseb">同时使用hasOwnProperty()方法和in操作符，就可以确定该属性到底是存在于对象中，还是存在于</div><div class="t m0 x0 h5 yb13 ff20 fs2 fc0 sc0 ls8 wseb">原型中，如下所示。 </div><div class="t m0 x0 hb yb14 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yb15 ff21 fs6 fc0 sc0 ls21 wsb">function hasPrototypeProperty(object, name){ </div><div class="t m0 x0 hb yb16 ff21 fs6 fc0 sc0 ls21 wsb">    return !object.hasOwnProperty(name) &amp;&amp; (name in object); </div><div class="t m0 x0 hb yb17 ff21 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h4 yb18 ff20 fs2 fc0 sc0 ls8 wseb">由于in操作符只要通过对象能够访问到属性就返回true，hasOwnProperty()只在属性存在于</div><div class="t m0 x0 h4 yb19 ff20 fs2 fc0 sc0 ls8 wseb">实例中时才返回true，因此只要in操作符返回true 而hasOwnProperty()返回false，就可以确</div><div class="t m0 x0 hc yb1a ff20 fs2 fc0 sc0 ls8 wseb">定属性是原型中的属性。下面来看一看上面定义的函数hasPrototypeProperty()的用法。 </div></div></div>
<div id="pfab" class="pf w0 h0" data-page-no="ab"><div class="pc pcab w0 h0"><div class="t m0 x2 h2 y1 ff1a fs0 fc0 sc0 ls10 wsc">6.2 创建对象    153 </div><div class="t m0 x0 h3 y2 ff1a fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff25 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff25 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff25 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff25 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff25 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff25 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff25 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff25 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff25 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff25 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff25 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff25 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff25 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x5 hb y866 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y867 ff21 fs6 fc0 sc0 ls21 wsb">function Person(){ </div><div class="t m0 x0 hb y868 ff21 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y869 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y86a ff21 fs6 fc0 sc0 ls21 wsb">Person.prototype.name = &quot;Nicholas&quot;; </div><div class="t m0 x0 hb y86b ff21 fs6 fc0 sc0 ls21 wsb">Person.prototype.age = 29; </div><div class="t m0 x0 hb yb1b ff21 fs6 fc0 sc0 ls21 wsb">Person.prototype.job = &quot;Software Engineer&quot;; </div><div class="t m0 x0 hb yb1c ff21 fs6 fc0 sc0 ls21 wsb">Person.prototype.sayName = function(){ </div><div class="t m0 x0 hb yb1d ff21 fs6 fc0 sc0 ls21 wsb">    alert(this.name); </div><div class="t m0 x0 hb yb1e ff21 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb yb1f ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yb20 ff21 fs6 fc0 sc0 ls21 wsb">var person = new Person();         </div><div class="t m0 x0 h15 yb21 ff27 fs6 fc0 sc0 ls21 wsb">alert(hasPrototypeProperty(person, &quot;name&quot;));  //true </div><div class="t m0 x0 hb yb22 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yb23 ff21 fs6 fc0 sc0 ls21 wsb">person.name = &quot;Greg&quot;; </div><div class="t m0 x0 h15 yb24 ff27 fs6 fc0 sc0 ls21 wsb">alert(hasPrototypeProperty(person, &quot;name&quot;));  //false </div><div class="t m0 x0 h15 yb25 ff27 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf yb26 ff22 fs2 fc0 sc0 ls7a wsb">PrototypePatternExample05.htm </div><div class="t m0 x0 h4 y850 ff20 fs2 fc0 sc0 ls8 wseb">在这里，name属性先是存在于原型中，因此hasPrototypeProperty()返回true。当在实例中</div><div class="t m0 x0 h1e y851 ff20 fs2 fc0 sc0 ls8 wseb">重写name属性后，该属性就存在于实例中了，因此hasPrototypeProperty()返回false。即使原</div><div class="t m0 x0 h5 yb27 ff20 fs2 fc0 sc0 ls8 wseb">型中仍然有name属性，但由于现在实例中也有了这个属性，因此原型中的name属性就用不到了。 </div><div class="t m0 x0 hc yb28 ff20 fs2 fc0 sc0 ls8 wseb">在使用for-in循环时，返回的是所有能够通过对象访问的、可枚举的（enumerated）属性，其中</div><div class="t m0 x0 h4 y790 ff20 fs2 fc0 sc0 ls6f ws113">既包括存在于实例中的属性，也包括存在于原型中的属性。屏蔽了原型中不可枚举属性（即将</div><div class="t m0 x0 h4 y791 ff21 fs1 fc0 sc0 ls9 ws2">[[Enumerable]]标记为false的属性）的实例属性也会在for-in 循环中返回，因为根据规定，所</div><div class="t m0 x0 h5 y792 ff20 fs2 fc0 sc0 ls8 wseb">有开发人员定义的属性都是可枚举的——只有在IE8及更早版本中例外。 </div><div class="t m0 x0 h5 yb29 ff1a fs2 fc0 sc0 lse ws9">IE早期版本的实现中存在一个bug，即屏蔽不可枚举属性的实例属性不会出现在for-in循环中。</div><div class="t m0 x0 h5 yb2a ff20 fs2 fc0 sc0 ls8">例如： </div><div class="t m0 x5 hb yb2b ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yb2c ff21 fs6 fc0 sc0 ls21 wsb">var o = { </div><div class="t m0 x0 hb yb2d ff21 fs6 fc0 sc0 ls21 wsb">    toString : function(){ </div><div class="t m0 x0 hb yb2e ff21 fs6 fc0 sc0 ls21 wsb">        return &quot;My Object&quot;; </div><div class="t m0 x0 hb yb2f ff21 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb yb30 ff21 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb yb31 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yb32 ff21 fs6 fc0 sc0 ls21 wsb">for (var prop in o){ </div><div class="t m0 x0 hb yb33 ff21 fs6 fc0 sc0 ls21 wsb">    if (prop == &quot;toString&quot;){ </div><div class="t m0 x0 h36 yb34 ff21 fs6 fc0 sc0 ls21 wsb">        alert(&quot;Found toString&quot;);    //在IE中不会显示 </div><div class="t m0 x0 hb yb35 ff21 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb yb36 ff21 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb yb37 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf yb38 ff22 fs2 fc0 sc0 ls7a wsb">PrototypePatternExample06.htm </div><div class="t m0 x0 h4 yb39 ff20 fs2 fc0 sc0 ls8 wseb">当以上代码运行时，应该会显示一个警告框，表明找到了toString()方法。这里的对象o定义了</div><div class="t m0 x0 h5 yb3a ff20 fs2 fc0 sc0 ls8 wseb">一个名为toString()的方法，该方法屏蔽了原型中（不可枚举）的toString()方法。在IE 中，由</div><div class="t m0 x0 h1e yb3b ff20 fs2 fc0 sc0 ls8 wseb">于其实现认为原型的toString()方法被打上了值为false的[[En umerable]]标记，因此应该跳过</div><div class="t m0 x0 h1e yb3c ff20 fs2 fc0 sc0 ls147 ws115">该属性，结果我们就不会看到警告框。该bug会影响默认不可枚举的所有属性和方法，包括：</div><div class="t m0 x0 h4 yb3d ff21 fs1 fc0 sc0 ls9 ws2">hasOwnProperty()、propertyIsEnumerable()、toLocaleString()、toString()和valueOf()。</div><div class="t m0 x0 h5 yb3e ff1a fs2 fc0 sc0 ls25 ws116">ECMAScript 5也将constructor和prototype属性的[[Enumerable]]特性设置为false，但并不</div><div class="t m0 x0 h5 yb3f ff20 fs2 fc0 sc0 ls8 wseb">是所有浏览器都照此实现。 </div></div></div>
<div id="pfac" class="pf w0 h0" data-page-no="ac"><div class="pc pcac w0 h0"><div class="t m0 x0 h2 y1 ff1a fs0 fc0 sc0 ls7 ws0">154  第6章 面向对象的程序设计 </div><div class="t m0 x0 h3 y2 ff1a fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff20 fs2 fc0 sc0 ls8 wseb">要取得对象上所有可枚举的实例属性，可以使用ECMAScript 5的Object.keys()方法。这个方法</div><div class="t m0 x0 h5 y4d ff20 fs2 fc0 sc0 ls8 wseb">接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。例如： </div><div class="t m0 x0 hb yb40 ff21 fs6 fc0 sc0 ls21 wsb">function Person(){ </div><div class="t m0 x0 hb yb41 ff21 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb yb42 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yb43 ff21 fs6 fc0 sc0 ls21 wsb">Person.prototype.name = &quot;Nicholas&quot;; </div><div class="t m0 x0 hb yb44 ff21 fs6 fc0 sc0 ls21 wsb">Person.prototype.age = 29; </div><div class="t m0 x0 hb yb45 ff21 fs6 fc0 sc0 ls21 wsb">Person.prototype.job = &quot;Software Engineer&quot;; </div><div class="t m0 x0 hb yb46 ff21 fs6 fc0 sc0 ls21 wsb">Person.prototype.sayName = function(){ </div><div class="t m0 x0 hb yb47 ff21 fs6 fc0 sc0 ls21 wsb">    alert(this.name);  </div><div class="t m0 x0 hb yb48 ff21 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 h15 yb49 ff27 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 yb4a ff27 fs6 fc0 sc0 ls21 wsb">var keys = Object.keys(Person.prototype); </div><div class="t m0 x0 hb yb4b ff27 fs6 fc0 sc0 ls21 ws34">alert(keys);       //&quot;name,age,job,sayName&quot; </div><div class="t m0 x0 h15 yb4c ff27 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 yb4d ff27 fs6 fc0 sc0 ls21 wsb">var p1 = new Person(); </div><div class="t m0 x0 h15 yb4e ff27 fs6 fc0 sc0 ls21 wsb">p1.name = &quot;Rob&quot;; </div><div class="t m0 x0 h15 yb4f ff27 fs6 fc0 sc0 ls21 wsb">p1.age = 31; </div><div class="t m0 x0 h15 yb50 ff27 fs6 fc0 sc0 ls21 wsb">var p1keys = Object.keys(p1); </div><div class="t m0 x0 hb yb51 ff27 fs6 fc0 sc0 ls21 ws34">alert(p1keys);    //&quot;name,age&quot; </div><div class="t m0 x2 hf yb52 ff22 fs2 fc0 sc0 ls8 wsb">ObjectKeysExample01.htm </div><div class="t m0 x0 h4 yb53 ff20 fs2 fc0 sc0 ls8 wseb">这里，变量keys中将保存一个数组，数组中是字符串&quot;name&quot;、&quot;age&quot;、&quot;job&quot;和&quot;sayName&quot;。这</div><div class="t m0 x0 h1e yb54 ff20 fs2 fc0 sc0 ls8 wseb">个顺序也是它们在for-in循环中出现的顺序。如果是通过Person的实例调 用，则Object.keys()</div><div class="t m0 x0 h5 yb55 ff20 fs2 fc0 sc0 ls8 wseb">返回的数组只包含&quot;name&quot;和&quot;age&quot;这两个实例属性。 </div><div class="t m0 x0 h4 yb56 ff20 fs2 fc0 sc0 ls42 wsf0">如果你想要得到所有实例属性，无论它是否可枚举，都可以使用Object.getOwnPropertyNames()</div><div class="t m0 x0 h5 yb57 ff20 fs2 fc0 sc0 ls44 wsef">方法。 </div><div class="t m0 x0 h15 yb58 ff27 fs6 fc0 sc0 ls21 wsb">var keys = Object.getOwnPropertyNames(Person.prototype); </div><div class="t m0 x0 h15 yb59 ff27 fs6 fc0 sc0 ls21 wsb">alert(keys);    //&quot;constructor,name,age,job,sayName&quot; </div><div class="t m0 x0 h15 yb5a ff27 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf yb5b ff22 fs2 fc0 sc0 ls25 wsb">ObjectPropertyNamesExample01.htm </div><div class="t m0 x0 h4 yb5c ff20 fs2 fc0 sc0 ls1f ws108">注意结果中包含了不可枚举的constructor属性。Object.keys()和Object.getOwnProperty- </div><div class="t m0 x0 h21 yb5d ff21 fs1 fc0 sc0 ls20 ws16">Names()方法都可以用来替代for-in循环。支持这两个方法的浏览器有IE9+、Firefox 4+、Safari 5+、Opera </div><div class="t m0 x0 h5 yb5e ff1a fs2 fc0 sc0 ls1f wsb6">12+和Chrome。 </div><div class="t m0 x0 h3c yb5f ff1e fs2 fc0 sc0 ls2e wsb">3. 更简单的原型语法 </div><div class="t m0 x0 h4 yb60 ff20 fs2 fc0 sc0 ls6 wsf7">读者大概注意到了，前面例子中每添加一个属性和方法就要敲一遍Person.prototype。为减少</div><div class="t m0 x0 h4 yb61 ff20 fs2 fc0 sc0 ls8 wseb">不必要的输入，也为了从视觉上更好地封装原型的功能，更常见的做法是用一个包含所有属性和方法的</div><div class="t m0 x0 h5 yb62 ff20 fs2 fc0 sc0 ls8 wseb">对象字面量来重写整个原型对象，如下面的例子所示。 </div><div class="t m0 x0 hb yb63 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yb64 ff21 fs6 fc0 sc0 ls21 wsb">function Person(){ </div><div class="t m0 x0 hb yb65 ff21 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb yb66 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 yb67 ff27 fs6 fc0 sc0 ls21 wsb">Person.prototype = { </div><div class="t m0 x0 h15 yb68 ff27 fs6 fc0 sc0 ls21 wsb">    name : &quot;Nicholas&quot;, </div><div class="t m0 x0 h15 yb69 ff27 fs6 fc0 sc0 ls21 wsb">    age : 29, </div><div class="t m0 x0 h15 yb6a ff27 fs6 fc0 sc0 ls21 wsb">    job: &quot;Software Engineer&quot;, </div><div class="t m0 x0 h15 yb6b ff27 fs6 fc0 sc0 ls21 wsb">    sayName : function () { </div><div class="t m0 x0 h15 yb6c ff27 fs6 fc0 sc0 ls21 wsb">        alert(this.name); </div><div class="t m0 x0 h15 yb6d ff27 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 h15 yb6e ff27 fs6 fc0 sc0 ls21 wsb">};  </div><div class="t m0 x2 hf yb6f ff22 fs2 fc0 sc0 ls7a wsb">PrototypePatternExample07.htm </div></div></div>
<div id="pfad" class="pf w0 h0" data-page-no="ad"><div class="pc pcad w0 h0"><div class="t m0 x2 h2 y1 ff1a fs0 fc0 sc0 ls10 wsc">6.2 创建对象    155 </div><div class="t m0 x0 h3 y2 ff1a fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff25 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff25 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff25 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff25 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff25 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff25 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff25 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff25 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff25 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff25 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff25 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff25 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff25 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h4 y3 ff20 fs2 fc0 sc0 ls8 wseb">在上面的代码中，我们将Person.prototype设置为等于一个以对象字面量形式创建的新对象。</div><div class="t m0 x0 h1e y4d ff20 fs2 fc0 sc0 ls8 wseb">最终结果相同，但有一个例外：constructor属性不再指向Person了。前面曾经介绍过，每创建一</div><div class="t m0 x0 h1e y5 ff20 fs2 fc0 sc0 ls8 wseb">个函数，就会同时创建它的prototype对象，这个对象也会自动获得constructor 属性。而我们在</div><div class="t m0 x0 h4 yd9 ff20 fs2 fc0 sc0 ls8 wseb">这里使用的语法，本质上完全重写了默认的prototype对象，因此constructor 属性也就变成了新</div><div class="t m0 x0 h1e y15d ff20 fs2 fc0 sc0 ls8 wseb">对象的constructor属性（指向Object构造函数），不再指向Person函数。此时，尽管instanceof</div><div class="t m0 x0 h5 y8 ff20 fs2 fc0 sc0 ls8 wseb">操作符还能返回正确的结果，但通过constructor已经无法确定对象的类型了，如下所示。 </div><div class="t m0 x5 hb yb70 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yb71 ff21 fs6 fc0 sc0 ls21 wsb">var friend = new Person(); </div><div class="t m0 x0 hb yb72 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yb73 ff21 fs6 fc0 sc0 ls21 wsb">alert(friend instanceof Object);       //true </div><div class="t m0 x0 hb yb74 ff21 fs6 fc0 sc0 ls21 wsb">alert(friend instanceof Person);       //true </div><div class="t m0 x0 hb yb75 ff21 fs6 fc0 sc0 ls21 wsb">alert(friend.constructor == Person);    //false </div><div class="t m0 x0 hb yb76 ff21 fs6 fc0 sc0 ls21 wsb">alert(friend.constructor == Object);   //true </div><div class="t m0 x5 hb yb77 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf yb78 ff22 fs2 fc0 sc0 ls7a wsb">PrototypePatternExample07.htm </div><div class="t m0 x0 h4 yb79 ff20 fs2 fc0 sc0 ls8 wseb">在此，用instanceof操作符测试Object和Person 仍然返回true，但constructor属性则</div><div class="t m0 x0 h4 yb7a ff20 fs2 fc0 sc0 ls8 wseb">等于Object而不等于Person了。如果 constructor的值真的很重要，可以像下面这样特意将它设</div><div class="t m0 x0 h5 yb7b ff20 fs2 fc0 sc0 ls8 wseb">置回适当的值。 </div><div class="t m0 x5 hb yb7c ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yb7d ff21 fs6 fc0 sc0 ls21 wsb">function Person(){ </div><div class="t m0 x0 hb yb7e ff21 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb yb7f ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yb80 ff21 fs6 fc0 sc0 ls21 wsb">Person.prototype = { </div><div class="t m0 x0 h15 yb81 ff27 fs6 fc0 sc0 ls21 wsb">    constructor : Person, </div><div class="t m0 x0 hb yb82 ff21 fs6 fc0 sc0 ls21 wsb">    name : &quot;Nicholas&quot;, </div><div class="t m0 x0 hb yb83 ff21 fs6 fc0 sc0 ls21 wsb">    age : 29, </div><div class="t m0 x0 hb yb84 ff21 fs6 fc0 sc0 ls21 wsb">    job: &quot;Software Engineer&quot;, </div><div class="t m0 x0 hb yb85 ff21 fs6 fc0 sc0 ls21 wsb">    sayName : function () { </div><div class="t m0 x0 hb yb86 ff21 fs6 fc0 sc0 ls21 wsb">        alert(this.name); </div><div class="t m0 x0 hb yb87 ff21 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb yb88 ff21 fs6 fc0 sc0 ls21 wsb">};  </div><div class="t m0 x2 hf yb89 ff22 fs2 fc0 sc0 ls7a wsb">PrototypePatternExample07.htm </div><div class="t m0 x0 h4 yb8a ff20 fs2 fc0 sc0 ls8 wseb">以上代码特意包含了一个constructor属性，并将它的值设置为Person，从而确保了通过该属</div><div class="t m0 x0 h5 yb8b ff20 fs2 fc0 sc0 ls8 wseb">性能够访问到适当的值。 </div><div class="t m0 x0 hc yb8c ff20 fs2 fc0 sc0 ls8 wseb">注意，以这种方式重设constructor属性会导致它的[[Enumerable]]特性被设置为true。默认</div><div class="t m0 x0 hc yb8d ff20 fs2 fc0 sc0 ls8 wseb">情况下，原生的constructor属性是不可枚举的，因此如果你使用兼容ECMAScript 5的JavaScript引</div><div class="t m0 x0 hc yb8e ff20 fs2 fc0 sc0 ls8 wseb">擎，可以试一试Object.defineProperty()。 </div><div class="t m0 x0 hb yb8f ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yb90 ff21 fs6 fc0 sc0 ls21 wsb">function Person(){ </div><div class="t m0 x0 hb yb91 ff21 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb yb92 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yb93 ff21 fs6 fc0 sc0 ls21 wsb">Person.prototype = { </div><div class="t m0 x0 hb yb94 ff21 fs6 fc0 sc0 ls21 wsb">    name : &quot;Nicholas&quot;, </div><div class="t m0 x0 hb yb95 ff21 fs6 fc0 sc0 ls21 wsb">    age : 29, </div><div class="t m0 x0 hb yb96 ff21 fs6 fc0 sc0 ls21 wsb">    job : &quot;Software Engineer&quot;, </div><div class="t m0 x0 hb yb97 ff21 fs6 fc0 sc0 ls21 wsb">    sayName : function () { </div><div class="t m0 x0 hb yb98 ff21 fs6 fc0 sc0 ls21 wsb">        alert(this.name); </div><div class="t m0 x0 hb yb99 ff21 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb yb9a ff21 fs6 fc0 sc0 ls21 wsb">};  </div></div></div>
<div id="pfae" class="pf w0 h0" data-page-no="ae"><div class="pc pcae w0 h0"><div class="t m0 x0 h2 y1 ff1a fs0 fc0 sc0 ls7 ws0">156  第6章 面向对象的程序设计 </div><div class="t m0 x0 h3 y2 ff1a fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h36 y79 ff27 fs6 fc0 sc0 ls21 ws34">//重设构造函数，只适用于ECMAScript 5兼容的浏览器 </div><div class="t m0 x0 h15 y7a ff27 fs6 fc0 sc0 ls21 wsb">Object.defineProperty(Person.prototype, &quot;constructor&quot;, { </div><div class="t m0 x0 hb y7b ff21 fs6 fc0 sc0 ls21 wsb">    enumerable: false, </div><div class="t m0 x0 hb y7c ff21 fs6 fc0 sc0 ls21 wsb">    value: Person </div><div class="t m0 x0 h15 y7d ff27 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 h15 yaab ff27 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h3c yb9c ff1e fs2 fc0 sc0 ls2e wsb">4. 原型的动态性 </div><div class="t m0 x0 h4 yb9d ff20 fs2 fc0 sc0 ls8 wseb">由于在原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上</div><div class="t m0 x0 h5 yb9e ff20 fs2 fc0 sc0 ls8 wseb">反映出来——即使是先创建了实例后修改原型也照样如此。请看下面的例子。 </div><div class="t m0 x0 hb yb9f ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yba0 ff21 fs6 fc0 sc0 ls21 wsb">var friend = new Person(); </div><div class="t m0 x0 hb yba1 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yba2 ff21 fs6 fc0 sc0 ls21 wsb">Person.prototype.sayHi = function(){ </div><div class="t m0 x0 hb yba3 ff21 fs6 fc0 sc0 ls21 wsb">    alert(&quot;hi&quot;); </div><div class="t m0 x0 hb yba4 ff21 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb yba5 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 yba6 ff21 fs6 fc0 sc0 ls21 wsb">friend.sayHi();   //&quot;hi&quot;（没有问题！） </div><div class="t m0 x0 hb yba7 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf yba8 ff22 fs2 fc0 sc0 ls7a wsb">PrototypePatternExample09.htm </div><div class="t m0 x0 h4 yba9 ff20 fs2 fc0 sc0 ls8 wseb">以上代码先创建了Person的一个实例，并将其保存在person中。然后，下一条语句在Person. </div><div class="t m0 x0 h42 ybaa ff21 fs1 fc0 sc0 ls9 ws2">prototype中添加了一个方法sayHi()。即使person实例是在添加新方法之前创建的，但它仍然可</div><div class="t m0 x0 h4 ybab ff20 fs2 fc0 sc0 ls8 wseb">以访问这个新方法。其原因可以归结为实例与原型之间的松散连接关系。当我们调用person.sayHi()</div><div class="t m0 x0 h4 ybac ff20 fs2 fc0 sc0 ls8 wseb">时，首先会在实例中搜索名为sayHi的属性，在没找到的情况下，会继续搜索原型。因为实例与原型</div><div class="t m0 x0 h1e ybad ff20 fs2 fc0 sc0 ls8 wseb">之间的连接只不过是一个指针，而非一个副本，因此就可以在原型中找到新的sayHi属性并返回保存</div><div class="t m0 x0 h5 ybae ff20 fs2 fc0 sc0 ls8 wseb">在那里的函数。 </div><div class="t m0 x0 h4 ybaf ff20 fs2 fc0 sc0 ls8 wseb">尽管可以随时为原型添加属性和方法，并且修改能够立即在所有对象实例中反映出来，但如果是重</div><div class="t m0 x0 h4 ybb0 ff20 fs2 fc0 sc0 ls8 wseb">写整个原型对象，那么情况就不一样了。我们知道，调用构造函数时会为实例添加一个指向最初原型的</div><div class="t m0 x0 h4 ybb1 ff21 fs1 fc0 sc0 ls9 ws2">[[Prototype]]指针，而把原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系。</div><div class="t m0 x0 h5 ybb2 ff20 fs2 fc0 sc0 ls8 wseb">请记住：实例中的指针仅指向原型，而不指向构造函数。看下面的例子。 </div><div class="t m0 x0 hb ybb3 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ybb4 ff21 fs6 fc0 sc0 ls21 wsb">function Person(){ </div><div class="t m0 x0 hb ybb5 ff21 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb ybb6 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ybb7 ff21 fs6 fc0 sc0 ls21 wsb">var friend = new Person(); </div><div class="t m0 x0 hb ybb8 ff21 fs6 fc0 sc0 ls21 wsb">         </div><div class="t m0 x0 hb ybb9 ff21 fs6 fc0 sc0 ls21 wsb">Person.prototype = { </div><div class="t m0 x0 hb ybba ff21 fs6 fc0 sc0 ls21 wsb">    constructor: Person, </div><div class="t m0 x0 hb ybbb ff21 fs6 fc0 sc0 ls21 wsb">    name : &quot;Nicholas&quot;, </div><div class="t m0 x0 hb ybbc ff21 fs6 fc0 sc0 ls21 wsb">    age : 29, </div><div class="t m0 x0 hb ybbd ff21 fs6 fc0 sc0 ls21 wsb">    job : &quot;Software Engineer&quot;, </div><div class="t m0 x0 hb ybbe ff21 fs6 fc0 sc0 ls21 wsb">    sayName : function () { </div><div class="t m0 x0 hb ybbf ff21 fs6 fc0 sc0 ls21 wsb">        alert(this.name); </div><div class="t m0 x0 hb ybc0 ff21 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb ybc1 ff21 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb ybc2 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ybc3 ff21 fs6 fc0 sc0 ls21 wsb">friend.sayName();   //error </div><div class="t m0 x0 hb ybc4 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf ybc5 ff22 fs2 fc0 sc0 ls7a wsb">PrototypePatternExample10.htm </div><div class="t m0 x0 h4 ybc6 ff20 fs2 fc0 sc0 ls4c wsfa">在这个例子中，我们先创建了Person的一个实例，然后又重写了其原型对象。然后在调用</div><div class="t m0 x0 h5 ybc7 ff21 fs1 fc0 sc0 ls9 ws2">friend.sayName()时发生了错误，因为friend指向的原型中不包含以该名字命名的属性。图6-3展</div></div></div>
<div id="pfaf" class="pf w0 h0" data-page-no="af"><div class="pc pcaf w0 h0"><div class="t m0 x2 h2 y1 ff1a fs0 fc0 sc0 ls10 wsc">6.2 创建对象    157 </div><div class="t m0 x0 h3 y2 ff1a fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff25 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff25 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff25 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff25 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff25 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff25 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff25 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff25 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff25 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff25 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff25 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff25 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff25 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff20 fs2 fc0 sc0 ls8 wseb">示了这个过程的内幕。 </div><div class="t m0 x6 h5 ybc8 ff1a fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 h3 ybc9 ff20 fs1 fc0 sc0 ls8 wsb">图 6-3 </div><div class="t m0 x0 h5 ybca ff20 fs2 fc0 sc0 ls8 wseb">从图6-3可以看出，重写原型对象切断了现有原型与任何之前已经存在的对象实例之间的联系；它</div><div class="t m0 x0 h5 ybcb ff20 fs2 fc0 sc0 ls8 wseb">们引用的仍然是最初的原型。 </div><div class="t m0 x0 h3c ybcc ff1e fs2 fc0 sc0 ls2e wsb">5. 原生对象的原型 </div><div class="t m0 x0 h4 ybcd ff20 fs2 fc0 sc0 ls8 wseb">原型模式的重要性不仅体现在创建自定义类型方面，就连所有原生的引用类型，都是采用这种模式</div><div class="t m0 x0 h4 ybce ff20 fs2 fc0 sc0 ls8 wseb">创建的。所有原生引用类型（Object、Array、String，等等）都在其构造函数的原型上定义了方法。</div><div class="t m0 x0 h1e ybcf ff20 fs2 fc0 sc0 ls147 ws115">例如，在Array.prototype中可以找到 sort()方法，而在String.prototype中可以找到</div><div class="t m0 x0 h5 ybd0 ff21 fs1 fc0 sc0 ls9 ws2">substring()方法，如下所示。 </div><div class="t m0 x5 hb ybd1 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ybd2 ff21 fs6 fc0 sc0 ls21 wsb">alert(typeof Array.prototype.sort);           //&quot;function&quot; </div><div class="t m0 x0 hb ybd3 ff21 fs6 fc0 sc0 ls21 wsb">alert(typeof String.prototype.substring);     //&quot;function&quot; </div><div class="t m0 x5 hb ybd4 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 ybd5 ff20 fs2 fc0 sc0 ls8 wseb">通过原生对象的原型，不仅可以取得所有默认方法的引用，而且也可以定义新方法。可以像修改自</div><div class="t m0 x0 h4 ybd6 ff20 fs2 fc0 sc0 ls4">定义对象的原型一样修改原生对象的原型，因此可以随时添加方法。下面的代码就给基本包装类型</div><div class="t m0 x0 h5 ybd7 ff21 fs1 fc0 sc0 ls9 ws2">String添加了一个名为startsWith()的方法。 </div><div class="t m0 x5 hb ybd8 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ybd9 ff21 fs6 fc0 sc0 ls21 wsb">String.prototype.startsWith = function (text) { </div><div class="t m0 x0 hb ybda ff21 fs6 fc0 sc0 ls21 wsb">    return this.indexOf(text) == 0; </div><div class="t m0 x0 hb ybdb ff21 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb ybdc ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ybdd ff21 fs6 fc0 sc0 ls21 wsb">var msg = &quot;Hello world!&quot;; </div><div class="t m0 x0 hb ybde ff21 fs6 fc0 sc0 ls21 wsb">alert(msg.startsWith(&quot;Hello&quot;));   //true </div><div class="t m0 x0 hb ybdf ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf ybe0 ff22 fs2 fc0 sc0 ls2f wsb">PrototypePatternExample11.htm </div></div></div>
<div id="pfb0" class="pf w0 h0" data-page-no="b0"><div class="pc pcb0 w0 h0"><div class="t m0 x0 h2 y1 ff1a fs0 fc0 sc0 ls7 ws0">158  第6章 面向对象的程序设计 </div><div class="t m0 x0 h3 y2 ff1a fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ff20 fs2 fc0 sc0 ls8 wseb">这里新定义的startsWith()方法会在传入的文本位于一个字符串开始时返回true。既然方法被</div><div class="t m0 x0 h1e y4d ff20 fs2 fc0 sc0 ls8 wseb">添加给了String.prototype，那么当前环境中的所有字符串就都可以调用它。由于msg是字符串，</div><div class="t m0 x0 hc y5 ff20 fs2 fc0 sc0 ls1f ws108">而且后台会调用String基本包装函数创建这个字符串，因此通过msg就可以调用startsWith()方法。 </div><div class="t m0 x5 ha y59e ff1b fs2 fc0 sc0 ls8 ws14">尽管可以这样做，但我们不推荐在产品化的程序中修改原生对象的原型。如果因</div><div class="t m0 x0 ha ybe2 ff1b fs2 fc0 sc0 ls8 ws14">某个实现中缺少某个方法，就在原生对象的原型中添加这个方法，那么当在另一个支</div><div class="t m0 x0 ha ybe3 ff1b fs2 fc0 sc0 ls8 ws14">持该方法的实现中运行代码时，就可能会导致命名冲突。而且，这样做也可能会意外</div><div class="t m0 x0 h5 ybe4 ff1b fs2 fc0 sc0 ls8 ws14">地重写原生方法。 </div><div class="t m0 x0 h3c ybe5 ff1e fs2 fc0 sc0 ls2e wsb">6. 原型对象的问题 </div><div class="t m0 x0 h4 ybe6 ff20 fs2 fc0 sc0 ls8 wseb">原型模式也不是没有缺点。首先，它省略了为构造函数传递初始化参数这一环节，结果所有实例在</div><div class="t m0 x0 h4 ybe7 ff20 fs2 fc0 sc0 ls8 wseb">默认情况下都将取得相同的属性值。虽然这会在某种程度上带来一些不方便，但还不是原型的最大问题。</div><div class="t m0 x0 h5 ybe8 ff20 fs2 fc0 sc0 ls8 wseb">原型模式的最大问题是由其共享的本性所导致的。 </div><div class="t m0 x0 h4 ybe9 ff20 fs2 fc0 sc0 ls8 wseb">原型中所有属性是被很多实例共享的，这种共享对于函数非常合适。对于那些包含基本值的属性倒</div><div class="t m0 x0 h4 ybea ff20 fs2 fc0 sc0 ls6 wsf7">也说得过去，毕竟（如前面的例子所示），通过在实例上添加一个同名属性，可以隐藏原型中的对应属</div><div class="t m0 x0 h5 ybeb ff20 fs2 fc0 sc0 ls8 wseb">性。然而，对于包含引用类型值的属性来说，问题就比较突出了。来看下面的例子。 </div><div class="t m0 x0 hb ybec ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ybed ff21 fs6 fc0 sc0 ls21 wsb">function Person(){ </div><div class="t m0 x0 hb ybee ff21 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb ybef ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ybf0 ff21 fs6 fc0 sc0 ls21 wsb">Person.prototype = { </div><div class="t m0 x0 hb ybf1 ff21 fs6 fc0 sc0 ls21 wsb">    constructor: Person, </div><div class="t m0 x0 hb ybf2 ff21 fs6 fc0 sc0 ls21 wsb">    name : &quot;Nicholas&quot;, </div><div class="t m0 x0 hb ybf3 ff21 fs6 fc0 sc0 ls21 wsb">    age : 29, </div><div class="t m0 x0 hb ybf4 ff21 fs6 fc0 sc0 ls21 wsb">    job : &quot;Software Engineer&quot;, </div><div class="t m0 x0 h15 ybf5 ff27 fs6 fc0 sc0 ls21 wsb">    friends : [&quot;Shelby&quot;, &quot;Court&quot;], </div><div class="t m0 x0 hb ybf6 ff21 fs6 fc0 sc0 ls21 wsb">    sayName : function () { </div><div class="t m0 x0 hb ybf7 ff21 fs6 fc0 sc0 ls21 wsb">        alert(this.name); </div><div class="t m0 x0 hb ybf8 ff21 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb ybf9 ff21 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb ybfa ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ybfb ff21 fs6 fc0 sc0 ls21 wsb">var person1 = new Person(); </div><div class="t m0 x0 hb ybfc ff21 fs6 fc0 sc0 ls21 wsb">var person2 = new Person(); </div><div class="t m0 x0 hb ybfd ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 ybfe ff27 fs6 fc0 sc0 ls21 wsb">person1.friends.push(&quot;Van&quot;); </div><div class="t m0 x0 h15 ybff ff27 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 yc00 ff27 fs6 fc0 sc0 ls21 wsb">alert(person1.friends);    //&quot;Shelby,Court,Van&quot; </div><div class="t m0 x0 h15 yc01 ff27 fs6 fc0 sc0 ls21 wsb">alert(person2.friends);    //&quot;Shelby,Court,Van&quot; </div><div class="t m0 x0 h15 yc02 ff27 fs6 fc0 sc0 ls21 wsb">alert(person1.friends === person2.friends);  //true </div><div class="t m0 x2 hf yc03 ff22 fs2 fc0 sc0 ls7a wsb">PrototypePatternExample12.htm </div><div class="t m0 x0 h4 yc04 ff20 fs2 fc0 sc0 ls8 wseb">在此，Person.prototype对象有一个名为friends的属性，该属性包含一个字符串数组。然后，</div><div class="t m0 x0 h1e yc05 ff20 fs2 fc0 sc0 ls8 wseb">创建了Person的两个实例。接着，修改了person1.friends引用的数组，向数组中添加了一个字符</div><div class="t m0 x0 h4 yc06 ff20 fs2 fc0 sc0 ls8 wseb">串。由于friends数组存在于Person.prototype而非 person1中，所以刚刚提到的修改也会通过</div><div class="t m0 x0 h4 yc07 ff21 fs1 fc0 sc0 ls9 ws2">person2.friends（与person1.friends指向同一个数组）反映出来。假如我们的初衷就是像这样</div><div class="t m0 x0 h4 yc08 ff20 fs2 fc0 sc0 ls8 wseb">在所有实例中共享一个数组，那么对这个结果我没有话可说。可是，实例一般都是要有属于自己的全部</div><div class="t m0 x0 h5 yc09 ff20 fs2 fc0 sc0 ls8 wseb">属性的。而这个问题正是我们很少看到有人单独使用原型模式的原因所在。 </div></div></div>
<div id="pfb1" class="pf w0 h0" data-page-no="b1"><div class="pc pcb1 w0 h0"><div class="t m0 x2 h2 y1 ff1a fs0 fc0 sc0 ls10 wsc">6.2 创建对象    159 </div><div class="t m0 x0 h3 y2 ff1a fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff25 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff25 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff25 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff25 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff25 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff25 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff25 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff25 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff25 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff25 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff25 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff25 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff25 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h20 y12d ff1e fs3 fc0 sc0 ls4d ws40">6.2.4 组合使用构造函数模式和原型模式 </div><div class="t m0 x0 h4 y12e ff20 fs2 fc0 sc0 ls8 wseb">创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式。构造函数模式用于定义实</div><div class="t m0 x0 h4 y12f ff20 fs2 fc0 sc0 ls8 wseb">例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，</div><div class="t m0 x0 h4 y130 ff20 fs2 fc0 sc0 ls8 wseb">但同时又共享着对方法的引用，最大限度地节省了内存。另外，这种混成模式还支持向构造函数传递参</div><div class="t m0 x0 h5 yc0a ff20 fs2 fc0 sc0 ls8 wseb">数；可谓是集两种模式之长。下面的代码重写了前面的例子。 </div><div class="t m0 x5 hb y132 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yc0b ff21 fs6 fc0 sc0 ls21 wsb">function Person(name, age, job){ </div><div class="t m0 x0 hb yc0c ff21 fs6 fc0 sc0 ls21 wsb">    this.name = name; </div><div class="t m0 x0 hb yc0d ff21 fs6 fc0 sc0 ls21 wsb">    this.age = age; </div><div class="t m0 x0 hb yc0e ff21 fs6 fc0 sc0 ls21 wsb">    this.job = job; </div><div class="t m0 x0 hb yc0f ff21 fs6 fc0 sc0 ls21 wsb">    this.friends = [&quot;Shelby&quot;, &quot;Court&quot;]; </div><div class="t m0 x0 hb yc10 ff21 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb yc11 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yc12 ff21 fs6 fc0 sc0 ls21 wsb">Person.prototype = { </div><div class="t m0 x0 hb yc13 ff21 fs6 fc0 sc0 ls21 wsb">    constructor : Person, </div><div class="t m0 x0 hb yc14 ff21 fs6 fc0 sc0 ls21 wsb">    sayName : function(){ </div><div class="t m0 x0 hb yc15 ff21 fs6 fc0 sc0 ls21 wsb">        alert(this.name); </div><div class="t m0 x0 hb yc16 ff21 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb yc17 ff21 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb yc18 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yc19 ff21 fs6 fc0 sc0 ls21 wsb">var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;); </div><div class="t m0 x0 hb yc1a ff21 fs6 fc0 sc0 ls21 wsb">var person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;); </div><div class="t m0 x0 hb yc1b ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yc1c ff21 fs6 fc0 sc0 ls21 wsb">person1.friends.push(&quot;Van&quot;); </div><div class="t m0 x0 hb yc1d ff21 fs6 fc0 sc0 ls21 wsb">alert(person1.friends);    //&quot;Shelby,Count,Van&quot; </div><div class="t m0 x0 hb yc1e ff21 fs6 fc0 sc0 ls21 wsb">alert(person2.friends);    //&quot;Shelby,Count&quot; </div><div class="t m0 x0 hb yc1f ff21 fs6 fc0 sc0 ls21 wsb">alert(person1.friends === person2.friends);    //false </div><div class="t m0 x0 hb yc20 ff21 fs6 fc0 sc0 ls21 wsb">alert(person1.sayName === person2.sayName);    //true </div><div class="t m0 x2 hf yc21 ff22 fs2 fc0 sc0 ls5e wsb">HybridPatternExample01.htm </div><div class="t m0 x0 h4 yc22 ff20 fs2 fc0 sc0 ls8 wseb">在这个例子中，实例属性都是在构造函数中定义的，而由所有实例共享的属性constructor和方</div><div class="t m0 x0 h1e yc23 ff20 fs2 fc0 sc0 ls14f">法sayName()则是在原型中定义的。而修改了person1.friends（向其中添加一个新字符串），并不</div><div class="t m0 x0 hc yc24 ff20 fs2 fc0 sc0 ls8 wseb">会影响到person2.friends，因为它们分别引用了不同的数组。 </div><div class="t m0 x0 h5 yc25 ff20 fs2 fc0 sc0 ls8 wseb">这种构造函数与原型混成的模式，是目前在ECMAScript中使用最广泛、认同度最高的一种创建自</div><div class="t m0 x0 h5 yc26 ff20 fs2 fc0 sc0 ls8 wseb">定义类型的方法。可以说，这是用来定义引用类型的一种默认模式。 </div><div class="t m0 x0 h20 yc27 ff1e fs3 fc0 sc0 ls4d ws40">6.2.5 动态原型模式 </div><div class="t m0 x0 h5 yc28 ff20 fs2 fc0 sc0 ls8 wseb">有其他OO语言经验的开发人员在看到独立的构造函数和原型时，很可能会感到非常困惑。动态原</div><div class="t m0 x0 h4 yc29 ff20 fs2 fc0 sc0 ls8 wseb">型模式正是致力于解决这个问题的一个方案，它把所有信息都封装在了构造函数中，而通过在构造函数</div><div class="t m0 x0 h4 yc2a ff20 fs2 fc0 sc0 ls6 wsf7">中初始化原型（仅在必要的情况下），又保持了同时使用构造函数和原型的优点。换句话说，可以通过</div><div class="t m0 x0 h5 yc2b ff20 fs2 fc0 sc0 ls8 wseb">检查某个应该存在的方法是否有效，来决定是否需要初始化原型。来看一个例子。 </div><div class="t m0 x5 hb yc2c ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yc2d ff21 fs6 fc0 sc0 ls21 wsb">function Person(name, age, job){ </div><div class="t m0 x0 hb yc2e ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 yc2f ff21 fs6 fc0 sc0 ls21 wsb">    //属性 </div><div class="t m0 x0 hb yc30 ff21 fs6 fc0 sc0 ls21 wsb">    this.name = name; </div><div class="t m0 x0 hb yc31 ff21 fs6 fc0 sc0 ls21 wsb">    this.age = age; </div><div class="t m0 x0 hb yc32 ff21 fs6 fc0 sc0 ls21 wsb">    this.job = job; </div><div class="t m0 x0 hb yc33 ff21 fs6 fc0 sc0 ls21 wsb">     </div></div></div>
<div id="pfb2" class="pf w0 h0" data-page-no="b2"><div class="pc pcb2 w0 h0"><div class="t m0 x0 h2 y1 ff1a fs0 fc0 sc0 ls7 ws0">160  第6章 面向对象的程序设计 </div><div class="t m0 x0 h3 y2 ff1a fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y79 ff21 fs6 fc0 sc0 ls21 wsb">    //方法 </div><div class="t m0 x0 h15 y7a ff27 fs6 fc0 sc0 ls21 wsb">    if (typeof this.sayName != &quot;function&quot;){ </div><div class="t m0 x0 h15 y7b ff27 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 h15 y7c ff27 fs6 fc0 sc0 ls21 wsb">        Person.prototype.sayName = function(){ </div><div class="t m0 x0 h15 y7d ff27 fs6 fc0 sc0 ls21 wsb">            alert(this.name); </div><div class="t m0 x0 h15 y7e ff27 fs6 fc0 sc0 ls21 wsb">        }; </div><div class="t m0 x0 h15 y7f ff27 fs6 fc0 sc0 ls21 wsb">         </div><div class="t m0 x0 h15 y80 ff27 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y81 ff21 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y82 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y83 ff21 fs6 fc0 sc0 ls21 wsb">var friend = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;); </div><div class="t m0 x0 hb y84 ff21 fs6 fc0 sc0 ls21 wsb">friend.sayName(); </div><div class="t m0 x0 hb yc35 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf yc36 ff22 fs2 fc0 sc0 ls1b wsb">DynamicPrototypeExample01.htm </div><div class="t m0 x0 h4 yc37 ff20 fs2 fc0 sc0 ls6 wsf7">注意构造函数代码中加粗的部分。这里只在sayName()方法不存在的情况下，才会将它添加到原</div><div class="t m0 x0 h4 yc38 ff20 fs2 fc0 sc0 ls8 wseb">型中。这段代码只会在初次调用构造函数时才会执行。此后，原型已经完成初始化，不需要再做什么修</div><div class="t m0 x0 h4 y2bc ff20 fs2 fc0 sc0 ls8 wseb">改了。不过要记住，这里对原型所做的修改，能够立即在所有实例中得到反映。因此，这种方法确实可</div><div class="t m0 x0 h1c yc39 ff20 fs2 fc0 sc0 ls8 wseb">以说非常完美。其中，if语句检查的可以是初始化之后应该存在的任何属性或方法——不必用一大堆</div><div class="t m0 x0 h4 yc3a ff21 fs1 fc0 sc0 ls9 ws2">if语句检查每个属性和每个方法；只要检查其中一个即可。对于采用这种模式创建的对象，还可以使</div><div class="t m0 x0 hc yc3b ff20 fs2 fc0 sc0 ls151">用instanceof操作符确定它的类型。 </div><div class="t m0 x5 ha yc3c ff1b fs2 fc0 sc0 ls8 ws14">使用动态原型模式时，不能使用对象字面量重写原型。前面已经解释过了，如果</div><div class="t m0 x0 h5 yc3d ff1b fs2 fc0 sc0 ls8 ws14">在已经创建了实例的情况下重写原型，那么就会切断现有实例与新原型之间的联系。 </div><div class="t m0 x0 h20 yc3e ff1e fs3 fc0 sc0 ls4d ws40">6.2.6 寄生构造函数模式 </div><div class="t m0 x0 h5 yc3f ff20 fs2 fc0 sc0 ls5 wsec">通常，在前述的几种模式都不适用的情况下，可以使用寄生（parasitic）构造函数模式。这种模式</div><div class="t m0 x0 h4 ya98 ff20 fs2 fc0 sc0 ls8 wseb">的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象；但</div><div class="t m0 x0 h5 yc40 ff20 fs2 fc0 sc0 ls8 wseb">从表面上看，这个函数又很像是典型的构造函数。下面是一个例子。 </div><div class="t m0 x0 hb yc41 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yc42 ff21 fs6 fc0 sc0 ls21 wsb">function Person(name, age, job){ </div><div class="t m0 x0 hb yc43 ff21 fs6 fc0 sc0 ls21 wsb">    var o = new Object(); </div><div class="t m0 x0 hb yc44 ff21 fs6 fc0 sc0 ls21 wsb">    o.name = name; </div><div class="t m0 x0 hb yc45 ff21 fs6 fc0 sc0 ls21 wsb">    o.age = age; </div><div class="t m0 x0 hb yc46 ff21 fs6 fc0 sc0 ls21 wsb">    o.job = job; </div><div class="t m0 x0 hb yc47 ff21 fs6 fc0 sc0 ls21 wsb">    o.sayName = function(){ </div><div class="t m0 x0 hb yc48 ff21 fs6 fc0 sc0 ls21 wsb">        alert(this.name); </div><div class="t m0 x0 hb yc49 ff21 fs6 fc0 sc0 ls21 wsb">    };     </div><div class="t m0 x0 hb yc4a ff21 fs6 fc0 sc0 ls21 wsb">    return o; </div><div class="t m0 x0 hb yc4b ff21 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb yc4c ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yc4d ff21 fs6 fc0 sc0 ls21 wsb">var friend = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;); </div><div class="t m0 x0 hb yc4e ff21 fs6 fc0 sc0 ls21 wsb">friend.sayName();  //&quot;Nicholas&quot; </div><div class="t m0 x0 hb yc4f ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf y8c0 ff22 fs2 fc0 sc0 ls25 wsb">HybridFactoryPatternExample01.htm </div><div class="t m0 x0 h4 yc50 ff20 fs2 fc0 sc0 ls8 wseb">在这个例子中，Person函数创建了一个新对象，并以相应的属性和方法初始化该对象，然后又返</div><div class="t m0 x0 h1e yc51 ff20 fs2 fc0 sc0 ls8 wseb">回了这个对象。除了使用new操作符并把使用的包装函数叫做构造函数之外，这个模式跟工厂模式其实</div><div class="t m0 x0 h4 yc52 ff20 fs2 fc0 sc0 ls8 wseb">是一模一样的。构造函数在不返回值的情况下，默认会返回新对象实例。而通过在构造函数的末尾添加</div></div></div>
<div id="pfb3" class="pf w0 h0" data-page-no="b3"><div class="pc pcb3 w0 h0"><div class="t m0 x2 h2 y1 ff1a fs0 fc0 sc0 ls10 wsc">6.2 创建对象    161 </div><div class="t m0 x0 h3 y2 ff1a fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff25 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff25 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff25 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff25 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff25 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff25 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff25 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff25 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff25 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff25 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff25 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff25 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff25 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff20 fs2 fc0 sc0 ls8 wseb">一个return语句，可以重写调用构造函数时返回的值。 </div><div class="t m0 x0 h4 y4d ff20 fs2 fc0 sc0 ls8 wseb">这个模式可以在特殊的情况下用来为对象创建构造函数。假设我们想创建一个具有额外方法的特殊</div><div class="t m0 x0 he yd8 ff20 fs2 fc0 sc0 ls8 wseb">数组。由于不能直接修改Array构造函数，因此可以使用这个模式。 </div><div class="t m0 x5 hb y6bd ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y6be ff21 fs6 fc0 sc0 ls21 wsb">function SpecialArray(){ </div><div class="t m0 x0 hb y6bf ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y6c0 ff21 fs6 fc0 sc0 ls21 wsb">    //创建数组 </div><div class="t m0 x0 hb y6c1 ff21 fs6 fc0 sc0 ls21 wsb">    var values = new Array(); </div><div class="t m0 x0 hb y6c2 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y6c3 ff21 fs6 fc0 sc0 ls21 wsb">    //添加值 </div><div class="t m0 x0 hb y6c4 ff21 fs6 fc0 sc0 ls21 wsb">    values.push.apply(values, arguments); </div><div class="t m0 x0 hb yc53 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 yc54 ff21 fs6 fc0 sc0 ls21 wsb">    //添加方法 </div><div class="t m0 x0 hb yc55 ff21 fs6 fc0 sc0 ls21 wsb">    values.toPipedString = function(){ </div><div class="t m0 x0 hb yc56 ff21 fs6 fc0 sc0 ls21 wsb">        return this.join(&quot;|&quot;); </div><div class="t m0 x0 hb yc57 ff21 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 hb yc58 ff21 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 h16 yc59 ff21 fs6 fc0 sc0 ls21 wsb">    //返回数组 </div><div class="t m0 x0 hb yc5a ff21 fs6 fc0 sc0 ls21 wsb">    return values; </div><div class="t m0 x0 hb yc5b ff21 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb yc5c ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yc5d ff21 fs6 fc0 sc0 ls21 wsb">var colors = new SpecialArray(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;); </div><div class="t m0 x0 hb yc5e ff21 fs6 fc0 sc0 ls21 wsb">alert(colors.toPipedString()); //&quot;red|blue|green&quot; </div><div class="t m0 x2 hf yc5f ff22 fs2 fc0 sc0 ls25 wsb">HybridFactoryPatternExample02.htm </div><div class="t m0 x0 h4 yc60 ff20 fs2 fc0 sc0 ls8 wseb">在这个例子中，我们创建了一个名叫SpecialArray的构造函数。在这个函数内部，首先创建了</div><div class="t m0 x0 h1e yc61 ff20 fs2 fc0 sc0 ls8 wseb">一个数组，然后push()方法（用构造函数接收到的所有参数）初始化了数组的值。随后，又给数组实</div><div class="t m0 x0 h1e yc62 ff20 fs2 fc0 sc0 ls8 wseb">例添加了一个toPipedString()方法，该方法返回以竖线分割的数组值。最后，将数组以函数值的形</div><div class="t m0 x0 h4 yc63 ff20 fs2 fc0 sc0 ls8 wseb">式返回。接着，我们调用了SpecialArray构造函数，向其中传入了用于初始化数组的值，此后又调</div><div class="t m0 x0 hc yc64 ff20 fs2 fc0 sc0 ls8 wseb">用了toPipedString()方法。 </div><div class="t m0 x0 h4 yc65 ff20 fs2 fc0 sc0 ls8 wseb">关于寄生构造函数模式，有一点需要说明：首先，返回的对象与构造函数或者与构造函数的原型属</div><div class="t m0 x0 h4 yc66 ff20 fs2 fc0 sc0 ls8 wseb">性之间没有关系；也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同。为此，</div><div class="t m0 x0 h1c yc67 ff20 fs2 fc0 sc0 ls8 wseb">不能依赖instanceof操作符来确定对象类型。由于存在上述问题，我们建议在可以使用其他模式的情</div><div class="t m0 x0 h5 yc68 ff20 fs2 fc0 sc0 ls8 wseb">况下，不要使用这种模式。 </div><div class="t m0 x0 h20 yc69 ff1e fs3 fc0 sc0 ls4d ws40">6.2.7 稳妥构造函数模式 </div><div class="t m0 x0 h5 yc6a ff20 fs2 fc0 sc0 ls8 wseb">道格拉斯·克罗克福德（Douglas Crockford）发明了JavaScript中的稳妥对象（durable objects）这</div><div class="t m0 x0 h1e yc6b ff20 fs2 fc0 sc0 ls8 wseb">个概念。所谓稳妥对象，指的是没有公共属性，而且其方法也不引用this的对象。稳妥对象最适合在</div><div class="t m0 x0 h5 yc6c ff20 fs2 fc0 sc0 ls8 wseb">一些安全的环境中（这些环境中会禁止使用this和new），或者在防止数据被其他应用程序（如Mashup</div><div class="t m0 x0 h4 yc6d ff20 fs2 fc0 sc0 ls8 wseb">程序）改动时使用。稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：一是新创建对象的</div><div class="t m0 x0 h1c yc6e ff20 fs2 fc0 sc0 ls8 wseb">实例方法不引用this；二是不使用new操作符调用构造函数。按照稳妥构造函数的要求，可以将前面</div><div class="t m0 x0 hc yc6f ff20 fs2 fc0 sc0 lsda">的Person构造函数重写如下。 </div><div class="t m0 x5 hb yc70 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yc71 ff21 fs6 fc0 sc0 ls21 wsb">function Person(name, age, job){ </div><div class="t m0 x0 hb yc72 ff21 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 h16 yc73 ff21 fs6 fc0 sc0 ls21 wsb">    //创建要返回的对象 </div><div class="t m0 x0 hb yc74 ff21 fs6 fc0 sc0 ls21 wsb">    var o = new Object(); </div><div class="t m0 x0 hb yc75 ff21 fs6 fc0 sc0 ls21 wsb">     </div></div></div>
<div id="pfb4" class="pf w0 h0" data-page-no="b4"><div class="pc pcb4 w0 h0"><div class="t m0 x0 h2 y1 ff1a fs0 fc0 sc0 ls7 ws0">162  第6章 面向对象的程序设计 </div><div class="t m0 x0 h3 y2 ff1a fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y44f ff21 fs6 fc0 sc0 ls21 wsb">    //可以在这里定义私有变量和函数 </div><div class="t m0 x0 hb yc77 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 yc78 ff21 fs6 fc0 sc0 ls21 wsb">    //添加方法 </div><div class="t m0 x0 hb yc79 ff21 fs6 fc0 sc0 ls21 wsb">    o.sayName = function(){ </div><div class="t m0 x0 hb yc7a ff21 fs6 fc0 sc0 ls21 wsb">        alert(name); </div><div class="t m0 x0 hb yc7b ff21 fs6 fc0 sc0 ls21 wsb">    };     </div><div class="t m0 x0 hb yc7c ff21 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 h16 yc7d ff21 fs6 fc0 sc0 ls21 wsb">    //返回对象 </div><div class="t m0 x0 hb yc7e ff21 fs6 fc0 sc0 ls21 wsb">    return o; </div><div class="t m0 x0 hb yc7f ff21 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h4 yc80 ff20 fs2 fc0 sc0 ls8 wseb">注意，在以这种模式创建的对象中，除了使用sayName()方法之外，没有其他办法访问name的值。</div><div class="t m0 x0 hc yc81 ff20 fs2 fc0 sc0 ls8 wseb">可以像下面使用稳妥的Person构造函数。 </div><div class="t m0 x0 hb yc82 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yc83 ff21 fs6 fc0 sc0 ls21 wsb">var friend = Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;); </div><div class="t m0 x0 hb yc84 ff21 fs6 fc0 sc0 ls21 wsb">friend.sayName();  //&quot;Nicholas&quot; </div><div class="t m0 x0 hb yc85 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 yc86 ff20 fs2 fc0 sc0 ls8 wseb">这样，变量friend中保存的是一个稳妥对象，而除了调用sayName()方法外，没有别的方式可</div><div class="t m0 x0 h4 yc87 ff20 fs2 fc0 sc0 ls8 wseb">以访问其数据成员。即使有其他代码会给这个对象添加方法或数据成员，但也不可能有别的办法访问传</div><div class="t m0 x0 h4 yc88 ff20 fs2 fc0 sc0 ls8 wseb">入到构造函数中的原始数据。稳妥构造函数模式提供的这种安全性，使得它非常适合在某些安全执行环</div><div class="t m0 x0 h5 yc89 ff20 fs2 fc0 sc0 ls8 wseb">境——例如，ADsafe（www.adsafe.org）和Caja（http://code.google.com/p/google-caja/）提供的环境——</div><div class="t m0 x0 h5 yc8a ff20 fs2 fc0 sc0 ls8">下使用。 </div><div class="t m0 x5 ha yc8b ff1b fs2 fc0 sc0 ls8 ws14">与寄生构造函数模式类似，使用稳妥构造函数模式创建的对象与构造函数之间也</div><div class="t m0 x0 h67 yc8c ff1b fs2 fc0 sc0 ls8 ws14">没有什么关系，因此instanceof操作符对这种对象也没有意义。 </div><div class="t m0 x0 hd yc8d ff1e fs7 fc0 sc0 ls22">6.3 继承 </div><div class="t m0 x0 h5 yc8e ff20 fs2 fc0 sc0 ls8 wseb">继承是OO语言中的一个最为人津津乐道的概念。许多OO语言都支持两种继承方式：接口继承和</div><div class="t m0 x0 h4 yc8f ff20 fs2 fc0 sc0 ls8 wseb">实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。如前所述，由于函数没有签名，</div><div class="t m0 x0 h5 yc90 ff20 fs2 fc0 sc0 ls3b">在ECMAScript中无法实现接口继承。ECMAScript只支持实现继承，而且其实现继承主要是依靠原型链</div><div class="t m0 x0 h5 yc91 ff20 fs2 fc0 sc0 ls8 wseb">来实现的。 </div><div class="t m0 x0 h20 yc92 ff1e fs3 fc0 sc0 ls4d ws40">6.3.1 原型链 </div><div class="t m0 x0 h5 yc93 ff1a fs2 fc0 sc0 ls1a ws1c">ECMAScript中描述了原型链的概念，并将原型链作为实现继承的主要方法。其基本思想是利用原</div><div class="t m0 x0 h4 yc94 ff20 fs2 fc0 sc0 ls8 wseb">型让一个引用类型继承另一个引用类型的属性和方法。简单回顾一下构造函数、原型和实例的关系：每</div><div class="t m0 x0 h4 yc95 ff20 fs2 fc0 sc0 ls8 wseb">个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型</div><div class="t m0 x0 h4 yc96 ff20 fs2 fc0 sc0 ls8 wseb">对象的内部指针。那么，假如我们让原型对象等于另一个类型的实例，结果会怎么样呢？显然，此时的</div><div class="t m0 x0 h4 yc97 ff20 fs2 fc0 sc0 ls8 wseb">原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数</div><div class="t m0 x0 h4 yc98 ff20 fs2 fc0 sc0 ls8 wseb">的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实</div><div class="t m0 x0 h5 yc99 ff20 fs2 fc0 sc0 ls8 wseb">例与原型的链条。这就是所谓原型链的基本概念。 </div><div class="t m0 x0 h5 yc9a ff20 fs2 fc0 sc0 ls8 wseb">实现原型链有一种基本模式，其代码大致如下。 </div><div class="t m0 x0 hb yc9b ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yc9c ff21 fs6 fc0 sc0 ls21 wsb">function SuperType(){ </div><div class="t m0 x0 hb yc9d ff21 fs6 fc0 sc0 ls21 wsb">    this.property = true; </div><div class="t m0 x0 hb yc9e ff21 fs6 fc0 sc0 ls21 wsb">} </div></div></div>
<div id="pfb5" class="pf w0 h0" data-page-no="b5"><div class="pc pcb5 w0 h0"><div class="t m0 x2 h2 y1 ff1a fs0 fc0 sc0 ls10 wsc">6.3 继承  163 </div><div class="t m0 x0 h3 y2 ff1a fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff25 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff25 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff25 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff25 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff25 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff25 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff25 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff25 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff25 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff25 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff25 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff25 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff25 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb yad6 ff21 fs6 fc0 sc0 ls21 wsb">SuperType.prototype.getSuperValue = function(){ </div><div class="t m0 x0 hb yad7 ff21 fs6 fc0 sc0 ls21 wsb">    return this.property; </div><div class="t m0 x0 hb yad8 ff21 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb yad9 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yada ff21 fs6 fc0 sc0 ls21 wsb">function SubType(){ </div><div class="t m0 x0 hb yadb ff21 fs6 fc0 sc0 ls21 wsb">    this.subproperty = false; </div><div class="t m0 x0 hb yc9f ff21 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb yca0 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 yca1 ff21 fs6 fc0 sc0 ls21">//继承了SuperType </div><div class="t m0 x0 hb yca2 ff21 fs6 fc0 sc0 ls21 wsb">SubType.prototype = new SuperType(); </div><div class="t m0 x0 hb yca3 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yca4 ff21 fs6 fc0 sc0 ls21 wsb">SubType.prototype.getSubValue = function (){ </div><div class="t m0 x0 hb yca5 ff21 fs6 fc0 sc0 ls21 wsb">    return this.subproperty; </div><div class="t m0 x0 hb yca6 ff21 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb yca7 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yca8 ff21 fs6 fc0 sc0 ls21 wsb">var instance = new SubType(); </div><div class="t m0 x0 hb yca9 ff21 fs6 fc0 sc0 ls21 wsb">alert(instance.getSuperValue());      //true </div><div class="t m0 x0 hb ycaa ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf ycab ff22 fs2 fc0 sc0 ls2b wsb">PrototypeChainingExample01.htm </div><div class="t m0 x5 hb ycac ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 ycad ff20 fs2 fc0 sc0 ls8 wseb">以上代码定义了两个类型：SuperType和SubType。每个类型分别有一个属性和一个方法。它们</div><div class="t m0 x0 h1e ycae ff20 fs2 fc0 sc0 ls8 wseb">的主要区别是SubType继承了SuperType，而继承是通过创建SuperType 的实例，并将该实例赋给</div><div class="t m0 x0 h4 ycaf ff21 fs1 fc0 sc0 ls9 ws2">SubType.prototype实现的。实现的本质是重写原型对象，代之以一个新类型的实例。换句话说，原</div><div class="t m0 x0 h4 ycb0 ff20 fs2 fc0 sc0 ls5f ws10b">来存在于SuperType的实例中的所有属性和方法，现在也存在于SubType.prototype中了。在确立了</div><div class="t m0 x0 h1e ycb1 ff20 fs2 fc0 sc0 ls5f ws10b">继承关系之后，我们给SubType.prototype添加了一个方法，这样就在继承了SuperType的属性和方</div><div class="t m0 x0 h5 ycb2 ff20 fs2 fc0 sc0 ls5f ws10b">法的基础上又添加了一个新方法。这个例子中的实例以及构造函数和原型之间的关系如图6-4所示。 </div><div class="t m0 x6 h5 ycb3 ff1a fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 h3 y8bb ff20 fs1 fc0 sc0 ls8 wsb">图 6-4 </div><div class="t m0 x0 h4 ycb4 ff20 fs2 fc0 sc0 ls42 wsf0">在上面的代码中，我们没有使用SubType默认提供的原型，而是给它换了一个新原型；这个新原型</div><div class="t m0 x0 h1e ycb5 ff20 fs2 fc0 sc0 ls44 wsef">就是SuperType的实例。于是，新原型不仅具有作为一个SuperType的实例所拥有的全部属性和方法，</div><div class="t m0 x0 h1e ycb6 ff20 fs2 fc0 sc0 ls42 wsf0">而且其内部还有一个指针，指向了SuperType的原型。最终结果就是这样的：instance指向SubType</div><div class="t m0 x0 h4 ycb7 ff20 fs2 fc0 sc0 ls153 ws120">的原型，SubType的原型又指向 SuperType的原型。getSuperValue()方法仍然还在</div><div class="t m0 x0 h4 ycb8 ff21 fs1 fc0 sc0 ls43 ws31">SuperType.prototype中，但property则位于SubType.prototype 中。这是因为property是一</div><div class="t m0 x0 h1e ycb9 ff20 fs2 fc0 sc0 ls42 wsf0">个实例属性，而getSuperValue()则是一个原型方法。既然SubType.prototype现在是SuperType</div></div></div>
<div id="pfb6" class="pf w0 h0" data-page-no="b6"><div class="pc pcb6 w0 h0"><div class="t m0 x0 h2 y1 ff1a fs0 fc0 sc0 ls7 ws0">164  第6章 面向对象的程序设计 </div><div class="t m0 x0 h3 y2 ff1a fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ff20 fs2 fc0 sc0 ls42 wsf0">的实例，那么property当然就位于该实例中了。此外，要注意instance.constructor 现在指向的</div><div class="t m0 x0 h69 y4d ff20 fs2 fc0 sc0 ls154">是SuperType，这是因为原来SubType.prototype中的constructor被重写了的缘故①。 </div><div class="t m0 x0 h4 y5 ff20 fs2 fc0 sc0 ls8 wseb">通过实现原型链，本质上扩展了本章前面介绍的原型搜索机制。读者大概还记得，当以读取模式访</div><div class="t m0 x0 h4 y6 ff20 fs2 fc0 sc0 ls8 wseb">问一个实例属性时，首先会在实例中搜索该属性。如果没有找到该属性，则会继续搜索实例的原型。在</div><div class="t m0 x0 h4 y7 ff20 fs2 fc0 sc0 ls4">通过原型链实现继承的情况下，搜索过程就得以沿着原型链继续向上。就拿上面的例子来说，调用</div><div class="t m0 x0 h5 y8 ff21 fs1 fc0 sc0 ls16 ws17">instance.getSuperValue()会经历三个搜索步骤：1）搜索实例；2）搜索SubType.prototype；</div><div class="t m0 x0 h5 y15e ff1a fs2 fc0 sc0 ls14">3）搜索SuperType.prototype，最后一步才会找到该方法。在找不到属性或方法的情况下，搜索过</div><div class="t m0 x0 h5 y15f ff20 fs2 fc0 sc0 ls8 wseb">程总是要一环一环地前行到原型链末端才会停下来。 </div><div class="t m0 x0 h3c ycbb ff1e fs2 fc0 sc0 ls2e wsb">1. 别忘记默认的原型 </div><div class="t m0 x0 h4 ycbc ff20 fs2 fc0 sc0 ls8 wseb">事实上，前面例子中展示的原型链还少一环。我们知道，所有引用类型默认都继承了Object，而</div><div class="t m0 x0 h1e ycbd ff20 fs2 fc0 sc0 ls8 wseb">这个继承也是通过原型链实现的。大家要记住，所有函数的默认原型都是Object的实例，因此默认原</div><div class="t m0 x0 h1e ycbe ff20 fs2 fc0 sc0 ls8 wseb">型都会包含一个内部指针，指向Object.prototype。这也正是所有自定义类型都会继承toString()、</div><div class="t m0 x0 h4 ycbf ff21 fs1 fc0 sc0 ls9 ws2">valueOf()等默认方法的根本原因。所以，我们说上面例子展示的原型链中还应该包括另外一个继承层</div><div class="t m0 x0 h5 ycc0 ff20 fs2 fc0 sc0 ls8 wseb">次。图6-5为我们展示了该例子中完整的原型链。 </div><div class="t m0 x2 h5 ycc1 ff1a fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x7 h3 ycc2 ff20 fs1 fc0 sc0 ls8 wsb">图 6-5 </div><div class="t m0 x0 h4 ycc3 ff20 fs2 fc0 sc0 ls1f ws108">一句话，SubType继承了SuperType，而SuperType继承了Object。当调用instance.toString()</div><div class="t m0 x0 h5 y37d ff20 fs2 fc0 sc0 ls1f ws108">时，实际上调用的是保存在Object.prototype中的那个方法。 </div><div class="t m0 x0 h3c ycc4 ff1d fs2 fc0 sc0 ls7b wsb">—————————— </div><div class="t m0 x0 h36 ycc5 ff20 fs6 fc0 sc0 lsf6">① 实际上，不是SubType的原型的constructor 属性被重写了，而是SubType的原型指向了另一个对象——</div><div class="t m0 x0 h36 ycc6 ff21 fsc fc0 sc0 lsa8 ws80">SuperType的原型，而这个原型对象的constructor属性指向的是SuperType。 </div></div></div>
<div id="pfb7" class="pf w0 h0" data-page-no="b7"><div class="pc pcb7 w0 h0"><div class="t m0 x2 h2 y1 ff1a fs0 fc0 sc0 ls10 wsc">6.3 继承  165 </div><div class="t m0 x0 h3 y2 ff1a fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff25 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff25 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff25 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff25 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff25 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff25 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff25 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff25 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff25 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff25 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff25 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff25 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff25 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h3c y68b ff1e fs2 fc0 sc0 ls2e wsb">2. 确定原型和实例的关系 </div><div class="t m0 x0 h4 y68c ff20 fs2 fc0 sc0 ls8 wseb">可以通过两种方式来确定原型和实例之间的关系。第一种方式是使用instanceof操作符，只要用</div><div class="t m0 x0 h1e y68d ff20 fs2 fc0 sc0 ls8 wseb">这个操作符来测试实例与原型链中出现过的构造函数，结果就会返回true。以下几行代码就说明了这</div><div class="t m0 x0 h5 y68e ff20 fs2 fc0 sc0 ls8">一点。 </div><div class="t m0 x5 hb ycc7 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ycc8 ff21 fs6 fc0 sc0 ls21 wsb">alert(instance instanceof Object);         //true </div><div class="t m0 x0 hb ycc9 ff21 fs6 fc0 sc0 ls21 wsb">alert(instance instanceof SuperType);      //true </div><div class="t m0 x0 hb ycca ff21 fs6 fc0 sc0 ls21 wsb">alert(instance instanceof SubType);         //true </div><div class="t m0 x2 hf yccb ff22 fs2 fc0 sc0 ls2b wsb">PrototypeChainingExample01.htm </div><div class="t m0 x0 h4 yb ff20 fs2 fc0 sc0 ls8 wseb">由于原型链的关系，我们可以说instance是Object、SuperType或SubType中任何一个类型</div><div class="t m0 x0 h5 yccc ff20 fs2 fc0 sc0 ls8 wseb">的实例。因此，测试这三个构造函数的结果都返回了true。 </div><div class="t m0 x0 h1e yccd ff20 fs2 fc0 sc0 ls8 wseb">第二种方式是使用isPrototypeOf()方法。同样，只要是原型链中出现过的原型，都可以说是该</div><div class="t m0 x0 hc ycce ff20 fs2 fc0 sc0 ls8 wseb">原型链所派生的实例的原型，因此isPrototypeOf()方法也会返回true，如下所示。 </div><div class="t m0 x5 hb yccf ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ycd0 ff21 fs6 fc0 sc0 ls21 wsb">alert(Object.prototype.isPrototypeOf(instance));         //true </div><div class="t m0 x0 hb ycd1 ff21 fs6 fc0 sc0 ls21 wsb">alert(SuperType.prototype.isPrototypeOf(instance));      //true </div><div class="t m0 x0 hb ycd2 ff21 fs6 fc0 sc0 ls21 wsb">alert(SubType.prototype.isPrototypeOf(instance));        //true </div><div class="t m0 x0 hb ycd3 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf ycd4 ff22 fs2 fc0 sc0 ls2b wsb">PrototypeChainingExample01.htm </div><div class="t m0 x0 h3c ycd5 ff1e fs2 fc0 sc0 ls2e wsb">3. 谨慎地定义方法 </div><div class="t m0 x0 h4 ycd6 ff20 fs2 fc0 sc0 ls8 wseb">子类型有时候需要重写超类型中的某个方法，或者需要添加超类型中不存在的某个方法。但不管怎</div><div class="t m0 x0 h5 ycd7 ff20 fs2 fc0 sc0 ls8 wseb">样，给原型添加方法的代码一定要放在替换原型的语句之后。来看下面的例子。 </div><div class="t m0 x5 hb ycd8 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ycd9 ff21 fs6 fc0 sc0 ls21 wsb">function SuperType(){ </div><div class="t m0 x0 hb ycda ff21 fs6 fc0 sc0 ls21 wsb">    this.property = true; </div><div class="t m0 x0 hb ycdb ff21 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb ycdc ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ycdd ff21 fs6 fc0 sc0 ls21 wsb">SuperType.prototype.getSuperValue = function(){ </div><div class="t m0 x0 hb ycde ff21 fs6 fc0 sc0 ls21 wsb">    return this.property; </div><div class="t m0 x0 hb ycdf ff21 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb yce0 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yce1 ff21 fs6 fc0 sc0 ls21 wsb">function SubType(){ </div><div class="t m0 x0 hb yce2 ff21 fs6 fc0 sc0 ls21 wsb">    this.subproperty = false; </div><div class="t m0 x0 hb yce3 ff21 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb yce4 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 yce5 ff21 fs6 fc0 sc0 ls21">//继承了SuperType </div><div class="t m0 x0 hb yce6 ff21 fs6 fc0 sc0 ls21 wsb">SubType.prototype = new SuperType(); </div><div class="t m0 x0 hb yce7 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 yce8 ff27 fs6 fc0 sc0 ls21 ws34">//添加新方法 </div><div class="t m0 x0 h15 yce9 ff27 fs6 fc0 sc0 ls21 wsb">SubType.prototype.getSubValue = function (){ </div><div class="t m0 x0 h15 ycea ff27 fs6 fc0 sc0 ls21 wsb">    return this.subproperty; </div><div class="t m0 x0 h15 yceb ff27 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 h15 ycec ff27 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 yced ff27 fs6 fc0 sc0 ls21 ws34">//重写超类型中的方法 </div><div class="t m0 x0 h15 ycee ff27 fs6 fc0 sc0 ls21 wsb">SubType.prototype.getSuperValue = function (){ </div><div class="t m0 x0 h15 ycef ff27 fs6 fc0 sc0 ls21 wsb">    return false; </div><div class="t m0 x0 h15 ycf0 ff27 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb ycf1 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ycf2 ff21 fs6 fc0 sc0 ls21 wsb">var instance = new SubType(); </div><div class="t m0 x0 hb ycf3 ff21 fs6 fc0 sc0 ls21 wsb">alert(instance.getSuperValue());   //false </div><div class="t m0 x0 hb ycf4 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf yb6f ff22 fs2 fc0 sc0 ls2b wsb">PrototypeChainingExample02.htm </div></div></div>
<div id="pfb8" class="pf w0 h0" data-page-no="b8"><div class="pc pcb8 w0 h0"><div class="t m0 x0 h2 y1 ff1a fs0 fc0 sc0 ls7 ws0">166  第6章 面向对象的程序设计 </div><div class="t m0 x0 h3 y2 ff1a fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ff20 fs2 fc0 sc0 ls8 wseb">在以上代码中，加粗的部分是两个方法的定义。第一个方法getSubValue()被添加到了SubType</div><div class="t m0 x0 h4 y4 ff20 fs2 fc0 sc0 ls8 wseb">中。第二个方法getSuperValue()是原型链中已经存在的一个方法，但重写这个方法将会屏蔽原来的</div><div class="t m0 x0 h1e y5 ff20 fs2 fc0 sc0 ls8 wseb">那个方法。换句话说，当通过SubType的实例调用getSuperValue()时，调用的就是这个重新定义</div><div class="t m0 x0 h4 yd9 ff20 fs2 fc0 sc0 ls8 wseb">的方法；但通过SuperType的实例调用getSuperValue()时，还会继续调用原来的那个方法。这里</div><div class="t m0 x0 hc y15d ff20 fs2 fc0 sc0 ls8 wseb">要格外注意的是，必须在用SuperType的实例替换原型之后，再定义这两个方法。 </div><div class="t m0 x0 h4 y21a ff20 fs2 fc0 sc0 ls8 wseb">还有一点需要提醒读者，即在通过原型链实现继承时，不能使用对象字面量创建原型方法。因为这</div><div class="t m0 x0 h5 y5c8 ff20 fs2 fc0 sc0 ls8 wseb">样做就会重写原型链，如下面的例子所示。 </div><div class="t m0 x0 hb ycf5 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ycf6 ff21 fs6 fc0 sc0 ls21 wsb">function SuperType(){ </div><div class="t m0 x0 hb ycf7 ff21 fs6 fc0 sc0 ls21 wsb">    this.property = true; </div><div class="t m0 x0 hb ycf8 ff21 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb ycf9 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ycfa ff21 fs6 fc0 sc0 ls21 wsb">SuperType.prototype.getSuperValue = function(){ </div><div class="t m0 x0 hb ycfb ff21 fs6 fc0 sc0 ls21 wsb">    return this.property; </div><div class="t m0 x0 hb ycfc ff21 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb ycfd ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ycfe ff21 fs6 fc0 sc0 ls21 wsb">function SubType(){ </div><div class="t m0 x0 hb ycff ff21 fs6 fc0 sc0 ls21 wsb">    this.subproperty = false; </div><div class="t m0 x0 hb yd00 ff21 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb yd01 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 yd02 ff21 fs6 fc0 sc0 ls21">//继承了SuperType </div><div class="t m0 x0 hb yd03 ff21 fs6 fc0 sc0 ls21 wsb">SubType.prototype = new SuperType(); </div><div class="t m0 x0 hb yd04 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 yd05 ff27 fs6 fc0 sc0 ls21 ws34">//使用字面量添加新方法，会导致上一行代码无效 </div><div class="t m0 x0 h15 yd06 ff27 fs6 fc0 sc0 ls21 wsb">SubType.prototype = { </div><div class="t m0 x0 h15 yd07 ff27 fs6 fc0 sc0 ls21 wsb">    getSubValue : function (){ </div><div class="t m0 x0 h15 yd08 ff27 fs6 fc0 sc0 ls21 wsb">        return this.subproperty; </div><div class="t m0 x0 h15 yd09 ff27 fs6 fc0 sc0 ls21 wsb">    }, </div><div class="t m0 x0 h15 yd0a ff27 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 yd0b ff27 fs6 fc0 sc0 ls21 wsb">    someOtherMethod : function (){ </div><div class="t m0 x0 h15 yd0c ff27 fs6 fc0 sc0 ls21 wsb">        return false; </div><div class="t m0 x0 h15 yd0d ff27 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 h15 yd0e ff27 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb yd0f ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yd10 ff21 fs6 fc0 sc0 ls21 wsb">var instance = new SubType(); </div><div class="t m0 x0 h15 yd11 ff27 fs6 fc0 sc0 ls21 wsb">alert(instance.getSuperValue());   //error! </div><div class="t m0 x0 h15 yd12 ff27 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf yd13 ff22 fs2 fc0 sc0 ls2b wsb">PrototypeChainingExample03.htm </div><div class="t m0 x0 h4 yd14 ff20 fs2 fc0 sc0 ls8 wseb">以上代码展示了刚刚把SuperType的实例赋值给原型，紧接着又将原型替换成一个对象字面量而</div><div class="t m0 x0 h1e yd15 ff20 fs2 fc0 sc0 ls8 wseb">导致的问题。由于现在的原型包含的是一个Object的实例，而非SuperType的实例，因此我们设想</div><div class="t m0 x0 h5 yd16 ff20 fs2 fc0 sc0 ls8 wseb">中的原型链已经被切断——SubType和SuperType之间已经没有关系了。 </div><div class="t m0 x0 h3c yd17 ff1e fs2 fc0 sc0 ls2e wsb">4. 原型链的问题 </div><div class="t m0 x0 h4 yd18 ff20 fs2 fc0 sc0 ls8 wseb">原型链虽然很强大，可以用它来实现继承，但它也存在一些问题。其中，最主要的问题来自包含引</div><div class="t m0 x0 h4 yd19 ff20 fs2 fc0 sc0 ls8 wseb">用类型值的原型。想必大家还记得，我们前面介绍过包含引用类型值的原型属性会被所有实例共享；而</div><div class="t m0 x0 h4 yd1a ff20 fs2 fc0 sc0 ls8 wseb">这也正是为什么要在构造函数中，而不是在原型对象中定义属性的原因。在通过原型来实现继承时，原</div><div class="t m0 x0 h4 yd1b ff20 fs2 fc0 sc0 ls8 wseb">型实际上会变成另一个类型的实例。于是，原先的实例属性也就顺理成章地变成了现在的原型属性了。</div><div class="t m0 x0 h5 yd1c ff20 fs2 fc0 sc0 ls8 wseb">下列代码可以用来说明这个问题。 </div><div class="t m0 x0 hb yb3e ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yd1d ff21 fs6 fc0 sc0 ls21 wsb">function SuperType(){ </div><div class="t m0 x0 hb yd1e ff21 fs6 fc0 sc0 ls21 wsb">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; </div></div></div>
<div id="pfb9" class="pf w0 h0" data-page-no="b9"><div class="pc pcb9 w0 h0"><div class="t m0 x2 h2 y1 ff1a fs0 fc0 sc0 ls10 wsc">6.3 继承  167 </div><div class="t m0 x0 h3 y2 ff1a fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff25 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff25 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff25 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff25 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff25 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff25 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff25 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff25 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff25 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff25 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff25 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff25 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff25 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y79 ff21 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y7a ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y7b ff21 fs6 fc0 sc0 ls21 wsb">function SubType(){             </div><div class="t m0 x0 hb y7c ff21 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y7d ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y7e ff21 fs6 fc0 sc0 ls21">//继承了SuperType </div><div class="t m0 x0 hb y7f ff21 fs6 fc0 sc0 ls21 wsb">SubType.prototype = new SuperType(); </div><div class="t m0 x0 hb y80 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y81 ff21 fs6 fc0 sc0 ls21 wsb">var instance1 = new SubType(); </div><div class="t m0 x0 hb y82 ff21 fs6 fc0 sc0 ls21 wsb">instance1.colors.push(&quot;black&quot;); </div><div class="t m0 x0 hb y83 ff21 fs6 fc0 sc0 ls21 wsb">alert(instance1.colors);    //&quot;red,blue,green,black&quot; </div><div class="t m0 x0 hb y84 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y85 ff21 fs6 fc0 sc0 ls21 wsb">var instance2 = new SubType(); </div><div class="t m0 x0 hb y86 ff21 fs6 fc0 sc0 ls21 wsb">alert(instance2.colors);      //&quot;red,blue,green,black&quot; </div><div class="t m0 x0 hb yd1f ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf yd20 ff22 fs2 fc0 sc0 ls2b wsb">PrototypeChainingExample04.htm </div><div class="t m0 x0 h4 yd21 ff20 fs2 fc0 sc0 ls8 wseb">这个例子中的SuperType构造函数定义了一个colors属性，该属性包含一个数组（引用类型值）。</div><div class="t m0 x0 h4 y4ab ff21 fs1 fc0 sc0 ls9 ws2">SuperType的每个实例都会有各自包含自己数组的colors 属性。当SubType通过原型链继承了</div><div class="t m0 x0 h4 yd22 ff21 fs1 fc0 sc0 ls9 ws2">SuperType之后，SubType.prototype就变成了SuperType的一个实例，因此它也拥有了一个它自</div><div class="t m0 x0 h4 yd23 ff20 fs2 fc0 sc0 ls8 wseb">己的colors属性——就跟专门创建了一个SubType.prototype.colors 属性一样。但结果是什么</div><div class="t m0 x0 h1e yd24 ff20 fs2 fc0 sc0 ls8 wseb">呢？结果是SubType的所有实例都会共享这一个colors属性。而我们对instance1.colors的修改</div><div class="t m0 x0 hc yd25 ff20 fs2 fc0 sc0 ls8 wseb">能够通过instance2.colors反映出来，就已经充分证实了这一点。 </div><div class="t m0 x0 h4 yd26 ff20 fs2 fc0 sc0 ls8 wseb">原型链的第二个问题是：在创建子类型的实例时，不能向超类型的构造函数中传递参数。实际上，</div><div class="t m0 x0 h4 yd27 ff20 fs2 fc0 sc0 ls8 wseb">应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。有鉴于此，再加上</div><div class="t m0 x0 h5 yd28 ff20 fs2 fc0 sc0 ls8 wseb">前面刚刚讨论过的由于原型中包含引用类型值所带来的问题，实践中很少会单独使用原型链。 </div><div class="t m0 x0 h20 yd29 ff1e fs3 fc0 sc0 ls4d ws40">6.3.2 借用构造函数 </div><div class="t m0 x0 h4 yd2a ff20 fs2 fc0 sc0 ls4 ws10d">在解决原型中包含引用类型值所带来问题的过程中，开发人员开始使用一种叫做借用构造函数</div><div class="t m0 x0 h5 yd2b ff20 fs2 fc0 sc0 ls8">（constructor stealing）的技术（有时候也叫做伪造对象或经典继承）。这种技术的基本思想相当简单，即</div><div class="t m0 x0 h4 yd2c ff20 fs2 fc0 sc0 ls8 wseb">在子类型构造函数的内部调用超类型构造函数。别忘了，函数只不过是在特定环境中执行代码的对象，</div><div class="t m0 x0 he yd2d ff20 fs2 fc0 sc0 ls1f ws108">因此通过使用apply()和call()方法也可以在（将来）新创建的对象上执行构造函数，如下所示： </div><div class="t m0 x5 hb yd2e ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yd2f ff21 fs6 fc0 sc0 ls21 wsb">function SuperType(){ </div><div class="t m0 x0 hb yd30 ff21 fs6 fc0 sc0 ls21 wsb">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; </div><div class="t m0 x0 hb yd31 ff21 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb yd32 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yd33 ff21 fs6 fc0 sc0 ls21 wsb">function SubType(){   </div><div class="t m0 x0 h16 yd34 ff27 fs6 fc0 sc0 ls21 wsb">    //继承了SuperType </div><div class="t m0 x0 h15 yd35 ff27 fs6 fc0 sc0 ls21 wsb">    SuperType.call(this); </div><div class="t m0 x0 hb yd36 ff21 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb yd37 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yd38 ff21 fs6 fc0 sc0 ls21 wsb">var instance1 = new SubType(); </div><div class="t m0 x0 hb yd39 ff21 fs6 fc0 sc0 ls21 wsb">instance1.colors.push(&quot;black&quot;); </div><div class="t m0 x0 hb yd3a ff21 fs6 fc0 sc0 ls21 wsb">alert(instance1.colors);    //&quot;red,blue,green,black&quot; </div><div class="t m0 x0 hb yd3b ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yd3c ff21 fs6 fc0 sc0 ls21 wsb">var instance2 = new SubType(); </div><div class="t m0 x0 hb yd3d ff21 fs6 fc0 sc0 ls21 wsb">alert(instance2.colors);    //&quot;red,blue,green&quot; </div><div class="t m0 x0 hb yd3e ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf yd3f ff22 fs2 fc0 sc0 ls2b wsb">ConstructorStealingExample01.htm </div></div></div>
<div id="pfba" class="pf w0 h0" data-page-no="ba"><div class="pc pcba w0 h0"><div class="t m0 x0 h2 y1 ff1a fs0 fc0 sc0 ls7 ws0">168  第6章 面向对象的程序设计 </div><div class="t m0 x0 h3 y2 ff1a fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ff20 fs2 fc0 sc0 ls8 wseb">代码中加粗的那一行代码“借调”了超类型的构造函数。通过使用call()方法（或apply()方法</div><div class="t m0 x0 h1e y4d ff20 fs2 fc0 sc0 ls8 wseb">也可以），我们实际上是在（未来将要）新创建的SubType实例的环境下调用了SuperType构造函数。</div><div class="t m0 x0 h1e y5 ff20 fs2 fc0 sc0 ls8 wseb">这样一来，就会在新SubType对象上执行 SuperType()函数中定义的所有对象初始化代码。结果，</div><div class="t m0 x0 h5 yd9 ff21 fs1 fc0 sc0 ls9 ws2">SubType的每个实例就都会具有自己的colors属性的副本了。 </div><div class="t m0 x0 h3c yd41 ff1e fs2 fc0 sc0 ls2e wsb">1. 传递参数 </div><div class="t m0 x0 h4 yd42 ff20 fs2 fc0 sc0 ls8 wseb">相对于原型链而言，借用构造函数有一个很大的优势，即可以在子类型构造函数中向超类型构造函</div><div class="t m0 x0 h5 yd43 ff20 fs2 fc0 sc0 ls8 wseb">数传递参数。看下面这个例子。 </div><div class="t m0 x0 hb yd44 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yd45 ff21 fs6 fc0 sc0 ls21 wsb">function SuperType(name){ </div><div class="t m0 x0 hb yd46 ff21 fs6 fc0 sc0 ls21 wsb">    this.name = name; </div><div class="t m0 x0 hb yd47 ff21 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb yd48 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yd49 ff21 fs6 fc0 sc0 ls21 wsb">function SubType(){   </div><div class="t m0 x0 h16 yd4a ff21 fs6 fc0 sc0 ls21 wsb">    //继承了SuperType，同时还传递了参数 </div><div class="t m0 x0 hb yd4b ff21 fs6 fc0 sc0 ls21 wsb">    SuperType.call(this, &quot;Nicholas&quot;); </div><div class="t m0 x0 hb yd4c ff21 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 h16 yd4d ff21 fs6 fc0 sc0 ls21 wsb">    //实例属性 </div><div class="t m0 x0 hb yd4e ff21 fs6 fc0 sc0 ls21 wsb">    this.age = 29; </div><div class="t m0 x0 hb yd4f ff21 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb yd50 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yd51 ff21 fs6 fc0 sc0 ls21 wsb">var instance = new SubType(); </div><div class="t m0 x0 hb yd52 ff21 fs6 fc0 sc0 ls21 wsb">alert(instance.name);    //&quot;Nicholas&quot;; </div><div class="t m0 x0 hb yd53 ff21 fs6 fc0 sc0 ls21 wsb">alert(instance.age);     //29 </div><div class="t m0 x0 hb yd54 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf yd55 ff22 fs2 fc0 sc0 ls2b wsb">ConstructorStealingExample02.htm </div><div class="t m0 x0 h4 yd56 ff20 fs2 fc0 sc0 ls8 wseb">以上代码中的SuperType只接受一个参数name，该参数会直接赋给一个属性。在SubType 构造</div><div class="t m0 x0 h1e yd57 ff20 fs2 fc0 sc0 ls6 wsf7">函数内部调用SuperType构造函数时，实际上是为 SubType的实例设置了name 属性。为了确保</div><div class="t m0 x0 h4 y55d ff21 fs1 fc0 sc0 ls9 ws2">SuperType构造函数不会重写子类型的属性，可以在调用超类型构造函数后，再添加应该在子类型中</div><div class="t m0 x0 h5 y729 ff20 fs2 fc0 sc0 ls8 wseb">定义的属性。 </div><div class="t m0 x0 h3c y72a ff1e fs2 fc0 sc0 ls2e wsb">2. 借用构造函数的问题 </div><div class="t m0 x0 h4 yd58 ff20 fs2 fc0 sc0 ls8 wseb">如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题——方法都在构造函数中定</div><div class="t m0 x0 h4 yd59 ff20 fs2 fc0 sc0 ls1f ws108">义，因此函数复用就无从谈起了。而且，在超类型的原型中定义的方法，对子类型而言也是不可见的，结</div><div class="t m0 x0 h5 yd5a ff20 fs2 fc0 sc0 ls1f">果所有类型都只能使用构造函数模式。考虑到这些问题，借用构造函数的技术也是很少单独使用的。 </div><div class="t m0 x0 h20 yd5b ff1e fs3 fc0 sc0 ls4d ws40">6.3.3 组合继承 </div><div class="t m0 x0 h5 yd5c ff20 fs2 fc0 sc0 ls8 wseb">组合继承（combination inheritance），有时候也叫做伪经典继承，指的是将原型链和借用构造函数的</div><div class="t m0 x0 h4 yd5d ff20 fs2 fc0 sc0 ls8 wseb">技术组合到一块，从而发挥二者之长的一种继承模式。其背后的思路是使用原型链实现对原型属性和方</div><div class="t m0 x0 h4 yd5e ff20 fs2 fc0 sc0 ls8 wseb">法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数</div><div class="t m0 x0 h5 yd5f ff20 fs2 fc0 sc0 ls8 wseb">复用，又能够保证每个实例都有它自己的属性。下面来看一个例子。 </div><div class="t m0 x0 hb yd60 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yd61 ff21 fs6 fc0 sc0 ls21 wsb">function SuperType(name){ </div><div class="t m0 x0 hb yd62 ff21 fs6 fc0 sc0 ls21 wsb">    this.name = name; </div><div class="t m0 x0 hb yd63 ff21 fs6 fc0 sc0 ls21 wsb">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; </div><div class="t m0 x0 hb yd64 ff21 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb yd65 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yd66 ff21 fs6 fc0 sc0 ls21 wsb">SuperType.prototype.sayName = function(){ </div><div class="t m0 x0 hb yd67 ff21 fs6 fc0 sc0 ls21 wsb">    alert(this.name); </div></div></div>
<div id="pfbb" class="pf w0 h0" data-page-no="bb"><div class="pc pcbb w0 h0"><div class="t m0 x2 h2 y1 ff1a fs0 fc0 sc0 ls10 wsc">6.3 继承  169 </div><div class="t m0 x0 h3 y2 ff1a fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff25 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff25 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff25 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff25 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff25 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff25 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff25 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff25 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff25 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff25 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff25 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff25 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff25 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y79 ff21 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb yd68 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yd69 ff21 fs6 fc0 sc0 ls21 wsb">function SubType(name, age){   </div><div class="t m0 x0 hb yd6a ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 yd6b ff21 fs6 fc0 sc0 ls21 wsb">    //继承属性 </div><div class="t m0 x0 hb yd6c ff21 fs6 fc0 sc0 ls21 wsb">    SuperType.call(this, name); </div><div class="t m0 x0 hb yd6d ff21 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 hb yd6e ff21 fs6 fc0 sc0 ls21 wsb">    this.age = age; </div><div class="t m0 x0 hb yd6f ff21 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb yd70 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 yd71 ff21 fs6 fc0 sc0 ls21">//继承方法 </div><div class="t m0 x0 hb yd72 ff21 fs6 fc0 sc0 ls21 wsb">SubType.prototype = new SuperType(); </div><div class="t m0 x0 hb yd73 ff21 fs6 fc0 sc0 ls21 wsb">SubType.prototype.constructor = SubType; </div><div class="t m0 x0 hb yd74 ff21 fs6 fc0 sc0 ls21 wsb">SubType.prototype.sayAge = function(){ </div><div class="t m0 x0 hb yd75 ff21 fs6 fc0 sc0 ls21 wsb">    alert(this.age); </div><div class="t m0 x0 hb yd76 ff21 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb yd77 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yd78 ff21 fs6 fc0 sc0 ls21 wsb">var instance1 = new SubType(&quot;Nicholas&quot;, 29); </div><div class="t m0 x0 hb yd79 ff21 fs6 fc0 sc0 ls21 wsb">instance1.colors.push(&quot;black&quot;); </div><div class="t m0 x0 hb yd7a ff21 fs6 fc0 sc0 ls21 wsb">alert(instance1.colors);      //&quot;red,blue,green,black&quot; </div><div class="t m0 x0 hb yd7b ff21 fs6 fc0 sc0 ls21 wsb">instance1.sayName();          //&quot;Nicholas&quot;; </div><div class="t m0 x0 hb yd7c ff21 fs6 fc0 sc0 ls21 wsb">instance1.sayAge();           //29 </div><div class="t m0 x0 hb yd7d ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yd7e ff21 fs6 fc0 sc0 ls21 wsb">var instance2 = new SubType(&quot;Greg&quot;, 27); </div><div class="t m0 x0 hb yd7f ff21 fs6 fc0 sc0 ls21 wsb">alert(instance2.colors);      //&quot;red,blue,green&quot; </div><div class="t m0 x0 hb yd80 ff21 fs6 fc0 sc0 ls21 wsb">instance2.sayName();          //&quot;Greg&quot;; </div><div class="t m0 x0 hb yd81 ff21 fs6 fc0 sc0 ls21 wsb">instance2.sayAge();           //27 </div><div class="t m0 x5 hb yd82 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf y2ee ff22 fs2 fc0 sc0 ls25 wsb">CombinationInheritanceExample01.htm </div><div class="t m0 x0 h4 y629 ff20 fs2 fc0 sc0 ls8 wseb">在这个例子中，SuperType构造函数定义了两个属性：name和colors。SuperType的原型定义</div><div class="t m0 x0 h4 y9cd ff20 fs2 fc0 sc0 ls8 wseb">了一个方法sayName()。SubType构造函数在调用SuperType构造函数时传入了name 参数，紧接着</div><div class="t m0 x0 h1e yd83 ff20 fs2 fc0 sc0 ls8 wseb">又定义了它自己的属性age。然后，将SuperType的实例赋值给SubType的原型，然后又在该新原型</div><div class="t m0 x0 h1e yd84 ff20 fs2 fc0 sc0 ls8 wseb">上定义了方法sayAge()。这样一来，就可以让两个不同的SubType实例既分别拥有自己属性——包</div><div class="t m0 x0 hc yd85 ff20 fs2 fc0 sc0 ls15a">括colors属性，又可以使用相同的方法了。 </div><div class="t m0 x0 h5 yd86 ff20 fs2 fc0 sc0 ls8 wseb">组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为JavaScript中最常用的继</div><div class="t m0 x0 hc yd87 ff20 fs2 fc0 sc0 ls8 wseb">承模式。而且，instanceof和isPrototypeOf()也能够用于识别基于组合继承创建的对象。 </div><div class="t m0 x0 h20 yd88 ff1e fs3 fc0 sc0 ls4d ws40">6.3.4 原型式继承 </div><div class="t m0 x0 h5 yd89 ff20 fs2 fc0 sc0 ls8 wseb">道格拉斯·克罗克福德在2006年写了一篇文章，题为Prototypal Inheritance in JavaScript （JavaScript</div><div class="t m0 x0 h4 yd8a ff20 fs2 fc0 sc0 ls6 wsf7">中的原型式继承）。在这篇文章中，他介绍了一种实现继承的方法，这种方法并没有使用严格意义上的</div><div class="t m0 x0 h4 yd8b ff20 fs2 fc0 sc0 ls8 wseb">构造函数。他的想法是借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。为</div><div class="t m0 x0 h5 yd8c ff20 fs2 fc0 sc0 ls8 wseb">了达到这个目的，他给出了如下函数。 </div><div class="t m0 x0 hb y1c6 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yd8d ff21 fs6 fc0 sc0 ls21 wsb">function object(o){ </div><div class="t m0 x0 hb yd8e ff21 fs6 fc0 sc0 ls21 wsb">    function F(){} </div><div class="t m0 x0 hb yd8f ff21 fs6 fc0 sc0 ls21 wsb">    F.prototype = o; </div><div class="t m0 x0 hb yd90 ff21 fs6 fc0 sc0 ls21 wsb">    return new F(); </div><div class="t m0 x0 hb yd91 ff21 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb yd92 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 yd93 ff20 fs2 fc0 sc0 ls2c">在object()函数内部，先创建了一个临时性的构造函数，然后将传入的对象作为这个构造函数的</div><div class="t m0 x0 h1e yd94 ff20 fs2 fc0 sc0 ls6 wsf7">原型，最后返回了这个临时类型的一个新实例。从本质上讲，object()对传入其中的对象执行了一次</div></div></div>
<div id="pfbc" class="pf w0 h0" data-page-no="bc"><div class="pc pcbc w0 h0"><div class="t m0 x0 h2 y1 ff1a fs0 fc0 sc0 ls7 ws0">170  第6章 面向对象的程序设计 </div><div class="t m0 x0 h3 y2 ff1a fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff20 fs2 fc0 sc0 ls8 wseb">浅复制。来看下面的例子。 </div><div class="t m0 x0 hb yd96 ff21 fs6 fc0 sc0 ls21 wsb">var person = { </div><div class="t m0 x0 hb yd97 ff21 fs6 fc0 sc0 ls21 wsb">    name: &quot;Nicholas&quot;, </div><div class="t m0 x0 hb yd98 ff21 fs6 fc0 sc0 ls21 wsb">    friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;] </div><div class="t m0 x0 hb yd99 ff21 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb yd9a ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yd9b ff21 fs6 fc0 sc0 ls21 wsb">var anotherPerson = object(person); </div><div class="t m0 x0 hb yd9c ff21 fs6 fc0 sc0 ls21 wsb">anotherPerson.name = &quot;Greg&quot;; </div><div class="t m0 x0 hb yd9d ff21 fs6 fc0 sc0 ls21 wsb">anotherPerson.friends.push(&quot;Rob&quot;); </div><div class="t m0 x0 hb yd9e ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yd9f ff21 fs6 fc0 sc0 ls21 wsb">var yetAnotherPerson = object(person); </div><div class="t m0 x0 hb yda0 ff21 fs6 fc0 sc0 ls21 wsb">yetAnotherPerson.name = &quot;Linda&quot;; </div><div class="t m0 x0 hb yda1 ff21 fs6 fc0 sc0 ls21 wsb">yetAnotherPerson.friends.push(&quot;Barbie&quot;); </div><div class="t m0 x0 hb yda2 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yda3 ff21 fs6 fc0 sc0 ls21 wsb">alert(person.friends);   //&quot;Shelby,Court,Van,Rob,Barbie&quot; </div><div class="t m0 x0 hb yda4 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf y4a9 ff22 fs2 fc0 sc0 ls2f wsb">PrototypalInheritanceExample01.htm </div><div class="t m0 x0 h4 yda5 ff20 fs2 fc0 sc0 ls1f ws108">克罗克福德主张的这种原型式继承，要求你必须有一个对象可以作为另一个对象的基础。如果有这么</div><div class="t m0 x0 h1e yda6 ff20 fs2 fc0 sc0 ls1f ws108">一个对象的话，可以把它传递给object()函数，然后再根据具体需求对得到的对象加以修改即可。在这</div><div class="t m0 x0 h4 yda7 ff20 fs2 fc0 sc0 ls1f ws108">个例子中，可以作为另一个对象基础的是person对象，于是我们把它传入到object()函数中，然后该</div><div class="t m0 x0 h1e yda8 ff20 fs2 fc0 sc0 ls1f ws108">函数就会返回一个新对象。这个新对象将person作为原型，所以它的原型中就包含一个基本类型值属性</div><div class="t m0 x0 h1e yda9 ff20 fs2 fc0 sc0 ls1f ws108">和一个引用类型值属性。这意味着person.friends不仅属于person所有，而且也会被anotherPerson</div><div class="t m0 x0 h5 ydaa ff20 fs2 fc0 sc0 ls1f ws108">以及yetAnotherPerson共享。实际上，这就相当于又创建了person对象的两个副本。 </div><div class="t m0 x0 h5 ydab ff1a fs2 fc0 sc0 ls25 ws57">ECMAScript 5通过新增Object.create()方法规范化了原型式继承。这个方法接收两个参数：一</div><div class="t m0 x0 h4 ydac ff20 fs2 fc0 sc0 ls8 wseb">个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。在传入一个参数的情况下，</div><div class="t m0 x0 h5 y2f1 ff21 fs1 fc0 sc0 ls9 ws2">Object.create()与object()方法的行为相同。 </div><div class="t m0 x0 hb ydad ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ydae ff21 fs6 fc0 sc0 ls21 wsb">var person = { </div><div class="t m0 x0 hb ydaf ff27 fs6 fc0 sc0 ls21 wsb">    name: &quot;Nicholas&quot;, </div><div class="t m0 x0 hb ydb0 ff27 fs6 fc0 sc0 ls21 wsb">    friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;] </div><div class="t m0 x0 hb ydb1 ff21 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 h15 ydb2 ff27 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 ydb3 ff27 fs6 fc0 sc0 ls21 wsb">var anotherPerson = Object.create(person); </div><div class="t m0 x0 hb ydb4 ff21 fs6 fc0 sc0 ls21 wsb">anotherPerson.name = &quot;Greg&quot;; </div><div class="t m0 x0 hb ydb5 ff21 fs6 fc0 sc0 ls21 wsb">anotherPerson.friends.push(&quot;Rob&quot;); </div><div class="t m0 x0 h15 ydb6 ff27 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 h15 ydb7 ff27 fs6 fc0 sc0 ls21 wsb">var yetAnotherPerson = Object.create(person); </div><div class="t m0 x0 hb ydb8 ff21 fs6 fc0 sc0 ls21 wsb">yetAnotherPerson.name = &quot;Linda&quot;; </div><div class="t m0 x0 hb ydb9 ff21 fs6 fc0 sc0 ls21 wsb">yetAnotherPerson.friends.push(&quot;Barbie&quot;); </div><div class="t m0 x0 hb ydba ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ydbb ff21 fs6 fc0 sc0 ls21 wsb">alert(person.friends); //&quot;Shelby,Court,Van,Rob,Barbie&quot; </div><div class="t m0 x0 hb ydbc ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf ydbd ff22 fs2 fc0 sc0 ls2f wsb">PrototypalInheritanceExample02.htm </div><div class="t m0 x0 h4 ydbe ff21 fs1 fc0 sc0 ls9 ws2">Object.create()方法的第二个参数与Object.defineProperties()方法的第二个参数格式相</div><div class="t m0 x0 h4 ydbf ff20 fs2 fc0 sc0 ls8 wseb">同：每个属性都是通过自己的描述符定义的。以这种方式指定的任何属性都会覆盖原型对象上的同名属</div><div class="t m0 x0 h5 ydc0 ff20 fs2 fc0 sc0 ls8 wseb">性。例如： </div><div class="t m0 x0 hb ydc1 ff21 fs6 fc0 sc0 ls21 wsb">var person = { </div><div class="t m0 x0 hb ydc2 ff21 fs6 fc0 sc0 ls21 wsb">    name: &quot;Nicholas&quot;, </div><div class="t m0 x0 hb ydc3 ff21 fs6 fc0 sc0 ls21 wsb">    friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;] </div><div class="t m0 x0 hb ydc4 ff21 fs6 fc0 sc0 ls21 wsb">}; </div></div></div>
<div id="pfbd" class="pf w0 h0" data-page-no="bd"><div class="pc pcbd w0 h0"><div class="t m0 x2 h2 y1 ff1a fs0 fc0 sc0 ls10 wsc">6.3 继承  171 </div><div class="t m0 x0 h3 y2 ff1a fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff25 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff25 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff25 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff25 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff25 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff25 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff25 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff25 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff25 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff25 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff25 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff25 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff25 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h15 y79 ff27 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y7a ff27 fs6 fc0 sc0 ls21 wsb">var anotherPerson = Object.create(person, { </div><div class="t m0 x0 hb y7b ff21 fs6 fc0 sc0 ls21 wsb">    name: { </div><div class="t m0 x0 hb y7c ff21 fs6 fc0 sc0 ls21 wsb">        value: &quot;Greg&quot; </div><div class="t m0 x0 hb y7d ff21 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y7e ff27 fs6 fc0 sc0 ls21">}); </div><div class="t m0 x0 hb y7f ff21 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 hb y80 ff21 fs6 fc0 sc0 ls21 wsb">alert(anotherPerson.name); //&quot;Greg&quot; </div><div class="t m0 x0 hb ydc6 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf ydc7 ff22 fs2 fc0 sc0 ls2f wsb">PrototypalInheritanceExample03.htm </div><div class="t m0 x0 h5 ydc8 ff20 fs2 fc0 sc0 ls8 wseb">支持Object.create()方法的浏览器有IE9+、Firefox 4+、Safari 5+、Opera 12+和Chrome。 </div><div class="t m0 x0 h4 ydc9 ff20 fs2 fc0 sc0 ls8 wseb">在没有必要兴师动众地创建构造函数，而只想让一个对象与另一个对象保持类似的情况下，原型式</div><div class="t m0 x0 h4 ydca ff20 fs2 fc0 sc0 ls8 wseb">继承是完全可以胜任的。不过别忘了，包含引用类型值的属性始终都会共享相应的值，就像使用原型模</div><div class="t m0 x0 h5 ydcb ff20 fs2 fc0 sc0 ls8">式一样。 </div><div class="t m0 x0 h20 ydcc ff1e fs3 fc0 sc0 ls4d ws40">6.3.5 寄生式继承 </div><div class="t m0 x0 h5 ydcd ff20 fs2 fc0 sc0 ls5">寄生式（parasitic）继承是与原型式继承紧密相关的一种思路，并且同样也是由克罗克福德推而广</div><div class="t m0 x0 h4 ydce ff20 fs2 fc0 sc0 ls8 wseb">之的。寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该</div><div class="t m0 x0 h4 ydcf ff20 fs2 fc0 sc0 ls8 wseb">函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。以下代码示范了寄</div><div class="t m0 x0 h5 ydd0 ff20 fs2 fc0 sc0 ls8 wseb">生式继承模式。 </div><div class="t m0 x5 hb ydd1 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ydd2 ff21 fs6 fc0 sc0 ls21 wsb">function createAnother(original){ </div><div class="t m0 x0 h16 ydd3 ff21 fs6 fc0 sc0 ls21 wsb">    var clone = object(original);  //通过调用函数创建一个新对象 </div><div class="t m0 x0 h16 ydd4 ff21 fs6 fc0 sc0 ls21 wsb">    clone.sayHi = function(){      //以某种方式来增强这个对象 </div><div class="t m0 x0 hb ydd5 ff21 fs6 fc0 sc0 ls21 wsb">        alert(&quot;hi&quot;); </div><div class="t m0 x0 hb ydd6 ff21 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 h16 ydd7 ff21 fs6 fc0 sc0 ls21 wsb">    return clone;         //返回这个对象 </div><div class="t m0 x0 hb ydd8 ff21 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h4 ydd9 ff20 fs2 fc0 sc0 ls6 wsf7">在这个例子中，createAnother()函数接收了一个参数，也就是将要作为新对象基础的对象。然</div><div class="t m0 x0 h1e ydda ff20 fs2 fc0 sc0 ls8 wseb">后，把这个对象（original）传递给object()函数，将返回的结果赋值给clone。再为clone对象</div><div class="t m0 x0 h5 yddb ff20 fs2 fc0 sc0 ls8 wseb">添加一个新方法sayHi()，最后返回clone对象。可以像下面这样来使用createAnother()函数： </div><div class="t m0 x5 hb y440 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yddc ff21 fs6 fc0 sc0 ls21 wsb">var person = { </div><div class="t m0 x0 hb yddd ff21 fs6 fc0 sc0 ls21 wsb">    name: &quot;Nicholas&quot;, </div><div class="t m0 x0 hb ydde ff21 fs6 fc0 sc0 ls21 wsb">    friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;] </div><div class="t m0 x0 hb yddf ff21 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb yde0 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yde1 ff21 fs6 fc0 sc0 ls21 wsb">var anotherPerson = createAnother(person); </div><div class="t m0 x0 hb yde2 ff21 fs6 fc0 sc0 ls21 wsb">anotherPerson.sayHi(); //&quot;hi&quot; </div><div class="t m0 x5 hb yde3 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y88e ff20 fs2 fc0 sc0 ls8 wseb">这个例子中的代码基于person返回了一个新对象——anotherPerson。新对象不仅具有person</div><div class="t m0 x0 h5 y785 ff20 fs2 fc0 sc0 ls8 wseb">的所有属性和方法，而且还有自己的sayHi()方法。 </div><div class="t m0 x0 h4 yde4 ff20 fs2 fc0 sc0 ls8 wseb">在主要考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。前面示</div><div class="t m0 x0 hc yde5 ff20 fs2 fc0 sc0 ls8 wseb">范继承模式时使用的object()函数不是必需的；任何能够返回新对象的函数都适用于此模式。 </div><div class="t m0 x5 ha yde6 ff1b fs2 fc0 sc0 ls8 ws14">使用寄生式继承来为对象添加函数，会由于不能做到函数复用而降低效率；这一</div><div class="t m0 x5 h5 yde7 ff1b fs2 fc0 sc0 ls8 ws14">点与构造函数模式类似。 </div></div></div>
<div id="pfbe" class="pf w0 h0" data-page-no="be"><div class="pc pcbe w0 h0"><div class="t m0 x0 h2 y1 ff1a fs0 fc0 sc0 ls7 ws0">172  第6章 面向对象的程序设计 </div><div class="t m0 x0 h3 y2 ff1a fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h20 y12d ff1e fs3 fc0 sc0 ls4d ws40">6.3.6 寄生组合式继承 </div><div class="t m0 x0 h5 y12e ff20 fs2 fc0 sc0 ls8 wseb">前面说过，组合继承是JavaScript最常用的继承模式；不过，它也有自己的不足。组合继承最大的</div><div class="t m0 x0 h4 y12f ff20 fs2 fc0 sc0 ls8 wseb">问题就是无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是</div><div class="t m0 x0 h4 y130 ff20 fs2 fc0 sc0 ls8 wseb">在子类型构造函数内部。没错，子类型最终会包含超类型对象的全部实例属性，但我们不得不在调用子</div><div class="t m0 x0 h5 yc0a ff20 fs2 fc0 sc0 ls8 wseb">类型构造函数时重写这些属性。再来看一看下面组合继承的例子。 </div><div class="t m0 x0 hb y132 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yde8 ff21 fs6 fc0 sc0 ls21 wsb">function SuperType(name){ </div><div class="t m0 x0 hb yde9 ff21 fs6 fc0 sc0 ls21 wsb">    this.name = name; </div><div class="t m0 x0 hb ydea ff21 fs6 fc0 sc0 ls21 wsb">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; </div><div class="t m0 x0 hb ydeb ff21 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb ydec ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yded ff21 fs6 fc0 sc0 ls21 wsb">SuperType.prototype.sayName = function(){ </div><div class="t m0 x0 hb ydee ff21 fs6 fc0 sc0 ls21 wsb">    alert(this.name); </div><div class="t m0 x0 hb ydef ff21 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb ydf0 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ydf1 ff21 fs6 fc0 sc0 ls21 wsb">function SubType(name, age){   </div><div class="t m0 x0 h16 ydf2 ff27 fs6 fc0 sc0 ls21 wsb">    SuperType.call(this, name);         //第二次调用SuperType() </div><div class="t m0 x0 hb ydf3 ff21 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 hb ydf4 ff21 fs6 fc0 sc0 ls21 wsb">    this.age = age; </div><div class="t m0 x0 hb ydf5 ff21 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb ydf6 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 ydf7 ff27 fs6 fc0 sc0 ls21 wsb">SubType.prototype = new SuperType();    //第一次调用SuperType() </div><div class="t m0 x0 hb ydf8 ff21 fs6 fc0 sc0 ls21 wsb">SubType.prototype.constructor = SubType; </div><div class="t m0 x0 hb ydf9 ff21 fs6 fc0 sc0 ls21 wsb">SubType.prototype.sayAge = function(){ </div><div class="t m0 x0 hb ydfa ff21 fs6 fc0 sc0 ls21 wsb">    alert(this.age); </div><div class="t m0 x0 hb ydfb ff21 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb ydfc ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 ydfd ff20 fs2 fc0 sc0 ls5 wsec">加粗字体的行中是调用SuperType构造函数的代码。在第一次调用 SuperType构造函数时， </div><div class="t m0 x0 h4 ydfe ff21 fs1 fc0 sc0 ls9 ws2">SubType.prototype会得到两个属性：name和colors；它们都是SuperType的实例属性，只不过</div><div class="t m0 x0 h4 ydff ff20 fs2 fc0 sc0 ls8 wseb">现在位于SubType的原型中。当调用SubType构造函数时，又会调用一次 SuperType构造函数，这</div><div class="t m0 x0 h1e ye00 ff20 fs2 fc0 sc0 ls8 wseb">一次又在新对象上创建了实例属性name和colors。于是，这两个属性就屏蔽了原型中的两个同名属</div><div class="t m0 x0 h5 ye01 ff20 fs2 fc0 sc0 ls8 wseb">性。图6-6展示了上述过程。 </div><div class="t m0 x0 h5 ye02 ff20 fs2 fc0 sc0 ls8 wseb">如图6-6所示，有两组name和colors属性：一组在实例上，一组在 SubType原型中。这就是调</div><div class="t m0 x0 h5 ye03 ff20 fs2 fc0 sc0 ls8 wseb">用两次SuperType构造函数的结果。好在我们已经找到了解决这个问题方法——寄生组合式继承。 </div><div class="t m0 x0 h4 ye04 ff20 fs2 fc0 sc0 ls8 wseb">所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。其背</div><div class="t m0 x0 h4 ye05 ff20 fs2 fc0 sc0 ls8 wseb">后的基本思路是：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型</div><div class="t m0 x0 h4 ye06 ff20 fs2 fc0 sc0 ls8 wseb">原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型</div><div class="t m0 x0 h5 ye07 ff20 fs2 fc0 sc0 ls8 wseb">的原型。寄生组合式继承的基本模式如下所示。 </div><div class="t m0 x0 hb ye08 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ye09 ff21 fs6 fc0 sc0 ls21 wsb">function inheritPrototype(subType, superType){ </div><div class="t m0 x0 h16 ye0a ff21 fs6 fc0 sc0 ls21 wsb">    var prototype = object(superType.prototype);     //创建对象 </div><div class="t m0 x0 h16 ye0b ff21 fs6 fc0 sc0 ls21 wsb">    prototype.constructor = subType;               //增强对象 </div><div class="t m0 x0 h16 ye0c ff21 fs6 fc0 sc0 ls21 wsb">    subType.prototype = prototype;                //指定对象 </div><div class="t m0 x0 hb ye0d ff21 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb ye0e ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 ye0f ff20 fs2 fc0 sc0 ls8 wseb">这个示例中的inheritPrototype()函数实现了寄生组合式继承的最简单形式。这个函数接收两</div><div class="t m0 x0 h4 ye10 ff20 fs2 fc0 sc0 ls8 wseb">个参数：子类型构造函数和超类型构造函数。在函数内部，第一步是创建超类型原型的一个副本。第二</div><div class="t m0 x0 h1e ye11 ff20 fs2 fc0 sc0 ls8 wseb">步是为创建的副本添加constructor属性，从而弥补因重写原型而失去的默认的constructor属性。</div><div class="t m0 x0 h4 ye12 ff20 fs2 fc0 sc0 ls4 ws10d">最后一步，将新创建的对象（即副本）赋值给子类型的原型。这样，我们就可以用调用inherit- </div><div class="t m0 x0 h6d ye13 ff21 fs1 fc0 sc0 ls9 ws2">Prototype()函数的语句，去替换前面例子中为子类型原型赋值的语句了，例如： </div></div></div>
<div id="pfbf" class="pf w0 h0" data-page-no="bf"><div class="pc pcbf w0 h0"><div class="t m0 x2 h2 y1 ff1a fs0 fc0 sc0 ls10 wsc">6.3 继承  173 </div><div class="t m0 x0 h3 y2 ff1a fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff25 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff25 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff25 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff25 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff25 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff25 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff25 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff25 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff25 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff25 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff25 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff25 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff25 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y79 ff21 fs6 fc0 sc0 ls21 wsb">function SuperType(name){ </div><div class="t m0 x0 hb y7a ff21 fs6 fc0 sc0 ls21 wsb">    this.name = name; </div><div class="t m0 x0 hb y7b ff21 fs6 fc0 sc0 ls21 wsb">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; </div><div class="t m0 x0 hb y7c ff21 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb ye14 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yd6c ff21 fs6 fc0 sc0 ls21 wsb">SuperType.prototype.sayName = function(){ </div><div class="t m0 x0 hb yd6d ff21 fs6 fc0 sc0 ls21 wsb">    alert(this.name); </div><div class="t m0 x0 hb yd6e ff21 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb ye15 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ye16 ff21 fs6 fc0 sc0 ls21 wsb">function SubType(name, age){   </div><div class="t m0 x0 hb ye17 ff21 fs6 fc0 sc0 ls21 wsb">    SuperType.call(this, name); </div><div class="t m0 x0 hb ye18 ff21 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 hb ye19 ff21 fs6 fc0 sc0 ls21 wsb">    this.age = age; </div><div class="t m0 x0 hb ye1a ff21 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb ye1b ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 ye1c ff27 fs6 fc0 sc0 ls21 wsb">inheritPrototype(SubType, SuperType); </div><div class="t m0 x0 hb ye1d ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ye1e ff21 fs6 fc0 sc0 ls21 wsb">SubType.prototype.sayAge = function(){ </div><div class="t m0 x0 hb ye1f ff21 fs6 fc0 sc0 ls21 wsb">    alert(this.age); </div><div class="t m0 x0 hb ye20 ff21 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb ye21 ff21 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf ye22 ff22 fs2 fc0 sc0 ls8 wsb">ParasiticCombinationInheritanceExample01.htm </div><div class="t m0 x2 h5 ye23 ff1a fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 h3 ye24 ff20 fs1 fc0 sc0 ls8 wsb">图 6-6 </div></div></div>
<div id="pfc0" class="pf w0 h0" data-page-no="c0"><div class="pc pcc0 w0 h0"><div class="t m0 x0 h2 y1 ff1a fs0 fc0 sc0 ls7 ws0">174  第6章 面向对象的程序设计 </div><div class="t m0 x0 h3 y2 ff1a fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ff20 fs2 fc0 sc0 ls30 wsf6">这个例子的高效率体现在它只调用了一次SuperType构造函数，并且因此避免了在 SubType. </div><div class="t m0 x0 h42 ye26 ff21 fs1 fc0 sc0 ls43 ws31">prototype上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用</div><div class="t m0 x0 h5 y4e ff21 fs1 fc0 sc0 ls43 ws31">instanceof和isPrototypeOf()。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。 </div><div class="t m0 x5 h5 y59e ff1a fs2 fc0 sc0 ls81 ws76">YUI的YAHOO.lang.extend()方法采用了寄生组合继承，从而让这种模式首次</div><div class="t m0 x0 h5 y59f ff1b fs2 fc0 sc0 ls8 ws14">出现在了一个应用非常广泛的JavaScript库中。要了解有关YUI的更多信息，请访问</div><div class="t m0 x0 h5 ye27 ff1a fs2 fc0 sc0 ls79 ws12a">http://developer. yahoo.com/yui/。 </div><div class="t m0 x0 hd y5a2 ff1e fs7 fc0 sc0 ls22">6.4 小结 </div><div class="t m0 x0 h5 ye28 ff1a fs2 fc0 sc0 ls1a ws1c">ECMAScript支持面向对象（OO）编程，但不使用类或者接口。对象可以在代码执行过程中创建和</div><div class="t m0 x0 h5 ye29 ff20 fs2 fc0 sc0 ls8 wseb">增强，因此具有动态性而非严格定义的实体。在没有类的情况下，可以采用下列模式创建对象。 </div><div class="t m0 x0 h4 ye2a ff1f fs1 fc0 sc0 ls2"> 工厂模式，使用简单的函数创建对象，为对象添加属性和方法，然后返回对象。这个模式后来</div><div class="t m0 x0 h5 ye2b ff20 fs2 fc0 sc0 ls8 wseb">被构造函数模式所取代。 </div><div class="t m0 x0 h4 ye2c ff1f fs1 fc0 sc0 ls2"> 构造函数模式，可以创建自定义引用类型，可以像创建内置对象实例一样使用new操作符。不</div><div class="t m0 x0 h4 ye2d ff20 fs2 fc0 sc0 ls5 wsec">过，构造函数模式也有缺点，即它的每个成员都无法得到复用，包括函数。由于函数可以不局</div><div class="t m0 x0 h5 ye2e ff20 fs2 fc0 sc0 ls8 wseb">限于任何对象（即与对象具有松散耦合的特点），因此没有理由不在多个对象间共享函数。 </div><div class="t m0 x0 h4 ye2f ff1f fs1 fc0 sc0 ls2"> 原型模式，使用构造函数的prototype属性来指定那些应该共享的属性和方法。组合使用构造</div><div class="t m0 x0 h5 ye30 ff20 fs2 fc0 sc0 ls8 wseb">函数模式和原型模式时，使用构造函数定义实例属性，而使用原型定义共享的属性和方法。 </div><div class="t m0 x0 h5 ye31 ff1a fs2 fc0 sc0 lsb ws5">JavaScript主要通过原型链实现继承。原型链的构建是通过将一个类型的实例赋值给另一个构造函</div><div class="t m0 x0 h4 ye32 ff20 fs2 fc0 sc0 ls8 wseb">数的原型实现的。这样，子类型就能够访问超类型的所有属性和方法，这一点与基于类的继承很相似。</div><div class="t m0 x0 h4 ye33 ff20 fs2 fc0 sc0 ls8 wseb">原型链的问题是对象实例共享所有继承的属性和方法，因此不适宜单独使用。解决这个问题的技术是借</div><div class="t m0 x0 h4 ye34 ff20 fs2 fc0 sc0 ls8 wseb">用构造函数，即在子类型构造函数的内部调用超类型构造函数。这样就可以做到每个实例都具有自己的</div><div class="t m0 x0 h4 ye35 ff20 fs2 fc0 sc0 ls8 wseb">属性，同时还能保证只使用构造函数模式来定义类型。使用最多的继承模式是组合继承，这种模式使用</div><div class="t m0 x0 h5 ye36 ff20 fs2 fc0 sc0 ls8 wseb">原型链继承共享的属性和方法，而通过借用构造函数继承实例属性。 </div><div class="t m0 x0 h5 ye37 ff20 fs2 fc0 sc0 ls8 wseb">此外，还存在下列可供选择的继承模式。 </div><div class="t m0 x0 h4 ye38 ff1f fs1 fc0 sc0 ls2"> 原型式继承，可以在不必预先定义构造函数的情况下实现继承，其本质是执行对给定对象的浅</div><div class="t m0 x0 h5 ye39 ff20 fs2 fc0 sc0 ls8 wseb">复制。而复制得到的副本还可以得到进一步改造。 </div><div class="t m0 x0 h4 ye3a ff1f fs1 fc0 sc0 ls2"> 寄生式继承，与原型式继承非常相似，也是基于某个对象或某些信息创建一个对象，然后增强</div><div class="t m0 x0 h4 ye3b ff20 fs2 fc0 sc0 ls5 wsec">对象，最后返回对象。为了解决组合继承模式由于多次调用超类型构造函数而导致的低效率问</div><div class="t m0 x0 h5 ye3c ff20 fs2 fc0 sc0 ls8 wseb">题，可以将这个模式与组合继承一起使用。 </div><div class="t m0 x0 h5 ye3d ff1f fs1 fc0 sc0 ls2"> 寄生组合式继承，集寄生式继承和组合继承的优点与一身，是实现基于类型继承的最有效方式。 </div><div class="t m0 x0 h5 ye3e ff1a fs2 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pfc1" class="pf w0 h0" data-page-no="c1"><div class="pc pcc1 w0 h0"><div class="t m0 x2 h2 y1 ff2a fs0 fc0 sc0 ls10 wsc">7.1 递归  175 </div><div class="t m0 x0 h3 y2 ff2a fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff2c fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff2c fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff2c fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff2c fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff2c fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff2c fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff2c fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff2c fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff2c fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff2c fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff2c fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff2c fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff2c fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h9 y2a ff2d fs5 fc0 sc0 ls8 wsb">函数表达式 </div><div class="t m0 x0 h3c y2b ff2e fs2 fc0 sc0 ls8">本章内容 </div><div class="t m0 x0 h5 y2c ff30 fs1 fc0 sc0 ls2"> 函数表达式的特征 </div><div class="t m0 x0 h5 y2d ff30 fs1 fc0 sc0 ls2"> 使用函数实现递归 </div><div class="t m0 x0 h5 y2e ff30 fs1 fc0 sc0 ls2"> 使用闭包定义私有变量 </div><div class="t m0 x0 h5 y8d9 ff2a fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x5 h5 y8da ff31 fs2 fc0 sc0 ls8 wseb">数表达式是JavaScript中的一个既强大又容易令人困惑的特性。第5章曾介绍过，定义函数的</div><div class="t m0 x5 h5 y8db ff31 fs2 fc0 sc0 ls8 wseb">方式有两种：一种是函数声明，另一种就是函数表达式。函数声明的语法是这样的。 </div><div class="t m0 x5 hb ye3f ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ye40 ff32 fs6 fc0 sc0 ls21 wsb">function functionName(arg0, arg1, arg2) { </div><div class="t m0 x0 h16 ye41 ff32 fs6 fc0 sc0 ls21 wsb">    //函数体 </div><div class="t m0 x0 hb ye42 ff32 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h5 ye43 ff31 fs2 fc0 sc0 ls8 wseb">首先是function关键字，然后是函数的名字，这就是指定函数名的方式。Firefox、Safari、Chrome</div><div class="t m0 x0 h5 ye44 ff31 fs2 fc0 sc0 ls8d">和Opera都给函数定义了一个非标准的name属性，通过这个属性可以访问到给函数指定的名字。这个</div><div class="t m0 x0 hc ye45 ff31 fs2 fc0 sc0 ls8 wseb">属性的值永远等于跟在function关键字后面的标识符。 </div><div class="t m0 x0 hb ye46 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 ye47 ff32 fs6 fc0 sc0 ls21">//只在Firefox、Safari、Chrome和Opera有效 </div><div class="t m0 x0 hb ye48 ff32 fs6 fc0 sc0 ls21 wsb">alert(functionName.name);  //&quot;functionName&quot; </div><div class="t m0 x0 h5 ye49 ff2a fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf ye4a ff34 fs2 fc0 sc0 ls1b wsb">FunctionNameExample01.htm </div><div class="t m0 x0 h5 ye4b ff31 fs2 fc0 sc0 ls8 wseb">关于函数声明，它的一个重要特征就是函数声明提升（function declaration hoisting），意思是在执行</div><div class="t m0 x0 h5 ye4c ff31 fs2 fc0 sc0 ls8 wseb">代码之前会先读取函数声明。这就意味着可以把函数声明放在调用它的语句后面。 </div><div class="t m0 x0 hb ye38 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ye4d ff32 fs6 fc0 sc0 ls21 wsb">sayHi(); </div><div class="t m0 x0 hb ye4e ff32 fs6 fc0 sc0 ls21 wsb">function sayHi(){ </div><div class="t m0 x0 hb ye4f ff32 fs6 fc0 sc0 ls21 wsb">    alert(&quot;Hi!&quot;);  </div><div class="t m0 x0 hb ye50 ff32 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb ye51 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf ye52 ff34 fs2 fc0 sc0 ls2b wsb">FunctionDeclarationHoisting01.htm </div><div class="t m0 x0 h5 ye53 ff31 fs2 fc0 sc0 ls8 wseb">这个例子不会抛出错误，因为在代码执行之前会先读取函数声明。 </div><div class="t m0 x0 h4 ye54 ff31 fs2 fc0 sc0 ls8 wseb">第二种创建函数的方式是使用函数表达式。函数表达式有几种不同的语法形式。下面是最常见的一</div><div class="t m0 x0 h5 ye55 ff31 fs2 fc0 sc0 ls8">种形式。 </div><div class="t m0 x0 hb ye56 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ye57 ff32 fs6 fc0 sc0 ls21 wsb">var functionName = function(arg0, arg1, arg2){ </div><div class="t m0 x0 h16 ye58 ff32 fs6 fc0 sc0 ls21 wsb">    //函数体  </div><div class="t m0 x0 hb ye59 ff32 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 h5 ye5a ff2a fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h6f y338 ff2e fsf fc0 sc0 ls8 wsb">函 </div><div class="t m0 x0 h11 y4b ff35 fsa fc0 sc0 ls8">第</div><div class="t m1 x0 h12 y4b ff36 fsb fc3 sc0 ls8">7</div><div class="t m0 x5 h11 y4b ff35 fsa fc0 sc0 ls8 ws1d">章 </div></div></div>
<div id="pfc2" class="pf w0 h0" data-page-no="c2"><div class="pc pcc2 w0 h0"><div class="t m0 x0 h2 y1 ff2a fs0 fc0 sc0 ls7 ws0">176  第7章 函数表达式 </div><div class="t m0 x0 h3 y2 ff2a fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ff31 fs2 fc0 sc0 ls8 wseb">这种形式看起来好像是常规的变量赋值语句，即创建一个函数并将它赋值给变量functionName。</div><div class="t m0 x0 h5 y4d ff31 fs2 fc0 sc0 ls8 wseb">这种情况下创建的函数叫做匿名函数（anonymous function），因为function关键字后面没有标识符。</div><div class="t m0 x0 hc y5 ff31 fs2 fc0 sc0 ls8 wseb">（匿名函数有时候也叫拉姆达函数。）匿名函数的name属性是空字符串。 </div><div class="t m0 x0 h5 yd9 ff31 fs2 fc0 sc0 ls8 wseb">函数表达式与其他表达式一样，在使用前必须先赋值。以下代码会导致错误。 </div><div class="t m0 x0 hb ye5c ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 ye5d ff32 fs6 fc0 sc0 ls21 wsb">sayHi();    //错误：函数还不存在 </div><div class="t m0 x0 hb ye5e ff32 fs6 fc0 sc0 ls21 wsb">var sayHi = function(){ </div><div class="t m0 x0 hb ye5f ff32 fs6 fc0 sc0 ls21 wsb">    alert(&quot;Hi!&quot;); </div><div class="t m0 x0 hb ye60 ff32 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 h5 ye61 ff2a fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 ye62 ff31 fs2 fc0 sc0 ls8 wseb">理解函数提升的关键，就是理解函数声明与函数表达式之间的区别。例如，执行以下代码的结果可</div><div class="t m0 x0 h5 ye63 ff31 fs2 fc0 sc0 ls8 wseb">能会让人意想不到。 </div><div class="t m0 x0 hb ye64 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 ye65 ff32 fs6 fc0 sc0 ls21">//不要这样做！  </div><div class="t m0 x0 hb ye66 ff32 fs6 fc0 sc0 ls21 wsb">if(condition){ </div><div class="t m0 x0 hb ye67 ff32 fs6 fc0 sc0 ls21 wsb">    function sayHi(){ </div><div class="t m0 x0 hb ye68 ff32 fs6 fc0 sc0 ls21 wsb">        alert(&quot;Hi!&quot;); </div><div class="t m0 x0 hb ye69 ff32 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb ye6a ff32 fs6 fc0 sc0 ls21 wsb">} else { </div><div class="t m0 x0 hb ye6b ff32 fs6 fc0 sc0 ls21 wsb">    function sayHi(){ </div><div class="t m0 x0 hb ye6c ff32 fs6 fc0 sc0 ls21 wsb">        alert(&quot;Yo!&quot;); </div><div class="t m0 x0 hb ye6d ff32 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb ye6e ff32 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 hb ye6f ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf ye70 ff34 fs2 fc0 sc0 ls2b wsb">FunctionDeclarationsErrorExample01.htm </div><div class="t m0 x0 h4 y3bb ff31 fs2 fc0 sc0 ls8 wseb">表面上看，以上代码表示在condition为true时，使用一个sayHi()的定义；否则，就使用另</div><div class="t m0 x0 h5 ye71 ff31 fs2 fc0 sc0 ls8 wseb">一个定义。实际上，这在ECMAScript中属于无效语法，JavaScript引擎会尝试修正错误，将其转换为合</div><div class="t m0 x0 h4 y9f2 ff31 fs2 fc0 sc0 ls4">理的状态。但问题是浏览器尝试修正错误的做法并不一致。大多数浏览器会返回第二个声明，忽略</div><div class="t m0 x0 h5 ye72 ff32 fs1 fc0 sc0 ls9 ws2">condition；Firefox会在condition为true时返回第一个声明。因此这种使用方式很危险，不应该</div><div class="t m0 x0 h5 ye73 ff31 fs2 fc0 sc0 ls8 wseb">出现在你的代码中。不过，如果是使用函数表达式，那就没有什么问题了。 </div><div class="t m0 x0 hb ye74 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 ye75 ff32 fs6 fc0 sc0 ls21">//可以这样做 </div><div class="t m0 x0 hb ye76 ff32 fs6 fc0 sc0 ls21 wsb">var sayHi; </div><div class="t m0 x0 hb ye77 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ye78 ff32 fs6 fc0 sc0 ls21 wsb">if(condition){  </div><div class="t m0 x0 hb ye79 ff32 fs6 fc0 sc0 ls21 wsb">    sayHi = function(){ </div><div class="t m0 x0 hb ye7a ff32 fs6 fc0 sc0 ls21 wsb">        alert(&quot;Hi!&quot;); </div><div class="t m0 x0 hb ye7b ff32 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 hb ye7c ff32 fs6 fc0 sc0 ls21 wsb">} else { </div><div class="t m0 x0 hb ye7d ff32 fs6 fc0 sc0 ls21 wsb">    sayHi = function(){ </div><div class="t m0 x0 hb ye7e ff32 fs6 fc0 sc0 ls21 wsb">        alert(&quot;Yo!&quot;); </div><div class="t m0 x0 hb ye7f ff32 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 hb ye80 ff32 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb ye81 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y9dd ff31 fs2 fc0 sc0 ls8 wseb">这个例子不会有什么意外，不同的函数会根据condition被赋值给sayHi。 </div><div class="t m0 x0 h5 y9de ff31 fs2 fc0 sc0 ls55 wsfc">能够创建函数再赋值给变量，也就能够把函数作为其他函数的值返回。还记得第5章中的那个</div><div class="t m0 x0 h5 y286 ff32 fs1 fc0 sc0 ls9 ws2">createComparisonFunction()函数吗： </div><div class="t m0 x0 hb ye82 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ye83 ff32 fs6 fc0 sc0 ls21 wsb">function createComparisonFunction(propertyName) { </div><div class="t m0 x0 hb ye84 ff32 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 hb ye85 ff32 fs6 fc0 sc0 ls21 wsb">    return function(object1, object2){ </div><div class="t m0 x0 hb ye86 ff32 fs6 fc0 sc0 ls21 wsb">        var value1 = object1[propertyName]; </div><div class="t m0 x0 hb ye87 ff32 fs6 fc0 sc0 ls21 wsb">        var value2 = object2[propertyName]; </div></div></div>
<div id="pfc3" class="pf w0 h0" data-page-no="c3"><div class="pc pcc3 w0 h0"><div class="t m0 x2 h2 y1 ff2a fs0 fc0 sc0 ls10 wsc">7.1 递归  177 </div><div class="t m0 x0 h3 y2 ff2a fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff2c fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff2c fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff2c fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff2c fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff2c fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff2c fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff2c fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff2c fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff2c fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff2c fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff2c fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff2c fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff2c fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y44f ff32 fs6 fc0 sc0 ls21 wsb">         </div><div class="t m0 x0 hb y450 ff32 fs6 fc0 sc0 ls21 wsb">        if (value1 &lt; value2){ </div><div class="t m0 x0 hb y451 ff32 fs6 fc0 sc0 ls21 wsb">            return -1; </div><div class="t m0 x0 hb y452 ff32 fs6 fc0 sc0 ls21 wsb">        } else if (value1 &gt; value2){ </div><div class="t m0 x0 hb y453 ff32 fs6 fc0 sc0 ls21 wsb">            return 1; </div><div class="t m0 x0 hb y454 ff32 fs6 fc0 sc0 ls21 wsb">        } else { </div><div class="t m0 x0 hb y455 ff32 fs6 fc0 sc0 ls21 wsb">            return 0; </div><div class="t m0 x0 hb y456 ff32 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb ye88 ff32 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 hb ye89 ff32 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h4 ye8a ff32 fs1 fc0 sc0 ls9 ws2">createComparisonFunction()就返回了一个匿名函数。返回的函数可能会被赋值给一个变量，</div><div class="t m0 x0 h1e ye8b ff31 fs2 fc0 sc0 ls8 wseb">或者以其他方式被调用；不过，在createComparisonFunction()函数内部，它是匿名的。在把函数</div><div class="t m0 x0 h5 ye8c ff31 fs2 fc0 sc0 ls8 wseb">当成值来使用的情况下，都可以使用匿名函数。不过，这并不是匿名函数唯一的用途。 </div><div class="t m0 x0 hd ye8d ff2f fs7 fc0 sc0 ls22">7.1 递归 </div><div class="t m0 x0 h5 ye8e ff31 fs2 fc0 sc0 ls8 wseb">递归函数是在一个函数通过名字调用自身的情况下构成的，如下所示。 </div><div class="t m0 x5 hb ye8f ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ye90 ff32 fs6 fc0 sc0 ls21 wsb">function factorial(num){ </div><div class="t m0 x0 hb ye91 ff32 fs6 fc0 sc0 ls21 wsb">    if (num &lt;= 1){ </div><div class="t m0 x0 hb ye92 ff32 fs6 fc0 sc0 ls21 wsb">        return 1; </div><div class="t m0 x0 hb ye93 ff32 fs6 fc0 sc0 ls21 wsb">    } else { </div><div class="t m0 x0 hb ye94 ff32 fs6 fc0 sc0 ls21 wsb">        return num * factorial(num-1); </div><div class="t m0 x0 hb ye95 ff32 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb ye96 ff32 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x2 hf ye97 ff34 fs2 fc0 sc0 ls2b wsb">RecursionExample01.htm </div><div class="t m0 x0 h5 y8ae ff31 fs2 fc0 sc0 ls1f ws108">这是一个经典的递归阶乘函数。虽然这个函数表面看来没什么问题，但下面的代码却可能导致它出错。 </div><div class="t m0 x5 hb ye98 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ye99 ff32 fs6 fc0 sc0 ls21 wsb">var anotherFactorial = factorial; </div><div class="t m0 x0 hb ye9a ff32 fs6 fc0 sc0 ls21 wsb">factorial = null; </div><div class="t m0 x0 h16 ye9b ff32 fs6 fc0 sc0 ls21 wsb">alert(anotherFactorial(4)); //出错！ </div><div class="t m0 x5 hb ye9c ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf ye9d ff34 fs2 fc0 sc0 ls2b wsb">RecursionExample01.htm </div><div class="t m0 x0 h4 ye9e ff31 fs2 fc0 sc0 ls8 wseb">以上代码先把factorial()函数保存在变量anotherFactorial中，然后将factorial 变量设</div><div class="t m0 x0 h1e ye9f ff31 fs2 fc0 sc0 ls8 wseb">置为null，结果指向原始函数的引用只剩下一个。但在接下来调用anotherFactorial()时，由于必</div><div class="t m0 x0 h4 yea0 ff31 fs2 fc0 sc0 ls8 wseb">须执行factorial()，而factorial已经不再是函数，所以就会导致错误。在这种情况下，使用argu- </div><div class="t m0 x0 h21 yea1 ff32 fs1 fc0 sc0 ls9 ws2">ments.callee可以解决这个问题。 </div><div class="t m0 x0 h1e yea2 ff31 fs2 fc0 sc0 ls6 wsf7">我们知道，arguments.callee是一个指向正在执行的函数的指针，因此可以用它来实现对函数</div><div class="t m0 x0 h5 yea3 ff31 fs2 fc0 sc0 ls8 wseb">的递归调用，例如： </div><div class="t m0 x5 hb yea4 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yea5 ff32 fs6 fc0 sc0 ls21 wsb">function factorial(num){ </div><div class="t m0 x0 hb yea6 ff32 fs6 fc0 sc0 ls21 wsb">    if (num &lt;= 1){ </div><div class="t m0 x0 hb yea7 ff32 fs6 fc0 sc0 ls21 wsb">        return 1; </div><div class="t m0 x0 hb yea8 ff32 fs6 fc0 sc0 ls21 wsb">    } else { </div><div class="t m0 x0 h15 yea9 ff37 fs6 fc0 sc0 ls21 wsb">        return num * arguments.callee(num-1); </div><div class="t m0 x0 hb yeaa ff32 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb yeab ff32 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x2 hf yeac ff34 fs2 fc0 sc0 ls2b wsb">RecursionExample02.htm </div></div></div>
<div id="pfc4" class="pf w0 h0" data-page-no="c4"><div class="pc pcc4 w0 h0"><div class="t m0 x0 h2 y1 ff2a fs0 fc0 sc0 ls7 ws0">178  第7章 函数表达式 </div><div class="t m0 x0 h3 y2 ff2a fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ff31 fs2 fc0 sc0 ls8 wseb">加粗的代码显示，通过使用arguments.callee代替函数名，可以确保无论怎样调用函数都不会</div><div class="t m0 x0 hc y4d ff31 fs2 fc0 sc0 ls8 wseb">出问题。因此，在编写递归函数时，使用arguments.callee总比使用函数名更保险。 </div><div class="t m0 x0 h1e y5 ff31 fs2 fc0 sc0 ls6 wsf7">但在严格模式下，不能通过脚本访问arguments.callee，访问这个属性会导致错误。不过，可</div><div class="t m0 x0 h5 yd9 ff31 fs2 fc0 sc0 ls8 wseb">以使用命名函数表达式来达成相同的结果。例如： </div><div class="t m0 x0 hb ye5c ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yead ff32 fs6 fc0 sc0 ls21 wsb">var factorial = (function f(num){ </div><div class="t m0 x0 hb yeae ff32 fs6 fc0 sc0 ls21 wsb">    if (num &lt;= 1){  </div><div class="t m0 x0 hb yeaf ff32 fs6 fc0 sc0 ls21 wsb">        return 1; </div><div class="t m0 x0 hb yeb0 ff32 fs6 fc0 sc0 ls21 wsb">    } else { </div><div class="t m0 x0 hb yeb1 ff32 fs6 fc0 sc0 ls21 wsb">        return num * f(num-1); </div><div class="t m0 x0 hb yeb2 ff32 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb yeb3 ff32 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 hb yeb4 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 yeb5 ff31 fs2 fc0 sc0 ls8 wseb">以上代码创建了一个名为f()的命名函数表达式，然后将它赋值给变量factorial。即便把函数</div><div class="t m0 x0 h1e yeb6 ff31 fs2 fc0 sc0 ls8 wseb">赋值给了另一个变量，函数的名字f仍然有效，所以递归调用照样能正确完成。这种方式在严格模式和</div><div class="t m0 x0 h5 yccf ff31 fs2 fc0 sc0 ls8 wseb">非严格模式下都行得通。 </div><div class="t m0 x0 hd yeb7 ff2f fs7 fc0 sc0 ls22">7.2 闭包 </div><div class="t m0 x0 h4 yeb8 ff31 fs2 fc0 sc0 ls8 wseb">有不少开发人员总是搞不清匿名函数和闭包这两个概念，因此经常混用。闭包是指有权访问另一个</div><div class="t m0 x0 h4 yeb9 ff31 fs2 fc0 sc0 ls8 wseb">函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数，仍以前面的</div><div class="t m0 x0 h5 yeba ff32 fs1 fc0 sc0 ls9 ws2">createComparisonFunction()函数为例，注意加粗的代码。 </div><div class="t m0 x0 hb yc60 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yebb ff32 fs6 fc0 sc0 ls21 wsb">function createComparisonFunction(propertyName) { </div><div class="t m0 x0 hb yebc ff32 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 hb yebd ff32 fs6 fc0 sc0 ls21 wsb">    return function(object1, object2){ </div><div class="t m0 x0 h15 yebe ff37 fs6 fc0 sc0 ls21 wsb">        var value1 = object1[propertyName]; </div><div class="t m0 x0 h15 yebf ff37 fs6 fc0 sc0 ls21 wsb">        var value2 = object2[propertyName]; </div><div class="t m0 x0 hb yec0 ff32 fs6 fc0 sc0 ls21 wsb">         </div><div class="t m0 x0 hb yec1 ff32 fs6 fc0 sc0 ls21 wsb">        if (value1 &lt; value2){ </div><div class="t m0 x0 hb yec2 ff32 fs6 fc0 sc0 ls21 wsb">            return -1; </div><div class="t m0 x0 hb yec3 ff32 fs6 fc0 sc0 ls21 wsb">        } else if (value1 &gt; value2){ </div><div class="t m0 x0 hb yec4 ff32 fs6 fc0 sc0 ls21 wsb">            return 1; </div><div class="t m0 x0 hb yec5 ff32 fs6 fc0 sc0 ls21 wsb">        } else { </div><div class="t m0 x0 hb yec6 ff32 fs6 fc0 sc0 ls21 wsb">            return 0; </div><div class="t m0 x0 hb yec7 ff32 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb yec8 ff32 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 hb yec9 ff32 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h4 yeca ff31 fs2 fc0 sc0 ls8 wseb">在这个例子中，突出的那两行代码是内部函数（一个匿名函数）中的代码，这两行代码访问了外部</div><div class="t m0 x0 h1e yecb ff31 fs2 fc0 sc0 ls8 wseb">函数中的变量propertyName。即使这个内部函数被返回了，而且是在其他地方被调用了，但它仍然可</div><div class="t m0 x0 h4 yecc ff31 fs2 fc0 sc0 ls147 ws115">以访问变量propertyName。之所以还能够访问这个变量，是因为内部函数的作用域链中包含</div><div class="t m0 x0 h4 yecd ff32 fs1 fc0 sc0 ls9 ws2">createComparisonFunction()的作用域。要彻底搞清楚其中的细节，必须从理解函数被调用的时候</div><div class="t m0 x0 h5 yece ff31 fs2 fc0 sc0 ls8 wseb">都会发生什么入手。 </div><div class="t m0 x0 h5 yecf ff31 fs2 fc0 sc0 ls3b">第4章介绍了作用域链的概念。而有关如何创建作用域链以及作用域链有什么作用的细节，对彻底</div><div class="t m0 x0 h5 yed0 ff31 fs2 fc0 sc0 ls8 wseb">理解闭包至关重要。当某个函数被调用时，会创建一个执行环境（execution context）及相应的作用域链。</div><div class="t m0 x0 h14 yed1 ff31 fs2 fc0 sc0 ls8 wseb">然后，使用arguments和其他命名参数的值来初始化函数的活动对象（activation object）。但在作用域</div><div class="t m0 x0 h4 yed2 ff31 fs2 fc0 sc0 ls8 wseb">链中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位，……直至作</div></div></div>
<div id="pfc5" class="pf w0 h0" data-page-no="c5"><div class="pc pcc5 w0 h0"><div class="t m0 x2 h2 y1 ff2a fs0 fc0 sc0 ls10 wsc">7.2 闭包  179 </div><div class="t m0 x0 h3 y2 ff2a fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff2c fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff2c fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff2c fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff2c fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff2c fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff2c fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff2c fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff2c fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff2c fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff2c fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff2c fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff2c fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff2c fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff31 fs2 fc0 sc0 ls8 wseb">为作用域链终点的全局执行环境。 </div><div class="t m0 x0 h5 y4d ff31 fs2 fc0 sc0 ls8 wseb">在函数执行过程中，为读取和写入变量的值，就需要在作用域链中查找变量。来看下面的例子。 </div><div class="t m0 x5 hb y2d8 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2d9 ff32 fs6 fc0 sc0 ls21 wsb">function compare(value1, value2){ </div><div class="t m0 x0 hb y2da ff32 fs6 fc0 sc0 ls21 wsb">    if (value1 &lt; value2){ </div><div class="t m0 x0 hb y2db ff32 fs6 fc0 sc0 ls21 wsb">        return -1; </div><div class="t m0 x0 hb y2dc ff32 fs6 fc0 sc0 ls21 wsb">    } else if (value1 &gt; value2){ </div><div class="t m0 x0 hb y2dd ff32 fs6 fc0 sc0 ls21 wsb">        return 1; </div><div class="t m0 x0 hb y9e2 ff32 fs6 fc0 sc0 ls21 wsb">    } else { </div><div class="t m0 x0 hb y9e3 ff32 fs6 fc0 sc0 ls21 wsb">        return 0; </div><div class="t m0 x0 hb y9e4 ff32 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y9e5 ff32 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y9e6 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y9e7 ff32 fs6 fc0 sc0 ls21 wsb">var result = compare(5, 10); </div><div class="t m0 x5 hb yed3 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 yed4 ff31 fs2 fc0 sc0 ls8 wseb">以上代码先定义了compare()函数，然后又在全局作用域中调用了它。当调用compare()时，会</div><div class="t m0 x0 h1e yed5 ff31 fs2 fc0 sc0 ls8 wseb">创建一个包含arguments、value1和value2的活动对象。全局执行环境的变量对象（包含result</div><div class="t m0 x0 h5 yed6 ff31 fs2 fc0 sc0 lsff">和compare）在compare()执行环境的作用域链中则处于第二位。图7-1 展示了包含上述关系的</div><div class="t m0 x0 h5 yed7 ff32 fs1 fc0 sc0 ls9 ws2">compare()函数执行时的作用域链。 </div><div class="t m0 x6 h5 yed8 ff2a fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 h3 yed9 ff31 fs1 fc0 sc0 ls8 wsb">图 7-1 </div><div class="t m0 x0 h4 yeda ff31 fs2 fc0 sc0 ls8 wseb">后台的每个执行环境都有一个表示变量的对象——变量对象。全局环境的变量对象始终存在，而像</div><div class="t m0 x0 h4 yedb ff32 fs1 fc0 sc0 ls9 ws2">compare()函数这样的局部环境的变量对象，则只在函数执行的过程中存在。在创建compare()函数</div><div class="t m0 x0 h4 yedc ff31 fs2 fc0 sc0 ls8 wseb">时，会创建一个预先包含全局变量对象的作用域链，这个作用域链被保存在内部的[[Scope]]属性中。</div><div class="t m0 x0 h1e yedd ff31 fs2 fc0 sc0 ls8 wseb">当调用compare()函数时，会为函数创建一个执行环境，然后通过复制函数的[[Scope]]属性中的对</div><div class="t m0 x0 h4 yede ff31 fs2 fc0 sc0 ls8 wseb">象构建起执行环境的作用域链。此后，又有一个活动对象（在此作为变量对象使用）被创建并被推入执</div><div class="t m0 x0 h1c yedf ff31 fs2 fc0 sc0 ls6 wsf7">行环境作用域链的前端。对于这个例子中compare()函数的执行环境而言，其作用域链中包含两个变</div><div class="t m0 x0 h4 yee0 ff31 fs2 fc0 sc0 ls8 wseb">量对象：本地活动对象和全局变量对象。显然，作用域链本质上是一个指向变量对象的指针列表，它只</div><div class="t m0 x0 h5 yee1 ff31 fs2 fc0 sc0 ls8 wseb">引用但不实际包含变量对象。 </div><div class="t m0 x0 h4 yee2 ff31 fs2 fc0 sc0 ls8 wseb">无论什么时候在函数中访问一个变量时，就会从作用域链中搜索具有相应名字的变量。一般来讲，</div><div class="t m0 x0 h4 yee3 ff31 fs2 fc0 sc0 ls8 wseb">当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）。</div><div class="t m0 x0 h5 yee4 ff31 fs2 fc0 sc0 ls8 wseb">但是，闭包的情况又有所不同。 </div><div class="t m0 x0 h5 yee5 ff2a fs2 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pfc6" class="pf w0 h0" data-page-no="c6"><div class="pc pcc6 w0 h0"><div class="t m0 x0 h2 y1 ff2a fs0 fc0 sc0 ls7 ws0">180  第7章 函数表达式 </div><div class="t m0 x0 h3 y2 ff2a fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ff31 fs2 fc0 sc0 ls8 wseb">在另一个函数内部定义的函数会将包含函数（即外部函数）的活动对象添加到它的作用域链中。因</div><div class="t m0 x0 h1e y4d ff31 fs2 fc0 sc0 ls8 wseb">此，在createComparisonFunction()函数内部定义的匿名函数的作用域链中，实际上将会包含外部</div><div class="t m0 x0 hc y5 ff31 fs2 fc0 sc0 ls8 wseb">函数createComparisonFunction()的活动对象。图7-2展示了当下列代码执行时，包含函数与内部</div><div class="t m0 x0 h5 yd9 ff31 fs2 fc0 sc0 ls8 wseb">匿名函数的作用域链。 </div><div class="t m0 x0 hb ya81 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ya82 ff32 fs6 fc0 sc0 ls21 wsb">var compare = createComparisonFunction(&quot;name&quot;); </div><div class="t m0 x0 hb ya83 ff32 fs6 fc0 sc0 ls21 wsb">var result = compare({ name: &quot;Nicholas&quot; }, { name: &quot;Greg&quot; }); </div><div class="t m0 x0 hb ya84 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 ya85 ff31 fs2 fc0 sc0 ls147 ws115">在匿名函数从createComparisonFunction()中被返回后，它的作用域链被初始化为包含</div><div class="t m0 x0 h4 ya86 ff32 fs1 fc0 sc0 ls9 ws2">createComparisonFunction()函数的活动对象和全局变量对象。这样，匿名函数就可以访问在</div><div class="t m0 x0 h4 yee7 ff32 fs1 fc0 sc0 ls9 ws2">createComparisonFunction()中定义的所有变量。更为重要的是，createComparisonFunction()</div><div class="t m0 x0 h4 yee8 ff31 fs2 fc0 sc0 ls8 wseb">函数在执行完毕后，其活动对象也不会被销毁，因为匿名函数的作用域链仍然在引用这个活动对象。换</div><div class="t m0 x0 h1e yee9 ff31 fs2 fc0 sc0 ls8 wseb">句话说，当createComparisonFunction()函数返回后，其执行环境的作用域链会被销毁，但它的活</div><div class="t m0 x0 h4 yeea ff31 fs2 fc0 sc0 ls8 wseb">动对象仍然会留在内存中；直到匿名函数被销毁后，createComparisonFunction()的活动对象才会</div><div class="t m0 x0 h5 yeeb ff31 fs2 fc0 sc0 ls8 wseb">被销毁，例如： </div><div class="t m0 x0 hb yeec ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 yeed ff32 fs6 fc0 sc0 ls21">//创建函数 </div><div class="t m0 x0 hb yeee ff32 fs6 fc0 sc0 ls21 wsb">var compareNames = createComparisonFunction(&quot;name&quot;); </div><div class="t m0 x0 hb yeef ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 yef0 ff32 fs6 fc0 sc0 ls21">//调用函数 </div><div class="t m0 x0 hb yef1 ff32 fs6 fc0 sc0 ls21 wsb">var result = compareNames({ name: &quot;Nicholas&quot; }, { name: &quot;Greg&quot; }); </div><div class="t m0 x0 hb yef2 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 yef3 ff32 fs6 fc0 sc0 ls21">//解除对匿名函数的引用（以便释放内存） </div><div class="t m0 x0 hb yef4 ff32 fs6 fc0 sc0 ls21 wsb">compareNames = null; </div><div class="t m0 x0 hb yef5 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 yef6 ff31 fs2 fc0 sc0 ls8 wseb">首先，创建的比较函数被保存在变量compareNames中。而通过将compareNames设置为等于null</div><div class="t m0 x0 h4 yef7 ff31 fs2 fc0 sc0 ls8 wseb">解除该函数的引用，就等于通知垃圾回收例程将其清除。随着匿名函数的作用域链被销毁，其他作用域</div><div class="t m0 x0 h5 yef8 ff31 fs2 fc0 sc0 ls8 wseb">（除了全局作用域）也都可以安全地销毁了。图7-2展示了调用compareNames()的过程中产生的作用</div><div class="t m0 x0 h5 yef9 ff31 fs2 fc0 sc0 ls8 wseb">域链之间的关系。 </div><div class="t m0 x6 h5 yefa ff2a fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x7 h3 yefb ff31 fs1 fc0 sc0 ls8 wsb">图 7-2 </div></div></div>
<div id="pfc7" class="pf w0 h0" data-page-no="c7"><div class="pc pcc7 w0 h0"><div class="t m0 x2 h2 y1 ff2a fs0 fc0 sc0 ls10 wsc">7.2 闭包  181 </div><div class="t m0 x0 h3 y2 ff2a fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff2c fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff2c fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff2c fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff2c fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff2c fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff2c fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff2c fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff2c fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff2c fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff2c fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff2c fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff2c fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff2c fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y70f ff2a fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x5 ha y945 ff2b fs2 fc0 sc0 ls8 ws14">由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存。过</div><div class="t m0 x5 ha yefc ff2b fs2 fc0 sc0 ls30 ws12c">度使用闭包可能会导致内存占用过多，我们建议读者只在绝对必要时再考虑使用闭</div><div class="t m0 x5 h5 yefd ff2b fs2 fc0 sc0 ls8 ws14">包。虽然像V8等优化后的JavaScript 引擎会尝试回收被闭包占用的内存，但请大家</div><div class="t m0 x5 h5 yefe ff2b fs2 fc0 sc0 ls8 ws14">还是要慎重使用闭包。 </div><div class="t m0 x0 h20 yeff ff2f fs3 fc0 sc0 ls4d ws40">7.2.1 闭包与变量 </div><div class="t m0 x0 h4 yf00 ff31 fs2 fc0 sc0 ls8 wseb">作用域链的这种配置机制引出了一个值得注意的副作用，即闭包只能取得包含函数中任何变量的最</div><div class="t m0 x0 h4 yf01 ff31 fs2 fc0 sc0 ls8 wseb">后一个值。别忘了闭包所保存的是整个变量对象，而不是某个特殊的变量。下面这个例子可以清晰地说</div><div class="t m0 x0 h5 yf02 ff31 fs2 fc0 sc0 ls8 wseb">明这个问题。 </div><div class="t m0 x5 hb yf03 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yf04 ff32 fs6 fc0 sc0 ls21 wsb">function createFunctions(){ </div><div class="t m0 x0 hb yf05 ff32 fs6 fc0 sc0 ls21 wsb">    var result = new Array(); </div><div class="t m0 x0 hb yf06 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yf07 ff32 fs6 fc0 sc0 ls21 wsb">    for (var i=0; i &lt; 10; i++){ </div><div class="t m0 x0 hb yf08 ff32 fs6 fc0 sc0 ls21 wsb">        result[i] = function(){ </div><div class="t m0 x0 hb yf09 ff32 fs6 fc0 sc0 ls21 wsb">            return i; </div><div class="t m0 x0 hb yf0a ff32 fs6 fc0 sc0 ls21 wsb">        }; </div><div class="t m0 x0 hb yf0b ff32 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb yf0c ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yf0d ff32 fs6 fc0 sc0 ls21 wsb">    return result; </div><div class="t m0 x0 hb yf0e ff32 fs6 fc0 sc0 ls21 wsb">}   </div><div class="t m0 x2 hf yf0f ff34 fs2 fc0 sc0 ls2b wsb">ClosureExample01.htm </div><div class="t m0 x0 h5 yf10 ff31 fs2 fc0 sc0 ls8 wseb">这个函数会返回一个函数数组。表面上看，似乎每个函数都应该返自己的索引值，即位置0的函数</div><div class="t m0 x0 h5 yf11 ff31 fs2 fc0 sc0 ls8 wseb">返回0，位置1的函数返回1，以此类推。但实际上，每个函数都返回10。因为每个函数的作用域链中</div><div class="t m0 x0 h1c yf12 ff31 fs2 fc0 sc0 ls164 ws12d">都保存着createFunctions()函数的活动对象，所以它们引用的都是同一个变量i。当</div><div class="t m0 x0 h5 y8e4 ff32 fs1 fc0 sc0 ls9 ws2">createFunctions()函数返回后，变量i的值是10，此时每个函数都引用着保存变量i的同一个变量</div><div class="t m0 x0 h5 yf13 ff31 fs2 fc0 sc0 ls8 wseb">对象，所以在每个函数内部i的值都是10。但是，我们可以通过创建另一个匿名函数强制让闭包的行为</div><div class="t m0 x0 h5 yf14 ff31 fs2 fc0 sc0 ls1f">符合预期，如下所示。 </div><div class="t m0 x5 hb yf15 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yf16 ff32 fs6 fc0 sc0 ls21 wsb">function createFunctions(){ </div><div class="t m0 x0 hb yf17 ff32 fs6 fc0 sc0 ls21 wsb">    var result = new Array(); </div><div class="t m0 x0 hb yf18 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yf19 ff32 fs6 fc0 sc0 ls21 wsb">    for (var i=0; i &lt; 10; i++){ </div><div class="t m0 x0 hb yf1a ff32 fs6 fc0 sc0 ls21 wsb">        result[i] = function(num){ </div><div class="t m0 x0 h15 yf1b ff37 fs6 fc0 sc0 ls21 wsb">            return function(){ </div><div class="t m0 x0 h15 yf1c ff37 fs6 fc0 sc0 ls21 wsb">                return num; </div><div class="t m0 x0 h15 yf1d ff37 fs6 fc0 sc0 ls21 wsb">            }; </div><div class="t m0 x0 hb yf1e ff37 fs6 fc0 sc0 ls21 wsb">        }(i); </div><div class="t m0 x0 hb yf1f ff32 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb yf20 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yf21 ff32 fs6 fc0 sc0 ls21 wsb">    return result; </div><div class="t m0 x0 hb yf22 ff32 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x2 hf yf23 ff34 fs2 fc0 sc0 ls2b wsb">ClosureExample02.htm </div></div></div>
<div id="pfc8" class="pf w0 h0" data-page-no="c8"><div class="pc pcc8 w0 h0"><div class="t m0 x0 h2 y1 ff2a fs0 fc0 sc0 ls7 ws0">182  第7章 函数表达式 </div><div class="t m0 x0 h3 y2 ff2a fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ff31 fs2 fc0 sc0 ls8 wseb">在重写了前面的createFunctions()函数后，每个函数就会返回各自不同的索引值了。在这个版</div><div class="t m0 x0 h4 y4d ff31 fs2 fc0 sc0 ls8 wseb">本中，我们没有直接把闭包赋值给数组，而是定义了一个匿名函数，并将立即执行该匿名函数的结果赋</div><div class="t m0 x0 h1c yd8 ff31 fs2 fc0 sc0 ls8 wseb">给数组。这里的匿名函数有一个参数num，也就是最终的函数要返回的值。在调用每个匿名函数时，我</div><div class="t m0 x0 h4 yd9 ff31 fs2 fc0 sc0 ls8 wseb">们传入了变量i。由于函数参数是按值传递的，所以就会将变量i的当前值复制给参数num。而在这个</div><div class="t m0 x0 h1e y15d ff31 fs2 fc0 sc0 ls8 wseb">匿名函数内部，又创建并返回了一个访问num的闭包。这样一来，result数组中的每个函数都有自己</div><div class="t m0 x0 h5 y8 ff32 fs1 fc0 sc0 ls9 ws2">num变量的一个副本，因此就可以返回各自不同的数值了。 </div><div class="t m0 x0 h20 yf25 ff2f fs3 fc0 sc0 ls4d ws40">7.2.2 关于this对象 </div><div class="t m0 x0 h4 yf26 ff31 fs2 fc0 sc0 ls8 wseb">在闭包中使用this对象也可能会导致一些问题。我们知道，this对象是在运行时基于函数的执</div><div class="t m0 x0 h1e yf27 ff31 fs2 fc0 sc0 ls8 wseb">行环境绑定的：在全局函数中，this等于window，而当函数被作为某个对象的方法调用时，this等</div><div class="t m0 x0 h4 yf28 ff31 fs2 fc0 sc0 ls8 wseb">于那个对象。不过，匿名函数的执行环境具有全局性，因此其this对象通常指向window①。但有时候</div><div class="t m0 x0 h5 yf29 ff31 fs2 fc0 sc0 ls8 wseb">由于编写闭包的方式不同，这一点可能不会那么明显。下面来看一个例子。 </div><div class="t m0 x0 hb yf2a ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yf2b ff32 fs6 fc0 sc0 ls21 wsb">var name = &quot;The Window&quot;; </div><div class="t m0 x0 hb yf2c ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yf2d ff32 fs6 fc0 sc0 ls21 wsb">var object = { </div><div class="t m0 x0 hb yf2e ff32 fs6 fc0 sc0 ls21 wsb">    name : &quot;My Object&quot;, </div><div class="t m0 x0 hb yf2f ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yf30 ff32 fs6 fc0 sc0 ls21 wsb">    getNameFunc : function(){ </div><div class="t m0 x0 hb yf31 ff32 fs6 fc0 sc0 ls21 wsb">        return function(){ </div><div class="t m0 x0 hb yf32 ff32 fs6 fc0 sc0 ls21 wsb">            return this.name; </div><div class="t m0 x0 hb yf33 ff32 fs6 fc0 sc0 ls21 wsb">        }; </div><div class="t m0 x0 hb yf34 ff32 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb yf35 ff32 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb yf36 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 yf37 ff32 fs6 fc0 sc0 ls21 wsb">alert(object.getNameFunc()());  //&quot;The Window&quot;（在非严格模式下） </div><div class="t m0 x0 hb yf38 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf yf39 ff34 fs2 fc0 sc0 ls25 wsb">ThisObjectExample01.htm </div><div class="t m0 x0 h4 yf3a ff31 fs2 fc0 sc0 ls8 wseb">以上代码先创建了一个全局变量name，又创建了一个包含name属性的对象。这个对象还包含一</div><div class="t m0 x0 h1e yf3b ff31 fs2 fc0 sc0 ls1f ws108">个方法——getNameFunc()，它返回一个匿名函数，而匿名函数又返回this.name。由于getNameFunc()</div><div class="t m0 x0 h4 yf3c ff31 fs2 fc0 sc0 ls8 wseb">返回一个函数，因此调用object.getNameFunc()()就会立即调用它返回的函数，结果就是返回一个</div><div class="t m0 x0 h1e yf3d ff31 fs2 fc0 sc0 ls8 wseb">字符串。然而，这个例子返回的字符串是&quot;The Window&quot;，即全局name变量的值。为什么匿名函数没</div><div class="t m0 x0 h5 yf3e ff31 fs2 fc0 sc0 ls8 wseb">有取得其包含作用域（或外部作用域）的this对象呢？ </div><div class="t m0 x0 h1e yf3f ff31 fs2 fc0 sc0 ls8 wseb">前面曾经提到过，每个函数在被调用时都会自动取得两个特殊变量：this和arguments。内部函</div><div class="t m0 x0 h4 yf40 ff31 fs2 fc0 sc0 ls8 wseb">数在搜索这两个变量时，只会搜索到其活动对象为止，因此永远不可能直接访问外部函数中的这两个变</div><div class="t m0 x0 h5 yf41 ff31 fs2 fc0 sc0 ls8 wseb">量（这一点通过图7-2可以看得更清楚）。不过，把外部作用域中的this对象保存在一个闭包能够访问</div><div class="t m0 x0 h5 yf42 ff31 fs2 fc0 sc0 ls8 wseb">到的变量里，就可以让闭包访问该对象了，如下所示。 </div><div class="t m0 x0 hb yf43 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yf44 ff32 fs6 fc0 sc0 ls21 wsb">var name = &quot;The Window&quot;; </div><div class="t m0 x0 hb yf45 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yf46 ff32 fs6 fc0 sc0 ls21 wsb">var object = { </div><div class="t m0 x0 hb yf47 ff32 fs6 fc0 sc0 ls21 wsb">    name : &quot;My Object&quot;, </div><div class="t m0 x0 hb yf48 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yf49 ff32 fs6 fc0 sc0 ls21 wsb">    getNameFunc : function(){ </div><div class="t m0 x0 h3c y2d6 ff2e fs2 fc0 sc0 ls7b wsb">—————————— </div><div class="t m0 x0 h36 ycc6 ff31 fs6 fc0 sc0 ls95">① 当然，在通过call()或apply()改变函数执行环境的情况下，this就会指向其他对象。 </div></div></div>
<div id="pfc9" class="pf w0 h0" data-page-no="c9"><div class="pc pcc9 w0 h0"><div class="t m0 x2 h2 y1 ff2a fs0 fc0 sc0 ls10 wsc">7.2 闭包  183 </div><div class="t m0 x0 h3 y2 ff2a fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff2c fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff2c fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff2c fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff2c fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff2c fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff2c fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff2c fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff2c fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff2c fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff2c fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff2c fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff2c fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff2c fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h15 y79 ff37 fs6 fc0 sc0 ls21 wsb">        var that = this; </div><div class="t m0 x0 hb y7a ff32 fs6 fc0 sc0 ls21 wsb">        return function(){ </div><div class="t m0 x0 h15 y7b ff37 fs6 fc0 sc0 ls21 wsb">            return that.name; </div><div class="t m0 x0 hb y7c ff32 fs6 fc0 sc0 ls21 wsb">        }; </div><div class="t m0 x0 hb y7d ff32 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y7e ff32 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y7f ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y80 ff32 fs6 fc0 sc0 ls21 wsb">alert(object.getNameFunc()());  //&quot;My Object&quot; </div><div class="t m0 x5 hb yf4a ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf yf4b ff34 fs2 fc0 sc0 ls25 wsb">ThisObjectExample02.htm </div><div class="t m0 x0 h4 yf4c ff31 fs2 fc0 sc0 ls8 wseb">代码中突出的行展示了这个例子与前一个例子之间的不同之处。在定义匿名函数之前，我们把this</div><div class="t m0 x0 h4 y871 ff31 fs2 fc0 sc0 ls8 wseb">对象赋值给了一个名叫that的变量。而在定义了闭包之后，闭包也可以访问这个变量，因为它是我们</div><div class="t m0 x0 h1e yf4d ff31 fs2 fc0 sc0 ls30 wsf6">在包含函数中特意声名的一个变量。即使在函数返回之后，that也仍然引用着object，所以调用</div><div class="t m0 x0 h5 yf4e ff32 fs1 fc0 sc0 ls9 ws2">object.getNameFunc()()就返回了&quot;My Object&quot;。 </div><div class="t m0 x5 ha yf4f ff32 fs1 fc0 sc0 ls9 ws2">this和arguments也存在同样的问题。如果想访问作用域中的arguments对</div><div class="t m0 x5 h5 yf50 ff2b fs2 fc0 sc0 ls8 ws14">象，必须将对该对象的引用保存到另一个闭包能够访问的变量中。 </div><div class="t m0 x0 h44 yf51 ff31 fs2 fc0 sc0 ls8 wseb">在几种特殊情况下，this的值可能会意外地改变。比如，下面的代码是修改前面例子的结果。 </div><div class="t m0 x0 hb yf52 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yf53 ff32 fs6 fc0 sc0 ls21 wsb">var name = &quot;The Window&quot;; </div><div class="t m0 x0 hb yf54 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yf55 ff32 fs6 fc0 sc0 ls21 wsb">var object = { </div><div class="t m0 x0 hb yf56 ff32 fs6 fc0 sc0 ls21 wsb">    name : &quot;My Object&quot;, </div><div class="t m0 x0 h15 yf57 ff37 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yf58 ff32 fs6 fc0 sc0 ls21 wsb">    getName: function(){ </div><div class="t m0 x0 hb yf59 ff32 fs6 fc0 sc0 ls21 wsb">        return this.name; </div><div class="t m0 x0 hb yf5a ff32 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb yf5b ff32 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 h4 yf5c ff31 fs2 fc0 sc0 ls8 wseb">这里的getName()方法只简单地返回this.name的值。以下是几种调用 object.getName()的</div><div class="t m0 x0 h5 yf5d ff31 fs2 fc0 sc0 ls8 wseb">方式以及各自的结果。 </div><div class="t m0 x0 hb yf5e ff32 fs6 fc0 sc0 ls21 wsb">object.getName();   //&quot;My Object&quot; </div><div class="t m0 x0 hb yf5f ff32 fs6 fc0 sc0 ls21 wsb">(object.getName)(); //&quot;My Object&quot; </div><div class="t m0 x0 h16 yf60 ff32 fs6 fc0 sc0 ls21 wsb">(object.getName = object.getName)(); //&quot;The Window&quot;，在非严格模式下 </div><div class="t m0 x0 hb yf61 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf yf62 ff34 fs2 fc0 sc0 ls25 wsb">ThisObjectExample03.htm </div><div class="t m0 x0 h4 yf63 ff31 fs2 fc0 sc0 ls5 wsec">第一行代码跟平常一样调用了object.getName()，返回的是&quot;My Object&quot;，因为this.name</div><div class="t m0 x0 h4 yf64 ff31 fs2 fc0 sc0 ls8 wseb">就是object.name。第二行代码在调用这个方法前先给它加上了括号。虽然加上括号之后，就好像只</div><div class="t m0 x0 h1e yf65 ff31 fs2 fc0 sc0 ls8 wseb">是在引用一个函数，但this的值得到了维持，因为object.getName 和(object.getName)的定义</div><div class="t m0 x0 h4 yf66 ff31 fs2 fc0 sc0 ls8 wseb">是相同的。第三行代码先执行了一条赋值语句，然后再调用赋值后的结果。因为这个赋值表达式的值是</div><div class="t m0 x0 hc yf67 ff31 fs2 fc0 sc0 ls8 wseb">函数本身，所以this的值不能得到维持，结果就返回了&quot;The Window&quot;。 </div><div class="t m0 x0 h4 yf68 ff31 fs2 fc0 sc0 ls8 wseb">当然，你不大可能会像第二行和第三行代码一样调用这个方法。不过，这个例子有助于说明即使是</div><div class="t m0 x0 he yf69 ff31 fs2 fc0 sc0 ls8 wseb">语法的细微变化，都有可能意外改变this的值。 </div><div class="t m0 x0 h20 yf6a ff2f fs3 fc0 sc0 ls4d ws40">7.2.3 内存泄漏 </div><div class="t m0 x0 h5 y103 ff31 fs2 fc0 sc0 ls8 wseb">由于IE9之前的版本对JScript对象和 COM对象使用不同的垃圾收集例程（第4章曾经讨论过），</div></div></div>
<div id="pfca" class="pf w0 h0" data-page-no="ca"><div class="pc pcca w0 h0"><div class="t m0 x0 h2 y1 ff2a fs0 fc0 sc0 ls7 ws0">184  第7章 函数表达式 </div><div class="t m0 x0 h3 y2 ff2a fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff31 fs2 fc0 sc0 ls30 wsf6">因此闭包在IE的这些版本中会导致一些特殊的问题。具体来说，如果闭包的作用域链中保存着一个</div><div class="t m0 x0 h5 y4d ff2a fs2 fc0 sc0 lsfa wsc9">HTML元素，那么就意味着该元素将无法被销毁。来看下面的例子。 </div><div class="t m0 x0 hb y2d8 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2d9 ff32 fs6 fc0 sc0 ls21 wsb">function assignHandler(){ </div><div class="t m0 x0 hb y2da ff32 fs6 fc0 sc0 ls21 wsb">    var element = document.getElementById(&quot;someElement&quot;); </div><div class="t m0 x0 hb y2db ff32 fs6 fc0 sc0 ls21 wsb">    element.onclick = function(){ </div><div class="t m0 x0 hb y2dc ff32 fs6 fc0 sc0 ls21 wsb">        alert(element.id); </div><div class="t m0 x0 hb y2dd ff32 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 hb y9e2 ff32 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h4 y4cd ff31 fs2 fc0 sc0 ls8 wseb">以上代码创建了一个作为element元素事件处理程序的闭包，而这个闭包则又创建了一个循环引</div><div class="t m0 x0 h5 yf6c ff31 fs2 fc0 sc0 ls8 wseb">用（事件将在第13章讨论）。由于匿名函数保存了一个对assignHandler()的活动对象的引用，因此</div><div class="t m0 x0 hc yf6d ff31 fs2 fc0 sc0 ls8 wseb">就会导致无法减少element的引用数。只要匿名函数存在，element的引用数至少也是 1，因此它所</div><div class="t m0 x0 h5 yf6e ff31 fs2 fc0 sc0 ls8 wseb">占用的内存就永远不会被回收。不过，这个问题可以通过稍微改写一下代码来解决，如下所示。 </div><div class="t m0 x0 hb yf6f ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yf70 ff32 fs6 fc0 sc0 ls21 wsb">function assignHandler(){ </div><div class="t m0 x0 hb yf71 ff32 fs6 fc0 sc0 ls21 wsb">    var element = document.getElementById(&quot;someElement&quot;); </div><div class="t m0 x0 h15 yf72 ff37 fs6 fc0 sc0 ls21 wsb">    var id = element.id; </div><div class="t m0 x0 hb yf73 ff32 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 hb yf74 ff32 fs6 fc0 sc0 ls21 wsb">    element.onclick = function(){ </div><div class="t m0 x0 h15 yf75 ff37 fs6 fc0 sc0 ls21 wsb">        alert(id); </div><div class="t m0 x0 hb yf76 ff32 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 hb yf77 ff32 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 h15 yf78 ff37 fs6 fc0 sc0 ls21 wsb">    element = null; </div><div class="t m0 x0 hb yf79 ff32 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h4 yf7a ff31 fs2 fc0 sc0 ls8 wseb">在上面的代码中，通过把element.id的一个副本保存在一个变量中，并且在闭包中引用该变量消</div><div class="t m0 x0 h4 yf7b ff31 fs2 fc0 sc0 ls8 wseb">除了循环引用。但仅仅做到这一步，还是不能解决内存泄漏的问题。必须要记住：闭包会引用包含函数</div><div class="t m0 x0 h1c yf7c ff31 fs2 fc0 sc0 ls8 wseb">的整个活动对象，而其中包含着element。即使闭包不直接引用element，包含函数的活动对象中也</div><div class="t m0 x0 hc yf7d ff31 fs2 fc0 sc0 ls8 wseb">仍然会保存一个引用。因此，有必要把element变量设置为null。这样就能够解除对DOM对象的引</div><div class="t m0 x0 h5 yf7e ff31 fs2 fc0 sc0 ls8 wseb">用，顺利地减少其引用数，确保正常回收其占用的内存。 </div><div class="t m0 x0 hd yf7f ff2f fs7 fc0 sc0 ls22">7.3 模仿块级作用域 </div><div class="t m0 x0 h5 yf80 ff31 fs2 fc0 sc0 ls6">如前所述，JavaScript没有块级作用域的概念。这意味着在块语句中定义的变量，实际上是在包含</div><div class="t m0 x0 h5 y72c ff31 fs2 fc0 sc0 ls8 wseb">函数中而非语句中创建的，来看下面的例子。 </div><div class="t m0 x0 hb yf81 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yf82 ff32 fs6 fc0 sc0 ls21 wsb">function outputNumbers(count){ </div><div class="t m0 x0 hb yf83 ff32 fs6 fc0 sc0 ls21 wsb">    for (var i=0; i &lt; count; i++){ </div><div class="t m0 x0 hb yf84 ff32 fs6 fc0 sc0 ls21 wsb">        alert(i); </div><div class="t m0 x0 hb yf85 ff32 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 h16 yf86 ff32 fs6 fc0 sc0 ls21 wsb">    alert(i);   //计数 </div><div class="t m0 x0 hb yf87 ff32 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x2 hf yf88 ff34 fs2 fc0 sc0 ls2b wsb">BlockScopeExample01.htm </div><div class="t m0 x0 h5 yf89 ff31 fs2 fc0 sc0 ls8 wseb">这个函数中定义了一个for循环，而变量i的初始值被设置为0。在 Java、C++等语言中，变量i</div><div class="t m0 x0 h5 yf8a ff31 fs2 fc0 sc0 ls8 wseb">只会在for循环的语句块中有定义，循环一旦结束，变量i就会被销毁。可是在JavaScrip 中，变量i</div><div class="t m0 x0 h4 yf8b ff31 fs2 fc0 sc0 ls8 wseb">是定义在ouputNumbers()的活动对象中的，因此从它有定义开始，就可以在函数内部随处访问它。即</div><div class="t m0 x0 h5 yf8c ff31 fs2 fc0 sc0 ls8 wseb">使像下面这样错误地重新声明同一个变量，也不会改变它的值。 </div><div class="t m0 x0 hb yf8d ff32 fs6 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pfcb" class="pf w0 h0" data-page-no="cb"><div class="pc pccb w0 h0"><div class="t m0 x2 h2 y1 ff2a fs0 fc0 sc0 ls10 wsc">7.3 模仿块级作用域    185 </div><div class="t m0 x0 h3 y2 ff2a fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff2c fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff2c fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff2c fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff2c fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff2c fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff2c fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff2c fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff2c fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff2c fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff2c fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff2c fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff2c fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff2c fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y44f ff32 fs6 fc0 sc0 ls21 wsb">function outputNumbers(count){ </div><div class="t m0 x0 hb y450 ff32 fs6 fc0 sc0 ls21 wsb">    for (var i=0; i &lt; count; i++){ </div><div class="t m0 x0 hb y451 ff32 fs6 fc0 sc0 ls21 wsb">        alert(i); </div><div class="t m0 x0 hb y452 ff32 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y453 ff32 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 h16 y454 ff37 fs6 fc0 sc0 ls21 wsb">    var i;       //重新声明变量 </div><div class="t m0 x0 h16 y455 ff32 fs6 fc0 sc0 ls21 wsb">    alert(i);    //计数 </div><div class="t m0 x0 hb y456 ff32 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x2 hf y457 ff34 fs2 fc0 sc0 ls2b wsb">BlockScopeExample02.htm </div><div class="t m0 x0 h5 y458 ff2a fs2 fc0 sc0 ls16b wsf0">JavaScript从来不会告诉你是否多次声明了同一个变量；遇到这种情况，它只会对后续的声明视而不</div><div class="t m0 x0 h5 y459 ff31 fs2 fc0 sc0 ls42 wsf0">见（不过，它会执行后续声明中的变量初始化）。匿名函数可以用来模仿块级作用域并避免这个问题。 </div><div class="t m0 x0 h5 y45a ff31 fs2 fc0 sc0 ls8 wseb">用作块级作用域（通常称为私有作用域）的匿名函数的语法如下所示。 </div><div class="t m0 x5 hb y1f9 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y45b ff32 fs6 fc0 sc0 ls21 wsb">(function(){ </div><div class="t m0 x0 h16 yf8e ff32 fs6 fc0 sc0 ls21 wsb">    //这里是块级作用域 </div><div class="t m0 x0 hb yf8f ff32 fs6 fc0 sc0 ls21 wsb">})(); </div><div class="t m0 x5 hb yf90 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 yf91 ff31 fs2 fc0 sc0 ls8 wseb">以上代码定义并立即调用了一个匿名函数。将函数声明包含在一对圆括号中，表示它实际上是一个</div><div class="t m0 x0 h4 yf92 ff31 fs2 fc0 sc0 ls8 wseb">函数表达式。而紧随其后的另一对圆括号会立即调用这个函数。如果有读者感觉这种语法不太好理解，</div><div class="t m0 x0 h5 yf93 ff31 fs2 fc0 sc0 ls8 wseb">可以再看看下面这个例子。 </div><div class="t m0 x5 hb yf94 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yf95 ff32 fs6 fc0 sc0 ls21 wsb">var count = 5; </div><div class="t m0 x0 hb yf96 ff32 fs6 fc0 sc0 ls21 wsb">outputNumbers(count); </div><div class="t m0 x5 hb yf97 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 yf98 ff31 fs2 fc0 sc0 ls8 wseb">这里初始化了变量count，将其值设置为5。当然，这里的变量是没有必要的，因为可以把值直接</div><div class="t m0 x0 hc yf99 ff31 fs2 fc0 sc0 ls8 wseb">传给函数。为了让代码更简洁，我们在调用函数时用5来代替变量count，如下所示。 </div><div class="t m0 x0 hb yf9a ff32 fs6 fc0 sc0 ls21 wsb">outputNumbers(5); </div><div class="t m0 x5 hb yf9b ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 yf9c ff31 fs2 fc0 sc0 ls8 wseb">这样做之所以可行，是因为变量只不过是值的另一种表现形式，因此用实际的值替换变量没有问题。</div><div class="t m0 x0 h5 y22b ff31 fs2 fc0 sc0 ls8 wseb">再看下面的例子。 </div><div class="t m0 x5 hb yf9d ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yf9e ff32 fs6 fc0 sc0 ls21 wsb">var someFunction = function(){ </div><div class="t m0 x0 h16 yf9f ff32 fs6 fc0 sc0 ls21 wsb">    //这里是块级作用域 </div><div class="t m0 x0 hb yfa0 ff32 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb yfa1 ff32 fs6 fc0 sc0 ls21 wsb">someFunction(); </div><div class="t m0 x5 hb yfa2 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y46b ff31 fs2 fc0 sc0 ls8 wseb">这个例子先定义了一个函数，然后立即调用了它。定义函数的方式是创建一个匿名函数，并把匿名</div><div class="t m0 x0 h4 yfa3 ff31 fs2 fc0 sc0 ls16c ws130">函数赋值给变量someFunction。而调用函数的方式是在函数名称后面添加一对圆括号，即</div><div class="t m0 x0 h4 yfa4 ff32 fs1 fc0 sc0 ls9 ws2">someFunction()。通过前面的例子我们知道，可以使用实际的值来取代变量count，那在这里是不是</div><div class="t m0 x0 h5 yfa5 ff31 fs2 fc0 sc0 ls8 wseb">也可以用函数的值直接取代函数名呢？ 然而，下面的代码却会导致错误。 </div><div class="t m0 x5 hb yfa6 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yfa7 ff32 fs6 fc0 sc0 ls21 wsb">function(){ </div><div class="t m0 x0 h16 yfa8 ff32 fs6 fc0 sc0 ls21 wsb">    //这里是块级作用域 </div><div class="t m0 x0 h16 yfa9 ff32 fs6 fc0 sc0 ls21 wsb">}();    //出错！ </div><div class="t m0 x5 hb yfaa ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 yfab ff31 fs2 fc0 sc0 ls8 wseb">这段代码会导致语法错误，是因为JavaScript将function关键字当作一个函数声明的开始，而函</div><div class="t m0 x0 h4 yfac ff31 fs2 fc0 sc0 ls8 wseb">数声明后面不能跟圆括号。然而，函数表达式的后面可以跟圆括号。要将函数声明转换成函数表达式，</div><div class="t m0 x0 h5 y6b9 ff31 fs2 fc0 sc0 ls8 wseb">只要像下面这样给它加上一对圆括号即可。 </div><div class="t m0 x5 hb yfad ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 yfae ff37 fs6 fc0 sc0 ls21 wsb">(function(){ </div><div class="t m0 x0 h16 yfaf ff32 fs6 fc0 sc0 ls21 wsb">    //这里是块级作用域 </div><div class="t m0 x0 h15 yfb0 ff37 fs6 fc0 sc0 ls21 wsb">})(); </div></div></div>
<div id="pfcc" class="pf w0 h0" data-page-no="cc"><div class="pc pccc w0 h0"><div class="t m0 x0 h2 y1 ff2a fs0 fc0 sc0 ls7 ws0">186  第7章 函数表达式 </div><div class="t m0 x0 h3 y2 ff2a fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff31 fs2 fc0 sc0 ls8 wseb">无论在什么地方，只要临时需要一些变量，就可以使用私有作用域，例如： </div><div class="t m0 x0 hb yfb2 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yfb3 ff32 fs6 fc0 sc0 ls21 wsb">function outputNumbers(count){ </div><div class="t m0 x0 h15 yfb4 ff37 fs6 fc0 sc0 ls21 wsb">    (function () { </div><div class="t m0 x0 hb yfb5 ff32 fs6 fc0 sc0 ls21 wsb">        for (var i=0; i &lt; count; i++){ </div><div class="t m0 x0 hb yfb6 ff32 fs6 fc0 sc0 ls21 wsb">            alert(i); </div><div class="t m0 x0 hb yfb7 ff32 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 h15 yfb8 ff37 fs6 fc0 sc0 ls21 wsb">    })(); </div><div class="t m0 x0 hb yfb9 ff32 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 h16 yfba ff32 fs6 fc0 sc0 ls21 wsb">    alert(i);   //导致一个错误！ </div><div class="t m0 x0 hb yfbb ff32 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x2 hf yfbc ff34 fs2 fc0 sc0 ls2b wsb">BlockScopeExample03.htm </div><div class="t m0 x0 h4 yfbd ff31 fs2 fc0 sc0 ls8 wseb">在这个重写后的outputNumbers()函数中，我们在for循环外部插入了一个私有作用域。在匿名</div><div class="t m0 x0 h1e yfbe ff31 fs2 fc0 sc0 ls8 wseb">函数中定义的任何变量，都会在执行结束时被销毁。因此，变量i只能在循环中使用，使用后即被销毁。</div><div class="t m0 x0 h4 yfbf ff31 fs2 fc0 sc0 ls8 wseb">而在私有作用域中能够访问变量count，是因为这个匿名函数是一个闭包，它能够访问包含作用域中的</div><div class="t m0 x0 h5 yfc0 ff31 fs2 fc0 sc0 ls8 wseb">所有变量。 </div><div class="t m0 x0 h4 yfc1 ff31 fs2 fc0 sc0 ls8 wseb">这种技术经常在全局作用域中被用在函数外部，从而限制向全局作用域中添加过多的变量和函数。</div><div class="t m0 x0 h4 yfc2 ff31 fs2 fc0 sc0 ls8 wseb">一般来说，我们都应该尽量少向全局作用域中添加变量和函数。在一个由很多开发人员共同参与的大型</div><div class="t m0 x0 h4 yfc3 ff31 fs2 fc0 sc0 ls8 wseb">应用程序中，过多的全局变量和函数很容易导致命名冲突。而通过创建私有作用域，每个开发人员既可</div><div class="t m0 x0 h5 yfc4 ff31 fs2 fc0 sc0 ls8 wseb">以使用自己的变量，又不必担心搞乱全局作用域。例如： </div><div class="t m0 x0 hb ydaa ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yfc5 ff32 fs6 fc0 sc0 ls21 wsb">(function(){ </div><div class="t m0 x0 hb yfc6 ff32 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 hb yfc7 ff32 fs6 fc0 sc0 ls21 wsb">    var now = new Date(); </div><div class="t m0 x0 hb yfc8 ff32 fs6 fc0 sc0 ls21 wsb">    if (now.getMonth() == 0 &amp;&amp; now.getDate() == 1){ </div><div class="t m0 x0 hb yfc9 ff32 fs6 fc0 sc0 ls21 wsb">        alert(&quot;Happy new year!&quot;); </div><div class="t m0 x0 hb yfca ff32 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb yfcb ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yfcc ff32 fs6 fc0 sc0 ls21 wsb">})(); </div><div class="t m0 x0 hb yfcd ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 yfce ff31 fs2 fc0 sc0 ls8 wseb">把上面这段代码放在全局作用域中，可以用来确定哪一天是1月1日；如果到了这一天，就会向用</div><div class="t m0 x0 h4 yfcf ff31 fs2 fc0 sc0 ls8 wseb">户显示一条祝贺新年的消息。其中的变量now现在是匿名函数中的局部变量，而我们不必在全局作用域</div><div class="t m0 x0 h5 yfd0 ff31 fs2 fc0 sc0 ls8 wseb">中创建它。 </div><div class="t m0 x5 ha yfd1 ff2b fs2 fc0 sc0 ls8 ws14">这种做法可以减少闭包占用的内存问题，因为没有指向匿名函数的引用。只要函</div><div class="t m0 x0 h5 yfd2 ff2b fs2 fc0 sc0 ls8 ws14">数执行完毕，就可以立即销毁其作用域链了。 </div><div class="t m0 x0 hd yfd3 ff2f fs7 fc0 sc0 ls22">7.4 私有变量 </div><div class="t m0 x0 h5 yfd4 ff31 fs2 fc0 sc0 ls6">严格来讲，JavaScript中没有私有成员的概念；所有对象属性都是公有的。不过，倒是有一个私有</div><div class="t m0 x0 h4 y215 ff31 fs2 fc0 sc0 ls8 wseb">变量的概念。任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数的外部访问这些变量。</div><div class="t m0 x0 h5 yfd5 ff31 fs2 fc0 sc0 ls8 wseb">私有变量包括函数的参数、局部变量和在函数内部定义的其他函数。来看下面的例子： </div><div class="t m0 x0 hb yfd6 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yfd7 ff32 fs6 fc0 sc0 ls21 wsb">function add(num1, num2){ </div><div class="t m0 x0 hb yfd8 ff32 fs6 fc0 sc0 ls21 wsb">    var sum = num1 + num2; </div><div class="t m0 x0 hb yfd9 ff32 fs6 fc0 sc0 ls21 wsb">    return sum; </div><div class="t m0 x0 hb yfda ff32 fs6 fc0 sc0 ls21 wsb">} </div></div></div>
<div id="pfcd" class="pf w0 h0" data-page-no="cd"><div class="pc pccd w0 h0"><div class="t m0 x2 h2 y1 ff2a fs0 fc0 sc0 ls10 wsc">7.4 私有变量    187 </div><div class="t m0 x0 h3 y2 ff2a fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff2c fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff2c fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff2c fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff2c fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff2c fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff2c fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff2c fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff2c fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff2c fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff2c fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff2c fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff2c fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff2c fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff31 fs2 fc0 sc0 ls8 wseb">在这个函数内部，有3个私有变量：num1、num2和sum。在函数内部可以访问这几个变量，但在</div><div class="t m0 x0 h4 y4d ff31 fs2 fc0 sc0 ls8 wseb">函数外部则不能访问它们。如果在这个函数内部创建一个闭包，那么闭包通过自己的作用域链也可以访</div><div class="t m0 x0 h5 yd8 ff31 fs2 fc0 sc0 ls8 wseb">问这些变量。而利用这一点，就可以创建用于访问私有变量的公有方法。 </div><div class="t m0 x0 h5 y28b ff31 fs2 fc0 sc0 ls8 wseb">我们把有权访问私有变量和私有函数的公有方法称为特权方法（privileged method）。有两种在对象</div><div class="t m0 x0 h5 yfdb ff31 fs2 fc0 sc0 ls8 wseb">上创建特权方法的方式。第一种是在构造函数中定义特权方法，基本模式如下。 </div><div class="t m0 x5 hb y4ef ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yfdc ff32 fs6 fc0 sc0 ls21 wsb">function MyObject(){ </div><div class="t m0 x0 hb yfdd ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 yfde ff32 fs6 fc0 sc0 ls21 wsb">    //私有变量和私有函数 </div><div class="t m0 x0 hb yfdf ff32 fs6 fc0 sc0 ls21 wsb">    var privateVariable = 10; </div><div class="t m0 x0 hb yfe0 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yfe1 ff32 fs6 fc0 sc0 ls21 wsb">    function privateFunction(){ </div><div class="t m0 x0 hb yfe2 ff32 fs6 fc0 sc0 ls21 wsb">        return false; </div><div class="t m0 x0 hb yfe3 ff32 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb yfe4 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 yfe5 ff32 fs6 fc0 sc0 ls21 wsb">    //特权方法 </div><div class="t m0 x0 hb yfe6 ff32 fs6 fc0 sc0 ls21 wsb">    this.publicMethod = function (){ </div><div class="t m0 x0 hb yfe7 ff32 fs6 fc0 sc0 ls21 wsb">        privateVariable++; </div><div class="t m0 x0 hb yfe8 ff32 fs6 fc0 sc0 ls21 wsb">        return privateFunction(); </div><div class="t m0 x0 hb yfe9 ff32 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 hb yfea ff32 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h4 yfeb ff31 fs2 fc0 sc0 ls8 wseb">这个模式在构造函数内部定义了所有私有变量和函数。然后，又继续创建了能够访问这些私有成员</div><div class="t m0 x0 h4 yfec ff31 fs2 fc0 sc0 ls8 wseb">的特权方法。能够在构造函数中定义特权方法，是因为特权方法作为闭包有权访问在构造函数中定义的</div><div class="t m0 x0 h1c yfed ff31 fs2 fc0 sc0 ls8 wseb">所有变量和函数。对这个例子而言，变量privateVariable和函数privateFunction()只能通过特</div><div class="t m0 x0 h4 yfee ff31 fs2 fc0 sc0 ls8 wseb">权方法publicMethod()来访问。在创建MyObject的实例后，除了使用 publicMethod()这一个途</div><div class="t m0 x0 hc yfef ff31 fs2 fc0 sc0 ls8 wseb">径外，没有任何办法可以直接访问privateVariable和privateFunction()。 </div><div class="t m0 x0 h5 yff0 ff31 fs2 fc0 sc0 ls8 wseb">利用私有和特权成员，可以隐藏那些不应该被直接修改的数据，例如： </div><div class="t m0 x5 hb yff1 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yff2 ff32 fs6 fc0 sc0 ls21 wsb">function Person(name){ </div><div class="t m0 x0 hb yff3 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yff4 ff32 fs6 fc0 sc0 ls21 wsb">    this.getName = function(){ </div><div class="t m0 x0 hb yff5 ff32 fs6 fc0 sc0 ls21 wsb">        return name; </div><div class="t m0 x0 hb yff6 ff32 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 hb yff7 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yff8 ff32 fs6 fc0 sc0 ls21 wsb">    this.setName = function (value) { </div><div class="t m0 x0 hb yff9 ff32 fs6 fc0 sc0 ls21 wsb">        name = value; </div><div class="t m0 x0 hb yffa ff32 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 hb yffb ff32 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb yffc ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yffd ff32 fs6 fc0 sc0 ls21 wsb">var person = new Person(&quot;Nicholas&quot;); </div><div class="t m0 x0 hb yffe ff32 fs6 fc0 sc0 ls21 wsb">alert(person.getName());   //&quot;Nicholas&quot; </div><div class="t m0 x0 hb yfff ff32 fs6 fc0 sc0 ls21 wsb">person.setName(&quot;Greg&quot;); </div><div class="t m0 x0 hb y1000 ff32 fs6 fc0 sc0 ls21 wsb">alert(person.getName());   //&quot;Greg&quot; </div><div class="t m0 x5 hb y1001 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1002 ff34 fs2 fc0 sc0 ls7a wsb">PrivilegedMethodExample01.htm </div><div class="t m0 x0 h4 y1003 ff31 fs2 fc0 sc0 ls8 wseb">以上代码的构造函数中定义了两个特权方法：getName()和setName()。这两个方法都可以在构</div><div class="t m0 x0 h1e y1004 ff31 fs2 fc0 sc0 ls8 wseb">造函数外部使用，而且都有权访问私有变量name。但在Person构造函数外部，没有任何办法访问name。</div><div class="t m0 x0 h1e y1005 ff31 fs2 fc0 sc0 ls8 wseb">由于这两个方法是在构造函数内部定义的，它们作为闭包能够通过作用域链访问name。私有变量name</div><div class="t m0 x0 h4 y1006 ff31 fs2 fc0 sc0 ls2c">在Person的每一个实例中都不相同，因为每次调用构造函数都会重新创建这两个方法。不过，在构造</div></div></div>
<div id="pfce" class="pf w0 h0" data-page-no="ce"><div class="pc pcce w0 h0"><div class="t m0 x0 h2 y1 ff2a fs0 fc0 sc0 ls7 ws0">188  第7章 函数表达式 </div><div class="t m0 x0 h3 y2 ff2a fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff31 fs2 fc0 sc0 ls8 wseb">函数中定义特权方法也有一个缺点，那就是你必须使用构造函数模式来达到这个目的。第6章曾经讨论</div><div class="t m0 x0 h4 y4d ff31 fs2 fc0 sc0 ls8 wseb">过，构造函数模式的缺点是针对每个实例都会创建同样一组新方法，而使用静态私有变量来实现特权方</div><div class="t m0 x0 h5 yd8 ff31 fs2 fc0 sc0 ls8 wseb">法就可以避免这个问题。 </div><div class="t m0 x0 h20 y1008 ff2f fs3 fc0 sc0 ls4d ws40">7.4.1 静态私有变量 </div><div class="t m0 x0 h5 y1f4 ff31 fs2 fc0 sc0 ls8 wseb">通过在私有作用域中定义私有变量或函数，同样也可以创建特权方法，其基本模式如下所示。 </div><div class="t m0 x0 hb y1009 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y100a ff32 fs6 fc0 sc0 ls21 wsb">(function(){ </div><div class="t m0 x0 hb y100b ff32 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 h16 y100c ff32 fs6 fc0 sc0 ls21 wsb">    //私有变量和私有函数 </div><div class="t m0 x0 hb y100d ff32 fs6 fc0 sc0 ls21 wsb">    var privateVariable = 10; </div><div class="t m0 x0 hb y100e ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y100f ff32 fs6 fc0 sc0 ls21 wsb">    function privateFunction(){ </div><div class="t m0 x0 hb y1010 ff32 fs6 fc0 sc0 ls21 wsb">        return false; </div><div class="t m0 x0 hb y1011 ff32 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y1012 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1013 ff32 fs6 fc0 sc0 ls21 wsb">    //构造函数 </div><div class="t m0 x0 hb y1014 ff32 fs6 fc0 sc0 ls21 wsb">    MyObject = function(){ </div><div class="t m0 x0 hb y1015 ff32 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 hb y1016 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1017 ff32 fs6 fc0 sc0 ls21 wsb">    //公有/特权方法 </div><div class="t m0 x0 hb y1018 ff32 fs6 fc0 sc0 ls21 wsb">    MyObject.prototype.publicMethod = function(){ </div><div class="t m0 x0 hb y1019 ff32 fs6 fc0 sc0 ls21 wsb">        privateVariable++; </div><div class="t m0 x0 hb y101a ff32 fs6 fc0 sc0 ls21 wsb">        return privateFunction(); </div><div class="t m0 x0 hb y101b ff32 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 hb y101c ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y101d ff32 fs6 fc0 sc0 ls21 wsb">})(); </div><div class="t m0 x0 hb y101e ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y101f ff31 fs2 fc0 sc0 ls8 wseb">这个模式创建了一个私有作用域，并在其中封装了一个构造函数及相应的方法。在私有作用域中，</div><div class="t m0 x0 h4 y1020 ff31 fs2 fc0 sc0 ls8 wseb">首先定义了私有变量和私有函数，然后又定义了构造函数及其公有方法。公有方法是在原型上定义的，</div><div class="t m0 x0 h4 y1021 ff31 fs2 fc0 sc0 ls8 wseb">这一点体现了典型的原型模式。需要注意的是，这个模式在定义构造函数时并没有使用函数声明，而是</div><div class="t m0 x0 h4 y1022 ff31 fs2 fc0 sc0 ls8 wseb">使用了函数表达式。函数声明只能创建局部函数，但那并不是我们想要的。出于同样的原因，我们也没</div><div class="t m0 x0 h4b y1023 ff31 fs2 fc0 sc0 ls8 wseb">有在声明MyObject时使用var 关键字。记住：初始化未经声明的变量，总是会创建一个全局变量。</div><div class="t m0 x0 h1e y1024 ff31 fs2 fc0 sc0 ls8 wseb">因此，MyObject就成了一个全局变量，能够在私有作用域之外被访问到。但也要知道，在严格模式下</div><div class="t m0 x0 h5 y1025 ff31 fs2 fc0 sc0 ls8 wseb">给未经声明的变量赋值会导致错误。 </div><div class="t m0 x0 h4 y1026 ff31 fs2 fc0 sc0 ls8 wseb">这个模式与在构造函数中定义特权方法的主要区别，就在于私有变量和函数是由实例共享的。由于</div><div class="t m0 x0 h4 y1027 ff31 fs2 fc0 sc0 ls8 wseb">特权方法是在原型上定义的，因此所有实例都使用同一个函数。而这个特权方法，作为一个闭包，总是</div><div class="t m0 x0 h5 y1028 ff31 fs2 fc0 sc0 ls8 wseb">保存着对包含作用域的引用。来看一看下面的代码。 </div><div class="t m0 x0 hb y1029 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y102a ff32 fs6 fc0 sc0 ls21 wsb">(function(){ </div><div class="t m0 x0 hb y102b ff32 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 hb y102c ff32 fs6 fc0 sc0 ls21 wsb">    var name = &quot;&quot;; </div><div class="t m0 x0 hb y102d ff32 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 hb y102e ff32 fs6 fc0 sc0 ls21 wsb">    Person = function(value){ </div><div class="t m0 x0 hb y102f ff32 fs6 fc0 sc0 ls21 wsb">        name = value; </div><div class="t m0 x0 hb y1030 ff32 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 hb y1031 ff32 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 hb y1032 ff32 fs6 fc0 sc0 ls21 wsb">    Person.prototype.getName = function(){ </div><div class="t m0 x0 hb y1033 ff32 fs6 fc0 sc0 ls21 wsb">        return name; </div><div class="t m0 x0 hb y1034 ff32 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 hb y1035 ff32 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 hb y1036 ff32 fs6 fc0 sc0 ls21 wsb">    Person.prototype.setName = function (value){ </div></div></div>
<div id="pfcf" class="pf w0 h0" data-page-no="cf"><div class="pc pccf w0 h0"><div class="t m0 x2 h2 y1 ff2a fs0 fc0 sc0 ls10 wsc">7.4 私有变量    189 </div><div class="t m0 x0 h3 y2 ff2a fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff2c fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff2c fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff2c fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff2c fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff2c fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff2c fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff2c fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff2c fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff2c fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff2c fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff2c fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff2c fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff2c fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y8f5 ff32 fs6 fc0 sc0 ls21 wsb">        name = value; </div><div class="t m0 x0 hb y8f6 ff32 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 hb y8f7 ff32 fs6 fc0 sc0 ls21 wsb">})(); </div><div class="t m0 x0 hb y8f8 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y8f9 ff32 fs6 fc0 sc0 ls21 wsb">var person1 = new Person(&quot;Nicholas&quot;); </div><div class="t m0 x0 hb y8fa ff32 fs6 fc0 sc0 ls21 wsb">alert(person1.getName());  //&quot;Nicholas&quot; </div><div class="t m0 x0 hb y8fb ff32 fs6 fc0 sc0 ls21 wsb">person1.setName(&quot;Greg&quot;); </div><div class="t m0 x0 hb y8fc ff32 fs6 fc0 sc0 ls21 wsb">alert(person1.getName());  //&quot;Greg&quot; </div><div class="t m0 x0 hb y8fd ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1037 ff32 fs6 fc0 sc0 ls21 wsb">var person2 = new Person(&quot;Michael&quot;); </div><div class="t m0 x0 hb y1038 ff32 fs6 fc0 sc0 ls21 wsb">alert(person1.getName()); //&quot;Michael&quot; </div><div class="t m0 x0 hb y1039 ff32 fs6 fc0 sc0 ls21 wsb">alert(person2.getName()); //&quot;Michael&quot; </div><div class="t m0 x5 hb y103a ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y103b ff34 fs2 fc0 sc0 ls7a wsb">PrivilegedMethodExample02.htm </div><div class="t m0 x0 h4 y103c ff31 fs2 fc0 sc0 ls8 wseb">这个例子中的Person构造函数与getName()和setName()方法一样，都有权访问私有变量name。</div><div class="t m0 x0 h1e y103d ff31 fs2 fc0 sc0 ls8 wseb">在这种模式下，变量name就变成了一个静态的、由所有实例共享的属性。也就是说，在一个实例上调</div><div class="t m0 x0 h1e y103e ff31 fs2 fc0 sc0 ls16e">用setName()会影响所有实例。而调用setName()或新建一个Person实例都会赋予name 属性一个</div><div class="t m0 x0 h5 y103f ff31 fs2 fc0 sc0 ls8 wseb">新值。结果就是所有实例都会返回相同的值。 </div><div class="t m0 x0 h4 y1040 ff31 fs2 fc0 sc0 ls24 wsf5">以这种方式创建静态私有变量会因为使用原型而增进代码复用，但每个实例都没有自己的私有变</div><div class="t m0 x0 h5 y1041 ff31 fs2 fc0 sc0 ls8 wseb">量。到底是使用实例变量，还是静态私有变量，最终还是要视你的具体需求而定。 </div><div class="t m0 x5 ha y1042 ff2b fs2 fc0 sc0 ls8 ws14">多查找作用域链中的一个层次，就会在一定程度上影响查找速度。而这正是使用</div><div class="t m0 x5 h5 y1043 ff2b fs2 fc0 sc0 ls8 ws14">闭包和私有变量的一个显明的不足之处。 </div><div class="t m0 x0 h20 y1044 ff2f fs3 fc0 sc0 ls4d ws40">7.4.2 模块模式 </div><div class="t m0 x0 h5 y1045 ff31 fs2 fc0 sc0 ls8 wseb">前面的模式是用于为自定义类型创建私有变量和特权方法的。而道格拉斯所说的模块模式（module </div><div class="t m0 x0 h5 y1046 ff2a fs2 fc0 sc0 ls2f ws8a">pattern）则是为单例创建私有变量和特权方法。所谓单例（singleton），指的就是只有一个实例的对象。</div><div class="t m0 x0 h5 y1047 ff31 fs2 fc0 sc0 ls8 wseb">按照惯例，JavaScript是以对象字面量的方式来创建单例对象的。 </div><div class="t m0 x5 hb y1048 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1049 ff32 fs6 fc0 sc0 ls21 wsb">var singleton = { </div><div class="t m0 x0 hb y104a ff32 fs6 fc0 sc0 ls21 wsb">    name : value, </div><div class="t m0 x0 hb y104b ff32 fs6 fc0 sc0 ls21 wsb">    method : function () { </div><div class="t m0 x0 h16 y104c ff32 fs6 fc0 sc0 ls21 wsb">        //这里是方法的代码 </div><div class="t m0 x0 hb y104d ff32 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y104e ff32 fs6 fc0 sc0 ls21 wsb">};  </div><div class="t m0 x0 h5 y104f ff31 fs2 fc0 sc0 ls8 wseb">模块模式通过为单例添加私有变量和特权方法能够使其得到增强，其语法形式如下： </div><div class="t m0 x5 hb y1050 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1051 ff32 fs6 fc0 sc0 ls21 wsb">var singleton = function(){ </div><div class="t m0 x0 hb y1052 ff32 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 h16 y1053 ff32 fs6 fc0 sc0 ls21 wsb">    //私有变量和私有函数 </div><div class="t m0 x0 hb y1054 ff32 fs6 fc0 sc0 ls21 wsb">    var privateVariable = 10; </div><div class="t m0 x0 hb y1055 ff32 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 hb y1056 ff32 fs6 fc0 sc0 ls21 wsb">    function privateFunction(){ </div><div class="t m0 x0 hb y1057 ff32 fs6 fc0 sc0 ls21 wsb">        return false; </div><div class="t m0 x0 hb y1058 ff32 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y1059 ff32 fs6 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pfd0" class="pf w0 h0" data-page-no="d0"><div class="pc pcd0 w0 h0"><div class="t m0 x0 h2 y1 ff2a fs0 fc0 sc0 ls7 ws0">190  第7章 函数表达式 </div><div class="t m0 x0 h3 y2 ff2a fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y8f5 ff32 fs6 fc0 sc0 ls21 wsb">    //特权/公有方法和属性 </div><div class="t m0 x0 hb y8f6 ff32 fs6 fc0 sc0 ls21 wsb">    return { </div><div class="t m0 x0 hb y8f7 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y8f8 ff32 fs6 fc0 sc0 ls21 wsb">        publicProperty: true, </div><div class="t m0 x0 hb y8f9 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y8fa ff32 fs6 fc0 sc0 ls21 wsb">        publicMethod : function(){ </div><div class="t m0 x0 hb y8fb ff32 fs6 fc0 sc0 ls21 wsb">            privateVariable++; </div><div class="t m0 x0 hb y8fc ff32 fs6 fc0 sc0 ls21 wsb">            return privateFunction(); </div><div class="t m0 x0 hb y8fd ff32 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y1037 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1038 ff32 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 hb y1039 ff32 fs6 fc0 sc0 ls21 wsb">}();  </div><div class="t m0 x0 h4 y105b ff31 fs2 fc0 sc0 ls8 wseb">这个模块模式使用了一个返回对象的匿名函数。在这个匿名函数内部，首先定义了私有变量和函数。</div><div class="t m0 x0 h4 y105c ff31 fs2 fc0 sc0 ls8 wseb">然后，将一个对象字面量作为函数的值返回。返回的对象字面量中只包含可以公开的属性和方法。由于</div><div class="t m0 x0 h4 y105d ff31 fs2 fc0 sc0 ls8 wseb">这个对象是在匿名函数内部定义的，因此它的公有方法有权访问私有变量和函数。从本质上来讲，这个</div><div class="t m0 x0 h4 y105e ff31 fs2 fc0 sc0 ls8 wseb">对象字面量定义的是单例的公共接口。这种模式在需要对单例进行某些初始化，同时又需要维护其私有</div><div class="t m0 x0 h5 y105f ff31 fs2 fc0 sc0 ls8 wseb">变量时是非常有用的，例如： </div><div class="t m0 x0 hb y1060 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1061 ff32 fs6 fc0 sc0 ls21 wsb">var application = function(){ </div><div class="t m0 x0 hb y1062 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1063 ff32 fs6 fc0 sc0 ls21 wsb">    //私有变量和函数 </div><div class="t m0 x0 hb y1064 ff32 fs6 fc0 sc0 ls21 wsb">    var components = new Array(); </div><div class="t m0 x0 hb y1065 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1066 ff32 fs6 fc0 sc0 ls21 wsb">    //初始化 </div><div class="t m0 x0 hb y1067 ff32 fs6 fc0 sc0 ls21 wsb">    components.push(new BaseComponent()); </div><div class="t m0 x0 hb y1068 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1069 ff32 fs6 fc0 sc0 ls21 wsb">    //公共 </div><div class="t m0 x0 hb y106a ff32 fs6 fc0 sc0 ls21 wsb">    return { </div><div class="t m0 x0 hb y106b ff32 fs6 fc0 sc0 ls21 wsb">        getComponentCount : function(){ </div><div class="t m0 x0 hb y106c ff32 fs6 fc0 sc0 ls21 wsb">            return components.length; </div><div class="t m0 x0 hb y106d ff32 fs6 fc0 sc0 ls21 wsb">        }, </div><div class="t m0 x0 hb y106e ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y106f ff32 fs6 fc0 sc0 ls21 wsb">        registerComponent : function(component){ </div><div class="t m0 x0 hb y1070 ff32 fs6 fc0 sc0 ls21 wsb">            if (typeof component == &quot;object&quot;){ </div><div class="t m0 x0 hb y1071 ff32 fs6 fc0 sc0 ls21 wsb">                components.push(component); </div><div class="t m0 x0 hb y1072 ff32 fs6 fc0 sc0 ls21 wsb">            } </div><div class="t m0 x0 hb y1073 ff32 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y1074 ff32 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 hb y1075 ff32 fs6 fc0 sc0 ls21 wsb">}(); </div><div class="t m0 x0 hb y1076 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1077 ff34 fs2 fc0 sc0 ls2e wsb">ModulePatternExample01.htm </div><div class="t m0 x0 h5 y1078 ff31 fs2 fc0 sc0 lsd0">在Web应用程序中，经常需要使用一个单例来管理应用程序级的信息。这个简单的例子创建了一</div><div class="t m0 x0 h4 y1079 ff31 fs2 fc0 sc0 ls8 wseb">个用于管理组件的application对象。在创建这个对象的过程中，首先声明了一个私有的components</div><div class="t m0 x0 h4 y107a ff31 fs2 fc0 sc0 ls5c ws10f">数组，并向数组中添加了一个BaseComponent的新实例（在这里不需要关心BaseComponent 的代码，我</div><div class="t m0 x0 h1e y107b ff31 fs2 fc0 sc0 ls5c ws10f">们只是用它来展示初始化操作）。而返回对象的getComponentCount()和registerComponent()方法，都</div><div class="t m0 x0 hc y107c ff31 fs2 fc0 sc0 ls5c ws10f">是有权访问数组components的特权方法。前者只是返回已注册的组件数目，后者用于注册新组件。 </div><div class="t m0 x0 h4 y107d ff31 fs2 fc0 sc0 ls1f ws108">简言之，如果必须创建一个对象并以某些数据对其进行初始化，同时还要公开一些能够访问这些私有</div><div class="t m0 x0 h1e y107e ff31 fs2 fc0 sc0 ls1f ws108">数据的方法，那么就可以使用模块模式。以这种模式创建的每个单例都是Object的实例，因为最终要通</div><div class="t m0 x0 h4 y107f ff31 fs2 fc0 sc0 ls1f ws108">过一个对象字面量来表示它。事实上，这也没有什么；毕竟，单例通常都是作为全局对象存在的，我们不</div><div class="t m0 x0 he y1080 ff31 fs2 fc0 sc0 ls1f ws108">会将它传递给一个函数。因此，也就没有什么必要使用instanceof操作符来检查其对象类型了。 </div></div></div>
<div id="pfd1" class="pf w0 h0" data-page-no="d1"><div class="pc pcd1 w0 h0"><div class="t m0 x2 h2 y1 ff2a fs0 fc0 sc0 ls10 wsc">7.4 私有变量    191 </div><div class="t m0 x0 h3 y2 ff2a fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff2c fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff2c fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff2c fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff2c fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff2c fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff2c fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff2c fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff2c fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff2c fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff2c fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff2c fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff2c fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff2c fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h20 y12d ff2f fs3 fc0 sc0 ls4d ws40">7.4.3 增强的模块模式 </div><div class="t m0 x0 h4 y12e ff31 fs2 fc0 sc0 ls8 wseb">有人进一步改进了模块模式，即在返回对象之前加入对其增强的代码。这种增强的模块模式适合那</div><div class="t m0 x0 h4 y12f ff31 fs2 fc0 sc0 ls8 wseb">些单例必须是某种类型的实例，同时还必须添加某些属性和（或）方法对其加以增强的情况。来看下面</div><div class="t m0 x0 h5 y130 ff31 fs2 fc0 sc0 ls8">的例子。 </div><div class="t m0 x5 hb y32f ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1081 ff32 fs6 fc0 sc0 ls21 wsb">var singleton = function(){ </div><div class="t m0 x0 hb y1082 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1083 ff32 fs6 fc0 sc0 ls21 wsb">    //私有变量和私有函数 </div><div class="t m0 x0 hb y1084 ff32 fs6 fc0 sc0 ls21 wsb">    var privateVariable = 10; </div><div class="t m0 x0 hb y1085 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1086 ff32 fs6 fc0 sc0 ls21 wsb">    function privateFunction(){ </div><div class="t m0 x0 hb y1087 ff32 fs6 fc0 sc0 ls21 wsb">        return false; </div><div class="t m0 x0 hb y1088 ff32 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y1089 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y108a ff32 fs6 fc0 sc0 ls21 wsb">    //创建对象 </div><div class="t m0 x0 hb y108b ff32 fs6 fc0 sc0 ls21 wsb">    var object = new CustomType(); </div><div class="t m0 x0 hb y108c ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y108d ff32 fs6 fc0 sc0 ls21 wsb">    //添加特权/公有属性和方法 </div><div class="t m0 x0 hb y108e ff32 fs6 fc0 sc0 ls21 wsb">    object.publicProperty = true; </div><div class="t m0 x0 hb y108f ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1090 ff32 fs6 fc0 sc0 ls21 wsb">    object.publicMethod = function(){ </div><div class="t m0 x0 hb y1091 ff32 fs6 fc0 sc0 ls21 wsb">        privateVariable++; </div><div class="t m0 x0 hb y1092 ff32 fs6 fc0 sc0 ls21 wsb">        return privateFunction(); </div><div class="t m0 x0 hb y1093 ff32 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 hb y1094 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1095 ff32 fs6 fc0 sc0 ls21 wsb">    //返回这个对象 </div><div class="t m0 x0 hb y1096 ff32 fs6 fc0 sc0 ls21 wsb">    return object; </div><div class="t m0 x0 hb y1097 ff32 fs6 fc0 sc0 ls21 wsb">}();  </div><div class="t m0 x0 h4 yc63 ff31 fs2 fc0 sc0 ls8 wseb">如果前面演示模块模式的例子中的application对象必须是BaseComponent的实例，那么就可</div><div class="t m0 x0 h5 yc64 ff31 fs2 fc0 sc0 ls8 wseb">以使用以下代码。 </div><div class="t m0 x5 hb y24e ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1098 ff32 fs6 fc0 sc0 ls21 wsb">var application = function(){ </div><div class="t m0 x0 hb y1099 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y109a ff32 fs6 fc0 sc0 ls21 wsb">    //私有变量和函数 </div><div class="t m0 x0 hb y109b ff32 fs6 fc0 sc0 ls21 wsb">    var components = new Array(); </div><div class="t m0 x0 hb y109c ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y109d ff32 fs6 fc0 sc0 ls21 wsb">    //初始化 </div><div class="t m0 x0 hb y109e ff32 fs6 fc0 sc0 ls21 wsb">    components.push(new BaseComponent()); </div><div class="t m0 x0 hb y109f ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y10a0 ff32 fs6 fc0 sc0 ls21 wsb">    //创建application的一个局部副本 </div><div class="t m0 x0 hb y10a1 ff32 fs6 fc0 sc0 ls21 wsb">    var app = new BaseComponent(); </div><div class="t m0 x0 hb y10a2 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y10a3 ff32 fs6 fc0 sc0 ls21 wsb">    //公共接口 </div><div class="t m0 x0 hb y10a4 ff32 fs6 fc0 sc0 ls21 wsb">    app.getComponentCount = function(){ </div><div class="t m0 x0 hb y10a5 ff32 fs6 fc0 sc0 ls21 wsb">        return components.length; </div><div class="t m0 x0 hb y10a6 ff32 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 hb y10a7 ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y10a8 ff32 fs6 fc0 sc0 ls21 wsb">    app.registerComponent = function(component){ </div><div class="t m0 x0 hb y10a9 ff32 fs6 fc0 sc0 ls21 wsb">        if (typeof component == &quot;object&quot;){ </div><div class="t m0 x0 hb y10aa ff32 fs6 fc0 sc0 ls21 wsb">            components.push(component); </div><div class="t m0 x0 hb y10ab ff32 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y10ac ff32 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 hb y10ad ff32 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y10ae ff32 fs6 fc0 sc0 ls21 wsb">    //返回这个副本 </div></div></div>
<div id="pfd2" class="pf w0 h0" data-page-no="d2"><div class="pc pcd2 w0 h0"><div class="t m0 x0 h2 y1 ff2a fs0 fc0 sc0 ls7 ws0">192  第7章 函数表达式 </div><div class="t m0 x0 h3 y2 ff2a fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 ff32 fs6 fc0 sc0 ls21 wsb">    return app; </div><div class="t m0 x0 hb y7a ff32 fs6 fc0 sc0 ls21 wsb">}();  </div><div class="t m0 x4 hf y10b0 ff34 fs2 fc0 sc0 ls2b wsb">ModuleAugmentationPatternExample01.htm </div><div class="t m0 x0 h5 y10b1 ff31 fs2 fc0 sc0 ls5 wsec">在这个重写后的应用程序（application）单例中，首先也是像前面例子中一样定义了私有变量。主</div><div class="t m0 x0 h1e y10b2 ff31 fs2 fc0 sc0 ls8 wseb">要的不同之处在于命名变量app的创建过程，因为它必须是BaseComponent的实例。这个实例实际上</div><div class="t m0 x0 h1e y10b3 ff31 fs2 fc0 sc0 ls170">是application对象的局部变量版。此后，我们又为app对象添加了能够访问私有变量的公有方法。</div><div class="t m0 x0 hc y10b4 ff31 fs2 fc0 sc0 ls8 wseb">最后一步是返回app对象，结果仍然是将它赋值给全局变量application。 </div><div class="t m0 x0 hd y10b5 ff2f fs7 fc0 sc0 ls22">7.5 小结 </div><div class="t m0 x0 h5 yc37 ff31 fs2 fc0 sc0 ls32">在JavaScript编程中，函数表达式是一种非常有用的技术。使用函数表达式可以无须对函数命名，</div><div class="t m0 x0 h5 yc38 ff31 fs2 fc0 sc0 ls8 wseb">从而实现动态编程。匿名函数，也称为拉姆达函数，是一种使用JavaScript函数的强大方式。以下总结</div><div class="t m0 x0 h5 y2bc ff31 fs2 fc0 sc0 ls8 wseb">了函数表达式的特点。 </div><div class="t m0 x0 h4 y10b6 ff30 fs1 fc0 sc0 ls2"> 函数表达式不同于函数声明。函数声明要求有名字，但函数表达式不需要。没有名字的函数表</div><div class="t m0 x0 h5 y10b7 ff31 fs2 fc0 sc0 ls8 wseb">达式也叫做匿名函数。 </div><div class="t m0 x0 h5 y10b8 ff30 fs1 fc0 sc0 ls2"> 在无法确定如何引用函数的情况下，递归函数就会变得比较复杂； </div><div class="t m0 x0 h4 y10b9 ff30 fs1 fc0 sc0 ls2"> 递归函数应该始终使用arguments.callee来递归地调用自身，不要使用函数名——函数名可</div><div class="t m0 x0 h5 y10ba ff31 fs2 fc0 sc0 ls8 wseb">能会发生变化。 </div><div class="t m0 x0 h4 y10bb ff31 fs2 fc0 sc0 ls24 wsf5">当在函数内部定义了其他函数时，就创建了闭包。闭包有权访问包含函数内部的所有变量，原理</div><div class="t m0 x0 h5 y10bc ff31 fs2 fc0 sc0 ls5">如下。 </div><div class="t m0 x0 h5 y10bd ff30 fs1 fc0 sc0 ls2"> 在后台执行环境中，闭包的作用域链包含着它自己的作用域、包含函数的作用域和全局作用域。 </div><div class="t m0 x0 h5 yc21 ff30 fs1 fc0 sc0 ls2"> 通常，函数的作用域及其所有变量都会在函数执行结束后被销毁。 </div><div class="t m0 x0 h5 y10be ff30 fs1 fc0 sc0 ls8 ws134"> 但是，当函数返回了一个闭包时，这个函数的作用域将会一直在内存中保存到闭包不存在为止。 </div><div class="t m0 x0 h5 y10bf ff31 fs2 fc0 sc0 ls1f ws108">使用闭包可以在JavaScript中模仿块级作用域（JavaScript本身没有块级作用域的概念），要点如下。 </div><div class="t m0 x0 h5 y2a3 ff30 fs1 fc0 sc0 ls2"> 创建并立即调用一个函数，这样既可以执行其中的代码，又不会在内存中留下对该函数的引用。 </div><div class="t m0 x0 h4 y10c0 ff30 fs1 fc0 sc0 ls2"> 结果就是函数内部的所有变量都会被立即销毁——除非将某些变量赋值给了包含作用域（即外</div><div class="t m0 x0 h5 y10c1 ff31 fs2 fc0 sc0 ls8 wseb">部作用域）中的变量。 </div><div class="t m0 x0 h5 y10c2 ff31 fs2 fc0 sc0 ls8 wseb">闭包还可以用于在对象中创建私有变量，相关概念和要点如下。 </div><div class="t m0 x0 h5 y9a ff30 fs1 fc0 sc0 ls2"> 即使JavaScript中没有正式的私有对象属性的概念，但可以使用闭包来实现公有方法，而通过公</div><div class="t m0 x0 h5 y10c3 ff31 fs2 fc0 sc0 ls8 wseb">有方法可以访问在包含作用域中定义的变量。 </div><div class="t m0 x0 h5 y10c4 ff30 fs1 fc0 sc0 ls2"> 有权访问私有变量的公有方法叫做特权方法。 </div><div class="t m0 x0 h4 y8bb ff30 fs1 fc0 sc0 ls2"> 可以使用构造函数模式、原型模式来实现自定义类型的特权方法，也可以使用模块模式、增强</div><div class="t m0 x0 h5 y10c5 ff31 fs2 fc0 sc0 ls8 wseb">的模块模式来实现单例的特权方法。 </div><div class="t m0 x0 h5 y10c6 ff2a fs2 fc0 sc0 lsb ws5">JavaScript中的函数表达式和闭包都是极其有用的特性，利用它们可以实现很多功能。不过，因为</div><div class="t m0 x0 h5 y10c7 ff31 fs2 fc0 sc0 ls8 wseb">创建闭包必须维护额外的作用域，所以过度使用它们可能会占用大量内存。 </div></div></div>
<div id="pfd3" class="pf w0 h0" data-page-no="d3"><div class="pc pcd3 w0 h0"><div class="t m0 x2 h2 y1 ff38 fs0 fc0 sc0 ls10 wsc">8.1 window对象   193 </div><div class="t m0 x0 h3 y2 ff38 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff3a fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff3a fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff3a fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff3a fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff3a fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff3a fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff3a fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff3a fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff3a fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff3a fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff3a fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff3a fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff3a fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h9 y2a ff3b fs5 fc0 sc0 ls175 wsb">BOM </div><div class="t m0 x0 h3c y2b ff3c fs2 fc0 sc0 ls8">本章内容 </div><div class="t m0 x0 h5 y2c ff3e fs1 fc0 sc0 ls2"> 理解window对象——BOM的核心 </div><div class="t m0 x0 h5 y2d ff3e fs1 fc0 sc0 ls2"> 控制窗口、框架和弹出窗口 </div><div class="t m0 x0 h5 y2e ff3e fs1 fc0 sc0 ls2"> 利用location对象中的页面信息 </div><div class="t m0 x0 h5 y2f ff3e fs1 fc0 sc0 ls2"> 使用navigator对象了解浏览器 </div><div class="t m0 x0 h5 y30 ff38 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x5 h5 y31 ff38 fs2 fc0 sc0 ls176 ws137">CMAScript是JavaScript的核心，但如果要在Web中使用JavaScript，那么 BOM（浏览器对象模</div><div class="t m0 x5 h5 y32 ff3f fs2 fc0 sc0 ls8 wseb">型）则无疑才是真正的核心。BOM提供了很多对象，用于访问浏览器的功能，这些功能与任</div><div class="t m0 x0 h5 y33 ff3f fs2 fc0 sc0 ls1f ws108">何网页内容无关。多年来，缺少事实上的规范导致BOM既有意思又有问题，因为浏览器提供商会按照各</div><div class="t m0 x0 h4 y34 ff3f fs2 fc0 sc0 ls1f ws108">自的想法随意去扩展它。于是，浏览器之间共有的对象就成为了事实上的标准。这些对象在浏览器中得以</div><div class="t m0 x0 h5 y10c8 ff3f fs2 fc0 sc0 ls1f ws108">存在，很大程度上是由于它们提供了与浏览器的互操作性。W3C为了把浏览器中JavaScript最基本的部分</div><div class="t m0 x0 h5 y10c9 ff3f fs2 fc0 sc0 ls1f ws108">标准化，已经将BOM的主要方面纳入了HTML5的规范中。 </div><div class="t m0 x0 hd yef7 ff3d fs7 fc0 sc0 ls22">8.1 window对象 </div><div class="t m0 x0 h5 y10ca ff38 fs2 fc0 sc0 ls50 ws41">BOM的核心对象是window，它表示浏览器的一个实例。在浏览器中，window对象有双重角色，</div><div class="t m0 x0 h5 y10cb ff3f fs2 fc0 sc0 ls8 wseb">它既是通过JavaScript访问浏览器窗口的一个接口，又是ECMAScript规定的 Global对象。这意味着</div><div class="t m0 x0 h1e y10cc ff3f fs2 fc0 sc0 ls60 ws140">在网页中定义的任何一个对象、变量和函数，都以window作为其 Global对象，因此有权访问</div><div class="t m0 x0 h5 y10cd ff40 fs1 fc0 sc0 ls9 ws2">parseInt()等方法。 </div><div class="t m0 x0 h20 y607 ff3d fs3 fc0 sc0 ls4d ws40">8.1.1 全局作用域 </div><div class="t m0 x0 h5 y758 ff3f fs2 fc0 sc0 ls8 wseb">由于window对象同时扮演着ECMAScript中Global 对象的角色，因此所有在全局作用域中声明</div><div class="t m0 x0 h5 y10ce ff3f fs2 fc0 sc0 ls8 wseb">的变量、函数都会变成window对象的属性和方法。来看下面的例子。 </div><div class="t m0 x5 hb y10cf ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y10d0 ff40 fs6 fc0 sc0 ls21 wsb">var age = 29; </div><div class="t m0 x0 hb y10d1 ff40 fs6 fc0 sc0 ls21 wsb">function sayAge(){ </div><div class="t m0 x0 hb y10d2 ff40 fs6 fc0 sc0 ls21 wsb">    alert(this.age); </div><div class="t m0 x0 hb y10d3 ff40 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y10d4 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y10d5 ff40 fs6 fc0 sc0 ls21 wsb">alert(window.age);     //29 </div><div class="t m0 x0 hb y10d6 ff40 fs6 fc0 sc0 ls21 wsb">sayAge();           //29 </div><div class="t m0 x0 hb y10d7 ff40 fs6 fc0 sc0 ls21 wsb">window.sayAge();      //29 </div><div class="t m0 x5 hb y10d8 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 yf8b ff3f fs2 fc0 sc0 ls8 wseb">我们在全局作用域中定义了一个变量age和一个函数sayAge()，它们被自动归在了window对象</div><div class="t m0 x0 h4 yf8c ff3f fs2 fc0 sc0 ls8 wseb">名下。于是，可以通过window.age访问变量age，可以通过window.sayAge()访问函数sayAge()。</div><div class="t m0 x0 h78 y10d9 ff42 fs11 fc0 sc0 ls17f wsb">E </div><div class="t m0 x0 h11 y4b ff43 fsa fc0 sc0 ls8">第</div><div class="t m1 x0 h12 y4b ff44 fsb fc3 sc0 ls8">8</div><div class="t m0 x5 h11 y4b ff43 fsa fc0 sc0 ls8 ws1d">章 </div></div></div>
<div id="pfd4" class="pf w0 h0" data-page-no="d4"><div class="pc pcd4 w0 h0"><div class="t m0 x0 h2 y1 ff38 fs0 fc0 sc0 ls7 ws0">194  第8章 BOM </div><div class="t m0 x0 h3 y2 ff38 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ff3f fs2 fc0 sc0 ls8 wseb">由于sayAge()存在于全局作用域中，因此this.age被映射到window.age，最终显示的仍然是正确</div><div class="t m0 x0 h5 y4d ff3f fs2 fc0 sc0 ls8">的结果。 </div><div class="t m0 x0 h1c yd8 ff3f fs2 fc0 sc0 ls8 wseb">抛开全局变量会成为window对象的属性不谈，定义全局变量与在window对象上直接定义属性还</div><div class="t m0 x0 h4 yd9 ff3f fs2 fc0 sc0 ls8 wseb">是有一点差别：全局变量不能通过delete操作符删除，而直接在window对象上的定义的属性可以。</div><div class="t m0 x0 h5 y15d ff3f fs2 fc0 sc0 ls8">例如： </div><div class="t m0 x0 hb y263 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y264 ff40 fs6 fc0 sc0 ls21 wsb">var age = 29; </div><div class="t m0 x0 hb y265 ff40 fs6 fc0 sc0 ls21 wsb">window.color = &quot;red&quot;; </div><div class="t m0 x0 hb y266 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y267 ff40 fs6 fc0 sc0 ls21">//在IE &lt; 9 时抛出错误，在其他所有浏览器中都返回false  </div><div class="t m0 x0 hb y268 ff40 fs6 fc0 sc0 ls21 wsb">delete window.age; </div><div class="t m0 x0 hb y269 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y10db ff40 fs6 fc0 sc0 ls21">//在IE &lt; 9 时抛出错误，在其他所有浏览器中都返回true </div><div class="t m0 x0 hb y10dc ff40 fs6 fc0 sc0 ls21 wsb">delete window.color; //returns true </div><div class="t m0 x0 hb y10dd ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y10de ff40 fs6 fc0 sc0 ls21 wsb">alert(window.age);   //29 </div><div class="t m0 x0 hb y10df ff40 fs6 fc0 sc0 ls21 wsb">alert(window.color); //undefined </div><div class="t m0 x0 h5 ycac ff38 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y10e0 ff46 fs2 fc0 sc0 ls2b wsb">DeleteOperatorExample01.htm </div><div class="t m0 x0 h4 y10e1 ff3f fs2 fc0 sc0 ls8 wseb">刚才使用var语句添加的window 属性有一个名为[[Configurable]]的特性，这个特性的值被</div><div class="t m0 x0 hc y10e2 ff3f fs2 fc0 sc0 ls8 wseb">设置为false，因此这样定义的属性不可以通过delete操作符删除。IE8及更早版本在遇到使用delete</div><div class="t m0 x0 h5 y10e3 ff3f fs2 fc0 sc0 ls8 wseb">删除window属性的语句时，不管该属性最初是如何创建的，都会抛出错误，以示警告。IE9及更高版</div><div class="t m0 x0 h5 y10e4 ff3f fs2 fc0 sc0 ls8 wseb">本不会抛出错误。 </div><div class="t m0 x0 h1e y10e5 ff3f fs2 fc0 sc0 ls8 wseb">另外，还要记住一件事：尝试访问未声明的变量会抛出错误，但是通过查询window对象，可以知</div><div class="t m0 x0 h5 y10e6 ff3f fs2 fc0 sc0 ls8 wseb">道某个可能未声明的变量是否存在。例如： </div><div class="t m0 x0 h5 y10e7 ff38 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y10e8 ff40 fs6 fc0 sc0 ls21">//这里会抛出错误，因为oldValue未定义 </div><div class="t m0 x0 hb y10e9 ff40 fs6 fc0 sc0 ls21 wsb">var newValue = oldValue; </div><div class="t m0 x0 hb y10ea ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y10eb ff40 fs6 fc0 sc0 ls21">//这里不会抛出错误，因为这是一次属性查询 </div><div class="t m0 x0 h16 y10ec ff40 fs6 fc0 sc0 ls21 ws34">//newValue的值是undefined </div><div class="t m0 x0 hb y10ed ff40 fs6 fc0 sc0 ls21 wsb">var newValue = window.oldValue; </div><div class="t m0 x0 hb y10ee ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y10ef ff3f fs2 fc0 sc0 ls8 wseb">本章后面将要讨论的很多全局JavaScript对象（如location和navigator）实际上都是 window</div><div class="t m0 x0 h5 y10f0 ff3f fs2 fc0 sc0 ls8 wseb">对象的属性。 </div><div class="t m0 x5 h5 y10f1 ff38 fs2 fc0 sc0 lsc7 ws141">Windows Mobile平台的IE浏览器不允许通过window.property = value之类</div><div class="t m0 x0 ha y10f2 ff39 fs2 fc0 sc0 ls8 ws14">的形式，直接在window对象上创建新的属性或方法。可是，在全局作用域中声明的</div><div class="t m0 x0 h18 y10f3 ff39 fs2 fc0 sc0 ls8 ws14">所有变量和函数，照样会变成window对象的成员。 </div><div class="t m0 x0 h20 y10f4 ff3d fs3 fc0 sc0 ls4d ws40">8.1.2 窗口关系及框架 </div><div class="t m0 x0 h4 y10f5 ff3f fs2 fc0 sc0 ls5f ws10b">如果页面中包含框架，则每个框架都拥有自己的window对象，并且保存在frames集合中。在frames</div><div class="t m0 x0 h5 y10f6 ff3f fs2 fc0 sc0 ls8 wseb">集合中，可以通过数值索引（从0开始，从左至右，从上到下）或者框架名称来访问相应的window对</div><div class="t m0 x0 h5 y10f7 ff3f fs2 fc0 sc0 ls8 wseb">象。每个window对象都有一个name属性，其中包含框架的名称。下面是一个包含框架的页面： </div></div></div>
<div id="pfd5" class="pf w0 h0" data-page-no="d5"><div class="pc pcd5 w0 h0"><div class="t m0 x2 h2 y1 ff38 fs0 fc0 sc0 ls10 wsc">8.1 window对象   195 </div><div class="t m0 x0 h3 y2 ff38 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff3a fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff3a fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff3a fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff3a fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff3a fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff3a fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff3a fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff3a fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff3a fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff3a fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff3a fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff3a fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff3a fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y79 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y7a ff40 fs6 fc0 sc0 ls21 wsb">&lt;html&gt; </div><div class="t m0 x0 hb y7b ff40 fs6 fc0 sc0 ls21 wsb">    &lt;head&gt; </div><div class="t m0 x0 hb y7c ff40 fs6 fc0 sc0 ls21 wsb">        &lt;title&gt;Frameset Example&lt;/title&gt; </div><div class="t m0 x0 hb y7d ff40 fs6 fc0 sc0 ls21 wsb">    &lt;/head&gt; </div><div class="t m0 x0 hb y7e ff40 fs6 fc0 sc0 ls21 wsb">    &lt;frameset rows=&quot;160,*&quot;&gt; </div><div class="t m0 x0 hb y7f ff40 fs6 fc0 sc0 ls21 wsb">        &lt;frame src=&quot;frame.htm&quot; name=&quot;topFrame&quot;&gt; </div><div class="t m0 x0 hb y80 ff40 fs6 fc0 sc0 ls21 wsb">        &lt;frameset cols=&quot;50%,50%&quot;&gt; </div><div class="t m0 x0 hb y81 ff40 fs6 fc0 sc0 ls21 wsb">            &lt;frame src=&quot;anotherframe.htm&quot; name=&quot;leftFrame&quot;&gt; </div><div class="t m0 x0 hb y82 ff40 fs6 fc0 sc0 ls21 wsb">            &lt;frame src=&quot;yetanotherframe.htm&quot; name=&quot;rightFrame&quot;&gt; </div><div class="t m0 x0 hb y83 ff40 fs6 fc0 sc0 ls21 wsb">        &lt;/frameset&gt; </div><div class="t m0 x0 hb y84 ff40 fs6 fc0 sc0 ls21 wsb">    &lt;/frameset&gt; </div><div class="t m0 x0 hb y85 ff40 fs6 fc0 sc0 ls21 wsb">&lt;/html&gt; </div><div class="t m0 x5 hb y10f8 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y293 ff46 fs2 fc0 sc0 ls1b wsb">FramesetExample01.htm </div><div class="t m0 x0 h4 y10f9 ff3f fs2 fc0 sc0 ls4 ws10d">以上代码创建了一个框架集，其中一个框架居上，两个框架居下。对这个例子而言，可以通过</div><div class="t m0 x0 h4 y5f4 ff40 fs1 fc0 sc0 ls9 ws2">window.frames[0]或者window.frames[&quot;topFrame&quot;]来引用上方的框架。不过，恐怕你最好使用</div><div class="t m0 x0 h5 y10fa ff40 fs1 fc0 sc0 ls9 ws2">top而非window来引用这些框架（例如，通过top.frames[0]）。 </div><div class="t m0 x0 h1e y10fb ff3f fs2 fc0 sc0 ls8 wseb">我们知道，top对象始终指向最高（最外）层的框架，也就是浏览器窗口。使用它可以确保在一个</div><div class="t m0 x0 h1e y10fc ff3f fs2 fc0 sc0 ls8 wseb">框架中正确地访问另一个框架。因为对于在一个框架中编写的任何代码来说，其中的window对象指向</div><div class="t m0 x0 h5 y10fd ff3f fs2 fc0 sc0 ls8 wseb">的都是那个框架的特定实例，而非最高层的框架。图8-1展示了在最高层窗口中，通过代码来访问前面</div><div class="t m0 x0 h5 yfec ff3f fs2 fc0 sc0 ls8 wseb">例子中每个框架的不同方式。 </div><div class="t m0 x2 h5 y1079 ff38 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 h3 y10fe ff3f fs1 fc0 sc0 ls8 wsb">图 8-1 </div><div class="t m0 x0 h4 y10ff ff3f fs2 fc0 sc0 ls2c">与top相对的另一个window对象是parent。顾名思义，parent（父）对象始终指向当前框架的</div><div class="t m0 x0 h4 y1100 ff3f fs2 fc0 sc0 ls8 wseb">直接上层框架。在某些情况下，parent有可能等于top；但在没有框架的情况下，parent一定等于</div><div class="t m0 x0 h5 y1101 ff40 fs1 fc0 sc0 ls9 ws2">top（此时它们都等于window）。再看下面的例子。 </div><div class="t m0 x5 hb y1102 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1103 ff40 fs6 fc0 sc0 ls21 wsb">&lt;html&gt; </div><div class="t m0 x0 hb y1104 ff40 fs6 fc0 sc0 ls21 wsb">    &lt;head&gt; </div><div class="t m0 x0 hb y1105 ff40 fs6 fc0 sc0 ls21 wsb">        &lt;title&gt;Frameset Example&lt;/title&gt; </div></div></div>
<div id="pfd6" class="pf w0 h0" data-page-no="d6"><div class="pc pcd6 w0 h0"><div class="t m0 x0 h2 y1 ff38 fs0 fc0 sc0 ls7 ws0">196  第8章 BOM </div><div class="t m0 x0 h3 y2 ff38 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 ff40 fs6 fc0 sc0 ls21 wsb">    &lt;/head&gt; </div><div class="t m0 x0 hb y7a ff40 fs6 fc0 sc0 ls21 wsb">    &lt;frameset rows=&quot;100,*&quot;&gt; </div><div class="t m0 x0 hb y7b ff40 fs6 fc0 sc0 ls21 wsb">        &lt;frame src=&quot;frame.htm&quot; name=&quot;topFrame&quot;&gt; </div><div class="t m0 x0 hb y7c ff40 fs6 fc0 sc0 ls21 wsb">        &lt;frameset cols=&quot;50%,50%&quot;&gt; </div><div class="t m0 x0 hb y7d ff40 fs6 fc0 sc0 ls21 wsb">            &lt;frame src=&quot;anotherframe.htm&quot; name=&quot;leftFrame&quot;&gt; </div><div class="t m0 x0 h15 y7e ff41 fs6 fc0 sc0 ls21 wsb">            &lt;frame src=&quot;anotherframeset.htm&quot; name=&quot;rightFrame&quot;&gt; </div><div class="t m0 x0 hb y7f ff40 fs6 fc0 sc0 ls21 wsb">        &lt;/frameset&gt; </div><div class="t m0 x0 hb y80 ff40 fs6 fc0 sc0 ls21 wsb">    &lt;/frameset&gt; </div><div class="t m0 x0 hb y81 ff40 fs6 fc0 sc0 ls21 wsb">&lt;/html&gt; </div><div class="t m0 x0 hb y1107 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1108 ff46 fs2 fc0 sc0 ls25 wsb">frameset1.htm </div><div class="t m0 x0 h5 y1109 ff3f fs2 fc0 sc0 ls8 wseb">这个框架集中的一个框架包含了另一个框架集，该框架集的代码如下所示。 </div><div class="t m0 x0 hb y110a ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y110b ff40 fs6 fc0 sc0 ls21 wsb">&lt;html&gt; </div><div class="t m0 x0 hb y110c ff40 fs6 fc0 sc0 ls21 wsb">    &lt;head&gt; </div><div class="t m0 x0 hb y110d ff40 fs6 fc0 sc0 ls21 wsb">        &lt;title&gt;Frameset Example&lt;/title&gt; </div><div class="t m0 x0 hb y110e ff40 fs6 fc0 sc0 ls21 wsb">    &lt;/head&gt; </div><div class="t m0 x0 hb y110f ff40 fs6 fc0 sc0 ls21 wsb">    &lt;frameset cols=&quot;50%,50%&quot;&gt; </div><div class="t m0 x0 hb y1110 ff40 fs6 fc0 sc0 ls21 wsb">        &lt;frame src=&quot;red.htm&quot; name=&quot;redFrame&quot;&gt; </div><div class="t m0 x0 hb y1111 ff40 fs6 fc0 sc0 ls21 wsb">        &lt;frame src=&quot;blue.htm&quot; name=&quot;blueFrame&quot;&gt; </div><div class="t m0 x0 hb y1112 ff40 fs6 fc0 sc0 ls21 wsb">    &lt;/frameset&gt; </div><div class="t m0 x0 hb y1113 ff40 fs6 fc0 sc0 ls21 wsb">&lt;/html&gt; </div><div class="t m0 x0 hb y1114 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1115 ff46 fs2 fc0 sc0 ls8 wsb">anotherframeset.htm </div><div class="t m0 x0 h4 y1116 ff3f fs2 fc0 sc0 ls8 wseb">浏览器在加载完第一个框架集以后，会继续将第二个框架集加载到rightFrame中。如果代码位于</div><div class="t m0 x0 h4 y1117 ff40 fs1 fc0 sc0 ls9 ws2">redFrame（或blueFrame）中，那么parent 对象指向的就是rightFrame。可是，如果代码位于</div><div class="t m0 x0 h5 y1118 ff40 fs1 fc0 sc0 ls9 ws2">topFrame中，则parent指向的是top，因为 topFrame的直接上层框架就是最外层框架。图8-2展</div><div class="t m0 x0 hc y1119 ff3f fs2 fc0 sc0 ls8 wseb">示了在将前面例子加载到浏览器之后，不同window对象的值。 </div><div class="t m0 x2 h5 y111a ff38 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x7 h3 y111b ff3f fs1 fc0 sc0 ls8 wsb">图 8-2 </div></div></div>
<div id="pfd7" class="pf w0 h0" data-page-no="d7"><div class="pc pcd7 w0 h0"><div class="t m0 x2 h2 y1 ff38 fs0 fc0 sc0 ls10 wsc">8.1 window对象   197 </div><div class="t m0 x0 h3 y2 ff38 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff3a fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff3a fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff3a fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff3a fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff3a fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff3a fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff3a fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff3a fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff3a fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff3a fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff3a fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff3a fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff3a fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h4 y3 ff3f fs2 fc0 sc0 ls8 wseb">注意，除非最高层窗口是通过window.open()打开的（本章后面将会讨论），否则其window对象</div><div class="t m0 x0 hc y4d ff3f fs2 fc0 sc0 ls184">的name属性不会包含任何值。 </div><div class="t m0 x0 h1e y5 ff3f fs2 fc0 sc0 ls8 wseb">与框架有关的最后一个对象是self，它始终指向window；实际上，self和window对象可以互</div><div class="t m0 x0 h5 yd9 ff3f fs2 fc0 sc0 ls8 wseb">换使用。引入self对象的目的只是为了与top和parent 对象对应起来，因此它不格外包含其他值。 </div><div class="t m0 x0 h1e y15d ff3f fs2 fc0 sc0 ls8 wseb">所有这些对象都是window对象的属性，可以通过window.parent、window.top等形式来访问。</div><div class="t m0 x0 hc y21a ff3f fs2 fc0 sc0 ls5f ws10b">同时，这也意味着可以将不同层次的window对象连缀起来，例如window.parent.parent.frames[0]。 </div><div class="t m0 x5 ha y111c ff39 fs2 fc0 sc0 ls8 ws14">在使用框架的情况下，浏览器中会存在多个Global对象。在每个框架中定义的</div><div class="t m0 x5 ha y111d ff39 fs2 fc0 sc0 ls8 ws14">全局变量会自动成为框架中window对象的属性。由于每个window对象都包含原生</div><div class="t m0 x5 ha y111e ff39 fs2 fc0 sc0 ls8 ws14">类型的构造函数，因此每个框架都有一套自己的构造函数，这些构造函数一一对应，</div><div class="t m0 x5 ha y111f ff39 fs2 fc0 sc0 ls8 ws14">但并不相等。例如，top.Object并不等于top.frames[0].Object。这个问题会</div><div class="t m0 x5 h18 y1120 ff39 fs2 fc0 sc0 ls8 ws14">影响到对跨框架传递的对象使用instanceof操作符。 </div><div class="t m0 x0 h20 y646 ff3d fs3 fc0 sc0 ls4d ws40">8.1.3 窗口位置 </div><div class="t m0 x0 h5 y1121 ff3f fs2 fc0 sc0 ls8 wseb">用来确定和修改window对象位置的属性和方法有很多。IE、Safari、Opera 和Chrome都提供了</div><div class="t m0 x0 h5 y1122 ff40 fs1 fc0 sc0 ls9 ws2">screenLeft和screenTop属性，分别用于表示窗口相对于屏幕左边和上边的位置。Firefox 则在</div><div class="t m0 x0 h5 y1123 ff40 fs1 fc0 sc0 ls9 ws2">screenX和screenY属性中提供相同的窗口位置信息，Safari和Chrome也同时支持这两个属性。Opera</div><div class="t m0 x0 h1e y1124 ff3f fs2 fc0 sc0 ls8 wseb">虽然也支持screenX和screenY属性，但与screenLeft和screenTop 属性并不对应，因此建议大</div><div class="t m0 x0 h5 y1125 ff3f fs2 fc0 sc0 ls8 wseb">家不要在Opera中使用它们。使用下列代码可以跨浏览器取得窗口左边和上边的位置。 </div><div class="t m0 x5 hb y1126 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1127 ff40 fs6 fc0 sc0 ls21 wsb">var leftPos = (typeof window.screenLeft == &quot;number&quot;) ? </div><div class="t m0 x0 hb y1128 ff40 fs6 fc0 sc0 ls21 wsb">                  window.screenLeft : window.screenX; </div><div class="t m0 x0 hb y1129 ff40 fs6 fc0 sc0 ls21 wsb">var topPos = (typeof window.screenTop == &quot;number&quot;) ? </div><div class="t m0 x0 hb y112a ff40 fs6 fc0 sc0 ls21 wsb">                  window.screenTop : window.screenY; </div><div class="t m0 x5 hb y112b ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y112c ff46 fs2 fc0 sc0 ls2b wsb">WindowPositionExample01.htm </div><div class="t m0 x0 h5 y112d ff3f fs2 fc0 sc0 ls8 wseb">这个例子运用二元操作符首先确定screenLeft和screenTop属性是否存在，如果是（ 在IE、</div><div class="t m0 x0 h5 y112e ff38 fs2 fc0 sc0 ls48 ws39">Safari、Opera和Chrome中），则取得这两个属性的值。如果不存在（在Firefox中），则取得screenX</div><div class="t m0 x0 h5 y112f ff3f fs2 fc0 sc0 ls2c">和screenY的值。 </div><div class="t m0 x0 h5 y1130 ff3f fs2 fc0 sc0 ls8 wseb">在使用这些值的过程中，还必须注意一些小问题。在IE、Opera中，screenLeft和screenTop中保存</div><div class="t m0 x0 h1e y1131 ff3f fs2 fc0 sc0 ls8 wseb">的是从屏幕左边和上边到由window对象表示的页面可见区域的距离。换句话说，如果window对象是</div><div class="t m0 x0 h5 y1132 ff3f fs2 fc0 sc0 ls8 wseb">最外层对象，而且浏览器窗口紧贴屏幕最上端——即y轴坐标为0，那么screenTop的值就是位于页面</div><div class="t m0 x0 h5 y1133 ff3f fs2 fc0 sc0 ls5f ws10b">可见区域上方的浏览器工具栏的像素高度。但是，在Chrome、Firefox和Safari中，screenY或screenTop</div><div class="t m0 x0 h5 y1134 ff3f fs2 fc0 sc0 ls8 wseb">中保存的是整个浏览器窗口相对于屏幕的坐标值，即在窗口的y轴坐标为0时返回0。 </div><div class="t m0 x0 h5 y1135 ff3f fs2 fc0 sc0 ls4c wsfa">更让人捉摸不透是，Firefox、Safari和Chrome始终返回页面中每个框架的 top.screenX和</div><div class="t m0 x0 h4 y1136 ff40 fs1 fc0 sc0 ls9 ws2">top.screenY值。即使在页面由于被设置了外边距而发生偏移的情况下，相对于window 对象使用</div><div class="t m0 x0 h5 y1137 ff40 fs1 fc0 sc0 ls9 ws2">screenX和screenY每次也都会返回相同的值。而IE和Opera则会给出框架相对于屏幕边界的精确坐</div><div class="t m0 x0 h5 y1138 ff3f fs2 fc0 sc0 ls8">标值。 </div><div class="t m0 x0 h4 y1139 ff3f fs2 fc0 sc0 ls8 wseb">最终结果，就是无法在跨浏览器的条件下取得窗口左边和上边的精确坐标值。然而，使用moveTo()</div><div class="t m0 x0 h4 y113a ff3f fs2 fc0 sc0 lsff">和moveBy()方法倒是有可能将窗口精确地移动到一个新位置。这两个方法都接收两个参数，其中</div></div></div>
<div id="pfd8" class="pf w0 h0" data-page-no="d8"><div class="pc pcd8 w0 h0"><div class="t m0 x0 h2 y1 ff38 fs0 fc0 sc0 ls7 ws0">198  第8章 BOM </div><div class="t m0 x0 h3 y2 ff38 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ff40 fs1 fc0 sc0 ls9 ws2">moveTo()接收的是新位置的x和y坐标值，而moveBy()接收的是在水平和垂直方向上移动的像素数。</div><div class="t m0 x0 h5 y4d ff3f fs2 fc0 sc0 ls8 wseb">下面来看几个例子： </div><div class="t m0 x0 hb y113c ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y113d ff40 fs6 fc0 sc0 ls21">//将窗口移动到屏幕左上角 </div><div class="t m0 x0 hb y113e ff40 fs6 fc0 sc0 ls21 wsb">window.moveTo(0,0); </div><div class="t m0 x0 hb y113f ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1140 ff40 fs6 fc0 sc0 ls21">//将窗向下移动100像素 </div><div class="t m0 x0 hb y1141 ff40 fs6 fc0 sc0 ls21 wsb">window.moveBy(0,100); </div><div class="t m0 x0 hb y1142 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1143 ff40 fs6 fc0 sc0 ls21">//将窗口移动到(200,300) </div><div class="t m0 x0 hb y1144 ff40 fs6 fc0 sc0 ls21 wsb">window.moveTo(200,300); </div><div class="t m0 x0 hb y1145 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1146 ff40 fs6 fc0 sc0 ls21">//将窗口向左移动50像素 </div><div class="t m0 x0 hb y1147 ff40 fs6 fc0 sc0 ls21 wsb">window.moveBy(-50,0); </div><div class="t m0 x0 hb y1148 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1149 ff3f fs2 fc0 sc0 ls8 wseb">需要注意的是，这两个方法可能会被浏览器禁用；而且，在Opera和IE 7（及更高版本）中默认就</div><div class="t m0 x0 h5 y114a ff3f fs2 fc0 sc0 ls8 wseb">是禁用的。另外，这两个方法都不适用于框架，只能对最外层的window对象使用。 </div><div class="t m0 x0 h20 y114b ff3d fs3 fc0 sc0 ls4d ws40">8.1.4 窗口大小 </div><div class="t m0 x0 h5 y114c ff3f fs2 fc0 sc0 ls1f">跨浏览器确定一个窗口的大小不是一件简单的事。IE9+、Firefox、Safari、Opera和Chrome均为此提</div><div class="t m0 x0 hc y114d ff3f fs2 fc0 sc0 ls1f ws108">供了4个属性：innerWidth、innerHeight、outerWidth和outerHeight。在IE9+、Safari和Firefox</div><div class="t m0 x0 h1e y114e ff3f fs2 fc0 sc0 ls1f ws108">中，outerWidth和outerHeight返回浏览器窗口本身的尺寸（无论是从最外层的window对象还是从</div><div class="t m0 x0 h69 y114f ff3f fs2 fc0 sc0 ls1f ws108">某个框架访问）。在Opera中，这两个属性的值表示页面视图容器①的大小。而innerWidth和innerHeight</div><div class="t m0 x0 h5 y1150 ff3f fs2 fc0 sc0 ls6 wsf7">则表示该容器中页面视图区的大小（减去边框宽度）。在Chrome中，outerWidth、outerHeight与</div><div class="t m0 x0 h5 y1151 ff40 fs1 fc0 sc0 ls20 ws16">innerWidth、innerHeight返回相同的值，即视口（viewport）大小而非浏览器窗口大小。 </div><div class="t m0 x0 h5 y1152 ff38 fs2 fc0 sc0 ls193 ws14f">IE8及更早版本没有提供取得当前浏览器窗口尺寸的属性；不过，它通过DOM提供了页面可见区域</div><div class="t m0 x0 h5 y1153 ff3f fs2 fc0 sc0 ls1f">的相关信息。 </div><div class="t m0 x0 h5 y1154 ff3f fs2 fc0 sc0 lsd0">在IE、Firefox、Safari、Opera和Chrome中，document.documentElement.clientWidth 和</div><div class="t m0 x0 h5 y1155 ff40 fs1 fc0 sc0 ls9 ws2">document.documentElement.clientHeight中保存了页面视口的信息。在IE6中，这些属性必须在</div><div class="t m0 x0 h1e y1156 ff3f fs2 fc0 sc0 ls8 wseb">标准模式下才有效；如果是混杂模式，就必须通过document.body.clientWidth和document.body. </div><div class="t m0 x0 h21 y1157 ff40 fs1 fc0 sc0 ls9 ws2">clientHeight取得相同信息。而对于混杂模式下的Chrome，则无论通过document.documentEle- </div><div class="t m0 x0 h5 y1158 ff40 fs1 fc0 sc0 ls9 ws2">ment还是document.body中的clientWidth 和clientHeight属性，都可以取得视口的大小。 </div><div class="t m0 x0 h5 y1159 ff3f fs2 fc0 sc0 ls8 wseb">虽然最终无法确定浏览器窗口本身的大小，但却可以取得页面视口的大小，如下所示。 </div><div class="t m0 x0 hb y115a ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y115b ff40 fs6 fc0 sc0 ls21 wsb">var pageWidth = window.innerWidth, </div><div class="t m0 x0 hb y115c ff40 fs6 fc0 sc0 ls21 wsb">    pageHeight = window.innerHeight; </div><div class="t m0 x0 hb y115d ff40 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 hb y115e ff40 fs6 fc0 sc0 ls21 wsb">if (typeof pageWidth != &quot;number&quot;){ </div><div class="t m0 x0 hb y115f ff40 fs6 fc0 sc0 ls21 wsb">    if (document.compatMode == &quot;CSS1Compat&quot;){ </div><div class="t m0 x0 hb y1160 ff40 fs6 fc0 sc0 ls21 wsb">        pageWidth = document.documentElement.clientWidth; </div><div class="t m0 x0 hb y1161 ff40 fs6 fc0 sc0 ls21 wsb">        pageHeight = document.documentElement.clientHeight; </div><div class="t m0 x0 hb y1162 ff40 fs6 fc0 sc0 ls21 wsb">    } else { </div><div class="t m0 x0 hb y1163 ff40 fs6 fc0 sc0 ls21 wsb">        pageWidth = document.body.clientWidth; </div><div class="t m0 x0 hb y1164 ff40 fs6 fc0 sc0 ls21 wsb">        pageHeight = document.body.clientHeight; </div><div class="t m0 x0 hb y1165 ff40 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y1166 ff40 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y1167 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1168 ff46 fs2 fc0 sc0 ls25 wsb">WindowSizeExample01.htm </div><div class="t m0 x0 h3c y2d6 ff3c fs2 fc0 sc0 ls7b wsb">—————————— </div><div class="t m0 x0 h36 ycc6 ff3f fs6 fc0 sc0 ls95">① 这里所谓的“页面视图容器”指的是Opera中单个标签页对应的浏览器窗口。 </div></div></div>
<div id="pfd9" class="pf w0 h0" data-page-no="d9"><div class="pc pcd9 w0 h0"><div class="t m0 x2 h2 y1 ff38 fs0 fc0 sc0 ls10 wsc">8.1 window对象   199 </div><div class="t m0 x0 h3 y2 ff38 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff3a fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff3a fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff3a fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff3a fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff3a fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff3a fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff3a fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff3a fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff3a fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff3a fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff3a fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff3a fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff3a fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h4 y3 ff3f fs2 fc0 sc0 ls57 ws151">在以上代码中，我们首先将window.innerWidth和window.innerHeight 的值分别赋给了</div><div class="t m0 x0 h4 y4 ff40 fs1 fc0 sc0 ls43 ws31">pageWidth和pageHeight。然后检查pageWidth中保存的是不是一个数值；如果不是，则通过检查</div><div class="t m0 x0 h5 y4e ff40 fs1 fc0 sc0 ls43 ws31">document.compatMode（这个属性将在第10章全面讨论）来确定页面是否处于标准模式。如果是，则</div><div class="t m0 x0 h4 yd9 ff3f fs2 fc0 sc0 ls4 ws10d">分别使用document.documentElement.clientWidth和document.documentElement.client- </div><div class="t m0 x0 h21 y1169 ff40 fs1 fc0 sc0 ls43 ws31">Height的值。否则，就使用document.body.clientWidth和document.body.clientHeight的值。 </div><div class="t m0 x0 h1e y21a ff3f fs2 fc0 sc0 ls42 wsf0">对于移动设备，window.innerWidth和window.innerHeight保存着可见视口，也就是屏幕上可</div><div class="t m0 x0 h5 y15e ff3f fs2 fc0 sc0 ls42 wsf0">见页面区域的大小。移动IE浏览器不支持这些属性，但通过document.documentElement.client- </div><div class="t m0 x0 h42 y116a ff40 fs1 fc0 sc0 ls43 ws31">Width和document.documentElement.clientHeihgt提供了相同的信息。随着页面的缩放，这些值</div><div class="t m0 x0 h5 yb ff3f fs2 fc0 sc0 ls42 wsf0">也会相应变化。 </div><div class="t m0 x0 h1e y78a ff3f fs2 fc0 sc0 ls42 wsf0">在其他移动浏览器中，document.documentElement度量的是布局视口，即渲染后页面的实际大</div><div class="t m0 x0 h5 y116b ff3f fs2 fc0 sc0 ls42 wsf0">小（与可见视口不同，可见视口只是整个页面中的一小部分）。移动IE浏览器把布局视口的信息保存在</div><div class="t m0 x0 h5 y21b ff40 fs1 fc0 sc0 ls43 ws31">document.body.clientWidth和document.body.clientHeight中。这些值不会随着页面缩放变化。 </div><div class="t m0 x0 h4 y21c ff3f fs2 fc0 sc0 ls8 wseb">由于与桌面浏览器间存在这些差异，最好是先检测一下用户是否在使用移动设备，然后再决定使用</div><div class="t m0 x0 h5 y116c ff3f fs2 fc0 sc0 ls8 wseb">哪个属性。 </div><div class="t m0 x5 ha y116d ff39 fs2 fc0 sc0 ls8 ws14">有关移动设备视口的话题比较复杂，有很多非常规的情形，也有各种各样的建议。</div><div class="t m0 x5 h5 y116e ff39 fs2 fc0 sc0 ls8 ws14">移动开发咨询师Peter-Paul Koch记述了他对这个问题的研究：http://t.cn/zOZs0Tz。如</div><div class="t m0 x5 h5 y116f ff39 fs2 fc0 sc0 ls8 ws14">果你在做移动Web开发，推荐你读一读这篇文章。 </div><div class="t m0 x0 h4 y1170 ff3f fs2 fc0 sc0 ls8 wseb">另外，使用resizeTo()和resizeBy()方法可以调整浏览器窗口的大小。这两个方法都接收两个</div><div class="t m0 x0 h1e y1171 ff3f fs2 fc0 sc0 ls8 wseb">参数，其中resizeTo()接收浏览器窗口的新宽度和新高度，而resizeBy()接收新窗口与原窗口的宽</div><div class="t m0 x0 h5 y1172 ff3f fs2 fc0 sc0 ls8 wseb">度和高度之差。来看下面的例子。 </div><div class="t m0 x5 hb y1173 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1174 ff40 fs6 fc0 sc0 ls21">//调整到100×100 </div><div class="t m0 x0 hb y1175 ff40 fs6 fc0 sc0 ls21 wsb">window.resizeTo(100, 100); </div><div class="t m0 x0 hb y1176 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1177 ff40 fs6 fc0 sc0 ls21">//调整到200×150 </div><div class="t m0 x0 hb y1178 ff40 fs6 fc0 sc0 ls21 wsb">window.resizeBy(100, 50); </div><div class="t m0 x0 hb y1179 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y117a ff40 fs6 fc0 sc0 ls21">//调整到 300×300 </div><div class="t m0 x0 hb y117b ff40 fs6 fc0 sc0 ls21 wsb">window.resizeTo(300, 300); </div><div class="t m0 x5 hb y117c ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y117d ff3f fs2 fc0 sc0 ls8 wseb">需要注意的是，这两个方法与移动窗口位置的方法类似，也有可能被浏览器禁用；而且，在Opera</div><div class="t m0 x0 h5 y117e ff3f fs2 fc0 sc0 ls197">和IE7（及更高版本）中默认就是禁用的。另外，这两个方法同样不适用于框架，而只能对最外层的</div><div class="t m0 x0 h5 y117f ff40 fs1 fc0 sc0 ls16 ws17">window对象使用。 </div><div class="t m0 x0 h20 y1180 ff3d fs3 fc0 sc0 ls4d ws40">8.1.5 导航和打开窗口 </div><div class="t m0 x0 h5 y1181 ff3f fs2 fc0 sc0 ls8 wseb">使用window.open()方法既可以导航到一个特定的URL，也可以打开一个新的浏览器窗口。这个</div><div class="t m0 x0 h5 y1182 ff3f fs2 fc0 sc0 ls8 wseb">方法可以接收4个参数：要加载的URL、窗口目标、一个特性字符串以及一个表示新页面是否取代浏览</div><div class="t m0 x0 h4 y1183 ff3f fs2 fc0 sc0 ls8 wseb">器历史记录中当前加载页面的布尔值。通常只须传递第一个参数，最后一个参数只在不打开新窗口的情</div><div class="t m0 x0 h5 y1184 ff3f fs2 fc0 sc0 ls8 wseb">况下使用。 </div><div class="t m0 x0 h4b y1185 ff3f fs2 fc0 sc0 ls8 wseb">如果为window.open()传递了第二个参数，而且该参数是已有窗口或框架的名称，那么就会在具</div><div class="t m0 x0 h5 y1186 ff3f fs2 fc0 sc0 ls8 wseb">有该名称的窗口或框架中加载第一个参数指定的URL。看下面的例子。 </div></div></div>
<div id="pfda" class="pf w0 h0" data-page-no="da"><div class="pc pcda w0 h0"><div class="t m0 x0 h2 y1 ff38 fs0 fc0 sc0 ls7 ws0">200  第8章 BOM </div><div class="t m0 x0 h3 y2 ff38 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y866 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y867 ff40 fs6 fc0 sc0 ls21">//等同于&lt; a href=&quot;http://www.wrox.com&quot; target=&quot;topFrame&quot;&gt;&lt;/a&gt; </div><div class="t m0 x0 hb y868 ff40 fs6 fc0 sc0 ls21 wsb">window.open(&quot;http://www.wrox.com/&quot;, &quot;topFrame&quot;); </div><div class="t m0 x0 hb y1188 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1189 ff3f fs2 fc0 sc0 ls8 wseb">调用这行代码，就如同用户单击了href属性为http://www.wrox.com/，target属性为&quot;topFrame&quot;</div><div class="t m0 x0 h5 y118a ff3f fs2 fc0 sc0 ls8 wseb">的链接。如果有一个名叫&quot;topFrame&quot;的窗口或者框架，就会在该窗口或框架加载这个URL；否则，就</div><div class="t m0 x0 h1e y118b ff3f fs2 fc0 sc0 ls6 wsf7">会创建一个新窗口并将其命名为&quot;topFrame&quot;。此外，第二个参数也可以是下列任何一个特殊的窗口名</div><div class="t m0 x0 hc y118c ff3f fs2 fc0 sc0 ls8 wseb">称：_self、_parent、_top或_blank。 </div><div class="t m0 x0 h3c y118d ff3d fs2 fc0 sc0 ls2e wsb">1. 弹出窗口 </div><div class="t m0 x0 h4 y118e ff3f fs2 fc0 sc0 ls8 wseb">如果给window.open()传递的第二个参数并不是一个已经存在的窗口或框架，那么该方法就会根</div><div class="t m0 x0 h4 y6ea ff3f fs2 fc0 sc0 ls8 wseb">据在第三个参数位置上传入的字符串创建一个新窗口或新标签页。如果没有传入第三个参数，那么就会</div><div class="t m0 x0 h4 y118f ff3f fs2 fc0 sc0 ls8 wseb">打开一个带有全部默认设置（工具栏、地址栏和状态栏等）的新浏览器窗口（或者打开一个新标签页—</div><div class="t m0 x0 h5 y1190 ff3f fs2 fc0 sc0 ls8 wseb">—根据浏览器设置）。在不打开新窗口的情况下，会忽略第三个参数。 </div><div class="t m0 x0 h4 y1191 ff3f fs2 fc0 sc0 ls8 wseb">第三个参数是一个逗号分隔的设置字符串，表示在新窗口中都显示哪些特性。下表列出了可以出现</div><div class="t m0 x0 h5 y1192 ff3f fs2 fc0 sc0 ls8 wseb">在这个字符串中的设置选项。 </div><div class="t m0 x0 hb y1193 ff40 fs6 fc0 sc0 ls8 wsb">  </div><div class="t m0 x0 h31 y1194 ff3c fs6 fc0 sc0 lsa7 wsb">设  置 值 说  明 </div><div class="t m0 x0 h32 y1195 ff40 fsc fc0 sc0 lsa8 wsb">fullscreen  yes或no 表示浏览器窗口是否最大化。仅限IE </div><div class="t m0 x0 h32 y1196 ff40 fsc fc0 sc0 lsa8 wsb">height  数值 表示新窗口的高度。不能小于100 </div><div class="t m0 x0 h32 y1197 ff40 fsc fc0 sc0 lsa8 wsb">left  数值 表示新窗口的左坐标。不能是负值 </div><div class="t m0 x0 h32 y1198 ff40 fsc fc0 sc0 lsa8 wsb">location  yes或no 表示是否在浏览器窗口中显示地址栏。不同浏览器的默认值不同。如果</div><div class="t m0 x7 h36 y1199 ff3f fs6 fc0 sc0 ls31 ws125">设置为no，地址栏可能会隐藏，也可能会被禁用（取决于浏览器） </div><div class="t m0 x0 h32 y119a ff40 fsc fc0 sc0 lsa8 wsb">menubar  yes或no 表示是否在浏览器窗口中显示菜单栏。默认值为no </div><div class="t m0 x0 h32 y119b ff40 fsc fc0 sc0 lsa8 wsb">resizable  yes或no 表示是否可以通过拖动浏览器窗口的边框改变其大小。默认值为no </div><div class="t m0 x0 h32 y119c ff40 fsc fc0 sc0 lsa8 wsb">scrollbars  yes或no 表示如果内容在视口中显示不下，是否允许滚动。默认值为no </div><div class="t m0 x0 h32 y119d ff40 fsc fc0 sc0 lsa8 wsb">status  yes或no 表示是否在浏览器窗口中显示状态栏。默认值为no </div><div class="t m0 x0 h32 y119e ff40 fsc fc0 sc0 lsa8 wsb">toolbar  yes或no 表示是否在浏览器窗口中显示工具栏。默认值为no </div><div class="t m0 x0 h32 y119f ff40 fsc fc0 sc0 lsa8 wsb">top  数值 表示新窗口的上坐标。不能是负值 </div><div class="t m0 x0 h32 y11a0 ff40 fsc fc0 sc0 lsa8 wsb">width  数值 表示新窗口的宽度。不能小于100 </div><div class="t m0 x0 hb y11a1 ff40 fs6 fc0 sc0 ls8 wsb">  </div><div class="t m0 x0 h4 y441 ff3f fs2 fc0 sc0 ls8 wseb">表中所列的部分或全部设置选项，都可以通过逗号分隔的名值对列表来指定。其中，名值对以等号</div><div class="t m0 x0 h5 y11a2 ff3f fs2 fc0 sc0 ls8 wseb">表示（注意，整个特性字符串中不允许出现空格），如下面的例子所示。 </div><div class="t m0 x0 hb y11a3 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y11a4 ff40 fs6 fc0 sc0 ls21 wsb">window.open(&quot;http://www.wrox.com/&quot;,&quot;wroxWindow&quot;, </div><div class="t m0 x0 hb y11a5 ff40 fs6 fc0 sc0 ls21 wsb">            &quot;height=400,width=400,top=10,left=10,resizable=yes&quot;); </div><div class="t m0 x0 hb y11a6 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y11a7 ff3f fs2 fc0 sc0 ls8 wseb">这行代码会打开一个新的可以调整大小的窗口，窗口初始大小为400×400像素，并且距屏幕上沿</div><div class="t m0 x0 h5 y11a8 ff3f fs2 fc0 sc0 ls8 wseb">和左边各10像素。 </div><div class="t m0 x0 h4 y11a9 ff40 fs1 fc0 sc0 ls9 ws2">window.open()方法会返回一个指向新窗口的引用。引用的对象与其他window对象大致相似，但</div><div class="t m0 x0 h4 y11aa ff3f fs2 fc0 sc0 ls8 wseb">我们可以对其进行更多控制。例如，有些浏览器在默认情况下可能不允许我们针对主浏览器窗口调整大</div><div class="t m0 x0 h1c y11ab ff3f fs2 fc0 sc0 ls8 wseb">小或移动位置，但却允许我们针对通过window.open()创建的窗口调整大小或移动位置。通过这个返</div><div class="t m0 x0 h5 y11ac ff3f fs2 fc0 sc0 ls8 wseb">回的对象，可以像操作其他窗口一样操作新打开的窗口，如下所示。 </div><div class="t m0 x0 hb y22 ff40 fs6 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pfdb" class="pf w0 h0" data-page-no="db"><div class="pc pcdb w0 h0"><div class="t m0 x2 h2 y1 ff38 fs0 fc0 sc0 ls10 wsc">8.1 window对象   201 </div><div class="t m0 x0 h3 y2 ff38 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff3a fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff3a fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff3a fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff3a fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff3a fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff3a fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff3a fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff3a fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff3a fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff3a fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff3a fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff3a fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff3a fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y79 ff40 fs6 fc0 sc0 ls21 wsb">var wroxWin = window.open(&quot;http://www.wrox.com/&quot;,&quot;wroxWindow&quot;, </div><div class="t m0 x0 hb y7a ff40 fs6 fc0 sc0 ls21 wsb">                          &quot;height=400,width=400,top=10,left=10,resizable=yes&quot;); </div><div class="t m0 x0 hb y7b ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y7c ff40 fs6 fc0 sc0 ls21">//调整大小 </div><div class="t m0 x0 hb y7d ff40 fs6 fc0 sc0 ls21 wsb">wroxWin.resizeTo(500,500); </div><div class="t m0 x0 hb y7e ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y7f ff40 fs6 fc0 sc0 ls21">//移动位置 </div><div class="t m0 x0 hb y80 ff40 fs6 fc0 sc0 ls21 wsb">wroxWin.moveTo(100,100); </div><div class="t m0 x5 hb yf4a ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y11ad ff3f fs2 fc0 sc0 ls8 wseb">调用close()方法还可以关闭新打开的窗口。 </div><div class="t m0 x5 hb y11ae ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y11af ff40 fs6 fc0 sc0 ls21 wsb">wroxWin.close(); </div><div class="t m0 x5 hb y11b0 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y11b1 ff3f fs2 fc0 sc0 ls8 wseb">但是，这个方法仅适用于通过window.open()打开的弹出窗口。对于浏览器的主窗口，如果没有</div><div class="t m0 x0 h1e y11b2 ff3f fs2 fc0 sc0 ls8 wseb">得到用户的允许是不能关闭它的。不过，弹出窗口倒是可以调用top.close()在不经用户允许的情况</div><div class="t m0 x0 h4 y18a ff3f fs2 fc0 sc0 ls8 wseb">下关闭自己。弹出窗口关闭之后，窗口的引用仍然还在，但除了像下面这样检测其closed属性之外，</div><div class="t m0 x0 h5 y11b3 ff3f fs2 fc0 sc0 ls8 wseb">已经没有其他用处了。 </div><div class="t m0 x5 hb y11b4 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y11b5 ff40 fs6 fc0 sc0 ls21 wsb">wroxWin.close(); </div><div class="t m0 x0 h15 y11b6 ff41 fs6 fc0 sc0 ls21 wsb">alert(wroxWin.closed);  //true </div><div class="t m0 x5 hb y11b7 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y11b8 ff3f fs2 fc0 sc0 ls1f ws108">新创建的window对象有一个opener属性，其中保存着打开它的原始窗口对象。这个属性只在弹出</div><div class="t m0 x0 hc y11b9 ff3f fs2 fc0 sc0 ls1f ws108">窗口中的最外层window对象（top）中有定义，而且指向调用window.open()的窗口或框架。例如： </div><div class="t m0 x5 hb y11ba ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y11bb ff40 fs6 fc0 sc0 ls21 wsb">var wroxWin = window.open(&quot;http://www.wrox.com/&quot;,&quot;wroxWindow&quot;, </div><div class="t m0 x0 hb y11bc ff40 fs6 fc0 sc0 ls21 wsb">                          &quot;height=400,width=400,top=10,left=10,resizable=yes&quot;); </div><div class="t m0 x0 hb y11bd ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y11be ff41 fs6 fc0 sc0 ls21 wsb">alert(wroxWin.opener == window);   //true </div><div class="t m0 x5 hb y11bf ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y11c0 ff3f fs2 fc0 sc0 ls24 wsf5">虽然弹出窗口中有一个指针指向打开它的原始窗口，但原始窗口中并没有这样的指针指向弹出窗</div><div class="t m0 x0 h5 y11c1 ff3f fs2 fc0 sc0 ls8 wseb">口。窗口并不跟踪记录它们打开的弹出窗口，因此我们只能在必要的时候自己来手动实现跟踪。 </div><div class="t m0 x0 h5 y11c2 ff3f fs2 fc0 sc0 ls8 wseb">有些浏览器（如IE8和Chrome）会在独立的进程中运行每个标签页。当一个标签页打开另一个标</div><div class="t m0 x0 he y11c3 ff3f fs2 fc0 sc0 ls8 wseb">签页时，如果两个window对象之间需要彼此通信，那么新标签页就不能运行在独立的进程中。在Chrome</div><div class="t m0 x0 hc y11c4 ff3f fs2 fc0 sc0 ls8 wseb">中，将新创建的标签页的opener属性设置为null，即表示在单独的进程中运行新标签页，如下所示。 </div><div class="t m0 x5 hb y11c5 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y11c6 ff40 fs6 fc0 sc0 ls21 wsb">var wroxWin = window.open(&quot;http://www.wrox.com/&quot;,&quot;wroxWindow&quot;, </div><div class="t m0 x0 hb y11c7 ff40 fs6 fc0 sc0 ls21 wsb">                          &quot;height=400,width=400,top=10,left=10,resizable=yes&quot;); </div><div class="t m0 x0 hb y11c8 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y11c9 ff41 fs6 fc0 sc0 ls21 wsb">wroxWin.opener = null; </div><div class="t m0 x5 hb y11ca ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y11cb ff3f fs2 fc0 sc0 ls2c">将opener属性设置为null就是告诉浏览器新创建的标签页不需要与打开它的标签页通信，因此</div><div class="t m0 x0 h5 y11cc ff3f fs2 fc0 sc0 ls8 wseb">可以在独立的进程中运行。标签页之间的联系一旦切断，将没有办法恢复。 </div><div class="t m0 x0 h3c y11cd ff3d fs2 fc0 sc0 ls2e wsb">2. 安全限制 </div><div class="t m0 x0 h4 y11ce ff3f fs2 fc0 sc0 ls8 wseb">曾经有一段时间，广告商在网上使用弹出窗口达到了肆无忌惮的程度。他们经常把弹出窗口打扮成</div><div class="t m0 x0 h4 y11cf ff3f fs2 fc0 sc0 ls8 wseb">系统对话框的模样，引诱用户去点击其中的广告。由于看起来像是系统对话框，一般用户很难分辨是真</div><div class="t m0 x0 h5 y11d0 ff3f fs2 fc0 sc0 ls8 wseb">是假。为了解决这个问题，有些浏览器开始在弹出窗口配置方面增加限制。 </div><div class="t m0 x0 h5 y11d1 ff38 fs2 fc0 sc0 lsc7 ws159">Windows XP SP2中的IE6对弹出窗口施加了多方面的安全限制，包括不允许在屏幕之外创建弹出窗</div><div class="t m0 x0 h5 y11d2 ff3f fs2 fc0 sc0 ls8 wseb">口、不允许将弹出窗口移动到屏幕以外、不允许关闭状态栏等。IE7则增加了更多的安全限制，如不允</div><div class="t m0 x0 h5 y11d3 ff3f fs2 fc0 sc0 ls8 wseb">许关闭地址栏、默认情况下不允许移动弹出窗口或调整其大小。Firefox 1从一开始就不支持修改状态栏，</div><div class="t m0 x0 h7d y11d4 ff3f fs2 fc0 sc0 ls8 wseb">因此无论给window.open()传入什么样的特性字符串，弹出窗口中都会无一例外地显示状态栏。后来</div></div></div>
<div id="pfdc" class="pf w0 h0" data-page-no="dc"><div class="pc pcdc w0 h0"><div class="t m0 x0 h2 y1 ff38 fs0 fc0 sc0 ls7 ws0">202  第8章 BOM </div><div class="t m0 x0 h3 y2 ff38 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff3f fs2 fc0 sc0 ls3b">的Firefox 3又强制始终在弹出窗口中显示地址栏。Opera只会在主浏览器窗口中打开弹出窗口，但不允</div><div class="t m0 x0 h5 y4d ff3f fs2 fc0 sc0 ls8 wseb">许它们出现在可能与系统对话框混淆的地方。 </div><div class="t m0 x0 h4 yd8 ff3f fs2 fc0 sc0 ls19 wsfb">此外，有的浏览器只根据用户操作来创建弹出窗口。这样一来，在页面尚未加载完成时调用</div><div class="t m0 x0 h4 yd9 ff40 fs1 fc0 sc0 ls9 ws2">window.open()的语句根本不会执行，而且还可能会将错误消息显示给用户。换句话说，只能通过单</div><div class="t m0 x0 h5 y15d ff3f fs2 fc0 sc0 ls8 wseb">击或者击键来打开弹出窗口。 </div><div class="t m0 x0 h5 y2b3 ff3f fs2 fc0 sc0 ls6 wsf7">对于那些不是用户有意打开的弹出窗口，Chrome采取了不同的处理方式。它不会像其他浏览器那</div><div class="t m0 x0 h5 y765 ff3f fs2 fc0 sc0 ls8 wseb">样简单地屏蔽这些弹出窗口，而是只显示它们的标题栏，并把它们放在浏览器窗口的右下角。 </div><div class="t m0 x5 h5 y11d6 ff39 fs2 fc0 sc0 ls8 ws14">在打开计算机硬盘中的网页时，IE会解除对弹出窗口的某些限制。但是在服务器</div><div class="t m0 x0 h5 y11d7 ff39 fs2 fc0 sc0 ls8 ws14">上执行这些代码会受到对弹出窗口的限制。 </div><div class="t m0 x0 h3c y11d8 ff3d fs2 fc0 sc0 ls2e wsb">3. 弹出窗口屏蔽程序 </div><div class="t m0 x0 h5 y11d9 ff3f fs2 fc0 sc0 ls55 wsfc">大多数浏览器都内置有弹出窗口屏蔽程序，而没有内置此类程序的浏览器，也可以安装Yahoo! </div><div class="t m0 x0 h5 y11da ff38 fs2 fc0 sc0 ls8 ws20">Toolbar等带有内置屏蔽程序的实用工具。结果就是用户可以将绝大多数不想看到弹出窗口屏蔽掉。于</div><div class="t m0 x0 h4 y11db ff3f fs2 fc0 sc0 ls8 wseb">是，在弹出窗口被屏蔽时，就应该考虑两种可能性。如果是浏览器内置的屏蔽程序阻止的弹出窗口，那</div><div class="t m0 x0 h7f y11dc ff3f fs2 fc0 sc0 ls1a4">么window.open()很可能会返回null。此时，只要检测这个返回的值就可以确定弹出窗口是否被屏蔽</div><div class="t m0 x0 h5 y11dd ff3f fs2 fc0 sc0 ls8 wseb">了，如下面的例子所示。 </div><div class="t m0 x0 hb y11de ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y11df ff40 fs6 fc0 sc0 ls21 wsb">var wroxWin = window.open(&quot;http://www.wrox.com&quot;, &quot;_blank&quot;); </div><div class="t m0 x0 hb y11e0 ff40 fs6 fc0 sc0 ls21 wsb">if (wroxWin == null){ </div><div class="t m0 x0 hb y11e1 ff40 fs6 fc0 sc0 ls21 wsb">    alert(&quot;The popup was blocked!&quot;); </div><div class="t m0 x0 hb y11e2 ff40 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h4 y11e3 ff3f fs2 fc0 sc0 ls8 wseb">如果是浏览器扩展或其他程序阻止的弹出窗口，那么window.open()通常会抛出一个错误。因此，</div><div class="t m0 x0 h1e y11e4 ff3f fs2 fc0 sc0 ls8 wseb">要想准确地检测出弹出窗口是否被屏蔽，必须在检测返回值的同时，将对window.open()的调用封装</div><div class="t m0 x0 hc y1021 ff3f fs2 fc0 sc0 ls8 wseb">在一个try-catch块中，如下所示。 </div><div class="t m0 x0 hb y11e5 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y11e6 ff41 fs6 fc0 sc0 ls21 wsb">var blocked = false; </div><div class="t m0 x0 h15 y11e7 ff41 fs6 fc0 sc0 ls21 wsb">             </div><div class="t m0 x0 h15 y11e8 ff41 fs6 fc0 sc0 ls21 wsb">try { </div><div class="t m0 x0 hb y11e9 ff40 fs6 fc0 sc0 ls21 wsb">    var wroxWin = window.open(&quot;http://www.wrox.com&quot;, &quot;_blank&quot;); </div><div class="t m0 x0 hb y11ea ff40 fs6 fc0 sc0 ls21 wsb">    if (wroxWin == null){ </div><div class="t m0 x0 h15 y11eb ff41 fs6 fc0 sc0 ls21 wsb">        blocked = true; </div><div class="t m0 x0 hb y11ec ff40 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y11ed ff41 fs6 fc0 sc0 ls16f">} catch (ex){ </div><div class="t m0 x0 h15 y11ee ff41 fs6 fc0 sc0 ls21 wsb">    blocked = true; </div><div class="t m0 x0 h15 y11ef ff41 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 h15 y11f0 ff41 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y11f1 ff41 fs6 fc0 sc0 ls21 wsb">if (blocked){ </div><div class="t m0 x0 h15 y11f2 ff41 fs6 fc0 sc0 ls21 wsb">    alert(&quot;The popup was blocked!&quot;); </div><div class="t m0 x0 h15 y11f3 ff41 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x2 hf y11f4 ff46 fs2 fc0 sc0 ls8 wsb">PopupBlockerExample01.htm </div><div class="t m0 x0 h4 y11f5 ff3f fs2 fc0 sc0 ls8 wseb">在任何情况下，以上代码都可以检测出调用window.open()打开的弹出窗口是不是被屏蔽了。但</div><div class="t m0 x0 h4 y11f6 ff3f fs2 fc0 sc0 ls8 wseb">要注意的是，检测弹出窗口是否被屏蔽只是一方面，它并不会阻止浏览器显示与被屏蔽的弹出窗口有关</div><div class="t m0 x0 h5 y11f7 ff3f fs2 fc0 sc0 ls8">的消息。 </div></div></div>
<div id="pfdd" class="pf w0 h0" data-page-no="dd"><div class="pc pcdd w0 h0"><div class="t m0 x2 h2 y1 ff38 fs0 fc0 sc0 ls10 wsc">8.1 window对象   203 </div><div class="t m0 x0 h3 y2 ff38 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff3a fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff3a fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff3a fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff3a fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff3a fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff3a fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff3a fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff3a fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff3a fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff3a fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff3a fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff3a fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff3a fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h20 y12d ff3d fs3 fc0 sc0 ls4d ws40">8.1.6 间歇调用和超时调用 </div><div class="t m0 x0 h5 y12e ff38 fs2 fc0 sc0 lsb ws5">JavaScript是单线程语言，但它允许通过设置超时值和间歇时间值来调度代码在特定的时刻执行。</div><div class="t m0 x0 h5 y12f ff3f fs2 fc0 sc0 ls8 wseb">前者是在指定的时间过后执行代码，而后者则是每隔指定的时间就执行一次代码。 </div><div class="t m0 x0 h1e y130 ff3f fs2 fc0 sc0 ls8 wseb">超时调用需要使用window对象的setTimeout()方法，它接受两个参数：要执行的代码和以毫秒</div><div class="t m0 x0 h5 y131 ff3f fs2 fc0 sc0 ls8 wseb">表示的时间（即在执行代码前需要等待多少毫秒）。其中，第一个参数可以是一个包含JavaScript代码的</div><div class="t m0 x0 h1c y11f8 ff3f fs2 fc0 sc0 ls8 wseb">字符串（就和在eval()函数中使用的字符串一样），也可以是一个函数。例如，下面对setTimeout()</div><div class="t m0 x0 h5 y11f9 ff3f fs2 fc0 sc0 ls8 wseb">的两次调用都会在一秒钟后显示一个警告框。 </div><div class="t m0 x5 hb y11fa ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y11fb ff40 fs6 fc0 sc0 ls21">//不建议传递字符串！ </div><div class="t m0 x0 hb y11fc ff40 fs6 fc0 sc0 ls21 wsb">setTimeout(&quot;alert(&apos;Hello world!&apos;) &quot;, 1000); </div><div class="t m0 x0 hb y11fd ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y11fe ff40 fs6 fc0 sc0 ls21">//推荐的调用方式 </div><div class="t m0 x0 hb y11ff ff40 fs6 fc0 sc0 ls21 wsb">setTimeout(function() {  </div><div class="t m0 x0 hb y1200 ff40 fs6 fc0 sc0 ls21 wsb">    alert(&quot;Hello world!&quot;);  </div><div class="t m0 x0 hb y1201 ff40 fs6 fc0 sc0 ls21 wsb">}, 1000); </div><div class="t m0 x5 hb y1202 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf yf91 ff46 fs2 fc0 sc0 ls1b wsb">TimeoutExample01.htm </div><div class="t m0 x0 h4 y1203 ff3f fs2 fc0 sc0 ls8 wseb">虽然这两种调用方式都没有问题，但由于传递字符串可能导致性能损失，因此不建议以字符串作为</div><div class="t m0 x0 h5 y1204 ff3f fs2 fc0 sc0 ls8 wseb">第一个参数。 </div><div class="t m0 x0 h4 y1205 ff3f fs2 fc0 sc0 ls19 wsfb">第二个参数是一个表示等待多长时间的毫秒数，但经过该时间后指定的代码不一定会执行。</div><div class="t m0 x0 h5 y1206 ff38 fs2 fc0 sc0 lsb ws5">JavaScript是一个单线程序的解释器，因此一定时间内只能执行一段代码。为了控制要执行的代码，就</div><div class="t m0 x0 h5 y1207 ff3f fs2 fc0 sc0 ls8 wseb">有一个JavaScript任务队列。这些任务会按照将它们添加到队列的顺序执行。setTimeout()的第二个</div><div class="t m0 x0 h5 y1208 ff3f fs2 fc0 sc0 ls8 wseb">参数告诉JavaScript再过多长时间把当前任务添加到队列中。如果队列是空的，那么添加的代码会立即</div><div class="t m0 x0 h5 y1209 ff3f fs2 fc0 sc0 ls8 wseb">执行；如果队列不是空的，那么它就要等前面的代码执行完了以后再执行。 </div><div class="t m0 x0 he y120a ff3f fs2 fc0 sc0 ls8 wseb">调用setTimeout()之后，该方法会返回一个数值ID，表示超时调用。这个超时调用ID是计划执</div><div class="t m0 x0 h4 y120b ff3f fs2 fc0 sc0 ls19">行代码的唯一标识符，可以通过它来取消超时调用。要取消尚未执行的超时调用计划，可以调用</div><div class="t m0 x0 h5 y120c ff40 fs1 fc0 sc0 ls9 ws2">clearTimeout()方法并将相应的超时调用ID作为参数传递给它，如下所示。 </div><div class="t m0 x5 hb y120d ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y120e ff40 fs6 fc0 sc0 ls21">//设置超时调用 </div><div class="t m0 x0 hb y120f ff40 fs6 fc0 sc0 ls21 wsb">var timeoutId = setTimeout(function() { </div><div class="t m0 x0 hb y1210 ff40 fs6 fc0 sc0 ls21 wsb">    alert(&quot;Hello world!&quot;); </div><div class="t m0 x0 hb y1211 ff40 fs6 fc0 sc0 ls21 wsb">}, 1000); </div><div class="t m0 x0 hb y1212 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1213 ff40 fs6 fc0 sc0 ls21">//注意：把它取消 </div><div class="t m0 x0 hb y1214 ff40 fs6 fc0 sc0 ls21 wsb">clearTimeout(timeoutId); </div><div class="t m0 x5 hb y1215 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1216 ff46 fs2 fc0 sc0 ls1b wsb">TimeoutExample02.htm </div><div class="t m0 x0 h4 y1217 ff3f fs2 fc0 sc0 ls8 wseb">只要是在指定的时间尚未过去之前调用clearTimeout()，就可以完全取消超时调用。前面的代码</div><div class="t m0 x0 hc y1218 ff3f fs2 fc0 sc0 ls8 wseb">在设置超时调用之后马上又调用了clearTimeout()，结果就跟什么也没有发生一样。 </div><div class="t m0 x5 h40 y1219 ff39 fs2 fc0 sc0 ls8 ws14">超时调用的代码都是在全局作用域中执行的，因此函数中this的值在非严格模</div><div class="t m0 x5 h18 y121a ff39 fs2 fc0 sc0 ls8 ws14">式下指向window对象，在严格模式下是undefined。 </div><div class="t m0 x0 h4 y121b ff3f fs2 fc0 sc0 ls8 wseb">间歇调用与超时调用类似，只不过它会按照指定的时间间隔重复执行代码，直至间歇调用被取消或</div><div class="t m0 x0 h80 y121c ff3f fs2 fc0 sc0 ls8 wseb">者页面被卸载。设置间歇调用的方法是setInterval()，它接受的参数与setTimeout()相同：要执</div></div></div>
<div id="pfde" class="pf w0 h0" data-page-no="de"><div class="pc pcde w0 h0"><div class="t m0 x0 h2 y1 ff38 fs0 fc0 sc0 ls7 ws0">204  第8章 BOM </div><div class="t m0 x0 h3 y2 ff38 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff3f fs2 fc0 sc0 ls8 wseb">行的代码（字符串或函数）和每次执行之前需要等待的毫秒数。下面来看一个例子。 </div><div class="t m0 x0 hb y121e ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y121f ff40 fs6 fc0 sc0 ls21">//不建议传递字符串！ </div><div class="t m0 x0 hb y1220 ff40 fs6 fc0 sc0 ls21 wsb">setInterval (&quot;alert(&apos;Hello world!&apos;) &quot;, 10000); </div><div class="t m0 x0 hb y1221 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1222 ff40 fs6 fc0 sc0 ls21">//推荐的调用方式 </div><div class="t m0 x0 hb y1223 ff40 fs6 fc0 sc0 ls21 wsb">setInterval (function() {  </div><div class="t m0 x0 hb y1224 ff40 fs6 fc0 sc0 ls21 wsb">    alert(&quot;Hello world!&quot;);  </div><div class="t m0 x0 hb y1225 ff40 fs6 fc0 sc0 ls21 wsb">}, 10000); </div><div class="t m0 x0 hb y1226 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1227 ff46 fs2 fc0 sc0 ls1b wsb">IntervalExample01.htm </div><div class="t m0 x0 h5 y1228 ff3f fs2 fc0 sc0 ls8 wseb">调用setInterval()方法同样也会返回一个间歇调用ID，该ID可用于在将来某个时刻取消间歇</div><div class="t m0 x0 hc y1229 ff3f fs2 fc0 sc0 ls8 wseb">调用。要取消尚未执行的间歇调用，可以使用clearInterval()方法并传入相应的间歇调用ID。取消</div><div class="t m0 x0 h4 y122a ff3f fs2 fc0 sc0 ls8 wseb">间歇调用的重要性要远远高于取消超时调用，因为在不加干涉的情况下，间歇调用将会一直执行到页面</div><div class="t m0 x0 h5 y122b ff3f fs2 fc0 sc0 ls8 wseb">卸载。以下是一个常见的使用间歇调用的例子。 </div><div class="t m0 x0 hb yccf ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ycd0 ff40 fs6 fc0 sc0 ls21 wsb">var num = 0; </div><div class="t m0 x0 hb y122c ff40 fs6 fc0 sc0 ls21 wsb">var max = 10; </div><div class="t m0 x0 hb y122d ff40 fs6 fc0 sc0 ls21 wsb">var intervalId = null; </div><div class="t m0 x0 hb y122e ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y122f ff40 fs6 fc0 sc0 ls21 wsb">function incrementNumber() { </div><div class="t m0 x0 hb y1230 ff40 fs6 fc0 sc0 ls21 wsb">    num++; </div><div class="t m0 x0 hb y1231 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1232 ff40 fs6 fc0 sc0 ls21 wsb">    //如果执行次数达到了max设定的值，则取消后续尚未执行的调用 </div><div class="t m0 x0 hb y1233 ff40 fs6 fc0 sc0 ls21 wsb">    if (num == max) { </div><div class="t m0 x0 hb y1234 ff40 fs6 fc0 sc0 ls21 wsb">        clearInterval(intervalId); </div><div class="t m0 x0 hb y1235 ff40 fs6 fc0 sc0 ls21 wsb">        alert(&quot;Done&quot;); </div><div class="t m0 x0 hb y1236 ff40 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y1237 ff40 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y1238 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1239 ff40 fs6 fc0 sc0 ls21 wsb">intervalId = setInterval(incrementNumber, 500); </div><div class="t m0 x0 hb y123a ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y123b ff46 fs2 fc0 sc0 ls1b wsb">IntervalExample02.htm </div><div class="t m0 x0 h4 y123c ff3f fs2 fc0 sc0 ls8 wseb">在这个例子中，变量num每半秒钟递增一次，当递增到最大值时就会取消先前设定的间歇调用。这</div><div class="t m0 x0 h5 y123d ff3f fs2 fc0 sc0 ls8 wseb">个模式也可以使用超时调用来实现，如下所示。 </div><div class="t m0 x0 hb y123e ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y123f ff40 fs6 fc0 sc0 ls21 wsb">var num = 0; </div><div class="t m0 x0 hb y1240 ff40 fs6 fc0 sc0 ls21 wsb">var max = 10; </div><div class="t m0 x0 hb y1241 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1242 ff40 fs6 fc0 sc0 ls21 wsb">function incrementNumber() { </div><div class="t m0 x0 hb y1243 ff40 fs6 fc0 sc0 ls21 wsb">    num++; </div><div class="t m0 x0 hb y1244 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1245 ff41 fs6 fc0 sc0 ls21 wsb">    //如果执行次数未达到max设定的值，则设置另一次超时调用 </div><div class="t m0 x0 h15 y1246 ff41 fs6 fc0 sc0 ls21 wsb">    if (num &lt; max) { </div><div class="t m0 x0 h15 y1247 ff41 fs6 fc0 sc0 ls21 wsb">        setTimeout(incrementNumber, 500); </div><div class="t m0 x0 h15 y1248 ff41 fs6 fc0 sc0 ls21 wsb">    } else { </div><div class="t m0 x0 h15 y1249 ff41 fs6 fc0 sc0 ls21 wsb">        alert(&quot;Done&quot;); </div><div class="t m0 x0 h15 y124a ff41 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y124b ff40 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y124c ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y124d ff41 fs6 fc0 sc0 ls21 wsb">setTimeout(incrementNumber, 500); </div><div class="t m0 x0 hb y124e ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y124f ff46 fs2 fc0 sc0 ls1b wsb">TimeoutExample03.htm </div></div></div>
<div id="pfdf" class="pf w0 h0" data-page-no="df"><div class="pc pcdf w0 h0"><div class="t m0 x2 h2 y1 ff38 fs0 fc0 sc0 ls10 wsc">8.1 window对象   205 </div><div class="t m0 x0 h3 y2 ff38 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff3a fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff3a fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff3a fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff3a fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff3a fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff3a fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff3a fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff3a fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff3a fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff3a fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff3a fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff3a fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff3a fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff3f fs2 fc0 sc0 ls6 wsf7">可见，在使用超时调用时，没有必要跟踪超时调用ID，因为每次执行代码之后，如果不再设置另</div><div class="t m0 x0 h4 y4d ff3f fs2 fc0 sc0 ls8 wseb">一次超时调用，调用就会自行停止。一般认为，使用超时调用来模拟间歇调用的是一种最佳模式。在开</div><div class="t m0 x0 h4 yd8 ff3f fs2 fc0 sc0 ls8 wseb">发环境下，很少使用真正的间歇调用，原因是后一个间歇调用可能会在前一个间歇调用结束之前启动。</div><div class="t m0 x0 h5 y28b ff3f fs2 fc0 sc0 ls8 wseb">而像前面示例中那样使用超时调用，则完全可以避免这一点。所以，最好不要使用间歇调用。 </div><div class="t m0 x0 h20 y1250 ff3d fs3 fc0 sc0 ls4d ws40">8.1.7 系统对话框 </div><div class="t m0 x0 h4 y1251 ff3f fs2 fc0 sc0 ls8 wseb">浏览器通过alert()、confirm()和prompt()方法可以调用系统对话框向用户显示消息。系统对</div><div class="t m0 x0 h5 y1f6 ff3f fs2 fc0 sc0 ls8 wseb">话框与在浏览器中显示的网页没有关系，也不包含HTML。它们的外观由操作系统及（或）浏览器设置</div><div class="t m0 x0 h5 y1252 ff3f fs2 fc0 sc0 ls6 wsf7">决定，而不是由CSS决定。此外，通过这几个方法打开的对话框都是同步和模态的。也就是说，显示这</div><div class="t m0 x0 h5 y1253 ff3f fs2 fc0 sc0 ls8 wseb">些对话框的时候代码会停止执行，而关掉这些对话框后代码又会恢复执行。 </div><div class="t m0 x0 h4b y1254 ff3f fs2 fc0 sc0 ls8 wseb">本书各章经常会用到alert()方法，这个方法接受一个字符串并将其显示给用户。具体来说，调用</div><div class="t m0 x0 h5 y1255 ff40 fs1 fc0 sc0 ls9 ws2">alert()方法的结果就是向用户显示一个系统对话框，其中包含指定的文本和一个OK（“确定”）按钮。</div><div class="t m0 x0 hc y1256 ff3f fs2 fc0 sc0 ls8 wseb">例如，alert(&quot;Hello world!&quot;)会在Windows XP系统的IE中生成如图8-3 所示的对话框。 </div><div class="t m0 x0 h1e y1257 ff3f fs2 fc0 sc0 ls8 wseb">通常使用alert()生成的“警告”对话框向用户显示一些他们无法控制的消息，例如错误消息。而</div><div class="t m0 x0 h5 y1258 ff3f fs2 fc0 sc0 ls8 wseb">用户只能在看完消息后关闭对话框。 </div><div class="t m0 x0 h1e y1259 ff3f fs2 fc0 sc0 ls6 wsf7">第二种对话框是调用confirm()方法生成的。从向用户显示消息的方面来看，这种“确认”对话</div><div class="t m0 x0 h5 y125a ff3f fs2 fc0 sc0 ls8 wseb">框很像是一个“警告”对话框。但二者的主要区别在于“确认”对话框除了显示OK按钮外，还会显示</div><div class="t m0 x0 h5 y125b ff3f fs2 fc0 sc0 ls8 wseb">一个Cancel（“取消”）按钮，两个按钮可以让用户决定是否执行给定的操作。例如，confirm(&quot;Are you </div><div class="t m0 x0 h5 y125c ff40 fs1 fc0 sc0 ls9 ws2">sure?&quot;)会显示如图8-4所示的确认对话框。 </div><div class="t m0 x7 h5 y123b ff38 fs2 fc0 sc0 ls8 wsb">   </div><div class="t m0 x1 h3 y125d ff3f fs1 fc0 sc0 ls8 wsb">图 8-3  图 8-4 </div><div class="t m0 x0 h5 y125e ff3f fs2 fc0 sc0 ls8 wseb">为了确定用户是单击了OK还是Cancel，可以检查confirm()方法返回的布尔值：true表示单击</div><div class="t m0 x0 h5 y125f ff3f fs2 fc0 sc0 ls3b">了OK，false表示单击了Cancel或单击了右上角的X按钮。确认对话框的典型用法如下。 </div><div class="t m0 x5 hb y1260 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1261 ff40 fs6 fc0 sc0 ls21 wsb">if (confirm(&quot;Are you sure?&quot;)) { </div><div class="t m0 x0 hb y1262 ff40 fs6 fc0 sc0 ls21 wsb">    alert(&quot;I&apos;m so glad you&apos;re sure! &quot;); </div><div class="t m0 x0 hb y1263 ff40 fs6 fc0 sc0 ls21 wsb">} else { </div><div class="t m0 x0 hb y1264 ff40 fs6 fc0 sc0 ls21 wsb">    alert(&quot;I&apos;m sorry to hear you&apos;re not sure. &quot;); </div><div class="t m0 x0 hb y1265 ff40 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h5 y1266 ff3f fs2 fc0 sc0 ls8 wseb">在这个例子中，第一行代码（if条件语句）会向用户显示一个确认对话框。如果用户单击了OK，</div><div class="t m0 x0 h5 y1267 ff3f fs2 fc0 sc0 ls8 wseb">则通过一个警告框向用户显示消息I’m so glad you’ re sure! 。如果用户单击的是Cancel按钮，则通过警</div><div class="t m0 x0 h5 y1268 ff3f fs2 fc0 sc0 ls8 wseb">告框显示I’m sorry to hear you’re not sure.。这种模式经常在用户想要执行删除操作的时候使用，例如删</div><div class="t m0 x0 h5 y1269 ff3f fs2 fc0 sc0 ls8 wseb">除电子邮件。 </div><div class="t m0 x0 h4b y126a ff3f fs2 fc0 sc0 ls8 wseb">最后一种对话框是通过调用prompt()方法生成的，这是一个“提示”框，用于提示用户输入一些</div><div class="t m0 x0 h5 y126b ff3f fs2 fc0 sc0 ls8 wseb">文本。提示框中除了显示OK和Cancel按钮之外，还会显示一个文本输入域，以供用户在其中输入内容。</div><div class="t m0 x0 h4 y126c ff40 fs1 fc0 sc0 ls9 ws2">prompt()方法接受两个参数：要显示给用户的文本提示和文本输入域的默认值（可以是一个空字符串）。</div></div></div>
<div id="pfe0" class="pf w0 h0" data-page-no="e0"><div class="pc pce0 w0 h0"><div class="t m0 x0 h2 y1 ff38 fs0 fc0 sc0 ls7 ws0">206  第8章 BOM </div><div class="t m0 x0 h3 y2 ff38 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff3f fs2 fc0 sc0 ls8 wseb">调用prompt(&quot;What&apos;s your name?&quot;,&quot;Michael&quot;)会得到如图8-5所示的对话框。 </div><div class="t m0 x2 h5 y2b4 ff38 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x7 h3 y126e ff3f fs1 fc0 sc0 ls8 wsb">图 8-5 </div><div class="t m0 x0 h5 y126f ff3f fs2 fc0 sc0 ls8 wseb">如果用户单击了OK按钮，则prompt()返回文本输入域的值；如果用户单击了Cancel或没有单击</div><div class="t m0 x0 h5 y89f ff38 fs2 fc0 sc0 ls81 ws76">OK而是通过其他方式关闭了对话框，则该方法返回null。下面是一个例子。 </div><div class="t m0 x0 hb yfbd ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1270 ff40 fs6 fc0 sc0 ls21 wsb">var result = prompt(&quot;What is your name? &quot;, &quot;&quot;); </div><div class="t m0 x0 hb y1271 ff40 fs6 fc0 sc0 ls21 wsb">if (result !== null) { </div><div class="t m0 x0 hb y1272 ff40 fs6 fc0 sc0 ls21 wsb">    alert(&quot;Welcome, &quot; + result); </div><div class="t m0 x0 hb y1273 ff40 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h5 y1274 ff3f fs2 fc0 sc0 ls8 wseb">综上所述，这些系统对话框很适合向用户显示消息并请用户作出决定。由于不涉及HTML、CSS或</div><div class="t m0 x0 h5 y1275 ff38 fs2 fc0 sc0 lsb ws5">JavaScript，因此它们是增强Web应用程序的一种便捷方式。 </div><div class="t m0 x0 h5 y1276 ff3f fs2 fc0 sc0 ls8 wseb">除了上述三种对话框之外，Google Chrome浏览器还引入了一种新特性。如果当前脚本在执行过程</div><div class="t m0 x0 h4 y1277 ff3f fs2 fc0 sc0 ls8 wseb">中会打开两个或多个对话框，那么从第二个对话框开始，每个对话框中都会显示一个复选框，以便用户</div><div class="t m0 x0 h5 y1278 ff3f fs2 fc0 sc0 ls8 wseb">阻止后续的对话框显示，除非用户刷新页面（见图8-6）。 </div><div class="t m0 x2 h5 y1279 ff38 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x7 h3 y127a ff3f fs1 fc0 sc0 ls8 wsb">图 8-6 </div><div class="t m0 x0 h4 y127b ff3f fs2 fc0 sc0 ls8 wseb">如果用户勾选了其中的复选框，并且关闭了对话框，那么除非用户刷新页面，所有后续的系统对话</div><div class="t m0 x0 h5 y127c ff3f fs2 fc0 sc0 ls6 wsf7">框（包括警告框、确认框和提示框）都会被屏蔽。Chrome没有就对话框是否显示向开发人员提供任何</div><div class="t m0 x0 h4 y127d ff3f fs2 fc0 sc0 ls8 wseb">信息。由于浏览器会在空闲时重置对话框计数器，因此如果两次独立的用户操作分别打开两个警告框，</div><div class="t m0 x0 h4 y127e ff3f fs2 fc0 sc0 ls8 wseb">那么这两个警告框中都不会显示复选框。而如果是同一次用户操作会生成两个警告框，那么第二个警告</div><div class="t m0 x0 h5 y127f ff3f fs2 fc0 sc0 ls8 wseb">框中就会显示复选框。这个新特性出现以后，IE9和Firefox 4也实现了它。 </div><div class="t m0 x0 h5 y1280 ff3f fs2 fc0 sc0 ls5 wsec">还有两个可以通过JavaScript打开的对话框，即“查找”和“打印”。这两个对话框都是异步显示</div><div class="t m0 x0 h4 y1281 ff3f fs2 fc0 sc0 ls24">的，能够将控制权立即交还给脚本。这两个对话框与用户通过浏览器菜单的“查找”和“打印”命令</div><div class="t m0 x0 h5 y1282 ff3f fs2 fc0 sc0 ls5 wsec">打开的对话框相同。而在JavaScript中则可以像下面这样通过window对象的find()和print()方法</div><div class="t m0 x0 h5 y1283 ff3f fs2 fc0 sc0 ls42 wsf0">打开它们。 </div><div class="t m0 x0 hb y1284 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1285 ff40 fs6 fc0 sc0 ls21">//显示“打印”对话框 </div><div class="t m0 x0 hb y1286 ff40 fs6 fc0 sc0 ls21 wsb">window.print(); </div><div class="t m0 x0 hb y1287 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1288 ff40 fs6 fc0 sc0 ls21">//显示“查找”对话框 </div><div class="t m0 x0 hb y1289 ff40 fs6 fc0 sc0 ls21 wsb">window.find(); </div><div class="t m0 x0 hb y128a ff40 fs6 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pfe1" class="pf w0 h0" data-page-no="e1"><div class="pc pce1 w0 h0"><div class="t m0 x2 h2 y1 ff38 fs0 fc0 sc0 ls10 wsc">8.2 location对象   207 </div><div class="t m0 x0 h3 y2 ff38 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff3a fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff3a fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff3a fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff3a fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff3a fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff3a fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff3a fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff3a fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff3a fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff3a fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff3a fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff3a fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff3a fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h4 y3 ff3f fs2 fc0 sc0 ls8 wseb">这两个方法同样不会就用户在对话框中的操作给出任何信息，因此它们的用处有限。另外，既然这</div><div class="t m0 x0 h5 y4d ff3f fs2 fc0 sc0 ls8 wseb">两个对话框是异步显示的，那么Chrome的对话框计数器就不会将它们计算在内，所以它们也不会受用</div><div class="t m0 x0 h5 yd8 ff3f fs2 fc0 sc0 ls8 wseb">户禁用后续对话框显示的影响。 </div><div class="t m0 x0 hd y219 ff3d fs7 fc0 sc0 ls22">8.2 location对象 </div><div class="t m0 x0 h5 y128b ff40 fs1 fc0 sc0 ls9 ws2">location是最有用的BOM对象之一，它提供了与当前窗口中加载的文档有关的信息，还提供了一</div><div class="t m0 x0 h1e y128c ff3f fs2 fc0 sc0 ls6 wsf7">些导航功能。事实上，location对象是很特别的一个对象，因为它既是window 对象的属性，也是</div><div class="t m0 x0 h4 y8c9 ff40 fs1 fc0 sc0 ls9 ws2">document对象的属性；换句话说，window.location和document.location引用的是同一个对象。</div><div class="t m0 x0 h5 y8ca ff40 fs1 fc0 sc0 ls9 ws2">location对象的用处不只表现在它保存着当前文档的信息，还表现在它将URL解析为独立的片段，让</div><div class="t m0 x0 h1e y128d ff3f fs2 fc0 sc0 ls1f ws108">开发人员可以通过不同的属性访问这些片段。下表列出了location对象的所有属性（注：省略了每个属</div><div class="t m0 x0 hc y128e ff3f fs2 fc0 sc0 ls1f ws108">性前面的location前缀）。 </div><div class="t m0 x5 hb y128f ff40 fs6 fc0 sc0 ls8 wsb">  </div><div class="t m0 x0 h31 y1290 ff3c fs6 fc0 sc0 ls8">属  性  名 例  子 说  明 </div><div class="t m0 x0 h32 y1291 ff40 fsc fc0 sc0 lsa8 ws168">hash &quot;#contents&quot;  返回URL中的hash（#号后跟零或多个字符），如果URL</div><div class="t m0 x4 h36 y1292 ff3f fs6 fc0 sc0 ls8 ws124">中不包含散列，则返回空字符串 </div><div class="t m0 x0 h32 y1293 ff40 fsc fc0 sc0 lsa8 ws168">host &quot;www.wrox.com:80&quot; </div><div class="t m0 x4 h36 y1294 ff3f fs6 fc0 sc0 ls8 ws124">返回服务器名称和端口号（如果有） </div><div class="t m0 x0 h32 y1295 ff40 fsc fc0 sc0 lsa8 ws169">hostname &quot;www.wrox.com&quot;  返回不带端口号的服务器名称 </div><div class="t m0 x0 h32 y1296 ff40 fsc fc0 sc0 lsa8 ws168">href &quot;http:/www.wrox.com&quot; </div><div class="t m0 x4 h36 y1297 ff3f fs6 fc0 sc0 ls1ab ws164">返回当前加载页面的完整URL。而location对象的</div><div class="t m0 x4 h36 y1298 ff40 fs6 fc0 sc0 ls21 ws34">toString()方法也返回这个值 </div><div class="t m0 x0 h32 y1299 ff40 fsc fc0 sc0 lsa8 ws169">pathname &quot;/WileyCDA/&quot;  返回URL中的目录和（或）文件名 </div><div class="t m0 x0 h32 y129a ff40 fsc fc0 sc0 lsa8 ws168">port &quot;8080&quot;  返回URL中指定的端口号。如果URL中不包含端口号，则</div><div class="t m0 x4 h36 y129b ff3f fs6 fc0 sc0 ls8 ws124">这个属性返回空字符串 </div><div class="t m0 x0 h32 y129c ff40 fsc fc0 sc0 lsa8 ws169">protocol &quot;http:&quot;  返回页面使用的协议。通常是http:或https: </div><div class="t m0 x0 h32 y129d ff40 fsc fc0 sc0 lsa8 ws16a">search &quot;?q=javascript&quot; 返回URL的查询字符串。这个字符串以问号开头 </div><div class="t m0 x5 hb y129e ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h20 y129f ff3d fs3 fc0 sc0 ls4d ws40">8.2.1 查询字符串参数 </div><div class="t m0 x0 h5 y12a0 ff3f fs2 fc0 sc0 ls8 wseb">虽然通过上面的属性可以访问到location对象的大多数信息，但其中访问URL包含的查询字符</div><div class="t m0 x0 hc y12a1 ff3f fs2 fc0 sc0 ls8 wseb">串的属性并不方便。尽管location.search返回从问号到URL末尾的所有内容，但却没有办法逐个</div><div class="t m0 x0 h4 y12a2 ff3f fs2 fc0 sc0 ls8 wseb">访问其中的每个查询字符串参数。为此，可以像下面这样创建一个函数，用以解析查询字符串，然后返</div><div class="t m0 x0 h5 y12a3 ff3f fs2 fc0 sc0 ls8 wseb">回包含所有参数的一个对象： </div><div class="t m0 x5 hb y12a4 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y12a5 ff40 fs6 fc0 sc0 ls21 wsb">function getQueryStringArgs(){ </div><div class="t m0 x0 hb y12a6 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y12a7 ff40 fs6 fc0 sc0 ls21 wsb">    //取得查询字符串并去掉开头的问号 </div><div class="t m0 x0 hb y12a8 ff40 fs6 fc0 sc0 ls21 wsb">    var qs = (location.search.length &gt; 0 ? location.search.substring(1) : &quot;&quot;), </div><div class="t m0 x0 hb y12a9 ff40 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 h16 y12aa ff40 fs6 fc0 sc0 ls21 wsb">    //保存数据的对象 </div><div class="t m0 x0 hb y12ab ff40 fs6 fc0 sc0 ls21 wsb">    args = {}, </div><div class="t m0 x0 hb y12ac ff40 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 h16 y12ad ff40 fs6 fc0 sc0 ls21 wsb">    //取得每一项 </div><div class="t m0 x0 hb y12ae ff40 fs6 fc0 sc0 ls21 wsb">    items = qs.length ? qs.split(&quot;&amp;&quot;) : [], </div><div class="t m0 x0 hb y12af ff40 fs6 fc0 sc0 ls21 wsb">    item = null, </div><div class="t m0 x0 hb y12b0 ff40 fs6 fc0 sc0 ls21 wsb">        name = null, </div></div></div>
<div id="pfe2" class="pf w0 h0" data-page-no="e2"><div class="pc pce2 w0 h0"><div class="t m0 x0 h2 y1 ff38 fs0 fc0 sc0 ls7 ws0">208  第8章 BOM </div><div class="t m0 x0 h3 y2 ff38 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y12b2 ff40 fs6 fc0 sc0 ls21 wsb">        value = null, </div><div class="t m0 x0 hb y12b3 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y12b4 ff40 fs6 fc0 sc0 ls21 wsb">        //在for循环中使用 </div><div class="t m0 x0 hb y12b5 ff40 fs6 fc0 sc0 ls21 wsb">        i = 0, </div><div class="t m0 x0 hb y12b6 ff40 fs6 fc0 sc0 ls21 wsb">        len = items.length; </div><div class="t m0 x0 hb y12b7 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y12b8 ff40 fs6 fc0 sc0 ls21 wsb">    //逐个将每一项添加到args对象中 </div><div class="t m0 x0 hb y12b9 ff40 fs6 fc0 sc0 ls21 wsb">    for (i=0; i &lt; len; i++){ </div><div class="t m0 x0 hb y12ba ff40 fs6 fc0 sc0 ls21 wsb">        item = items[i].split(&quot;=&quot;); </div><div class="t m0 x0 hb y12bb ff40 fs6 fc0 sc0 ls21 wsb">        name = decodeURIComponent(item[0]); </div><div class="t m0 x0 hb y12bc ff40 fs6 fc0 sc0 ls21 wsb">        value = decodeURIComponent(item[1]); </div><div class="t m0 x0 hb y12bd ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y12be ff40 fs6 fc0 sc0 ls21 wsb">        if (name.length) { </div><div class="t m0 x0 hb y12bf ff40 fs6 fc0 sc0 ls21 wsb">            args[name] = value; </div><div class="t m0 x0 hb y12c0 ff40 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y12c1 ff40 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y12c2 ff40 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 hb y12c3 ff40 fs6 fc0 sc0 ls21 wsb">    return args; </div><div class="t m0 x0 hb y12c4 ff40 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x2 hf y12c5 ff46 fs2 fc0 sc0 ls1b wsb">LocationExample01.htm </div><div class="t m0 x0 h4 y12c6 ff3f fs2 fc0 sc0 ls5 wsec">这个函数的第一步是先去掉查询字符串开头的问号。当然，前提是location.search中必须要</div><div class="t m0 x0 h1e y12c7 ff3f fs2 fc0 sc0 ls5 wsec">包含一或多个字符。然后，所有参数将被保存在args对象中，该对象以字面量形式创建。接下来，</div><div class="t m0 x0 h5 y12c8 ff3f fs2 fc0 sc0 ls5">根据和号（&amp;）来分割查询字符串，并返回name=value格式的字符串数组。下面的for循环会迭代</div><div class="t m0 x0 h4 y12c9 ff3f fs2 fc0 sc0 ls24">这个数组，然后再根据等于号分割每一项，从而返回第一项为参数名，第二项为参数值的数组。再使</div><div class="t m0 x0 h1e y12ca ff3f fs2 fc0 sc0 ls1b2">用decodeURIComponent()分别解码name和value（因为查询字符串应该是被编码过的）。最后，</div><div class="t m0 x0 hc y12cb ff3f fs2 fc0 sc0 ls1b3">将name作为args对象的属性，将value 作为相应属性的值。下面给出了使用这个函数的示例。 </div><div class="t m0 x0 hb y12cc ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y12cd ff40 fs6 fc0 sc0 ls21">//假设查询字符串是?q=javascript&amp;num=10 </div><div class="t m0 x0 hb y12ce ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y12cf ff40 fs6 fc0 sc0 ls21 wsb">var args = getQueryStringArgs(); </div><div class="t m0 x0 hb y12d0 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y12d1 ff40 fs6 fc0 sc0 ls21 wsb">alert(args[&quot;q&quot;]);   //&quot;javascript&quot; </div><div class="t m0 x0 hb y12d2 ff40 fs6 fc0 sc0 ls21 wsb">alert(args[&quot;num&quot;]); //&quot;10&quot; </div><div class="t m0 x0 hb y12d3 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3c0 ff3f fs2 fc0 sc0 ls8 wseb">可见，每个查询字符串参数都成了返回对象的属性。这样就极大地方便了对每个参数的访问。 </div><div class="t m0 x0 h20 y11a0 ff3d fs3 fc0 sc0 ls4d ws40">8.2.2 位置操作 </div><div class="t m0 x0 h4 y324 ff3f fs2 fc0 sc0 ls8 wseb">使用location对象可以通过很多方式来改变浏览器的位置。首先，也是最常用的方式，就是使用</div><div class="t m0 x0 h5 y325 ff40 fs1 fc0 sc0 ls9 ws2">assign()方法并为其传递一个URL，如下所示。 </div><div class="t m0 x0 hb y12d4 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y12d5 ff40 fs6 fc0 sc0 ls21 wsb">location.assign(&quot;http://www.wrox.com&quot;); </div><div class="t m0 x0 hb y12d6 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y12d7 ff3f fs2 fc0 sc0 ls8 wseb">这样，就可以立即打开新URL并在浏览器的历史记录中生成一条记录。如果是将location.href</div><div class="t m0 x0 h5 y12d8 ff3f fs2 fc0 sc0 lsc8">或window.location设置为一个URL值，也会以该值调用 assign()方法。例如，下列两行代码与</div><div class="t m0 x0 hc y12d9 ff3f fs2 fc0 sc0 ls8 wseb">显式调用assign()方法的效果完全一样。 </div><div class="t m0 x0 hb y12da ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y12db ff40 fs6 fc0 sc0 ls21 wsb">window.location = &quot;http://www.wrox.com&quot;; </div><div class="t m0 x0 hb y12dc ff40 fs6 fc0 sc0 ls21 wsb">location.href = &quot;http://www.wrox.com&quot;; </div><div class="t m0 x0 hb y12dd ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y12de ff3f fs2 fc0 sc0 ls8 wseb">在这些改变浏览器位置的方法中，最常用的是设置location.href属性。 </div><div class="t m0 x0 h84 y12df ff3f fs2 fc0 sc0 ls8 wseb">另外，修改location对象的其他属性也可以改变当前加载的页面。下面的例子展示了通过将hash、</div><div class="t m0 x0 h5 y12e0 ff40 fs1 fc0 sc0 ls9 ws2">search、hostname、pathname和port属性设置为新值来改变URL。 </div></div></div>
<div id="pfe3" class="pf w0 h0" data-page-no="e3"><div class="pc pce3 w0 h0"><div class="t m0 x2 h2 y1 ff38 fs0 fc0 sc0 ls10 wsc">8.2 location对象   209 </div><div class="t m0 x0 h3 y2 ff38 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff3a fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff3a fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff3a fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff3a fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff3a fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff3a fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff3a fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff3a fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff3a fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff3a fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff3a fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff3a fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff3a fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h16 y12e1 ff40 fs6 fc0 sc0 ls21">//假设初始URL为http://www.wrox.com/WileyCDA/ </div><div class="t m0 x0 hb y12e2 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y12e3 ff40 fs6 fc0 sc0 ls21">//将URL修改为&quot;http://www.wrox.com/WileyCDA/#section1&quot; </div><div class="t m0 x0 hb y12e4 ff40 fs6 fc0 sc0 ls21 wsb">location.hash = &quot;#section1&quot;; </div><div class="t m0 x0 hb y12e5 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y12e6 ff40 fs6 fc0 sc0 ls21">//将URL修改为&quot;http://www.wrox.com/WileyCDA/?q=javascript&quot; </div><div class="t m0 x0 hb y12e7 ff40 fs6 fc0 sc0 ls21 wsb">location.search = &quot;?q=javascript&quot;; </div><div class="t m0 x0 hb y12e8 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y12e9 ff40 fs6 fc0 sc0 ls21">//将URL修改为&quot;http://www.yahoo.com/WileyCDA/&quot; </div><div class="t m0 x0 hb y12ea ff40 fs6 fc0 sc0 ls21 wsb">location.hostname = &quot;www.yahoo.com&quot;; </div><div class="t m0 x0 hb y12eb ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y12ec ff40 fs6 fc0 sc0 ls21">//将URL修改为&quot;http://www.yahoo.com/mydir/&quot; </div><div class="t m0 x0 hb y12ed ff40 fs6 fc0 sc0 ls21 wsb">location.pathname = &quot;mydir&quot;; </div><div class="t m0 x0 hb y12ee ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y12ef ff40 fs6 fc0 sc0 ls21">//将URL修改为&quot;http://www.yahoo.com:8080/WileyCDA/&quot; </div><div class="t m0 x0 hb y12f0 ff40 fs6 fc0 sc0 ls21 wsb">location.port = 8080; </div><div class="t m0 x5 hb y12f1 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 ya70 ff3f fs2 fc0 sc0 ls8 wseb">每次修改location的属性（hash除外），页面都会以新URL重新加载。 </div><div class="t m0 x5 h5 y12f2 ff39 fs2 fc0 sc0 ls3b">在IE8、Firefox 1、Safari 2+、Opera 9+和Chrome中，修改hash的值会在浏览</div><div class="t m0 x5 h5 y12f3 ff39 fs2 fc0 sc0 ls8 ws14">器的历史记录中生成一条新记录。在IE的早期版本中，hash属性不会在用户单击“后</div><div class="t m0 x5 h18 y12f4 ff39 fs2 fc0 sc0 ls8 ws14">退”和“前进”按钮时被更新，而只会在用户单击包含hash的URL时才会被更新。 </div><div class="t m0 x0 h5 y12f5 ff3f fs2 fc0 sc0 ls8 wseb">当通过上述任何一种方式修改URL之后，浏览器的历史记录中就会生成一条新记录，因此用户通</div><div class="t m0 x0 h4 y12f6 ff3f fs2 fc0 sc0 ls6 wsf7">过单击“后退”按钮都会导航到前一个页面。要禁用这种行为，可以使用replace()方法。这个方法</div><div class="t m0 x0 h5 y12f7 ff3f fs2 fc0 sc0 ls8 wseb">只接受一个参数，即要导航到的URL；结果虽然会导致浏览器位置改变，但不会在历史记录中生成新记</div><div class="t m0 x0 he y12f8 ff3f fs2 fc0 sc0 ls8 wseb">录。在调用replace()方法之后，用户不能回到前一个页面，来看下面的例子： </div><div class="t m0 x5 hb y12f9 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y12fa ff40 fs6 fc0 sc0 ls21 wsb">&lt;!DOCTYPE html&gt; </div><div class="t m0 x0 hb y12fb ff40 fs6 fc0 sc0 ls21 wsb">&lt;html&gt; </div><div class="t m0 x0 hb y12fc ff40 fs6 fc0 sc0 ls21 wsb">&lt;head&gt; </div><div class="t m0 x0 hb y12fd ff40 fs6 fc0 sc0 ls21 wsb">    &lt;title&gt;You won&apos;t be able to get back here&lt;/title&gt; </div><div class="t m0 x0 hb y12fe ff40 fs6 fc0 sc0 ls21 wsb">&lt;/head&gt; </div><div class="t m0 x0 hb y12ff ff40 fs6 fc0 sc0 ls21 wsb">    &lt;body&gt; </div><div class="t m0 x0 hb y1300 ff40 fs6 fc0 sc0 ls21 wsb">    &lt;p&gt;Enjoy this page for a second, because you won&apos;t be coming back here.&lt;/p&gt; </div><div class="t m0 x0 hb y1301 ff40 fs6 fc0 sc0 ls21 wsb">    &lt;script type=&quot;text/javascript&quot;&gt; </div><div class="t m0 x0 hb y1302 ff40 fs6 fc0 sc0 ls21 wsb">        setTimeout(function () { </div><div class="t m0 x0 hb y1303 ff40 fs6 fc0 sc0 ls21 wsb">            location.replace(&quot;http://www.wrox.com/&quot;); </div><div class="t m0 x0 hb y1304 ff40 fs6 fc0 sc0 ls21 wsb">        }, 1000); </div><div class="t m0 x0 hb y1305 ff40 fs6 fc0 sc0 ls21 wsb">    &lt;/script&gt; </div><div class="t m0 x0 hb y1306 ff40 fs6 fc0 sc0 ls21 wsb">&lt;/body&gt; </div><div class="t m0 x0 hb y1307 ff40 fs6 fc0 sc0 ls21 wsb">&lt;/html&gt; </div><div class="t m0 x5 hb y1308 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1309 ff46 fs2 fc0 sc0 ls2b wsb">LocationReplaceExample01.htm </div><div class="t m0 x0 h5 y130a ff3f fs2 fc0 sc0 ls8 wseb">如果将这个页面加载到浏览器中，浏览器就会在1秒钟后重新定向到www.wrox.com。然后，“后退”</div><div class="t m0 x0 h5 y130b ff3f fs2 fc0 sc0 ls8 wseb">按钮将处于禁用状态，如果不重新输入完整的URL，则无法返回示例页面。 </div><div class="t m0 x0 h1e y130c ff3f fs2 fc0 sc0 ls8 wseb">与位置有关的最后一个方法是reload()，作用是重新加载当前显示的页面。如果调用reload()</div><div class="t m0 x0 h4 y130d ff3f fs2 fc0 sc0 ls8 wseb">时不传递任何参数，页面就会以最有效的方式重新加载。也就是说，如果页面自上次请求以来并没有改</div><div class="t m0 x0 h4 y130e ff3f fs2 fc0 sc0 ls8 wseb">变过，页面就会从浏览器缓存中重新加载。如果要强制从服务器重新加载，则需要像下面这样为该方法</div><div class="t m0 x0 he y130f ff3f fs2 fc0 sc0 ls8 wseb">传递参数true。 </div><div class="t m0 x5 hb y1310 ff40 fs6 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pfe4" class="pf w0 h0" data-page-no="e4"><div class="pc pce4 w0 h0"><div class="t m0 x0 h2 y1 ff38 fs0 fc0 sc0 ls7 ws0">210  第8章 BOM </div><div class="t m0 x0 h3 y2 ff38 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y79 ff40 fs6 fc0 sc0 ls21 wsb">location.reload();        //重新加载（有可能从缓存中加载） </div><div class="t m0 x0 h16 y7a ff40 fs6 fc0 sc0 ls21 wsb">location.reload(true);    //重新加载（从服务器重新加载） </div><div class="t m0 x0 hb y1311 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1312 ff3f fs2 fc0 sc0 ls8 wseb">位于reload()调用之后的代码可能会也可能不会执行，这要取决于网络延迟或系统资源等因素。</div><div class="t m0 x0 hc y1313 ff3f fs2 fc0 sc0 ls8 wseb">为此，最好将reload()放在代码的最后一行。 </div><div class="t m0 x0 hd y1314 ff3d fs7 fc0 sc0 ls22">8.3 navigator对象 </div><div class="t m0 x0 h5 y1315 ff3f fs2 fc0 sc0 ls8 wseb">最早由Netscape Navigator 2.0引入的navigator对象，现在已经成为识别客户端浏览器的事实标</div><div class="t m0 x0 h5 y1316 ff3f fs2 fc0 sc0 ls8 wseb">准。虽然其他浏览器也通过其他方式提供了相同或相似的信息（例如，IE中的window.clientInfor- </div><div class="t m0 x0 h21 y1317 ff40 fs1 fc0 sc0 ls9 ws2">mation和Opera中的window.opera），但navigator对象却是所有支持 JavaScript的浏览器所共有</div><div class="t m0 x0 h5 y1318 ff3f fs2 fc0 sc0 ls8 wseb">的。与其他BOM对象的情况一样，每个浏览器中的navigator 对象也都有一套自己的属性。下表列</div><div class="t m0 x0 h5 y1319 ff3f fs2 fc0 sc0 ls8 wseb">出了存在于所有浏览器中的属性和方法，以及支持它们的浏览器版本。 </div><div class="t m0 x0 hb y4a9 ff40 fs6 fc0 sc0 ls8 wsb">  </div><div class="t m0 x0 h31 y131a ff3c fs6 fc0 sc0 ls8 ws8b">属性或方法 说  明 IE Firefox </div><div class="t m0 x2 h85 y131b ff3d fs6 fc0 sc0 ls1c8 wsb">Safari/ </div><div class="t m0 x2 h86 y131c ff3d fs6 fc0 sc0 ls1c9 wsb">Chrome  Opera </div><div class="t m0 x0 h32 y131d ff40 fsc fc0 sc0 lsa8 wsb">appCodeName  浏览器的名称。通常都是Mozilla，即</div><div class="t m0 x5 h36 y131e ff3f fs6 fc0 sc0 ls31 ws125">使在非Mozilla浏览器中也是如此 </div><div class="t m0 x4 h36 y131f ff38 fs6 fc0 sc0 ls1b7 ws17d">3.0+ 1.0+ 1.0+ 7.0+ </div><div class="t m0 x0 h87 yb7c ff40 fsc fc0 sc0 lsa8 wsb">appMinorVersion   次版本信息 4.0+  －－ 9.5+ </div><div class="t m0 x0 h87 y1320 ff40 fsc fc0 sc0 lsa8 wsb">appName  完整的浏览器名称 3.0+ 1.0+ 1.0+ 7.0+ </div><div class="t m0 x0 h32 y1321 ff40 fsc fc0 sc0 lsa8 wsb">appVersion  浏览器的版本。一般不与实际的浏览器</div><div class="t m0 x5 h36 y1322 ff3f fs6 fc0 sc0 ls8 ws124">版本对应 </div><div class="t m0 x4 h36 y1323 ff38 fs6 fc0 sc0 ls1b7 ws17d">3.0+ 1.0+ 1.0+ 7.0+ </div><div class="t m0 x0 h87 y1324 ff40 fsc fc0 sc0 lsa8 wsb">buildID  浏览器编译版本 － 2.0+  － － </div><div class="t m0 x0 h87 y1325 ff40 fsc fc0 sc0 lsa8 wsb">cookieEnabled  表示cookie是否启用 4.0+ 1.0+ 1.0+ 7.0+ </div><div class="t m0 x0 h32 y1326 ff40 fsc fc0 sc0 lsa8 wsb">cpuClass  客户端计算机中使用的CPU类型（x86、</div><div class="t m0 x5 h36 y1327 ff38 fsc fc0 sc0 ls1cc ws172">68K、Alpha、PPC或Other） </div><div class="t m0 x4 h36 y1328 ff38 fs6 fc0 sc0 ls1b7 wsb">4.0+  － － － </div><div class="t m0 x0 h87 y1329 ff40 fsc fc0 sc0 lsa8 wsb">javaEnabled()  表示当前浏览器中是否启用了Java  4.0+ 1.0+ 1.0+ 7.0+ </div><div class="t m0 x0 h87 y132a ff40 fsc fc0 sc0 lsa8 wsb">language  浏览器的主语言 － 1.0+ 1.0+ 7.0+ </div><div class="t m0 x0 h87 y132b ff40 fsc fc0 sc0 lsa8 wsb">mimeTypes  在浏览器中注册的MIME类型数组 4.0+ 1.0+ 1.0+ 7.0+ </div><div class="t m0 x0 h87 y132c ff40 fsc fc0 sc0 lsa8 wsb">onLine  表示浏览器是否连接到了因特网 4.0+ 1.0+ － 9.5+ </div><div class="t m0 x0 h87 y252 ff40 fsc fc0 sc0 lsa8 wsb">opsProfile  似乎早就不用了。查不到相关文档 4.0+  － － － </div><div class="t m0 x0 h87 y132d ff40 fsc fc0 sc0 lsa8 wsb">oscpu  客户端计算机的操作系统 或使用的CPU － 1.0+  － － </div><div class="t m0 x0 h87 y11cb ff40 fsc fc0 sc0 lsa8 wsb">platform  浏览器所在的系统平台 4.0+ 1.0+ 1.0+ 7.0+ </div><div class="t m0 x0 h87 y132e ff40 fsc fc0 sc0 lsa8 wsb">plugins  浏览器中安装的插件信息的数组 4.0+ 1.0+ 1.0+ 7.0+ </div><div class="t m0 x0 h87 y132f ff40 fsc fc0 sc0 lsa8 wsb">preference()  设置用户的首选项 － 1.5+  － － </div><div class="t m0 x0 h87 y1330 ff40 fsc fc0 sc0 lsa8 wsb">product  产品名称（如 Gecko） － 1.0+ 1.0+ － </div><div class="t m0 x0 h87 y4c2 ff40 fsc fc0 sc0 lsa8 wsb">productSub  关于产品的次要信息（如Gecko的版本） － 1.0+ 1.0+ － </div><div class="t m0 x0 h32 ydbe ff40 fsc fc0 sc0 lsa8 wsb">register- </div><div class="t m0 x0 h88 y1331 ff40 fsc fc0 sc0 lsa8 wsb">ContentHandler()  针对特定的MIME类型将一个站点注册</div><div class="t m0 x5 h36 y1332 ff3f fs6 fc0 sc0 ls8 ws124">为处理程序 </div><div class="t m0 x4 h89 y1333 ff3f fs6 fc0 sc0 ls95">－ 2.0+  － － </div><div class="t m0 x0 h32 y1334 ff40 fsc fc0 sc0 lsa8 wsb">register- </div><div class="t m0 x0 h8a y1335 ff40 fsc fc0 sc0 lsa8 wsb">ProtocolHandler()  针对特定的协议将一个站点注册为处</div><div class="t m0 x5 h36 y1336 ff3f fs6 fc0 sc0 ls31 ws125">理程序 </div><div class="t m0 x4 h89 y1337 ff3f fs6 fc0 sc0 ls95">－ 2.0  － － </div><div class="t m0 x0 h32 y1338 ff40 fsc fc0 sc0 lsa8 wsb">securityPolicy  已经废弃。安全策略的名称。为了与</div><div class="t m0 x5 h36 y1339 ff38 fs6 fc0 sc0 ls1ae ws17f">Netscape Navigator 4向后兼容而保留下来 </div><div class="t m0 x4 h89 y133a ff3f fs6 fc0 sc0 ls95">－ 1.0+  － － </div></div></div>
<div id="pfe5" class="pf w0 h0" data-page-no="e5"><div class="pc pce5 w0 h0"><div class="t m0 x2 h2 y1 ff38 fs0 fc0 sc0 ls10 wsc">8.3 navigator对象   211 </div><div class="t m0 x0 h3 y2 ff38 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff3a fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff3a fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff3a fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff3a fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff3a fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff3a fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff3a fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff3a fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff3a fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff3a fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff3a fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff3a fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff3a fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x6 h3 y34f ff3f fs1 fc0 sc0 ls8">（续）  </div><div class="t m0 x0 h31 y133b ff3c fs6 fc0 sc0 ls8 ws8b">属性或方法 说  明 IE Firefox </div><div class="t m0 x2 h85 y133c ff3d fs6 fc0 sc0 ls1c8 wsb">Safari/ </div><div class="t m0 x2 h86 y133d ff3d fs6 fc0 sc0 ls1c9 wsb">Chrome  Opera </div><div class="t m0 x0 h8b y133e ff40 fsc fc0 sc0 lsa8 wsb">systemLanguage  操作系统的语言 4.0+  － － － </div><div class="t m0 x0 h32 y133f ff40 fsc fc0 sc0 lsa8 wsb">taintEnabled()  已经废弃。表示是否允许变量被修改</div><div class="t m0 x1 h36 y1340 ff3f fs6 fc0 sc0 ls95">（taint）。为了与Netscape Navigator 3向后</div><div class="t m0 x1 h36 y1341 ff3f fs6 fc0 sc0 ls8 ws124">兼容而保留下来 </div><div class="t m0 x4 h36 y1342 ff38 fs6 fc0 sc0 ls1b7 ws17d">4.0+ 1.0+ － 7.0+ </div><div class="t m0 x0 h8b y1343 ff40 fsc fc0 sc0 lsa8 wsb">userAgent  浏览器的用户代理字符串  3.0+ 1.0+ 1.0+ 7.0+ </div><div class="t m0 x0 h8b y1344 ff40 fsc fc0 sc0 lsa8 wsb">userLanguage  操作系统的默认语言 4.0+  － － 7.0+ </div><div class="t m0 x0 h8b yb ff40 fsc fc0 sc0 lsa8 wsb">userProfile  借以访问用户个人信息的对象 4.0+  － － － </div><div class="t m0 x0 h8b y1345 ff40 fsc fc0 sc0 lsa8 wsb">vendor  浏览器的品牌 － 1.0+ 1.0+ － </div><div class="t m0 x0 h8b y1346 ff40 fsc fc0 sc0 lsa8 wsb">vendorSub  有关供应商的次要信息  － 1.0+ 1.0+ － </div><div class="t m0 x5 hb y1347 ff40 fs6 fc0 sc0 ls8 wsb">  </div><div class="t m0 x0 h5 y1348 ff3f fs2 fc0 sc0 ls8 wseb">表中的这些navigator对象的属性通常用于检测显示网页的浏览器类型（第9章会详细讨论）。 </div><div class="t m0 x0 h20 y1349 ff3d fs3 fc0 sc0 ls4d ws40">8.3.1 检测插件 </div><div class="t m0 x0 h5 y134a ff3f fs2 fc0 sc0 ls60 ws140">检测浏览器中是否安装了特定的插件是一种最常见的检测例程。对于非IE浏览器，可以使用</div><div class="t m0 x0 h5 y134b ff40 fs1 fc0 sc0 ls9 ws2">plugins数组来达到这个目的。该数组中的每一项都包含下列属性。 </div><div class="t m0 x0 h5 y134c ff3e fs1 fc0 sc0 ls2"> name：插件的名字。 </div><div class="t m0 x0 h5 y134d ff3e fs1 fc0 sc0 ls2"> description：插件的描述。 </div><div class="t m0 x0 h5 y134e ff3e fs1 fc0 sc0 ls2"> filename：插件的文件名。 </div><div class="t m0 x0 h5 y134f ff3e fs1 fc0 sc0 ls2"> length：插件所处理的MIME类型数量。 </div><div class="t m0 x0 h1e y1350 ff3f fs2 fc0 sc0 ls8 wseb">一般来说，name属性中会包含检测插件必需的所有信息，但有时候也不完全如此。在检测插件时，</div><div class="t m0 x0 h5 y1351 ff3f fs2 fc0 sc0 ls8 wseb">需要像下面这样循环迭代每个插件并将插件的name与给定的名字进行比较。 </div><div class="t m0 x5 hb y1352 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h36 y1353 ff40 fs6 fc0 sc0 ls21">//检测插件（在IE中无效） </div><div class="t m0 x0 hb y1354 ff40 fs6 fc0 sc0 ls21 wsb">function hasPlugin(name){ </div><div class="t m0 x0 hb y1355 ff40 fs6 fc0 sc0 ls21 wsb">    name = name.toLowerCase(); </div><div class="t m0 x0 hb y1356 ff40 fs6 fc0 sc0 ls21 wsb">    for (var i=0; i &lt; navigator.plugins.length; i++){ </div><div class="t m0 x0 hb y1357 ff40 fs6 fc0 sc0 ls21 wsb">        if (navigator. plugins [i].name.toLowerCase().indexOf(name) &gt; -1){ </div><div class="t m0 x0 hb y1358 ff40 fs6 fc0 sc0 ls21 wsb">            return true; </div><div class="t m0 x0 hb y1359 ff40 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y135a ff40 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y135b ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y135c ff40 fs6 fc0 sc0 ls21 wsb">    return false; </div><div class="t m0 x0 hb y135d ff40 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y135e ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y135f ff40 fs6 fc0 sc0 ls21">//检测Flash </div><div class="t m0 x0 hb y1360 ff40 fs6 fc0 sc0 ls21 wsb">alert(hasPlugin(&quot;Flash&quot;)); </div><div class="t m0 x0 hb y1361 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1362 ff40 fs6 fc0 sc0 ls21">//检测QuickTime </div><div class="t m0 x0 hb y1363 ff40 fs6 fc0 sc0 ls21 wsb">alert(hasPlugin(&quot;QuickTime&quot;)); </div><div class="t m0 x0 hb y1364 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1365 ff46 fs2 fc0 sc0 ls1b wsb">PluginDetectionExample01.htm </div><div class="t m0 x0 h5 y1366 ff38 fs2 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pfe6" class="pf w0 h0" data-page-no="e6"><div class="pc pce6 w0 h0"><div class="t m0 x0 h2 y1 ff38 fs0 fc0 sc0 ls7 ws0">212  第8章 BOM </div><div class="t m0 x0 h3 y2 ff38 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ff3f fs2 fc0 sc0 ls8 wseb">这个hasPlugin()函数接受一个参数：要检测的插件名。第一步是将传入的名称转换为小写形式，</div><div class="t m0 x0 h1e y4d ff3f fs2 fc0 sc0 ls8 wseb">以便于比较。然后，迭代plugins数组，通过indexOf()检测每个name 属性，以确定传入的名称是</div><div class="t m0 x0 h4 y5 ff3f fs2 fc0 sc0 ls8 wseb">否出现在字符串的某个地方。比较的字符串都使用小写形式可以避免因大小写不一致导致的错误。而传</div><div class="t m0 x0 h1e y6 ff3f fs2 fc0 sc0 ls8 wseb">入的参数应该尽可能具体，以避免混淆。应该说，像Flash和QuickTime这样的字符串就比较具体了，</div><div class="t m0 x0 h5 y15d ff3f fs2 fc0 sc0 ls8 wseb">不容易导致混淆。在Firefox、Safari、Opera和Chrome中可以使用这种方法来检测插件。 </div><div class="t m0 x5 ha y1368 ff39 fs2 fc0 sc0 ls8 ws14">每个插件对象本身也是一个MimeType对象的数组，这些对象可以通过方括号语</div><div class="t m0 x0 h18 y1369 ff39 fs2 fc0 sc0 ls8 ws14">法来访问。每个MimeType对象有4个属性：包含MIME类型描述的description、</div><div class="t m0 x0 h18 y54d ff39 fs2 fc0 sc0 ls5 wsd7">回指插件对象的enabledPlugin、表示与MIME 类型对应的文件扩展名的字符串</div><div class="t m0 x0 h5 y136a ff40 fs1 fc0 sc0 ls9 ws2">suffixes（以逗号分隔）和表示完整MIME类型字符串的type。 </div><div class="t m0 x0 h5 y136b ff3f fs2 fc0 sc0 ls8 wseb">检测IE中的插件比较麻烦，因为IE不支持 Netscape式的插件。在IE 中检测插件的唯一方式就是</div><div class="t m0 x0 h8d y136c ff3f fs2 fc0 sc0 ls8 wseb">使用专有的ActiveXObject类型，并尝试创建一个特定插件的实例。IE是以COM对象的方式实现插</div><div class="t m0 x0 h5 y136d ff3f fs2 fc0 sc0 ls8 wseb">件的，而COM对象使用唯一标识符来标识。因此，要想检查特定的插件，就必须知道其COM标识符。</div><div class="t m0 x0 h5 y136e ff3f fs2 fc0 sc0 ls8 wseb">例如，Flash的标识符是ShockwaveFlash.ShockwaveFlash。知道唯一标识符之后，就可以编写类似</div><div class="t m0 x0 h5 y114d ff3f fs2 fc0 sc0 ls8 wseb">下面的函数来检测IE中是否安装相应插件了。 </div><div class="t m0 x0 hb y136f ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h36 y1370 ff40 fs6 fc0 sc0 ls21">//检测IE中的插件 </div><div class="t m0 x0 hb y1371 ff40 fs6 fc0 sc0 ls21 wsb">function hasIEPlugin(name){ </div><div class="t m0 x0 hb y1372 ff40 fs6 fc0 sc0 ls21 wsb">    try { </div><div class="t m0 x0 hb y1373 ff40 fs6 fc0 sc0 ls21 wsb">        new ActiveXObject(name); </div><div class="t m0 x0 hb y1374 ff40 fs6 fc0 sc0 ls21 wsb">        return true; </div><div class="t m0 x0 hb y1375 ff40 fs6 fc0 sc0 ls21 wsb">    } catch (ex){ </div><div class="t m0 x0 hb y1376 ff40 fs6 fc0 sc0 ls21 wsb">        return false; </div><div class="t m0 x0 hb y1377 ff40 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y1378 ff40 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y1379 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y137a ff40 fs6 fc0 sc0 ls21">//检测Flash </div><div class="t m0 x0 hb y137b ff40 fs6 fc0 sc0 ls21 wsb">alert(hasIEPlugin(&quot;ShockwaveFlash.ShockwaveFlash&quot;)); </div><div class="t m0 x0 hb y137c ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y137d ff40 fs6 fc0 sc0 ls21">//检测QuickTime </div><div class="t m0 x0 hb y137e ff40 fs6 fc0 sc0 ls21 wsb">alert(hasIEPlugin(&quot;QuickTime.QuickTime&quot;)); </div><div class="t m0 x0 hb y137f ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1e7 ff46 fs2 fc0 sc0 ls1b wsb">PluginDetectionExample02.htm </div><div class="t m0 x0 h5 y1380 ff3f fs2 fc0 sc0 ls8 wseb">在这个例子中，函数hasIEPlugin()只接收一个COM标识符作为参数。在函数内部，首先会尝</div><div class="t m0 x0 hc y1381 ff3f fs2 fc0 sc0 ls8 wseb">试创建一个COM对象的实例。之所以要在try-catch语句中进行实例化，是因为创建未知COM对象</div><div class="t m0 x0 h4 y1382 ff3f fs2 fc0 sc0 ls8 wseb">会导致抛出错误。这样，如果实例化成功，则函数返回true；否则，如果抛出了错误，则执行catch</div><div class="t m0 x0 h5 y1383 ff3f fs2 fc0 sc0 ls8 wseb">块，结果就会返回false。例子最后检测IE中是否安装了Flash和QuickTime插件。 </div><div class="t m0 x0 h4 y1384 ff3f fs2 fc0 sc0 ls8 wseb">鉴于检测这两种插件的方法差别太大，因此典型的做法是针对每个插件分别创建检测函数，而不是</div><div class="t m0 x0 h5 y1385 ff3f fs2 fc0 sc0 ls8 wseb">使用前面介绍的通用检测方法。来看下面的例子。 </div><div class="t m0 x0 hb y1386 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1387 ff40 fs6 fc0 sc0 ls21">//检测所有浏览器中的Flash </div><div class="t m0 x0 hb y1388 ff40 fs6 fc0 sc0 ls21 wsb">function hasFlash(){ </div><div class="t m0 x0 hb y1389 ff40 fs6 fc0 sc0 ls21 wsb">    var result = hasPlugin(&quot;Flash&quot;); </div><div class="t m0 x0 hb y138a ff40 fs6 fc0 sc0 ls21 wsb">    if (!result){ </div><div class="t m0 x0 hb y138b ff40 fs6 fc0 sc0 ls21 wsb">        result = hasIEPlugin(&quot;ShockwaveFlash.ShockwaveFlash&quot;); </div><div class="t m0 x0 hb y138c ff40 fs6 fc0 sc0 ls21 wsb">    } </div></div></div>
<div id="pfe7" class="pf w0 h0" data-page-no="e7"><div class="pc pce7 w0 h0"><div class="t m0 x2 h2 y1 ff38 fs0 fc0 sc0 ls10 wsc">8.3 navigator对象   213 </div><div class="t m0 x0 h3 y2 ff38 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff3a fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff3a fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff3a fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff3a fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff3a fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff3a fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff3a fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff3a fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff3a fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff3a fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff3a fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff3a fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff3a fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y138d ff40 fs6 fc0 sc0 ls21 wsb">    return result; </div><div class="t m0 x0 hb y138e ff40 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y138f ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1390 ff40 fs6 fc0 sc0 ls21">//检测所有浏览器中的QuickTime </div><div class="t m0 x0 hb y1391 ff40 fs6 fc0 sc0 ls21 wsb">function hasQuickTime(){ </div><div class="t m0 x0 hb y1392 ff40 fs6 fc0 sc0 ls21 wsb">    var result = hasPlugin(&quot;QuickTime&quot;); </div><div class="t m0 x0 hb y1393 ff40 fs6 fc0 sc0 ls21 wsb">    if (!result){ </div><div class="t m0 x0 hb y1394 ff40 fs6 fc0 sc0 ls21 wsb">        result = hasIEPlugin(&quot;QuickTime.QuickTime&quot;); </div><div class="t m0 x0 hb y1395 ff40 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y1396 ff40 fs6 fc0 sc0 ls21 wsb">    return result; </div><div class="t m0 x0 hb y1397 ff40 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y1398 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1399 ff40 fs6 fc0 sc0 ls21">//检测Flash </div><div class="t m0 x0 hb y139a ff40 fs6 fc0 sc0 ls21 wsb">alert(hasFlash()); </div><div class="t m0 x0 hb y139b ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y139c ff40 fs6 fc0 sc0 ls21">//检测QuickTime </div><div class="t m0 x0 hb y139d ff40 fs6 fc0 sc0 ls21 wsb">alert(hasQuickTime()); </div><div class="t m0 x5 hb y139e ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y139f ff46 fs2 fc0 sc0 ls1b wsb">PluginDetectionExample03.htm </div><div class="t m0 x0 h4 y13a0 ff3f fs2 fc0 sc0 ls8 wseb">上面代码中定义了两个函数：hasFlash()和hasQuickTime()。每个函数都是先尝试使用不针对</div><div class="t m0 x0 hc y13a1 ff38 fs2 fc0 sc0 lse ws9">IE的插件检测方法。如果返回了false（在IE中会这样），那么再使用针对IE的插件检测方法。如果</div><div class="t m0 x0 h5 y13a2 ff38 fs2 fc0 sc0 lse ws9">IE的插件检测方法再返回false，则整个方法也将返回false。只要任何一次检测返回true，整个方</div><div class="t m0 x0 h5 y13a3 ff3f fs2 fc0 sc0 ls8 wseb">法都会返回true。 </div><div class="t m0 x5 ha y13a4 ff40 fs1 fc0 sc0 ls9 ws2">plugins集合有一个名叫refresh()的方法，用于刷新plugins以反映最新安</div><div class="t m0 x5 ha y13a5 ff39 fs2 fc0 sc0 ls8 ws14">装的插件。这个方法接收一个参数：表示是否应该重新加载页面的一个布尔值。如果</div><div class="t m0 x5 ha y13a6 ff39 fs2 fc0 sc0 ls5 wsd7">将这个值设置为true，则会重新加载包含插件的所有页面；否则，只更新plugins</div><div class="t m0 x5 h5 y13a7 ff39 fs2 fc0 sc0 ls1f">集合，不重新加载页面。 </div><div class="t m0 x0 h20 y13a8 ff3d fs3 fc0 sc0 ls4d ws40">8.3.2 注册处理程序 </div><div class="t m0 x0 h5 y13a9 ff38 fs2 fc0 sc0 ls1da ws186">Firefox 2为navigator对象新增了registerContentHandler()和registerProtocolHandler()方</div><div class="t m0 x0 h5 y13aa ff3f fs2 fc0 sc0 ls8 wseb">法（这两个方法是在HTML5中定义的，相关内容将在第22章讨论）。这两个方法可以让一个站点指明</div><div class="t m0 x0 h5 y13ab ff3f fs2 fc0 sc0 ls8 wseb">它可以处理特定类型的信息。随着RSS阅读器和在线电子邮件程序的兴起，注册处理程序就为像使用桌</div><div class="t m0 x0 h5 y13ac ff3f fs2 fc0 sc0 ls8 wseb">面应用程序一样默认使用这些在线应用程序提供了一种方式。 </div><div class="t m0 x0 h14 y13ad ff3f fs2 fc0 sc0 ls8 wseb">其中，registerContentHandler()方法接收三个参数：要处理的MIME类型、可以处理该MIME</div><div class="t m0 x0 h5 y13ae ff3f fs2 fc0 sc0 ls8 wseb">类型的页面的URL以及应用程序的名称。举个例子，要将一个站点注册为处理RSS源的处理程序，可</div><div class="t m0 x0 h5 y13af ff3f fs2 fc0 sc0 ls8 wseb">以使用如下代码。 </div><div class="t m0 x5 hb y13b0 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y13b1 ff40 fs6 fc0 sc0 ls21 wsb">navigator.registerContentHandler(&quot;application/rss+xml&quot;, </div><div class="t m0 x0 hb y13b2 ff40 fs6 fc0 sc0 ls21 wsb">    &quot;http://www.somereader.com?feed=%s&quot;, &quot;Some Reader&quot;); </div><div class="t m0 x5 hb y13b3 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y41c ff3f fs2 fc0 sc0 ls8 wseb">第一个参数是RSS源的MIME类型。第二个参数是应该接收RSS 源URL的URL，其中的%s表示</div><div class="t m0 x0 h5 y13b4 ff38 fs2 fc0 sc0 ls14d ws11a">RSS源URL，由浏览器自动插入。当下一次请求RSS源时，浏览器就会打开指定的 URL，而相应的</div><div class="t m0 x0 h5 y13b5 ff38 fs2 fc0 sc0 lsfd wscc">Web应用程序将以适当方式来处理该请求。 </div></div></div>
<div id="pfe8" class="pf w0 h0" data-page-no="e8"><div class="pc pce8 w0 h0"><div class="t m0 x0 h2 y1 ff38 fs0 fc0 sc0 ls7 ws0">214  第8章 BOM </div><div class="t m0 x0 h3 y2 ff38 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y70f ff38 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x5 h5 y945 ff38 fs2 fc0 sc0 ls2e ws18d">Firefox 4及之前版本只允许在registerContentHandler()方法中使用三个</div><div class="t m0 x0 h5 y946 ff38 fs2 fc0 sc0 ls1d6 ws182">MIME类型：application/rss+xml、application/atom+xml和application/ </div><div class="t m0 x0 h5 y13b6 ff40 fs1 fc0 sc0 ls9 ws18e">vnd.mozilla.maybe. feed。这三个MIME类型的作用都一样，即为RSS或ATOM</div><div class="t m0 x0 h5 y13b7 ff39 fs2 fc0 sc0 ls1f">新闻源（feed）注册处理程序。 </div><div class="t m0 x0 h4 y13b8 ff3f fs2 fc0 sc0 ls6 wsf7">类似的调用方式也适用于registerProtocolHandler()方法，它也接收三个参数：要处理的协</div><div class="t m0 x0 hc y13b9 ff3f fs2 fc0 sc0 ls8 wseb">议（例如，mailto或ftp）、处理该协议的页面的URL和应用程序的名称。例如，要想将一个应用程</div><div class="t m0 x0 h5 y13ba ff3f fs2 fc0 sc0 ls8 wseb">序注册为默认的邮件客户端，可以使用如下代码。 </div><div class="t m0 x0 hb y429 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y13bb ff40 fs6 fc0 sc0 ls21 wsb">navigator.registerProtocolHandler(&quot;mailto&quot;, </div><div class="t m0 x0 hb y13bc ff40 fs6 fc0 sc0 ls21 wsb">    &quot;http://www.somemailclient.com?cmd=%s&quot;, &quot;Some Mail Client&quot;); </div><div class="t m0 x0 hb y13bd ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y13be ff3f fs2 fc0 sc0 ls8 wseb">这个例子注册了一个mailto协议的处理程序，该程序指向一个基于Web的电子邮件客户端。同样，</div><div class="t m0 x0 hc y13bf ff3f fs2 fc0 sc0 ls8 wseb">第二个参数仍然是处理相应请求的URL，而%s则表示原始的请求。 </div><div class="t m0 x5 h5 y13c0 ff38 fs2 fc0 sc0 ls2e ws18f">Firefox 2虽然实现了registerProtocolHandler()，但该方法还不能用。</div><div class="t m0 x0 h5 y13c1 ff38 fs2 fc0 sc0 ls2e ws67">Firefox 3完整实现这个方法。 </div><div class="t m0 x0 hd y13c2 ff3d fs7 fc0 sc0 ls22">8.4 screen对象 </div><div class="t m0 x0 h5 y7de ff38 fs2 fc0 sc0 lsb ws5">JavaScript中有几个对象在编程中用处不大，而screen对象就是其中之一。screen对象基本上只</div><div class="t m0 x0 h4 y13c3 ff3f fs2 fc0 sc0 ls8 wseb">用来表明客户端的能力，其中包括浏览器窗口外部的显示器的信息，如像素宽度和高度等。每个浏览器</div><div class="t m0 x0 he y13c4 ff3f fs2 fc0 sc0 ls8 wseb">中的screen对象都包含着各不相同的属性，下表列出了所有属性及支持相应属性的浏览器。 </div><div class="t m0 x0 hb y13c5 ff40 fs6 fc0 sc0 ls8 wsb">  </div><div class="t m0 x0 h8e y13c6 ff3c fs6 fc0 sc0 lsa7 wsb">属  性 说  明 IE Firefox Safari/ </div><div class="t m0 x2 h86 y13c7 ff3d fs6 fc0 sc0 ls1c9 wsb">Chrome  Opera </div><div class="t m0 x0 h32 y13c8 ff40 fsc fc0 sc0 lsa8 wsb">availHeight  屏幕的像素高度减系统部件高度之后的值（只读）     </div><div class="t m0 x0 h8f y13c9 ff40 fsc fc0 sc0 lsa8 wsb">availLeft  未被系统部件占用的最左侧的像素值（只读）     </div><div class="t m0 x0 h8f y13ca ff40 fsc fc0 sc0 lsa8 wsb">availTop  未被系统部件占用的最上方的像素值（只读）     </div><div class="t m0 x0 h32 y13cb ff40 fsc fc0 sc0 lsa8 wsb">availWidth  屏幕的像素宽度减系统部件宽度之后的值（只读）     </div><div class="t m0 x0 h8f y13cc ff40 fsc fc0 sc0 lsa8 wsb">bufferDepth  读、写用于呈现屏外位图的位数     </div><div class="t m0 x0 h32 y13cd ff40 fsc fc0 sc0 lsa8 wsb">colorDepth  用于表现颜色的位数；多数系统都是32（只读）     </div><div class="t m0 x0 h8f y13ce ff40 fsc fc0 sc0 lsa8 wsb">deviceXDPI  屏幕实际的水平DPI（只读）     </div><div class="t m0 x0 h8f y13cf ff40 fsc fc0 sc0 lsa8 wsb">deviceYDPI  屏幕实际的垂直DPI（只读）     </div><div class="t m0 x0 h32 y13d0 ff40 fsc fc0 sc0 ls1ef wsb">fontSmooth- </div><div class="t m0 x0 h90 y13d1 ff40 fsc fc0 sc0 lsa8 wsb">ingEnabled  表示是否启用了字体平滑（只读）     </div><div class="t m0 x0 h32 yc2c ff40 fsc fc0 sc0 lsa8 wsb">height  屏幕的像素高度     </div><div class="t m0 x0 h8f y1003 ff40 fsc fc0 sc0 lsa8 wsb">left  当前屏幕距左边的像素距离     </div><div class="t m0 x0 h8f y13d2 ff40 fsc fc0 sc0 lsa8 wsb">logicalXDPI  屏幕逻辑的水平DPI（只读）     </div><div class="t m0 x0 h8f y13d3 ff40 fsc fc0 sc0 lsa8 wsb">logicalYDPI  屏幕逻辑的垂直DPI（只读）     </div><div class="t m0 x0 h8f y8c5 ff40 fsc fc0 sc0 lsa8 wsb">pixelDepth  屏幕的位深（只读）     </div></div></div>
<div id="pfe9" class="pf w0 h0" data-page-no="e9"><div class="pc pce9 w0 h0"><div class="t m0 x2 h2 y1 ff38 fs0 fc0 sc0 ls10 wsc">8.5 history对象   215 </div><div class="t m0 x0 h3 y2 ff38 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff3a fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff3a fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff3a fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff3a fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff3a fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff3a fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff3a fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff3a fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff3a fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff3a fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff3a fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff3a fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff3a fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x6 h3 y34f ff3f fs1 fc0 sc0 ls8">（续） </div><div class="t m0 x0 h8e y133b ff3c fs6 fc0 sc0 lsa7 wsb">属  性 说  明 IE Firefox Safari/ </div><div class="t m0 x2 h86 y133d ff3d fs6 fc0 sc0 ls1c9 wsb">Chrome  Opera </div><div class="t m0 x0 h8f y13d4 ff40 fsc fc0 sc0 lsa8 wsb">top  当前屏幕距上边的像素距离     </div><div class="t m0 x0 h8f y13d5 ff40 fsc fc0 sc0 ls1f9 wsb">updateInterval  读、写以毫秒表示的屏幕刷新时间间隔     </div><div class="t m0 x0 h32 y421 ff40 fsc fc0 sc0 lsa8 wsb">width  屏幕的像素宽度     </div><div class="t m0 x5 hb y13d6 ff40 fs6 fc0 sc0 ls8 wsb">  </div><div class="t m0 x0 h4 y2df ff3f fs2 fc0 sc0 ls8 wseb">这些信息经常集中出现在测定客户端能力的站点跟踪工具中，但通常不会用于影响功能。不过，有</div><div class="t m0 x0 h5 y13d7 ff3f fs2 fc0 sc0 ls8 wseb">时候也可能会用到其中的信息来调整浏览器窗口大小，使其占据屏幕的可用空间，例如： </div><div class="t m0 x5 hb y13d8 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y13d9 ff40 fs6 fc0 sc0 ls21 wsb">window.resizeTo(screen.availWidth, screen.availHeight); </div><div class="t m0 x5 hb y13da ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y13db ff3f fs2 fc0 sc0 ls8 wseb">前面曾经提到过，许多浏览器都会禁用调整浏览器窗口大小的能力，因此上面这行代码不一定在所</div><div class="t m0 x0 h5 y13dc ff3f fs2 fc0 sc0 ls8 wseb">有环境下都有效。 </div><div class="t m0 x0 h5 y13dd ff3f fs2 fc0 sc0 ls42 wsf0">涉及移动设备的屏幕大小时，情况有点不一样。运行iOS的设备始终会像是把设备竖着拿在手里一</div><div class="t m0 x0 he y13de ff3f fs2 fc0 sc0 ls44 wsef">样，因此返回的值是768×1024。而Android设备则会相应调用screen.width和screen.height的值。 </div><div class="t m0 x0 hd y13df ff3d fs7 fc0 sc0 ls22">8.5 history对象 </div><div class="t m0 x0 h4 y13e0 ff40 fs1 fc0 sc0 ls9 ws2">history对象保存着用户上网的历史记录，从窗口被打开的那一刻算起。因为history是window</div><div class="t m0 x0 h4 y13e1 ff3f fs2 fc0 sc0 ls24 wsf5">对象的属性，因此每个浏览器窗口、每个标签页乃至每个框架，都有自己的history对象与特定的</div><div class="t m0 x0 h5 y13e2 ff40 fs1 fc0 sc0 ls9 ws2">window对象关联。出于安全方面的考虑，开发人员无法得知用户浏览过的URL。不过，借由用户访问</div><div class="t m0 x0 h5 y13e3 ff3f fs2 fc0 sc0 ls8 wseb">过的页面列表，同样可以在不知道实际URL的情况下实现后退和前进。 </div><div class="t m0 x0 h1c y13e4 ff3f fs2 fc0 sc0 ls8 wseb">使用go()方法可以在用户的历史记录中任意跳转，可以向后也可以向前。这个方法接受一个参数，</div><div class="t m0 x0 h4 y13e5 ff3f fs2 fc0 sc0 ls8 wseb">表示向后或向前跳转的页面数的一个整数值。负数表示向后跳转（类似于单击浏览器的“后退”按钮），</div><div class="t m0 x0 h5 yef9 ff3f fs2 fc0 sc0 ls8 wseb">正数表示向前跳转（类似于单击浏览器的“前进”按钮）。来看下面的例子。 </div><div class="t m0 x5 hb ydd9 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y13e6 ff40 fs6 fc0 sc0 ls21">//后退一页 </div><div class="t m0 x0 hb y13e7 ff40 fs6 fc0 sc0 ls21 wsb">history.go(-1); </div><div class="t m0 x0 hb y13e8 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y13e9 ff40 fs6 fc0 sc0 ls21">//前进一页 </div><div class="t m0 x0 hb y13ea ff40 fs6 fc0 sc0 ls21 wsb">history.go(1); </div><div class="t m0 x0 hb y13eb ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y13ec ff40 fs6 fc0 sc0 ls21">//前进两页 </div><div class="t m0 x0 hb y13ed ff40 fs6 fc0 sc0 ls21 wsb">history.go(2); </div><div class="t m0 x5 hb y13ee ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y510 ff3f fs2 fc0 sc0 ls8 wseb">也可以给go()方法传递一个字符串参数，此时浏览器会跳转到历史记录中包含该字符串的第一个</div><div class="t m0 x0 h4 y13ef ff3f fs2 fc0 sc0 ls8 wseb">位置——可能后退，也可能前进，具体要看哪个位置最近。如果历史记录中不包含该字符串，那么这个</div><div class="t m0 x0 h5 y13f0 ff3f fs2 fc0 sc0 ls8 wseb">方法什么也不做，例如： </div><div class="t m0 x5 hb y13f1 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y13f2 ff40 fs6 fc0 sc0 ls21">//跳转到最近的wrox.com页面 </div><div class="t m0 x0 hb y13f3 ff40 fs6 fc0 sc0 ls21 wsb">history.go(&quot;wrox.com&quot;); </div><div class="t m0 x0 hb y13f4 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y13f5 ff40 fs6 fc0 sc0 ls21">//跳转到最近的nczonline.net页面 </div><div class="t m0 x0 hb y13f6 ff40 fs6 fc0 sc0 ls21 wsb">history.go(&quot;nczonline.net&quot;); </div><div class="t m0 x5 hb y13f7 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y13f8 ff3f fs2 fc0 sc0 ls8 wseb">另外，还可以使用两个简写方法back()和forward()来代替go()。顾名思义，这两个方法可以</div><div class="t m0 x0 h5 y13f9 ff3f fs2 fc0 sc0 ls8 wseb">模仿浏览器的“后退”和“前进”按钮。 </div></div></div>
<div id="pfea" class="pf w0 h0" data-page-no="ea"><div class="pc pcea w0 h0"><div class="t m0 x0 h2 y1 ff38 fs0 fc0 sc0 ls7 ws0">216  第8章 BOM </div><div class="t m0 x0 h3 y2 ff38 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y866 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y867 ff40 fs6 fc0 sc0 ls21">//后退一页 </div><div class="t m0 x0 hb y868 ff40 fs6 fc0 sc0 ls21 wsb">history.back(); </div><div class="t m0 x0 hb y869 ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y86a ff40 fs6 fc0 sc0 ls21">//前进一页 </div><div class="t m0 x0 hb y86b ff40 fs6 fc0 sc0 ls21 wsb">history.forward(); </div><div class="t m0 x0 hb y86c ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y13fb ff3f fs2 fc0 sc0 ls5 wsec">除了上述几个方法外，history对象还有一个length属性，保存着历史记录的数量。这个数量</div><div class="t m0 x0 h4 y13fc ff3f fs2 fc0 sc0 ls5 wsec">包括所有历史记录，即所有向后和向前的记录。对于加载到窗口、标签页或框架中的第一个页面而言，</div><div class="t m0 x0 h5 y13fd ff40 fs1 fc0 sc0 ls16 ws17">history.length等于0。通过像下面这样测试该属性的值，可以确定用户是否一开始就打开了你的</div><div class="t m0 x0 h5 y13fe ff3f fs2 fc0 sc0 ls5">页面。 </div><div class="t m0 x0 hb y13ff ff40 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1400 ff40 fs6 fc0 sc0 ls21 wsb">if (history.length == 0){ </div><div class="t m0 x0 h16 y1401 ff40 fs6 fc0 sc0 ls21 wsb">    //这应该是用户打开窗口后的第一个页面 </div><div class="t m0 x0 hb y1402 ff40 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h4 y1403 ff3f fs2 fc0 sc0 ls8 wseb">虽然history并不常用，但在创建自定义的“后退”和“前进”按钮，以及检测当前页面是不是</div><div class="t m0 x0 h5 y296 ff3f fs2 fc0 sc0 ls8 wseb">用户历史记录中的第一个页面时，还是必须使用它。 </div><div class="t m0 x5 h5 y1404 ff39 fs2 fc0 sc0 ls8 ws14">当页面的URL改变时，就会生成一条历史记录。在 IE8及更高版本、Opera、</div><div class="t m0 x0 h5 y1405 ff38 fs2 fc0 sc0 ls47 ws38">Firefox、Safari 3及更高版本以及Chrome中，这里所说的改变包括URL中hash的变</div><div class="t m0 x0 h18 y1406 ff39 fs2 fc0 sc0 ls8 ws14">化（因此，设置location.hash会在这些浏览器中生成一条新的历史记录）。 </div><div class="t m0 x0 hd y1407 ff3d fs7 fc0 sc0 ls22">8.6 小结 </div><div class="t m0 x0 h5 y1408 ff3f fs2 fc0 sc0 ls8 wseb">浏览器对象模型（BOM）以window对象为依托，表示浏览器窗口以及页面可见区域。同时，window</div><div class="t m0 x0 h5 y1409 ff3f fs2 fc0 sc0 ls8 wseb">对象还是ECMAScript中的Global对象，因而所有全局变量和函数都是它的属性，且所有原生的构造</div><div class="t m0 x0 h5 y140a ff3f fs2 fc0 sc0 ls8 wseb">函数及其他函数也都存在于它的命名空间下。本章讨论了下列BOM的组成部分。 </div><div class="t m0 x0 h4 y140b ff3e fs1 fc0 sc0 ls2"> 在使用框架时，每个框架都有自己的window对象以及所有原生构造函数及其他函数的副本。</div><div class="t m0 x0 hc y140c ff3f fs2 fc0 sc0 ls8 wseb">每个框架都保存在frames集合中，可以通过位置或通过名称来访问。 </div><div class="t m0 x0 h5 y6ac ff3e fs1 fc0 sc0 ls2"> 有一些窗口指针，可以用来引用其他框架，包括父框架。 </div><div class="t m0 x0 h5 y140d ff3e fs1 fc0 sc0 ls2"> top对象始终指向最外围的框架，也就是整个浏览器窗口。 </div><div class="t m0 x0 h5 y140e ff3e fs1 fc0 sc0 ls2"> parent对象表示包含当前框架的框架，而self对象则回指window。 </div><div class="t m0 x0 h4 y140f ff3e fs1 fc0 sc0 ls2"> 使用location对象可以通过编程方式来访问浏览器的导航系统。设置相应的属性，可以逐段</div><div class="t m0 x0 h5 y1410 ff3f fs2 fc0 sc0 ls8 wseb">或整体性地修改浏览器的URL。 </div><div class="t m0 x0 h5 y1411 ff3e fs1 fc0 sc0 ls2"> 调用replace()方法可以导航到一个新URL，同时该URL会替换浏览器历史记录中当前显示</div><div class="t m0 x0 h5 y1412 ff3f fs2 fc0 sc0 ls8">的页面。 </div><div class="t m0 x0 h4 y1413 ff3e fs1 fc0 sc0 ls2"> navigator对象提供了与浏览器有关的信息。到底提供哪些信息，很大程度上取决于用户的浏</div><div class="t m0 x0 h5 y1414 ff3f fs2 fc0 sc0 ls8 wseb">览器；不过，也有一些公共的属性（如userAgent）存在于所有浏览器中。 </div><div class="t m0 x0 h5 y1415 ff38 fs2 fc0 sc0 ls50 ws41">BOM中还有两个对象：screen和history，但它们的功能有限。screen对象中保存着与客户端</div><div class="t m0 x0 h1e y1416 ff3f fs2 fc0 sc0 ls6 wsf7">显示器有关的信息，这些信息一般只用于站点分析。history对象为访问浏览器的历史记录开了一个</div><div class="t m0 x0 h5 y1417 ff3f fs2 fc0 sc0 ls8 wseb">小缝隙，开发人员可以据此判断历史记录的数量，也可以在历史记录中向后或向前导航到任意页面。 </div><div class="t m0 x0 h5 y1418 ff38 fs2 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pfeb" class="pf w0 h0" data-page-no="eb"><div class="pc pceb w0 h0"><div class="t m0 x2 h2 y1 ff48 fs0 fc0 sc0 ls10 wsc">9.1 能力检测    217 </div><div class="t m0 x0 h3 y2 ff48 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff4a fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff4a fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff4a fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff4a fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff4a fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff4a fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff4a fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff4a fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff4a fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff4a fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff4a fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff4a fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff4a fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h9 y2a ff4b fs5 fc0 sc0 ls8 wsb">客户端检测 </div><div class="t m0 x0 h3c y2b ff4c fs2 fc0 sc0 ls8">本章内容 </div><div class="t m0 x0 h5 y2c ff4e fs1 fc0 sc0 ls2"> 使用能力检测 </div><div class="t m0 x0 h5 y2d ff4e fs1 fc0 sc0 ls2"> 用户代理检测的历史 </div><div class="t m0 x0 h5 y2e ff4e fs1 fc0 sc0 ls2"> 选择检测方式 </div><div class="t m0 x0 h5 y8d9 ff48 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x5 h4 y8da ff4f fs2 fc0 sc0 ls5 ws4">览器提供商虽然在实现公共接口方面投入了很多精力，但结果仍然是每一种浏览器都有各自</div><div class="t m0 x5 h4 y8db ff4f fs2 fc0 sc0 ls5 ws4">的长处，也都有各自的缺点。即使是那些跨平台的浏览器，虽然从技术上看版本相同，也照</div><div class="t m0 x0 h4 y8dc ff4f fs2 fc0 sc0 ls8 ws1">样存在不一致性问题。面对普遍存在的不一致性问题，开发人员要么采取迁就各方的“最小公分母”策</div><div class="t m0 x0 h5 y8dd ff4f fs2 fc0 sc0 ls8 ws1">略，要么（也是更常见的）就得利用各种客户端检测方法，来突破或者规避种种局限性。 </div><div class="t m0 x0 h5 y8de ff4f fs2 fc0 sc0 ls8 ws1">迄今为止，客户端检测仍然是Web开发领域中一个饱受争议的话题。一谈到这个话题，人们总会</div><div class="t m0 x0 h4 y8df ff4f fs2 fc0 sc0 ls8 ws1">不约而同地提到浏览器应该支持一组最常用的公共功能。在理想状态下，确实应该如此。但是，在现实</div><div class="t m0 x0 h5 y8e0 ff4f fs2 fc0 sc0 ls8 ws1">当中，浏览器之间的差异以及不同浏览器的“怪癖”（quirk），多得简直不胜枚举。因此，客户端检测除</div><div class="t m0 x0 h5 y8e1 ff4f fs2 fc0 sc0 ls8 ws1">了是一种补救措施之外，更是一种行之有效的开发策略。 </div><div class="t m0 x0 h5 y8e2 ff4f fs2 fc0 sc0 ls8 ws1">检测Web客户端的手段很多，而且各有利弊。但最重要的还是要知道，不到万不得已，就不要使</div><div class="t m0 x0 h4 y1419 ff4f fs2 fc0 sc0 ls8 ws1">用客户端检测。只要能找到更通用的方法，就应该优先采用更通用的方法。一言以蔽之，先设计最通用</div><div class="t m0 x0 h5 y141a ff4f fs2 fc0 sc0 ls8 ws1">的方案，然后再使用特定于浏览器的技术增强该方案。 </div><div class="t m0 x0 hd y141b ff4d fs7 fc0 sc0 ls22">9.1 能力检测 </div><div class="t m0 x0 h4 y344 ff4f fs2 fc0 sc0 ls6 ws6">最常用也最为人们广泛接受的客户端检测形式是能力检测（又称特性检测）。能力检测的目标不是</div><div class="t m0 x0 h4 y141c ff4f fs2 fc0 sc0 ls8 ws1">识别特定的浏览器，而是识别浏览器的能力。采用这种方式不必顾及特定的浏览器如何如何，只要确定</div><div class="t m0 x0 h5 y141d ff4f fs2 fc0 sc0 ls8 ws1">浏览器支持特定的能力，就可以给出解决方案。能力检测的基本模式如下： </div><div class="t m0 x5 hb y141e ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y141f ff50 fs6 fc0 sc0 ls21 wsb">if (object.propertyInQuestion){ </div><div class="t m0 x0 h16 y1420 ff50 fs6 fc0 sc0 ls21 wsb">    //使用object.propertyInQuestion </div><div class="t m0 x0 hb y1421 ff50 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h5 y1422 ff4f fs2 fc0 sc0 ls5 ws4">举例来说，IE5.0之前的版本不支持document.getElementById()这个DOM方法。尽管可以使</div><div class="t m0 x0 hc y1423 ff4f fs2 fc0 sc0 ls6 ws6">用非标准的document.all属性实现相同的目的，但 IE的早期版本中确实不存在document.get- </div><div class="t m0 x0 h21 y1424 ff50 fs1 fc0 sc0 ls43 ws31">ElementById()。于是，也就有了类似下面的能力检测代码： </div><div class="t m0 x5 hb y1425 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1426 ff50 fs6 fc0 sc0 ls21 wsb">function getElement(id){ </div><div class="t m0 x0 hb y1427 ff50 fs6 fc0 sc0 ls21 wsb">    if (document.getElementById){ </div><div class="t m0 x0 hb y1428 ff50 fs6 fc0 sc0 ls21 wsb">        return document.getElementById(id); </div><div class="t m0 x0 hb y1429 ff50 fs6 fc0 sc0 ls21 wsb">    } else if (document.all){ </div><div class="t m0 x0 hb y142a ff50 fs6 fc0 sc0 ls21 wsb">        return document.all[id]; </div><div class="t m0 x0 h92 y8f4 ff4c fs12 fc0 sc0 ls8 wsb">浏 </div><div class="t m0 x0 h11 y4b ff52 fsa fc0 sc0 ls8">第</div><div class="t m1 x0 h12 y4b ff53 fsb fc3 sc0 ls8">9</div><div class="t m0 x5 h11 y4b ff52 fsa fc0 sc0 ls8 ws1d">章 </div></div></div>
<div id="pfec" class="pf w0 h0" data-page-no="ec"><div class="pc pcec w0 h0"><div class="t m0 x0 h2 y1 ff48 fs0 fc0 sc0 ls7 ws0">218  第9章 客户端检测 </div><div class="t m0 x0 h3 y2 ff48 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 ff50 fs6 fc0 sc0 ls21 wsb">    } else { </div><div class="t m0 x0 hb y7a ff50 fs6 fc0 sc0 ls21 wsb">        throw new Error(&quot;No way to retrieve element!&quot;); </div><div class="t m0 x0 hb y7b ff50 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y7c ff50 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h5 y142b ff4f fs2 fc0 sc0 ls44 ws32">这里的getElement()函数的用途是返回具有给定ID的元素。因为document.getElementById()</div><div class="t m0 x0 h4 y142c ff4f fs2 fc0 sc0 ls6 ws6">是实现这一目的的标准方式，所以一开始就测试了这个方法。如果该函数存在（不是未定义），则使用</div><div class="t m0 x0 h4 y142d ff4f fs2 fc0 sc0 ls8 ws1">该函数。否则，就要继续检测document.all是否存在，如果是，则使用它。如果上述两个特性都不</div><div class="t m0 x0 h5 y142e ff4f fs2 fc0 sc0 ls8 ws1">存在（很有可能），则创建并抛出错误，表示这个函数无法使用。 </div><div class="t m0 x0 h4 y142f ff4f fs2 fc0 sc0 ls10b wsdc">要理解能力检测，首先必须理解两个重要的概念。如前所述，第一个概念就是先检测达成目的的最常</div><div class="t m0 x0 h4b y1430 ff4f fs2 fc0 sc0 ls5f ws4c">用的特性。对前面的例子来说，就是要先检测document.getElementById()，后检测document.all。</div><div class="t m0 x0 h5 y1431 ff4f fs2 fc0 sc0 ls8 ws1">先检测最常用的特性可以保证代码最优化，因为在多数情况下都可以避免测试多个条件。 </div><div class="t m0 x0 h4 y1432 ff4f fs2 fc0 sc0 ls8 ws1">第二个重要的概念就是必须测试实际要用到的特性。一个特性存在，不一定意味着另一个特性也存</div><div class="t m0 x0 h5 y1433 ff4f fs2 fc0 sc0 ls8 ws1">在。来看一个例子： </div><div class="t m0 x0 hb y1434 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1435 ff50 fs6 fc0 sc0 ls21 wsb">function getWindowWidth(){ </div><div class="t m0 x0 h36 y1436 ff50 fs6 fc0 sc0 ls21 wsb">    if (document.all){   //假设是IE </div><div class="t m0 x0 h16 y1437 ff50 fs6 fc0 sc0 ls21 wsb">        return document.documentElement.clientWidth; //错误的用法！！！ </div><div class="t m0 x0 hb y1438 ff50 fs6 fc0 sc0 ls21 wsb">    } else { </div><div class="t m0 x0 hb y1439 ff50 fs6 fc0 sc0 ls21 wsb">        return window.innerWidth; </div><div class="t m0 x0 hb y143a ff50 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y143b ff50 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h4 y143c ff4f fs2 fc0 sc0 ls8 ws1">这是一个错误使用能力检测的例子。getWindowWidth()函数首先检查document.all是否存在，</div><div class="t m0 x0 hc y143d ff4f fs2 fc0 sc0 ls8 ws1">如果是则返回document.documentElement.clientWidth。第8章曾经讨论过，IE8及之前版本确</div><div class="t m0 x0 hc ya4c ff4f fs2 fc0 sc0 ls8 ws1">实不支持window.innerWidth属性。但问题是document.all存在也不一定表示浏览器就是 IE。实</div><div class="t m0 x0 hc y143e ff4f fs2 fc0 sc0 ls8 ws1">际上，也可能是Opera；Opera支持document.all，也支持window.innerWidth。 </div><div class="t m0 x0 h20 y143f ff4d fs3 fc0 sc0 ls4d ws40">9.1.1 更可靠的能力检测 </div><div class="t m0 x0 h4 y1440 ff4f fs2 fc0 sc0 ls8 ws1">能力检测对于想知道某个特性是否会按照适当方式行事（而不仅仅是某个特性存在）非常有用。上</div><div class="t m0 x0 h4 y1441 ff4f fs2 fc0 sc0 ls24 ws1e">一节中的例子利用类型转换来确定某个对象成员是否存在，但这样你还是不知道该成员是不是你想要</div><div class="t m0 x0 h5 y1442 ff4f fs2 fc0 sc0 ls8 ws1">的。来看下面的函数，它用来确定一个对象是否支持排序。 </div><div class="t m0 x0 h5 y1443 ff48 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1444 ff50 fs6 fc0 sc0 ls21">//不要这样做！这不是能力检测——只检测了是否存在相应的方法 </div><div class="t m0 x0 hb y1445 ff50 fs6 fc0 sc0 ls21 wsb">function isSortable(object){ </div><div class="t m0 x0 hb y1446 ff50 fs6 fc0 sc0 ls21 wsb">    return !!object.sort; </div><div class="t m0 x0 hb y1447 ff50 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 hb y1448 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 yfa ff4f fs2 fc0 sc0 ls8 ws1">这个函数通过检测对象是否存在sort()方法，来确定对象是否支持排序。问题是，任何包含sort</div><div class="t m0 x0 h5 y1449 ff4f fs2 fc0 sc0 ls8 ws1">属性的对象也会返回true。 </div><div class="t m0 x0 hb y144a ff50 fs6 fc0 sc0 ls21 wsb">var result = isSortable({ sort: true }); </div><div class="t m0 x0 h5 y1386 ff4f fs2 fc0 sc0 ls8 ws1">检测某个属性是否存在并不能确定对象是否支持排序。更好的方式是检测sort是不是一个函数。 </div><div class="t m0 x0 hb y144b ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y144c ff50 fs6 fc0 sc0 ls21">//这样更好：检查sort是不是函数 </div><div class="t m0 x0 hb y144d ff50 fs6 fc0 sc0 ls21 wsb">function isSortable(object){  </div><div class="t m0 x0 hb y144e ff50 fs6 fc0 sc0 ls21 wsb">    return typeof object.sort == &quot;function&quot;; </div><div class="t m0 x0 hb y144f ff50 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y1450 ff50 fs6 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pfed" class="pf w0 h0" data-page-no="ed"><div class="pc pced w0 h0"><div class="t m0 x2 h2 y1 ff48 fs0 fc0 sc0 ls10 wsc">9.1 能力检测    219 </div><div class="t m0 x0 h3 y2 ff48 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff4a fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff4a fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff4a fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff4a fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff4a fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff4a fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff4a fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff4a fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff4a fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff4a fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff4a fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff4a fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff4a fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff4f fs2 fc0 sc0 ls8 ws1">这里的typeof操作符用于确定sort的确是一个函数，因此可以调用它对数据进行排序。 </div><div class="t m0 x0 h1e y4d ff4f fs2 fc0 sc0 ls8 ws1">在可能的情况下，要尽量使用typeof进行能力检测。特别是，宿主对象没有义务让typeof返回</div><div class="t m0 x0 h5 y5 ff4f fs2 fc0 sc0 ls8 ws1">合理的值。最令人发指的事儿就发生在IE中。大多数浏览器在检测到document.createElement()</div><div class="t m0 x0 h5 yd9 ff4f fs2 fc0 sc0 ls8 ws1">存在时，都会返回true。 </div><div class="t m0 x0 hb ye5c ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h36 yead ff50 fs6 fc0 sc0 ls21 wsb"> //在IE8及之前版本中不行  </div><div class="t m0 x0 hb yeae ff50 fs6 fc0 sc0 ls21 wsb">function hasCreateElement(){ </div><div class="t m0 x0 hb yeaf ff50 fs6 fc0 sc0 ls21 wsb">    return typeof document.createElement == &quot;function&quot;; </div><div class="t m0 x0 hb yeb0 ff50 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y1451 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1452 ff4f fs2 fc0 sc0 ls3b">在IE8及之前版本中，这个函数返回false，因为typeof document.createElement返回的是</div><div class="t m0 x0 h5 y10b5 ff50 fs1 fc0 sc0 ls9 ws2">&quot;object&quot;，而不是&quot;function&quot;。如前所述，DOM对象是宿主对象，IE及更早版本中的宿主对象是通</div><div class="t m0 x0 h5 y1453 ff4f fs2 fc0 sc0 ls32">过COM而非JScript实现的。因此，document.createElement()函数确实是一个COM 对象，所以</div><div class="t m0 x0 h5 y1454 ff50 fs1 fc0 sc0 ls9 ws2">typeof才会返回&quot;object&quot;。IE9纠正了这个问题，对所有DOM方法都返回&quot;function&quot;。 </div><div class="t m0 x0 h5 y1455 ff4f fs2 fc0 sc0 ls8 ws1">关于typeof的行为不标准，IE中还可以举出例子来。ActiveX对象（只有IE支持）与其他对象的行</div><div class="t m0 x0 he y1456 ff4f fs2 fc0 sc0 ls8 ws1">为差异很大。例如，不使用typeof测试某个属性会导致错误，如下所示。 </div><div class="t m0 x0 hb y1457 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h36 y1458 ff50 fs6 fc0 sc0 ls21">//在IE中会导致错误 </div><div class="t m0 x0 hb y1459 ff50 fs6 fc0 sc0 ls21 wsb">var xhr = new ActiveXObject(&quot;Microsoft.XMLHttp&quot;); </div><div class="t m0 x0 h16 y145a ff50 fs6 fc0 sc0 ls21 wsb">if (xhr.open){    //这里会发生错误 </div><div class="t m0 x0 h16 y145b ff50 fs6 fc0 sc0 ls21 wsb">    //执行操作 </div><div class="t m0 x0 hb y145c ff50 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 hb y145d ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y145e ff4f fs2 fc0 sc0 ls8 ws1">像这样直接把函数作为属性访问会导致JavaScript错误。使用typeof操作符会更靠谱一点，但 IE</div><div class="t m0 x0 h1e y145f ff4f fs2 fc0 sc0 lsb1">对typeof xhr.open会返回&quot;unknown&quot;。这就意味着，在浏览器环境下测试任何对象的某个特性是否</div><div class="t m0 x0 h5 y1460 ff4f fs2 fc0 sc0 ls8 ws1">存在，要使用下面这个函数。 </div><div class="t m0 x0 hb y1461 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1462 ff50 fs6 fc0 sc0 ls21">//作者：Peter Michaux </div><div class="t m0 x0 hb y1463 ff50 fs6 fc0 sc0 ls21 wsb">function isHostMethod(object, property) { </div><div class="t m0 x0 hb y1464 ff50 fs6 fc0 sc0 ls21 wsb">  var t = typeof object[property]; </div><div class="t m0 x0 hb y1465 ff50 fs6 fc0 sc0 ls21 wsb">  return t==&apos;function&apos; || </div><div class="t m0 x0 hb y1466 ff50 fs6 fc0 sc0 ls21 wsb">         (!!(t==&apos;object&apos; &amp;&amp; object[property])) || </div><div class="t m0 x0 hb y1467 ff50 fs6 fc0 sc0 ls21 wsb">          t==&apos;unknown&apos;; </div><div class="t m0 x0 hb y1468 ff50 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y1469 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y77d ff4f fs2 fc0 sc0 ls8 ws1">可以像下面这样使用这个函数： </div><div class="t m0 x0 hb y146a ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y146b ff50 fs6 fc0 sc0 ls21 wsb">result = isHostMethod(xhr, &quot;open&quot;);   //true </div><div class="t m0 x0 hb y146c ff50 fs6 fc0 sc0 ls21 wsb">result = isHostMethod(xhr, &quot;foo&quot;);    //false </div><div class="t m0 x0 hb y146d ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y146e ff4f fs2 fc0 sc0 ls8 ws1">目前使用isHostMethod()方法还是比较可靠的，因为它考虑到了浏览器的怪异行为。不过也要注</div><div class="t m0 x0 h4 y146f ff4f fs2 fc0 sc0 ls8 ws1">意，宿主对象没有义务保持目前的实现方式不变，也不一定会模仿已有宿主对象的行为。所以，这个函</div><div class="t m0 x0 h4 y1470 ff4f fs2 fc0 sc0 ls8 ws1">数——以及其他类似函数，都不能百分之百地保证永远可靠。作为开发人员，必须对自己要使用某个功</div><div class="t m0 x0 h5 y1471 ff4f fs2 fc0 sc0 ls8 ws1">能的风险作出理性的估计。 </div><div class="t m0 x5 h5 y1472 ff49 fs2 fc0 sc0 ls8 ws14">要想深入了解围绕JavaScript中能力检测的一些观点，请参考Peter Michaux的文</div><div class="t m0 x5 h5 y1473 ff49 fs2 fc0 sc0 ls8 ws14">章“Feature Detection: State of the Art Browser Scripting”，网址为http://peter.michaux.ca/ </div><div class="t m0 x5 h5 y1474 ff48 fs2 fc0 sc0 ls2f ws8a">articles/feature-detection-state-of-the-art-browser-scripting。 </div></div></div>
<div id="pfee" class="pf w0 h0" data-page-no="ee"><div class="pc pcee w0 h0"><div class="t m0 x0 h2 y1 ff48 fs0 fc0 sc0 ls7 ws0">220  第9章 客户端检测 </div><div class="t m0 x0 h3 y2 ff48 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h20 y12d ff4d fs3 fc0 sc0 ls4d ws40">9.1.2 能力检测，不是浏览器检测 </div><div class="t m0 x0 h4 y12e ff4f fs2 fc0 sc0 ls8 ws1">检测某个或某几个特性并不能够确定浏览器。下面给出的这段代码（或与之差不多的代码）可以在</div><div class="t m0 x0 h5 y12f ff4f fs2 fc0 sc0 ls8 ws1">许多网站中看到，这种“浏览器检测”代码就是错误地依赖能力检测的典型示例。 </div><div class="t m0 x0 hb y49e ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1476 ff50 fs6 fc0 sc0 ls21">//错误！还不够具体 </div><div class="t m0 x0 hb y1477 ff50 fs6 fc0 sc0 ls21 wsb">var isFirefox = !!(navigator.vendor &amp;&amp; navigator.vendorSub); </div><div class="t m0 x0 hb y1478 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1479 ff50 fs6 fc0 sc0 ls21">//错误！假设过头了 </div><div class="t m0 x0 hb y147a ff50 fs6 fc0 sc0 ls21 wsb">var isIE = !!(document.all &amp;&amp; document.uniqueID); </div><div class="t m0 x0 hb y147b ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y147c ff4f fs2 fc0 sc0 ls60 ws198">这两行代码代表了对能力检测的典型误用。以前，确实可以通过检测navigator.vendor和</div><div class="t m0 x0 h5 y147d ff50 fs1 fc0 sc0 ls9 ws2">navigator.vendorSub来确定Firefox浏览器。但是，Safari也依葫芦画瓢地实现了相同的属性。于是，</div><div class="t m0 x0 h5 y147e ff4f fs2 fc0 sc0 ls4c ws3e">这段代码就会导致人们作出错误的判断。为检测IE，代码测试了document.all 和document. </div><div class="t m0 x0 h21 y147f ff50 fs1 fc0 sc0 ls9 ws2">uniqueID。这就相当于假设IE将来的版本中仍然会继续存在这两个属性，同时还假设其他浏览器都不</div><div class="t m0 x0 h4 y1480 ff4f fs2 fc0 sc0 ls8 ws1">会实现这两个属性。最后，这两个检测都使用了双逻辑非操作符来得到布尔值（比先存储后访问的效果</div><div class="t m0 x0 h5 y1481 ff4f fs2 fc0 sc0 ls8 ws1">更好）。 </div><div class="t m0 x0 h4 y1482 ff4f fs2 fc0 sc0 ls8 ws1">实际上，根据浏览器不同将能力组合起来是更可取的方式。如果你知道自己的应用程序需要使用某</div><div class="t m0 x0 h5 y1483 ff4f fs2 fc0 sc0 ls8 ws1">些特定的浏览器特性，那么最好是一次性检测所有相关特性，而不要分别检测。看下面的例子。 </div><div class="t m0 x0 hb y1484 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1485 ff50 fs6 fc0 sc0 ls21">//确定浏览器是否支持Netscape风格的插件 </div><div class="t m0 x0 hb y1486 ff50 fs6 fc0 sc0 ls21 wsb">var hasNSPlugins = !!(navigator.plugins &amp;&amp; navigator.plugins.length); </div><div class="t m0 x0 hb y1487 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1488 ff50 fs6 fc0 sc0 ls21">//确定浏览器是否具有DOM1级规定的能力 </div><div class="t m0 x0 hb y1489 ff50 fs6 fc0 sc0 ls21 wsb">var hasDOM1 = !!(document.getElementById &amp;&amp; document.createElement &amp;&amp; </div><div class="t m0 x0 hb y148a ff50 fs6 fc0 sc0 ls21 wsb">               document.getElementsByTagName); </div><div class="t m0 x0 hb y148b ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf y3bd ff55 fs2 fc0 sc0 ls1b wsb">CapabilitiesDetectionExample01.htm </div><div class="t m0 x0 h5 y148c ff4f fs2 fc0 sc0 ls8 ws1">以上例子展示了两个检测：一个检测浏览器是否支持Netscapte风格的插件；另一个检测浏览器是</div><div class="t m0 x0 h5 y148d ff4f fs2 fc0 sc0 ls8 ws1">否具备DOM1级所规定的能力。得到的布尔值可以在以后继续使用，从而节省重新检测能力的时间。 </div><div class="t m0 x5 ha y148e ff49 fs2 fc0 sc0 ls8 ws14">在实际开发中，应该将能力检测作为确定下一步解决方案的依据，而不是用它来</div><div class="t m0 x0 h5 y148f ff49 fs2 fc0 sc0 ls8 ws14">判断用户使用的是什么浏览器。 </div><div class="t m0 x0 hd y1490 ff4d fs7 fc0 sc0 ls22">9.2 怪癖检测 </div><div class="t m0 x0 h5 y1491 ff4f fs2 fc0 sc0 ls6 ws6">与能力检测类似，怪癖检测（quirks detection）的目标是识别浏览器的特殊行为。但与能力检测确</div><div class="t m0 x0 h5 y1492 ff4f fs2 fc0 sc0 ls8 ws1">认浏览器支持什么能力不同，怪癖检测是想要知道浏览器存在什么缺陷（“怪癖”也就是bug）。这通常</div><div class="t m0 x0 h5 y1493 ff4f fs2 fc0 sc0 ls8 ws1">需要运行一小段代码，以确定某一特性不能正常工作。例如，IE8及更早版本中存在一个bug，即如果</div><div class="t m0 x0 h4b y1494 ff4f fs2 fc0 sc0 ls8 ws1">某个实例属性与[[Enumerable]]标记为false的某个原型属性同名，那么该实例属性将不会出现在</div><div class="t m0 x0 h5 y1495 ff50 fs1 fc0 sc0 ls9 ws2">fon-in循环当中。可以使用如下代码来检测这种“怪癖”。 </div><div class="t m0 x0 hb y1496 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1497 ff50 fs6 fc0 sc0 ls21 wsb">var hasDontEnumQuirk = function(){ </div><div class="t m0 x0 hb y1498 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1499 ff50 fs6 fc0 sc0 ls21 wsb">    var o = { toString : function(){} }; </div><div class="t m0 x0 hb y149a ff50 fs6 fc0 sc0 ls21 wsb">    for (var prop in o){ </div></div></div>
<div id="pfef" class="pf w0 h0" data-page-no="ef"><div class="pc pcef w0 h0"><div class="t m0 x2 h2 y1 ff48 fs0 fc0 sc0 ls10 wsc">9.3 用户代理检测    221 </div><div class="t m0 x0 h3 y2 ff48 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff4a fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff4a fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff4a fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff4a fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff4a fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff4a fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff4a fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff4a fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff4a fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff4a fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff4a fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff4a fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff4a fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y8f5 ff50 fs6 fc0 sc0 ls21 wsb">        if (prop == &quot;toString&quot;){ </div><div class="t m0 x0 hb y8f6 ff50 fs6 fc0 sc0 ls21 wsb">            return false; </div><div class="t m0 x0 hb y8f7 ff50 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y8f8 ff50 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y8f9 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y8fa ff50 fs6 fc0 sc0 ls21 wsb">    return true; </div><div class="t m0 x0 hb y8fb ff50 fs6 fc0 sc0 ls21 wsb">}(); </div><div class="t m0 x0 hb y8fc ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y149b ff55 fs2 fc0 sc0 ls8 wsb">QuirksDetectionExample01.htm </div><div class="t m0 x0 h4 y149c ff4f fs2 fc0 sc0 ls6 ws6">以上代码通过一个匿名函数来测试该“怪癖”，函数中创建了一个带有toString()方法的对象。</div><div class="t m0 x0 hc y149d ff4f fs2 fc0 sc0 ls8 ws1">在正确的ECMAScript实现中，toString应该在for-in循环中作为属性返回。 </div><div class="t m0 x0 h5 y149e ff4f fs2 fc0 sc0 ls8 ws1">另一个经常需要检测的“怪癖”是Safari 3以前版本会枚举被隐藏的属性。可以用下面的函数来检</div><div class="t m0 x0 h5 y149f ff4f fs2 fc0 sc0 ls8 ws1">测该“怪癖”。 </div><div class="t m0 x5 hb y14a0 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y14a1 ff50 fs6 fc0 sc0 ls21 wsb">var hasEnumShadowsQuirk = function(){ </div><div class="t m0 x0 hb y14a2 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y14a3 ff50 fs6 fc0 sc0 ls21 wsb">    var o = { toString : function(){} }; </div><div class="t m0 x0 hb y14a4 ff50 fs6 fc0 sc0 ls21 wsb">    var count = 0; </div><div class="t m0 x0 hb y14a5 ff50 fs6 fc0 sc0 ls21 wsb">    for (var prop in o){ </div><div class="t m0 x0 hb y14a6 ff50 fs6 fc0 sc0 ls21 wsb">        if (prop == &quot;toString&quot;){ </div><div class="t m0 x0 hb y14a7 ff50 fs6 fc0 sc0 ls21 wsb">            count++; </div><div class="t m0 x0 hb y14a8 ff50 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y14a9 ff50 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y14aa ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y14ab ff50 fs6 fc0 sc0 ls21 wsb">    return (count &gt; 1); </div><div class="t m0 x0 hb y14ac ff50 fs6 fc0 sc0 ls21 wsb">}();  </div><div class="t m0 x2 hf y14ad ff55 fs2 fc0 sc0 ls8 wsb">QuirksDetectionExample01.htm </div><div class="t m0 x0 h5 y14ae ff4f fs2 fc0 sc0 ls8 ws1">如果浏览器存在这个bug，那么使用for-in循环枚举带有自定义的toString()方法的对象，就</div><div class="t m0 x0 h5 y14af ff4f fs2 fc0 sc0 ls8 ws1">会返回两个toString的实例。 </div><div class="t m0 x0 h5 y14b0 ff4f fs2 fc0 sc0 ls8 ws1">一般来说，“怪癖”都是个别浏览器所独有的，而且通常被归为bug。在相关浏览器的新版本中，这</div><div class="t m0 x0 h4 y14b1 ff4f fs2 fc0 sc0 ls8 ws1">些问题可能会也可能不会被修复。由于检测“怪癖”涉及运行代码，因此我们建议仅检测那些对你有直</div><div class="t m0 x0 h5 y14b2 ff4f fs2 fc0 sc0 ls8 ws1">接影响的“怪癖”，而且最好在脚本一开始就执行此类检测，以便尽早解决问题。 </div><div class="t m0 x0 hd y14b3 ff4d fs7 fc0 sc0 ls22">9.3 用户代理检测 </div><div class="t m0 x0 h4 y14b4 ff4f fs2 fc0 sc0 ls8 ws1">第三种，也是争议最大的一种客户端检测技术叫做用户代理检测。用户代理检测通过检测用户代理</div><div class="t m0 x0 h5 y14b5 ff4f fs2 fc0 sc0 ls8 ws1">字符串来确定实际使用的浏览器。在每一次HTTP请求过程中，用户代理字符串是作为响应首部发送的，</div><div class="t m0 x0 h5 y14b6 ff4f fs2 fc0 sc0 ls8 ws1">而且该字符串可以通过JavaScript的navigator.userAgent属性访问。在服务器端，通过检测用户代</div><div class="t m0 x0 h4 y14b7 ff4f fs2 fc0 sc0 ls8 ws1">理字符串来确定用户使用的浏览器是一种常用而且广为接受的做法。而在客户端，用户代理检测一般被</div><div class="t m0 x0 h5 y14b8 ff4f fs2 fc0 sc0 ls8 ws1">当作一种万不得已才用的做法，其优先级排在能力检测和（或）怪癖检测之后。 </div><div class="t m0 x0 h5 y14b9 ff4f fs2 fc0 sc0 ls8 ws1">提到与用户代理字符串有关的争议，就不得不提到电子欺骗（spoofing）。所谓电子欺骗，就是指浏</div><div class="t m0 x0 h4 y14ba ff4f fs2 fc0 sc0 ls8 ws1">览器通过在自己的用户代理字符串加入一些错误或误导性信息，来达到欺骗服务器的目的。要弄清楚这</div><div class="t m0 x0 h5 y14bb ff4f fs2 fc0 sc0 ls8 ws1">个问题的来龙去脉，必须从Web问世初期用户代理字符串的发展讲起。 </div></div></div>
<div id="pff0" class="pf w0 h0" data-page-no="f0"><div class="pc pcf0 w0 h0"><div class="t m0 x0 h2 y1 ff48 fs0 fc0 sc0 ls7 ws0">222  第9章 客户端检测 </div><div class="t m0 x0 h3 y2 ff48 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h20 y12d ff4d fs3 fc0 sc0 ls4d ws40">9.3.1 用户代理字符串的历史 </div><div class="t m0 x0 h5 y12e ff48 fs2 fc0 sc0 ls84 ws62">HTTP规范（包括1.0和1.1版）明确规定，浏览器应该发送简短的用户代理字符串，指明浏览器的</div><div class="t m0 x0 h5 y12f ff4f fs2 fc0 sc0 ls8 ws1">名称和版本号。RFC 2616（即HTTP 1.1协议规范）是这样描述用户代理字符串的： </div><div class="t m0 x0 h5 y14bc ff48 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y14bd ff4f fs2 fc0 sc0 ls5 ws4">上述规范进一步规定，用户代理字符串应该以一组产品的形式给出，字符串格式为：标识符/产品</div><div class="t m0 x0 h5 y14be ff4f fs2 fc0 sc0 ls8 ws1">版本号。但是，现实中的用户代理字符串则绝没有如此简单。 </div><div class="t m0 x0 h3c y14bf ff4d fs2 fc0 sc0 ls2e wsb">1. 早期的浏览器 </div><div class="t m0 x0 h5 y14c0 ff48 fs2 fc0 sc0 ls8 ws20">1993年，美国NCSA（National Center for Supercomputing Applications，国家超级计算机中心）发布</div><div class="t m0 x0 h5 y14c1 ff4f fs2 fc0 sc0 ls8 ws1">了世界上第一款Web浏览器Mosaic。这款浏览器的用户代理字符串非常简单，类似如下所示。 </div><div class="t m0 x0 hb y2bb ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y14c2 ff50 fs6 fc0 sc0 ls21 wsb">Mosaic/0.9 </div><div class="t m0 x0 hb y14c3 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y14c4 ff4f fs2 fc0 sc0 ls8 ws1">尽管这个字符串在不同操作系统和不同平台下会有所变化，但其基本格式还是简单明了的。正斜杠</div><div class="t m0 x0 h5 y14c5 ff4f fs2 fc0 sc0 ls8 ws1">前面的文本表示产品名称（有时候会出现NCSA Mosaic或其他类似字样），而斜杠后面的文本是产品的</div><div class="t m0 x0 h5 y14c6 ff4f fs2 fc0 sc0 ls8">版本号。 </div><div class="t m0 x0 h5 y14c7 ff48 fs2 fc0 sc0 lsb ws1a1">Netscape Communications公司介入浏览器开发领域后，遂将自己产品的代号定名为Mozilla（Mosaic </div><div class="t m0 x0 h5 y14c8 ff48 fs2 fc0 sc0 ls25 wsb3">Killer的简写，意即Mosaic杀手）。该公司第一个公开发行版，Netscape Navigator 2的用户代理字符串</div><div class="t m0 x0 h5 y14c9 ff4f fs2 fc0 sc0 ls8 ws1">具有如下格式。 </div><div class="t m0 x0 hb y14ca ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y14cb ff50 fs6 fc0 sc0 ls21 ws34">Mozilla/版本号 [语言] (平台; 加密类型) </div><div class="t m0 x0 hb y14cc ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y14cd ff48 fs2 fc0 sc0 ls200 ws19c">Netscape在坚持将产品名和版本号作为用户代理字符串开头的基础上，又在后面依次添加了下列</div><div class="t m0 x0 h5 y14ce ff4f fs2 fc0 sc0 ls5">信息。 </div><div class="t m0 x0 h5 y14cf ff4e fs1 fc0 sc0 ls2"> 语言：即语言代码，表示应用程序针对哪种语言设计。 </div><div class="t m0 x0 h5 y14d0 ff4e fs1 fc0 sc0 ls2"> 平台：即操作系统和（或）平台，表示应用程序的运行环境。 </div><div class="t m0 x0 h5 y14d1 ff4e fs1 fc0 sc0 ls2"> 加密类型：即安全加密的类型。可能的值有U（128位加密）、I（40位加密）和N（未加密）。 </div><div class="t m0 x0 h5 y14d2 ff4f fs2 fc0 sc0 ls8 ws1">典型的Netscape Navigator 2的用户代理字符串如下所示。 </div><div class="t m0 x0 hb y14d3 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y14d4 ff50 fs6 fc0 sc0 ls21 wsb">Mozilla/2.02 [fr] (WinNT; I) </div><div class="t m0 x0 hb y14d5 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y14d6 ff4f fs2 fc0 sc0 ls8 ws1">这个字符串表示浏览器是Netscape Navigator 2.02，为法语国家编译，运行在Windows NT平台下，</div><div class="t m0 x0 h5 y14d7 ff4f fs2 fc0 sc0 ls8 ws1">加密类型为40位。那个时候，通过用户代理字符串中的产品名称，至少还能够轻易地确定用户使用的</div><div class="t m0 x0 h5 yf9 ff4f fs2 fc0 sc0 ls8 ws1">是什么浏览器。 </div><div class="t m0 x0 hb y14d8 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h3c y14d9 ff4d fs2 fc0 sc0 ls94 ws1a2">2. Netscape Navigator 3和Internet Explorer 3 </div><div class="t m0 x0 hb y14da ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y4e9 ff48 fs2 fc0 sc0 ls8 ws20">1996年，Netscape Navigator 3发布，随即超越Mosaic成为当时最流行的Web 浏览器。而用户代理</div><div class="t m0 x0 h5 y14db ff4f fs2 fc0 sc0 ls8 ws1">字符串只作了一些小的改变，删除了语言标记，同时允许添加操作系统或系统使用的CPU等可选信息。</div><div class="t m0 x0 h5 y14dc ff4f fs2 fc0 sc0 ls8 ws1">于是，格式变成如下所示。 </div><div class="t m0 x0 hb y14dd ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y14de ff50 fs6 fc0 sc0 ls21 ws34">Mozilla/版本号 (平台; 加密类型 [; 操作系统或CPU说明]) </div><div class="t m0 x0 hb y14df ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y10f6 ff4f fs2 fc0 sc0 ls8 ws1">运行在Windows系统下的Netscape Navigator 3的用户代理字符串大致如下。 </div><div class="t m0 x0 hb y14e0 ff50 fs6 fc0 sc0 ls21 wsb">Mozilla/3.0 (Win95; U) </div></div></div>
<div id="pff1" class="pf w0 h0" data-page-no="f1"><div class="pc pcf1 w0 h0"><div class="t m0 x2 h2 y1 ff48 fs0 fc0 sc0 ls10 wsc">9.3 用户代理检测    223 </div><div class="t m0 x0 h3 y2 ff48 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff4a fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff4a fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff4a fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff4a fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff4a fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff4a fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff4a fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff4a fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff4a fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff4a fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff4a fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff4a fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff4a fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff4f fs2 fc0 sc0 ls8 ws1">这个字符串表示Netscape Navigator 3运行在Windows 95 中，采用了 128位加密技术。可见，在</div><div class="t m0 x0 h5 y4d ff48 fs2 fc0 sc0 lsb ws5">Windows系统中，字符串中的操作系统或CPU说明被省略了。 </div><div class="t m0 x0 h5 yd8 ff48 fs2 fc0 sc0 ls8 ws1a8">Netscape Navigator 3发布后不久，微软也发布了其第一款赢得用户广泛认可的Web 浏览器，即</div><div class="t m0 x0 h5 y28b ff48 fs2 fc0 sc0 ls94 ws1a9">Internet Explorer 3。由于Netscape浏览器在当时占绝对市场份额，许多服务器在提供网页之前都要专门</div><div class="t m0 x0 h5 yfdb ff4f fs2 fc0 sc0 ls8 ws1">检测该浏览器。如果用户通过IE打不开相关网页，那么这个新生的浏览器很可能就会夭折。于是，微</div><div class="t m0 x0 h5 y14e1 ff4f fs2 fc0 sc0 ls8 ws1">软决定将IE的用户代理字符串修改成兼容Netscape的形式，结果如下： </div><div class="t m0 x5 hb yb70 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y14e2 ff50 fs6 fc0 sc0 ls21 wsb">Mozilla/2.0 (compatible; MSIE 版本号; 操作系统) </div><div class="t m0 x5 hb y14e3 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y14e4 ff4f fs2 fc0 sc0 ls8">例如，Windows 95平台下的Internet Explorer 3.02带有如下用户代理字符串： </div><div class="t m0 x5 hb y14e5 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y14e6 ff50 fs6 fc0 sc0 ls21 wsb">Mozilla/2.0 (compatible; MSIE 3.02; Windows 95) </div><div class="t m0 x5 hb y14e7 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y14e8 ff4f fs2 fc0 sc0 ls8 ws1">由于当时的大多数浏览器嗅探程序只检测用户代理字符串中的产品名称部分，结果IE就成功地将</div><div class="t m0 x0 h5 y14e9 ff4f fs2 fc0 sc0 ls8 ws1">自己标识为Mozilla，从而伪装成Netscape Navigator。微软的这一做法招致了很多批评，因为它违反了</div><div class="t m0 x0 h5 y14ea ff4f fs2 fc0 sc0 ls8 ws1">浏览器标识的惯例。更不规范的是，IE将真正的浏览器版本号插入到了字符串的中间。 </div><div class="t m0 x0 h5 y14eb ff4f fs2 fc0 sc0 ls8 ws1">字符串中另外一个有趣的地方是标识符Mozilla 2.0（而不是3.0）。毕竟，当时的主流版本是3.0，</div><div class="t m0 x0 h5 y14ec ff4f fs2 fc0 sc0 ls8 ws1">改成3.0应该对微软更有利才对。但真正的谜底到现在还没有揭开——但很可能只是人为疏忽所致。 </div><div class="t m0 x0 h3c y14ed ff4d fs2 fc0 sc0 ls96 ws7d">3. Netscape Communicator 4和IE4～IE8 </div><div class="t m0 x0 h5 y14ee ff48 fs2 fc0 sc0 ls8 ws20">1997年8月，Netscapte Communicator 4发布（这一版将浏览器名字中的Navigator换成了Commu- </div><div class="t m0 x0 h5 y14ef ff48 fs2 fc0 sc0 ls5e ws66">nicator）。Netscape继续遵循了第3版时的用户代理字符串格式： </div><div class="t m0 x5 hb y14f0 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y14f1 ff50 fs6 fc0 sc0 ls21 ws34">Mozilla/版本号 (平台; 加密类型 [; 操作系统或CPU说明]) </div><div class="t m0 x5 hb y14f2 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y14f3 ff4f fs2 fc0 sc0 ls8">因此，Windows 98平台中第4版的用户代理字符串如下所示： </div><div class="t m0 x5 hb y14f4 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y14f5 ff50 fs6 fc0 sc0 ls21 wsb">Mozilla/4.0 (Win98; I) </div><div class="t m0 x5 hb y14f6 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y14f7 ff48 fs2 fc0 sc0 ls81 ws76">Netscape在发布补丁时，子版本号也会相应提高，用户代理字符串如下面的4.79版所示： </div><div class="t m0 x5 hb y14f8 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y14f9 ff50 fs6 fc0 sc0 ls21 wsb">Mozilla/4.79 (Win98; I) </div><div class="t m0 x5 hb y14fa ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y14fb ff4f fs2 fc0 sc0 ls8 ws1">但是，微软在发布Internet Explorer 4时，顺便将用户代理字符串修改成了如下格式： </div><div class="t m0 x5 hb y14fc ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y14fd ff50 fs6 fc0 sc0 ls21 wsb">Mozilla/4.0 (compatible; MSIE 版本号; 操作系统) </div><div class="t m0 x5 hb y14fe ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y14ff ff4f fs2 fc0 sc0 ls8 ws1">换句话说，对于Windows 98中运行的IE4而言，其用户代理字符串为： </div><div class="t m0 x5 hb ycb ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1500 ff50 fs6 fc0 sc0 ls21 wsb">Mozilla/4.0 (compatible; MSIE 4.0; Windows 98) </div><div class="t m0 x5 hb y1501 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1502 ff4f fs2 fc0 sc0 ls8 ws1">经过此番修改，Mozilla版本号就与实际的IE版本号一致了，为识别它们的第四代浏览器提供了方</div><div class="t m0 x0 h5 y1503 ff4f fs2 fc0 sc0 ls8 ws1">便。但令人遗憾的是，两者的一致性仅限于这一个版本。在Internet Explorer 4.5发布时（只针对Macs），</div><div class="t m0 x0 h5 y1504 ff4f fs2 fc0 sc0 ls8 ws1">虽然Mozilla版本号还是4，但IE版本号则改成了如下所示： </div><div class="t m0 x0 hb y1505 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1506 ff50 fs6 fc0 sc0 ls21 wsb">Mozilla/4.0 (compatible; MSIE 4.5; Mac_PowerPC) </div><div class="t m0 x0 hb y1507 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1508 ff4f fs2 fc0 sc0 ls8">此后，IE的版本一直到7都沿袭了这个模式： </div><div class="t m0 x0 hb y1509 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y150a ff50 fs6 fc0 sc0 ls21 wsb">Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1) </div><div class="t m0 x0 hb y150b ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y32c ff4f fs2 fc0 sc0 ls3b">而IE8的用户代理字符串中添加了呈现引擎（Trident）的版本号： </div><div class="t m0 x5 hb y150c ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y150d ff50 fs6 fc0 sc0 ls21 wsb">Mozilla/4.0 (compatible; MSIE 版本号; 操作系统; Trident/Trident版本号) </div><div class="t m0 x5 hb y150e ff50 fs6 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pff2" class="pf w0 h0" data-page-no="f2"><div class="pc pcf2 w0 h0"><div class="t m0 x0 h2 y1 ff48 fs0 fc0 sc0 ls7 ws0">224  第9章 客户端检测 </div><div class="t m0 x0 h3 y2 ff48 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff4f fs2 fc0 sc0 ls8">例如： </div><div class="t m0 x0 hb yfb2 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yfb3 ff50 fs6 fc0 sc0 ls21 wsb">Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0) </div><div class="t m0 x0 hb y1510 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1511 ff4f fs2 fc0 sc0 ls8 ws1">这个新增的Trident记号是为了让开发人员知道IE8是不是在兼容模式下运行。如果是，则MSIE的</div><div class="t m0 x0 h5 y1512 ff4f fs2 fc0 sc0 ls8 ws1">版本号会变成7，但Trident及版本号还会留在用户代码字符串中： </div><div class="t m0 x0 hb y3fd ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1513 ff50 fs6 fc0 sc0 ls21 wsb">Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0)  </div><div class="t m0 x0 h5 y1514 ff48 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1515 ff4f fs2 fc0 sc0 ls8 ws1">增加这个记号有助于分辨浏览器到底是IE7（没有Trident记号），还是运行在兼容模式下的IE8。 </div><div class="t m0 x0 h5 y1516 ff48 fs2 fc0 sc0 ls2a ws21">IE9对字符串格式做了一点调整。Mozilla版本号增加到了5.0，而Trident的版本号也升到了5.0。IE9</div><div class="t m0 x0 h5 y1517 ff4f fs2 fc0 sc0 ls8 ws1">默认的用户代理字符串如下： </div><div class="t m0 x0 h5 y1518 ff48 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1519 ff50 fs6 fc0 sc0 ls21 wsb">Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0) </div><div class="t m0 x0 hb y151a ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y151b ff4f fs2 fc0 sc0 ls8 ws1">如果IE9运行在兼容模式下，字符串中的Mozilla版本号和 MSIE版本号会恢复旧的值，但Trident</div><div class="t m0 x0 h5 y151c ff4f fs2 fc0 sc0 ls8 ws1">的版本号仍然是5.0。例如，下面就是IE9运行在IE7兼容模式下的用户代理字符串： </div><div class="t m0 x0 h5 y151d ff48 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y151e ff50 fs6 fc0 sc0 ls21 ws34">Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; Trident/5.0) </div><div class="t m0 x0 h5 y151f ff48 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1520 ff4f fs2 fc0 sc0 ls8 ws1">所有这些变化都是为了确保过去的用户代理检测脚本能够继续发挥作用，同时还能给新脚本提供更</div><div class="t m0 x0 h5 y1521 ff4f fs2 fc0 sc0 ls8 ws1">丰富的信息。 </div><div class="t m0 x0 h2f y1522 ff4d fs2 fc0 sc0 ls7a ws1b9">4. Gecko </div><div class="t m0 x0 h5 y1523 ff48 fs2 fc0 sc0 ls81 ws76">Gecko是Firefox的呈现引擎。当初的Gecko是作为通用Mozilla 浏览器的一部分开发的，而第一个</div><div class="t m0 x0 h5 y1524 ff4f fs2 fc0 sc0 ls8 ws1">采用Gecko引擎的浏览器是Netscape 6。为Netscape 6编写的一份规范中规定了未来版本中用户代理字</div><div class="t m0 x0 h5 y1525 ff4f fs2 fc0 sc0 ls8 ws1">符串的构成。这个新格式与4.x版本中相对简单的字符串相比，有着非常大的区别，如下所示： </div><div class="t m0 x0 hb y1526 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1527 ff50 fs6 fc0 sc0 ls21 ws34">Mozilla/Mozilla版本号 (平台; 加密类型; 操作系统或CPU; 语言; 预先发行版本)  </div><div class="t m0 x0 h16 y1528 ff50 fs6 fc0 sc0 ls21 wsb">     Gecko/Gecko版本号 应用程序或产品/应用程序或产品版本号 </div><div class="t m0 x0 hb y1529 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y152a ff4f fs2 fc0 sc0 ls8 ws1">这个明显复杂了很多的用户代理字符串中蕴含很多新想法。下表列出了字符串中各项的用意。 </div><div class="t m0 x0 hb y152b ff50 fs6 fc0 sc0 ls8 wsb">  </div><div class="t m0 x0 h31 y152c ff4c fs6 fc0 sc0 ls8">字符串项 必需吗 说  明 </div><div class="t m0 x0 h36 y152d ff48 fs6 fc0 sc0 ls1b6 ws16e">Mozilla版本号 是 Mozilla的版本号 </div><div class="t m0 x0 h36 y152e ff4f fs6 fc0 sc0 ls31">平台 是 浏览器运行的平台。可能的值包括Windows、Mac和X11（指Unix的</div><div class="t m0 x7 h36 y152f ff48 fs6 fc0 sc0 ls8">X窗口系统） </div><div class="t m0 x0 h36 y1530 ff4f fs6 fc0 sc0 ls8 ws33">加密类型 是 加密技术的类型：U表示128位、I表示40位、N表示未加密 </div><div class="t m0 x0 h36 y1531 ff4f fs6 fc0 sc0 ls8 ws33">操作系统或CPU  是 浏览器运行的操作系统或计算机系统使用的CPU。在Windows平台</div><div class="t m0 x7 h36 y1532 ff4f fs6 fc0 sc0 ls8 ws33">中，这一项指Windows的版本（如WinNT、Win95，等等）。如果平台</div><div class="t m0 x7 h36 y1533 ff4f fs6 fc0 sc0 ls95">是Macintosh，这一项指CPU（针对PowerPC的68K、PPC，或MacIntel）。</div><div class="t m0 x7 h36 y1534 ff4f fs6 fc0 sc0 ls1c6 ws1b5">如果平台是X11，这一项是Unix操作系统的名称，与使用Unix命令</div><div class="t m0 x7 h36 y378 ff50 fsc fc0 sc0 lsa8 ws80">uname–sm得到的名称相同 </div><div class="t m0 x0 h36 y1535 ff4f fs6 fc0 sc0 ls31">语言 是 浏览器设计时所针对的目标用户语言 </div><div class="t m0 x0 h36 y1536 ff4f fs6 fc0 sc0 ls8 ws33">预先发行版本 否 最初用于表示Mozilla的预先发行版本，现在则用来表示Gecko呈现引</div><div class="t m0 x7 h36 y1537 ff4f fs6 fc0 sc0 ls8 ws33">擎的版本号 </div><div class="t m0 x0 h36 y1538 ff48 fs6 fc0 sc0 ls1c5 ws176">Gecko版本号 是 Gecko呈现引擎的版本号，但由yyyymmdd格式的日期表示 </div><div class="t m0 x0 h36 y1539 ff4f fs6 fc0 sc0 ls8 ws33">应用程序或产品 否 使用Gecko的产品名。可能是Netscape、Firefox等 </div><div class="t m0 x0 h36 y153a ff4f fs6 fc0 sc0 ls8 ws33">应用程序或产品版本号 否 应用程序或产品的版本号；用于区分Mozilla版本号和Gecko版本号 </div></div></div>
<div id="pff3" class="pf w0 h0" data-page-no="f3"><div class="pc pcf3 w0 h0"><div class="t m0 x2 h2 y1 ff48 fs0 fc0 sc0 ls10 wsc">9.3 用户代理检测    225 </div><div class="t m0 x0 h3 y2 ff48 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff4a fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff4a fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff4a fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff4a fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff4a fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff4a fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff4a fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff4a fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff4a fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff4a fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff4a fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff4a fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff4a fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff4f fs2 fc0 sc0 ls8 ws1">为了帮助读者更好地理解Gecko的用户代理字符串，下面我们来看几个从基于Gecko的浏览器中取</div><div class="t m0 x0 h5 y4d ff4f fs2 fc0 sc0 ls8 ws1">得的字符串。 </div><div class="t m0 x0 h5 yd8 ff48 fs2 fc0 sc0 lsc7 ws141">Windows XP下的Netscape 6.21： </div><div class="t m0 x5 hb y6bd ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y6be ff50 fs6 fc0 sc0 ls216 ws1c1">Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:0.9.4) Gecko/20011128 Netscape6/6.2.1 </div><div class="t m0 x5 hb y153b ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y6e5 ff48 fs2 fc0 sc0 ls2e wsf4">Linux下的SeaMonkey 1.1a： </div><div class="t m0 x5 hb y618 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y153c ff50 fs6 fc0 sc0 ls21 wsb">Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.1b2) Gecko/20060823 SeaMonkey/1.1a </div><div class="t m0 x5 hb y153d ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y153e ff48 fs2 fc0 sc0 lsc7 ws141">Windows XP下的Firefox 2.0.0.11： </div><div class="t m0 x5 hb y153f ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1540 ff50 fs6 fc0 sc0 ls1b0 ws1c2">Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.11) Gecko/20071127 Firefox/2.0.0.11 </div><div class="t m0 x5 hb y1541 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1542 ff48 fs2 fc0 sc0 ls138 ws1c3">Mac OS X下的Camino 1.5.1： </div><div class="t m0 x5 hb y1543 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1544 ff50 fs6 fc0 sc0 ls21 ws1c4">Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en; rv:1.8.1.6) Gecko/20070809 Camino/1.5.1 </div><div class="t m0 x5 hb y1545 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1348 ff4f fs2 fc0 sc0 ls42 ws30">以上这些用户代理字符串都取自基于Gecko的浏览器（只是版本有所不同）。很多时候，检测特定的</div><div class="t m0 x0 h5 y1546 ff4f fs2 fc0 sc0 ls42 ws30">浏览器还不如搞清楚它是否基于Gecko更重要。每个字符串中的Mozilla版本都是 5.0，自从第一个基于</div><div class="t m0 x0 h5 y1547 ff48 fs2 fc0 sc0 ls217 ws1bd">Gecko的浏览器发布时修改成这个样子，至今就没有改变过；而且，看起来以后似乎也不会有什么变化。 </div><div class="t m0 x0 h5 y1548 ff4f fs2 fc0 sc0 ls8 ws1">随着Firefox 4发布，Mozilla简化了这个用户代理字符串。主要改变包括以下几方面。 </div><div class="t m0 x0 h5 y1549 ff4e fs1 fc0 sc0 ls2"> 删除了“语言”记号（例如，前面例子中的“en-US”）。 </div><div class="t m0 x0 h5 y154a ff4e fs1 fc0 sc0 ls2"> 在浏览器使用强加密（默认设置）时，不显示“加密类型”。也就是说，Mozilla用户代理字符串</div><div class="t m0 x5 h5 y154b ff4f fs2 fc0 sc0 ls8 ws1">中不会再出现“U”，而“I”和“N”还会照常出现。 </div><div class="t m0 x0 h5 y154c ff4e fs1 fc0 sc0 ls2"> “平台”记号从Windows用户代理字符串中删除了，“操作系统或CPU”中始终都包含</div><div class="t m0 x0 h5 y154d ff4f fs2 fc0 sc0 ls8 ws1">“Windows”字符串。 </div><div class="t m0 x0 h5 y154e ff4e fs1 fc0 sc0 ls2"> “Gecko版本号”固定为“Gecko/20100101”。 </div><div class="t m0 x0 h5 y154f ff4f fs2 fc0 sc0 ls8">最后，Firefox 4用户代理字符串变成了下面这个样子： </div><div class="t m0 x0 hb y601 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y602 ff50 fs6 fc0 sc0 ls21 wsb">Mozilla/5.0 (Windows NT 6.1; rv:2.0.1) Gecko/20100101 Firefox 4.0.1 </div><div class="t m0 x0 hb y1550 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h2f y1551 ff4d fs2 fc0 sc0 ls8 wsd9">5. WebKit </div><div class="t m0 x0 h5 y1552 ff48 fs2 fc0 sc0 ls8 ws20">2003年，Apple公司宣布要发布自己的Web浏览器，名字定为Safari。Safari的呈现引擎叫 WebKit，</div><div class="t m0 x0 h5 y1553 ff4f fs2 fc0 sc0 ls3b">是Linux平台中Konqueror浏览器的呈现引擎KHTML的一个分支。几年后，WebKit 独立出来成为了一</div><div class="t m0 x0 h5 y1554 ff4f fs2 fc0 sc0 ls8 ws1">个开源项目，专注于呈现引擎的开发。 </div><div class="t m0 x0 h5 y1555 ff4f fs2 fc0 sc0 ls8 ws1">这款新浏览器和呈现引擎的开发人员也遇到了与Internet Explorer 3.0类似的问题：如何确保这款浏</div><div class="t m0 x0 h4 y1556 ff4f fs2 fc0 sc0 ls8 ws1">览器不被流行的站点拒之门外？答案就是向用户代理字符串中放入足够多的信息，以便站点能够信任它</div><div class="t m0 x0 h5 y1557 ff4f fs2 fc0 sc0 ls8 ws1">与其他流行的浏览器是兼容的。于是，WebKit的用户代理字符串就具备了如下格式： </div><div class="t m0 x5 hb y1558 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1559 ff50 fs6 fc0 sc0 ls21 wsb">Mozilla/5.0 (;  ;  CPU; ) AppleWebKit/AppleWebKit   </div><div class="t m0 x0 h95 y155a ff50 fs6 fc0 sc0 ls21 wsb">     (KHTML, like Gecko) Safari/Safari  </div><div class="t m0 x5 hb y155b ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y12da ff4f fs2 fc0 sc0 ls8 ws1">以下就是一个示例： </div><div class="t m0 x5 hb ye0f ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y155c ff50 fs6 fc0 sc0 ls1b0 wsb">Mozilla/5.0 (Macintosh; U; PPC Mac OS X; en) AppleWebKit/124 (KHTML, like Gecko)  </div><div class="t m0 x0 hb y155d ff50 fs6 fc0 sc0 ls1b0 ws1c7">     Safari/125.1 </div><div class="t m0 x5 hb y155e ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y155f ff4f fs2 fc0 sc0 ls8 ws1">显然，这又是一个很长的用户代理字符串。其中不仅包含了Apple WebKit的版本号，也包含了Safari</div><div class="t m0 x0 h5 y1560 ff4f fs2 fc0 sc0 ls8 ws1">的版本号。出于兼容性的考虑，有关人员很快就决定了将Safari标识为Mozilla。至今，基于WebKi t的</div></div></div>
<div id="pff4" class="pf w0 h0" data-page-no="f4"><div class="pc pcf4 w0 h0"><div class="t m0 x0 h2 y1 ff48 fs0 fc0 sc0 ls7 ws0">226  第9章 客户端检测 </div><div class="t m0 x0 h3 y2 ff48 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff4f fs2 fc0 sc0 ls8 ws1">所有浏览器都将自己标识为Mozilla 5.0，与基于Gecko的浏览器完全一样。但Safari的版本号则通常是</div><div class="t m0 x0 h5 y4d ff4f fs2 fc0 sc0 ls8 ws1">浏览器的编译版本号，不一定与发布时的版本号对应。换句话说，虽然Safari 1.25的用户代理字符串中</div><div class="t m0 x0 h5 yd8 ff4f fs2 fc0 sc0 ls8 ws1">包含数字125.1，但两者却不一一对应。 </div><div class="t m0 x0 h5 y28b ff48 fs2 fc0 sc0 ls48 ws39">Safari预发行1.0 版用户代理字符串中最耐人寻味，也是最饱受诟病的部分就是字符串&quot;(KHTML, </div><div class="t m0 x0 h21 y1169 ff50 fs1 fc0 sc0 ls9 wsb">like Gecko)&quot;。Apple因此收到许多开发人员的反馈，他们认为这个字符串明显是在欺骗客户端和服</div><div class="t m0 x0 hc y21a ff4f fs2 fc0 sc0 ls8 ws1">务器，实际上是想让它们把Safari当成Gecko（好像光添加Mozilla/5.0 还嫌不够）。Apple的回应与</div><div class="t m0 x0 h5 y15e ff4f fs2 fc0 sc0 ls8 ws1">微软在IE的用户代理字符串遭到责难时如出一辙：Safari与Mozilla兼容，因此网站不应该将 Safari用</div><div class="t m0 x0 h5 y1561 ff4f fs2 fc0 sc0 ls8 ws1">户拒之门外，否则用户就会认为自己的浏览器不受支持。 </div><div class="t m0 x0 h5 y1562 ff4f fs2 fc0 sc0 ls8 ws1">到了Safari 3.0发布时，其用户代理字符串又稍微变长了一点。下面这个新增的Version 记号一直到</div><div class="t m0 x0 h5 y1563 ff4f fs2 fc0 sc0 ls8 ws1">现在都被用来标识Safari实际的版本号： </div><div class="t m0 x0 hb yeb5 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1564 ff50 fs6 fc0 sc0 ls21 wsb">Mozilla/5.0 (Macintosh; U; PPC Mac OS X; en) AppleWebKit/522.15.5 (KHTML, like  </div><div class="t m0 x0 hb y1565 ff50 fs6 fc0 sc0 ls21 wsb">     Gecko) Version/3.0.3 Safari/522.15.5 </div><div class="t m0 x0 hb y1566 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y165 ff4f fs2 fc0 sc0 ls5 ws4">需要注意的是，这个变化只在Safari中有，在WebKit 中没有。换句话说，其他基于WebKit的浏</div><div class="t m0 x0 h5 y1567 ff4f fs2 fc0 sc0 ls5 ws4">览器可能没有这个变化。一般来说，确定浏览器是否基于WebKit要比确定它是不是Safari更有价值，</div><div class="t m0 x0 h5 y1568 ff4f fs2 fc0 sc0 ls8 ws1">就像针对Gecko一样。 </div><div class="t m0 x0 h2f y1569 ff4d fs2 fc0 sc0 ls94 ws1a2">6. Konqueror </div><div class="t m0 x0 h5 y156a ff4f fs2 fc0 sc0 ls21b">与KDE Linux集成的Konqueror，是一款基于KHTML开源呈现引擎的浏览器。尽管Konqueror 只</div><div class="t m0 x0 h5 y156b ff4f fs2 fc0 sc0 ls8 ws1">能在Linux中使用，但它也有数量可观的用户。为确保最大限度的兼容性，Konqueror效仿IE选择了如</div><div class="t m0 x0 h5 y156c ff4f fs2 fc0 sc0 ls8 ws1">下用户代理字符串格式： </div><div class="t m0 x0 hb y156d ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y156e ff50 fs6 fc0 sc0 ls21 wsb">Mozilla/5.0 (compatible; Konqueror/ 版本号; 操作系统或CPU ) </div><div class="t m0 x0 hb y156f ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1570 ff4f fs2 fc0 sc0 ls8 ws1">不过，为了与WebKit的用户代理字符串的变化保持一致，Konqueror 3.2又有了变化，以如下格式</div><div class="t m0 x0 h5 y1571 ff4f fs2 fc0 sc0 ls8 ws1">将自己标识为KHTML： </div><div class="t m0 x0 hb y1572 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1573 ff50 fs6 fc0 sc0 ls21 ws1cc">Mozilla/5.0 (compatible; Konqueror/ 版本号; 操作系统或CPU) KHTML/ KHTML版本号 (like Gecko) </div><div class="t m0 x0 hb y1574 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1575 ff4f fs2 fc0 sc0 ls8 ws1">下面是一个例子： </div><div class="t m0 x0 hb y1576 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1577 ff50 fs6 fc0 sc0 ls21 wsb">Mozilla/5.0 (compatible; Konqueror/3.5; SunOS) KHTML/3.5.0 (like Gecko) </div><div class="t m0 x0 hb y1578 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1579 ff4f fs2 fc0 sc0 ls8 ws1">其中，Konqueror与KHTML的版本号比较一致，即使有差别也很小，例如Konqueror 3.5使用KHTML </div><div class="t m0 x0 h5 y157a ff48 fs2 fc0 sc0 lsd2 ws19b">3.5.1。 </div><div class="t m0 x0 h2f y157b ff4d fs2 fc0 sc0 ls96 ws7d">7. Chrome </div><div class="t m0 x0 h5 y157c ff4f fs2 fc0 sc0 ls8 ws1">谷歌公司的Chrome浏览器以WebKit作为呈现引擎，但使用了不同的JavaScript引擎。在Chrome 0.2</div><div class="t m0 x0 h5 y157d ff4f fs2 fc0 sc0 ls8 ws1">这个最初的 beta版中，用户代理字符串完全取自WebKit，只添加了一段表示Chrome版本号的信息，格</div><div class="t m0 x0 h5 y157e ff4f fs2 fc0 sc0 ls8">式如下： </div><div class="t m0 x0 hb y14da ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y157f ff50 fs6 fc0 sc0 ls21 wsb">Mozilla/5.0 ( 平台; 加密类型; 操作系统或CPU; 语言) AppleWebKit/AppleWebKit版本号 (KHTML,  </div><div class="t m0 x0 h16 y1580 ff50 fs6 fc0 sc0 ls21 wsb">     like Gecko) Chrome/ Chrome版本号 Safari/ Safari版本 </div><div class="t m0 x0 hb y1581 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1582 ff48 fs2 fc0 sc0 lsf ws1cf">Chrome 7的完整的用户代理字符串如下： </div><div class="t m0 x0 hb y1583 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1584 ff50 fs6 fc0 sc0 ls21 wsb">Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/534.7 (KHTML,  </div><div class="t m0 x0 hb y1585 ff50 fs6 fc0 sc0 ls21 wsb">     like Gecko) Chrome/7.0.517.44 Safari/534.7 </div><div class="t m0 x0 hb y1586 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1587 ff4f fs2 fc0 sc0 ls8">其中，WebKit版本与Safari版本看起来似乎始终会保持一致，尽管没有十分的把握。 </div></div></div>
<div id="pff5" class="pf w0 h0" data-page-no="f5"><div class="pc pcf5 w0 h0"><div class="t m0 x2 h2 y1 ff48 fs0 fc0 sc0 ls10 wsc">9.3 用户代理检测    227 </div><div class="t m0 x0 h3 y2 ff48 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff4a fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff4a fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff4a fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff4a fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff4a fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff4a fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff4a fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff4a fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff4a fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff4a fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff4a fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff4a fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff4a fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h2f y1588 ff4d fs2 fc0 sc0 ls47 ws1d0">8. Opera </div><div class="t m0 x0 h5 y1589 ff4f fs2 fc0 sc0 ls6 ws6">仅就用户代理字符串而言，Opera应该是最有争议的一款浏览器了。Opera默认的用户代理字符串</div><div class="t m0 x0 h5 y158a ff4f fs2 fc0 sc0 ls8 ws1">是所有现代浏览器中最合理的——正确地标识了自身及其版本号。在Opera 8.0之前，其用户代理字符</div><div class="t m0 x0 h5 y158b ff4f fs2 fc0 sc0 ls8 ws1">串采用如下格式： </div><div class="t m0 x5 hb y30a ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y158c ff50 fs6 fc0 sc0 ls21 wsb">Opera/ 版本号 (操作系统或CPU; 加密类型) [语言] </div><div class="t m0 x5 hb y158d ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y158e ff48 fs2 fc0 sc0 lsc7 ws141">Windows XP中的Opera 7.54会显示下面的用户代理字符串： </div><div class="t m0 x5 hb y158f ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1590 ff50 fs6 fc0 sc0 ls21 wsb">Opera/7.54 (Windows NT 5.1; U) [en] </div><div class="t m0 x5 hb y1591 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y332 ff48 fs2 fc0 sc0 ls5e ws1c8">Opera 8发布后，用户代理字符串的“语言”部分被移到圆括号内，以便更好地与其他浏览器匹配，</div><div class="t m0 x0 h5 y1592 ff4f fs2 fc0 sc0 ls8 ws1">如下所示： </div><div class="t m0 x5 hb y1593 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1594 ff50 fs6 fc0 sc0 ls21 wsb">Opera/ 版本号 (操作系统或CPU; 加密类型; 语言) </div><div class="t m0 x5 hb y1595 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y10f9 ff48 fs2 fc0 sc0 lsc7 ws141">Windows XP中的Opera 8会显示下面的用户代理字符串： </div><div class="t m0 x5 hb y1596 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1597 ff50 fs6 fc0 sc0 ls21 wsb">Opera/8.0 (Windows NT 5.1; U; en) </div><div class="t m0 x5 hb y1598 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1599 ff4f fs2 fc0 sc0 ls8 ws1">默认情况下，Opera会以上面这种简单的格式返回一个用户代理字符串。目前来看，Opera也是主</div><div class="t m0 x0 h4 y159a ff4f fs2 fc0 sc0 ls8 ws1">要浏览器中唯一一个使用产品名和版本号来完全彻底地标识自身的浏览器。可是，与其他浏览器一样，</div><div class="t m0 x0 h5 y159b ff48 fs2 fc0 sc0 ls2b ws22">Opera在使用自己的用户代理字符串时也遇到了问题。即使技术上正确，但因特网上仍然有不少浏览器</div><div class="t m0 x0 h5 y159c ff4f fs2 fc0 sc0 ls8 ws1">嗅探代码，只钟情于报告Mozilla产品名的那些用户代理字符串。另外还有相当数量的代码则只对IE或</div><div class="t m0 x0 h5 y159d ff48 fs2 fc0 sc0 ls81 ws76">Gecko感兴趣。Opera没有选择通过修改自身的用户代理字符串来迷惑嗅探代码，而是干脆选择通过修</div><div class="t m0 x0 h5 y159e ff4f fs2 fc0 sc0 ls8 ws1">改自身的用户代理字符串将自身标识为一个完全不同的浏览器。 </div><div class="t m0 x0 h5 y159f ff48 fs2 fc0 sc0 ls5e ws1c8">Opera 9以后，出现了两种修改用户代理字符串的方式。一种方式是将自身标识为另外一个浏览器，</div><div class="t m0 x0 h5 y15a0 ff4f fs2 fc0 sc0 ls21d">如Firefox或者IE。在这种方式下，用户代理字符串就如同Firefox或IE 的用户代理字符串一样，只不</div><div class="t m0 x0 h96 y15a1 ff4f fs2 fc0 sc0 ls8 ws1">过末尾追加了字符串Opera及Opera的版本号。下面是一个例子： </div><div class="t m0 x5 hb y15a2 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y15a3 ff50 fs6 fc0 sc0 ls21 ws1d2">Mozilla/5.0 (Windows NT 5.1; U; en; rv:1.8.1) Gecko/20061208 Firefox/2.0.0 Opera 9.50 </div><div class="t m0 x0 hb y15a4 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y15a5 ff50 fs6 fc0 sc0 ls21 wsb">Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; en) Opera 9.50 </div><div class="t m0 x5 hb y15a6 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y835 ff4f fs2 fc0 sc0 ls8 ws1">第一个字符串将Opera 9.5标识为Firefox 2，同时带有Opera版本信息。第二个字符串将 Opera 9.5</div><div class="t m0 x0 h5 y15a7 ff4f fs2 fc0 sc0 ls8 ws1">标识为IE6，也包含了Opera版本信息。这两个用户代理字符串可以通过针对Firefox 或IE的大多数测</div><div class="t m0 x0 h5 y15a8 ff4f fs2 fc0 sc0 ls8 ws1">试，不过还是为识别Opera留下了余地。 </div><div class="t m0 x0 h5 y15a9 ff48 fs2 fc0 sc0 ls2b ws22">Opera标识自身的另一种方式，就是把自己装扮成Firefox或IE。在这种隐瞒真实身份的情况下，用</div><div class="t m0 x0 h14 y15aa ff4f fs2 fc0 sc0 ls8 ws1">户代理字符串实际上与其他浏览器返回的相同——既没有Opera字样，也不包含Opera 版本信息。换</div><div class="t m0 x0 h5 y15ab ff4f fs2 fc0 sc0 ls8 ws1">句话说，在启用了身份隐瞒功能的情况下，无法将Opera和其他浏览器区别开来。另外，由于Opera喜</div><div class="t m0 x0 h5 y15ac ff4f fs2 fc0 sc0 ls30 ws2a">欢在不告知用户的情况下针对站点来设置用户代理字符串，因此问题就更复杂化了。例如，打开My </div><div class="t m0 x0 h5 y15ad ff48 fs2 fc0 sc0 ls8 ws20">Yahoo!站点（http://my.yahoo.com）会自动导致Opera将自己装扮成Firefox。如此一来，要想识别Opera</div><div class="t m0 x0 h5 y15ae ff4f fs2 fc0 sc0 ls8 ws1">就难上加难了。 </div><div class="t m0 x5 h5 y15af ff49 fs2 fc0 sc0 ls3b">在Opera 7以前的版本中，Opera会解析Windows操作系统字符串的含义。例如，</div><div class="t m0 x5 h5 y15b0 ff48 fs2 fc0 sc0 ls5e ws106">Windows NT 5.1实际上就是Windows XP，因此Opera 会在用户代理字符串中包含</div><div class="t m0 x5 h5 y15b1 ff48 fs2 fc0 sc0 lsc7 ws159">Windows XP而非Windows NT 5.1。为了与其他浏览器更兼容，Opera 7开始包含正式</div><div class="t m0 x5 h5 y15b2 ff49 fs2 fc0 sc0 ls8 ws14">的操作系统版本，而非解析后的版本。 </div></div></div>
<div id="pff6" class="pf w0 h0" data-page-no="f6"><div class="pc pcf6 w0 h0"><div class="t m0 x0 h2 y1 ff48 fs0 fc0 sc0 ls7 ws0">228  第9章 客户端检测 </div><div class="t m0 x0 h3 y2 ff48 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff48 fs2 fc0 sc0 ls5e ws71">Opera 10对代理字符串进行了修改。现在的格式是： </div><div class="t m0 x0 hb yfb2 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 yfb3 ff50 fs6 fc0 sc0 ls21 wsb">Opera/9.80 (操作系统或CPU; 加密类型; 语言) Presto/Presto版本号 Version/版本号 </div><div class="t m0 x0 hb y1510 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1511 ff4f fs2 fc0 sc0 ls8 ws1">注意，初始的版本号Opera/9.80是固定不变的。实际并没有Opera 9.8，但工程师们担心写得不好的</div><div class="t m0 x0 h5 y1512 ff4f fs2 fc0 sc0 ls8 ws1">浏览器嗅探脚本会将Opera/10.0错误的解释为Opera 1，而不是Opera 10。因此，Opera 10又增加了Presto</div><div class="t m0 x0 h5 y15b3 ff4f fs2 fc0 sc0 ls8 ws1">记号（Presto是Opera的呈现引擎）和Version 记号，后者用以保存实际的版本号。以下是Windows7中</div><div class="t m0 x0 h5 y15b4 ff48 fs2 fc0 sc0 ls1b wsa5">Opera 10.63的用户代理字符串： </div><div class="t m0 x0 hb y619 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y15b5 ff50 fs6 fc0 sc0 ls21 wsb">Opera/9.80 (Windows NT 6.1; U; en) Presto/2.6.30 Version/10.63 </div><div class="t m0 x0 hb y15b6 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h3c y15b7 ff4d fs2 fc0 sc0 ls79 ws7e">9. iOS和Android </div><div class="t m0 x0 h5 y15b8 ff4f fs2 fc0 sc0 ls8 ws1">移动操作系统iOS和Android默认的浏览器都基于WebKit，而且都像它们的桌面版一样，共享相同</div><div class="t m0 x0 h5 y15b9 ff4f fs2 fc0 sc0 ls8 ws1">的基本用户代理字符串格式。iOS设备的基本格式如下： </div><div class="t m0 x0 hb y15ba ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y15bb ff50 fs6 fc0 sc0 ls21 wsb">Mozilla/5.0 (;  ;  CPU like Mac OS X; ) </div><div class="t m0 x0 hb y15bc ff50 fs6 fc0 sc0 ls21 wsb">AppleWebKit/AppleWebKit (KHTML, like Gecko) Version/  </div><div class="t m0 x0 hb y15bd ff50 fs6 fc0 sc0 ls21 wsb">Mobile/  Safari/Safari </div><div class="t m0 x0 hb y15be ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y15bf ff4f fs2 fc0 sc0 ls8 ws1">注意用于辅助确定Mac操作系统的&quot;like Mac OS X&quot;和额外的 Mobile记号。一般来说，Mobile</div><div class="t m0 x0 h5 y15c0 ff4f fs2 fc0 sc0 ls8 ws1">记号的版本号（移动版本号）没什么用，主要是用来确定WebKit是移动版，而非桌面版。而平台则可</div><div class="t m0 x0 he y15c1 ff4f fs2 fc0 sc0 ls8 ws1">能是&quot;iPhone&quot;、&quot;iPod&quot;或&quot;iPad&quot;。例如： </div><div class="t m0 x0 hb y15c2 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y15c3 ff50 fs6 fc0 sc0 ls21 wsb">Mozilla/5.0 (iPhone; U; CPU iPhone OS 3_0 like Mac OS X; en-us) </div><div class="t m0 x0 hb y15c4 ff50 fs6 fc0 sc0 ls21 wsb">AppleWebKit/528.18 (KHTML, like Gecko) Version/4.0 Mobile/7A341 Safari/528.16 </div><div class="t m0 x0 hb y15c5 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y15c6 ff4f fs2 fc0 sc0 ls3b">在iOS 3之前，用户代理字符串中不会出现操作系统版本号。 </div><div class="t m0 x0 h5 y15c7 ff48 fs2 fc0 sc0 ls79 ws6c">Android浏览器中的默认格式与iOS的格式相似，没有移动版本号（但有Mobile记号）。例如： </div><div class="t m0 x0 hb y15c8 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y15c9 ff50 fs6 fc0 sc0 ls21 wsb">Mozilla/5.0 (Linux; U; Android 2.2; en-us; Nexus One Build/FRF91) </div><div class="t m0 x0 hb y15ca ff50 fs6 fc0 sc0 ls21 wsb">AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1 </div><div class="t m0 x0 hb y15cb ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y15cc ff4f fs2 fc0 sc0 ls8 ws1">这是Google Nexus One手机的用户代理字符串。不过，其他Android设备的模式也一样。 </div><div class="t m0 x0 h20 y15cd ff4d fs3 fc0 sc0 ls4d ws40">9.3.2 用户代理字符串检测技术 </div><div class="t m0 x0 h4 y15ce ff4f fs2 fc0 sc0 ls8 ws1">考虑到历史原因以及现代浏览器中用户代理字符串的使用方式，通过用户代理字符串来检测特定的</div><div class="t m0 x0 h4 y15cf ff4f fs2 fc0 sc0 ls8 ws1">浏览器并不是一件轻松的事。因此，首先要确定的往往是你需要多么具体的浏览器信息。一般情况下，</div><div class="t m0 x0 h5 y15d0 ff4f fs2 fc0 sc0 ls8 ws1">知道呈现引擎和最低限度的版本就足以决定正确的操作方法了。例如，我们不推荐使用下列代码： </div><div class="t m0 x0 hb y15d1 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y15d2 ff50 fs6 fc0 sc0 ls21 wsb">if (isIE6 || isIE7) { //不推荐!!! </div><div class="t m0 x0 h16 y15d3 ff50 fs6 fc0 sc0 ls21 wsb">    //代码 </div><div class="t m0 x0 hb y15d4 ff50 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h5 y15d5 ff4f fs2 fc0 sc0 ls8 ws1">这个例子是想要在浏览器为IE6或IE7时执行相应代码。这种代码其实是很脆弱的，因为它要依据</div><div class="t m0 x0 h5 y15d6 ff4f fs2 fc0 sc0 ls8 ws1">特定的版本来决定做什么。如果是IE8怎么办呢？只要IE有新版本出来，就必须更新这些代码。不过，</div><div class="t m0 x0 h5 y15d7 ff4f fs2 fc0 sc0 ls8 ws1">像下面这样使用相对版本号则可以避免此问题： </div><div class="t m0 x0 hb y736 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y15d8 ff50 fs6 fc0 sc0 ls21 wsb">if (ieVer &gt;=6){ </div><div class="t m0 x0 h16 y15d9 ff50 fs6 fc0 sc0 ls21 wsb">    //代码 </div><div class="t m0 x0 hb y15da ff50 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h5 y15db ff4f fs2 fc0 sc0 ls8 ws1">这个例子首先检测IE的版本号是否至少等于6，如果是则执行相应操作。这样就可以确保相应的代</div><div class="t m0 x0 h5 yb6f ff4f fs2 fc0 sc0 ls8 ws1">码将来照样能够起作用。我们下面的浏览器检测脚本就将本着这种思路来编写。 </div></div></div>
<div id="pff7" class="pf w0 h0" data-page-no="f7"><div class="pc pcf7 w0 h0"><div class="t m0 x2 h2 y1 ff48 fs0 fc0 sc0 ls10 wsc">9.3 用户代理检测    229 </div><div class="t m0 x0 h3 y2 ff48 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff4a fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff4a fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff4a fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff4a fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff4a fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff4a fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff4a fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff4a fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff4a fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff4a fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff4a fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff4a fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff4a fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h3c y68b ff4d fs2 fc0 sc0 ls2e wsb">1. 识别呈现引擎 </div><div class="t m0 x0 h5 y68c ff4f fs2 fc0 sc0 ls8 ws1">如前所述，确切知道浏览器的名字和版本号不如确切知道它使用的是什么呈现引擎。如果Firefox、</div><div class="t m0 x0 h5 y15dc ff48 fs2 fc0 sc0 ls201 ws1d7">Camino和Netscape都使用相同版本的Gecko，那它们一定支持相同的特性。类似地，不管是什么浏览</div><div class="t m0 x0 h5 y15dd ff4f fs2 fc0 sc0 ls8 ws1">器，只要它跟Safari 3使用的是同一个版本的WebKit，那么该浏览器也就跟 Safari 3具备同样的功能。</div><div class="t m0 x0 h5 y15de ff4f fs2 fc0 sc0 ls8 ws1">因此，我们要编写的脚本将主要检测五大呈现引擎：IE、Gecko、WebKit、KHTML和Opera。 </div><div class="t m0 x0 h4 y15df ff4f fs2 fc0 sc0 ls8 ws1">为了不在全局作用域中添加多余的变量，我们将使用模块增强模式来封装检测脚本。检测脚本的基</div><div class="t m0 x0 h5 y15e0 ff4f fs2 fc0 sc0 ls8 ws1">本代码结构如下所示： </div><div class="t m0 x5 hb yd44 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yd45 ff50 fs6 fc0 sc0 ls21 wsb">var client = function(){ </div><div class="t m0 x0 hb yd46 ff50 fs6 fc0 sc0 ls21 wsb">  </div><div class="t m0 x0 hb yd47 ff50 fs6 fc0 sc0 ls21 wsb">    var engine = {             </div><div class="t m0 x0 hb yd48 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 yd49 ff50 fs6 fc0 sc0 ls21 wsb">    //呈现引擎 </div><div class="t m0 x0 hb yd4a ff50 fs6 fc0 sc0 ls21 wsb">        ie: 0, </div><div class="t m0 x0 hb yd4b ff50 fs6 fc0 sc0 ls21 wsb">        gecko: 0, </div><div class="t m0 x0 hb yd4c ff50 fs6 fc0 sc0 ls21 wsb">        webkit: 0, </div><div class="t m0 x0 hb yd4d ff50 fs6 fc0 sc0 ls21 wsb">        khtml: 0, </div><div class="t m0 x0 hb yd4e ff50 fs6 fc0 sc0 ls21 wsb">        opera: 0, </div><div class="t m0 x0 hb y15e1 ff50 fs6 fc0 sc0 ls21 wsb">  </div><div class="t m0 x0 h16 y15e2 ff50 fs6 fc0 sc0 ls21 wsb">        //具体的版本号 </div><div class="t m0 x0 hb y15e3 ff50 fs6 fc0 sc0 ls21 wsb">        ver: null   </div><div class="t m0 x0 hb y15e4 ff50 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 hb y15e5 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y15e6 ff50 fs6 fc0 sc0 ls21 wsb">    //在此检测呈现引擎、平台和设备 </div><div class="t m0 x0 hb y15e7 ff50 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 hb y15e8 ff50 fs6 fc0 sc0 ls21 wsb">    return { </div><div class="t m0 x0 hb y15e9 ff50 fs6 fc0 sc0 ls21 wsb">        engine : engine </div><div class="t m0 x0 hb y15ea ff50 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 hb y15eb ff50 fs6 fc0 sc0 ls21 wsb">}();  </div><div class="t m0 x0 h4 y15ec ff4f fs2 fc0 sc0 ls8 ws1">这里声明了一个名为client的全局变量，用于保存相关信息。匿名函数内部定义了一个局部变量</div><div class="t m0 x0 h4 y15ed ff50 fs1 fc0 sc0 ls9 ws2">engine，它是一个包含默认设置的对象字面量。在这个对象字面量中，每个呈现引擎都对应着一个属</div><div class="t m0 x0 h5 y15ee ff4f fs2 fc0 sc0 ls8 ws1">性，属性的值默认为0。如果检测到了哪个呈现引擎，那么就以浮点数值形式将该引擎的版本号写入相</div><div class="t m0 x0 h1c y15ef ff4f fs2 fc0 sc0 ls8 ws1">应的属性。而呈现引擎的完整版本（是一个字符串），则被写入ver属性。作这样的区分可以支持像下</div><div class="t m0 x0 h5 y15f0 ff4f fs2 fc0 sc0 ls8 ws1">面这样编写代码： </div><div class="t m0 x5 hb y15f1 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y15f2 ff50 fs6 fc0 sc0 ls21 wsb">if (client.engine.ie) { //如果是IE，client.ie的值应该大于0 </div><div class="t m0 x0 h16 y15f3 ff50 fs6 fc0 sc0 ls21 wsb">    //针对IE的代码 </div><div class="t m0 x0 hb y15f4 ff50 fs6 fc0 sc0 ls21 wsb">} else if (client.engine.gecko &gt; 1.5){ </div><div class="t m0 x0 hb y15f5 ff50 fs6 fc0 sc0 ls21 wsb">    if (client.engine.ver == &quot;1.8.1&quot;){ </div><div class="t m0 x0 h16 y15f6 ff50 fs6 fc0 sc0 ls21 wsb">        //针对这个版本执行某些操作 </div><div class="t m0 x0 hb y15f7 ff50 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y15f8 ff50 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h5 y11a7 ff4f fs2 fc0 sc0 ls8 ws1">在检测到一个呈现引擎之后，其client.engine中对应的属性将被设置为一个大于0的值，该值</div><div class="t m0 x0 h1e y11a8 ff4f fs2 fc0 sc0 ls8 ws1">可以转换成布尔值true。这样，就可以在if语句中检测相应的属性，以确定当前使用的呈现引擎，连</div><div class="t m0 x0 h4 y15f9 ff4f fs2 fc0 sc0 ls8 ws1">具体的版本号都不必考虑。鉴于每个属性都包含一个浮点数值，因此有可能丢失某些版本信息。例如，</div><div class="t m0 x0 hc y11aa ff4f fs2 fc0 sc0 ls8 ws1">将字符串&quot;1.8.1&quot;传入parseFloat()后会得到数值1.8。不过，在必要的时候可以检测ver属性，该</div><div class="t m0 x0 h5 y11f6 ff4f fs2 fc0 sc0 ls8 ws1">属性中会保存完整的版本信息。 </div><div class="t m0 x0 h4 y15fa ff4f fs2 fc0 sc0 ls8 ws1">要正确地识别呈现引擎，关键是检测顺序要正确。由于用户代理字符串存在诸多不一致的地方，如</div><div class="t m0 x0 h5 y15fb ff4f fs2 fc0 sc0 ls8 ws1">果检测顺序不对，很可能会导致检测结果不正确。为此，第一步就是识别Opera，因为它的用户代理字</div></div></div>
<div id="pff8" class="pf w0 h0" data-page-no="f8"><div class="pc pcf8 w0 h0"><div class="t m0 x0 h2 y1 ff48 fs0 fc0 sc0 ls7 ws0">230  第9章 客户端检测 </div><div class="t m0 x0 h3 y2 ff48 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff4f fs2 fc0 sc0 ls8 ws1">符串有可能完全模仿其他浏览器。我们不相信Opera，是因为（任何情况下）其用户代理字符串（都）</div><div class="t m0 x0 h5 y4d ff4f fs2 fc0 sc0 ls8 ws1">不会将自己标识为Opera。 </div><div class="t m0 x0 he yd8 ff4f fs2 fc0 sc0 ls8 ws1">要识别Opera，必须得检测window.opera对象。Opera 5及更高版本中都有这个对象，用以保存</div><div class="t m0 x0 h5 yd9 ff4f fs2 fc0 sc0 ls8 ws1">与浏览器相关的标识信息以及与浏览器直接交互。在Opera 7.6及更高版本中，调用version()方法可</div><div class="t m0 x0 h5 y15d ff4f fs2 fc0 sc0 ls8 ws1">以返回一个表示浏览器版本的字符串，而这也是确定Opera版本号的最佳方式。要检测更早版本的Opera，</div><div class="t m0 x0 h5 y2b3 ff4f fs2 fc0 sc0 ls8 ws1">可以直接检查用户代理字符串，因为那些版本还不支持隐瞒身份。不过，2007底Opera的最高版本已经</div><div class="t m0 x0 h5 y765 ff4f fs2 fc0 sc0 ls6e">是9.5了，所以不太可能有人还在使用7.6之前的版本。那么，检测呈现引擎代码的第一步，就是编写</div><div class="t m0 x0 h5 y15fc ff4f fs2 fc0 sc0 ls8 ws1">如下代码： </div><div class="t m0 x0 hb y766 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y767 ff50 fs6 fc0 sc0 ls21 wsb">if (window.opera){ </div><div class="t m0 x0 hb y768 ff50 fs6 fc0 sc0 ls21 wsb">    engine.ver = window.opera.version(); </div><div class="t m0 x0 hb y769 ff50 fs6 fc0 sc0 ls21 wsb">    engine.opera = parseFloat(engine.ver); </div><div class="t m0 x0 hb y76a ff50 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h4 y15fd ff4f fs2 fc0 sc0 ls221 ws1d9">这里，将版本的字符串表示保存在了engine.ver中，将浮点数值表示的版本保存在了</div><div class="t m0 x0 h5 y15fe ff50 fs1 fc0 sc0 ls9 ws2">engine.opera中。如果浏览器是Opera，测试window.opera就会返回 true；否则，就要看看是其</div><div class="t m0 x0 h5 y15ff ff4f fs2 fc0 sc0 ls8 ws1">他的什么浏览器了。 </div><div class="t m0 x0 h5 y1600 ff4f fs2 fc0 sc0 ls55 ws49">应该放在第二位检测的呈现引擎是WebKit。因为 WebKit的用户代理字符串中包含&quot;Gecko&quot;和</div><div class="t m0 x0 h5 y1601 ff50 fs1 fc0 sc0 ls9 ws2">&quot;KHTML&quot;这两个子字符串，所以如果首先检测它们，很可能会得出错误的结论。 </div><div class="t m0 x0 h5 y1602 ff4f fs2 fc0 sc0 ls8 ws1">不过，WebKit的用户代理字符串中的&quot;AppleWebKit&quot;是独一无二的，因此检测这个字符串最合适。</div><div class="t m0 x0 h5 y1603 ff4f fs2 fc0 sc0 ls8 ws1">下面就是检测该字符串的示例代码： </div><div class="t m0 x0 hb y1604 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y1605 ff54 fs6 fc0 sc0 ls21 wsb">var ua = navigator.userAgent; </div><div class="t m0 x0 hb y1606 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1607 ff50 fs6 fc0 sc0 ls21 wsb">if (window.opera){ </div><div class="t m0 x0 hb y1608 ff50 fs6 fc0 sc0 ls21 wsb">    engine.ver = window.opera.version(); </div><div class="t m0 x0 hb y1609 ff50 fs6 fc0 sc0 ls21 wsb">    engine.opera = parseFloat(engine.ver);  </div><div class="t m0 x0 h15 y160a ff54 fs6 fc0 sc0 ls21 wsb">} else if (/AppleWebKit\/(\S+)/.test(ua)){ </div><div class="t m0 x0 h15 y160b ff54 fs6 fc0 sc0 ls21 wsb">    engine.ver = RegExp[&quot;$1&quot;]; </div><div class="t m0 x0 h15 y160c ff54 fs6 fc0 sc0 ls21 wsb">    engine.webkit = parseFloat(engine.ver);  </div><div class="t m0 x0 h15 y160d ff54 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h4 y160e ff4f fs2 fc0 sc0 ls5 ws4">代码首先将用户代理字符串保存在变量ua中。然后通过正则表达式来测试其中是否包含字符串</div><div class="t m0 x0 h4 y160f ff50 fs1 fc0 sc0 ls9 ws2">&quot;AppleWebKit&quot;，并使用捕获组来取得版本号。由于实际的版本号中可能会包含数字、小数点和字母，</div><div class="t m0 x0 h1e y1610 ff4f fs2 fc0 sc0 ls6 ws6">所以捕获组中使用了表示非空格的特殊字符（\S）。用户代理字符串中的版本号与下一部分的分隔符是</div><div class="t m0 x0 h4 y1611 ff4f fs2 fc0 sc0 ls5 ws4">一个空格，因此这个模式可以保证捕获所有版本信息。test()方法基于用户代理字符串运行正则表达</div><div class="t m0 x0 h1e y1612 ff4f fs2 fc0 sc0 ls19 ws1b">式。如果返回true，就将捕获的版本号保存在engine.ver 中，而将版本号的浮点表示保存在</div><div class="t m0 x0 h5 y1613 ff50 fs1 fc0 sc0 ls9 ws2">engine.webkit中。WebKit版本与Safari版本的详细对应情况如下表所示。 </div><div class="t m0 x0 hb y1614 ff50 fs6 fc0 sc0 ls8 wsb">  </div><div class="t m0 x0 h31 y1615 ff4d fs6 fc0 sc0 ls225 ws1da">Safari版本号 最低限度的WebKit版本号 Safari版本号 最低限度的WebKit版本号 </div><div class="t m0 x0 h97 y1616 ff48 fs6 fc0 sc0 lsa1 ws82">1.0至1.0.2  85.7 1.3 312.1 </div><div class="t m0 x0 h36 y1617 ff48 fs6 fc0 sc0 lsa1 ws1de">1.0.3 85.8.2 1.3.1 312.5 </div><div class="t m0 x0 h97 y1618 ff48 fs6 fc0 sc0 lsa1 ws82">1.1至1.1.1  100 1.3.2 312.8 </div><div class="t m0 x0 h36 y1619 ff48 fs6 fc0 sc0 lsa1 ws1de">1.2.2 125.2 2.0 412 </div><div class="t m0 x0 h36 y13d3 ff48 fs6 fc0 sc0 lsa1 ws1de">1.2.3 125.4 2.0.1 412.7 </div><div class="t m0 x0 h36 y41d ff48 fs6 fc0 sc0 lsa1 ws1de">1.2.4 125.5.5 2.0.2 416.11 </div></div></div>
<div id="pff9" class="pf w0 h0" data-page-no="f9"><div class="pc pcf9 w0 h0"><div class="t m0 x2 h2 y1 ff48 fs0 fc0 sc0 ls10 wsc">9.3 用户代理检测    231 </div><div class="t m0 x0 h3 y2 ff48 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff4a fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff4a fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff4a fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff4a fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff4a fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff4a fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff4a fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff4a fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff4a fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff4a fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff4a fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff4a fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff4a fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x6 h3 y34f ff4f fs1 fc0 sc0 ls8">（续） </div><div class="t m0 x5 h31 y350 ff4d fs6 fc0 sc0 ls225 ws1da">Safari版本号 最低限度的WebKit版本号 Safari版本号 最低限度的WebKit版本号 </div><div class="t m0 x5 h36 y161a ff48 fs6 fc0 sc0 lsa1 ws1e0">2.0.3 417.9 3.0.4 523.10 </div><div class="t m0 x5 h36 y161b ff48 fs6 fc0 sc0 lsa1 ws1e0">2.0.4 418.8 3.1  525 </div><div class="t m0 x5 hb y161c ff50 fs6 fc0 sc0 ls8 wsb">  </div><div class="t m0 x5 h5 y161d ff49 fs2 fc0 sc0 ls8 ws14">有时候，Safari版本并不会与WebKit版本严格地一一对应，也可能会存在某些小</div><div class="t m0 x5 h5 y161e ff49 fs2 fc0 sc0 ls8 ws14">版本上的差异。这个表中只是列出了最可能的WebKit版本，但不保证精确。 </div><div class="t m0 x0 h5 y161f ff4f fs2 fc0 sc0 ls8 ws1">接下来要测试的呈现引擎是KHTML。同样，KHTML的用户代理字符串中也包含&quot;Gecko&quot;，因此</div><div class="t m0 x0 h5 y1620 ff4f fs2 fc0 sc0 ls8 ws1">在排除KHTML之前，我们无法准确检测基于Gecko的浏览器。KHTML 的版本号与WebKit的版本号</div><div class="t m0 x0 h5 y1621 ff4f fs2 fc0 sc0 ls8 ws1">在用户代理字符串中的格式差不多，因此可以使用类似的正则表达式。此外，由于Konqueror 3.1及更</div><div class="t m0 x0 h5 y1622 ff4f fs2 fc0 sc0 ls8 ws1">早版本中不包含KHTML的版本，故而就要使用Konqueror的版本来代替。下面就是相应的检测代码。 </div><div class="t m0 x5 hb y1623 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1624 ff50 fs6 fc0 sc0 ls21 wsb">var ua = navigator.userAgent; </div><div class="t m0 x0 hb y1625 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1626 ff50 fs6 fc0 sc0 ls21 wsb">if (window.opera){ </div><div class="t m0 x0 hb y1627 ff50 fs6 fc0 sc0 ls21 wsb">    engine.ver = window.opera.version(); </div><div class="t m0 x0 hb y1628 ff50 fs6 fc0 sc0 ls21 wsb">    engine.opera = parseFloat(engine.ver);  </div><div class="t m0 x0 hb y1629 ff50 fs6 fc0 sc0 ls21 wsb">} else if (/AppleWebKit\/(\S+)/.test(ua)){ </div><div class="t m0 x0 hb y162a ff50 fs6 fc0 sc0 ls21 wsb">    engine.ver = RegExp[&quot;$1&quot;]; </div><div class="t m0 x0 hb y162b ff50 fs6 fc0 sc0 ls21 wsb">    engine.webkit = parseFloat(engine.ver); </div><div class="t m0 x0 h15 y162c ff54 fs6 fc0 sc0 ls21 wsb">} else if (/KHTML\/(\S+)/.test(ua) || /Konqueror\/([^;]+)/.test(ua)){ </div><div class="t m0 x0 h15 y162d ff54 fs6 fc0 sc0 ls21 wsb">    engine.ver = RegExp[&quot;$1&quot;]; </div><div class="t m0 x0 h15 y162e ff54 fs6 fc0 sc0 ls21 wsb">    engine.khtml = parseFloat(engine.ver); </div><div class="t m0 x0 h15 y162f ff54 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h5 y1630 ff4f fs2 fc0 sc0 ls8 ws1">与前面一样，由于KHTML的版本号与后继的标记之间有一个空格，因此仍然要使用特殊的非空格</div><div class="t m0 x0 h1e y1631 ff4f fs2 fc0 sc0 ls8 ws1">字符来取得与版本有关的所有字符。然后，将字符串形式的版本信息保存在engine.ver中，将浮点数</div><div class="t m0 x0 hc y410 ff4f fs2 fc0 sc0 ls8 ws1">值形式的版本保存在engin.khtml中。如果KHTML不在用户代理字符串中，那么就要匹配Konqueror</div><div class="t m0 x0 h5 y1632 ff4f fs2 fc0 sc0 ls8 ws1">后跟一个斜杠，再后跟不包含分号的所有字符。 </div><div class="t m0 x0 h5 y1633 ff4f fs2 fc0 sc0 ls8 ws1">在排除了WebKit和KHTML之后，就可以准确地检测Gecko了。但是，在用户代理字符串中，Gecko</div><div class="t m0 x0 h1c y1634 ff4f fs2 fc0 sc0 ls8 ws1">的版本号不会出现在字符串&quot;Gecko&quot;的后面，而是会出现在字符串&quot;rv:&quot;的后面。这样，我们就必须使</div><div class="t m0 x0 h5 y1635 ff4f fs2 fc0 sc0 ls8 ws1">用一个比前面复杂一些的正则表达式，如下所示。 </div><div class="t m0 x5 hb y1636 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1637 ff50 fs6 fc0 sc0 ls21 wsb">var ua = navigator.userAgent; </div><div class="t m0 x0 hb y1638 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1639 ff50 fs6 fc0 sc0 ls21 wsb">if (window.opera){ </div><div class="t m0 x0 hb y163a ff50 fs6 fc0 sc0 ls21 wsb">    engine.ver = window.opera.version(); </div><div class="t m0 x0 hb y163b ff50 fs6 fc0 sc0 ls21 wsb">    engine.opera = parseFloat(engine.ver);  </div><div class="t m0 x0 hb y163c ff50 fs6 fc0 sc0 ls21 wsb">} else if (/AppleWebKit\/(\S+)/.test(ua)){ </div><div class="t m0 x0 hb y163d ff50 fs6 fc0 sc0 ls21 wsb">    engine.ver = RegExp[&quot;$1&quot;]; </div><div class="t m0 x0 hb y163e ff50 fs6 fc0 sc0 ls21 wsb">    engine.webkit = parseFloat(engine.ver); </div><div class="t m0 x0 hb y163f ff50 fs6 fc0 sc0 ls21 wsb">} else if (/KHTML\/(\S+)/.test(ua)) { </div><div class="t m0 x0 hb y1640 ff50 fs6 fc0 sc0 ls21 wsb">    engine.ver = RegExp[&quot;$1&quot;]; </div><div class="t m0 x0 hb y1641 ff50 fs6 fc0 sc0 ls21 wsb">    engine.khtml = parseFloat(engine.ver);  </div><div class="t m0 x0 h15 y1642 ff54 fs6 fc0 sc0 ls21 wsb">} else if (/rv:([^\)]+)\) Gecko\/\d{8}/.test(ua)){     </div><div class="t m0 x0 h15 y1643 ff54 fs6 fc0 sc0 ls21 wsb">    engine.ver = RegExp[&quot;$1&quot;]; </div><div class="t m0 x0 h15 y1644 ff54 fs6 fc0 sc0 ls21 wsb">    engine.gecko = parseFloat(engine.ver);  </div><div class="t m0 x0 hb y1645 ff54 fs6 fc0 sc0 ls16f">}  </div></div></div>
<div id="pffa" class="pf w0 h0" data-page-no="fa"><div class="pc pcfa w0 h0"><div class="t m0 x0 h2 y1 ff48 fs0 fc0 sc0 ls7 ws0">232  第9章 客户端检测 </div><div class="t m0 x0 h3 y2 ff48 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff48 fs2 fc0 sc0 ls14d ws11a">Gecko的版本号位于字符串&quot;rv:&quot;与一个闭括号之间，因此为了提取出这个版本号，正则表达式要</div><div class="t m0 x0 hc y4d ff4f fs2 fc0 sc0 ls8 ws1">查找所有不是闭括号的字符，还要查找字符串&quot;Gecko/&quot;后跟8个数字。如果上述模式匹配，就提取出</div><div class="t m0 x0 h5 y5 ff4f fs2 fc0 sc0 ls8 ws1">版本号并将其保存在相应的属性中。Gecko版本号与Firefox版本号的对应关系如下表所示。 </div><div class="t m0 x0 hb y6bd ff50 fs6 fc0 sc0 ls8 wsb">  </div><div class="t m0 x0 h31 y1647 ff4d fs6 fc0 sc0 ls229 ws1e1">Firefox版本号 最低限度的Gecko版本号 Firefox版本号 最低限度的Gecko版本号 </div><div class="t m0 x5 h36 y1648 ff48 fs6 fc0 sc0 lsa1 ws1e5">1.0 1.7.5 3.5 1.9.1 </div><div class="t m0 x5 h36 y1649 ff48 fs6 fc0 sc0 lsa1 ws1e5">1.5 1.8.0 3.6 1.9.2 </div><div class="t m0 x5 h36 y164a ff48 fs6 fc0 sc0 lsa1 ws1e5">2.0 1.8.1 4.0 2.0.0 </div><div class="t m0 x5 h36 y164b ff48 fs6 fc0 sc0 lsa1 ws1e5">3.0 1.9.0    </div><div class="t m0 x5 h5 y164c ff49 fs2 fc0 sc0 ls3b">与Safari跟WebKit一样，Firefox与Gecko的版本号也不一定严格对应。 </div><div class="t m0 x0 h5 y164d ff4f fs2 fc0 sc0 ls8 ws1">最后一个要检测的呈现引擎就是IE了。IE的版本号位于字符串&quot;MSIE&quot;的后面、一个分号的前面，</div><div class="t m0 x0 h5 y164e ff4f fs2 fc0 sc0 ls8 ws1">因此相应的正则表达式非常简单，如下所示： </div><div class="t m0 x0 hb y164f ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1650 ff50 fs6 fc0 sc0 ls21 wsb">var ua = navigator.userAgent; </div><div class="t m0 x0 hb y1651 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1652 ff50 fs6 fc0 sc0 ls21 wsb">if (window.opera){ </div><div class="t m0 x0 hb y1653 ff50 fs6 fc0 sc0 ls21 wsb">    engine.ver = window.opera.version(); </div><div class="t m0 x0 hb y1654 ff50 fs6 fc0 sc0 ls21 wsb">    engine.opera = parseFloat(engine.ver); </div><div class="t m0 x0 hb y1655 ff50 fs6 fc0 sc0 ls21 wsb">} else if (/AppleWebKit\/(\S+)/.test(ua)){ </div><div class="t m0 x0 hb y1656 ff50 fs6 fc0 sc0 ls21 wsb">    engine.ver = RegExp[&quot;$1&quot;]; </div><div class="t m0 x0 hb y1657 ff50 fs6 fc0 sc0 ls21 wsb">    engine.webkit = parseFloat(engine.ver); </div><div class="t m0 x0 hb y1658 ff50 fs6 fc0 sc0 ls21 wsb">} else if (/KHTML\/(\S+)/.test(ua)) { </div><div class="t m0 x0 hb y1659 ff50 fs6 fc0 sc0 ls21 wsb">    engine.ver = RegExp[&quot;$1&quot;]; </div><div class="t m0 x0 hb y165a ff50 fs6 fc0 sc0 ls21 wsb">    engine.khtml = parseFloat(engine.ver); </div><div class="t m0 x0 hb y165b ff50 fs6 fc0 sc0 ls21 wsb">} else if (/rv:([^\)]+)\) Gecko\/\d{8}/.test(ua)){     </div><div class="t m0 x0 hb y165c ff50 fs6 fc0 sc0 ls21 wsb">    engine.ver = RegExp[&quot;$1&quot;]; </div><div class="t m0 x0 hb y165d ff50 fs6 fc0 sc0 ls21 wsb">    engine.gecko = parseFloat(engine.ver); </div><div class="t m0 x0 h15 y165e ff54 fs6 fc0 sc0 ls21 wsb">} else if (/MSIE ([^;]+)/.test(ua)){     </div><div class="t m0 x0 h15 y165f ff54 fs6 fc0 sc0 ls21 wsb">     engine.ver = RegExp[&quot;$1&quot;]; </div><div class="t m0 x0 h15 y1660 ff54 fs6 fc0 sc0 ls21 wsb">     engine.ie = parseFloat(engine.ver); </div><div class="t m0 x0 hb y1661 ff54 fs6 fc0 sc0 ls16f">}  </div><div class="t m0 x0 h4 y1662 ff4f fs2 fc0 sc0 ls8 ws1">以上呈现引擎检测脚本的最后一部分，就是在正则表达式中使用取反的字符类来取得不是分号的所</div><div class="t m0 x0 h5 y1663 ff4f fs2 fc0 sc0 ls8 ws1">有字符。IE通常会保证以标准浮点数值形式给出其版本号，但有时候也不一定。因此，取反的字符类[^;]</div><div class="t m0 x0 h5 y1664 ff4f fs2 fc0 sc0 ls8 ws1">可以确保取得多个小数点以及任何可能的字符。 </div><div class="t m0 x0 h3c y1665 ff4d fs2 fc0 sc0 ls2e wsb">2. 识别浏览器 </div><div class="t m0 x0 h4 y1666 ff4f fs2 fc0 sc0 ls8 ws1">大多数情况下，识别了浏览器的呈现引擎就足以为我们采取正确的操作提供依据了。可是，只有呈</div><div class="t m0 x0 h5 y1667 ff4f fs2 fc0 sc0 ls8 ws1">现引擎还不能说明存在所需的JavaScript功能。苹果公司的Safari浏览器和谷歌公司的Chrome浏览器都</div><div class="t m0 x0 h5 y1668 ff4f fs2 fc0 sc0 ls8 ws1">使用WebKit作为呈现引擎，但它们的JavaScript 引擎却不一样。在这两款浏览器中，client.webkit</div><div class="t m0 x0 h5 y1669 ff4f fs2 fc0 sc0 ls5f ws4c">都会返回非0值，但仅知道这一点恐怕还不够。对于它们，有必要像下面这样为client对象再添加一些</div><div class="t m0 x0 h5 y166a ff4f fs2 fc0 sc0 ls8 ws1">新的属性。 </div><div class="t m0 x0 hb y166b ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y166c ff50 fs6 fc0 sc0 ls21 wsb">var client = function(){ </div><div class="t m0 x0 hb y166d ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y166e ff50 fs6 fc0 sc0 ls21 wsb">    var engine = { </div><div class="t m0 x0 hb y166f ff50 fs6 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pffb" class="pf w0 h0" data-page-no="fb"><div class="pc pcfb w0 h0"><div class="t m0 x2 h2 y1 ff48 fs0 fc0 sc0 ls10 wsc">9.3 用户代理检测    233 </div><div class="t m0 x0 h3 y2 ff48 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff4a fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff4a fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff4a fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff4a fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff4a fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff4a fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff4a fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff4a fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff4a fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff4a fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff4a fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff4a fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff4a fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h16 y12b2 ff50 fs6 fc0 sc0 ls21 wsb">        //呈现引擎 </div><div class="t m0 x0 hb y1670 ff50 fs6 fc0 sc0 ls21 wsb">        ie: 0, </div><div class="t m0 x0 hb y1671 ff50 fs6 fc0 sc0 ls21 wsb">        gecko: 0, </div><div class="t m0 x0 hb y1672 ff50 fs6 fc0 sc0 ls21 wsb">        webkit: 0, </div><div class="t m0 x0 hb y1673 ff50 fs6 fc0 sc0 ls21 wsb">        khtml: 0, </div><div class="t m0 x0 hb y1674 ff50 fs6 fc0 sc0 ls21 wsb">        opera: 0, </div><div class="t m0 x0 hb y1675 ff50 fs6 fc0 sc0 ls21 wsb">         </div><div class="t m0 x0 h16 y1676 ff50 fs6 fc0 sc0 ls21 wsb">        //具体的版本 </div><div class="t m0 x0 hb y1677 ff50 fs6 fc0 sc0 ls21 wsb">        ver: null </div><div class="t m0 x0 hb y1678 ff50 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 hb y1679 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y167a ff54 fs6 fc0 sc0 ls21 wsb">    var browser = { </div><div class="t m0 x0 h15 y167b ff54 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y167c ff54 fs6 fc0 sc0 ls21 wsb">        //浏览器 </div><div class="t m0 x0 h15 y167d ff54 fs6 fc0 sc0 ls21 wsb">        ie: 0, </div><div class="t m0 x0 h15 y167e ff54 fs6 fc0 sc0 ls21 wsb">        firefox: 0, </div><div class="t m0 x0 h15 y167f ff54 fs6 fc0 sc0 ls21 wsb">        safari: 0, </div><div class="t m0 x0 h15 y1680 ff54 fs6 fc0 sc0 ls21 wsb">        konq: 0, </div><div class="t m0 x0 h15 y1681 ff54 fs6 fc0 sc0 ls21 wsb">        opera: 0, </div><div class="t m0 x0 h15 y1682 ff54 fs6 fc0 sc0 ls21 wsb">        chrome: 0, </div><div class="t m0 x0 h15 y1683 ff54 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1684 ff54 fs6 fc0 sc0 ls21 wsb">        //具体的版本 </div><div class="t m0 x0 h15 y1685 ff54 fs6 fc0 sc0 ls21 wsb">        ver: null </div><div class="t m0 x0 hb y1686 ff54 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 hb y1687 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1688 ff50 fs6 fc0 sc0 ls21 wsb">    //在此检测呈现引擎、平台和设备 </div><div class="t m0 x0 hb y1689 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y168a ff50 fs6 fc0 sc0 ls21 wsb">    return { </div><div class="t m0 x0 hb y168b ff50 fs6 fc0 sc0 ls21 wsb">        engine: engine, </div><div class="t m0 x0 h15 y168c ff54 fs6 fc0 sc0 ls21 wsb">        browser: browser </div><div class="t m0 x0 hb y168d ff50 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 hb y168e ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y168f ff50 fs6 fc0 sc0 ls21 wsb">}();  </div><div class="t m0 x0 h4 y1690 ff4f fs2 fc0 sc0 ls5 ws4">代码中又添加了私有变量browser，用于保存每个主要浏览器的属性。与engine变量一样，除</div><div class="t m0 x0 h5 y1691 ff4f fs2 fc0 sc0 ls5 ws4">了当前使用的浏览器，其他属性的值将保持为0；如果是当前使用的浏览器，则这个属性中保存的是浮</div><div class="t m0 x0 h1c y1692 ff4f fs2 fc0 sc0 ls5 ws4">点数值形式的版本号。同样，ver属性中在必要时将会包含字符串形式的浏览器完整版本号。由于大</div><div class="t m0 x0 h4 y1693 ff4f fs2 fc0 sc0 ls24">多数浏览器与其呈现引擎密切相关，所以下面示例中检测浏览器的代码与检测呈现引擎的代码是混合</div><div class="t m0 x0 h5 y1694 ff4f fs2 fc0 sc0 ls5">在一起的。 </div><div class="t m0 x5 hb y1695 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1696 ff50 fs6 fc0 sc0 ls21">//检测呈现引擎及浏览器 </div><div class="t m0 x0 hb y1697 ff50 fs6 fc0 sc0 ls21 wsb">var ua = navigator.userAgent;     </div><div class="t m0 x0 hb y1698 ff50 fs6 fc0 sc0 ls21 wsb">if (window.opera){ </div><div class="t m0 x0 h15 y1699 ff54 fs6 fc0 sc0 ls21 wsb">    engine.ver = browser.ver = window.opera.version(); </div><div class="t m0 x0 h15 y169a ff54 fs6 fc0 sc0 ls21 wsb">    engine.opera = browser.opera = parseFloat(engine.ver); </div><div class="t m0 x0 hb y169b ff50 fs6 fc0 sc0 ls21 wsb">} else if (/AppleWebKit\/(\S+)/.test(ua)){ </div><div class="t m0 x0 hb y169c ff50 fs6 fc0 sc0 ls21 wsb">    engine.ver = RegExp[&quot;$1&quot;]; </div><div class="t m0 x0 hb y169d ff50 fs6 fc0 sc0 ls21 wsb">    engine.webkit = parseFloat(engine.ver); </div><div class="t m0 x0 hb y169e ff50 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 h16 y169f ff54 fs6 fc0 sc0 ls21 wsb">    //确定是Chrome还是Safari </div><div class="t m0 x0 hb y16a0 ff50 fs6 fc0 sc0 ls21 wsb">    if (/Chrome\/(\S+)/.test(ua)){ </div><div class="t m0 x0 h15 y16a1 ff54 fs6 fc0 sc0 ls21 wsb">        browser.ver = RegExp[&quot;$1&quot;]; </div><div class="t m0 x0 h15 y16a2 ff54 fs6 fc0 sc0 ls21 wsb">        browser.chrome = parseFloat(browser.ver); </div><div class="t m0 x0 h15 y16a3 ff54 fs6 fc0 sc0 ls21 wsb">    } else if (/Version\/(\S+)/.test(ua)){ </div><div class="t m0 x0 h15 y16a4 ff54 fs6 fc0 sc0 ls21 wsb">        browser.ver = RegExp[&quot;$1&quot;]; </div><div class="t m0 x0 h15 y16a5 ff54 fs6 fc0 sc0 ls21 wsb">        browser.safari = parseFloat(browser.ver); </div><div class="t m0 x0 h15 y16a6 ff54 fs6 fc0 sc0 ls21 wsb">    } else { </div><div class="t m0 x0 h16 y16a7 ff54 fs6 fc0 sc0 ls21 wsb">        //近似地确定版本号 </div><div class="t m0 x0 h15 y16a8 ff54 fs6 fc0 sc0 ls21 wsb">        var safariVersion = 1; </div></div></div>
<div id="pffc" class="pf w0 h0" data-page-no="fc"><div class="pc pcfc w0 h0"><div class="t m0 x0 h2 y1 ff48 fs0 fc0 sc0 ls7 ws0">234  第9章 客户端检测 </div><div class="t m0 x0 h3 y2 ff48 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y8f5 ff54 fs6 fc0 sc0 ls21 wsb">        if (engine.webkit &lt; 100){ </div><div class="t m0 x0 h15 y8f6 ff54 fs6 fc0 sc0 ls21 wsb">            safariVersion = 1; </div><div class="t m0 x0 h15 y8f7 ff54 fs6 fc0 sc0 ls21 wsb">        } else if (engine.webkit &lt; 312){ </div><div class="t m0 x0 h15 y8f8 ff54 fs6 fc0 sc0 ls21 wsb">            safariVersion = 1.2; </div><div class="t m0 x0 h15 y8f9 ff54 fs6 fc0 sc0 ls21 wsb">        } else if (engine.webkit &lt; 412){ </div><div class="t m0 x0 h15 y8fa ff54 fs6 fc0 sc0 ls21 wsb">            safariVersion = 1.3; </div><div class="t m0 x0 h15 y8fb ff54 fs6 fc0 sc0 ls21 wsb">        } else { </div><div class="t m0 x0 h15 y8fc ff54 fs6 fc0 sc0 ls21 wsb">            safariVersion = 2; </div><div class="t m0 x0 h15 y8fd ff54 fs6 fc0 sc0 ls21 wsb">        }    </div><div class="t m0 x0 h15 y1037 ff54 fs6 fc0 sc0 ls21 wsb">         </div><div class="t m0 x0 h15 y1038 ff54 fs6 fc0 sc0 ls21 wsb">        browser.safari = browser.ver = safariVersion;         </div><div class="t m0 x0 h15 y1039 ff54 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y16a9 ff50 fs6 fc0 sc0 ls21 wsb">} else if (/KHTML\/(\S+)/.test(ua) || /Konqueror\/([^;]+)/.test(ua)){ </div><div class="t m0 x0 h15 y16aa ff54 fs6 fc0 sc0 ls21 wsb">    engine.ver = browser.ver = RegExp[&quot;$1&quot;]; </div><div class="t m0 x0 h15 y16ab ff54 fs6 fc0 sc0 ls21 wsb">    engine.khtml = browser.konq = parseFloat(engine.ver); </div><div class="t m0 x0 hb y16ac ff50 fs6 fc0 sc0 ls21 wsb">} else if (/rv:([^\)]+)\) Gecko\/\d{8}/.test(ua)){     </div><div class="t m0 x0 hb y16ad ff50 fs6 fc0 sc0 ls21 wsb">    engine.ver = RegExp[&quot;$1&quot;]; </div><div class="t m0 x0 hb y16ae ff50 fs6 fc0 sc0 ls21 wsb">    engine.gecko = parseFloat(engine.ver); </div><div class="t m0 x0 hb y16af ff50 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 h16 y16b0 ff54 fs6 fc0 sc0 ls21 wsb">    //确定是不是Firefox </div><div class="t m0 x0 h15 y16b1 ff54 fs6 fc0 sc0 ls21 wsb">    if (/Firefox\/(\S+)/.test(ua)){ </div><div class="t m0 x0 h15 y16b2 ff54 fs6 fc0 sc0 ls21 wsb">        browser.ver = RegExp[&quot;$1&quot;]; </div><div class="t m0 x0 h15 y16b3 ff54 fs6 fc0 sc0 ls21 wsb">        browser.firefox = parseFloat(browser.ver); </div><div class="t m0 x0 h15 y16b4 ff54 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y16b5 ff50 fs6 fc0 sc0 ls21 wsb">} else if (/MSIE ([^;]+)/.test(ua)){     </div><div class="t m0 x0 hb y16b6 ff50 fs6 fc0 sc0 ls21 wsb">    engine.ver = browser.ver = RegExp[&quot;$1&quot;]; </div><div class="t m0 x0 h15 y16b7 ff54 fs6 fc0 sc0 ls21 wsb">    engine.ie = browser.ie = parseFloat(engine.ver); </div><div class="t m0 x0 hb y16b8 ff50 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h5 y831 ff4f fs2 fc0 sc0 ls3b">对Opera和IE而言，browser对象中的值等于engine对象中的值。对Konqueror而言，browser. </div><div class="t m0 x0 h21 y16b9 ff50 fs1 fc0 sc0 ls9 ws2">konq和browser.ver属性分别等于engine.khtml和engine.ver 属性。 </div><div class="t m0 x0 h5 y16ba ff4f fs2 fc0 sc0 ls8 ws1">为了检测Chrome和Safari，我们在检测引擎的代码中添加了if语句。提取Chrome的版本号时，需</div><div class="t m0 x0 he y16bb ff4f fs2 fc0 sc0 ls5 ws4">要查找字符串&quot;Chrome/&quot;并取得该字符串后面的数值。而提取Safari的版本号时，则需要查找字符串</div><div class="t m0 x0 h5 y16bc ff50 fs1 fc0 sc0 ls9 ws2">&quot;Version/&quot;并取得其后的数值。由于这种方式仅适用于Safari 3及更高版本，因此需要一些备用的代</div><div class="t m0 x0 h5 y16bd ff4f fs2 fc0 sc0 ls8 ws1">码，将WebKit的版本号近似地映射为Safari的版本号（参见上一小节中的表格）。 </div><div class="t m0 x0 h5 y16be ff4f fs2 fc0 sc0 ls8 ws1">在检测Firefox的版本时，首先要找到字符串&quot;Firefox/&quot;，然后提取出该字符串后面的数值（即版</div><div class="t m0 x0 h5 y16bf ff4f fs2 fc0 sc0 ls8 ws1">本号）。当然，只有呈现引擎被判别为Gecko时才会这样做。 </div><div class="t m0 x0 h5 y16c0 ff4f fs2 fc0 sc0 ls8 ws1">有了上面这些代码之后，我们就可以编写下面的逻辑。 </div><div class="t m0 x0 hb y79e ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y16c1 ff50 fs6 fc0 sc0 ls21 wsb">if (client.engine.webkit) { //if it’s WebKit </div><div class="t m0 x0 hb y16c2 ff50 fs6 fc0 sc0 ls21 wsb">    if (client.browser.chrome){ </div><div class="t m0 x0 h16 y16c3 ff50 fs6 fc0 sc0 ls21 wsb">        //执行针对Chrome的代码 </div><div class="t m0 x0 hb y16c4 ff50 fs6 fc0 sc0 ls21 wsb">    } else if (client.browser.safari){ </div><div class="t m0 x0 h16 y16c5 ff50 fs6 fc0 sc0 ls21 wsb">        //执行针对Safari的代码 </div><div class="t m0 x0 hb y16c6 ff50 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y16c7 ff50 fs6 fc0 sc0 ls21 wsb">} else if (client.engine.gecko){ </div><div class="t m0 x0 hb y16c8 ff50 fs6 fc0 sc0 ls21 wsb">    if (client.browser.firefox){ </div><div class="t m0 x0 h16 y16c9 ff50 fs6 fc0 sc0 ls21 wsb">        //执行针对Firefox的代码 </div><div class="t m0 x0 hb y16ca ff50 fs6 fc0 sc0 ls21 wsb">    } else { </div><div class="t m0 x0 h16 y16cb ff50 fs6 fc0 sc0 ls21 wsb">        //执行针对其他Gecko浏览器的代码 </div><div class="t m0 x0 hb y16cc ff50 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y16cd ff50 fs6 fc0 sc0 ls21 wsb">}  </div></div></div>
<div id="pffd" class="pf w0 h0" data-page-no="fd"><div class="pc pcfd w0 h0"><div class="t m0 x2 h2 y1 ff48 fs0 fc0 sc0 ls10 wsc">9.3 用户代理检测    235 </div><div class="t m0 x0 h3 y2 ff48 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff4a fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff4a fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff4a fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff4a fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff4a fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff4a fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff4a fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff4a fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff4a fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff4a fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff4a fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff4a fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff4a fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h3c y68b ff4d fs2 fc0 sc0 ls2e wsb">3. 识别平台 </div><div class="t m0 x0 h4 y68c ff4f fs2 fc0 sc0 ls8 ws1">很多时候，只要知道呈现引擎就足以编写出适当的代码了。但在某些条件下，平台可能是必须关注</div><div class="t m0 x0 h5 y15dc ff4f fs2 fc0 sc0 ls8 ws1">的问题。那些具有各种平台版本的浏览器（如Safari、Firefox和Opera）在不同的平台下可能会有不同</div><div class="t m0 x0 h5 y15dd ff4f fs2 fc0 sc0 ls8 ws1">的问题。目前的三大主流平台是Windows、Mac和Unix（包括各种Linux）。为了检测这些平台，还需</div><div class="t m0 x0 h5 y15de ff4f fs2 fc0 sc0 ls8 ws1">要像下面这样再添加一个新对象。 </div><div class="t m0 x5 hb y6e5 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y16ce ff50 fs6 fc0 sc0 ls21 wsb">var client = function(){ </div><div class="t m0 x0 hb y16cf ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y16d0 ff50 fs6 fc0 sc0 ls21 wsb">    var engine = { </div><div class="t m0 x0 hb y16d1 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y16d2 ff50 fs6 fc0 sc0 ls21 wsb">        //呈现引擎 </div><div class="t m0 x0 hb y16d3 ff50 fs6 fc0 sc0 ls21 wsb">        ie: 0, </div><div class="t m0 x0 hb y16d4 ff50 fs6 fc0 sc0 ls21 wsb">        gecko: 0, </div><div class="t m0 x0 hb y16d5 ff50 fs6 fc0 sc0 ls21 wsb">        webkit: 0, </div><div class="t m0 x0 hb y16d6 ff50 fs6 fc0 sc0 ls21 wsb">        khtml: 0, </div><div class="t m0 x0 hb y16d7 ff50 fs6 fc0 sc0 ls21 wsb">        opera: 0, </div><div class="t m0 x0 hb y16d8 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y16d9 ff50 fs6 fc0 sc0 ls21 wsb">        //具体的版本号 </div><div class="t m0 x0 hb y16da ff50 fs6 fc0 sc0 ls21 wsb">        ver: null </div><div class="t m0 x0 hb y16db ff50 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 hb y16dc ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y16dd ff50 fs6 fc0 sc0 ls21 wsb">    var browser = { </div><div class="t m0 x0 hb y16de ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y16df ff50 fs6 fc0 sc0 ls21 wsb">        //浏览器 </div><div class="t m0 x0 hb y16e0 ff50 fs6 fc0 sc0 ls21 wsb">        ie: 0, </div><div class="t m0 x0 hb y16e1 ff50 fs6 fc0 sc0 ls21 wsb">        firefox: 0, </div><div class="t m0 x0 hb y16e2 ff50 fs6 fc0 sc0 ls21 wsb">        safari: 0, </div><div class="t m0 x0 hb y16e3 ff50 fs6 fc0 sc0 ls21 wsb">        konq: 0, </div><div class="t m0 x0 hb y16e4 ff50 fs6 fc0 sc0 ls21 wsb">        opera: 0, </div><div class="t m0 x0 hb y16e5 ff50 fs6 fc0 sc0 ls21 wsb">        chrome: 0, </div><div class="t m0 x0 hb y16e6 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y16e7 ff50 fs6 fc0 sc0 ls21 wsb">        //具体的版本号 </div><div class="t m0 x0 hb y16e8 ff50 fs6 fc0 sc0 ls21 wsb">        ver: null </div><div class="t m0 x0 hb y16e9 ff50 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 h15 y16ea ff54 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y16eb ff54 fs6 fc0 sc0 ls21 wsb">    var system = { </div><div class="t m0 x0 h15 y16ec ff54 fs6 fc0 sc0 ls21 wsb">        win: false, </div><div class="t m0 x0 h15 y16ed ff54 fs6 fc0 sc0 ls21 wsb">        mac: false, </div><div class="t m0 x0 h15 y16ee ff54 fs6 fc0 sc0 ls21 wsb">        x11: false </div><div class="t m0 x0 h15 y16ef ff54 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 hb y16f0 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y16f1 ff50 fs6 fc0 sc0 ls21 wsb">    //在此检测呈现引擎、平台和设备 </div><div class="t m0 x0 hb y16f2 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y16f3 ff50 fs6 fc0 sc0 ls21 wsb">    return { </div><div class="t m0 x0 hb y16f4 ff50 fs6 fc0 sc0 ls21 wsb">        engine: engine, </div><div class="t m0 x0 hb y16f5 ff50 fs6 fc0 sc0 ls21 wsb">        browser: browser, </div><div class="t m0 x0 h15 y16f6 ff54 fs6 fc0 sc0 ls21 wsb">        system: system </div><div class="t m0 x0 hb y16f7 ff50 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 hb y16f8 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y16f9 ff50 fs6 fc0 sc0 ls21 wsb">}();  </div><div class="t m0 x0 h5 y16fa ff4f fs2 fc0 sc0 ls30 ws2a">显然，上面的代码中又添加了一个包含3个属性的新变量system。其中，win属性表示是否为</div><div class="t m0 x0 h5 y16fb ff48 fs2 fc0 sc0 ls22c ws1e7">Windows平台，mac表示Mac，而x11 表示Unix。与呈现引擎不同，在不能访问操作系统或版本的</div><div class="t m0 x0 h5 y16fc ff4f fs2 fc0 sc0 ls30 ws2a">情况下，平台信息通常是很有限的。对这三个平台而言，浏览器一般只报告Windows版本。为此，新</div><div class="t m0 x0 he y16fd ff4f fs2 fc0 sc0 ls30 ws2a">变量system的每个属性最初都保存着布尔值false，而不是像呈现引擎属性那样保存着数字值。 </div><div class="t m0 x0 h1e y16fe ff4f fs2 fc0 sc0 ls8 ws1">在确定平台时，检测navigator.platform要比检测用户代理字符串更简单，后者在不同浏览器</div><div class="t m0 x0 h1e y16ff ff4f fs2 fc0 sc0 ls147 ws1e9">中会给出不同的平台信息。而navigator.platform属性可能的值包括&quot;Win32&quot;、&quot;Win64&quot; 、</div></div></div>
<div id="pffe" class="pf w0 h0" data-page-no="fe"><div class="pc pcfe w0 h0"><div class="t m0 x0 h2 y1 ff48 fs0 fc0 sc0 ls7 ws0">236  第9章 客户端检测 </div><div class="t m0 x0 h3 y2 ff48 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ff50 fs1 fc0 sc0 ls9 ws2">&quot;MacPPC&quot;、&quot;MacIntel&quot;、&quot;X11&quot;和&quot;Linux i686&quot;，这些值在不同的浏览器中都是一致的。检测平台</div><div class="t m0 x0 h5 y4d ff4f fs2 fc0 sc0 ls8 ws1">的代码非常直观，如下所示： </div><div class="t m0 x0 hb y1701 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1702 ff50 fs6 fc0 sc0 ls21 wsb">var p = navigator.platform; </div><div class="t m0 x0 hb y1703 ff50 fs6 fc0 sc0 ls21 wsb">system.win = p.indexOf(&quot;Win&quot;) == 0; </div><div class="t m0 x0 hb y1704 ff50 fs6 fc0 sc0 ls21 wsb">system.mac = p.indexOf(&quot;Mac&quot;) == 0; </div><div class="t m0 x0 hb y1705 ff50 fs6 fc0 sc0 ls21 wsb">system.x11 = (p.indexOf(&quot;X11&quot;) == 0)    || (p.indexOf(&quot;Linux&quot;) == 0); </div><div class="t m0 x0 hb y1706 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1707 ff4f fs2 fc0 sc0 ls6 ws6">以上代码使用indexOf()方法来查找平台字符串的开始位置。虽然&quot;Win32&quot;是当前浏览器唯一支</div><div class="t m0 x0 h5 y1708 ff4f fs2 fc0 sc0 ls8 ws1">持的Windows字符串，但随着向64位Windows架构的迁移，将来很可能会出现&quot;Win64&quot;平台信息值。</div><div class="t m0 x0 hc y13d7 ff4f fs2 fc0 sc0 ls8 ws1">为了对此有所准备，检测平台的代码中查找的只是字符串&quot;Win&quot;的开始位置。而检测Mac平台的方式也</div><div class="t m0 x0 hc y1709 ff4f fs2 fc0 sc0 ls8 ws1">类似，同样是考虑到了MacPPC和MacIntel。在检测Unix时，则同时检查了字符串&quot;X11&quot;和&quot;Linux&quot;</div><div class="t m0 x0 h5 y1453 ff4f fs2 fc0 sc0 ls8 ws1">在平台字符串中的开始位置，从而确保了代码能够向前兼容其他变体。 </div><div class="t m0 x5 h5 y170a ff48 fs2 fc0 sc0 ls230 ws1ea">Gecko的早期版本在所有Windows平台中都返回字符串&quot;Windows&quot;，在所有 Mac平</div><div class="t m0 x0 h18 y170b ff49 fs2 fc0 sc0 ls5f wsdd">台中则都返回字符串&quot;Macintosh&quot;。不过，这都是Firefox 1发布以前的事了，Firefox 1</div><div class="t m0 x0 h18 y170c ff49 fs2 fc0 sc0 ls5f wsdd">确定了navigator.platform的值。 </div><div class="t m0 x0 h3c y170d ff4d fs2 fc0 sc0 ls2e wsb">4. 识别Windows操作系统 </div><div class="t m0 x0 h5 y170e ff4f fs2 fc0 sc0 lse7">在Windows平台下，还可以从用户代理字符串中进一步取得具体的操作系统信息。在Windows XP</div><div class="t m0 x0 h5 y170f ff4f fs2 fc0 sc0 ls8">之前，Windows有两种版本，分别针对家庭用户和商业用户。针对家庭用户的版本分别是Windows 95、</div><div class="t m0 x0 h5 y1710 ff48 fs2 fc0 sc0 ls8 ws20">98和Windows ME。而针对商业用户的版本则一直叫做Window NT，最后由于市场原因改名为Windows </div><div class="t m0 x0 h5 y1711 ff48 fs2 fc0 sc0 ls8">2000。这两个产品线后来又合并成一个由Windows NT发展而来的公共的代码基，代表产品就是Windows </div><div class="t m0 x0 h5 y1712 ff48 fs2 fc0 sc0 ls81 ws76">XP。随后，微软在Windows XP基础上又构建了Windows Vista。 </div><div class="t m0 x0 h5 y1713 ff4f fs2 fc0 sc0 ls8 ws1">只有了解这些信息，才能搞清楚用户代理字符串中Windows操作系统的具体版本。下表列出了不同</div><div class="t m0 x0 h5 y1714 ff4f fs2 fc0 sc0 ls8 ws1">浏览器在表示不同的Windows操作系统时给出的不同字符串。 </div><div class="t m0 x0 h5 y1715 ff48 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h31 yfcf ff4d fs6 fc0 sc0 lsbf ws1ee">Windows版本  IE 4+  Gecko  Opera &lt; 7  Opera 7+  WebKit </div><div class="t m0 x0 h36 y1716 ff48 fs6 fc0 sc0 lsa1 wsb">95  &quot;Windows 95&quot;  &quot;Win95&quot;  &quot;Windows 95&quot;  &quot;Windows 95&quot;  n/a </div><div class="t m0 x0 h36 y1717 ff48 fs6 fc0 sc0 lsa1 wsb">98  &quot;Windows 98&quot;  &quot;Win98&quot;  &quot;Windows 98&quot;  &quot;Windows 98&quot;  n/a </div><div class="t m0 x0 h36 y1718 ff48 fs6 fc0 sc0 ls22f ws1f6">NT 4.0  &quot;Windows NT&quot;  &quot;WinNT4.0&quot;  &quot;Windows NT 4.0&quot;</div><div class="c x4 y1719 w11 h35"><div class="t m0 x0 h32 y353 ff50 fsc fc0 sc0 ls8 wsb"> </div></div><div class="t m0 x4 h32 y1718 ff50 fsc fc0 sc0 ls236 wsb">&quot;Windows NT 4.0&quot; n/a </div><div class="t m0 x0 h36 y171a ff48 fs6 fc0 sc0 lsa1 wsb">2000  &quot;Windows NT 5.0&quot;</div><div class="c x1 y171b w12 h35"><div class="t m0 x0 h32 y353 ff50 fsc fc0 sc0 ls8 wsb"> </div></div><div class="t m0 x1 h32 y171a ff50 fsc fc0 sc0 lsa8 wsb">&quot;Windows NT 5.0&quot;</div><div class="c x7 y171b w13 h35"><div class="t m0 x0 h32 y353 ff50 fsc fc0 sc0 ls8 wsb"> </div></div><div class="t m0 x4 h32 y171a ff50 fsc fc0 sc0 lsa8 wsb">&quot;Windows 2000&quot;</div><div class="c x4 y171b w14 h35"><div class="t m0 x0 h32 y353 ff50 fsc fc0 sc0 ls8 wsb"> </div></div><div class="t m0 x4 h32 y171a ff50 fsc fc0 sc0 ls236 wsb">&quot;Windows NT 5.0&quot; n/a </div><div class="t m0 x0 h36 y171c ff48 fs6 fc0 sc0 ls237 wsb">ME  &quot;Win 9x 4.90&quot; &quot;Win 9x 4.90&quot;  &quot;Windows ME&quot;  &quot;Win 9x 4.90&quot;  n/a </div><div class="t m0 x0 h36 y171d ff48 fs6 fc0 sc0 ls1c9 wsb">XP  &quot;Windows NT 5.1&quot;</div><div class="c x1 y171e w12 h35"><div class="t m0 x0 h32 y353 ff50 fsc fc0 sc0 ls8 wsb"> </div></div><div class="t m0 x1 h32 y171d ff50 fsc fc0 sc0 lsa8 wsb">&quot;Windows NT 5.1&quot;</div><div class="c x7 y171e w13 h35"><div class="t m0 x0 h32 y353 ff50 fsc fc0 sc0 ls8 wsb"> </div></div><div class="t m0 x4 h32 y171d ff50 fsc fc0 sc0 lsa8 wsb">&quot;Windows XP&quot;  &quot;Windows NT 5.1&quot;  &quot;Windows NT 5.1&quot; </div><div class="t m0 x0 h36 y46f ff48 fs6 fc0 sc0 lsbb wsb">Vista  &quot;Windows NT 6.0&quot;</div><div class="c x1 y171f w12 h35"><div class="t m0 x0 h32 y353 ff50 fsc fc0 sc0 ls8 wsb"> </div></div><div class="t m0 x1 h32 y46f ff50 fsc fc0 sc0 lsa8 wsb">&quot;Windows NT 6.0&quot;</div><div class="c x7 y171f w13 h35"><div class="t m0 x0 h32 y353 ff50 fsc fc0 sc0 ls8 wsb"> </div></div><div class="t m0 x4 h32 y46f ff50 fsc fc0 sc0 lsa8 wsb">n/a  &quot;Windows NT 6.0&quot;  &quot;Windows NT 6.0&quot; </div><div class="t m0 x0 h36 y1720 ff48 fs6 fc0 sc0 lsa1 wsb">7  &quot;Windows NT 6.1&quot;</div><div class="c x1 y1721 w12 h35"><div class="t m0 x0 h32 y353 ff50 fsc fc0 sc0 ls8 wsb"> </div></div><div class="t m0 x1 h32 y1720 ff50 fsc fc0 sc0 lsa8 wsb">&quot;Windows NT 6.1&quot;</div><div class="c x7 y1721 w13 h35"><div class="t m0 x0 h32 y353 ff50 fsc fc0 sc0 ls8 wsb"> </div></div><div class="t m0 x4 h32 y1720 ff50 fsc fc0 sc0 lsa8 wsb">n/a  &quot;Windows NT 6.1&quot; &quot;Windows NT 6.1&quot; </div><div class="t m0 x0 h5 y1722 ff48 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1723 ff4f fs2 fc0 sc0 ls8 ws1">由于用户代理字符串中的Windows操作系统版本表示方法各异，因此检测代码并不十分直观。好在，</div><div class="t m0 x0 h5 y1724 ff4f fs2 fc0 sc0 ls21d">从Windows 2000开始，表示操作系统的字符串大部分都还相同，只有版本号有变化。为了检测不同的</div><div class="t m0 x0 h5 y1725 ff48 fs2 fc0 sc0 lsb ws5">Windows操作系统，必须要使用正则表达式。由于使用Opera 7之前版本的用户已经不多了，因此我们</div><div class="t m0 x0 h5 y1726 ff4f fs2 fc0 sc0 ls8 ws1">可以忽略这部分浏览器。 </div></div></div>
<div id="pfff" class="pf w0 h0" data-page-no="ff"><div class="pc pcff w0 h0"><div class="t m0 x2 h2 y1 ff48 fs0 fc0 sc0 ls10 wsc">9.3 用户代理检测    237 </div><div class="t m0 x0 h3 y2 ff48 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff4a fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff4a fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff4a fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff4a fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff4a fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff4a fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff4a fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff4a fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff4a fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff4a fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff4a fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff4a fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff4a fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff4f fs2 fc0 sc0 ls8 ws1">第一步就是匹配Windows 95和Windows 98这两个字符串。对这两个字符串，只有Gecko与其他浏</div><div class="t m0 x0 h1e y4d ff4f fs2 fc0 sc0 ls8 ws1">览器不同，即没有&quot;dows&quot;，而且&quot;Win&quot;与版本号之间没有空格。要匹配这个模式，可以使用下面这个简</div><div class="t m0 x0 h5 y5 ff4f fs2 fc0 sc0 ls8 ws1">单的正则表达式。 </div><div class="t m0 x5 hb y6bd ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y6be ff50 fs6 fc0 sc0 ls21 wsb">/Win(?:dows )?([^do]{2})/ </div><div class="t m0 x5 hb y153b ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y6e5 ff4f fs2 fc0 sc0 ls8 ws1">这个正则表达式中的捕获组会返回操作系统的版本。由于版本可能是任何两个字符编码（例如95、</div><div class="t m0 x0 h5 y1727 ff48 fs2 fc0 sc0 ls8">98、9x、NT、ME及XP），因此要使用两个非空格字符。 </div><div class="t m0 x0 h5 y1728 ff48 fs2 fc0 sc0 ls81 ws76">Gecko在表示Windows NT时会在末尾添加&quot;4.0&quot;，与其查找实际的字符串，不如像下面这样查找</div><div class="t m0 x0 h5 y14e4 ff4f fs2 fc0 sc0 ls8 ws1">小数值更合适。 </div><div class="t m0 x5 hb y14e5 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y14e6 ff50 fs6 fc0 sc0 ls21 wsb">/Win(?:dows )?([^do]{2})(\d+\.\d+)?/ </div><div class="t m0 x5 hb y14e7 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y14e8 ff4f fs2 fc0 sc0 ls8 ws1">这样，正则表达式中就包含了第二个捕获组，用于取得NT的版本号。由于该版本号对于Windows </div><div class="t m0 x0 h5 y14e9 ff48 fs2 fc0 sc0 ls8 ws20">95和Windows 98而言是不存在的，所以必须设置为可选。这个模式与Opera表示Windows NT 的字符</div><div class="t m0 x0 hc y14ea ff4f fs2 fc0 sc0 ls8 ws1">串之间唯一的区别，就是&quot;NT&quot;与&quot;4.0&quot;之间的空格，这在模式中很容易添加。 </div><div class="t m0 x5 hb y1729 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y172a ff50 fs6 fc0 sc0 ls21 wsb">/Win(?:dows )?([^do]{2})\s?(\d+\.\d+)?/ </div><div class="t m0 x5 hb y172b ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y172c ff4f fs2 fc0 sc0 ls8 ws1">经过一番修改之后，这个正则表达式也可以成功地匹配Windows ME、Windows XP和Windows Vista</div><div class="t m0 x0 h5 y172d ff4f fs2 fc0 sc0 ls8 ws1">的字符串了。具体来说，第一个捕获组将会匹配95、98、9x、NT、ME或XP。第二个捕获组则只针对</div><div class="t m0 x0 h5 y172e ff48 fs2 fc0 sc0 ls152 ws202">Windows ME及所有Windows NT的变体。这个信息可以作为具体的操作系统信息保存在system.win</div><div class="t m0 x0 h5 y14f0 ff4f fs2 fc0 sc0 ls8 ws1">属性中，如下所示。 </div><div class="t m0 x5 hb y172f ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1730 ff50 fs6 fc0 sc0 ls21 wsb">if (system.win){ </div><div class="t m0 x0 hb y1731 ff50 fs6 fc0 sc0 ls21 wsb">    if (/Win(?:dows )?([^do]{2})\s?(\d+\.\d+)?/.test(ua)){ </div><div class="t m0 x0 hb y1732 ff50 fs6 fc0 sc0 ls21 wsb">        if (RegExp[&quot;$1&quot;] == &quot;NT&quot;){ </div><div class="t m0 x0 hb y1733 ff50 fs6 fc0 sc0 ls21 wsb">            switch(RegExp[&quot;$2&quot;]){ </div><div class="t m0 x0 hb y1734 ff50 fs6 fc0 sc0 ls21 wsb">                case &quot;5.0&quot;: </div><div class="t m0 x0 hb y1735 ff50 fs6 fc0 sc0 ls21 wsb">                    system.win = &quot;2000&quot;; </div><div class="t m0 x0 hb y1736 ff50 fs6 fc0 sc0 ls21 wsb">                    break; </div><div class="t m0 x0 hb y1737 ff50 fs6 fc0 sc0 ls21 wsb">                case &quot;5.1&quot;: </div><div class="t m0 x0 hb y1738 ff50 fs6 fc0 sc0 ls21 wsb">                    system.win = &quot;XP&quot;; </div><div class="t m0 x0 hb y1739 ff50 fs6 fc0 sc0 ls21 wsb">                    break; </div><div class="t m0 x0 hb y173a ff50 fs6 fc0 sc0 ls21 wsb">                case &quot;6.0&quot;: </div><div class="t m0 x0 hb y173b ff50 fs6 fc0 sc0 ls21 wsb">                    system.win = &quot;Vista&quot;; </div><div class="t m0 x0 hb y173c ff50 fs6 fc0 sc0 ls21 wsb">                    break; </div><div class="t m0 x0 hb y173d ff50 fs6 fc0 sc0 ls21 wsb">                case &quot;6.1&quot;: </div><div class="t m0 x0 hb y173e ff50 fs6 fc0 sc0 ls21 wsb">                    system.win = &quot;7&quot;; </div><div class="t m0 x0 hb y173f ff50 fs6 fc0 sc0 ls21 wsb">                    break; </div><div class="t m0 x0 hb y1740 ff50 fs6 fc0 sc0 ls21 wsb">                default: </div><div class="t m0 x0 hb y1741 ff50 fs6 fc0 sc0 ls21 wsb">                    system.win = &quot;NT&quot;; </div><div class="t m0 x0 hb y1742 ff50 fs6 fc0 sc0 ls21 wsb">                    break;                 </div><div class="t m0 x0 hb y1743 ff50 fs6 fc0 sc0 ls21 wsb">            }                             </div><div class="t m0 x0 hb y1744 ff50 fs6 fc0 sc0 ls21 wsb">        } else if (RegExp[&quot;$1&quot;] == &quot;9x&quot;){ </div><div class="t m0 x0 hb y1745 ff50 fs6 fc0 sc0 ls21 wsb">            system.win = &quot;ME&quot;; </div><div class="t m0 x0 hb y1746 ff50 fs6 fc0 sc0 ls21 wsb">        } else { </div><div class="t m0 x0 hb y1747 ff50 fs6 fc0 sc0 ls21 wsb">            system.win = RegExp[&quot;$1&quot;]; </div><div class="t m0 x0 hb y1748 ff50 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y1749 ff50 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y174a ff50 fs6 fc0 sc0 ls21 wsb">}  </div></div></div>
<div id="pf100" class="pf w0 h0" data-page-no="100"><div class="pc pc100 w0 h0"><div class="t m0 x0 h2 y1 ff48 fs0 fc0 sc0 ls7 ws0">238  第9章 客户端检测 </div><div class="t m0 x0 h3 y2 ff48 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ff4f fs2 fc0 sc0 ls8 ws1">如果system.win的值为true，那么就使用这个正则表达式从用户代理字符串中提取具体的信息。</div><div class="t m0 x0 h5 y4d ff4f fs2 fc0 sc0 ls8 ws1">鉴于Windows将来的某个版本也许不能使用这个方法来检测，所以第一步应该先检测用户代理字符串是</div><div class="t m0 x0 h1c yd8 ff4f fs2 fc0 sc0 ls8 ws1">否与这个模式匹配。在模式匹配的情况下，第一个捕获组中可能会包含&quot;95&quot;、&quot;98&quot;、&quot;9x&quot;或&quot;NT&quot;。如</div><div class="t m0 x0 h4 yd9 ff4f fs2 fc0 sc0 ls8 ws1">果这个值是&quot;NT&quot;，可以将system.win设置为相应操作系统的字符串；如果是&quot;9x&quot;，那么system.win</div><div class="t m0 x0 h4 y219 ff4f fs2 fc0 sc0 ls8 ws1">就要设置成&quot;ME&quot;；如果是其他值，则将所捕获的值直接赋给system.win。有了这些检测平台的代码后，</div><div class="t m0 x0 h5 y21a ff4f fs2 fc0 sc0 ls8 ws1">我们就可以编写如下代码。 </div><div class="t m0 x0 hb yb70 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y14e2 ff50 fs6 fc0 sc0 ls21 wsb">if (client.system.win){ </div><div class="t m0 x0 hb y174b ff50 fs6 fc0 sc0 ls21 wsb">    if (client.system.win == &quot;XP&quot;) { </div><div class="t m0 x0 h16 y174c ff50 fs6 fc0 sc0 ls21 wsb">        //说明是XP </div><div class="t m0 x0 hb y174d ff50 fs6 fc0 sc0 ls21 wsb">    } else if (client.system.win == &quot;Vista&quot;){ </div><div class="t m0 x0 h16 y174e ff50 fs6 fc0 sc0 ls21 wsb">        //说明是Vista </div><div class="t m0 x0 hb y174f ff50 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y1750 ff50 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h4 y1751 ff4f fs2 fc0 sc0 ls8 ws1">由于非空字符串会转换为布尔值true，因此可以将client.system.win作为布尔值用在 if语</div><div class="t m0 x0 h5 y1752 ff4f fs2 fc0 sc0 ls8 ws1">句中。而在需要更多有关操作系统的信息时，则可以使用其中保存的字符串值。 </div><div class="t m0 x0 h3c y1753 ff4d fs2 fc0 sc0 ls2e wsb">5. 识别移动设备 </div><div class="t m0 x0 h5 y1754 ff48 fs2 fc0 sc0 ls24 ws204">2006年到2007年，移动设备中Web浏览器的应用呈爆炸性增长。四大主要浏览器都推出了手机</div><div class="t m0 x0 h4 y1755 ff4f fs2 fc0 sc0 ls30 ws2a">版和在其他设备中运行的版本。要检测相应的设备，第一步是为要检测的所有移动设备添加属性，如</div><div class="t m0 x0 h5 y1756 ff4f fs2 fc0 sc0 ls30 ws2a">下所示。 </div><div class="t m0 x0 hb y1757 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1758 ff50 fs6 fc0 sc0 ls21 wsb">var client = function(){ </div><div class="t m0 x0 hb y1759 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y175a ff50 fs6 fc0 sc0 ls21 wsb">    var engine = { </div><div class="t m0 x0 hb y175b ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y175c ff50 fs6 fc0 sc0 ls21 wsb">        //呈现引擎 </div><div class="t m0 x0 hb y175d ff50 fs6 fc0 sc0 ls21 wsb">        ie: 0, </div><div class="t m0 x0 hb y175e ff50 fs6 fc0 sc0 ls21 wsb">        gecko: 0, </div><div class="t m0 x0 hb y175f ff50 fs6 fc0 sc0 ls21 wsb">        webkit: 0, </div><div class="t m0 x0 hb y1760 ff50 fs6 fc0 sc0 ls21 wsb">        khtml: 0, </div><div class="t m0 x0 hb y1761 ff50 fs6 fc0 sc0 ls21 wsb">        opera: 0, </div><div class="t m0 x0 hb y1762 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1763 ff50 fs6 fc0 sc0 ls21 wsb">        //具体的版本号 </div><div class="t m0 x0 hb y1764 ff50 fs6 fc0 sc0 ls21 wsb">        ver: null </div><div class="t m0 x0 hb y1765 ff50 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 hb y1766 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1767 ff50 fs6 fc0 sc0 ls21 wsb">    var browser = { </div><div class="t m0 x0 hb y1768 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1769 ff50 fs6 fc0 sc0 ls21 wsb">        //浏览器 </div><div class="t m0 x0 hb y176a ff50 fs6 fc0 sc0 ls21 wsb">        ie: 0, </div><div class="t m0 x0 hb y176b ff50 fs6 fc0 sc0 ls21 wsb">        firefox: 0, </div><div class="t m0 x0 hb y176c ff50 fs6 fc0 sc0 ls21 wsb">        safari: 0, </div><div class="t m0 x0 hb y176d ff50 fs6 fc0 sc0 ls21 wsb">        konq: 0, </div><div class="t m0 x0 hb y176e ff50 fs6 fc0 sc0 ls21 wsb">        opera: 0, </div><div class="t m0 x0 hb y176f ff50 fs6 fc0 sc0 ls21 wsb">        chrome: 0, </div><div class="t m0 x0 hb y1770 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1771 ff50 fs6 fc0 sc0 ls21 wsb">        //具体的版本号 </div><div class="t m0 x0 hb y1772 ff50 fs6 fc0 sc0 ls21 wsb">        ver: null </div><div class="t m0 x0 hb y1773 ff50 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 hb y1774 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1775 ff50 fs6 fc0 sc0 ls21 wsb">    var system = { </div><div class="t m0 x0 hb y1776 ff50 fs6 fc0 sc0 ls21 wsb">        win: false, </div><div class="t m0 x0 hb y1777 ff50 fs6 fc0 sc0 ls21 wsb">        mac: false, </div></div></div>
<div id="pf101" class="pf w0 h0" data-page-no="101"><div class="pc pc101 w0 h0"><div class="t m0 x2 h2 y1 ff48 fs0 fc0 sc0 ls10 wsc">9.3 用户代理检测    239 </div><div class="t m0 x0 h3 y2 ff48 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff4a fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff4a fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff4a fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff4a fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff4a fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff4a fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff4a fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff4a fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff4a fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff4a fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff4a fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff4a fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff4a fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y79 ff50 fs6 fc0 sc0 ls21 wsb">        x11: false, </div><div class="t m0 x0 hb yd68 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 yd69 ff50 fs6 fc0 sc0 ls21 wsb">        //移动设备 </div><div class="t m0 x0 h15 yd6a ff54 fs6 fc0 sc0 ls21 wsb">        iphone: false, </div><div class="t m0 x0 h15 yd6b ff54 fs6 fc0 sc0 ls21 wsb">        ipod: false, </div><div class="t m0 x0 h15 yd6c ff54 fs6 fc0 sc0 ls21 wsb">        ipad: false, </div><div class="t m0 x0 h15 yd6d ff54 fs6 fc0 sc0 ls21 wsb">        ios: false, </div><div class="t m0 x0 h15 yd6e ff54 fs6 fc0 sc0 ls21 wsb">        android: false, </div><div class="t m0 x0 h15 yd6f ff54 fs6 fc0 sc0 ls21 wsb">        nokiaN: false, </div><div class="t m0 x0 hb y1778 ff54 fs6 fc0 sc0 ls21 wsb">        winMobile: false    }; </div><div class="t m0 x0 hb y1779 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y177a ff50 fs6 fc0 sc0 ls21 wsb">    //在此检测呈现引擎、平台和设备 </div><div class="t m0 x0 hb y177b ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y177c ff50 fs6 fc0 sc0 ls21 wsb">    return { </div><div class="t m0 x0 hb y177d ff50 fs6 fc0 sc0 ls21 wsb">        engine: engine, </div><div class="t m0 x0 hb y177e ff50 fs6 fc0 sc0 ls21 wsb">        browser: browser, </div><div class="t m0 x0 hb y177f ff50 fs6 fc0 sc0 ls21 wsb">        system: system </div><div class="t m0 x0 hb y1780 ff50 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 hb y1781 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1782 ff50 fs6 fc0 sc0 ls21 wsb">}();  </div><div class="t m0 x0 h5 y6ca ff4f fs2 fc0 sc0 ls8 ws1">然后，通常简单地检测字符串&quot;iPhone&quot;、&quot;iPod&quot;和&quot;iPad&quot;，就可以分别设置相应属性的值了。 </div><div class="t m0 x5 hb y1783 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1784 ff50 fs6 fc0 sc0 ls21 wsb">system.iphone = ua.indexOf(&quot;iPhone&quot;) &gt; -1; </div><div class="t m0 x0 hb y1785 ff50 fs6 fc0 sc0 ls21 wsb">system.ipod = ua.indexOf(&quot;iPod&quot;) &gt; -1; </div><div class="t m0 x0 hb y1786 ff50 fs6 fc0 sc0 ls21 wsb">system.ipod = ua.indexOf(&quot;iPad&quot;) &gt; -1; </div><div class="t m0 x5 hb y1787 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1788 ff4f fs2 fc0 sc0 ls8 ws1">除了知道iOS设备，最好还能知道iOS的版本号。在iOS 3之前，用户代理字符串中只包含&quot;CPU like </div><div class="t m0 x0 h21 y1789 ff50 fs1 fc0 sc0 ls9 ws207">Mac OS&quot;，后来iPhone中又改成&quot;CPU iPhone OS 3_0 like Mac OS X&quot;，iPad中又改成&quot;CPU OS 3_2 </div><div class="t m0 x0 h21 y178a ff50 fs1 fc0 sc0 ls9 wsb">like Mac OS X&quot;。也就是说，检测iOS需要正则表达式反映这些变化。 </div><div class="t m0 x0 hb y178b ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y178c ff50 fs6 fc0 sc0 ls21">//检测iOS版本 </div><div class="t m0 x0 hb y178d ff50 fs6 fc0 sc0 ls21 wsb">if (system.mac &amp;&amp; ua.indexOf(&quot;Mobile&quot;) &gt; -1){ </div><div class="t m0 x0 hb y178e ff50 fs6 fc0 sc0 ls21 wsb">    if (/CPU (?:iPhone )?OS (\d+_\d+)/.test(ua)){ </div><div class="t m0 x0 hb y178f ff50 fs6 fc0 sc0 ls21 wsb">        system.ios = parseFloat(RegExp.$1.replace(&quot;_&quot;, &quot;.&quot;)); </div><div class="t m0 x0 hb y1790 ff50 fs6 fc0 sc0 ls21 wsb">    } else { </div><div class="t m0 x0 h16 y1791 ff50 fs6 fc0 sc0 ls21 wsb">        system.ios = 2; //不能真正检测出来，所以只能猜测 </div><div class="t m0 x0 hb y1792 ff50 fs6 fc0 sc0 ls21 wsb">    }  </div><div class="t m0 x0 hb y1793 ff50 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y1794 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1795 ff4f fs2 fc0 sc0 ls8 ws1">检查系统是不是Mac OS、字符串中是否存在&quot;Mobile&quot;，可以保证无论是什么版本，system.ios</div><div class="t m0 x0 h5 y1796 ff4f fs2 fc0 sc0 ls8 ws1">中都不会是0。然后，再使用正则表达式确定是否存在iOS的版本号。如果有，将system.ios设置为</div><div class="t m0 x0 h5 y1797 ff4f fs2 fc0 sc0 ls8 ws1">表示版本号的浮点值；否则，将版本设置为2。（因为没有办法确定到底是什么版本，所以设置为更早的</div><div class="t m0 x0 h5 y1798 ff4f fs2 fc0 sc0 ls8 ws1">版本比较稳妥。） </div><div class="t m0 x0 he y1799 ff4f fs2 fc0 sc0 ls8 ws1">检测Android操作系统也很简单，也就是搜索字符串&quot;Android&quot;并取得紧随其后的版本号。 </div><div class="t m0 x0 hb y179a ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y179b ff50 fs6 fc0 sc0 ls21">//检测Android版本 </div><div class="t m0 x0 hb y179c ff50 fs6 fc0 sc0 ls21 wsb">if (/Android (\d+\.\d+)/.test(ua)){  </div><div class="t m0 x0 hb y179d ff50 fs6 fc0 sc0 ls21 wsb">    system.android = parseFloat(RegExp.$1); </div><div class="t m0 x0 hb y179e ff50 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 h5 y179f ff4f fs2 fc0 sc0 ls19 ws1b">由于所有版本的Android都有版本值，因此这个正则表达式可以精确地检测所有版本，并将</div><div class="t m0 x0 h5 y56c ff50 fs1 fc0 sc0 ls9 ws2">system.android设置为正确的值。 </div><div class="t m0 x0 h5 y56d ff4f fs2 fc0 sc0 ls8 ws1">诺基亚N系列手机使用的也是WebKit，其用户代理字符串与其他基于WebKit的手机很相似，例如： </div><div class="t m0 x5 hb y17a0 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y17a1 ff50 fs6 fc0 sc0 ls21 wsb">Mozilla/5.0 (SymbianOS/9.2; U; Series60/3.1 NokiaN95/11.0.026; Profile MIDP-2.0 </div><div class="t m0 x0 hb y17a2 ff50 fs6 fc0 sc0 ls21 wsb">     Configuration/CLDC-1.1) AppleWebKit/413 (KHTML, like Gecko) Safari/413 </div></div></div>
<div id="pf102" class="pf w0 h0" data-page-no="102"><div class="pc pc102 w0 h0"><div class="t m0 x0 h2 y1 ff48 fs0 fc0 sc0 ls7 ws0">240  第9章 客户端检测 </div><div class="t m0 x0 h3 y2 ff48 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff4f fs2 fc0 sc0 ls8 ws1">虽然诺基亚N系列手机在用户代理字符串中声称使用的是&quot;Safari&quot;，但实际上并不是Safari，尽</div><div class="t m0 x0 h5 y4d ff4f fs2 fc0 sc0 ls8 ws1">管确实是基于WebKit引擎。只要像下面检测一下用户代理字符串中是否存在&quot;NokiaN&quot;，就足以确定是</div><div class="t m0 x0 h5 y5 ff4f fs2 fc0 sc0 ls8 ws1">不是该系列的手机了。 </div><div class="t m0 x0 hb y6bd ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y6be ff50 fs6 fc0 sc0 ls21 wsb">system.nokiaN = ua.indexOf(&quot;NokiaN&quot;) &gt; -1; </div><div class="t m0 x0 hb y153b ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y6e5 ff4f fs2 fc0 sc0 ls8 ws1">在了解这些设备信息的基础上，就可以通过下列代码来确定用户使用的是什么设备中的WebKit来</div><div class="t m0 x0 h5 y1727 ff4f fs2 fc0 sc0 ls8 ws1">访问网页： </div><div class="t m0 x0 hb y619 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y17a3 ff50 fs6 fc0 sc0 ls21 wsb">if (client.engine.webkit){ </div><div class="t m0 x0 hb y17a4 ff50 fs6 fc0 sc0 ls21 wsb">    if (client.system. iOS){ </div><div class="t m0 x0 h16 y17a5 ff50 fs6 fc0 sc0 ls21 wsb">        //iOS手机的内容 </div><div class="t m0 x0 hb y17a6 ff50 fs6 fc0 sc0 ls21 wsb">    } else if (client.system.android){ </div><div class="t m0 x0 h16 y17a7 ff50 fs6 fc0 sc0 ls21 wsb">        //Android手机的内容 </div><div class="t m0 x0 hb y17a8 ff50 fs6 fc0 sc0 ls21 wsb">    } else if (client.system.nokiaN){ </div><div class="t m0 x0 h16 y17a9 ff50 fs6 fc0 sc0 ls21 wsb">        //诺基亚手机的内容 </div><div class="t m0 x0 hb y17aa ff50 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y17ab ff50 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h5 y17ac ff4f fs2 fc0 sc0 ls60 ws198">最后一种主要的移动设备平台是Windows Mobile（也称为Windows CE），用于Pocket PC 和</div><div class="t m0 x0 h5 y5d3 ff48 fs2 fc0 sc0 ls79 ws6c">Smartphone中。由于从技术上说这些平台都属于Windows平台，因此Windows 平台和操作系统都会返</div><div class="t m0 x0 h5 y17ad ff4f fs2 fc0 sc0 ls8 ws1">回正确的值。对于Windows Mobile 5.0及以前版本，这两种设备的用户代理字符串非常相似，如下所示： </div><div class="t m0 x0 hb y17ae ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y17af ff50 fs6 fc0 sc0 ls21 wsb">Mozilla/4.0 (compatible; MSIE 4.01; Windows CE; PPC; 240x320) </div><div class="t m0 x0 hb y17b0 ff50 fs6 fc0 sc0 ls21 wsb">Mozilla/4.0 (compatible; MSIE 4.01; Windows CE; Smartphone; 176x220) </div><div class="t m0 x0 hb y17b1 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y17b2 ff4f fs2 fc0 sc0 ls8 ws1">第一个来自Pocket PC中的移动Internet Explorer 4.01，第二个来自Smartphone中的同一个浏览器。</div><div class="t m0 x0 h5 y17b3 ff4f fs2 fc0 sc0 ls23e">当Windows操作系统检测脚本检测这两个字符串时，system.win将被设置为&quot;CE&quot;，因此在检测</div><div class="t m0 x0 h5 y17b4 ff48 fs2 fc0 sc0 lsf ws1cf">Windows Mobile时可以使用这个值： </div><div class="t m0 x0 hb y17b5 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y17b6 ff50 fs6 fc0 sc0 ls21 wsb">system.winMobile = (system.win == &quot;CE&quot;); </div><div class="t m0 x0 hb y17b7 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y17b8 ff4f fs2 fc0 sc0 ls8 ws1">不建议测试字符串中的&quot;PPC&quot;或&quot;Smartphone&quot;，因为在Windows Mobile 5.0以后版本的浏览器中，</div><div class="t m0 x0 h5 y17b9 ff4f fs2 fc0 sc0 ls8 ws1">这些记号已经被移除了。不过，一般情况下，只知道某个设备使用的是Windows Mobile也就足够了。 </div><div class="t m0 x0 h5 y17ba ff48 fs2 fc0 sc0 ls81 ws20d">Windows Phone 7的用户代理字符串稍有改进，基本格式如下： </div><div class="t m0 x0 hb y17bb ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y17bc ff50 fs6 fc0 sc0 ls21 wsb">Mozilla/4.0 (compatible; MSIE 7.0; Windows Phone OS 7.0; Trident/3.1; IEMobile/7.0) </div><div class="t m0 x0 hb y17bd ff50 fs6 fc0 sc0 ls21 wsb">    Asus;Galaxy6  </div><div class="t m0 x0 hb y17be ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y17bf ff4f fs2 fc0 sc0 ls5 ws4">其中，Windows操作符的标识符与已往完全不同，因此在这个用户代理中client.system.win</div><div class="t m0 x0 h5 y17c0 ff4f fs2 fc0 sc0 ls8 ws1">等于&quot;Ph&quot;。从中可以取得有关系统的更多信息： </div><div class="t m0 x0 hb y17c1 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y17c2 ff50 fs6 fc0 sc0 ls21 wsb">//windows mobile </div><div class="t m0 x0 hb y17c3 ff50 fs6 fc0 sc0 ls21 wsb">if (system.win == &quot;CE&quot;){ </div><div class="t m0 x0 hb y17c4 ff50 fs6 fc0 sc0 ls21 wsb">    system.winMobile = system.win; </div><div class="t m0 x0 hb y17c5 ff50 fs6 fc0 sc0 ls21 wsb">} else if (system.win == &quot;Ph&quot;){ </div><div class="t m0 x0 hb y17c6 ff50 fs6 fc0 sc0 ls21 wsb">    if(/Windows Phone OS (\d+.\d+)/.test(ua)){; </div><div class="t m0 x0 hb y17c7 ff50 fs6 fc0 sc0 ls21 wsb">        system.win = &quot;Phone&quot;; </div><div class="t m0 x0 hb y17c8 ff50 fs6 fc0 sc0 ls21 wsb">        system.winMobile = parseFloat(RegExp[&quot;$1&quot;]); </div><div class="t m0 x0 hb y17c9 ff50 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y17ca ff50 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y17cb ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 yf23 ff4f fs2 fc0 sc0 ls8 ws1">如果system.win的值是&quot;CE&quot;，就说明是老版本的Windows Mobile，因此 system.winMobile</div><div class="t m0 x0 h4 y17cc ff4f fs2 fc0 sc0 ls6 ws6">会被设置为相同的值（只能知道这个信息）。如果system.win的值是&quot;Ph&quot;，那么这个设备就可能是</div></div></div>
<div id="pf103" class="pf w0 h0" data-page-no="103"><div class="pc pc103 w0 h0"><div class="t m0 x2 h2 y1 ff48 fs0 fc0 sc0 ls10 wsc">9.3 用户代理检测    241 </div><div class="t m0 x0 h3 y2 ff48 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff4a fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff4a fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff4a fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff4a fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff4a fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff4a fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff4a fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff4a fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff4a fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff4a fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff4a fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff4a fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff4a fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff48 fs2 fc0 sc0 ls81 ws20f">Windows Phone 7或更新版本。因此就用正则表达式来测试格式并提取版本号，将system.win的值重</div><div class="t m0 x0 hc y4d ff4f fs2 fc0 sc0 ls8 ws1">置为&quot;Phone&quot;，而将system.winMobile设置为版本号。 </div><div class="t m0 x0 h3c y17cd ff4d fs2 fc0 sc0 ls2e wsb">6. 识别游戏系统 </div><div class="t m0 x0 h5 y17ce ff4f fs2 fc0 sc0 ls8 ws1">除了移动设备之外，视频游戏系统中的Web浏览器也开始日益普及。任天堂Wii和Playstation 3 或</div><div class="t m0 x0 h5 y17cf ff4f fs2 fc0 sc0 ls8 ws1">者内置Web浏览器，或者提供了浏览器下载。Wii中的浏览器实际上是定制版的 Opera，是专门为Wii </div><div class="t m0 x0 h5 y17d0 ff48 fs2 fc0 sc0 ls152 ws11e">Remote设计的。Playstation的浏览器是自己开发的，没有基于前面提到的任何呈现引擎。这两个浏览器</div><div class="t m0 x0 h5 y17d1 ff4f fs2 fc0 sc0 ls8 ws1">中的用户代理字符串如下所示： </div><div class="t m0 x5 hb yd44 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yd45 ff50 fs6 fc0 sc0 ls21 wsb">Opera/9.10 (Nintendo Wii;U; ; 1621; en) </div><div class="t m0 x0 hb yd46 ff50 fs6 fc0 sc0 ls21 wsb">Mozilla/5.0 (PLAYSTATION 3; 2.00) </div><div class="t m0 x5 hb y17d2 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y17d3 ff4f fs2 fc0 sc0 ls8 ws1">第一个字符串来自运行在Wii中的Opera，它忠实地继承了Opera最初的用户代理字符串格式（Wii</div><div class="t m0 x0 h5 y17d4 ff4f fs2 fc0 sc0 ls8 ws1">上的Opera不具备隐瞒身份的能力）。第二个字符串来自Playstation3，虽然它为了兼容性而将自己标识</div><div class="t m0 x0 h5 y17d5 ff4f fs2 fc0 sc0 ls3b">为Mozilla 5.0，但并没有给出太多信息。而且，设备名称居然全部使用了大写字母，让人觉得很奇怪；</div><div class="t m0 x0 h5 y17d6 ff4f fs2 fc0 sc0 ls8 ws1">强烈希望将来的版本能够改变这种情况。 </div><div class="t m0 x0 h14 y17d7 ff4f fs2 fc0 sc0 ls8 ws1">在检测这些设备以前，我们必须先为client.system中添加适当的属性，如下所示： </div><div class="t m0 x5 hb y17d8 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y17d9 ff50 fs6 fc0 sc0 ls21 wsb">var client = function(){ </div><div class="t m0 x0 hb y17da ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y17db ff50 fs6 fc0 sc0 ls21 wsb">    var engine = { </div><div class="t m0 x0 hb y17dc ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y17dd ff50 fs6 fc0 sc0 ls21 wsb">        //呈现引擎 </div><div class="t m0 x0 hb y17de ff50 fs6 fc0 sc0 ls21 wsb">        ie: 0, </div><div class="t m0 x0 hb y17df ff50 fs6 fc0 sc0 ls21 wsb">        gecko: 0, </div><div class="t m0 x0 hb y17e0 ff50 fs6 fc0 sc0 ls21 wsb">        webkit: 0, </div><div class="t m0 x0 hb y17e1 ff50 fs6 fc0 sc0 ls21 wsb">        khtml: 0, </div><div class="t m0 x0 hb y17e2 ff50 fs6 fc0 sc0 ls21 wsb">        opera: 0, </div><div class="t m0 x0 hb y17e3 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y17e4 ff50 fs6 fc0 sc0 ls21 wsb">        //具体的版本号 </div><div class="t m0 x0 hb y17e5 ff50 fs6 fc0 sc0 ls21 wsb">        ver: null </div><div class="t m0 x0 hb y17e6 ff50 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 hb y17e7 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y17e8 ff50 fs6 fc0 sc0 ls21 wsb">    var browser = { </div><div class="t m0 x0 hb y17e9 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y17ea ff50 fs6 fc0 sc0 ls21 wsb">        //浏览器 </div><div class="t m0 x0 hb y17eb ff50 fs6 fc0 sc0 ls21 wsb">        ie: 0, </div><div class="t m0 x0 hb y17ec ff50 fs6 fc0 sc0 ls21 wsb">        firefox: 0, </div><div class="t m0 x0 hb y17ed ff50 fs6 fc0 sc0 ls21 wsb">        safari: 0, </div><div class="t m0 x0 hb y17ee ff50 fs6 fc0 sc0 ls21 wsb">        konq: 0, </div><div class="t m0 x0 hb y17ef ff50 fs6 fc0 sc0 ls21 wsb">        opera: 0, </div><div class="t m0 x0 hb y17f0 ff50 fs6 fc0 sc0 ls21 wsb">        chrome: 0, </div><div class="t m0 x0 hb y17f1 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y17f2 ff50 fs6 fc0 sc0 ls21 wsb">        //具体的版本号 </div><div class="t m0 x0 hb y17f3 ff50 fs6 fc0 sc0 ls21 wsb">        ver: null </div><div class="t m0 x0 hb y17f4 ff50 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 hb y17f5 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y17f6 ff50 fs6 fc0 sc0 ls21 wsb">    var system = { </div><div class="t m0 x0 hb y17f7 ff50 fs6 fc0 sc0 ls21 wsb">        win: false, </div><div class="t m0 x0 hb y17f8 ff50 fs6 fc0 sc0 ls21 wsb">        mac: false, </div><div class="t m0 x0 hb y17f9 ff50 fs6 fc0 sc0 ls21 wsb">        x11: false, </div><div class="t m0 x0 hb y17fa ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y17fb ff50 fs6 fc0 sc0 ls21 wsb">        //移动设备 </div><div class="t m0 x0 hb y17fc ff50 fs6 fc0 sc0 ls21 wsb">        iphone: false, </div><div class="t m0 x0 hb y17fd ff50 fs6 fc0 sc0 ls21 wsb">        ipod: false, </div></div></div>
<div id="pf104" class="pf w0 h0" data-page-no="104"><div class="pc pc104 w0 h0"><div class="t m0 x0 h2 y1 ff48 fs0 fc0 sc0 ls7 ws0">242  第9章 客户端检测 </div><div class="t m0 x0 h3 y2 ff48 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y12e1 ff50 fs6 fc0 sc0 ls21 wsb">        ipad: false, </div><div class="t m0 x0 hb y12e2 ff50 fs6 fc0 sc0 ls21 wsb">        ios: false, </div><div class="t m0 x0 hb y12e3 ff50 fs6 fc0 sc0 ls21 wsb">        android: false, </div><div class="t m0 x0 hb y12e4 ff50 fs6 fc0 sc0 ls21 wsb">        nokiaN: false, </div><div class="t m0 x0 hb y12e5 ff50 fs6 fc0 sc0 ls21 wsb">        winMobile: false, </div><div class="t m0 x0 h16 y12e6 ff50 fs6 fc0 sc0 ls21 wsb">        //游戏系统 </div><div class="t m0 x0 h15 y12e7 ff54 fs6 fc0 sc0 ls21 wsb">        wii: false, </div><div class="t m0 x0 h15 y12e8 ff54 fs6 fc0 sc0 ls21 wsb">        ps: false </div><div class="t m0 x0 hb y12e9 ff50 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 hb y12ea ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y12eb ff50 fs6 fc0 sc0 ls21 wsb">    //在此检测呈现引擎、平台和设备 </div><div class="t m0 x0 hb y12ec ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y12ed ff50 fs6 fc0 sc0 ls21 wsb">    return { </div><div class="t m0 x0 hb y12ee ff50 fs6 fc0 sc0 ls21 wsb">        engine: engine, </div><div class="t m0 x0 hb y12ef ff50 fs6 fc0 sc0 ls21 wsb">        browser: browser, </div><div class="t m0 x0 hb y12f0 ff50 fs6 fc0 sc0 ls21 wsb">        system: system </div><div class="t m0 x0 hb y17ff ff50 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 hb y1800 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1801 ff50 fs6 fc0 sc0 ls21 wsb">}();  </div><div class="t m0 x0 h5 y1802 ff4f fs2 fc0 sc0 ls8 ws1">检测前述游戏系统的代码如下： </div><div class="t m0 x0 hb y1803 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1804 ff50 fs6 fc0 sc0 ls21 wsb">system.wii = ua.indexOf(&quot;Wii&quot;) &gt; -1; </div><div class="t m0 x0 hb y1805 ff50 fs6 fc0 sc0 ls21 wsb">system.ps = /playstation/i.test(ua); </div><div class="t m0 x0 hb y1806 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1807 ff4f fs2 fc0 sc0 ls8 ws1">对于Wii，只要检测字符串&quot;Wii&quot;就够了，而其他代码将发现这是一个Opera浏览器，并将正确的</div><div class="t m0 x0 hc y4d4 ff4f fs2 fc0 sc0 ls8 ws1">版本号保存在client.browser.opera中。对于Playstation，我们则使用正则表达式来以不区分大小</div><div class="t m0 x0 h5 y6cf ff4f fs2 fc0 sc0 ls8 ws1">写的方式测试用户代理字符串。 </div><div class="t m0 x0 h20 y1808 ff4d fs3 fc0 sc0 ls4d ws40">9.3.3 完整的代码 </div><div class="t m0 x0 h5 y1809 ff4f fs2 fc0 sc0 ls8 ws1">以下是完整的用户代理字符串检测脚本，包括检测呈现引擎、平台、Windows操作系统、移动设备</div><div class="t m0 x0 h5 y180a ff4f fs2 fc0 sc0 ls8 ws1">和游戏系统。 </div><div class="t m0 x0 hb y180b ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y180c ff50 fs6 fc0 sc0 ls21 wsb">var client = function(){ </div><div class="t m0 x0 hb y180d ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y180e ff50 fs6 fc0 sc0 ls21 wsb">    //呈现引擎 </div><div class="t m0 x0 hb y180f ff50 fs6 fc0 sc0 ls21 wsb">    var engine = {             </div><div class="t m0 x0 hb y1810 ff50 fs6 fc0 sc0 ls21 wsb">        ie: 0, </div><div class="t m0 x0 hb y1811 ff50 fs6 fc0 sc0 ls21 wsb">        gecko: 0, </div><div class="t m0 x0 hb y1812 ff50 fs6 fc0 sc0 ls21 wsb">        webkit: 0, </div><div class="t m0 x0 hb y1813 ff50 fs6 fc0 sc0 ls21 wsb">        khtml: 0, </div><div class="t m0 x0 hb y1814 ff50 fs6 fc0 sc0 ls21 wsb">        opera: 0, </div><div class="t m0 x0 hb y1815 ff50 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 h16 y1816 ff50 fs6 fc0 sc0 ls21 wsb">        //完整的版本号 </div><div class="t m0 x0 hb y1817 ff50 fs6 fc0 sc0 ls21 wsb">        ver: null   </div><div class="t m0 x0 hb y1818 ff50 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 hb y1819 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y181a ff50 fs6 fc0 sc0 ls21 wsb">    //浏览器 </div><div class="t m0 x0 hb y181b ff50 fs6 fc0 sc0 ls21 wsb">    var browser = { </div><div class="t m0 x0 hb y181c ff50 fs6 fc0 sc0 ls21 wsb">         </div><div class="t m0 x0 h16 y181d ff50 fs6 fc0 sc0 ls21 wsb">        //主要浏览器 </div><div class="t m0 x0 hb y181e ff50 fs6 fc0 sc0 ls21 wsb">        ie: 0, </div><div class="t m0 x0 hb y181f ff50 fs6 fc0 sc0 ls21 wsb">        firefox: 0, </div><div class="t m0 x0 hb y1820 ff50 fs6 fc0 sc0 ls21 wsb">        safari: 0, </div><div class="t m0 x0 hb y1821 ff50 fs6 fc0 sc0 ls21 wsb">        konq: 0, </div><div class="t m0 x0 hb y1822 ff50 fs6 fc0 sc0 ls21 wsb">        opera: 0, </div></div></div>
<div id="pf105" class="pf w0 h0" data-page-no="105"><div class="pc pc105 w0 h0"><div class="t m0 x2 h2 y1 ff48 fs0 fc0 sc0 ls10 wsc">9.3 用户代理检测    243 </div><div class="t m0 x0 h3 y2 ff48 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff4a fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff4a fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff4a fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff4a fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff4a fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff4a fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff4a fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff4a fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff4a fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff4a fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff4a fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff4a fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff4a fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y79 ff50 fs6 fc0 sc0 ls21 wsb">        chrome: 0, </div><div class="t m0 x0 hb y7a ff50 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 h16 y7b ff50 fs6 fc0 sc0 ls21 wsb">        //具体的版本号 </div><div class="t m0 x0 hb y7c ff50 fs6 fc0 sc0 ls21 wsb">        ver: null </div><div class="t m0 x0 hb y7d ff50 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 hb y7e ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y7f ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y80 ff50 fs6 fc0 sc0 ls21 wsb">    //平台、设备和操作系统 </div><div class="t m0 x0 hb y81 ff50 fs6 fc0 sc0 ls21 wsb">    var system = { </div><div class="t m0 x0 hb y82 ff50 fs6 fc0 sc0 ls21 wsb">        win: false, </div><div class="t m0 x0 hb y83 ff50 fs6 fc0 sc0 ls21 wsb">        mac: false, </div><div class="t m0 x0 hb y84 ff50 fs6 fc0 sc0 ls21 wsb">        x11: false, </div><div class="t m0 x0 hb y85 ff50 fs6 fc0 sc0 ls21 wsb">         </div><div class="t m0 x0 h16 y86 ff50 fs6 fc0 sc0 ls21 wsb">        //移动设备 </div><div class="t m0 x0 hb y87 ff50 fs6 fc0 sc0 ls21 wsb">        iphone: false, </div><div class="t m0 x0 hb y88 ff50 fs6 fc0 sc0 ls21 wsb">        ipod: false, </div><div class="t m0 x0 hb y89 ff50 fs6 fc0 sc0 ls21 wsb">        ipad: false, </div><div class="t m0 x0 hb y8a ff50 fs6 fc0 sc0 ls21 wsb">        ios: false, </div><div class="t m0 x0 hb y1823 ff50 fs6 fc0 sc0 ls21 wsb">        android: false, </div><div class="t m0 x0 hb y1824 ff50 fs6 fc0 sc0 ls21 wsb">        nokiaN: false, </div><div class="t m0 x0 hb y1825 ff50 fs6 fc0 sc0 ls21 wsb">        winMobile: false, </div><div class="t m0 x0 hb y1826 ff50 fs6 fc0 sc0 ls21 wsb">         </div><div class="t m0 x0 h16 y1827 ff50 fs6 fc0 sc0 ls21 wsb">        //游戏系统 </div><div class="t m0 x0 hb y1828 ff50 fs6 fc0 sc0 ls21 wsb">        wii: false, </div><div class="t m0 x0 hb y1829 ff50 fs6 fc0 sc0 ls21 wsb">        ps: false  </div><div class="t m0 x0 hb y182a ff50 fs6 fc0 sc0 ls21 wsb">    };     </div><div class="t m0 x0 hb y182b ff50 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 h16 y182c ff50 fs6 fc0 sc0 ls21 wsb">    //检测呈现引擎和浏览器 </div><div class="t m0 x0 hb y182d ff50 fs6 fc0 sc0 ls21 wsb">    var ua = navigator.userAgent;     </div><div class="t m0 x0 hb y182e ff50 fs6 fc0 sc0 ls21 wsb">    if (window.opera){ </div><div class="t m0 x0 hb y182f ff50 fs6 fc0 sc0 ls21 wsb">        engine.ver = browser.ver = window.opera.version(); </div><div class="t m0 x0 hb y1830 ff50 fs6 fc0 sc0 ls21 wsb">        engine.opera = browser.opera = parseFloat(engine.ver); </div><div class="t m0 x0 hb y1831 ff50 fs6 fc0 sc0 ls21 wsb">    } else if (/AppleWebKit\/(\S+)/.test(ua)){ </div><div class="t m0 x0 hb y1832 ff50 fs6 fc0 sc0 ls21 wsb">        engine.ver = RegExp[&quot;$1&quot;]; </div><div class="t m0 x0 hb y1833 ff50 fs6 fc0 sc0 ls21 wsb">        engine.webkit = parseFloat(engine.ver); </div><div class="t m0 x0 hb y1834 ff50 fs6 fc0 sc0 ls21 wsb">         </div><div class="t m0 x0 h16 y1835 ff50 fs6 fc0 sc0 ls21 wsb">        //确定是Chrome还是Safari </div><div class="t m0 x0 hb y1836 ff50 fs6 fc0 sc0 ls21 wsb">        if (/Chrome\/(\S+)/.test(ua)){ </div><div class="t m0 x0 hb y1837 ff50 fs6 fc0 sc0 ls21 wsb">            browser.ver = RegExp[&quot;$1&quot;]; </div><div class="t m0 x0 hb y1838 ff50 fs6 fc0 sc0 ls21 wsb">            browser.chrome = parseFloat(browser.ver); </div><div class="t m0 x0 hb y1839 ff50 fs6 fc0 sc0 ls21 wsb">        } else if (/Version\/(\S+)/.test(ua)){ </div><div class="t m0 x0 hb y183a ff50 fs6 fc0 sc0 ls21 wsb">            browser.ver = RegExp[&quot;$1&quot;]; </div><div class="t m0 x0 hb y183b ff50 fs6 fc0 sc0 ls21 wsb">            browser.safari = parseFloat(browser.ver); </div><div class="t m0 x0 hb y183c ff50 fs6 fc0 sc0 ls21 wsb">        } else { </div><div class="t m0 x0 h16 y183d ff50 fs6 fc0 sc0 ls21 wsb">            //近似地确定版本号 </div><div class="t m0 x0 hb y183e ff50 fs6 fc0 sc0 ls21 wsb">            var safariVersion = 1; </div><div class="t m0 x0 hb y183f ff50 fs6 fc0 sc0 ls21 wsb">            if (engine.webkit &lt; 100){ </div><div class="t m0 x0 hb y1840 ff50 fs6 fc0 sc0 ls21 wsb">                safariVersion = 1; </div><div class="t m0 x0 hb y1841 ff50 fs6 fc0 sc0 ls21 wsb">            } else if (engine.webkit &lt; 312){ </div><div class="t m0 x0 hb y1842 ff50 fs6 fc0 sc0 ls21 wsb">                safariVersion = 1.2; </div><div class="t m0 x0 hb y1843 ff50 fs6 fc0 sc0 ls21 wsb">            } else if (engine.webkit &lt; 412){ </div><div class="t m0 x0 hb y1844 ff50 fs6 fc0 sc0 ls21 wsb">                safariVersion = 1.3; </div><div class="t m0 x0 hb y1845 ff50 fs6 fc0 sc0 ls21 wsb">            } else { </div><div class="t m0 x0 hb y1846 ff50 fs6 fc0 sc0 ls21 wsb">                safariVersion = 2; </div><div class="t m0 x0 hb y1847 ff50 fs6 fc0 sc0 ls21 wsb">            }    </div><div class="t m0 x0 hb y1848 ff50 fs6 fc0 sc0 ls21 wsb">             </div><div class="t m0 x0 hb y1849 ff50 fs6 fc0 sc0 ls21 wsb">            browser.safari = browser.ver = safariVersion;         </div><div class="t m0 x0 hb y184a ff50 fs6 fc0 sc0 ls21 wsb">        } </div></div></div>
<div id="pf106" class="pf w0 h0" data-page-no="106"><div class="pc pc106 w0 h0"><div class="t m0 x0 h2 y1 ff48 fs0 fc0 sc0 ls7 ws0">244  第9章 客户端检测 </div><div class="t m0 x0 h3 y2 ff48 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 ff50 fs6 fc0 sc0 ls21 wsb">    } else if (/KHTML\/(\S+)/.test(ua) || /Konqueror\/([^;]+)/.test(ua)){ </div><div class="t m0 x0 hb y7a ff50 fs6 fc0 sc0 ls21 wsb">        engine.ver = browser.ver = RegExp[&quot;$1&quot;]; </div><div class="t m0 x0 hb y7b ff50 fs6 fc0 sc0 ls21 wsb">        engine.khtml = browser.konq = parseFloat(engine.ver); </div><div class="t m0 x0 hb y7c ff50 fs6 fc0 sc0 ls21 wsb">    } else if (/rv:([^\)]+)\) Gecko\/\d{8}/.test(ua)){     </div><div class="t m0 x0 hb y7d ff50 fs6 fc0 sc0 ls21 wsb">        engine.ver = RegExp[&quot;$1&quot;]; </div><div class="t m0 x0 hb y7e ff50 fs6 fc0 sc0 ls21 wsb">        engine.gecko = parseFloat(engine.ver); </div><div class="t m0 x0 hb y7f ff50 fs6 fc0 sc0 ls21 wsb">         </div><div class="t m0 x0 h16 y80 ff50 fs6 fc0 sc0 ls21 wsb">        //确定是不是Firefox </div><div class="t m0 x0 hb y81 ff50 fs6 fc0 sc0 ls21 wsb">        if (/Firefox\/(\S+)/.test(ua)){ </div><div class="t m0 x0 hb y82 ff50 fs6 fc0 sc0 ls21 wsb">            browser.ver = RegExp[&quot;$1&quot;]; </div><div class="t m0 x0 hb y83 ff50 fs6 fc0 sc0 ls21 wsb">            browser.firefox = parseFloat(browser.ver); </div><div class="t m0 x0 hb y84 ff50 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y85 ff50 fs6 fc0 sc0 ls21 wsb">    } else if (/MSIE ([^;]+)/.test(ua)){     </div><div class="t m0 x0 hb y86 ff50 fs6 fc0 sc0 ls21 wsb">        engine.ver = browser.ver = RegExp[&quot;$1&quot;]; </div><div class="t m0 x0 hb y87 ff50 fs6 fc0 sc0 ls21 wsb">        engine.ie = browser.ie = parseFloat(engine.ver); </div><div class="t m0 x0 hb y88 ff50 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y89 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y8a ff50 fs6 fc0 sc0 ls21 wsb">    //检测浏览器 </div><div class="t m0 x0 hb y1823 ff50 fs6 fc0 sc0 ls21 wsb">    browser.ie = engine.ie; </div><div class="t m0 x0 hb y1824 ff50 fs6 fc0 sc0 ls21 wsb">    browser.opera = engine.opera; </div><div class="t m0 x0 hb y1825 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1826 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1827 ff50 fs6 fc0 sc0 ls21 wsb">    //检测平台 </div><div class="t m0 x0 hb y1828 ff50 fs6 fc0 sc0 ls21 wsb">    var p = navigator.platform; </div><div class="t m0 x0 hb y1829 ff50 fs6 fc0 sc0 ls21 wsb">    system.win = p.indexOf(&quot;Win&quot;) == 0; </div><div class="t m0 x0 hb y182a ff50 fs6 fc0 sc0 ls21 wsb">    system.mac = p.indexOf(&quot;Mac&quot;) == 0; </div><div class="t m0 x0 hb y182b ff50 fs6 fc0 sc0 ls21 wsb">    system.x11 = (p == &quot;X11&quot;) || (p.indexOf(&quot;Linux&quot;) == 0); </div><div class="t m0 x0 hb y182c ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y182d ff50 fs6 fc0 sc0 ls21 wsb">    //检测Windows操作系统 </div><div class="t m0 x0 hb y182e ff50 fs6 fc0 sc0 ls21 wsb">    if (system.win){ </div><div class="t m0 x0 hb y182f ff50 fs6 fc0 sc0 ls21 wsb">        if (/Win(?:dows )?([^do]{2})\s?(\d+\.\d+)?/.test(ua)){ </div><div class="t m0 x0 hb y1830 ff50 fs6 fc0 sc0 ls21 wsb">            if (RegExp[&quot;$1&quot;] == &quot;NT&quot;){ </div><div class="t m0 x0 hb y1831 ff50 fs6 fc0 sc0 ls21 wsb">                switch(RegExp[&quot;$2&quot;]){ </div><div class="t m0 x0 hb y1832 ff50 fs6 fc0 sc0 ls21 wsb">                    case &quot;5.0&quot;: </div><div class="t m0 x0 hb y1833 ff50 fs6 fc0 sc0 ls21 wsb">                        system.win = &quot;2000&quot;; </div><div class="t m0 x0 hb y1834 ff50 fs6 fc0 sc0 ls21 wsb">                        break; </div><div class="t m0 x0 hb y1835 ff50 fs6 fc0 sc0 ls21 wsb">                    case &quot;5.1&quot;: </div><div class="t m0 x0 hb y1836 ff50 fs6 fc0 sc0 ls21 wsb">                        system.win = &quot;XP&quot;; </div><div class="t m0 x0 hb y1837 ff50 fs6 fc0 sc0 ls21 wsb">                        break; </div><div class="t m0 x0 hb y1838 ff50 fs6 fc0 sc0 ls21 wsb">                    case &quot;6.0&quot;: </div><div class="t m0 x0 hb y1839 ff50 fs6 fc0 sc0 ls21 wsb">                        system.win = &quot;Vista&quot;; </div><div class="t m0 x0 hb y183a ff50 fs6 fc0 sc0 ls21 wsb">                        break; </div><div class="t m0 x0 hb y183b ff50 fs6 fc0 sc0 ls21 wsb">                    case &quot;6.1&quot;: </div><div class="t m0 x0 hb y183c ff50 fs6 fc0 sc0 ls21 wsb">                        system.win = &quot;7&quot;; </div><div class="t m0 x0 hb y183d ff50 fs6 fc0 sc0 ls21 wsb">                        break; </div><div class="t m0 x0 hb y183e ff50 fs6 fc0 sc0 ls21 wsb">                    default: </div><div class="t m0 x0 hb y183f ff50 fs6 fc0 sc0 ls21 wsb">                        system.win = &quot;NT&quot;; </div><div class="t m0 x0 hb y1840 ff50 fs6 fc0 sc0 ls21 wsb">                        break;                 </div><div class="t m0 x0 hb y1841 ff50 fs6 fc0 sc0 ls21 wsb">                }                             </div><div class="t m0 x0 hb y1842 ff50 fs6 fc0 sc0 ls21 wsb">            } else if (RegExp[&quot;$1&quot;] == &quot;9x&quot;){ </div><div class="t m0 x0 hb y1843 ff50 fs6 fc0 sc0 ls21 wsb">                system.win = &quot;ME&quot;; </div><div class="t m0 x0 hb y1844 ff50 fs6 fc0 sc0 ls21 wsb">            } else { </div><div class="t m0 x0 hb y1845 ff50 fs6 fc0 sc0 ls21 wsb">                system.win = RegExp[&quot;$1&quot;]; </div><div class="t m0 x0 hb y1846 ff50 fs6 fc0 sc0 ls21 wsb">            } </div><div class="t m0 x0 hb y1847 ff50 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y1848 ff50 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y1849 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y184a ff50 fs6 fc0 sc0 ls21 wsb">    //移动设备 </div></div></div>
<div id="pf107" class="pf w0 h0" data-page-no="107"><div class="pc pc107 w0 h0"><div class="t m0 x2 h2 y1 ff48 fs0 fc0 sc0 ls10 wsc">9.3 用户代理检测    245 </div><div class="t m0 x0 h3 y2 ff48 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff4a fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff4a fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff4a fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff4a fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff4a fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff4a fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff4a fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff4a fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff4a fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff4a fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff4a fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff4a fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff4a fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y79 ff50 fs6 fc0 sc0 ls21 wsb">   system.iphone = ua.indexOf(&quot;iPhone&quot;) &gt; -1; </div><div class="t m0 x0 hb y7a ff50 fs6 fc0 sc0 ls21 wsb">   system.ipod = ua.indexOf(&quot;iPod&quot;) &gt; -1; </div><div class="t m0 x0 hb y7b ff50 fs6 fc0 sc0 ls21 wsb">   system.ipad = ua.indexOf(&quot;iPad&quot;) &gt; -1; </div><div class="t m0 x0 hb y7c ff50 fs6 fc0 sc0 ls21 wsb">   system.nokiaN = ua.indexOf(&quot;NokiaN&quot;) &gt; -1; </div><div class="t m0 x0 hb y7d ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y7e ff50 fs6 fc0 sc0 ls21 wsb">   //windows mobile </div><div class="t m0 x0 hb y184b ff50 fs6 fc0 sc0 ls21 wsb"> if (system.win == &quot;CE&quot;){ </div><div class="t m0 x0 hb y184c ff50 fs6 fc0 sc0 ls21 wsb">    system.winMobile = system.win; </div><div class="t m0 x0 hb y184d ff50 fs6 fc0 sc0 ls21 wsb"> } else if (system.win == &quot;Ph&quot;){ </div><div class="t m0 x0 hb y184e ff50 fs6 fc0 sc0 ls21 wsb">    if(/Windows Phone OS (\d+.\d+)/.test(ua)){; </div><div class="t m0 x0 hb y184f ff50 fs6 fc0 sc0 ls241 wsb">     system.win = &quot;Phone&quot;; </div><div class="t m0 x0 hb y1850 ff50 fs6 fc0 sc0 ls243 wsb">    system.winMobile = parseFloat(RegExp[&quot;$1&quot;]); </div><div class="t m0 x0 hb y1851 ff50 fs6 fc0 sc0 ls244 wsb">     } </div><div class="t m0 x0 hb y1852 ff50 fs6 fc0 sc0 ls21 ws212"> } </div><div class="t m0 x0 hb y1853 ff50 fs6 fc0 sc0 ls243 wsb">  </div><div class="t m0 x0 h16 y1854 ff50 fs6 fc0 sc0 ls21 ws212"> //检测iOS版本 </div><div class="t m0 x0 hb y1855 ff50 fs6 fc0 sc0 ls21 wsb"> if (system.mac &amp;&amp; ua.indexOf(&quot;Mobile&quot;) &gt; -1){ </div><div class="t m0 x0 hb y1856 ff50 fs6 fc0 sc0 ls21 wsb">   if (/CPU (?:iPhone )?OS (\d+_\d+)/.test(ua)){ </div><div class="t m0 x0 hb y1857 ff50 fs6 fc0 sc0 ls241 wsb">     system.ios = parseFloat(RegExp.$1.replace(&quot;_&quot;, &quot;.&quot;)); </div><div class="t m0 x0 hb y1858 ff50 fs6 fc0 sc0 ls21 wsb">   } else { </div><div class="t m0 x0 h16 y1859 ff50 fs6 fc0 sc0 ls243 wsb">    system.ios = 2; //不能真正检测出来，所以只能猜测 </div><div class="t m0 x0 hb y185a ff50 fs6 fc0 sc0 ls21 ws212">  } </div><div class="t m0 x0 hb y185b ff50 fs6 fc0 sc0 ls21 ws212"> } </div><div class="t m0 x0 hb y185c ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y185d ff50 fs6 fc0 sc0 ls21 ws212"> //检测Android版本 </div><div class="t m0 x0 hb y185e ff50 fs6 fc0 sc0 ls21 wsb"> if (/Android (\d+\.\d+)/.test(ua)){ </div><div class="t m0 x0 hb y185f ff50 fs6 fc0 sc0 ls21 wsb">    system.android = parseFloat(RegExp.$1); </div><div class="t m0 x0 hb y1860 ff50 fs6 fc0 sc0 ls21 ws212"> } </div><div class="t m0 x0 hb y1861 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1862 ff50 fs6 fc0 sc0 ls21 wsb">    //游戏系统 </div><div class="t m0 x0 hb y1863 ff50 fs6 fc0 sc0 ls21 wsb">    system.wii = ua.indexOf(&quot;Wii&quot;) &gt; -1; </div><div class="t m0 x0 hb y1864 ff50 fs6 fc0 sc0 ls21 wsb">    system.ps = /playstation/i.test(ua); </div><div class="t m0 x0 hb y1865 ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1866 ff50 fs6 fc0 sc0 ls21 wsb">    //返回这些对象 </div><div class="t m0 x0 hb y1867 ff50 fs6 fc0 sc0 ls21 wsb">    return { </div><div class="t m0 x0 hb y1868 ff50 fs6 fc0 sc0 ls21 wsb">        engine:     engine, </div><div class="t m0 x0 hb y1869 ff50 fs6 fc0 sc0 ls21 wsb">        browser:    browser, </div><div class="t m0 x0 hb y186a ff50 fs6 fc0 sc0 ls21 wsb">        system:     system         </div><div class="t m0 x0 hb y186b ff50 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 hb y186c ff50 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y186d ff50 fs6 fc0 sc0 ls21 wsb">}(); </div><div class="t m0 x6 hf y186e ff55 fs2 fc0 sc0 lsb wsb">client.js </div><div class="t m0 x0 h20 y186f ff4d fs3 fc0 sc0 ls4d ws40">9.3.4 使用方法 </div><div class="t m0 x0 h4 y1870 ff4f fs2 fc0 sc0 ls8 ws1">我们在前面已经强调过了，用户代理检测是客户端检测的最后一个选择。只要可能，都应该优先采</div><div class="t m0 x0 h5 y1871 ff4f fs2 fc0 sc0 ls8 ws1">用能力检测和怪癖检测。用户代理检测一般适用于下列情形。 </div><div class="t m0 x0 h4 y1872 ff4e fs1 fc0 sc0 ls2"> 不能直接准确地使用能力检测或怪癖检测。例如，某些浏览器实现了为将来功能预留的存根</div><div class="t m0 x0 h5 y1873 ff4f fs2 fc0 sc0 ls8">（stub）函数。在这种情况下，仅测试相应的函数是否存在还得不到足够的信息。 </div><div class="t m0 x0 h4 y1874 ff4e fs1 fc0 sc0 ls23f"> 同一款浏览器在不同平台下具备不同的能力。这时候，可能就有必要确定浏览器位于哪个平</div><div class="t m0 x5 h5 y1875 ff4f fs2 fc0 sc0 ls24 ws1e">台下。 </div></div></div>
<div id="pf108" class="pf w0 h0" data-page-no="108"><div class="pc pc108 w0 h0"><div class="t m0 x0 h2 y1 ff48 fs0 fc0 sc0 ls7 ws0">246  第9章 客户端检测 </div><div class="t m0 x0 h3 y2 ff48 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff4e fs1 fc0 sc0 ls2"> 为了跟踪分析等目的需要知道确切的浏览器。 </div><div class="t m0 x0 hd y4e ff4d fs7 fc0 sc0 ls22">9.4 小结 </div><div class="t m0 x0 h5 y1876 ff4f fs2 fc0 sc0 ls8 ws1">客户端检测是JavaScript开发中最具争议的一个话题。由于浏览器间存在差别，通常需要根据不同</div><div class="t m0 x0 h5 y1877 ff4f fs2 fc0 sc0 ls8 ws1">浏览器的能力分别编写不同的代码。有不少客户端检测方法，但下列是最经常使用的。 </div><div class="t m0 x0 h4 y128b ff4e fs1 fc0 sc0 ls2"> 能力检测：在编写代码之前先检测特定浏览器的能力。例如，脚本在调用某个函数之前，可能</div><div class="t m0 x0 h4 y128c ff4f fs2 fc0 sc0 ls5 ws4">要先检测该函数是否存在。这种检测方法将开发人员从考虑具体的浏览器类型和版本中解放出</div><div class="t m0 x0 h4 y1878 ff4f fs2 fc0 sc0 ls5 ws4">来，让他们把注意力集中到相应的能力是否存在上。能力检测无法精确地检测特定的浏览器和</div><div class="t m0 x0 h5 y1879 ff4f fs2 fc0 sc0 ls8">版本。 </div><div class="t m0 x0 h5 y8cb ff4e fs1 fc0 sc0 ls2"> 怪癖检测：怪癖实际上是浏览器实现中存在的bug，例如早期的WebKit中就存在一个怪癖，即</div><div class="t m0 x0 h1e y128e ff4f fs2 fc0 sc0 ls8 ws1">它会在for-in循环中返回被隐藏的属性。怪癖检测通常涉及到运行一小段代码，然后确定浏</div><div class="t m0 x0 h4 y8cd ff4f fs2 fc0 sc0 ls5 ws4">览器是否存在某个怪癖。由于怪癖检测与能力检测相比效率更低，因此应该只在某个怪癖会干</div><div class="t m0 x0 h5 y8ce ff4f fs2 fc0 sc0 ls8 ws1">扰脚本运行的情况下使用。怪癖检测无法精确地检测特定的浏览器和版本。 </div><div class="t m0 x0 h4 y187a ff4e fs1 fc0 sc0 ls2"> 用户代理检测：通过检测用户代理字符串来识别浏览器。用户代理字符串中包含大量与浏览器</div><div class="t m0 x0 h4 y187b ff4f fs2 fc0 sc0 ls5 ws4">有关的信息，包括浏览器、平台、操作系统及浏览器版本。用户代理字符串有过一段相当长的</div><div class="t m0 x0 h4 y187c ff4f fs2 fc0 sc0 ls5 ws4">发展历史，在此期间，浏览器提供商试图通过在用户代理字符串中添加一些欺骗性信息，欺骗</div><div class="t m0 x0 h5 y187d ff4f fs2 fc0 sc0 ls8 ws1">网站相信自己的浏览器是另外一种浏览器。用户代理检测需要特殊的技巧，特别是要注意Opera</div><div class="t m0 x0 h4 y187e ff4f fs2 fc0 sc0 ls5 ws4">会隐瞒其用户代理字符串的情况。即便如此，通过用户代理字符串仍然能够检测出浏览器所用</div><div class="t m0 x0 h5 y187f ff4f fs2 fc0 sc0 ls8 ws1">的呈现引擎以及所在的平台，包括移动设备和游戏系统。 </div><div class="t m0 x0 h4 y1880 ff4f fs2 fc0 sc0 ls8 ws1">在决定使用哪种客户端检测方法时，一般应优先考虑使用能力检测。怪癖检测是确定应该如何处理</div><div class="t m0 x0 h4 y1881 ff4f fs2 fc0 sc0 ls8 ws1">代码的第二选择。而用户代理检测则是客户端检测的最后一种方案，因为这种方法对用户代理字符串具</div><div class="t m0 x0 h5 y1882 ff4f fs2 fc0 sc0 ls8 ws1">有很强的依赖性。 </div><div class="t m0 x0 h5 y1883 ff48 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1884 ff48 fs2 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf109" class="pf w0 h0" data-page-no="109"><div class="pc pc109 w0 h0"><div class="t m0 x2 h2 y1 ff57 fs0 fc0 sc0 ls7 ws0">10.1 节点层次    247 </div><div class="t m0 x0 h3 y2 ff57 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff59 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff59 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff59 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff59 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff59 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff59 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff59 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff59 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff59 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff59 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff59 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff59 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff59 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h9 y2a ff5a fs5 fc0 sc0 ls175 wsb">DOM </div><div class="t m0 x0 h3c y2b ff5b fs2 fc0 sc0 ls8">本章内容 </div><div class="t m0 x0 h5 y2c ff5d fs1 fc0 sc0 ls2"> 理解包含不同层次节点的DOM </div><div class="t m0 x0 h5 y2d ff5d fs1 fc0 sc0 ls2"> 使用不同的节点类型 </div><div class="t m0 x0 h5 y2e ff5d fs1 fc0 sc0 ls2"> 克服浏览器兼容性问题及各种陷阱 </div><div class="t m0 x0 h5 y8d9 ff57 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x5 h5 y8da ff57 fs2 fc0 sc0 ls81 ws76">OM（文档对象模型）是针对HTML和XML文档的一个API（应用程序编程接口）。DOM描</div><div class="t m0 x5 h5 y8db ff5e fs2 fc0 sc0 ls24 wsf5">绘了一个层次化的节点树，允许开发人员添加、移除和修改页面的某一部分。DOM脱胎于</div><div class="t m0 x0 h5 y8dc ff57 fs2 fc0 sc0 lsf wsa">Netscape及微软公司创始的DHTML（动态HTML），但现在它已经成为表现和操作页面标记的真正的跨</div><div class="t m0 x0 h5 y8dd ff5e fs2 fc0 sc0 ls8 wseb">平台、语言中立的方式。 </div><div class="t m0 x0 h5 y8de ff57 fs2 fc0 sc0 ls8 ws20">1998年10月DOM１级规范成为W3C的推荐标准，为基本的文档结构及查询提供了接口。本章主</div><div class="t m0 x0 h5 y8df ff5e fs2 fc0 sc0 ls8 wseb">要讨论与浏览器中的HTML页面相关的DOM1级的特性和应用，以及 JavaScript对DOM1级的实现。</div><div class="t m0 x0 h5 y8e0 ff57 fs2 fc0 sc0 lse ws9">IE、Firefox、Safari、Chrome和Opera都非常完善地实现了DOM。 </div><div class="t m0 x5 h5 y1885 ff58 fs2 fc0 sc0 ls8 ws14">注意，IE中的所有DOM对象都是以COM对象的形式实现的。这意味着IE中的</div><div class="t m0 x5 h5 y1886 ff57 fs2 fc0 sc0 ls81 ws76">DOM对象与原生JavaScript对象的行为或活动特点并不一致。本章将较多地谈及这些</div><div class="t m0 x5 h5 y1887 ff58 fs2 fc0 sc0 ls8">差异。 </div><div class="t m0 x0 hd y1888 ff5c fs7 fc0 sc0 ls245">10.1 节点层次 </div><div class="t m0 x0 h5 y1889 ff57 fs2 fc0 sc0 ls81 ws76">DOM可以将任何HTML或XML文档描绘成一个由多层节点构成的结构。节点分为几种不同的类</div><div class="t m0 x0 h4 y188a ff5e fs2 fc0 sc0 ls8 wseb">型，每种类型分别表示文档中不同的信息及（或）标记。每个节点都拥有各自的特点、数据和方法，另</div><div class="t m0 x0 h4 y12a2 ff5e fs2 fc0 sc0 ls8 wseb">外也与其他节点存在某种关系。节点之间的关系构成了层次，而所有页面标记则表现为一个以特定节点</div><div class="t m0 x0 h5 y188b ff5e fs2 fc0 sc0 ls8 wseb">为根节点的树形结构。以下面的HTML为例： </div><div class="t m0 x5 hb y188c ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y188d ff5f fs6 fc0 sc0 ls21 wsb">&lt;html&gt; </div><div class="t m0 x0 hb y188e ff5f fs6 fc0 sc0 ls21 wsb">    &lt;head&gt; </div><div class="t m0 x0 hb y188f ff5f fs6 fc0 sc0 ls21 wsb">        &lt;title&gt;Sample Page&lt;/title&gt; </div><div class="t m0 x0 hb y1890 ff5f fs6 fc0 sc0 ls21 wsb">    &lt;/head&gt; </div><div class="t m0 x0 hb y1891 ff5f fs6 fc0 sc0 ls21 wsb">    &lt;body&gt; </div><div class="t m0 x0 hb y1892 ff5f fs6 fc0 sc0 ls21 wsb">        &lt;p&gt;Hello World!&lt;/p&gt; </div><div class="t m0 x0 hb y1893 ff5f fs6 fc0 sc0 ls21 wsb">    &lt;/body&gt; </div><div class="t m0 x0 hb y1894 ff5f fs6 fc0 sc0 ls21 wsb">&lt;/html&gt; </div><div class="t m0 x5 hb y1895 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1896 ff5e fs2 fc0 sc0 ls8 wseb">可以将这个简单的HTML文档表示为一个层次结构，如图10-1所示。 </div><div class="t m0 x0 h4 y262 ff5e fs2 fc0 sc0 ls5 wsec">文档节点是每个文档的根节点。在这个例子中，文档节点只有一个子节点，即&lt;html&gt;元素，我们</div><div class="t m0 x0 h78 y12c6 ff60 fs11 fc0 sc0 ls246 wsb">D </div><div class="t m0 x0 h11 y4b ff61 fsa fc0 sc0 ls8">第</div><div class="t m1 x0 h12 y4b ff62 fsb fc3 sc0 ls247">10</div><div class="t m0 x5 h11 y4b ff61 fsa fc0 sc0 ls8 ws1d">章 </div></div></div>
<div id="pf10a" class="pf w0 h0" data-page-no="10a"><div class="pc pc10a w0 h0"><div class="t m0 x0 h2 y1 ff57 fs0 fc0 sc0 ls7 ws0">248  第10章 DOM </div><div class="t m0 x0 h3 y2 ff57 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ff5e fs2 fc0 sc0 ls8">称之为文档元素。文档元素是文档的最外层元素，文档中的其他所有元素都包含在文档元素中。每个文</div><div class="t m0 x0 hc y4d ff5e fs2 fc0 sc0 ls8 wseb">档只能有一个文档元素。在HTML页面中，文档元素始终都是&lt;html&gt;元素。在XML 中，没有预定义</div><div class="t m0 x0 h5 y5 ff5e fs2 fc0 sc0 ls8 wseb">的元素，因此任何元素都可能成为文档元素。 </div><div class="t m0 x0 h5 y6 ff5e fs2 fc0 sc0 ls6 wsf7">每一段标记都可以通过树中的一个节点来表示：HTML元素通过元素节点表示，特性（attribute）</div><div class="t m0 x0 h5 y7 ff5e fs2 fc0 sc0 ls8 wseb">通过特性节点表示，文档类型通过文档类型节点表示，而注释则通过注释节点表示。总共有12种节点</div><div class="t m0 x0 h5 y1898 ff5e fs2 fc0 sc0 ls8 wseb">类型，这些类型都继承自一个基类型。 </div><div class="t m0 x2 h5 y1899 ff57 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x7 h3 y189a ff5e fs1 fc0 sc0 ls8 wsb">图 10-1 </div><div class="t m0 x0 h20 y189b ff5c fs3 fc0 sc0 ls248 ws214">10.1.1 Node类型 </div><div class="t m0 x0 h5 y189c ff57 fs2 fc0 sc0 ls24a ws215">DOM1级定义了一个Node接口，该接口将由 DOM中的所有节点类型实现。这个Node接口在</div><div class="t m0 x0 hc y189d ff57 fs2 fc0 sc0 lsb ws5">JavaScript中是作为Node 类型实现的；除了IE之外，在其他所有浏览器中都可以访问到这个类型。</div><div class="t m0 x0 h5 y189e ff57 fs2 fc0 sc0 lsb ws5">JavaScript中的所有节点类型都继承自Node类型，因此所有节点类型都共享着相同的基本属性和方法。 </div><div class="t m0 x0 h1e y189f ff5e fs2 fc0 sc0 ls8 wseb">每个节点都有一个nodeType属性，用于表明节点的类型。节点类型由在Node类型中定义的下列</div><div class="t m0 x0 h5 y18a0 ff57 fs2 fc0 sc0 ls8 ws20">12个数值常量来表示，任何节点类型必居其一： </div><div class="t m0 x0 h5 y18a1 ff5d fs1 fc0 sc0 ls2"> Node.ELEMENT_NODE(1)； </div><div class="t m0 x0 h5 y18a2 ff5d fs1 fc0 sc0 ls2"> Node.ATTRIBUTE_NODE(2)； </div><div class="t m0 x0 h5 y18a3 ff5d fs1 fc0 sc0 ls2"> Node.TEXT_NODE(3)； </div><div class="t m0 x0 h5 y18a4 ff5d fs1 fc0 sc0 ls2"> Node.CDATA_SECTION_NODE(4)； </div><div class="t m0 x0 h5 y18a5 ff5d fs1 fc0 sc0 ls2"> Node.ENTITY_REFERENCE_NODE(5)； </div><div class="t m0 x0 h5 y18a6 ff5d fs1 fc0 sc0 ls2"> Node.ENTITY_NODE(6)； </div><div class="t m0 x0 h5 y18a7 ff5d fs1 fc0 sc0 ls2"> Node.PROCESSING_INSTRUCTION_NODE(7)； </div><div class="t m0 x0 h5 y18a8 ff5d fs1 fc0 sc0 ls2"> Node.COMMENT_NODE(8)； </div></div></div>
<div id="pf10b" class="pf w0 h0" data-page-no="10b"><div class="pc pc10b w0 h0"><div class="t m0 x2 h2 y1 ff57 fs0 fc0 sc0 ls7 ws0">10.1 节点层次    249 </div><div class="t m0 x0 h3 y2 ff57 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff59 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff59 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff59 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff59 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff59 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff59 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff59 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff59 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff59 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff59 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff59 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff59 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff59 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff5d fs1 fc0 sc0 ls2"> Node.DOCUMENT_NODE(9)； </div><div class="t m0 x0 h5 y4 ff5d fs1 fc0 sc0 ls2"> Node.DOCUMENT_TYPE_NODE(10)； </div><div class="t m0 x0 h5 y4e ff5d fs1 fc0 sc0 ls2"> Node.DOCUMENT_FRAGMENT_NODE(11)； </div><div class="t m0 x0 h5 yd9 ff5d fs1 fc0 sc0 ls2"> Node.NOTATION_NODE(12)。 </div><div class="t m0 x0 h5 y15d ff5e fs2 fc0 sc0 ls8 wseb">通过比较上面这些常量，可以很容易地确定节点的类型，例如： </div><div class="t m0 x5 hb y4ef ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h36 yfdc ff5f fs6 fc0 sc0 ls21 wsb">if (someNode.nodeType == Node.ELEMENT_NODE){   //在IE中无效 </div><div class="t m0 x0 hb yfdd ff5f fs6 fc0 sc0 ls21 wsb">    alert(&quot;Node is an element.&quot;); </div><div class="t m0 x0 hb yfde ff5f fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h4 y147c ff5e fs2 fc0 sc0 ls8 wseb">这个例子比较了someNode.nodeType与Node.ELEMENT_NODE常量。如果二者相等，则意味着</div><div class="t m0 x0 h5 y147d ff5f fs1 fc0 sc0 ls9 ws2">someNode确实是一个元素。然而，由于IE没有公开Node 类型的构造函数，因此上面的代码在IE中</div><div class="t m0 x0 hc y147e ff5e fs2 fc0 sc0 ls8 wseb">会导致错误。为了确保跨浏览器兼容，最好还是将nodeType属性与数字值进行比较，如下所示： </div><div class="t m0 x5 hb y18a9 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y18aa ff63 fs6 fc0 sc0 ls21 wsb">if (someNode.nodeType == 1){    //适用于所有浏览器 </div><div class="t m0 x0 hb y18ab ff5f fs6 fc0 sc0 ls21 wsb">    alert(&quot;Node is an element.&quot;); </div><div class="t m0 x0 hb y18ac ff5f fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h5 y18ad ff5e fs2 fc0 sc0 ls8 wseb">并不是所有节点类型都受到Web浏览器的支持。开发人员最常用的就是元素和文本节点。本章后</div><div class="t m0 x0 h5 y18ae ff5e fs2 fc0 sc0 ls8 wseb">面将详细讨论每个节点类型的受支持情况及使用方法。 </div><div class="t m0 x0 h4e y18af ff5c fs2 fc0 sc0 ls2e wsb">1. nodeName和nodeValue属性 </div><div class="t m0 x0 h4 y18b0 ff5e fs2 fc0 sc0 ls8 wseb">要了解节点的具体信息，可以使用nodeName和nodeValue这两个属性。这两个属性的值完全取</div><div class="t m0 x0 h5 y18b1 ff5e fs2 fc0 sc0 ls8 wseb">决于节点的类型。在使用这两个值以前，最好是像下面这样先检测一下节点的类型。 </div><div class="t m0 x5 hb y18b2 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y18b3 ff5f fs6 fc0 sc0 ls21 wsb">if (someNode.nodeType == 1){ </div><div class="t m0 x0 h16 y18b4 ff5f fs6 fc0 sc0 ls21 wsb">    value = someNode.nodeName;    //nodeName的值是元素的标签名 </div><div class="t m0 x0 hb y18b5 ff5f fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h4 y18b6 ff5e fs2 fc0 sc0 ls8 wseb">在这个例子中，首先检查节点类型，看它是不是一个元素。如果是，则取得并保存nodeName的值。</div><div class="t m0 x0 h5 y18b7 ff5e fs2 fc0 sc0 ls8 wseb">对于元素节点，nodeName中保存的始终都是元素的标签名，而nodeValue的值则始终为null。 </div><div class="t m0 x0 h3c y18b8 ff5c fs2 fc0 sc0 ls2e wsb">2. 节点关系 </div><div class="t m0 x0 h4 y18b9 ff5e fs2 fc0 sc0 ls24 wsf5">文档中所有的节点之间都存在这样或那样的关系。节点间的各种关系可以用传统的家族关系来描</div><div class="t m0 x0 h5 y18ba ff5e fs2 fc0 sc0 ls8 wseb">述，相当于把文档树比喻成家谱。在HTML中，可以将&lt;body&gt;元素看成是&lt;html&gt;元素的子元素；相应</div><div class="t m0 x0 h1e yf14 ff5e fs2 fc0 sc0 ls6 wsf7">地，也就可以将&lt;html&gt;元素看成是&lt;body&gt;元素的父元素。而&lt;head&gt;元素，则可以看成是&lt;body&gt;元素</div><div class="t m0 x0 hc y18bb ff5e fs2 fc0 sc0 ls8 wseb">的同胞元素，因为它们都是同一个父元素&lt;html&gt;的直接子元素。 </div><div class="t m0 x0 h4 y18bc ff5e fs2 fc0 sc0 ls8 wseb">每个节点都有一个childNodes属性，其中保存着一个NodeList对象。NodeList是一种类数组</div><div class="t m0 x0 h4 y18bd ff5e fs2 fc0 sc0 ls8 wseb">对象，用于保存一组有序的节点，可以通过位置来访问这些节点。请注意，虽然可以通过方括号语法来</div><div class="t m0 x0 h1c y18be ff5e fs2 fc0 sc0 ls8 wseb">访问NodeList的值，而且这个对象也有length属性，但它并不是Array 的实例。NodeList对象的</div><div class="t m0 x0 h5 y18bf ff5e fs2 fc0 sc0 ls8 wseb">独特之处在于，它实际上是基于DOM结构动态执行查询的结果，因此DOM结构的变化能够自动反映</div><div class="t m0 x0 h1e y18c0 ff5e fs2 fc0 sc0 ls24c">在NodeList对象中。我们常说，NodeList是有生命、有呼吸的对象，而不是在我们第一次访问它们</div><div class="t m0 x0 h5 y18c1 ff5e fs2 fc0 sc0 ls8 wseb">的某个瞬间拍摄下来的一张快照。 </div><div class="t m0 x0 h1c y18c2 ff5e fs2 fc0 sc0 ls8 wseb">下面的例子展示了如何访问保存在NodeList中的节点——可以通过方括号，也可以使用item()</div><div class="t m0 x0 h5 y18c3 ff5e fs2 fc0 sc0 ls8">方法。 </div><div class="t m0 x5 hb y18c4 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y18c5 ff5f fs6 fc0 sc0 ls21 wsb">var firstChild = someNode.childNodes[0]; </div><div class="t m0 x0 hb y18c6 ff5f fs6 fc0 sc0 ls21 wsb">var secondChild = someNode.childNodes.item(1); </div><div class="t m0 x0 hb y18c7 ff5f fs6 fc0 sc0 ls21 wsb">var count = someNode.childNodes.length; </div><div class="t m0 x5 hb y18c8 ff5f fs6 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf10c" class="pf w0 h0" data-page-no="10c"><div class="pc pc10c w0 h0"><div class="t m0 x0 h2 y1 ff57 fs0 fc0 sc0 ls7 ws0">250  第10章 DOM </div><div class="t m0 x0 h3 y2 ff57 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ff5e fs2 fc0 sc0 ls8 wseb">无论使用方括号还是使用item()方法都没有问题，但使用方括号语法看起来与访问数组相似，因</div><div class="t m0 x0 h1e y4d ff5e fs2 fc0 sc0 ls8 wseb">此颇受一些开发人员的青睐。另外，要注意length属性表示的是访问NodeList的那一刻，其中包含</div><div class="t m0 x0 h1e y5 ff5e fs2 fc0 sc0 ls8 wseb">的节点数量。我们在本书前面介绍过，对arguments对象使用Array.prototype.slice()方法可以</div><div class="t m0 x0 h5 yd9 ff5e fs2 fc0 sc0 ls8 wseb">将其转换为数组。而采用同样的方法，也可以将NodeList对象转换为数组。来看下面的例子： </div><div class="t m0 x0 hb ya81 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h36 ya82 ff5f fs6 fc0 sc0 ls21">//在IE8及之前版本中无效 </div><div class="t m0 x0 hb ya83 ff5f fs6 fc0 sc0 ls21 wsb">var arrayOfNodes = Array.prototype.slice.call(someNode.childNodes,0); </div><div class="t m0 x0 hb ya84 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 ya85 ff5e fs2 fc0 sc0 ls8e">除IE8及更早版本之外，这行代码能在任何浏览器中运行。由于IE8及更早版本将 NodeList</div><div class="t m0 x0 h5 ya86 ff5e fs2 fc0 sc0 lsa ws10a">实现为一个COM对象，而我们不能像使用JScript对象那样使用这种对象，因此上面的代码会导致</div><div class="t m0 x0 h5 ya87 ff5e fs2 fc0 sc0 lsa ws10a">错误。要想在IE中将NodeList转换为数组，必须手动枚举所有成员。下列代码在所有浏览器中都</div><div class="t m0 x0 h5 ya88 ff5e fs2 fc0 sc0 lsa ws10a">可以运行： </div><div class="t m0 x0 hb y18c9 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y18ca ff5f fs6 fc0 sc0 ls21 wsb">function convertToArray(nodes){ </div><div class="t m0 x0 hb y18cb ff5f fs6 fc0 sc0 ls21 wsb">    var array = null; </div><div class="t m0 x0 hb y18cc ff5f fs6 fc0 sc0 ls21 wsb">    try { </div><div class="t m0 x0 h36 y18cd ff5f fs6 fc0 sc0 ls21 wsb">        array = Array.prototype.slice.call(nodes, 0); //针对非IE浏览器 </div><div class="t m0 x0 hb y18ce ff5f fs6 fc0 sc0 ls21 wsb">    } catch (ex) { </div><div class="t m0 x0 hb y18cf ff5f fs6 fc0 sc0 ls21 wsb">        array = new Array(); </div><div class="t m0 x0 hb y18d0 ff5f fs6 fc0 sc0 ls21 wsb">        for (var i=0, len=nodes.length; i &lt; len; i++){ </div><div class="t m0 x0 hb y18d1 ff5f fs6 fc0 sc0 ls21 wsb">            array.push(nodes[i]); </div><div class="t m0 x0 hb y18d2 ff5f fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y18d3 ff5f fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y18d4 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y18d5 ff5f fs6 fc0 sc0 ls21 wsb">    return array; </div><div class="t m0 x0 hb y18d6 ff5f fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h4 y1808 ff5e fs2 fc0 sc0 ls30 wsf6">这个convertToArray()函数首先尝试了创建数组的最简单方式。如果导致了错误（说明是在</div><div class="t m0 x0 h5 y18d7 ff57 fs2 fc0 sc0 ls251 ws21a">IE8及更早版本中），则通过try-catch块来捕获错误，然后手动创建数组。这是另一种检测怪癖的</div><div class="t m0 x0 h5 y18d8 ff5e fs2 fc0 sc0 ls24 wsf5">形式。 </div><div class="t m0 x0 h1c y18d9 ff5e fs2 fc0 sc0 ls42 wsf0">每个节点都有一个parentNode属性，该属性指向文档树中的父节点。包含在childNodes列表中</div><div class="t m0 x0 h4 y18da ff5e fs2 fc0 sc0 lsa ws10a">的所有节点都具有相同的父节点，因此它们的parentNode属性都指向同一个节点。此外，包含在</div><div class="t m0 x0 h4 y18db ff5f fs1 fc0 sc0 ls43 ws31">childNodes列表中的每个节点相互之间都是同胞节点。通过使用列表中每个节点的previousSibling</div><div class="t m0 x0 h4 y18dc ff5e fs2 fc0 sc0 ls160">和nextSibling属性，可以访问同一列表中的其他节点。列表中第一个节点的previousSibling属性</div><div class="t m0 x0 hc y18dd ff5e fs2 fc0 sc0 ls44 wsef">值为null，而列表中最后一个节点的nextSibling属性的值同样也为null，如下面的例子所示： </div><div class="t m0 x0 hb y79d ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y18de ff5f fs6 fc0 sc0 ls21 wsb">if (someNode.nextSibling === null){ </div><div class="t m0 x0 hb y18df ff5f fs6 fc0 sc0 ls21 wsb">    alert(&quot;Last node in the parent’s childNodes list.&quot;); </div><div class="t m0 x0 hb y18e0 ff5f fs6 fc0 sc0 ls21 wsb">} else if (someNode.previousSibling === null){ </div><div class="t m0 x0 hb y18e1 ff5f fs6 fc0 sc0 ls21 wsb">    alert(&quot;First node in the parent’s childNodes list.&quot;); </div><div class="t m0 x0 hb y18e2 ff5f fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h5 y18e3 ff5e fs2 fc0 sc0 ls8 wseb">当然，如果列表中只有一个节点，那么该节点的nextSibling和previousSibling都为null。 </div><div class="t m0 x0 h1e y18e4 ff5e fs2 fc0 sc0 ls8 wseb">父节点与其第一个和最后一个子节点之间也存在特殊关系。父节点的firstChild和lastChild</div><div class="t m0 x0 h4 y18e5 ff5e fs2 fc0 sc0 ls8 wseb">属性分别指向其childNodes列表中的第一个和最后一个节点。其中，someNode.firstChild 的值</div><div class="t m0 x0 h1e y18e6 ff5e fs2 fc0 sc0 ls253 ws21b">始终等于someNode.childNodes[0]，而someNode.lastChild 的值始终等于someNode. </div><div class="t m0 x0 h42 y18e7 ff5f fs1 fc0 sc0 ls9 wsb0">childNodes [someNode.childNodes.length-1]。在只有一个子节点的情况下，firstChild和</div><div class="t m0 x0 h4 y18e8 ff5f fs1 fc0 sc0 ls9 ws2">lastChild指向同一个节点。如果没有子节点，那么firstChild和lastChild的值均为 null。明</div><div class="t m0 x0 h5 y18e9 ff5e fs2 fc0 sc0 ls8 wseb">确这些关系能够对我们查找和访问文档结构中的节点提供极大的便利。图10-2形象地展示了上述关系。 </div></div></div>
<div id="pf10d" class="pf w0 h0" data-page-no="10d"><div class="pc pc10d w0 h0"><div class="t m0 x2 h2 y1 ff57 fs0 fc0 sc0 ls7 ws0">10.1 节点层次    251 </div><div class="t m0 x0 h3 y2 ff57 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff59 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff59 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff59 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff59 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff59 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff59 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff59 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff59 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff59 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff59 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff59 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff59 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff59 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x6 h5 y18ea ff57 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 h3 y18eb ff5e fs1 fc0 sc0 ls8 wsb">图 10-2 </div><div class="t m0 x0 h4 y18ec ff5e fs2 fc0 sc0 ls8 wseb">在反映这些关系的所有属性当中，childNodes属性与其他属性相比更方便一些，因为只须使用简</div><div class="t m0 x0 h4 y18ed ff5e fs2 fc0 sc0 ls6 wsf7">单的关系指针，就可以通过它访问文档树中的任何节点。另外，hasChildNodes()也是一个非常有用</div><div class="t m0 x0 h1e y18ee ff5e fs2 fc0 sc0 ls8 wseb">的方法，这个方法在节点包含一或多个子节点的情况下返回true；应该说，这是比查询childNodes</div><div class="t m0 x0 h5 y18ef ff5e fs2 fc0 sc0 ls8 wseb">列表的length属性更简单的方法。 </div><div class="t m0 x0 h1e y18f0 ff5e fs2 fc0 sc0 ls8 wseb">所有节点都有的最后一个属性是ownerDocument，该属性指向表示整个文档的文档节点。这种关</div><div class="t m0 x0 h4 y18f1 ff5e fs2 fc0 sc0 ls8 wseb">系表示的是任何节点都属于它所在的文档，任何节点都不能同时存在于两个或更多个文档中。通过这个</div><div class="t m0 x0 h5 y18f2 ff5e fs2 fc0 sc0 ls8 wseb">属性，我们可以不必在节点层次中通过层层回溯到达顶端，而是可以直接访问文档节点。 </div><div class="t m0 x5 ha y18f3 ff58 fs2 fc0 sc0 ls8 ws14">虽然所有节点类型都继承自Node，但并不是每种节点都有子节点。本章后面将</div><div class="t m0 x5 h5 y18f4 ff58 fs2 fc0 sc0 ls8 ws14">会讨论不同节点类型之间的差异。 </div><div class="t m0 x0 h3c y18f5 ff5c fs2 fc0 sc0 ls2e wsb">3. 操作节点 </div><div class="t m0 x0 h5 y18f6 ff5e fs2 fc0 sc0 ls19 wsfb">因为关系指针都是只读的，所以DOM提供了一些操作节点的方法。其中，最常用的方法是</div><div class="t m0 x0 h4 y18f7 ff5f fs1 fc0 sc0 ls9 ws2">appendChild()，用于向childNodes列表的末尾添加一个节点。添加节点后，childNodes的新增</div><div class="t m0 x0 h4 y18f8 ff5e fs2 fc0 sc0 ls8 wseb">节点、父节点及以前的最后一个子节点的关系指针都会相应地得到更新。更新完成后，appendChild()</div><div class="t m0 x0 h5 y18f9 ff5e fs2 fc0 sc0 ls8 wseb">返回新增的节点。来看下面的例子： </div><div class="t m0 x5 hb y18fa ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y18fb ff5f fs6 fc0 sc0 ls21 wsb">var returnedNode = someNode.appendChild(newNode); </div><div class="t m0 x0 hb y18fc ff5f fs6 fc0 sc0 ls21 wsb">alert(returnedNode == newNode);         //true </div><div class="t m0 x0 hb y18fd ff5f fs6 fc0 sc0 ls21 wsb">alert(someNode.lastChild == newNode);   //true </div><div class="t m0 x5 hb y18fe ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y18ff ff5e fs2 fc0 sc0 ls8 wseb">如果传入到appendChild()中的节点已经是文档的一部分了，那结果就是将该节点从原来的位置</div><div class="t m0 x0 h5 y1900 ff5e fs2 fc0 sc0 ls8 wseb">转移到新位置。即使可以将DOM树看成是由一系列指针连接起来的，但任何DOM节点也不能同时出</div><div class="t m0 x0 h1c y1901 ff5e fs2 fc0 sc0 ls8 wseb">现在文档中的多个位置上。因此，如果在调用appendChild()时传入了父节点的第一个子节点，那么</div><div class="t m0 x0 h5 y1902 ff5e fs2 fc0 sc0 ls8 wseb">该节点就会成为父节点的最后一个子节点，如下面的例子所示。 </div><div class="t m0 x5 hb y1903 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1904 ff5f fs6 fc0 sc0 ls21 ws34">//someNode有多个子节点 </div><div class="t m0 x0 hb y1905 ff5f fs6 fc0 sc0 ls21 wsb">var returnedNode = someNode.appendChild(someNode.firstChild); </div><div class="t m0 x0 hb y1906 ff5f fs6 fc0 sc0 ls21 wsb">alert(returnedNode == someNode.firstChild);      //false </div><div class="t m0 x0 hb y1907 ff5f fs6 fc0 sc0 ls21 wsb">alert(returnedNode == someNode.lastChild);      //true </div></div></div>
<div id="pf10e" class="pf w0 h0" data-page-no="10e"><div class="pc pc10e w0 h0"><div class="t m0 x0 h2 y1 ff57 fs0 fc0 sc0 ls7 ws0">252  第10章 DOM </div><div class="t m0 x0 h3 y2 ff57 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ff5e fs2 fc0 sc0 lsa ws10a">如果需要把节点放在childNodes列表中某个特定的位置上，而不是放在末尾，那么可以使用</div><div class="t m0 x0 h4 y4 ff5f fs1 fc0 sc0 ls9 ws2">insertBefore()方法。这个方法接受两个参数：要插入的节点和作为参照的节点。插入节点后，被插</div><div class="t m0 x0 h1e y5 ff5e fs2 fc0 sc0 ls8 wseb">入的节点会变成参照节点的前一个同胞节点（previousSibling），同时被方法返回。如果参照节点是</div><div class="t m0 x0 h5 yd9 ff5f fs1 fc0 sc0 ls9 ws2">null，则insertBefore()与appendChild()执行相同的操作，如下面的例子所示。 </div><div class="t m0 x0 hb ya81 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 ya82 ff5f fs6 fc0 sc0 ls21">//插入后成为最后一个子节点 </div><div class="t m0 x0 hb ya83 ff5f fs6 fc0 sc0 ls21 wsb">returnedNode = someNode.insertBefore(newNode, null); </div><div class="t m0 x0 hb y1908 ff5f fs6 fc0 sc0 ls21 wsb">alert(newNode == someNode.lastChild);  //true </div><div class="t m0 x0 hb y1909 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y190a ff5f fs6 fc0 sc0 ls21">//插入后成为第一个子节点 </div><div class="t m0 x0 hb y190b ff5f fs6 fc0 sc0 ls21 wsb">var returnedNode = someNode.insertBefore(newNode, someNode.firstChild); </div><div class="t m0 x0 hb y190c ff5f fs6 fc0 sc0 ls21 wsb">alert(returnedNode == newNode);    //true </div><div class="t m0 x0 hb y190d ff5f fs6 fc0 sc0 ls21 wsb">alert(newNode == someNode.firstChild);  //true </div><div class="t m0 x0 hb y190e ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y190f ff5f fs6 fc0 sc0 ls21">//插入到最后一个子节点前面 </div><div class="t m0 x0 hb y1910 ff5f fs6 fc0 sc0 ls21 wsb">returnedNode = someNode.insertBefore(newNode, someNode.lastChild); </div><div class="t m0 x0 hb y1911 ff5f fs6 fc0 sc0 ls21 wsb">alert(newNode == someNode.childNodes[someNode.childNodes.length-2]); //true </div><div class="t m0 x0 hb y1912 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1913 ff5e fs2 fc0 sc0 ls8 wseb">前面介绍的appendChild()和insertBefore()方法都只插入节点，不会移除节点。而下面要介</div><div class="t m0 x0 h1e y1914 ff5e fs2 fc0 sc0 ls8 wseb">绍的replaceChild()方法接受的两个参数是：要插入的节点和要替换的节点。要替换的节点将由这个</div><div class="t m0 x0 h5 y1915 ff5e fs2 fc0 sc0 ls8 wseb">方法返回并从文档树中被移除，同时由要插入的节点占据其位置。来看下面的例子。 </div><div class="t m0 x0 hb y1916 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1917 ff5f fs6 fc0 sc0 ls21">//替换第一个子节点 </div><div class="t m0 x0 hb y1918 ff5f fs6 fc0 sc0 ls21 wsb">var returnedNode = someNode.replaceChild(newNode, someNode.firstChild); </div><div class="t m0 x0 hb y1919 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y191a ff5f fs6 fc0 sc0 ls21">//替换最后一个子节点 </div><div class="t m0 x0 hb y191b ff5f fs6 fc0 sc0 ls21 wsb">returnedNode = someNode.replaceChild(newNode, someNode.lastChild); </div><div class="t m0 x0 hb y191c ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y191d ff5e fs2 fc0 sc0 ls6 wsf7">在使用replaceChild()插入一个节点时，该节点的所有关系指针都会从被它替换的节点复制过</div><div class="t m0 x0 h5 y191e ff5e fs2 fc0 sc0 ls8 wseb">来。尽管从技术上讲，被替换的节点仍然还在文档中，但它在文档中已经没有了自己的位置。 </div><div class="t m0 x0 h1e y191f ff5e fs2 fc0 sc0 ls8 wseb">如果只想移除而非替换节点，可以使用removeChild()方法。这个方法接受一个参数，即要移除</div><div class="t m0 x0 h5 y1920 ff5e fs2 fc0 sc0 ls8 wseb">的节点。被移除的节点将成为方法的返回值，如下面的例子所示。 </div><div class="t m0 x0 hb y1921 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1922 ff5f fs6 fc0 sc0 ls21">//移除第一个子节点 </div><div class="t m0 x0 hb y1923 ff5f fs6 fc0 sc0 ls21 wsb">var formerFirstChild = someNode.removeChild(someNode.firstChild); </div><div class="t m0 x0 hb y1924 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1925 ff5f fs6 fc0 sc0 ls21">//移除最后一个子节点 </div><div class="t m0 x0 hb y1926 ff5f fs6 fc0 sc0 ls21 wsb">var formerLastChild = someNode.removeChild(someNode.lastChild); </div><div class="t m0 x0 hb y1927 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1928 ff5e fs2 fc0 sc0 ls8 wseb">与使用replaceChild()方法一样，通过removeChild()移除的节点仍然为文档所有，只不过在</div><div class="t m0 x0 h5 y1929 ff5e fs2 fc0 sc0 ls8 wseb">文档中已经没有了自己的位置。 </div><div class="t m0 x0 h4 y192a ff5e fs2 fc0 sc0 ls8 wseb">前面介绍的四个方法操作的都是某个节点的子节点，也就是说，要使用这几个方法必须先取得父节</div><div class="t m0 x0 h4b y192b ff5e fs2 fc0 sc0 ls8 wseb">点（使用parentNode属性）。另外，并不是所有类型的节点都有子节点，如果在不支持子节点的节点</div><div class="t m0 x0 h5 y192c ff5e fs2 fc0 sc0 ls8 wseb">上调用了这些方法，将会导致错误发生。 </div><div class="t m0 x0 h3c y192d ff5c fs2 fc0 sc0 ls2e wsb">4. 其他方法 </div><div class="t m0 x0 h4 y192e ff5e fs2 fc0 sc0 ls8 wseb">有两个方法是所有类型的节点都有的。第一个就是cloneNode()，用于创建调用这个方法的节点</div><div class="t m0 x0 h1e y11aa ff5e fs2 fc0 sc0 ls8 wseb">的一个完全相同的副本。cloneNode()方法接受一个布尔值参数，表示是否执行深复制。在参数为true</div><div class="t m0 x0 h4 y192f ff5e fs2 fc0 sc0 ls8 wseb">的情况下，执行深复制，也就是复制节点及其整个子节点树；在参数为false的情况下，执行浅复制，</div><div class="t m0 x0 h4 y11ac ff5e fs2 fc0 sc0 ls8 wseb">即只复制节点本身。复制后返回的节点副本属于文档所有，但并没有为它指定父节点。因此，这个节点</div><div class="t m0 x0 h1e y1930 ff5e fs2 fc0 sc0 ls8 wseb">副本就成为了一个“孤儿”，除非通过appendChild()、insertBefore()或replaceChild()将它</div></div></div>
<div id="pf10f" class="pf w0 h0" data-page-no="10f"><div class="pc pc10f w0 h0"><div class="t m0 x2 h2 y1 ff57 fs0 fc0 sc0 ls7 ws0">10.1 节点层次    253 </div><div class="t m0 x0 h3 y2 ff57 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff59 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff59 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff59 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff59 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff59 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff59 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff59 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff59 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff59 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff59 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff59 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff59 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff59 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff5e fs2 fc0 sc0 ls8 wseb">添加到文档中。例如，假设有下面的HTML代码。 </div><div class="t m0 x5 hb yfb2 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yfb3 ff5f fs6 fc0 sc0 ls21 wsb">&lt;ul&gt; </div><div class="t m0 x0 hb yfb4 ff5f fs6 fc0 sc0 ls21 wsb">    &lt;li&gt;item 1&lt;/li&gt; </div><div class="t m0 x0 hb yfb5 ff5f fs6 fc0 sc0 ls21 wsb">    &lt;li&gt;item 2&lt;/li&gt; </div><div class="t m0 x0 hb yfb6 ff5f fs6 fc0 sc0 ls21 wsb">    &lt;li&gt;item 3&lt;/li&gt; </div><div class="t m0 x0 hb yfb7 ff5f fs6 fc0 sc0 ls21 wsb">&lt;/ul&gt; </div><div class="t m0 x5 hb y1931 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1932 ff5e fs2 fc0 sc0 lsa ws10a">如果我们已经将&lt;ul&gt;元素的引用保存在了变量myList中，那么通常下列代码就可以看出使用</div><div class="t m0 x0 h5 y13fd ff5f fs1 fc0 sc0 ls9 ws2">cloneNode()方法的两种模式。 </div><div class="t m0 x5 hb y1933 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1934 ff5f fs6 fc0 sc0 ls21 wsb">var deepList = myList.cloneNode(true); </div><div class="t m0 x0 h16 y1935 ff5f fs6 fc0 sc0 ls21 wsb">alert(deepList.childNodes.length);   //3（IE &lt; 9）或7（其他浏览器） </div><div class="t m0 x0 hb y1936 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1937 ff5f fs6 fc0 sc0 ls21 wsb">var shallowList = myList.cloneNode(false); </div><div class="t m0 x0 hb y1938 ff5f fs6 fc0 sc0 ls21 wsb">alert(shallowList.childNodes.length);  //0 </div><div class="t m0 x5 hb y1939 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y18eb ff5e fs2 fc0 sc0 ls8 wseb">在这个例子中，deepList中保存着一个对myList执行深复制得到的副本。因此，deepList中</div><div class="t m0 x0 h5 y193a ff5e fs2 fc0 sc0 ls8 wseb">包含3个列表项，每个列表项中都包含文本。而变量shallowList中保存着对myList 执行浅复制得</div><div class="t m0 x0 hc y193b ff5e fs2 fc0 sc0 ls8 wseb">到的副本，因此它不包含子节点。deepList.childNodes.length中的差异主要是因为IE8及更早版</div><div class="t m0 x0 h5 y5d3 ff5e fs2 fc0 sc0 ls8 wseb">本与其他浏览器处理空白字符的方式不一样。IE9之前的版本不会为空白符创建节点。 </div><div class="t m0 x5 h5 y193c ff5f fs1 fc0 sc0 ls9 ws2">cloneNode()方法不会复制添加到DOM节点中的JavaScript属性，例如事件处</div><div class="t m0 x5 ha y193d ff58 fs2 fc0 sc0 ls8 ws14">理程序等。这个方法只复制特性、（在明确指定的情况下也复制）子节点，其他一切</div><div class="t m0 x5 h5 y193e ff58 fs2 fc0 sc0 ls8 ws14">都不会复制。IE在此存在一个bug，即它会复制事件处理程序，所以我们建议在复制</div><div class="t m0 x5 h5 y193f ff58 fs2 fc0 sc0 ls8 ws14">之前最好先移除事件处理程序。 </div><div class="t m0 x0 h4 y1940 ff5e fs2 fc0 sc0 ls8 wseb">我们要介绍的最后一个方法是normalize()，这个方法唯一的作用就是处理文档树中的文本节点。</div><div class="t m0 x0 h5 y154f ff5e fs2 fc0 sc0 ls8 wseb">由于解析器的实现或DOM操作等原因，可能会出现文本节点不包含文本，或者接连出现两个文本节点</div><div class="t m0 x0 h4 y1941 ff5e fs2 fc0 sc0 ls8 wseb">的情况。当在某个节点上调用这个方法时，就会在该节点的后代节点中查找上述两种情况。如果找到了</div><div class="t m0 x0 h4 y1942 ff5e fs2 fc0 sc0 ls8 wseb">空文本节点，则删除它；如果找到相邻的文本节点，则将它们合并为一个文本节点。本章后面还将进一</div><div class="t m0 x0 h5 y1943 ff5e fs2 fc0 sc0 ls8 wseb">步讨论这个方法。 </div><div class="t m0 x0 h20 yd13 ff5c fs3 fc0 sc0 ls248 ws214">10.1.2 Document类型 </div><div class="t m0 x0 h5 y1944 ff57 fs2 fc0 sc0 lsb ws5">JavaScript通过Document类型表示文档。在浏览器中，document 对象是HTMLDocument（继承</div><div class="t m0 x0 hc y1945 ff5e fs2 fc0 sc0 lsd9">自Document类型）的一个实例，表示整个HTML页面。而且，document对象是window对象的一个</div><div class="t m0 x0 hc y1946 ff5e fs2 fc0 sc0 ls8 wseb">属性，因此可以将其作为全局对象来访问。Document节点具有下列特征： </div><div class="t m0 x0 h5 y1947 ff5d fs1 fc0 sc0 ls2"> nodeType的值为9； </div><div class="t m0 x0 h5 y1948 ff5d fs1 fc0 sc0 ls2"> nodeName的值为&quot;#document&quot;； </div><div class="t m0 x0 h5 y1949 ff5d fs1 fc0 sc0 ls2"> nodeValue的值为null； </div><div class="t m0 x0 h5 y194a ff5d fs1 fc0 sc0 ls2"> parentNode的值为null； </div><div class="t m0 x0 h5 y194b ff5d fs1 fc0 sc0 ls2"> ownerDocument的值为 null； </div><div class="t m0 x0 h4 y194c ff5d fs1 fc0 sc0 ls2"> 其子节点可能是一个DocumentType（最多一个）、Element（最多一个）、ProcessingInstruction</div><div class="t m0 x5 h5 y194d ff5e fs2 fc0 sc0 ls2c">或Comment。 </div></div></div>
<div id="pf110" class="pf w0 h0" data-page-no="110"><div class="pc pc110 w0 h0"><div class="t m0 x0 h2 y1 ff57 fs0 fc0 sc0 ls7 ws0">254  第10章 DOM </div><div class="t m0 x0 h3 y2 ff57 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff5f fs1 fc0 sc0 ls9 ws2">Document类型可以表示HTML 页面或者其他基于XML的文档。不过，最常见的应用还是作为</div><div class="t m0 x0 h4 y4 ff5f fs1 fc0 sc0 ls9 ws2">HTMLDocument实例的document对象。通过这个文档对象，不仅可以取得与页面有关的信息，而且还</div><div class="t m0 x0 h5 y5 ff5e fs2 fc0 sc0 ls8 wseb">能操作页面的外观及其底层结构。 </div><div class="t m0 x5 h5 y194f ff58 fs2 fc0 sc0 ls3b">在Firefox、Safari、Chrome和Opera中，可以通过脚本访问Document类型的构</div><div class="t m0 x0 ha y59f ff58 fs2 fc0 sc0 ls8 ws14">造函数和原型。但在所有浏览器中都可以访问HTMLDocument类型的构造函数和原型，</div><div class="t m0 x0 h5 y1950 ff58 fs2 fc0 sc0 ls5f wsdd">包括IE8及后续版本。 </div><div class="t m0 x0 h3c y1951 ff5c fs2 fc0 sc0 ls2e wsb">1. 文档的子节点 </div><div class="t m0 x0 h5 y1952 ff5e fs2 fc0 sc0 ls8 wseb">虽然DOM标准规定Document节点的子节点可以是DocumentType、Element、ProcessingIn- </div><div class="t m0 x0 h4 y1953 ff5f fs1 fc0 sc0 ls9 ws2">struction或Comment，但还有两个内置的访问其子节点的快捷方式。第一个就是documentElement</div><div class="t m0 x0 h5 y1954 ff5e fs2 fc0 sc0 ls8 wseb">属性，该属性始终指向HTML页面中的&lt;html&gt;元素。另一个就是通过childNodes列表访问文档元素，</div><div class="t m0 x0 hc y1955 ff5e fs2 fc0 sc0 ls8 wseb">但通过documentElement属性则能更快捷、更直接地访问该元素。以下面这个简单的页面为例。 </div><div class="t m0 x0 hb ya8d ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1956 ff5f fs6 fc0 sc0 ls21 wsb">&lt;html&gt; </div><div class="t m0 x0 hb y1957 ff5f fs6 fc0 sc0 ls21 wsb">    &lt;body&gt; </div><div class="t m0 x0 hb y1958 ff5f fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 hb y1959 ff5f fs6 fc0 sc0 ls21 wsb">    &lt;/body&gt; </div><div class="t m0 x0 hb y195a ff5f fs6 fc0 sc0 ls21 wsb">&lt;/html&gt; </div><div class="t m0 x0 hb y195b ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y195c ff5e fs2 fc0 sc0 ls221 ws21e">这个页面在经过浏览器解析后，其文档中只包含一个子节点，即&lt;html&gt;元素。可以通过</div><div class="t m0 x0 h5 y195d ff5f fs1 fc0 sc0 ls9 ws2">documentElement或childNodes列表来访问这个元素，如下所示。 </div><div class="t m0 x0 hb y195e ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y195f ff5f fs6 fc0 sc0 ls21 wsb">var html = document.documentElement;      //取得对&lt;html&gt;的引用 </div><div class="t m0 x0 hb y1960 ff5f fs6 fc0 sc0 ls21 wsb">alert(html === document.childNodes[0]);     //true </div><div class="t m0 x0 hb y1961 ff5f fs6 fc0 sc0 ls21 wsb">alert(html === document.firstChild);      //true </div><div class="t m0 x0 hb y1962 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1963 ff5e fs2 fc0 sc0 ls8 wseb">这个例子说明，documentElement、firstChild和childNodes[0]的值相同，都指向&lt;html&gt;</div><div class="t m0 x0 h5 y1964 ff5e fs2 fc0 sc0 ls8">元素。 </div><div class="t m0 x0 h1e y1965 ff5e fs2 fc0 sc0 ls5f ws10b">作为HTMLDocument的实例，document对象还有一个body 属性，直接指向&lt;body&gt;元素。因为开</div><div class="t m0 x0 hc y1966 ff5e fs2 fc0 sc0 ls5f ws10b">发人员经常要使用这个元素，所以document.body在JavaScript代码中出现的频率非常高，其用法如下。 </div><div class="t m0 x0 h16 y1967 ff5f fs6 fc0 sc0 ls21 wsb">var body = document.body;    //取得对&lt;body&gt;的引用 </div><div class="t m0 x0 h5 y1968 ff5e fs2 fc0 sc0 ls8 wseb">所有浏览器都支持document.documentElement和document.body属性。 </div><div class="t m0 x0 h4 y1969 ff5f fs1 fc0 sc0 ls9 ws2">Document另一个可能的子节点是DocumentType。通常将&lt;!DOCTYPE&gt;标签看成一个与文档其他</div><div class="t m0 x0 hc y196a ff5e fs2 fc0 sc0 ls8 wseb">部分不同的实体，可以通过doctype属性（在浏览器中是document.doctype）来访问它的信息。 </div><div class="t m0 x0 h16 y196b ff5f fs6 fc0 sc0 ls21 wsb">var doctype = document.doctype;     //取得对&lt;!DOCTYPE&gt;的引用 </div><div class="t m0 x0 h5 y196c ff5e fs2 fc0 sc0 ls8 wseb">浏览器对document.doctype的支持差别很大，可以给出如下总结。 </div><div class="t m0 x0 h5 y196d ff5d fs1 fc0 sc0 ls2"> IE8及之前版本：如果存在文档类型声明，会将其错误地解释为一个注释并把它当作Comment</div><div class="t m0 x0 h5 y196e ff5e fs2 fc0 sc0 ls8 wseb">节点；而document.doctype的值始终为null。 </div><div class="t m0 x0 h5 y196f ff5d fs1 fc0 sc0 ls8 ws134"> IE9+及Firefox：如果存在文档类型声明，则将其作为文档的第一个子节点；document.doctype</div><div class="t m0 x0 h4 y1970 ff5e fs2 fc0 sc0 ls1f ws108">是一个DocumentType节点，也可以通过document.firstChild或document.childNodes[0]</div><div class="t m0 x0 h5 y1971 ff5e fs2 fc0 sc0 ls42 wsf0">访问同一个节点。 </div><div class="t m0 x0 h5 y1972 ff5d fs1 fc0 sc0 ls8 ws134"> Safari、Chrome和Opera：如果存在文档类型声明，则将其解析，但不作为文档的子节点。docu- </div><div class="t m0 x0 h21 y1973 ff5f fs1 fc0 sc0 ls43 ws31">ment.doctype是一个DocumentType节点，但该节点不会出现在document.childNodes中。 </div></div></div>
<div id="pf111" class="pf w0 h0" data-page-no="111"><div class="pc pc111 w0 h0"><div class="t m0 x2 h2 y1 ff57 fs0 fc0 sc0 ls7 ws0">10.1 节点层次    255 </div><div class="t m0 x0 h3 y2 ff57 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff59 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff59 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff59 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff59 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff59 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff59 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff59 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff59 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff59 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff59 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff59 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff59 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff59 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff5e fs2 fc0 sc0 ls8 wseb">由于浏览器对document.doctype的支持不一致，因此这个属性的用处很有限。 </div><div class="t m0 x0 h1e y4d ff5e fs2 fc0 sc0 ls5 wsec">从技术上说，出现在&lt;html&gt;元素外部的注释应该算是文档的子节点。然而，不同的浏览器在是否</div><div class="t m0 x0 h5 y5 ff5e fs2 fc0 sc0 ls8 wseb">解析这些注释以及能否正确处理它们等方面，也存在很大差异。以下面简单的HTML页面为例。 </div><div class="t m0 x5 hb y6bd ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y6be ff5f fs6 fc0 sc0 ls21">&lt;!--第一条注释 --&gt; </div><div class="t m0 x0 hb y6bf ff5f fs6 fc0 sc0 ls21 wsb">&lt;html&gt; </div><div class="t m0 x0 hb y6c0 ff5f fs6 fc0 sc0 ls21 wsb">    &lt;body&gt; </div><div class="t m0 x0 hb y6c1 ff5f fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 hb y6c2 ff5f fs6 fc0 sc0 ls21 wsb">    &lt;/body&gt; </div><div class="t m0 x0 hb y6c3 ff5f fs6 fc0 sc0 ls21 wsb">&lt;/html&gt; </div><div class="t m0 x0 h16 y6c4 ff5f fs6 fc0 sc0 ls21">&lt;!--第二条注释 --&gt; </div><div class="t m0 x5 hb y6c5 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1974 ff5e fs2 fc0 sc0 ls26 ws101">看起来这个页面应该有3个子节点：注释、&lt;html&gt;元素、注释。从逻辑上讲，我们会认为</div><div class="t m0 x0 h5 y1975 ff5f fs1 fc0 sc0 ls9 ws2">document.childNodes中应该包含与这3个节点对应的 3项。但是，现实中的浏览器在处理位于</div><div class="t m0 x0 h5 y1976 ff5f fs1 fc0 sc0 ls9 ws2">&lt;html&gt;外部的注释方面存在如下差异。 </div><div class="t m0 x0 h5 y1751 ff5d fs1 fc0 sc0 ls2"> IE8及之前版本、Safari 3.1及更高版本、Opera和Chrome只为第一条注释创建节点，不为第二</div><div class="t m0 x5 hc y1752 ff5e fs2 fc0 sc0 ls8 wseb">条注释创建节点。结果，第一条注释就会成为document.childNodes中的第一个子节点。 </div><div class="t m0 x0 h5 y1977 ff5d fs1 fc0 sc0 ls2"> IE9及更高版本会将第一条注释创建为document.childNodes中的一个注释节点，也会将第</div><div class="t m0 x5 hc y1978 ff5e fs2 fc0 sc0 ls8 wseb">二条注释创建为document.childNodes中的注释子节点。 </div><div class="t m0 x0 h5 y18e ff5d fs1 fc0 sc0 ls2"> Firefox以及Safari 3.1之前的版本会完全忽略这两条注释。 </div><div class="t m0 x0 hc y1979 ff5e fs2 fc0 sc0 ls8 wseb">同样，浏览器间的这种不一致性也导致了位于&lt;html&gt;元素外部的注释没有什么用处。 </div><div class="t m0 x0 h1e y197a ff5e fs2 fc0 sc0 lsed ws221">多数情况下，我们都用不着在document对象上调用 appendChild()、removeChild()和</div><div class="t m0 x0 h4 y197b ff5f fs1 fc0 sc0 ls9 ws2">replaceChild()方法，因为文档类型（如果存在的话）是只读的，而且它只能有一个元素子节点（该</div><div class="t m0 x0 h5 ye45 ff5e fs2 fc0 sc0 ls8 wseb">节点通常早就已经存在了）。 </div><div class="t m0 x0 h3c y197c ff5c fs2 fc0 sc0 ls2e wsb">2. 文档信息 </div><div class="t m0 x0 h4 y197d ff5e fs2 fc0 sc0 ls8 wseb">作为HTMLDocument的一个实例，document对象还有一些标准的Document 对象所没有的属性。</div><div class="t m0 x0 h1e y197e ff5e fs2 fc0 sc0 ls60 ws140">这些属性提供了document对象所表现的网页的一些信息。其中第一个属性就是 title，包含着</div><div class="t m0 x0 h4 y197f ff5f fs1 fc0 sc0 ls9 ws2">&lt;title&gt;元素中的文本——显示在浏览器窗口的标题栏或标签页上。通过这个属性可以取得当前页面的</div><div class="t m0 x0 h1e y1980 ff5e fs2 fc0 sc0 ls8 wseb">标题，也可以修改当前页面的标题并反映在浏览器的标题栏中。修改title属性的值不会改变&lt;title&gt;</div><div class="t m0 x0 h5 y6ac ff5e fs2 fc0 sc0 ls8 wseb">元素。来看下面的例子。 </div><div class="t m0 x5 hb y1981 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1982 ff5f fs6 fc0 sc0 ls21">//取得文档标题 </div><div class="t m0 x0 hb y1983 ff5f fs6 fc0 sc0 ls21 wsb">var originalTitle = document.title; </div><div class="t m0 x0 hb y1984 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1985 ff5f fs6 fc0 sc0 ls21">//设置文档标题 </div><div class="t m0 x0 hb y1986 ff5f fs6 fc0 sc0 ls21 wsb">document.title = &quot;New page title&quot;; </div><div class="t m0 x5 hb y1987 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1988 ff5e fs2 fc0 sc0 ls8 wseb">接下来要介绍的3个属性都与对网页的请求有关，它们是URL、domain和referrer。URL 属性</div><div class="t m0 x0 h5 y1989 ff5e fs2 fc0 sc0 ls8 wseb">中包含页面完整的URL（即地址栏中显示的URL），domain属性中只包含页面的域名，而referrer</div><div class="t m0 x0 h5 y198a ff5e fs2 fc0 sc0 ls8 wseb">属性中则保存着链接到当前页面的那个页面的URL。在没有来源页面的情况下，referrer属性中可能</div><div class="t m0 x0 h5 y198b ff5e fs2 fc0 sc0 ls55 wsfc">会包含空字符串。所有这些信息都存在于请求的HTTP头部，只不过是通过这些属性让我们能够在</div><div class="t m0 x0 h5 y198c ff57 fs2 fc0 sc0 ls138 ws133">JavaScrip中访问它们而已，如下面的例子所示。 </div><div class="t m0 x5 hb y37d ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h36 y198d ff5f fs6 fc0 sc0 ls21">//取得完整的URL </div><div class="t m0 x0 hb y198e ff5f fs6 fc0 sc0 ls21 wsb">var url = document.URL; </div><div class="t m0 x0 hb y198f ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1990 ff5f fs6 fc0 sc0 ls21">//取得域名 </div></div></div>
<div id="pf112" class="pf w0 h0" data-page-no="112"><div class="pc pc112 w0 h0"><div class="t m0 x0 h2 y1 ff57 fs0 fc0 sc0 ls7 ws0">256  第10章 DOM </div><div class="t m0 x0 h3 y2 ff57 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 ff5f fs6 fc0 sc0 ls21 wsb">var domain = document.domain; </div><div class="t m0 x0 hb y7a ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h36 y7b ff5f fs6 fc0 sc0 ls21">//取得来源页面的URL </div><div class="t m0 x0 hb y7c ff5f fs6 fc0 sc0 ls21 wsb">var referrer = document.referrer; </div><div class="t m0 x0 hb y1991 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y142b ff5f fs1 fc0 sc0 ls9 ws2">URL与domain属性是相互关联的。例如，如果document.URL等于http://www.wrox.com/WileyCDA/， </div><div class="t m0 x0 hc y1992 ff5e fs2 fc0 sc0 ls8 wseb">那么document.domain就等于www.wrox.com。 </div><div class="t m0 x0 h5 y142d ff5e fs2 fc0 sc0 ls8 wseb">在这3个属性中，只有domain是可以设置的。但由于安全方面的限制，也并非可以给domain设</div><div class="t m0 x0 h5 y142e ff5e fs2 fc0 sc0 ls8 wseb">置任何值。如果URL中包含一个子域名，例如p2p.wrox.com，那么就只能将domain设置为&quot;wrox.com&quot;</div><div class="t m0 x0 h5 y1993 ff5e fs2 fc0 sc0 ls8">（URL中包含&quot;www&quot;，如www.wrox.com时，也是如此）。不能将这个属性设置为URL中不包含的域，</div><div class="t m0 x0 h5 y1994 ff5e fs2 fc0 sc0 ls8 wseb">如下面的例子所示。 </div><div class="t m0 x0 hb y1995 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1996 ff5f fs6 fc0 sc0 ls21">//假设页面来自p2p.wrox.com域 </div><div class="t m0 x0 hb y1997 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1998 ff5f fs6 fc0 sc0 ls21 wsb">document.domain = &quot;wrox.com&quot;;          // 成功 </div><div class="t m0 x0 hb y1999 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y199a ff5f fs6 fc0 sc0 ls21 wsb">document.domain = &quot;nczonline.net&quot;;      // 出错！ </div><div class="t m0 x0 hb y199b ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y6ca ff5e fs2 fc0 sc0 ls8 wseb">当页面中包含来自其他子域的框架或内嵌框架时，能够设置document.domain就非常方便了。由</div><div class="t m0 x0 h5 y6cb ff5e fs2 fc0 sc0 ls253 ws21b">于跨域安全限制，来自不同子域的页面无法通过JavaScript通信。而通过将每个页面的</div><div class="t m0 x0 h5 y199c ff5f fs1 fc0 sc0 ls9 ws2">document.domain设置为相同的值，这些页面就可以互相访问对方包含的JavaScript对象了。例如，</div><div class="t m0 x0 h5 y199d ff5e fs2 fc0 sc0 ls8 wseb">假设有一个页面加载自www.wrox.com，其中包含一个内嵌框架，框架内的页面加载自p2p.wrox.com。</div><div class="t m0 x0 he y199e ff5e fs2 fc0 sc0 ls8 wseb">由于document.domain字符串不一样，内外两个页面之间无法相互访问对方的JavaScript对象。但如</div><div class="t m0 x0 hc y199f ff5e fs2 fc0 sc0 ls8 wseb">果将这两个页面的document.domain值都设置为&quot;wrox.com&quot;，它们之间就可以通信了。 </div><div class="t m0 x0 h5 y19a0 ff5e fs2 fc0 sc0 ls8 wseb">浏览器对domain属性还有一个限制，即如果域名一开始是“松散的”（loose），那么不能将它再设</div><div class="t m0 x0 h5 y19a1 ff5e fs2 fc0 sc0 ls8 wseb">置为“紧绷的”（tight）。换句话说，在将document.domain设置为&quot;wrox.com&quot;之后，就不能再将其</div><div class="t m0 x0 hc y806 ff5e fs2 fc0 sc0 ls8 wseb">设置回&quot;p2p.wrox.com&quot;，否则将会导致错误，如下面的例子所示。 </div><div class="t m0 x0 hb y19a2 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y19a3 ff5f fs6 fc0 sc0 ls21">//假设页面来自于p2p.wrox.com域 </div><div class="t m0 x0 hb y19a4 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y19a5 ff5f fs6 fc0 sc0 ls21 wsb">document.domain = &quot;wrox.com&quot;;         //松散的（成功） </div><div class="t m0 x0 hb y19a6 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y19a7 ff5f fs6 fc0 sc0 ls21 wsb">document.domain = &quot;p2p.wrox.com&quot;;     //紧绷的（出错！） </div><div class="t m0 x0 hb y19a8 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y19a9 ff5e fs2 fc0 sc0 ls8 wseb">所有浏览器中都存在这个限制，但IE8是实现这一限制的最早的IE版本。 </div><div class="t m0 x0 h3c y19aa ff5c fs2 fc0 sc0 ls2e wsb">3. 查找元素 </div><div class="t m0 x0 h5 y19ab ff5e fs2 fc0 sc0 ls8 wseb">说到最常见的DOM应用，恐怕就要数取得特定的某个或某组元素的引用，然后再执行一些操作了。</div><div class="t m0 x0 h4 y19ac ff5e fs2 fc0 sc0 ls8 wseb">取得元素的操作可以使用document对象的几个方法来完成。其中，Document类型为此提供了两个方</div><div class="t m0 x0 h5 y19ad ff5e fs2 fc0 sc0 ls8 wseb">法：getElementById()和getElementsByTagName()。 </div><div class="t m0 x0 hc y19ae ff5e fs2 fc0 sc0 ls6 wsf7">第一个方法，getElementById()，接收一个参数：要取得的元素的ID。如果找到相应的元素则</div><div class="t m0 x0 hc y19af ff5e fs2 fc0 sc0 ls8 wseb">返回该元素，如果不存在带有相应ID的元素，则返回null。注意，这里的ID必须与页面中元素的id</div><div class="t m0 x0 h5 y19b0 ff5e fs2 fc0 sc0 ls8">特性（attribute）严格匹配，包括大小写。以下面的元素为例。 </div><div class="t m0 x0 hb y19b1 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y19b2 ff5f fs6 fc0 sc0 ls21 wsb">&lt;div id=&quot;myDiv&quot;&gt;Some text&lt;/div&gt; </div><div class="t m0 x0 hb y19b3 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y19b4 ff5e fs2 fc0 sc0 ls8 wseb">可以使用下面的代码取得这个元素： </div><div class="t m0 x0 hb y19b5 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y19b6 ff5f fs6 fc0 sc0 ls21 wsb">var div = document.getElementById(&quot;myDiv&quot;);        //取得&lt;div&gt;元素的引用 </div><div class="t m0 x0 hb y19b7 ff5f fs6 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf113" class="pf w0 h0" data-page-no="113"><div class="pc pc113 w0 h0"><div class="t m0 x2 h2 y1 ff57 fs0 fc0 sc0 ls7 ws0">10.1 节点层次    257 </div><div class="t m0 x0 h3 y2 ff57 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff59 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff59 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff59 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff59 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff59 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff59 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff59 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff59 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff59 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff59 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff59 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff59 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff59 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff5e fs2 fc0 sc0 ls8 wseb">但是，下面的代码在除IE7及更早版本之外的所有浏览器中都将返回null。 </div><div class="t m0 x5 hb yfb2 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h36 yfb3 ff5f fs6 fc0 sc0 ls21 wsb">var div = document.getElementById(&quot;mydiv&quot;);        //无效的ID（在IE7及更早版本中可以） </div><div class="t m0 x5 hb y1510 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1511 ff57 fs2 fc0 sc0 ls2a ws21">IE8及较低版本不区分ID的大小写，因此&quot;myDiv&quot;和&quot;mydiv&quot;会被当作相同的元素ID。 </div><div class="t m0 x0 h5 y1512 ff5e fs2 fc0 sc0 ls8 wseb">如果页面中多个元素的ID值相同，getElementById()只返回文档中第一次出现的元素。IE7及较</div><div class="t m0 x0 hc y15b3 ff5e fs2 fc0 sc0 ls5 wsec">低版本还为此方法添加了一个有意思的“怪癖”：name特性与给定ID匹配的表单元素（&lt;input&gt;、</div><div class="t m0 x0 h4 y19b8 ff5f fs1 fc0 sc0 ls9 ws2">&lt;textarea&gt;、&lt;button&gt;及&lt;select&gt;）也会被该方法返回。如果有哪个表单元素的name特性等于指</div><div class="t m0 x0 h5 y19b9 ff5e fs2 fc0 sc0 ls8 wseb">定的ID，而且该元素在文档中位于带有给定ID的元素前面，那么IE就会返回那个表单元素。来看下面</div><div class="t m0 x0 h5 y19ba ff5e fs2 fc0 sc0 ls8">的例子。 </div><div class="t m0 x5 hb y14e5 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y14e6 ff5f fs6 fc0 sc0 ls21 wsb">&lt;input type=&quot;text&quot; name=&quot;myElement&quot; value=&quot;Text field&quot;&gt; </div><div class="t m0 x0 hb y19bb ff5f fs6 fc0 sc0 ls21 wsb">&lt;div id=&quot;myElement&quot;&gt;A div&lt;/div&gt; </div><div class="t m0 x5 hb y19bc ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y19bd ff5e fs2 fc0 sc0 ls8 wseb">基于这段HTML代码，在IE7中调用 document.getElementById(&quot;myElement &quot;)，结果会返</div><div class="t m0 x0 h5 y19be ff5e fs2 fc0 sc0 ls8 wseb">回&lt;input&gt;元素；而在其他所有浏览器中，都会返回对&lt;div&gt;元素的引用。为了避免IE中存在的这个问</div><div class="t m0 x0 hc y19bf ff5e fs2 fc0 sc0 ls8 wseb">题，最好的办法是不让表单字段的name特性与其他元素的ID相同。 </div><div class="t m0 x0 h1e y19c0 ff5e fs2 fc0 sc0 ls8 wseb">另一个常用于取得元素引用的方法是getElementsByTagName()。这个方法接受一个参数，即要</div><div class="t m0 x0 hc y19c1 ff5e fs2 fc0 sc0 ls8 wseb">取得元素的标签名，而返回的是包含零或多个元素的NodeList。在HTML文档中，这个方法会返回一</div><div class="t m0 x0 h4 y19c2 ff5e fs2 fc0 sc0 ls25f">个HTMLCollection对象，作为一个“动态”集合，该对象与NodeList非常类似。例如，下列代码</div><div class="t m0 x0 hc y19c3 ff5e fs2 fc0 sc0 ls8 wseb">会取得页面中所有的&lt;img&gt;元素，并返回一个HTMLCollection。 </div><div class="t m0 x5 hb ye70 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y19c4 ff5f fs6 fc0 sc0 ls21 wsb">var images = document.getElementsByTagName(&quot;img&quot;); </div><div class="t m0 x5 hb y19c5 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 ya20 ff5e fs2 fc0 sc0 ls8 wseb">这行代码会将一个HTMLCollection对象保存在images变量中。与 NodeList对象类似，可以</div><div class="t m0 x0 h1e ya21 ff5e fs2 fc0 sc0 ls8 wseb">使用方括号语法或item()方法来访问HTMLCollection对象中的项。而这个对象中元素的数量则可以</div><div class="t m0 x0 h5 y19c6 ff5e fs2 fc0 sc0 ls8 wseb">通过其length属性取得，如下面的例子所示。 </div><div class="t m0 x5 hb y19c7 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y19c8 ff5f fs6 fc0 sc0 ls21 wsb">alert(images.length);          //输出图像的数量 </div><div class="t m0 x0 h16 y19c9 ff5f fs6 fc0 sc0 ls21 wsb">alert(images[0].src);          //输出第一个图像元素的src特性 </div><div class="t m0 x0 h16 y19ca ff5f fs6 fc0 sc0 ls21 wsb">alert(images.item(0).src);     //输出第一个图像元素的src特性 </div><div class="t m0 x5 hb y19cb ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y129e ff5f fs1 fc0 sc0 ls9 ws2">HTMLCollection对象还有一个方法，叫做namedItem()，使用这个方法可以通过元素的 name</div><div class="t m0 x0 h5 y19cc ff5e fs2 fc0 sc0 ls8 wseb">特性取得集合中的项。例如，假设上面提到的页面中包含如下&lt;img&gt;元素： </div><div class="t m0 x0 hb y19cd ff5f fs6 fc0 sc0 ls21 wsb">&lt;img src=&quot;myimage.gif&quot; name=&quot;myImage&quot;&gt; </div><div class="t m0 x5 hb y19ce ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y19cf ff5e fs2 fc0 sc0 ls8 wseb">那么就可以通过如下方式从images变量中取得这个&lt;img&gt;元素： </div><div class="t m0 x5 hb y19d0 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y19d1 ff5f fs6 fc0 sc0 ls21 wsb">var myImage = images.namedItem(&quot;myImage&quot;); </div><div class="t m0 x5 hb y19d2 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y19d3 ff5e fs2 fc0 sc0 ls8 wseb">在提供按索引访问项的基础上，HTMLCollection还支持按名称访问项，这就为我们取得实际想要</div><div class="t m0 x0 h5 y19d4 ff5e fs2 fc0 sc0 ls8 wseb">的元素提供了便利。而且，对命名的项也可以使用方括号语法来访问，如下所示： </div><div class="t m0 x5 hb y19d5 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y19d6 ff5f fs6 fc0 sc0 ls21 wsb">var myImage = images[&quot;myImage&quot;]; </div><div class="t m0 x5 hb y19d7 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y19d8 ff5e fs2 fc0 sc0 lsce">对HTMLCollection而言，我们可以向方括号中传入数值或字符串形式的索引值。在后台，对数</div><div class="t m0 x0 hc y19d9 ff5e fs2 fc0 sc0 ls8 wseb">值索引就会调用item()，而对字符串索引就会调用namedItem()。 </div><div class="t m0 x0 hc y19da ff5e fs2 fc0 sc0 ls8 wseb">要想取得文档中的所有元素，可以向getElementsByTagName()中传入&quot;*&quot;。在JavaScript及CSS</div><div class="t m0 x0 hc y19db ff5e fs2 fc0 sc0 ls8 wseb">中，星号（*）通常表示“全部”。下面看一个例子。 </div><div class="t m0 x5 hb yd93 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y19dc ff5f fs6 fc0 sc0 ls21 wsb">var allElements = document.getElementsByTagName(&quot;*&quot;); </div><div class="t m0 x5 hb y19dd ff5f fs6 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf114" class="pf w0 h0" data-page-no="114"><div class="pc pc114 w0 h0"><div class="t m0 x0 h2 y1 ff57 fs0 fc0 sc0 ls7 ws0">258  第10章 DOM </div><div class="t m0 x0 h3 y2 ff57 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ff5e fs2 fc0 sc0 ls8 wseb">仅此一行代码返回的HTMLCollection中，就包含了整个页面中的所有元素——按照它们出现的</div><div class="t m0 x0 hc y4d ff5e fs2 fc0 sc0 ls8 wseb">先后顺序。换句话说，第一项是&lt;html&gt;元素，第二项是&lt;head&gt;元素，以此类推。由于IE将注释（Comment）</div><div class="t m0 x0 hc y5 ff5e fs2 fc0 sc0 ls8 wseb">实现为元素（Element），因此在IE中调用getElementsByTagName(&quot;*&quot;)将会返回所有注释节点。 </div><div class="t m0 x5 h5 y59e ff58 fs2 fc0 sc0 ls8 ws14">虽然标准规定标签名需要区分大小写，但为了最大限度地与既有HTML页面兼</div><div class="t m0 x0 h9d ybe2 ff58 fs2 fc0 sc0 ls8 ws14">容，传给getElementsByTagName()的标签名是不需要区分大小写的。但对于XML</div><div class="t m0 x0 h5 y1950 ff58 fs2 fc0 sc0 ls8 ws14">页面而言（包括XHTML），getElementsByTagName()方法就会区分大小写。 </div><div class="t m0 x0 h4 y19de ff5e fs2 fc0 sc0 ls8 wseb">第三个方法，也是只有HTMLDocument类型才有的方法，是getElementsByName()。顾名思义，</div><div class="t m0 x0 h1e y19df ff5e fs2 fc0 sc0 ls8 wseb">这个方法会返回带有给定name特性的所有元素。最常使用getElementsByName()方法的情况是取得</div><div class="t m0 x0 h1e y19e0 ff5e fs2 fc0 sc0 ls8 wseb">单选按钮；为了确保发送给浏览器的值正确无误，所有单选按钮必须具有相同的name特性，如下面的</div><div class="t m0 x0 h5 y54f ff5e fs2 fc0 sc0 ls8 wseb">例子所示。 </div><div class="t m0 x0 hb y19e1 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y19e2 ff5f fs6 fc0 sc0 ls21 wsb">&lt;fieldset&gt; </div><div class="t m0 x0 hb y19e3 ff5f fs6 fc0 sc0 ls21 wsb">    &lt;legend&gt;Which color do you prefer?&lt;/legend&gt; </div><div class="t m0 x0 hb y19e4 ff5f fs6 fc0 sc0 ls21 wsb">    &lt;ul&gt; </div><div class="t m0 x0 hb y19e5 ff5f fs6 fc0 sc0 ls21 wsb">        &lt;li&gt;&lt;input type=&quot;radio&quot; value=&quot;red&quot; name=&quot;color&quot; id=&quot;colorRed&quot;&gt; </div><div class="t m0 x0 hb y19e6 ff5f fs6 fc0 sc0 ls21 wsb">            &lt;label for=&quot;colorRed&quot;&gt;Red&lt;/label&gt;&lt;/li&gt; </div><div class="t m0 x0 hb y19e7 ff5f fs6 fc0 sc0 ls21 wsb">        &lt;li&gt;&lt;input type=&quot;radio&quot; value=&quot;green&quot; name=&quot;color&quot; id=&quot;colorGreen&quot;&gt; </div><div class="t m0 x0 hb y19e8 ff5f fs6 fc0 sc0 ls21 wsb">            &lt;label for=&quot;colorGreen&quot;&gt;Green&lt;/label&gt;&lt;/li&gt; </div><div class="t m0 x0 hb y19e9 ff5f fs6 fc0 sc0 ls21 wsb">        &lt;li&gt;&lt;input type=&quot;radio&quot; value=&quot;blue&quot; name=&quot;color&quot; id=&quot;colorBlue&quot;&gt; </div><div class="t m0 x0 hb y19ea ff5f fs6 fc0 sc0 ls21 wsb">            &lt;label for=&quot;colorBlue&quot;&gt;Blue&lt;/label&gt;&lt;/li&gt; </div><div class="t m0 x0 hb y19eb ff5f fs6 fc0 sc0 ls21 wsb">    &lt;/ul&gt; </div><div class="t m0 x0 hb y19ec ff5f fs6 fc0 sc0 ls21 wsb">&lt;/fieldset&gt; </div><div class="t m0 x0 hb y19ed ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y19ee ff5e fs2 fc0 sc0 ls8 wseb">如这个例子所示，其中所有单选按钮的name特性值都是&quot;color&quot;，但它们的ID可以不同。ID 的</div><div class="t m0 x0 h4 y19c6 ff5e fs2 fc0 sc0 ls8 wseb">作用在于将&lt;label&gt;元素应用到每个单选按钮，而name特性则用以确保三个值中只有一个被发送给浏</div><div class="t m0 x0 h5 y19ef ff5e fs2 fc0 sc0 ls8 wseb">览器。这样，我们就可以使用如下代码取得所有单选按钮： </div><div class="t m0 x0 hb y19f0 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y19f1 ff5f fs6 fc0 sc0 ls21 wsb">var radios = document.getElementsByName(&quot;color&quot;); </div><div class="t m0 x0 hb y19f2 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y85a ff5e fs2 fc0 sc0 ls261">与getElementsByTagName()类似，getElementsByName()方法也会返回一个HTMLCollectioin。</div><div class="t m0 x0 hc y19f3 ff5e fs2 fc0 sc0 ls5c ws10f">但是，对于这里的单选按钮来说，namedItem()方法则只会取得第一项（因为每一项的name特性都相同）。 </div><div class="t m0 x0 h3c y19f4 ff5c fs2 fc0 sc0 ls2e wsb">4. 特殊集合 </div><div class="t m0 x0 h4 y19f5 ff5e fs2 fc0 sc0 ls8 wseb">除了属性和方法，document对象还有一些特殊的集合。这些集合都是HTMLCollection对象，</div><div class="t m0 x0 h5 y19f6 ff5e fs2 fc0 sc0 ls8 wseb">为访问文档常用的部分提供了快捷方式，包括： </div><div class="t m0 x0 h5 y19f7 ff5d fs1 fc0 sc0 ls2"> document.anchors，包含文档中所有带name特性的&lt;a&gt;元素； </div><div class="t m0 x0 h4 y7eb ff5d fs1 fc0 sc0 ls2"> document.applets，包含文档中所有的&lt;applet&gt;元素，因为不再推荐使用&lt;applet&gt;元素，</div><div class="t m0 x0 h5 y19f8 ff5e fs2 fc0 sc0 ls8 wseb">所以这个集合已经不建议使用了； </div><div class="t m0 x0 h4 y19f9 ff5d fs1 fc0 sc0 ls2"> document.forms，包含文档中所有的&lt;form&gt;元素，与document.getElementsByTagName(&quot;form&quot;)</div><div class="t m0 x0 h5 y19fa ff5e fs2 fc0 sc0 ls8 wseb">得到的结果相同； </div><div class="t m0 x0 h4 y19fb ff5d fs1 fc0 sc0 ls2"> document.images，包含文档中所有的&lt;img&gt;元素，与document.getElementsByTagName </div><div class="t m0 x0 h21 y19fc ff5f fs1 fc0 sc0 ls9 ws2">(&quot;img&quot;)得到的结果相同； </div><div class="t m0 x0 h5 y19fd ff5d fs1 fc0 sc0 ls2"> document.links，包含文档中所有带href特性的&lt;a&gt;元素。 </div><div class="t m0 x0 h1e y19fe ff5e fs2 fc0 sc0 ls8 wseb">这个特殊集合始终都可以通过HTMLDocument对象访问到，而且，与HTMLCollection对象类似，</div><div class="t m0 x0 h5 y19ff ff5e fs2 fc0 sc0 ls8 wseb">集合中的项也会随着当前文档内容的更新而更新。 </div></div></div>
<div id="pf115" class="pf w0 h0" data-page-no="115"><div class="pc pc115 w0 h0"><div class="t m0 x2 h2 y1 ff57 fs0 fc0 sc0 ls7 ws0">10.1 节点层次    259 </div><div class="t m0 x0 h3 y2 ff57 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff59 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff59 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff59 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff59 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff59 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff59 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff59 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff59 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff59 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff59 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff59 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff59 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff59 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h3c y68b ff5c fs2 fc0 sc0 ls79 ws7e">5. DOM一致性检测 </div><div class="t m0 x0 h5 y68c ff5e fs2 fc0 sc0 ls8 wseb">由于DOM分为多个级别，也包含多个部分，因此检测浏览器实现了DOM的哪些部分就十分必要</div><div class="t m0 x0 h54 y15dc ff5e fs2 fc0 sc0 ls8 wseb">了。document.implementation属性就是为此提供相应信息和功能的对象，与浏览器对DOM的实现</div><div class="t m0 x0 h5 y68e ff5e fs2 fc0 sc0 ls8 wseb">直接对应。DOM1级只为document.implementation规定了一个方法，即hasFeature()。这个方</div><div class="t m0 x0 h5 y6e4 ff5e fs2 fc0 sc0 ls8 wseb">法接受两个参数：要检测的DOM功能的名称及版本号。如果浏览器支持给定名称和版本的功能，则该</div><div class="t m0 x0 hc y1a00 ff5e fs2 fc0 sc0 ls8 wseb">方法返回true，如下面的例子所示： </div><div class="t m0 x5 hb y19b8 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1a01 ff5f fs6 fc0 sc0 ls21 wsb">var hasXmlDom = document.implementation.hasFeature(&quot;XML&quot;, &quot;1.0&quot;); </div><div class="t m0 x5 hb y1a02 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1a03 ff5e fs2 fc0 sc0 ls8 wseb">下表列出了可以检测的不同的值及版本号。 </div><div class="t m0 x5 hb y1a04 ff5f fs6 fc0 sc0 ls8 wsb">  </div><div class="t m0 x0 h31 y1a05 ff5b fs6 fc0 sc0 lsa7 wsb">功  能 版  本  号 说  明 </div><div class="t m0 x0 h36 y1a06 ff57 fs6 fc0 sc0 ls1aa wsb">Core  1.0、2.0、3.0  基本的DOM，用于描述表现文档的节点树 </div><div class="t m0 x0 h36 y1a07 ff57 fs6 fc0 sc0 ls26c wsb">XML  1.0、2.0、3.0 Core的XML扩展，添加了对CDATA、处理指令及实体的支持 </div><div class="t m0 x0 h36 y1a08 ff57 fs6 fc0 sc0 lsab wsb">HTML  1.0、2.0 XML的HTML扩展，添加了对HTML特有元素及实体的支持 </div><div class="t m0 x0 h36 y1a09 ff57 fs6 fc0 sc0 ls267 ws22c">Views 2.0 基于某些样式完成文档的格式化 </div><div class="t m0 x0 h36 y1a0a ff57 fs6 fc0 sc0 ls1aa ws22d">StyleSheets 2.0  将样式表关联到文档 </div><div class="t m0 x0 h36 y1a0b ff57 fs6 fc0 sc0 ls268 ws22e">CSS 2.0 对层叠样式表1级的支持 </div><div class="t m0 x0 h36 y1a0c ff57 fs6 fc0 sc0 ls269 ws22f">CSS2 2.0 对层叠样式表2级的支持 </div><div class="t m0 x0 h36 y1a0d ff57 fs6 fc0 sc0 ls26e wsb">Events  2.0，3.0  常规的DOM事件 </div><div class="t m0 x0 h36 y1a0e ff57 fs6 fc0 sc0 ls22e wsb">UIEvents  2.0，3.0  用户界面事件 </div><div class="t m0 x0 h36 y1a0f ff57 fs6 fc0 sc0 ls26a wsb">MouseEvents  2.0，3.0  由鼠标引发的事件（click、mouseover等） </div><div class="t m0 x0 h36 y1a10 ff57 fs6 fc0 sc0 ls267 wsb">MutationEvents  2.0，3.0 DOM树变化时引发的事件 </div><div class="t m0 x0 h36 y1a11 ff57 fs6 fc0 sc0 ls268 ws231">HTMLEvents 2.0  HTML4.01事件 </div><div class="t m0 x0 h36 y1a12 ff57 fs6 fc0 sc0 ls269 ws232">Range 2.0 用于操作DOM树中某个范围的对象和方法 </div><div class="t m0 x0 h36 y1a13 ff57 fs6 fc0 sc0 ls22e ws233">Traversal 2.0  遍历DOM树的方法 </div><div class="t m0 x0 h36 y1a14 ff57 fs6 fc0 sc0 lsa1 ws234">LS 3.0 文件与DOM树之间的同步加载和保存 </div><div class="t m0 x0 h36 y1a15 ff57 fs6 fc0 sc0 ls26f ws235">LS-Async 3.0  文件与DOM树之间的异步加载和保存 </div><div class="t m0 x0 h36 y1a16 ff57 fs6 fc0 sc0 ls11e ws236">Validation 3.0  在确保有效的前提下修改DOM树的方法 </div><div class="t m0 x5 hb y1a17 ff5f fs6 fc0 sc0 ls8 wsb">  </div><div class="t m0 x0 h5 y1a18 ff5e fs2 fc0 sc0 ls8 wseb">尽管使用hasFeature()确实方便，但也有缺点。因为实现者可以自行决定是否与DOM规范的不</div><div class="t m0 x0 h4 y1664 ff5e fs2 fc0 sc0 ls8 wseb">同部分保持一致。事实上，要想让hasFearture()方法针对所有值都返回true很容易，但返回true</div><div class="t m0 x0 h5 y1a19 ff5e fs2 fc0 sc0 ls8 wseb">有时候也不意味着实现与规范一致。例如，Safari 2.x及更早版本会在没有完全实现某些DOM功能的情</div><div class="t m0 x0 hc y1a1a ff5e fs2 fc0 sc0 ls8 wseb">况下也返回true。为此，我们建议多数情况下，在使用DOM的某些特殊的功能之前，最好除了检测</div><div class="t m0 x0 h5 y815 ff5f fs1 fc0 sc0 ls9 ws2">hasFeature()之外，还同时使用能力检测。 </div><div class="t m0 x0 h3c y1a1b ff5c fs2 fc0 sc0 ls2e wsb">6. 文档写入 </div><div class="t m0 x0 h4 y1a1c ff5e fs2 fc0 sc0 ls8 wseb">有一个document对象的功能已经存在很多年了，那就是将输出流写入到网页中的能力。这个能力</div><div class="t m0 x0 h5 y1a1d ff5e fs2 fc0 sc0 ls8 wseb">体现在下列4个方法中：write()、writeln()、open()和close()。其中，write()和writeln()</div><div class="t m0 x0 h4 y1a1e ff5e fs2 fc0 sc0 ls6 wsf7">方法都接受一个字符串参数，即要写入到输出流中的文本。write()会原样写入，而writeln()则会</div><div class="t m0 x0 h1e y1a1f ff5e fs2 fc0 sc0 ls6 wsf7">在字符串的末尾添加一个换行符（\n）。在页面被加载的过程中，可以使用这两个方法向页面中动态地</div><div class="t m0 x0 h5 y1a20 ff5e fs2 fc0 sc0 ls8 wseb">加入内容，如下面的例子所示。 </div></div></div>
<div id="pf116" class="pf w0 h0" data-page-no="116"><div class="pc pc116 w0 h0"><div class="t m0 x0 h2 y1 ff57 fs0 fc0 sc0 ls7 ws0">260  第10章 DOM </div><div class="t m0 x0 h3 y2 ff57 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 ff5f fs6 fc0 sc0 ls21 wsb">&lt;html&gt; </div><div class="t m0 x0 hb y7a ff5f fs6 fc0 sc0 ls21 wsb">&lt;head&gt; </div><div class="t m0 x0 hb y7b ff5f fs6 fc0 sc0 ls21 wsb">    &lt;title&gt;document.write() Example&lt;/title&gt; </div><div class="t m0 x0 hb y7c ff5f fs6 fc0 sc0 ls21 wsb">&lt;/head&gt; </div><div class="t m0 x0 hb y7d ff5f fs6 fc0 sc0 ls21 wsb">&lt;body&gt; </div><div class="t m0 x0 hb y7e ff5f fs6 fc0 sc0 ls21 wsb">    &lt;p&gt;The current date and time is: </div><div class="t m0 x0 hb y7f ff5f fs6 fc0 sc0 ls21 wsb">    &lt;script type=&quot;text/javascript&quot;&gt; </div><div class="t m0 x0 hb y80 ff5f fs6 fc0 sc0 ls21 wsb">        document.write(&quot;&lt;strong&gt;&quot; + (new Date()).toString() + &quot;&lt;/strong&gt;&quot;); </div><div class="t m0 x0 hb y81 ff5f fs6 fc0 sc0 ls21 wsb">    &lt;/script&gt; </div><div class="t m0 x0 hb y82 ff5f fs6 fc0 sc0 ls21 wsb">    &lt;/p&gt; </div><div class="t m0 x0 hb y83 ff5f fs6 fc0 sc0 ls21 wsb">&lt;/body&gt; </div><div class="t m0 x0 hb y84 ff5f fs6 fc0 sc0 ls21 wsb">&lt;/html&gt; </div><div class="t m0 x0 hb y1a22 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1a23 ff66 fs2 fc0 sc0 ls25 wsb">DocumentWriteExample01.htm </div><div class="t m0 x0 h4 y1a24 ff5e fs2 fc0 sc0 ls8 wseb">这个例子展示了在页面加载过程中输出当前日期和时间的代码。其中，日期被包含在一个&lt;strong&gt;</div><div class="t m0 x0 h5 y1a25 ff5e fs2 fc0 sc0 ls8 wseb">元素中，就像在HTML页面中包含普通的文本一样。这样做会创建一个DOM元素，而且可以在将来访</div><div class="t m0 x0 hc y1a26 ff5e fs2 fc0 sc0 ls8 wseb">问该元素。通过write()和writeln()输出的任何HTML代码都将如此处理。 </div><div class="t m0 x0 h5 y1a27 ff5e fs2 fc0 sc0 ls6 wsf7">此外，还可以使用write()和writeln()方法动态地包含外部资源，例如JavaScript文件等。在包</div><div class="t m0 x0 h5 y1a28 ff5e fs2 fc0 sc0 ls3b">含JavaScript文件时，必须注意不能像下面的例子那样直接包含字符串&quot;&lt;/script&gt;&quot;，因为这会导致该</div><div class="t m0 x0 h5 y1a29 ff5e fs2 fc0 sc0 ls8 wseb">字符串被解释为脚本块的结束，它后面的代码将无法执行。 </div><div class="t m0 x0 hb y1a2a ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1a2b ff5f fs6 fc0 sc0 ls21 wsb">&lt;html&gt; </div><div class="t m0 x0 hb y1a2c ff5f fs6 fc0 sc0 ls21 wsb">&lt;head&gt; </div><div class="t m0 x0 hb y1a2d ff5f fs6 fc0 sc0 ls21 wsb">    &lt;title&gt;document.write() Example 2&lt;/title&gt; </div><div class="t m0 x0 hb y1a2e ff5f fs6 fc0 sc0 ls21 wsb">&lt;/head&gt; </div><div class="t m0 x0 hb y1a2f ff5f fs6 fc0 sc0 ls21 wsb">&lt;body&gt; </div><div class="t m0 x0 hb y1a30 ff5f fs6 fc0 sc0 ls21 wsb">    &lt;script type=&quot;text/javascript&quot;&gt; </div><div class="t m0 x0 hb y1a31 ff5f fs6 fc0 sc0 ls21 wsb">        document.write(&quot;&lt;script type=\&quot;text/javascript\&quot; src=\&quot;file.js\&quot;&gt;&quot; +    </div><div class="t m0 x0 hb y1a32 ff5f fs6 fc0 sc0 ls21 wsb">            &quot;&lt;/script&gt;&quot;); </div><div class="t m0 x0 hb y1a33 ff5f fs6 fc0 sc0 ls21 wsb">    &lt;/script&gt; </div><div class="t m0 x0 hb y1a34 ff5f fs6 fc0 sc0 ls21 wsb">&lt;/body&gt; </div><div class="t m0 x0 hb y1a35 ff5f fs6 fc0 sc0 ls21 wsb">&lt;/html&gt; </div><div class="t m0 x0 hb y1a36 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1576 ff66 fs2 fc0 sc0 ls25 wsb">DocumentWriteExample02.htm </div><div class="t m0 x0 h4 y1a37 ff5e fs2 fc0 sc0 ls8 wseb">即使这个文件看起来没错，但字符串&quot;&lt;/script&gt;&quot;将被解释为与外部的&lt;script&gt;标签匹配，结果</div><div class="t m0 x0 hc y1a38 ff5e fs2 fc0 sc0 ls8 wseb">文本&quot;);将会出现在页面中。为避免这个问题，只需加入转义字符\即可；第2章也曾经提及这个问题，</div><div class="t m0 x0 h5 y1a39 ff5e fs2 fc0 sc0 ls8 wseb">解决方案如下。 </div><div class="t m0 x0 hb y1a3a ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1a3b ff5f fs6 fc0 sc0 ls21 wsb">&lt;html&gt; </div><div class="t m0 x0 hb y1a3c ff5f fs6 fc0 sc0 ls21 wsb">&lt;head&gt; </div><div class="t m0 x0 hb y1a3d ff5f fs6 fc0 sc0 ls21 wsb">    &lt;title&gt;document.write() Example 3&lt;/title&gt; </div><div class="t m0 x0 hb y1a3e ff5f fs6 fc0 sc0 ls21 wsb">&lt;/head&gt; </div><div class="t m0 x0 hb y1a3f ff5f fs6 fc0 sc0 ls21 wsb">&lt;body&gt; </div><div class="t m0 x0 hb y1a40 ff5f fs6 fc0 sc0 ls21 wsb">    &lt;script type=&quot;text/javascript&quot;&gt; </div><div class="t m0 x0 hb y1a41 ff5f fs6 fc0 sc0 ls21 wsb">        document.write(&quot;&lt;script type=\&quot;text/javascript\&quot; src=\&quot;file.js\&quot;&gt;&quot; +    </div><div class="t m0 x0 h15 y1a42 ff63 fs6 fc0 sc0 ls21 wsb">            &quot;&lt;\/script&gt;&quot;); </div><div class="t m0 x0 hb y1a43 ff5f fs6 fc0 sc0 ls21 wsb">    &lt;/script&gt; </div><div class="t m0 x0 hb y1a44 ff5f fs6 fc0 sc0 ls21 wsb">&lt;/body&gt; </div><div class="t m0 x0 hb y1a45 ff5f fs6 fc0 sc0 ls21 wsb">&lt;/html&gt; </div><div class="t m0 x0 hb y1a46 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1a47 ff66 fs2 fc0 sc0 ls25 wsb">DocumentWriteExample03.htm </div></div></div>
<div id="pf117" class="pf w0 h0" data-page-no="117"><div class="pc pc117 w0 h0"><div class="t m0 x2 h2 y1 ff57 fs0 fc0 sc0 ls7 ws0">10.1 节点层次    261 </div><div class="t m0 x0 h3 y2 ff57 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff59 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff59 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff59 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff59 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff59 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff59 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff59 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff59 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff59 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff59 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff59 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff59 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff59 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h4 y3 ff5e fs2 fc0 sc0 ls5 wsec">字符串&quot;&lt;\/script&gt;&quot;不会被当作外部&lt;script&gt;标签的关闭标签，因而页面中也就不会出现多余</div><div class="t m0 x0 h5 y4d ff5e fs2 fc0 sc0 ls8 wseb">的内容了。 </div><div class="t m0 x0 h1c yd8 ff5e fs2 fc0 sc0 ls6 wsf7">前面的例子使用document.write()在页面被呈现的过程中直接向其中输出了内容。如果在文档</div><div class="t m0 x0 h5 yd9 ff5e fs2 fc0 sc0 ls8 wseb">加载结束后再调用document.write()，那么输出的内容将会重写整个页面，如下面的例子所示： </div><div class="t m0 x5 hb ye5c ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1a48 ff5f fs6 fc0 sc0 ls21 wsb">&lt;html&gt; </div><div class="t m0 x0 hb y1a49 ff5f fs6 fc0 sc0 ls21 wsb">&lt;head&gt; </div><div class="t m0 x0 hb y1a4a ff5f fs6 fc0 sc0 ls21 wsb">    &lt;title&gt;document.write() Example 4&lt;/title&gt; </div><div class="t m0 x0 hb y1a4b ff5f fs6 fc0 sc0 ls21 wsb">&lt;/head&gt; </div><div class="t m0 x0 hb y1a4c ff5f fs6 fc0 sc0 ls21 wsb">&lt;body&gt; </div><div class="t m0 x0 hb y1a4d ff5f fs6 fc0 sc0 ls21 ws239">    &lt;p&gt;This is some content that you won&apos;t get to see because it will be overwritten.&lt;/p&gt; </div><div class="t m0 x0 hb y1a4e ff5f fs6 fc0 sc0 ls21 wsb">    &lt;script type=&quot;text/javascript&quot;&gt; </div><div class="t m0 x0 hb y1a4f ff5f fs6 fc0 sc0 ls21 wsb">        window.onload = function(){ </div><div class="t m0 x0 hb y1a50 ff5f fs6 fc0 sc0 ls21 wsb">            document.write(&quot;Hello world!&quot;); </div><div class="t m0 x0 hb y1a51 ff5f fs6 fc0 sc0 ls21 wsb">        }; </div><div class="t m0 x0 hb y1a52 ff5f fs6 fc0 sc0 ls21 wsb">    &lt;/script&gt; </div><div class="t m0 x0 hb y1a53 ff5f fs6 fc0 sc0 ls21 wsb">&lt;/body&gt; </div><div class="t m0 x0 hb y1a54 ff5f fs6 fc0 sc0 ls21 wsb">&lt;/html&gt; </div><div class="t m0 x0 hb y1a55 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1a56 ff66 fs2 fc0 sc0 ls1b wsb">DocumentWriteExample04.htm </div><div class="t m0 x0 h5 y1a57 ff5e fs2 fc0 sc0 ls8 wseb">在这个例子中，我们使用了window.onload事件处理程序（事件将在第13章讨论），等到页面完</div><div class="t m0 x0 hc y1a58 ff5e fs2 fc0 sc0 ls8 wseb">全加载之后延迟执行函数。函数执行之后，字符串&quot;Hello world!&quot;会重写整个页面内容。 </div><div class="t m0 x0 h1e y1a59 ff5e fs2 fc0 sc0 ls8 wseb">方法open()和close()分别用于打开和关闭网页的输出流。如果是在页面加载期间使用write()</div><div class="t m0 x0 h5 y1a5a ff5e fs2 fc0 sc0 ls2c">或writeln()方法，则不需要用到这两个方法。 </div><div class="t m0 x5 h5 y1a5b ff58 fs2 fc0 sc0 ls8 ws14">严格型XHTML文档不支持文档写入。对于那些按照application/xml+xhtml</div><div class="t m0 x5 h5 y1a5c ff58 fs2 fc0 sc0 ls8 ws14">内容类型提供的页面，这两个方法也同样无效。 </div><div class="t m0 x0 h20 y1a5d ff5c fs3 fc0 sc0 ls248 ws214">10.1.3 Element类型 </div><div class="t m0 x0 h5 y1a5e ff5e fs2 fc0 sc0 ls8 wseb">除了Document类型之外，Element类型就要算是Web 编程中最常用的类型了。Element类型用</div><div class="t m0 x0 h5 y1a5f ff5e fs2 fc0 sc0 ls5f ws10b">于表现XML或HTML元素，提供了对元素标签名、子节点及特性的访问。Element节点具有以下特征： </div><div class="t m0 x0 h5 y1a60 ff5d fs1 fc0 sc0 ls2"> nodeType的值为1； </div><div class="t m0 x0 h5 y1a61 ff5d fs1 fc0 sc0 ls2"> nodeName的值为元素的标签名； </div><div class="t m0 x0 h5 y2fc ff5d fs1 fc0 sc0 ls2"> nodeValue的值为null； </div><div class="t m0 x0 h5 y2fd ff5d fs1 fc0 sc0 ls2"> parentNode可能是Document或Element； </div><div class="t m0 x0 h4 y1a62 ff5d fs1 fc0 sc0 ls2"> 其子节点可能是Element、Text、Comment、ProcessingInstruction、CDATASection或</div><div class="t m0 x5 h5 y1a63 ff5f fs1 fc0 sc0 ls9 ws2">EntityReference。 </div><div class="t m0 x0 h1e y300 ff5e fs2 fc0 sc0 ls8 wseb">要访问元素的标签名，可以使用nodeName属性，也可以使用tagName属性；这两个属性会返回</div><div class="t m0 x0 h5 y301 ff5e fs2 fc0 sc0 ls8 wseb">相同的值（使用后者主要是为了清晰起见）。以下面的元素为例： </div><div class="t m0 x5 hb y1a64 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1a65 ff5f fs6 fc0 sc0 ls21 wsb">&lt;div id=&quot;myDiv&quot;&gt;&lt;/div&gt; </div><div class="t m0 x5 hb y1a66 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1a67 ff5e fs2 fc0 sc0 ls8 wseb">可以像下面这样取得这个元素及其标签名： </div><div class="t m0 x5 hb y1a68 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1a69 ff5f fs6 fc0 sc0 ls21 wsb">var div = document.getElementById(&quot;myDiv&quot;); </div><div class="t m0 x0 hb y1a6a ff5f fs6 fc0 sc0 ls21 wsb">alert(div.tagName);     //&quot;DIV&quot; </div><div class="t m0 x0 hb y1a6b ff5f fs6 fc0 sc0 ls21 wsb">alert(div.tagName == div.nodeName); //true </div></div></div>
<div id="pf118" class="pf w0 h0" data-page-no="118"><div class="pc pc118 w0 h0"><div class="t m0 x0 h2 y1 ff57 fs0 fc0 sc0 ls7 ws0">262  第10章 DOM </div><div class="t m0 x0 h3 y2 ff57 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff5e fs2 fc0 sc0 ls8 wseb">这里的元素标签名是div，它拥有一个值为&quot;myDiv&quot;的ID。可是，div.tagName实际上输出的是</div><div class="t m0 x0 h5 y4 ff5f fs1 fc0 sc0 ls9 ws2">&quot;DIV&quot;而非&quot;div&quot;。在HTML中，标签名始终都以全部大写表示；而在XML（有时候也包括XHTML）</div><div class="t m0 x0 h5 y5 ff5e fs2 fc0 sc0 ls8 wseb">中，标签名则始终会与源代码中的保持一致。假如你不确定自己的脚本将会在HTML还是XML文档中</div><div class="t m0 x0 h5 y6 ff5e fs2 fc0 sc0 ls8 wseb">执行，最好是在比较之前将标签名转换为相同的大小写形式，如下面的例子所示： </div><div class="t m0 x0 hb ya81 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 ya82 ff5f fs6 fc0 sc0 ls21 wsb">if (element.tagName == &quot;div&quot;){ //不能这样比较，很容易出错！ </div><div class="t m0 x0 h16 ya83 ff5f fs6 fc0 sc0 ls21 wsb">    //在此执行某些操作 </div><div class="t m0 x0 hb y1908 ff5f fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y1909 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y190a ff5f fs6 fc0 sc0 ls21 wsb">if (element.tagName.toLowerCase() == &quot;div&quot;){ //这样最好（适用于任何文档） </div><div class="t m0 x0 h16 y190b ff5f fs6 fc0 sc0 ls21 wsb">    //在此执行某些操作 </div><div class="t m0 x0 hb y190c ff5f fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h4 y1975 ff5e fs2 fc0 sc0 ls24 wsf5">这个例子展示了围绕tagName属性的两次比较操作。第一次比较非常容易出错，因为其代码在</div><div class="t m0 x0 h5 y1a6d ff57 fs2 fc0 sc0 lsfa wsc9">HTML文档中不管用。第二次比较将标签名转换成了全部小写，是我们推荐的做法，因为这种做法适用</div><div class="t m0 x0 h5 y1a6e ff5e fs2 fc0 sc0 ls3b">于HTML文档，也适用于XML文档。 </div><div class="t m0 x7 h5 y1a6f ff5f fs1 fc0 sc0 ls9 ws23a">Element IE8</div><div class="t m0 x1 h5 y1a70 ff57 fs2 fc0 sc0 ls190 ws23c">Safari 2 Opera 8 Element</div><div class="t m0 x0 h5 y1a71 ff57 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h3c y1a72 ff5c fs2 fc0 sc0 ls4e wscd">1. HTML元素 </div><div class="t m0 x0 h5 y1a73 ff5e fs2 fc0 sc0 ls8 wseb">所有HTML元素都由HTMLElement类型表示，不是直接通过这个类型，也是通过它的子类型来表</div><div class="t m0 x0 hc y1a74 ff5e fs2 fc0 sc0 ls8 wseb">示。HTMLElement类型直接继承自Element并添加了一些属性。添加的这些属性分别对应于每个HTML</div><div class="t m0 x0 h5 y1a75 ff5e fs2 fc0 sc0 ls8 wseb">元素中都存在的下列标准特性。 </div><div class="t m0 x0 h5 y1a76 ff5d fs1 fc0 sc0 ls2"> id，元素在文档中的唯一标识符。 </div><div class="t m0 x0 h5 y1a77 ff5d fs1 fc0 sc0 ls2"> title，有关元素的附加说明信息，一般通过工具提示条显示出来。 </div><div class="t m0 x0 h5 y1a78 ff5d fs1 fc0 sc0 ls2"> lang，元素内容的语言代码，很少使用。 </div><div class="t m0 x0 h5 y1a79 ff5d fs1 fc0 sc0 ls2"> dir，语言的方向，值为&quot;ltr&quot;（left-to-right，从左至右）或&quot;rtl&quot;（right-to-left，从右至左），</div><div class="t m0 x0 h5 y1a7a ff5e fs2 fc0 sc0 ls8 wseb">也很少使用。 </div><div class="t m0 x0 h5 y50c ff5d fs1 fc0 sc0 ls2"> className，与元素的class特性对应，即为元素指定的CSS类。没有将这个属性命名为class，</div><div class="t m0 x0 hc y1a7b ff5e fs2 fc0 sc0 ls8 wseb">是因为class是ECMAScript的保留字（有关保留字的信息，请参见第1章）。 </div><div class="t m0 x0 h5 y1a7c ff5e fs2 fc0 sc0 ls8 wseb">上述这些属性都可以用来取得或修改相应的特性值。以下面的HTML元素为例： </div><div class="t m0 x0 hb y1a7d ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1a7e ff5f fs6 fc0 sc0 ls21 wsb">&lt;div id=&quot;myDiv&quot; class=&quot;bd&quot; title=&quot;Body text&quot; lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;&lt;/div&gt; </div><div class="t m0 x2 hf y1a7f ff66 fs2 fc0 sc0 ls7a wsb">HTMLElementsExample01.htm </div><div class="t m0 x0 h5 y1a80 ff5e fs2 fc0 sc0 ls8 wseb">元素中指定的所有信息，都可以通过下列JavaScript代码取得： </div><div class="t m0 x0 hb y861 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1a81 ff5f fs6 fc0 sc0 ls21 wsb">var div = document.getElementById(&quot;myDiv&quot;); </div><div class="t m0 x0 hb y1a82 ff5f fs6 fc0 sc0 ls21 wsb">alert(div.id);          //&quot;myDiv&quot;&quot; </div><div class="t m0 x0 hb y1a83 ff5f fs6 fc0 sc0 ls21 wsb">alert(div.className);   //&quot;bd&quot; </div><div class="t m0 x0 hb y1a84 ff5f fs6 fc0 sc0 ls21 wsb">alert(div.title);         //&quot;Body text&quot; </div><div class="t m0 x0 hb y1a85 ff5f fs6 fc0 sc0 ls21 wsb">alert(div.lang);         //&quot;en&quot; </div><div class="t m0 x0 hb y1a86 ff5f fs6 fc0 sc0 ls21 wsb">alert(div.dir);         //&quot;ltr&quot; </div><div class="t m0 x0 hb y1a87 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y6bb ff5e fs2 fc0 sc0 ls8 wseb">当然，像下面这样通过为每个属性赋予新的值，也可以修改对应的每个特性： </div><div class="t m0 x0 hb y1a88 ff5f fs6 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf119" class="pf w0 h0" data-page-no="119"><div class="pc pc119 w0 h0"><div class="t m0 x2 h2 y1 ff57 fs0 fc0 sc0 ls7 ws0">10.1 节点层次    263 </div><div class="t m0 x0 h3 y2 ff57 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff59 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff59 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff59 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff59 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff59 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff59 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff59 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff59 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff59 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff59 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff59 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff59 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff59 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y79 ff5f fs6 fc0 sc0 ls21 wsb">div.id = &quot;someOtherId&quot;; </div><div class="t m0 x0 hb y7a ff5f fs6 fc0 sc0 ls21 wsb">div.className = &quot;ft&quot;; </div><div class="t m0 x0 hb y7b ff5f fs6 fc0 sc0 ls21 wsb">div.title = &quot;Some other text&quot;; </div><div class="t m0 x0 hb y7c ff5f fs6 fc0 sc0 ls21 wsb">div.lang = &quot;fr&quot;; </div><div class="t m0 x0 hb y7d ff5f fs6 fc0 sc0 ls21 wsb">div.dir =&quot;rtl&quot;; </div><div class="t m0 x5 hb y3fc ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y3fd ff66 fs2 fc0 sc0 ls7a wsb">HTMLElementsExample01.htm </div><div class="t m0 x0 h4 y3fe ff5e fs2 fc0 sc0 ls8 wseb">并不是对所有属性的修改都会在页面中直观地表现出来。对id或lang的修改对用户而言是透明</div><div class="t m0 x0 h5 y3ff ff5e fs2 fc0 sc0 ls8 wseb">不可见的（假设没有基于它们的值设置的CSS样式），而对title的修改则只会在鼠标移动到这个元素</div><div class="t m0 x0 h1e y400 ff5e fs2 fc0 sc0 ls8 wseb">之上时才会显示出来。对dir的修改会在属性被重写的那一刻，立即影响页面中文本的左、右对齐方式。</div><div class="t m0 x0 hc y401 ff5e fs2 fc0 sc0 ls8 wseb">修改className时，如果新类关联了与此前不同的CSS样式，那么就会立即应用新的样式。 </div><div class="t m0 x0 h5 y1975 ff5e fs2 fc0 sc0 ls8 wseb">前面提到过，所有HTML元素都是由HTMLElement或者其更具体的子类型来表示的。下表列出了</div><div class="t m0 x0 h5 y1a6d ff5e fs2 fc0 sc0 ls8 wseb">所有HTML元素以及与之关联的类型（以斜体印刷的元素表示已经不推荐使用了）。注意，表中的这些</div><div class="t m0 x0 h5 y1a89 ff5e fs2 fc0 sc0 ls8 wseb">类型在Opera、Safari、Chrome和Firefox中都可以通过JavaScript 访问，但在IE8之前的版本中不能通</div><div class="t m0 x0 h5 y1a8a ff5e fs2 fc0 sc0 ls3b">过JavaScript访问。 </div><div class="t m0 x5 hb y1a8b ff5f fs6 fc0 sc0 ls8 wsb">  </div><div class="t m0 x0 h31 y1a8c ff5b fs6 fc0 sc0 lsa7 wsb">元  素 类  型 元  素 类  型 </div><div class="t m0 x0 h36 y1a8d ff57 fs6 fc0 sc0 ls1ca wsb">A  HTMLAnchorElement  EM  HTMLElement </div><div class="t m0 x0 h36 y387 ff57 fs6 fc0 sc0 ls209 wsb">ABBR  HTMLElement  FIELDSET  HTMLFieldSetElement </div><div class="t m0 x0 h36 y1a8e ff57 fs6 fc0 sc0 ls276 wsb">ACRONYM  HTMLElement  FONT  HTMLFontElement </div><div class="t m0 x0 h36 y1a8f ff57 fs6 fc0 sc0 ls8 wsb">ADDRESS  HTMLElement  FORM  HTMLFormElement </div><div class="t m0 x0 h36 y1a90 ff66 fs6 fc0 sc0 ls279 wsb">APPLET  HTMLAppletElement  FRAME  HTMLFrameElement </div><div class="t m0 x0 h36 y1a91 ff57 fs6 fc0 sc0 ls1c9 wsb">AREA  HTMLAreaElement  FRAMESET  HTMLFrameSetElement </div><div class="t m0 x0 h36 y805 ff57 fs6 fc0 sc0 ls277 wsb">B  HTMLElement  H1  HTMLHeadingElement </div><div class="t m0 x0 h36 y1ba ff57 fs6 fc0 sc0 ls276 wsb">BASE  HTMLBaseElement  H2  HTMLHeadingElement </div><div class="t m0 x0 h36 y1a92 ff66 fs6 fc0 sc0 ls1c7 wsb">BASEFONT  HTMLBaseFontElement  H3  HTMLHeadingElement </div><div class="t m0 x0 h36 y1a93 ff57 fs6 fc0 sc0 lsbb wsb">BDO  HTMLElement  H4  HTMLHeadingElement </div><div class="t m0 x0 h36 y1a94 ff57 fs6 fc0 sc0 ls225 wsb">BIG  HTMLElement  H5  HTMLHeadingElement </div><div class="t m0 x0 h36 y1a95 ff57 fs6 fc0 sc0 ls276 wsb">BLOCKQUOTE  HTMLQuoteElement  H6  HTMLHeadingElement </div><div class="t m0 x0 h36 y1a96 ff57 fs6 fc0 sc0 ls276 wsb">BODY  HTMLBodyElement  HEAD  HTMLHeadElement </div><div class="t m0 x0 h36 y1a97 ff57 fs6 fc0 sc0 ls277 wsb">BR  HTMLBRElement  HR  HTMLHRElement </div><div class="t m0 x0 h36 y85d ff57 fs6 fc0 sc0 ls14e wsb">BUTTON  HTMLButtonElement  HTML  HTMLHtmlElement </div><div class="t m0 x0 h36 y1a98 ff57 fs6 fc0 sc0 ls1c8 wsb">CAPTION  HTMLTableCaptionElement  I  HTMLElement </div><div class="t m0 x0 h36 y1a99 ff66 fs6 fc0 sc0 ls1ca wsb">CENTER  HTMLElement  IFRAME  HTMLIFrameElement </div><div class="t m0 x0 h36 y231 ff57 fs6 fc0 sc0 lsab wsb">CITE  HTMLElement  IMG  HTMLImageElement </div><div class="t m0 x0 h36 y1a9a ff57 fs6 fc0 sc0 ls1c9 wsb">CODE  HTMLElement  INPUT  HTMLInputElement </div><div class="t m0 x0 h36 y1a9b ff57 fs6 fc0 sc0 ls1c7 wsb">COL  HTMLTableColElement  INS  HTMLModElement </div><div class="t m0 x0 h36 y1a9c ff57 fs6 fc0 sc0 ls20b wsb">COLGROUP  HTMLTableColElement  ISINDEX  HTMLIsIndexElement </div><div class="t m0 x0 h36 y1870 ff57 fs6 fc0 sc0 ls1ca wsb">DD  HTMLElement  KBD  HTMLElement </div><div class="t m0 x0 h36 y1a9d ff57 fs6 fc0 sc0 ls26c wsb">DEL  HTMLModElement  LABEL  HTMLLabelElement </div><div class="t m0 x0 h36 y1a9e ff57 fs6 fc0 sc0 ls26e wsb">DFN  HTMLElement  LEGEND  HTMLLegendElement </div><div class="t m0 x0 h36 y1a9f ff66 fs6 fc0 sc0 ls22a wsb">DIR  HTMLDirectoryElement  LI  HTMLLIElement </div><div class="t m0 x0 h36 y1aa0 ff57 fs6 fc0 sc0 ls279 wsb">DIV  HTMLDivElement  LINK  HTMLLinkElement </div><div class="t m0 x0 h36 y18e8 ff57 fs6 fc0 sc0 lsab wsb">DL  HTMLDListElement  MAP  HTMLMapElement </div><div class="t m0 x0 h36 y1aa1 ff57 fs6 fc0 sc0 lsab wsb">DT  HTMLElement  MENU  HTMLMenuElement </div></div></div>
<div id="pf11a" class="pf w0 h0" data-page-no="11a"><div class="pc pc11a w0 h0"><div class="t m0 x0 h2 y1 ff57 fs0 fc0 sc0 ls7 ws0">264  第10章 DOM </div><div class="t m0 x0 h3 y2 ff57 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x6 h3 y34f ff5e fs1 fc0 sc0 ls8">（续） </div><div class="t m0 x0 h31 y350 ff5b fs6 fc0 sc0 lsa7 wsb">元  素 类  型 元  素 类  型 </div><div class="t m0 x0 h36 y161a ff57 fs6 fc0 sc0 ls237 wsb">META  HTMLMetaElement  STRONG  HTMLElement </div><div class="t m0 x0 h36 y161b ff57 fs6 fc0 sc0 ls20b wsb">NOFRAMES  HTMLElement  STYLE  HTMLStyleElement </div><div class="t m0 x0 h36 y1aa3 ff57 fs6 fc0 sc0 ls8 wsb">NOSCRIPT  HTMLElement  SUB  HTMLElement </div><div class="t m0 x0 h36 y1aa4 ff57 fs6 fc0 sc0 ls1ae wsb">OBJECT  HTMLObjectElement  SUP  HTMLElement </div><div class="t m0 x0 h36 y1aa5 ff57 fs6 fc0 sc0 lsab wsb">OL  HTMLOListElement  TABLE  HTMLTableElement </div><div class="t m0 x0 h36 y1aa6 ff57 fs6 fc0 sc0 ls20b wsb">OPTGROUP  HTMLOptGroupElement  TBODY  HTMLTableSectionElement </div><div class="t m0 x0 h36 y1aa7 ff57 fs6 fc0 sc0 ls27a wsb">OPTION  HTMLOptionElement  TD  HTMLTableCellElement </div><div class="t m0 x0 h36 y1aa8 ff57 fs6 fc0 sc0 ls20b wsb">P  HTMLParagraphElement  TEXTAREA  HTMLTextAreaElement </div><div class="t m0 x0 h36 y1aa9 ff57 fs6 fc0 sc0 ls1ca wsb">PARAM  HTMLParamElement  TFOOT  HTMLTableSectionElement </div><div class="t m0 x0 h36 y1149 ff57 fs6 fc0 sc0 ls26e wsb">PRE  HTMLPreElement  TH  HTMLTableCellElement </div><div class="t m0 x0 h36 y1aaa ff57 fs6 fc0 sc0 ls1ca wsb">Q  HTMLQuoteElement  THEAD  HTMLTableSectionElement </div><div class="t m0 x0 h36 y1aab ff66 fs6 fc0 sc0 lsa1 wsb">S  HTMLElement  TITLE  HTMLTitleElement </div><div class="t m0 x0 h36 y1aac ff57 fs6 fc0 sc0 ls1c7 wsb">SAMP  HTMLElement  TR  HTMLTableRowElement </div><div class="t m0 x0 h36 y1aad ff57 fs6 fc0 sc0 ls276 wsb">SCRIPT  HTMLScriptElement  TT  HTMLElement </div><div class="t m0 x0 h36 yb7a ff57 fs6 fc0 sc0 ls26e wsb">SELECT  HTMLSelectElement  U  HTMLElement </div><div class="t m0 x0 h36 y1aae ff57 fs6 fc0 sc0 ls278 wsb">SMALL  HTMLElement  UL  HTMLUListElement </div><div class="t m0 x0 h36 ybec ff57 fs6 fc0 sc0 ls225 wsb">SPAN  HTMLElement  VAR  HTMLElement </div><div class="t m0 x0 h36 y1aaf ff66 fs6 fc0 sc0 ls11e wsb">STRIKE  HTMLElement    </div><div class="t m0 x0 h5 y1ab0 ff57 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1ab1 ff5e fs2 fc0 sc0 ls8 wseb">表中的每一种类型都有与之相关的特性和方法。本书将会讨论其中很多类型。 </div><div class="t m0 x0 h3c y1ab2 ff5c fs2 fc0 sc0 ls2e wsb">2. 取得特性 </div><div class="t m0 x0 h4 y1ab3 ff5e fs2 fc0 sc0 ls24 wsf5">每个元素都有一或多个特性，这些特性的用途是给出相应元素或其内容的附加信息。操作特性的</div><div class="t m0 x0 h5 y1ab4 ff57 fs2 fc0 sc0 ls81 ws76">DOM方法主要有三个，分别是getAttribute()、setAttribute()和removeAttribute()。这三</div><div class="t m0 x0 hc y1ab5 ff5e fs2 fc0 sc0 ls1f ws108">个方法可以针对任何特性使用，包括那些以HTMLElement类型属性的形式定义的特性。来看下面的例子： </div><div class="t m0 x0 hb y1ab6 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1ab7 ff5f fs6 fc0 sc0 ls21 wsb">var div = document.getElementById(&quot;myDiv&quot;); </div><div class="t m0 x0 hb y1ab8 ff5f fs6 fc0 sc0 ls21 wsb">alert(div.getAttribute(&quot;id&quot;));         //&quot;myDiv&quot; </div><div class="t m0 x0 hb y1ab9 ff5f fs6 fc0 sc0 ls21 wsb">alert(div.getAttribute(&quot;class&quot;));      //&quot;bd&quot; </div><div class="t m0 x0 hb y1aba ff5f fs6 fc0 sc0 ls21 wsb">alert(div.getAttribute(&quot;title&quot;));      //&quot;Body text&quot; </div><div class="t m0 x0 hb y1abb ff5f fs6 fc0 sc0 ls21 wsb">alert(div.getAttribute(&quot;lang&quot;));       //&quot;en&quot; </div><div class="t m0 x0 hb y1abc ff5f fs6 fc0 sc0 ls21 wsb">alert(div.getAttribute(&quot;dir&quot;));        //&quot;ltr&quot; </div><div class="t m0 x0 hb y1abd ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1abe ff5e fs2 fc0 sc0 ls8 wseb">注意，传递给getAttribute()的特性名与实际的特性名相同。因此要想得到class特性值，应</div><div class="t m0 x0 hc y1abf ff5e fs2 fc0 sc0 ls8 wseb">该传入&quot;class&quot;而不是&quot;className&quot;，后者只有在通过对象属性访问特性时才用。如果给定名称的特性</div><div class="t m0 x0 h5 y1490 ff5e fs2 fc0 sc0 ls8 wseb">不存在，getAttribute()返回null。 </div><div class="t m0 x0 hc y1ac0 ff5e fs2 fc0 sc0 ls8 wseb">通过getAttribute()方法也可以取得自定义特性（即标准HTML语言中没有的特性）的值，以</div><div class="t m0 x0 h5 y1ac1 ff5e fs2 fc0 sc0 ls8 wseb">下面的元素为例： </div><div class="t m0 x0 hb y1ac2 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1ac3 ff5f fs6 fc0 sc0 ls21 wsb">&lt;div id=&quot;myDiv&quot; my_special_attribute=&quot;hello!&quot;&gt;&lt;/div&gt; </div><div class="t m0 x0 hb y1ac4 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1ac5 ff5e fs2 fc0 sc0 ls8 wseb">这个元素包含一个名为my_special_attribute的自定义特性，它的值是&quot;hello!&quot;。可以像取</div><div class="t m0 x0 h5 y1ac6 ff5e fs2 fc0 sc0 ls8 wseb">得其他特性一样取得这个值，如下所示： </div><div class="t m0 x0 hb y1ac7 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1ac8 ff5f fs6 fc0 sc0 ls21 wsb">var value = div.getAttribute(&quot;my_special_attribute&quot;); </div><div class="t m0 x0 hb y1ac9 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1aca ff5e fs2 fc0 sc0 ls6 wsf7">不过，特性的名称是不区分大小写的，即&quot;ID&quot;和&quot;id&quot;代表的都是同一个特性。另外也要注意，根</div><div class="t m0 x0 h5 y1acb ff5e fs2 fc0 sc0 ls3b">据HTML5规范，自定义特性应该加上data-前缀以便验证。 </div></div></div>
<div id="pf11b" class="pf w0 h0" data-page-no="11b"><div class="pc pc11b w0 h0"><div class="t m0 x2 h2 y1 ff57 fs0 fc0 sc0 ls7 ws0">10.1 节点层次    265 </div><div class="t m0 x0 h3 y2 ff57 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff59 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff59 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff59 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff59 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff59 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff59 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff59 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff59 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff59 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff59 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff59 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff59 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff59 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff5e fs2 fc0 sc0 ls8 wseb">任何元素的所有特性，也都可以通过DOM元素本身的属性来访问。当然，HTMLElement也会有5</div><div class="t m0 x0 h5 y4d ff5e fs2 fc0 sc0 ls8 wseb">个属性与相应的特性一一对应。不过，只有公认的（非自定义的）特性才会以属性的形式添加到DOM</div><div class="t m0 x0 h5 yd8 ff5e fs2 fc0 sc0 ls8 wseb">对象中。以下面的元素为例： </div><div class="t m0 x5 hb y6bd ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y6be ff5f fs6 fc0 sc0 ls21 wsb">&lt;div id=&quot;myDiv&quot; align=&quot;left&quot; my_special_attribute=&quot;hello!&quot;&gt;&lt;/div&gt; </div><div class="t m0 x5 hb y153b ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y6e5 ff5e fs2 fc0 sc0 ls8 wseb">因为id和align在HTML中是&lt;div&gt;的公认特性，因此该元素的DOM对象中也将存在对 应的属</div><div class="t m0 x0 hc y1727 ff5e fs2 fc0 sc0 ls8 wseb">性。不过，自定义特性my_special_attribute在Safari、Opera、Chrome及Firefox中是不存在的；</div><div class="t m0 x0 h5 y19b9 ff5e fs2 fc0 sc0 ls3b">但IE却会为自定义特性也创建属性，如下面的例子所示： </div><div class="t m0 x5 hb y1acc ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1acd ff5f fs6 fc0 sc0 ls21 wsb">alert(div.id);                       //&quot;myDiv&quot; </div><div class="t m0 x0 h36 y1ace ff5f fs6 fc0 sc0 ls21 wsb">alert(div.my_special_attribute);      //undefined（IE除外） </div><div class="t m0 x0 hb y1acf ff5f fs6 fc0 sc0 ls21 wsb">alert(div.align);                    //&quot;left&quot; </div><div class="t m0 x5 hb y1ad0 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1ad1 ff66 fs2 fc0 sc0 ls25 wsb">ElementAttributesExample02.htm </div><div class="t m0 x0 h4 y1ad2 ff5e fs2 fc0 sc0 ls8 wseb">有两类特殊的特性，它们虽然有对应的属性名，但属性的值与通过getAttribute()返回的值并不</div><div class="t m0 x0 hc y1ad3 ff5e fs2 fc0 sc0 ls8 wseb">相同。第一类特性就是style，用于通过CSS为元素指定样式。在通过getAttribute()访问时，返</div><div class="t m0 x0 hc y1ad4 ff5e fs2 fc0 sc0 ls8 wseb">回的style特性值中包含的是CSS文本，而通过属性来访问它则会返回一个对象。由于style 属性是</div><div class="t m0 x0 hc y1ad5 ff5e fs2 fc0 sc0 ls8 wseb">用于以编程方式访问元素样式的（本章后面讨论），因此并没有直接映射到style特性。 </div><div class="t m0 x0 h4 y1ad6 ff5e fs2 fc0 sc0 ls8 wseb">第二类与众不同的特性是onclick这样的事件处理程序。当在元素上使用时，onclick特性中包</div><div class="t m0 x0 h5 y1ad7 ff5e fs2 fc0 sc0 ls55 wsfc">含的是JavaScript代码，如果通过 getAttribute()访问，则会返回相应代码的字符串。而在访问</div><div class="t m0 x0 h5 y1ad8 ff5f fs1 fc0 sc0 ls9 ws2">onclick属性时，则会返回一个JavaScript函数（如果未在元素中指定相应特性，则返回null）。这是</div><div class="t m0 x0 hc y1ad9 ff5e fs2 fc0 sc0 ls8 wseb">因为onclick及其他事件处理程序属性本身就应该被赋予函数值。 </div><div class="t m0 x0 h5 y465 ff5e fs2 fc0 sc0 ls8 wseb">由于存在这些差别，在通过JavaScript以编程方式操作DOM时，开发人员经常不使用 getAttri- </div><div class="t m0 x0 h21 y1ada ff5f fs1 fc0 sc0 ls5d ws4b">bute()，而是只使用对象的属性。只有在取得自定义特性值的情况下，才会使用getAttribute()方法。 </div><div class="t m0 x5 h5 y1adb ff58 fs2 fc0 sc0 ls3a">在IE7及以前版本中，通过getAttribute()方法访问style特性或onclick这样</div><div class="t m0 x5 ha y1adc ff58 fs2 fc0 sc0 ls5c ws23f">的事件处理特性时，返回的值与属性的值相同。换句话说，getAttribute(&quot;style&quot;)返</div><div class="t m0 x5 h18 y1add ff58 fs2 fc0 sc0 ls5c ws23f">回一个对象，而getAttribute(&quot;onclick&quot;)返回一个函数。虽然IE8 已经修复了这个</div><div class="t m0 x5 h5 y1ade ff57 fs2 fc0 sc0 ls75 ws242">bug，但不同IE版本间的不一致性，也是导致开发人员不使用getAttribute()访问HTML</div><div class="t m0 x5 h5 y1adf ff58 fs2 fc0 sc0 ls5c ws23f">特性的一个原因。 </div><div class="t m0 x0 h3c y1ae0 ff5c fs2 fc0 sc0 ls2e wsb">3. 设置特性 </div><div class="t m0 x0 h4 y1ae1 ff5e fs2 fc0 sc0 ls27d">与getAttribute()对应的方法是setAttribute()，这个方法接受两个参数：要设置的特性名和</div><div class="t m0 x0 h1e y1ae2 ff5e fs2 fc0 sc0 ls1f ws108">值。如果特性已经存在，setAttribute()会以指定的值替换现有的值；如果特性不存在，setAttribute()</div><div class="t m0 x0 h5 y378 ff5e fs2 fc0 sc0 ls8 wseb">则创建该属性并设置相应的值。来看下面的例子： </div><div class="t m0 x5 hb y861 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1ae3 ff5f fs6 fc0 sc0 ls21 wsb">div.setAttribute(&quot;id&quot;, &quot;someOtherId&quot;); </div><div class="t m0 x0 hb y1ae4 ff5f fs6 fc0 sc0 ls21 wsb">div.setAttribute(&quot;class&quot;, &quot;ft&quot;); </div><div class="t m0 x0 hb y1ae5 ff5f fs6 fc0 sc0 ls21 wsb">div.setAttribute(&quot;title&quot;, &quot;Some other text&quot;); </div><div class="t m0 x0 hb y1ae6 ff5f fs6 fc0 sc0 ls21 wsb">div.setAttribute(&quot;lang&quot;,&quot;fr&quot;); </div><div class="t m0 x0 hb y1ae7 ff5f fs6 fc0 sc0 ls21 wsb">div.setAttribute(&quot;dir&quot;, &quot;rtl&quot;); </div><div class="t m0 x5 hb y1ae8 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1ae9 ff66 fs2 fc0 sc0 ls25 wsb">ElementAttributesExample01.htm </div></div></div>
<div id="pf11c" class="pf w0 h0" data-page-no="11c"><div class="pc pc11c w0 h0"><div class="t m0 x0 h2 y1 ff57 fs0 fc0 sc0 ls7 ws0">266  第10章 DOM </div><div class="t m0 x0 h3 y2 ff57 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff5e fs2 fc0 sc0 ls8 wseb">通过setAttribute()方法既可以操作HTML特性也可以操作自定义特性。通过这个方法设置的</div><div class="t m0 x0 hc y4d ff5e fs2 fc0 sc0 ls8 wseb">特性名会被统一转换为小写形式，即&quot;ID&quot;最终会变成&quot;id&quot;。 </div><div class="t m0 x0 h5 y5 ff5e fs2 fc0 sc0 ls8 wseb">因为所有特性都是属性，所以直接给属性赋值可以设置特性的值，如下所示。 </div><div class="t m0 x0 hb y6bd ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y6be ff5f fs6 fc0 sc0 ls21 wsb">div.id = &quot;someOtherId&quot;; </div><div class="t m0 x0 hb y6bf ff5f fs6 fc0 sc0 ls21 wsb">div.align = &quot;left&quot;; </div><div class="t m0 x0 hb y1aeb ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y7b1 ff5e fs2 fc0 sc0 ls8 wseb">不过，像下面这样为DOM元素添加一个自定义的属性，该属性不会自动成为元素的特性。 </div><div class="t m0 x0 hb y5a0 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1aec ff5f fs6 fc0 sc0 ls21 wsb">div.mycolor = &quot;red&quot;; </div><div class="t m0 x0 h16 y1aed ff5f fs6 fc0 sc0 ls21 wsb">alert(div.getAttribute(&quot;mycolor&quot;)); //null（IE除外） </div><div class="t m0 x0 hb y1aee ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1aef ff5e fs2 fc0 sc0 ls8 wseb">这个例子添加了一个名为mycolor的属性并将它的值设置为&quot;red&quot;。在大多数浏览器中，这个属</div><div class="t m0 x0 h1e y1af0 ff5e fs2 fc0 sc0 ls8 wseb">性都不会自动变成元素的特性，因此想通过getAttribute()取得同名特性的值，结果会返回null。</div><div class="t m0 x0 h5 y26b ff5e fs2 fc0 sc0 ls8 wseb">可是，自定义属性在IE中会被当作元素的特性，反之亦然。 </div><div class="t m0 x5 h5 y1af1 ff58 fs2 fc0 sc0 ls3b">在IE7及以前版本中，setAttribute()存在一些异常行为。通过这个方法设置</div><div class="t m0 x0 ha y1af2 ff5f fs1 fc0 sc0 ls9 ws2">class和style特性，没有任何效果，而使用这个方法设置事件处理程序特性时也</div><div class="t m0 x0 h5 y1af3 ff58 fs2 fc0 sc0 ls8 ws14">一样。尽管到了IE8才解决这些问题，但我们还是推荐通过属性来设置特性。 </div><div class="t m0 x0 h4 y1af4 ff5e fs2 fc0 sc0 ls8 wseb">要介绍的最后一个方法是removeAttribute()，这个方法用于彻底删除元素的特性。调用这个方</div><div class="t m0 x0 h5 y1af5 ff5e fs2 fc0 sc0 ls8 wseb">法不仅会清除特性的值，而且也会从元素中完全删除特性，如下所示： </div><div class="t m0 x0 hb y1af6 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1af7 ff5f fs6 fc0 sc0 ls21 wsb">div.removeAttribute(&quot;class&quot;); </div><div class="t m0 x0 hb y1af8 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1af9 ff5e fs2 fc0 sc0 ls8 wseb">这个方法并不常用，但在序列化DOM元素时，可以通过它来确切地指定要包含哪些特性。 </div><div class="t m0 x5 h5 y1afa ff57 fs2 fc0 sc0 ls2a ws21">IE6及以前版本不支持removeAttribute()。 </div><div class="t m0 x0 h50 y1afb ff5c fs2 fc0 sc0 ls2e wsb">4. attributes属性 </div><div class="t m0 x0 h5 y1afc ff5f fs1 fc0 sc0 ls9 ws2">Element类型是使用attributes属性的唯一一个DOM节点类型。attributes属性中包含一个</div><div class="t m0 x0 h4 y1a96 ff5f fs1 fc0 sc0 ls9 ws2">NamedNodeMap，与NodeList类似，也是一个“动态”的集合。元素的每一个特性都由一个Attr节</div><div class="t m0 x0 hc y1afd ff5e fs2 fc0 sc0 ls8 wseb">点表示，每个节点都保存在NamedNodeMap对象中。NamedNodeMap对象拥有下列方法。 </div><div class="t m0 x0 h5 y1afe ff5d fs1 fc0 sc0 ls2"> getNamedItem(name)：返回nodeName属性等于name的节点； </div><div class="t m0 x0 h5 y1aff ff5d fs1 fc0 sc0 ls2"> removeNamedItem(name)：从列表中移除nodeName属性等于name的节点； </div><div class="t m0 x0 h5 y1b00 ff5d fs1 fc0 sc0 ls2"> setNamedItem(node)：向列表中添加节点，以节点的nodeName属性为索引； </div><div class="t m0 x0 h5 y1b01 ff5d fs1 fc0 sc0 ls2"> item(pos)：返回位于数字pos位置处的节点。 </div><div class="t m0 x0 h4 y1b02 ff5f fs1 fc0 sc0 ls9 ws2">attributes属性中包含一系列节点，每个节点的nodeName就是特性的名称，而节点的nodeValue</div><div class="t m0 x0 h5 y13d0 ff5e fs2 fc0 sc0 ls8 wseb">就是特性的值。要取得元素的id特性，可以使用以下代码。 </div><div class="t m0 x0 hb y1b03 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1b04 ff5f fs6 fc0 sc0 ls21 wsb">var id = element.attributes.getNamedItem(&quot;id&quot;).nodeValue; </div><div class="t m0 x0 hb y1b05 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1b06 ff5e fs2 fc0 sc0 ls8 wseb">以下是使用方括号语法通过特性名称访问节点的简写方式。 </div><div class="t m0 x0 hb y1b07 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1b08 ff5f fs6 fc0 sc0 ls21 wsb">var id = element.attributes[&quot;id&quot;].nodeValue; </div><div class="t m0 x0 hb y1b09 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1b0a ff5e fs2 fc0 sc0 ls8 wseb">也可以使用这种语法来设置特性的值，即先取得特性节点，然后再将其nodeValue设置为新值，</div><div class="t m0 x0 h5 yeac ff5e fs2 fc0 sc0 ls8 wseb">如下所示。 </div></div></div>
<div id="pf11d" class="pf w0 h0" data-page-no="11d"><div class="pc pc11d w0 h0"><div class="t m0 x2 h2 y1 ff57 fs0 fc0 sc0 ls7 ws0">10.1 节点层次    267 </div><div class="t m0 x0 h3 y2 ff57 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff59 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff59 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff59 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff59 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff59 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff59 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff59 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff59 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff59 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff59 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff59 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff59 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff59 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y79 ff5f fs6 fc0 sc0 ls21 wsb">element.attributes[&quot;id&quot;].nodeValue = &quot;someOtherId&quot;; </div><div class="t m0 x5 hb y1b0b ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1b0c ff5e fs2 fc0 sc0 ls8 wseb">调用removeNamedItem()方法与在元素上调用removeAttribute()方法的效果相同——直接删</div><div class="t m0 x0 h1e y1b0d ff5e fs2 fc0 sc0 ls8 wseb">除具有给定名称的特性。下面的例子展示了两个方法间唯一的区别，即removeNamedItem()返回表示</div><div class="t m0 x0 h5 y1b0e ff5e fs2 fc0 sc0 ls8 wseb">被删除特性的Attr节点。 </div><div class="t m0 x5 hb y1b0f ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1b10 ff5f fs6 fc0 sc0 ls21 wsb">var oldAttr = element.attributes.removeNamedItem(&quot;id&quot;); </div><div class="t m0 x5 hb y1b11 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1b12 ff5e fs2 fc0 sc0 ls8 wseb">最后，setNamedItem()是一个很不常用的方法，通过这个方法可以为元素添加一个新特性，为此</div><div class="t m0 x0 h5 y1b13 ff5e fs2 fc0 sc0 ls8 wseb">需要为它传入一个特性节点，如下所示。 </div><div class="t m0 x5 hb y1b14 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1b15 ff5f fs6 fc0 sc0 ls21 wsb">element.attributes.setNamedItem(newAttr); </div><div class="t m0 x5 hb y1b16 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1b17 ff5e fs2 fc0 sc0 ls221 ws21e">一般来说，由于前面介绍的attributes的方法不够方便，因此开发人员更多的会使用</div><div class="t m0 x0 h5 y9e8 ff5f fs1 fc0 sc0 ls9 ws2">getAttribute()、removeAttribute()和setAttribute()方法。 </div><div class="t m0 x0 hc y1b18 ff5e fs2 fc0 sc0 ls8 wseb">不过，如果想要遍历元素的特性，attributes属性倒是可以派上用场。在需要将DOM结构序列</div><div class="t m0 x0 h5 y1b19 ff5e fs2 fc0 sc0 ls8 wseb">化为XML或HTML字符串时，多数都会涉及遍历元素特性。以下代码展示了如何迭代元素的每一个特</div><div class="t m0 x0 hc y1b1a ff5e fs2 fc0 sc0 ls8 wseb">性，然后将它们构造成name=&quot;value&quot; name=&quot;value&quot;这样的字符串格式。 </div><div class="t m0 x5 hb y1b1b ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1b1c ff5f fs6 fc0 sc0 ls21 wsb">function outputAttributes(element){ </div><div class="t m0 x0 hb y1b1d ff5f fs6 fc0 sc0 ls21 wsb">    var pairs = new Array(), </div><div class="t m0 x0 hb y1b1e ff5f fs6 fc0 sc0 ls21 wsb">        attrName, </div><div class="t m0 x0 hb y1b1f ff5f fs6 fc0 sc0 ls21 wsb">        attrValue, </div><div class="t m0 x0 hb y1b20 ff5f fs6 fc0 sc0 ls21 wsb">        i, </div><div class="t m0 x0 hb y1b21 ff5f fs6 fc0 sc0 ls21 wsb">        len; </div><div class="t m0 x0 hb y1b22 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1b23 ff5f fs6 fc0 sc0 ls21 wsb">    for (i=0, len=element.attributes.length; i &lt; len; i++){ </div><div class="t m0 x0 hb y1b24 ff5f fs6 fc0 sc0 ls21 wsb">        attrName = element.attributes[i].nodeName; </div><div class="t m0 x0 hb y1b25 ff5f fs6 fc0 sc0 ls21 wsb">        attrValue = element.attributes[i].nodeValue; </div><div class="t m0 x0 hb y1b26 ff5f fs6 fc0 sc0 ls21 wsb">        pairs.push(attrName + &quot;=\&quot;&quot; + attrValue + &quot;\&quot;&quot;); </div><div class="t m0 x0 hb y1b27 ff5f fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y1b28 ff5f fs6 fc0 sc0 ls21 wsb">    return pairs.join(&quot; &quot;); </div><div class="t m0 x0 hb y1b29 ff5f fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x2 hf y7c5 ff66 fs2 fc0 sc0 ls25 wsb">ElementAttributesExample03.htm </div><div class="t m0 x0 h4 y1b2a ff5e fs2 fc0 sc0 ls8 wseb">这个函数使用了一个数组来保存名值对，最后再以空格为分隔符将它们拼接起来（这是序列化长字</div><div class="t m0 x0 h1e y1b2b ff5e fs2 fc0 sc0 ls8 wseb">符串时的一种常用技巧）。通过attributes.length属性，for循环会遍历每个特性，将特性的名称</div><div class="t m0 x0 h5 y1b2c ff5e fs2 fc0 sc0 ls8 wseb">和值输出为字符串。关于以上代码的运行结果，以下是两点必要的说明。 </div><div class="t m0 x0 h5 y11a3 ff5d fs1 fc0 sc0 ls2"> 针对attributes对象中的特性，不同浏览器返回的顺序不同。这些特性在XML或HTML 代</div><div class="t m0 x5 h5 y1b2d ff5e fs2 fc0 sc0 ls8 wseb">码中出现的先后顺序，不一定与它们出现在attributes对象中的顺序一致。 </div><div class="t m0 x0 h5 y1b2e ff5d fs1 fc0 sc0 ls2"> IE7及更早的版本会返回HTML元素中所有可能的特性，包括没有指定的特性。换句话说，返</div><div class="t m0 x5 h5 y1b2f ff5e fs2 fc0 sc0 ls3b">回100多个特性的情况会很常见。 </div><div class="t m0 x0 h5 y1b30 ff5e fs2 fc0 sc0 ls8 wseb">针对IE7及更早版本中存在的问题，可以对上面的函数加以改进，让它只返回指定的特性。每个特</div><div class="t m0 x0 h14 y1b31 ff5e fs2 fc0 sc0 ls8 wseb">性节点都有一个名为specified的属性，这个属性的值如果为true，则意味着要么是在 HTML中指</div><div class="t m0 x0 h5 ycb7 ff5e fs2 fc0 sc0 ls8 wseb">定了相应特性，要么是通过setAttribute()方法设置了该特性。在IE中，所有未设置过的特性的该</div><div class="t m0 x0 h1e y1b32 ff5e fs2 fc0 sc0 ls8 wseb">属性值都为false，而在其他浏览器中根本不会为这类特性生成对应的特性节点（因此，在这些浏览器</div><div class="t m0 x0 hc ycb9 ff5e fs2 fc0 sc0 ls8 wseb">中，任何特性节点的specified值始终为true）。改进后的代码如下所示。 </div></div></div>
<div id="pf11e" class="pf w0 h0" data-page-no="11e"><div class="pc pc11e w0 h0"><div class="t m0 x0 h2 y1 ff57 fs0 fc0 sc0 ls7 ws0">268  第10章 DOM </div><div class="t m0 x0 h3 y2 ff57 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 ff5f fs6 fc0 sc0 ls21 wsb">function outputAttributes(element){ </div><div class="t m0 x0 hb y7a ff5f fs6 fc0 sc0 ls21 wsb">    var pairs = new Array(), </div><div class="t m0 x0 hb y7b ff5f fs6 fc0 sc0 ls21 wsb">        attrName, </div><div class="t m0 x0 hb y7c ff5f fs6 fc0 sc0 ls21 wsb">        attrValue, </div><div class="t m0 x0 hb y7d ff5f fs6 fc0 sc0 ls21 wsb">        i, </div><div class="t m0 x0 hb y7e ff5f fs6 fc0 sc0 ls21 wsb">        len; </div><div class="t m0 x0 hb y7f ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y80 ff5f fs6 fc0 sc0 ls21 wsb">    for (i=0, len=element.attributes.length; i &lt; len; i++){ </div><div class="t m0 x0 hb y81 ff5f fs6 fc0 sc0 ls21 wsb">        attrName = element.attributes[i].nodeName; </div><div class="t m0 x0 hb y82 ff5f fs6 fc0 sc0 ls21 wsb">        attrValue = element.attributes[i].nodeValue; </div><div class="t m0 x0 hb y83 ff5f fs6 fc0 sc0 ls21 wsb">        if (element.attributes[i].specified) { </div><div class="t m0 x0 h15 y84 ff63 fs6 fc0 sc0 ls21 wsb">            pairs.push(attrName + &quot;=\&quot;&quot; + attrValue + &quot;\&quot;&quot;); </div><div class="t m0 x0 h15 y85 ff63 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y86 ff63 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y87 ff5f fs6 fc0 sc0 ls21 wsb">    return pairs.join(&quot; &quot;); </div><div class="t m0 x0 hb y88 ff5f fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x2 hf y1b34 ff66 fs2 fc0 sc0 ls1b wsb">ElementAttributesExample04.htm </div><div class="t m0 x0 h5 y1b35 ff5e fs2 fc0 sc0 ls8 wseb">这个经过改进的函数可以确保即使在IE7及更早的版本中，也会只返回指定的特性。 </div><div class="t m0 x0 h3c y1b36 ff5c fs2 fc0 sc0 ls2e wsb">5. 创建元素 </div><div class="t m0 x0 h4 y1b37 ff5e fs2 fc0 sc0 ls8 wseb">使用document.createElement()方法可以创建新元素。这个方法只接受一个参数，即要创建元</div><div class="t m0 x0 h5 y1b38 ff5e fs2 fc0 sc0 ls8 wseb">素的标签名。这个标签名在HTML文档中不区分大小写，而在XML（包括XHTML）文档中，则是区</div><div class="t m0 x0 hc y1b39 ff5e fs2 fc0 sc0 ls8 wseb">分大小写的。例如，使用下面的代码可以创建一个&lt;div&gt;元素。 </div><div class="t m0 x0 hb y1b3a ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1b3b ff5f fs6 fc0 sc0 ls21 wsb">var div = document.createElement(&quot;div&quot;); </div><div class="t m0 x0 hb y1b3c ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1b3d ff5e fs2 fc0 sc0 ls8 wseb">在使用createElement()方法创建新元素的同时，也为新元素设置了ownerDocuemnt属性。此</div><div class="t m0 x0 h5 y1b3e ff5e fs2 fc0 sc0 ls8 wseb">时，还可以操作元素的特性，为它添加更多子节点，以及执行其他操作。来看下面的例子。 </div><div class="t m0 x0 hb y930 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1b3f ff5f fs6 fc0 sc0 ls21 wsb">div.id = &quot;myNewDiv&quot;; </div><div class="t m0 x0 hb y1b40 ff5f fs6 fc0 sc0 ls21 wsb">div.className = &quot;box&quot;; </div><div class="t m0 x0 hb y1b41 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y14af ff5e fs2 fc0 sc0 ls8 wseb">在新元素上设置这些特性只是给它们赋予了相应的信息。由于新元素尚未被添加到文档树中，因此</div><div class="t m0 x0 h4 y1b42 ff5e fs2 fc0 sc0 ls8 wseb">设置这些特性不会影响浏览器的显示。要把新元素添加到文档树，可以使用appendChild()、inser- </div><div class="t m0 x0 h21 y1b43 ff5f fs1 fc0 sc0 ls9 ws2">tBefore()或replaceChild()方法。下面的代码会把新创建的元素添加到文档的&lt;body&gt;元素中。 </div><div class="t m0 x0 hb y1a97 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1b44 ff5f fs6 fc0 sc0 ls21 wsb">document.body.appendChild(div); </div><div class="t m0 x0 hb y1b45 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1380 ff66 fs2 fc0 sc0 ls5e wsb">CreateElementExample01.htm </div><div class="t m0 x0 h4 y1b46 ff5e fs2 fc0 sc0 ls8 wseb">一旦将元素添加到文档树中，浏览器就会立即呈现该元素。此后，对这个元素所作的任何修改都会</div><div class="t m0 x0 h5 y1b47 ff5e fs2 fc0 sc0 ls8 wseb">实时反映在浏览器中。 </div><div class="t m0 x0 h5 y1b48 ff5e fs2 fc0 sc0 ls3b">在IE中可以以另一种方式使用createElement()，即为这个方法传入完整的元素标签，也可以包</div><div class="t m0 x0 h5 y1b49 ff5e fs2 fc0 sc0 ls8 wseb">含属性，如下面的例子所示。 </div><div class="t m0 x0 hb y1b4a ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1b4b ff5f fs6 fc0 sc0 ls21 wsb">var div = document.createElement(&quot;&lt;div id=\&quot;myNewDiv\&quot; class=\&quot;box\&quot;&gt;&lt;/div &gt;&quot;); </div><div class="t m0 x0 hb y1b4c ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1b4d ff5e fs2 fc0 sc0 ls8 wseb">这种方式有助于避开在IE7及更早版本中动态创建元素的某些问题。下面是已知的一些这类问题。 </div><div class="t m0 x0 h5 y1b4e ff5d fs1 fc0 sc0 ls2"> 不能设置动态创建的&lt;iframe&gt;元素的name特性。 </div><div class="t m0 x0 h5 y1b4f ff5d fs1 fc0 sc0 ls2"> 不能通过表单的reset()方法重设动态创建的&lt;input&gt;元素（第13章将讨论reset()方法）。 </div></div></div>
<div id="pf11f" class="pf w0 h0" data-page-no="11f"><div class="pc pc11f w0 h0"><div class="t m0 x2 h2 y1 ff57 fs0 fc0 sc0 ls7 ws0">10.1 节点层次    269 </div><div class="t m0 x0 h3 y2 ff57 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff59 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff59 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff59 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff59 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff59 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff59 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff59 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff59 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff59 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff59 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff59 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff59 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff59 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff5d fs1 fc0 sc0 ls2"> 动态创建的type特性值为&quot;reset&quot;的&lt;buttou&gt;元素重设不了表单。 </div><div class="t m0 x0 h4 y4 ff5d fs1 fc0 sc0 ls2"> 动态创建的一批name相同的单选按钮彼此毫无关系。name值相同的一组单选按钮本来应该用</div><div class="t m0 x5 h5 y5 ff5e fs2 fc0 sc0 ls8 wseb">于表示同一选项的不同值，但动态创建的一批这种单选按钮之间却没有这种关系。 </div><div class="t m0 x0 hc y6 ff5e fs2 fc0 sc0 ls1f ws108">上述所有问题都可以通过在createElement()中指定完整的HTML标签来解决，如下面的例子所示。 </div><div class="t m0 x5 hb ya81 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1b50 ff5f fs6 fc0 sc0 ls21 wsb">if (client.browser.ie &amp;&amp; client.browser.ie &lt;=7){ </div><div class="t m0 x0 hb y1b51 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1b52 ff5f fs6 fc0 sc0 ls21 wsb">    //创建一个带name特性的iframe元素 </div><div class="t m0 x0 hb y1b53 ff5f fs6 fc0 sc0 ls21 wsb">    var iframe = document.createElement(&quot;&lt;iframe name=\&quot;myframe\&quot;&gt;&lt;/iframe&gt;&quot;); </div><div class="t m0 x0 hb y1b54 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1b55 ff5f fs6 fc0 sc0 ls21 wsb">    //创建input元素 </div><div class="t m0 x0 hb y1b56 ff5f fs6 fc0 sc0 ls21 wsb">    var input = document.createElement(&quot;&lt;input type=\&quot;checkbox\&quot;&gt;&quot;); </div><div class="t m0 x0 hb y1b57 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1b58 ff5f fs6 fc0 sc0 ls21 wsb">    //创建button元素 </div><div class="t m0 x0 hb y1b59 ff5f fs6 fc0 sc0 ls21 wsb">    var button = document.createElement(&quot;&lt;button type=\&quot;reset\&quot;&gt;&lt;/button&gt;&quot;); </div><div class="t m0 x0 hb y1b5a ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1b5b ff5f fs6 fc0 sc0 ls21 wsb">    //创建单选按钮 </div><div class="t m0 x0 h16 y1b5c ff5f fs6 fc0 sc0 ls21 wsb">    var radio1 = document.createElement(&quot;&lt;input type=\&quot;radio\&quot; name=\&quot;choice\&quot; &quot;＋ </div><div class="t m0 x5 hb y1b5d ff5f fs6 fc0 sc0 ls21 wsb">&quot;value=\&quot;1\&quot;&gt;&quot;); </div><div class="t m0 x0 h16 y1b5e ff5f fs6 fc0 sc0 ls21 wsb">    var radio2 = document.createElement(&quot;&lt;input type=\&quot;radio\&quot; name=\&quot;choice\&quot; &quot;＋  </div><div class="t m0 x5 hb y1b5f ff5f fs6 fc0 sc0 ls21 wsb">&quot;value=\&quot;2\&quot;&gt;&quot;); </div><div class="t m0 x0 hb y1b60 ff5f fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h5 y13 ff5e fs2 fc0 sc0 ls8 wseb">与使用createElement()的惯常方式一样，这样的用法也会返回一个DOM元素的引用。可以将</div><div class="t m0 x0 h4 y14 ff5e fs2 fc0 sc0 ls8 wseb">这个引用添加到文档中，也可以对其加以增强。但是，由于这样的用法要求使用浏览器检测，因此我们</div><div class="t m0 x0 h5 y15 ff5e fs2 fc0 sc0 ls8 wseb">建议只在需要避开IE及更早版本中上述某个问题的情况下使用。其他浏览器都不支持这种用法。 </div><div class="t m0 x0 h3c y1b61 ff5c fs2 fc0 sc0 ls2e wsb">6. 元素的子节点 </div><div class="t m0 x0 h4 y1b62 ff5e fs2 fc0 sc0 ls16c ws130">元素可以有任意数目的子节点和后代节点，因为元素可以是其他元素的子节点。元素的</div><div class="t m0 x0 h4 ydad ff5f fs1 fc0 sc0 ls9 ws2">childNodes属性中包含了它的所有子节点，这些子节点有可能是元素、文本节点、注释或处理指令。</div><div class="t m0 x0 h5 y1b63 ff5e fs2 fc0 sc0 ls8 wseb">不同浏览器在看待这些节点方面存在显著的不同，以下面的代码为例。 </div><div class="t m0 x5 hb y1b64 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4b8 ff5f fs6 fc0 sc0 ls21 wsb">&lt;ul id=&quot;myList&quot;&gt; </div><div class="t m0 x0 hb y1b65 ff5f fs6 fc0 sc0 ls21 wsb">    &lt;li&gt;Item 1&lt;/li&gt; </div><div class="t m0 x0 hb y1b66 ff5f fs6 fc0 sc0 ls21 wsb">    &lt;li&gt;Item 2&lt;/li&gt; </div><div class="t m0 x0 hb y1b67 ff5f fs6 fc0 sc0 ls21 wsb">    &lt;li&gt;Item 3&lt;/li&gt; </div><div class="t m0 x0 hb y1b68 ff5f fs6 fc0 sc0 ls21 wsb">&lt;/ul&gt; </div><div class="t m0 x5 hb y1b69 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1b6a ff5e fs2 fc0 sc0 ls8 wseb">如果是IE来解析这些代码，那么&lt;ul&gt;元素会有3个子节点，分别是3个&lt;li&gt;元素。但如果是在其</div><div class="t m0 x0 h5 y1b6b ff5e fs2 fc0 sc0 ls8 wseb">他浏览器中，&lt;ul&gt;元素都会有7个元素，包括3个&lt;li&gt;元素和4个文本节点（表示&lt;li&gt;元素之间的空</div><div class="t m0 x0 h5 y1b6c ff5e fs2 fc0 sc0 ls8 wseb">白符）。如果像下面这样将元素间的空白符删除，那么所有浏览器都会返回相同数目的子节点。 </div><div class="t m0 x0 hb y1b6d ff5f fs6 fc0 sc0 ls21 wsb">&lt;ul id=&quot;myList&quot;&gt;&lt;li&gt;Item 1&lt;/li&gt;&lt;li&gt;Item 2&lt;/li&gt;&lt;li&gt;Item 3&lt;/li&gt;&lt;/ul&gt; </div><div class="t m0 x0 h5 y1b6e ff5e fs2 fc0 sc0 ls8 wseb">对于这段代码，&lt;ul&gt;元素在任何浏览器中都会包含3个子节点。如果需要通过childNodes属性</div><div class="t m0 x0 h4 y1b6f ff5e fs2 fc0 sc0 ls8 wseb">遍历子节点，那么一定不要忘记浏览器间的这一差别。这意味着在执行某项操作以前，通常都要先检查</div><div class="t m0 x0 hc y1b70 ff5e fs2 fc0 sc0 ls8 wseb">一下nodeTpye属性，如下面的例子所示。 </div><div class="t m0 x5 hb y1b71 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1b72 ff5f fs6 fc0 sc0 ls21 wsb">for (var i=0, len=element.childNodes.length; i &lt; len; i++){ </div><div class="t m0 x0 hb y1b73 ff5f fs6 fc0 sc0 ls21 wsb">    if (element.childNodes[i].nodeType == 1){ </div><div class="t m0 x0 h16 y1b74 ff5f fs6 fc0 sc0 ls21 wsb">        //执行某些操作 </div><div class="t m0 x0 hb y1b75 ff5f fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y1b76 ff5f fs6 fc0 sc0 ls21 wsb">}   </div></div></div>
<div id="pf120" class="pf w0 h0" data-page-no="120"><div class="pc pc120 w0 h0"><div class="t m0 x0 h2 y1 ff57 fs0 fc0 sc0 ls7 ws0">270  第10章 DOM </div><div class="t m0 x0 h3 y2 ff57 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff5e fs2 fc0 sc0 ls8 wseb">这个例子会循环遍历特定元素的每一个子节点，然后只在子节点的nodeType等于1（表示是元素</div><div class="t m0 x0 h5 y4d ff5e fs2 fc0 sc0 ls8 wseb">节点）的情况下，才会执行某些操作。 </div><div class="t m0 x0 h4 yd8 ff5e fs2 fc0 sc0 ls16c ws130">如果想通过某个特定的标签名取得子节点或后代节点该怎么办呢？实际上，元素也支持</div><div class="t m0 x0 h4 yd9 ff5f fs1 fc0 sc0 ls9 ws2">getElementsByTagName()方法。在通过元素调用这个方法时，除了搜索起点是当前元素之外，其他</div><div class="t m0 x0 h1e y15d ff5e fs2 fc0 sc0 ls8 wseb">方面都跟通过document调用这个方法相同，因此结果只会返回当前元素的后代。例如，要想取得前面</div><div class="t m0 x0 h5 y8 ff5f fs1 fc0 sc0 ls9 ws2">&lt;ul&gt;元素中包含的所有&lt;li&gt;元素，可以使用下列代码。 </div><div class="t m0 x0 hb y1b77 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1b78 ff5f fs6 fc0 sc0 ls21 wsb">var ul = document.getElementById(&quot;myList&quot;); </div><div class="t m0 x0 hb y1b79 ff5f fs6 fc0 sc0 ls21 wsb">var items = ul.getElementsByTagName(&quot;li&quot;); </div><div class="t m0 x0 hb y1b7a ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1b7b ff5e fs2 fc0 sc0 ls5 wsec">要注意的是，这里&lt;ul&gt;的后代中只包含直接子元素。不过，如果它包含更多层次的后代元素，那</div><div class="t m0 x0 hc y1b7c ff5e fs2 fc0 sc0 ls8 wseb">么各个层次中包含的&lt;li&gt;元素也都会返回。 </div><div class="t m0 x0 h20 y1b7d ff5c fs3 fc0 sc0 ls248 ws214">10.1.4 Text类型 </div><div class="t m0 x0 h4 ye2a ff5e fs2 fc0 sc0 ls8 wseb">文本节点由Text类型表示，包含的是可以照字面解释的纯文本内容。纯文本中可以包含转义后的</div><div class="t m0 x0 hc ye2b ff57 fs2 fc0 sc0 lsfa wsc9">HTML字符，但不能包含HTML代码。Text节点具有以下特征： </div><div class="t m0 x0 h5 y1aae ff5d fs1 fc0 sc0 ls2"> nodeType的值为3； </div><div class="t m0 x0 h5 ycd4 ff5d fs1 fc0 sc0 ls2"> nodeName的值为&quot;#text&quot;； </div><div class="t m0 x0 h5 y1b7e ff5d fs1 fc0 sc0 ls2"> nodeValue的值为节点所包含的文本； </div><div class="t m0 x0 h5 ye2f ff5d fs1 fc0 sc0 ls2"> parentNode是一个Element； </div><div class="t m0 x0 h5 y1b7f ff5d fs1 fc0 sc0 ls2"> 不支持（没有）子节点。 </div><div class="t m0 x0 h4 y1b80 ff5e fs2 fc0 sc0 ls8 wseb">可以通过nodeValue属性或data 属性访问Text节点中包含的文本，这两个属性中包含的值相</div><div class="t m0 x0 hc y1b81 ff5e fs2 fc0 sc0 ls8 wseb">同。对nodeValue的修改也会通过data反映出来，反之亦然。使用下列方法可以操作节点中的文本。 </div><div class="t m0 x0 h5 y1b82 ff5d fs1 fc0 sc0 ls2"> appendData(text)：将text添加到节点的末尾。 </div><div class="t m0 x0 h5 y1b83 ff5d fs1 fc0 sc0 ls2"> deleteData(offset, count)：从offset指定的位置开始删除count个字符。 </div><div class="t m0 x0 h5 y1b84 ff5d fs1 fc0 sc0 ls2"> insertData(offset, text)：在offset指定的位置插入text。 </div><div class="t m0 x0 h4 y141b ff5d fs1 fc0 sc0 ls2"> replaceData(offset, count, text)：用text替换从offset指定的位置开始到offset+ </div><div class="t m0 x0 h21 y1b85 ff67 fs1 fc0 sc0 ls9 ws2">count为止处的文本。 </div><div class="t m0 x0 h5 ye38 ff5d fs1 fc0 sc0 ls2"> splitText(offset)：从offset指定的位置将当前文本节点分成两个文本节点。 </div><div class="t m0 x0 h4 y1b86 ff5d fs1 fc0 sc0 ls2"> substringData(offset, count)：提取从offset指定的位置开始到offset+count为止</div><div class="t m0 x0 h5 y1b87 ff5e fs2 fc0 sc0 ls8 wseb">处的字符串。 </div><div class="t m0 x0 h1c y1b88 ff5e fs2 fc0 sc0 ls6f ws113">除了这些方法之外，文本节点还有一个length属性，保存着节点中字符的数目。而且，</div><div class="t m0 x0 h5 y1b89 ff5f fs1 fc0 sc0 ls9 ws2">nodeValue.length和data.length中也保存着同样的值。 </div><div class="t m0 x0 h4 y1b8a ff5e fs2 fc0 sc0 ls8 wseb">在默认情况下，每个可以包含内容的元素最多只能有一个文本节点，而且必须确实有内容存在。来</div><div class="t m0 x0 h5 y1b8b ff5e fs2 fc0 sc0 ls8 wseb">看几个例子。 </div><div class="t m0 x0 hb y1b8c ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1b8d ff5f fs6 fc0 sc0 ls21 wsb">&lt;!-- 没有内容，也就没有文本节点 --&gt; </div><div class="t m0 x0 hb y1b8e ff5f fs6 fc0 sc0 ls21 wsb">&lt;div&gt;&lt;/div&gt; </div><div class="t m0 x0 hb y1b8f ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1b90 ff5f fs6 fc0 sc0 ls21 wsb">&lt;!-- 有空格，因而有一个文本节点 --&gt; </div><div class="t m0 x0 hb y1b91 ff5f fs6 fc0 sc0 ls21 wsb">&lt;div&gt; &lt;/div&gt; </div><div class="t m0 x0 hb y1b92 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1b93 ff5f fs6 fc0 sc0 ls21 wsb">&lt;!-- 有内容，因而有一个文本节点 --&gt; </div><div class="t m0 x0 hb y1b94 ff5f fs6 fc0 sc0 ls21 wsb">&lt;div&gt;Hello World!&lt;/div&gt; </div><div class="t m0 x0 hb y1b95 ff5f fs6 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf121" class="pf w0 h0" data-page-no="121"><div class="pc pc121 w0 h0"><div class="t m0 x2 h2 y1 ff57 fs0 fc0 sc0 ls7 ws0">10.1 节点层次    271 </div><div class="t m0 x0 h3 y2 ff57 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff59 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff59 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff59 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff59 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff59 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff59 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff59 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff59 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff59 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff59 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff59 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff59 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff59 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h4 y3 ff5e fs2 fc0 sc0 ls8 wseb">上面代码给出的第一个&lt;div&gt;元素没有内容，因此也就不存在文本节点。开始与结束标签之间只要</div><div class="t m0 x0 h1e y4d ff5e fs2 fc0 sc0 ls8 wseb">存在内容，就会创建一个文本节点。因此，第二个&lt;div&gt;元素中虽然只包含一个空格，但仍然有一个文</div><div class="t m0 x0 h1e y5 ff5e fs2 fc0 sc0 ls8 wseb">本子节点；文本节点的nodeValue值是一个空格。第三个&lt;div&gt;也有一个文本节点，其nodeValue的</div><div class="t m0 x0 h5 yd9 ff5e fs2 fc0 sc0 ls8 wseb">值为&quot;Hello World!&quot;。可以使用以下代码来访问这些文本子节点。 </div><div class="t m0 x0 h16 y28c ff5f fs6 fc0 sc0 ls21 wsb">var textNode = div.firstChild;     //或者div.childNodes[0] </div><div class="t m0 x5 hb y1b96 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1b97 ff5e fs2 fc0 sc0 ls8 wseb">在取得了文本节点的引用后，就可以像下面这样来修改它了。 </div><div class="t m0 x5 hb y158f ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1b98 ff5f fs6 fc0 sc0 ls21 wsb">div.firstChild.nodeValue = &quot;Some other message&quot;; </div><div class="t m0 x2 hf y14e4 ff66 fs2 fc0 sc0 ls8 wsb">TextNodeExample01.htm </div><div class="t m0 x5 hb yc82 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1b99 ff5e fs2 fc0 sc0 ls8 wseb">如果这个文本节点当前存在于文档树中，那么修改文本节点的结果就会立即得到反映。另外，在修</div><div class="t m0 x0 h5 y1b9a ff5e fs2 fc0 sc0 ls8 wseb">改文本节点时还要注意，此时的字符串会经过HTML（或XML，取决于文档类型）编码。换句话说，</div><div class="t m0 x0 h5 y1b9b ff5e fs2 fc0 sc0 ls8 wseb">小于号、大于号或引号都会像下面的例子一样被转义。 </div><div class="t m0 x5 hb y1b9c ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1b9d ff5f fs6 fc0 sc0 ls21">//输出结果是&quot;Some &amp;lt;strong&amp;gt;other&amp;lt;/strong&amp;gt; message&quot; </div><div class="t m0 x0 hb y1b9e ff5f fs6 fc0 sc0 ls21 wsb">div.firstChild.nodeValue = &quot;Some &lt;strong&gt;other&lt;/strong&gt; message&quot;; </div><div class="t m0 x2 hf y1b9f ff66 fs2 fc0 sc0 ls8 wsb">TextNodeExample02.htm </div><div class="t m0 x5 hb y18e ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y193c ff5e fs2 fc0 sc0 ls8 wseb">应该说，这是在向DOM文档中插入文本之前，先对其进行HTML编码的一种有效方式。 </div><div class="t m0 x5 h5 y1ba0 ff58 fs2 fc0 sc0 ls137">在IE8、Firefox、Safari、Chrome和Opera中，可以通过脚本访问Text类型的构造</div><div class="t m0 x5 h5 y1ba1 ff58 fs2 fc0 sc0 ls1f">函数和原型。 </div><div class="t m0 x0 h3c y1ba2 ff5c fs2 fc0 sc0 ls2e wsb">1. 创建文本节点 </div><div class="t m0 x0 h4 y1ba3 ff5e fs2 fc0 sc0 ls44 wsef">可以使用document.createTextNode()创建新文本节点，这个方法接受一个参数——要插入节点</div><div class="t m0 x0 h5 y1ba4 ff5e fs2 fc0 sc0 ls8 wseb">中的文本。与设置已有文本节点的值一样，作为参数的文本也将按照HTML或XML的格式进行编码。 </div><div class="t m0 x5 hb y1ba5 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1ba6 ff5f fs6 fc0 sc0 ls21 wsb">var textNode = document.createTextNode(&quot;&lt;strong&gt;Hello&lt;/strong&gt; world!&quot;); </div><div class="t m0 x5 hb y1ba7 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y152e ff5e fs2 fc0 sc0 ls8 wseb">在创建新文本节点的同时，也会为其设置ownerDocument属性。不过，除非把新节点添加到文档</div><div class="t m0 x0 h1e y1ba8 ff5e fs2 fc0 sc0 ls8 wseb">树中已经存在的节点中，否则我们不会在浏览器窗口中看到新节点。下面的代码会创建一个&lt;div&gt;元素</div><div class="t m0 x0 h5 y7e9 ff5e fs2 fc0 sc0 ls8 wseb">并向其中添加一条消息。 </div><div class="t m0 x5 hb y1ba9 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1baa ff5f fs6 fc0 sc0 ls21 wsb">var element = document.createElement(&quot;div&quot;); </div><div class="t m0 x0 hb y1bab ff5f fs6 fc0 sc0 ls21 wsb">element.className = &quot;message&quot;; </div><div class="t m0 x0 hb y1bac ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1bad ff5f fs6 fc0 sc0 ls21 wsb">var textNode = document.createTextNode(&quot;Hello world!&quot;); </div><div class="t m0 x0 hb y1bae ff5f fs6 fc0 sc0 ls21 wsb">element.appendChild(textNode); </div><div class="t m0 x0 hb y1baf ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1bb0 ff5f fs6 fc0 sc0 ls21 wsb">document.body.appendChild(element); </div><div class="t m0 x2 hf y1bb1 ff66 fs2 fc0 sc0 ls8 wsb">TextNodeExample03.htm </div><div class="t m0 x0 h4 y91c ff5e fs2 fc0 sc0 ls8 wseb">这个例子创建了一个新&lt;div&gt;元素并为它指定了值为&quot;message&quot;的class特性。然后，又创建了</div><div class="t m0 x0 h4 y91d ff5e fs2 fc0 sc0 ls5 wsec">一个文本节点，并将其添加到前面创建的元素中。最后一步，就是将这个元素添加到了文档的&lt;body&gt;</div><div class="t m0 x0 h5 y1bb2 ff5e fs2 fc0 sc0 ls8 wseb">元素中，这样就可以在浏览器中看到新创建的元素和文本节点了。 </div></div></div>
<div id="pf122" class="pf w0 h0" data-page-no="122"><div class="pc pc122 w0 h0"><div class="t m0 x0 h2 y1 ff57 fs0 fc0 sc0 ls7 ws0">272  第10章 DOM </div><div class="t m0 x0 h3 y2 ff57 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ff5e fs2 fc0 sc0 ls8 wseb">一般情况下，每个元素只有一个文本子节点。不过，在某些情况下也可能包含多个文本子节点，如</div><div class="t m0 x0 h5 y4d ff5e fs2 fc0 sc0 ls8 wseb">下面的例子所示。 </div><div class="t m0 x0 hb y2d8 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2d9 ff5f fs6 fc0 sc0 ls21 wsb">var element = document.createElement(&quot;div&quot;); </div><div class="t m0 x0 hb y2da ff5f fs6 fc0 sc0 ls21 wsb">element.className = &quot;message&quot;; </div><div class="t m0 x0 hb y2db ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2dc ff5f fs6 fc0 sc0 ls21 wsb">var textNode = document.createTextNode(&quot;Hello world!&quot;); </div><div class="t m0 x0 hb y2dd ff5f fs6 fc0 sc0 ls21 wsb">element.appendChild(textNode); </div><div class="t m0 x0 hb y9e2 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y9e3 ff63 fs6 fc0 sc0 ls21 wsb">var anotherTextNode = document.createTextNode(&quot;Yippee!&quot;); </div><div class="t m0 x0 h15 y9e4 ff63 fs6 fc0 sc0 ls21 wsb">element.appendChild(anotherTextNode); </div><div class="t m0 x0 hb y1bb4 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1bb5 ff5f fs6 fc0 sc0 ls21 wsb">document.body.appendChild(element); </div><div class="t m0 x0 hb y1bb6 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1bb7 ff66 fs2 fc0 sc0 ls8 wsb">TextNodeExample04.htm </div><div class="t m0 x0 h5 y1bb8 ff5e fs2 fc0 sc0 ls1f ws108">如果两个文本节点是相邻的同胞节点，那么这两个节点中的文本就会连起来显示，中间不会有空格。 </div><div class="t m0 x0 h3c y1bb9 ff5c fs2 fc0 sc0 ls2e wsb">2. 规范化文本节点 </div><div class="t m0 x0 h5 y1bba ff57 fs2 fc0 sc0 ls81 ws76">DOM文档中存在相邻的同胞文本节点很容易导致混乱，因为分不清哪个文本节点表示哪个字符串。</div><div class="t m0 x0 h5 y1bbb ff5e fs2 fc0 sc0 ls8 wseb">另外，DOM文档中出现相邻文本节点的情况也不在少数，于是就催生了一个能够将相邻文本节点合并</div><div class="t m0 x0 ha4 y1bbc ff5e fs2 fc0 sc0 ls8 wseb">的方法。这个方法是由Node类型定义的（因而在所有节点类型中都存在），名叫normalize()。如果</div><div class="t m0 x0 h1e y1bbd ff5e fs2 fc0 sc0 ls8 wseb">在一个包含两个或多个文本节点的父元素上调用normalize()方法，则会将所有文本节点合并成一个</div><div class="t m0 x0 h4 y1bbe ff5e fs2 fc0 sc0 ls8 wseb">节点，结果节点的nodeValue等于将合并前每个文本节点的nodeValue 值拼接起来的值。来看一个</div><div class="t m0 x0 h5 y1bbf ff5e fs2 fc0 sc0 ls8">例子。 </div><div class="t m0 x0 hb y1bc0 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1bc1 ff5f fs6 fc0 sc0 ls21 wsb">var element = document.createElement(&quot;div&quot;); </div><div class="t m0 x0 hb y1bc2 ff5f fs6 fc0 sc0 ls21 wsb">element.className = &quot;message&quot;; </div><div class="t m0 x0 hb y1bc3 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1bc4 ff5f fs6 fc0 sc0 ls21 wsb">var textNode = document.createTextNode(&quot;Hello world!&quot;); </div><div class="t m0 x0 hb y1bc5 ff5f fs6 fc0 sc0 ls21 wsb">element.appendChild(textNode); </div><div class="t m0 x0 hb y1bc6 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1bc7 ff5f fs6 fc0 sc0 ls21 wsb">var anotherTextNode = document.createTextNode(&quot;Yippee!&quot;); </div><div class="t m0 x0 hb y1bc8 ff5f fs6 fc0 sc0 ls21 wsb">element.appendChild(anotherTextNode); </div><div class="t m0 x0 hb y1bc9 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1bca ff5f fs6 fc0 sc0 ls21 wsb">document.body.appendChild(element); </div><div class="t m0 x0 hb y1bcb ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y1bcc ff63 fs6 fc0 sc0 ls21 wsb">alert(element.childNodes.length);    //2 </div><div class="t m0 x0 h15 y1bcd ff63 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y1bce ff63 fs6 fc0 sc0 ls21 wsb">element.normalize(); </div><div class="t m0 x0 h15 y1bcf ff63 fs6 fc0 sc0 ls21 wsb">alert(element.childNodes.length);    //1 </div><div class="t m0 x0 h15 y1bd0 ff63 fs6 fc0 sc0 ls21 wsb">alert(element.firstChild.nodeValue);    // &quot;Hello world!Yippee!&quot; </div><div class="t m0 x0 hb y1bd1 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1bd2 ff66 fs2 fc0 sc0 ls8 wsb">TextNodeExample05.htm </div><div class="t m0 x0 h5 y1bd3 ff5e fs2 fc0 sc0 ls1f ws108">浏览器在解析文档时永远不会创建相邻的文本节点。这种情况只会作为执行DOM操作的结果出现。 </div><div class="t m0 x5 h1d y1bd4 ff58 fs2 fc0 sc0 ls8 ws14">在某些情况下，执行normalize()方法会导致IE6崩溃。不过，在 IE6后来的</div><div class="t m0 x0 h5 y1bd5 ff58 fs2 fc0 sc0 ls8 ws14">补丁中，可能已经修复了这个问题（未经证实）。IE7及更高版本中不存在这个问题。 </div></div></div>
<div id="pf123" class="pf w0 h0" data-page-no="123"><div class="pc pc123 w0 h0"><div class="t m0 x2 h2 y1 ff57 fs0 fc0 sc0 ls7 ws0">10.1 节点层次    273 </div><div class="t m0 x0 h3 y2 ff57 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff59 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff59 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff59 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff59 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff59 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff59 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff59 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff59 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff59 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff59 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff59 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff59 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff59 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h3c y68b ff5c fs2 fc0 sc0 ls2e wsb">3. 分割文本节点 </div><div class="t m0 x0 h4 y1bd6 ff5f fs1 fc0 sc0 ls9 ws2">Text类型提供了一个作用与normalize()相反的方法：splitText()。这个方法会将一个文本节</div><div class="t m0 x0 h1e y68d ff5e fs2 fc0 sc0 ls8 wseb">点分成两个文本节点，即按照指定的位置分割nodeValue值。原来的文本节点将包含从开始到指定位</div><div class="t m0 x0 h4 y68e ff5e fs2 fc0 sc0 ls24 wsf5">置之前的内容，新文本节点将包含剩下的文本。这个方法会返回一个新文本节点，该节点与原节点的</div><div class="t m0 x0 h5 y1bd7 ff5f fs1 fc0 sc0 ls9 ws2">parentNode相同。来看下面的例子。 </div><div class="t m0 x0 hb y1bd8 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1bd9 ff5f fs6 fc0 sc0 ls21 wsb">var element = document.createElement(&quot;div&quot;); </div><div class="t m0 x0 hb y1bda ff5f fs6 fc0 sc0 ls21 wsb">element.className = &quot;message&quot;; </div><div class="t m0 x0 hb y1bdb ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1bdc ff5f fs6 fc0 sc0 ls21 wsb">var textNode = document.createTextNode(&quot;Hello world!&quot;); </div><div class="t m0 x0 hb y1bdd ff5f fs6 fc0 sc0 ls21 wsb">element.appendChild(textNode); </div><div class="t m0 x0 hb y1bde ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1bdf ff5f fs6 fc0 sc0 ls21 wsb">document.body.appendChild(element); </div><div class="t m0 x0 hb y1be0 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y1be1 ff63 fs6 fc0 sc0 ls21 wsb">var newNode = element.firstChild.splitText(5); </div><div class="t m0 x0 h15 y1be2 ff63 fs6 fc0 sc0 ls21 wsb">alert(element.firstChild.nodeValue);    //&quot;Hello&quot; </div><div class="t m0 x0 h15 y1be3 ff63 fs6 fc0 sc0 ls21 wsb">alert(newNode.nodeValue);             //&quot; world!&quot; </div><div class="t m0 x0 h15 y1be4 ff63 fs6 fc0 sc0 ls21 wsb">alert(element.childNodes.length);       //2 </div><div class="t m0 x0 h15 y1be5 ff63 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1be6 ff66 fs2 fc0 sc0 ls8 wsb">TextNodeExample06.htm </div><div class="t m0 x0 h5 y1be7 ff5e fs2 fc0 sc0 ls8 wseb">在这个例子中，包含&quot;Hello world!&quot;的文本节点被分割为两个文本节点，从位置5开始。位置5</div><div class="t m0 x0 h4 y1be8 ff5e fs2 fc0 sc0 ls6c">是&quot;Hello&quot;和&quot;world!&quot;之间的空格，因此原来的文本节点将包含字符串&quot;Hello&quot;，而新文本节点将包</div><div class="t m0 x0 hc y1be9 ff5e fs2 fc0 sc0 ls8 wseb">含文本&quot;world!&quot;（包含空格）。 </div><div class="t m0 x0 h5 y1bea ff5e fs2 fc0 sc0 ls8 wseb">分割文本节点是从文本节点中提取数据的一种常用DOM解析技术。 </div><div class="t m0 x0 h20 y1beb ff5c fs3 fc0 sc0 ls248 ws214">10.1.5 Comment类型 </div><div class="t m0 x0 h5 y1bec ff5e fs2 fc0 sc0 ls8 wseb">注释在DOM中是通过Comment类型来表示的。Comment节点具有下列特征 ： </div><div class="t m0 x0 h5 y1bed ff5d fs1 fc0 sc0 ls2"> nodeType的值为8； </div><div class="t m0 x0 h5 y1bee ff5d fs1 fc0 sc0 ls2"> nodeName的值为&quot;#comment&quot;； </div><div class="t m0 x0 h5 y1bef ff5d fs1 fc0 sc0 ls2"> nodeValue的值是注释的内容； </div><div class="t m0 x0 h5 y413 ff5d fs1 fc0 sc0 ls2"> parentNode可能是Document或Element； </div><div class="t m0 x0 h5 y1bf0 ff5d fs1 fc0 sc0 ls2"> 不支持（没有）子节点。 </div><div class="t m0 x0 h4 y1636 ff5f fs1 fc0 sc0 ls9 ws2">Comment类型与Text类型继承自相同的基类，因此它拥有除 splitText()之外的所有字符串操</div><div class="t m0 x0 hc y1bf1 ff5e fs2 fc0 sc0 ls8 wseb">作方法。与Text类型相似，也可以通过nodeValue或data 属性来取得注释的内容。 </div><div class="t m0 x0 h5 y1bf2 ff5e fs2 fc0 sc0 ls8 wseb">注释节点可以通过其父节点来访问，以下面的代码为例。 </div><div class="t m0 x5 hb y1bf3 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1bf4 ff5f fs6 fc0 sc0 ls21 wsb">&lt;div id=&quot;myDiv&quot;&gt;&lt;!--A comment --&gt;&lt;/div&gt; </div><div class="t m0 x5 hb y1bf5 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1bf6 ff5e fs2 fc0 sc0 ls8 wseb">在此，注释节点是&lt;div&gt;元素的一个子节点，因此可以通过下面的代码来访问它。 </div><div class="t m0 x5 hb y1bf7 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1bf8 ff5f fs6 fc0 sc0 ls21 wsb">var div = document.getElementById(&quot;myDiv&quot;); </div><div class="t m0 x0 hb y1bf9 ff5f fs6 fc0 sc0 ls21 wsb">var comment = div.firstChild; </div><div class="t m0 x0 hb y1bfa ff5f fs6 fc0 sc0 ls21 wsb">alert(comment.data);    //&quot;A comment&quot; </div><div class="t m0 x5 hb y1bfb ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1bfc ff66 fs2 fc0 sc0 ls1b wsb">CommentNodeExample01.htm </div><div class="t m0 x0 h5 y1bfd ff57 fs2 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf124" class="pf w0 h0" data-page-no="124"><div class="pc pc124 w0 h0"><div class="t m0 x0 h2 y1 ff57 fs0 fc0 sc0 ls7 ws0">274  第10章 DOM </div><div class="t m0 x0 h3 y2 ff57 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ff5e fs2 fc0 sc0 ls8 wseb">另外，使用document.createComment()并为其传递注释文本也可以创建注释节点，如下面的例</div><div class="t m0 x0 h5 y4d ff5e fs2 fc0 sc0 ls8">子所示。 </div><div class="t m0 x0 hb y2d8 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2d9 ff5f fs6 fc0 sc0 ls21 wsb">var comment = document.createComment(&quot;A comment &quot;); </div><div class="t m0 x0 hb y1bfe ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1512 ff5e fs2 fc0 sc0 ls8 wseb">显然，开发人员很少会创建和访问注释节点，因为注释节点对算法鲜有影响。此外，浏览器也不会</div><div class="t m0 x0 h1e y15b3 ff5e fs2 fc0 sc0 ls5 wsec">识别位于&lt;/html&gt;标签后面的注释。如果要访问注释节点，一定要保证它们是&lt;html&gt;元素的后代（即</div><div class="t m0 x0 hc y1727 ff5e fs2 fc0 sc0 ls8 wseb">位于&lt;html&gt;和&lt;/html&gt;之间）。 </div><div class="t m0 x0 h5 y1bff ff57 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x5 h5 y1c00 ff58 fs2 fc0 sc0 ls71">在Firefox、Safari、Chrome和Opera中，可以访问Comment类型的构造函数和</div><div class="t m0 x0 h5 y1c01 ff58 fs2 fc0 sc0 ls97 ws249">原型。在IE8中，注释节点被视作标签名为&quot;!&quot;的元素。也就是说，使用</div><div class="t m0 x0 h5 y1c02 ff5f fs1 fc0 sc0 ls9 ws2">getElementsByTagName()可以取得注释节点。尽管IE9没有把注释当成元素，但</div><div class="t m0 x0 h18 y1c03 ff58 fs2 fc0 sc0 ls8 ws14">它仍然通过一个名为HTMLCommentElement的构造函数来表示注释。 </div><div class="t m0 x0 h20 y139f ff5c fs3 fc0 sc0 ls248 ws214">10.1.6 CDATASection类型 </div><div class="t m0 x0 h5 y1c04 ff5f fs1 fc0 sc0 ls9 ws2">CDATASection类型只针对基于XML 的文档，表示的是CDATA区域。与Comment 类似，</div><div class="t m0 x0 h4 y18ef ff5f fs1 fc0 sc0 ls9 ws2">CDATASection类型继承自Text 类型，因此拥有除splitText()之外的所有字符串操作方法。</div><div class="t m0 x0 h5 y1c05 ff5f fs1 fc0 sc0 ls9 ws2">CDATASection节点具有下列特征： </div><div class="t m0 x0 h5 y1c06 ff5d fs1 fc0 sc0 ls2"> nodeType的值为4； </div><div class="t m0 x0 h5 y1c07 ff5d fs1 fc0 sc0 ls2"> nodeName的值为&quot;#cdata-section&quot;； </div><div class="t m0 x0 h5 y1c08 ff5d fs1 fc0 sc0 ls2"> nodeValue的值是CDATA区域中的内容； </div><div class="t m0 x0 h5 y1c09 ff5d fs1 fc0 sc0 ls2"> parentNode可能是Document或Element； </div><div class="t m0 x0 h5 y985 ff5d fs1 fc0 sc0 ls2"> 不支持（没有）子节点。 </div><div class="t m0 x0 h5 y1c0a ff57 fs2 fc0 sc0 ls90 ws6b">CDATA区域只会出现在XML文档中，因此多数浏览器都会把CDATA区域错误地解析为Comment</div><div class="t m0 x0 h5 y1c0b ff5e fs2 fc0 sc0 ls2c">或Element。以下面的代码为例： </div><div class="t m0 x0 hb y1c0c ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1c0d ff5f fs6 fc0 sc0 ls21 wsb">&lt;div id=&quot;myDiv&quot;&gt;&lt;![CDATA[This is some content.]]&gt;&lt;/div&gt; </div><div class="t m0 x0 hb y1c0e ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y323 ff5e fs2 fc0 sc0 ls8 wseb">这个例子中的&lt;div&gt;元素应该包含一个CDATASection节点。可是，四大主流浏览器无一能够这样</div><div class="t m0 x0 h5 y324 ff5e fs2 fc0 sc0 ls8 wseb">解析它。即使对于有效的XHTML页面，浏览器也没有正确地支持嵌入的CDATA区域。 </div><div class="t m0 x0 hc y1c0f ff5e fs2 fc0 sc0 ls8 wseb">在真正的XML文档中，可以使用document.createCDataSection()来创建CDATA区域，只需</div><div class="t m0 x0 h5 y1c10 ff5e fs2 fc0 sc0 ls8 wseb">为其传入节点的内容即可。 </div><div class="t m0 x5 h5 y1c11 ff58 fs2 fc0 sc0 ls3b">在Firefox、Safari、Chrome和Opera中，可以访问CDATASection类型的构造函</div><div class="t m0 x0 h5 y1c12 ff58 fs2 fc0 sc0 ls8 ws14">数和原型。IE9及之前版本不支持这个类型。 </div><div class="t m0 x0 h20 y1c13 ff5c fs3 fc0 sc0 ls248 ws214">10.1.7 DocumentType类型 </div><div class="t m0 x0 ha5 y1c14 ff5f fs1 fc0 sc0 ls9 ws2">DocumentType类型在Web浏览器中并不常用，仅有Firefox、Safari和Opera支持它①。Document- </div><div class="t m0 x0 h3c y2d6 ff5b fs2 fc0 sc0 ls7b wsb">—————————— </div><div class="t m0 x0 h36 ycc6 ff5e fs6 fc0 sc0 ls95">① Chrome 4.0也支持DocumentType类型。 </div></div></div>
<div id="pf125" class="pf w0 h0" data-page-no="125"><div class="pc pc125 w0 h0"><div class="t m0 x2 h2 y1 ff57 fs0 fc0 sc0 ls7 ws0">10.1 节点层次    275 </div><div class="t m0 x0 h3 y2 ff57 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff59 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff59 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff59 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff59 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff59 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff59 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff59 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff59 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff59 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff59 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff59 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff59 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff59 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff5f fs1 fc0 sc0 ls9 ws2">Type包含着与文档的doctype有关的所有信息，它具有下列特征： </div><div class="t m0 x0 h5 y4 ff5d fs1 fc0 sc0 ls2"> nodeType的值为10； </div><div class="t m0 x0 h5 y4e ff5d fs1 fc0 sc0 ls2"> nodeName的值为doctype的名称； </div><div class="t m0 x0 h5 yd9 ff5d fs1 fc0 sc0 ls2"> nodeValue的值为null； </div><div class="t m0 x0 h5 y219 ff5d fs1 fc0 sc0 ls2"> parentNode是Document； </div><div class="t m0 x0 h5 y8 ff5d fs1 fc0 sc0 ls2"> 不支持（没有）子节点。 </div><div class="t m0 x0 h5 y15e ff5e fs2 fc0 sc0 ls21f">在DOM1级中，DocumentType对象不能动态创建，而只能通过解析文档代码的方式来创建。支</div><div class="t m0 x0 hc y15f ff5e fs2 fc0 sc0 ls288 ws24b">持它的浏览器会把DocumentType对象保存在 document.doctype中。DOM1 级描述了</div><div class="t m0 x0 h5 yb ff5f fs1 fc0 sc0 ls9 ws2">DocumentType对象的3个属性：name、entities和notations。其中，name表示文档类型的名称；</div><div class="t m0 x0 h4 yc ff5f fs1 fc0 sc0 ls9 ws2">entities是由文档类型描述的实体的NamedNodeMap对象；notations是由文档类型描述的符 号的</div><div class="t m0 x0 h5 yd ff5f fs1 fc0 sc0 ls9 ws2">NamedNodeMap对象。通常，浏览器中的文档使用的都是HTML或XHTML文档类型，因而entities</div><div class="t m0 x0 h4 y21b ff5e fs2 fc0 sc0 ls2c">和notations都是空列表（列表中的项来自行内文档类型声明）。但不管怎样，只有name属性是有用</div><div class="t m0 x0 h5 y21c ff5e fs2 fc0 sc0 ls8 wseb">的。这个属性中保存的是文档类型的名称，也就是出现在&lt;!DOCTYPE之后的文本。以下面严格型HTML </div><div class="t m0 x0 h5 y116c ff57 fs2 fc0 sc0 ls94 ws77">4.01的文档类型声明为例： </div><div class="t m0 x0 hb y1c15 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1c16 ff5f fs6 fc0 sc0 ls21 wsb">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; </div><div class="t m0 x0 hb y1c17 ff5f fs6 fc0 sc0 ls21 wsb">&quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt; </div><div class="t m0 x0 hb y1c18 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y52d ff5f fs1 fc0 sc0 ls9 ws2">DocumentType的name属性中保存的就是&quot;HTML&quot;： </div><div class="t m0 x0 hb y1c19 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1c1a ff5f fs6 fc0 sc0 ls21 wsb">alert(document.doctype.name);        //&quot;HTML&quot; </div><div class="t m0 x0 hb y1c1b ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1c1c ff57 fs2 fc0 sc0 lse ws9">IE及更早版本不支持DocumentType，因此document.doctype 的值始终都等于null。可是，</div><div class="t m0 x0 h5 y1c1d ff5e fs2 fc0 sc0 ls97 ws24d">这些浏览器会把文档类型声明错误地解释为注释，并且为它创建一个注释节点。IE9会给</div><div class="t m0 x0 h5 y1c1e ff5f fs1 fc0 sc0 ls9 ws2">document.doctype赋正确的对象，但仍然不支持访问DocumentType类型。 </div><div class="t m0 x0 h20 y1c1f ff5c fs3 fc0 sc0 ls248 ws214">10.1.8 DocumentFragment类型 </div><div class="t m0 x0 h5 y19cc ff5e fs2 fc0 sc0 lsa ws10a">在所有节点类型中，只有DocumentFragment在文档中没有对应的标记。DOM 规定文档片段</div><div class="t m0 x0 h5 y1c20 ff5e fs2 fc0 sc0 ls59">（document fragment）是一种“轻量级”的文档，可以包含和控制节点，但不会像完整的文档那样占用</div><div class="t m0 x0 hc y1c21 ff5e fs2 fc0 sc0 ls8 wseb">额外的资源。DocumentFragment节点具有下列特征： </div><div class="t m0 x0 h5 y1c22 ff5d fs1 fc0 sc0 ls2"> nodeType的值为11； </div><div class="t m0 x0 h5 y1c23 ff5d fs1 fc0 sc0 ls2"> nodeName的值为&quot;#document-fragment&quot;； </div><div class="t m0 x0 h5 y1c24 ff5d fs1 fc0 sc0 ls2"> nodeValue的值为null； </div><div class="t m0 x0 h5 y1c25 ff5d fs1 fc0 sc0 ls2"> parentNode的值为null； </div><div class="t m0 x0 h4 y1a9c ff5d fs1 fc0 sc0 ls2"> 子节点可以是Element、ProcessingInstruction、Comment、Text、CDATASection或</div><div class="t m0 x5 h5 y1c26 ff5f fs1 fc0 sc0 ls9 ws2">EntityReference。 </div><div class="t m0 x0 h4 y1c27 ff5e fs2 fc0 sc0 ls1f ws108">虽然不能把文档片段直接添加到文档中，但可以将它作为一个“仓库”来使用，即可以在里面保存将</div><div class="t m0 x0 h1c y1c28 ff5e fs2 fc0 sc0 ls1f ws108">来可能会添加到文档中的节点。要创建文档片段，可以使用document.createDocumentFragment()方</div><div class="t m0 x0 h5 y1c29 ff5e fs2 fc0 sc0 ls8 wseb">法，如下所示： </div><div class="t m0 x0 hb y1c2a ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1c2b ff5f fs6 fc0 sc0 ls21 wsb">var fragment = document.createDocumentFragment(); </div><div class="t m0 x0 hb y1c2c ff5f fs6 fc0 sc0 ls8 wsb">  </div></div></div>
<div id="pf126" class="pf w0 h0" data-page-no="126"><div class="pc pc126 w0 h0"><div class="t m0 x0 h2 y1 ff57 fs0 fc0 sc0 ls7 ws0">276  第10章 DOM </div><div class="t m0 x0 h3 y2 ff57 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff5e fs2 fc0 sc0 ls8 wseb">文档片段继承了Node的所有方法，通常用于执行那些针对文档的DOM操作。如果将文档中的节</div><div class="t m0 x0 h4 y4d ff5e fs2 fc0 sc0 ls8 wseb">点添加到文档片段中，就会从文档树中移除该节点，也不会从浏览器中再看到该节点。添加到文档片段</div><div class="t m0 x0 h1c yd8 ff5e fs2 fc0 sc0 ls8 wseb">中的新节点同样也不属于文档树。可以通过appendChild()或insertBefore()将文档片段中内容添</div><div class="t m0 x0 h4 yd9 ff5e fs2 fc0 sc0 ls8 wseb">加到文档中。在将文档片段作为参数传递给这两个方法时，实际上只会将文档片段的所有子节点添加到</div><div class="t m0 x0 h5 y15d ff5e fs2 fc0 sc0 ls8 wseb">相应位置上；文档片段本身永远不会成为文档树的一部分。来看下面的HTML示例代码： </div><div class="t m0 x0 hb y263 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y264 ff5f fs6 fc0 sc0 ls21 wsb">&lt;ul id=&quot;myList&quot;&gt;&lt;/ul&gt; </div><div class="t m0 x0 hb y1c2e ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1c2f ff5e fs2 fc0 sc0 ls8 wseb">假设我们想为这个&lt;ul&gt;元素添加3个列表项。如果逐个地添加列表项，将会导致浏览器反复渲染（呈</div><div class="t m0 x0 h4 y1c30 ff5e fs2 fc0 sc0 ls8 wseb">现）新信息。为避免这个问题，可以像下面这样使用一个文档片段来保存创建的列表项，然后再一次性</div><div class="t m0 x0 h5 y1c31 ff5e fs2 fc0 sc0 ls8 wseb">将它们添加到文档中。 </div><div class="t m0 x0 hb y149e ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1c32 ff5f fs6 fc0 sc0 ls21 wsb">var fragment = document.createDocumentFragment(); </div><div class="t m0 x0 hb y1c33 ff5f fs6 fc0 sc0 ls21 wsb">var ul = document.getElementById(&quot;myList&quot;); </div><div class="t m0 x0 hb y1c34 ff5f fs6 fc0 sc0 ls21 wsb">var li = null; </div><div class="t m0 x0 hb y1c35 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1c36 ff5f fs6 fc0 sc0 ls21 wsb">for (var i=0; i &lt; 3; i++){ </div><div class="t m0 x0 hb y1c37 ff5f fs6 fc0 sc0 ls21 wsb">    li = document.createElement(&quot;li&quot;); </div><div class="t m0 x0 hb y1c38 ff5f fs6 fc0 sc0 ls21 wsb">    li.appendChild(document.createTextNode(&quot;Item &quot; + (i+1))); </div><div class="t m0 x0 hb y1c39 ff5f fs6 fc0 sc0 ls21 wsb">    fragment.appendChild(li); </div><div class="t m0 x0 hb y1c3a ff5f fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y1c3b ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1c3c ff5f fs6 fc0 sc0 ls21 wsb">ul.appendChild(fragment);   </div><div class="t m0 x0 hb y1c3d ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf y1c3e ff66 fs2 fc0 sc0 ls25 ws68">DocumentFragmentExample01.htm   </div><div class="t m0 x0 h4 y1c3f ff5e fs2 fc0 sc0 ls8 wseb">在这个例子中，我们先创建一个文档片段并取得了对&lt;ul&gt;元素的引用。然后，通过for循环创建</div><div class="t m0 x0 h5 y1c40 ff57 fs2 fc0 sc0 ls38">3个列表项，并通过文本表示它们的顺序。为此，需要分别创建&lt;li&gt;元素、创建文本节点，再把文本节</div><div class="t m0 x0 h1e y1c41 ff5e fs2 fc0 sc0 ls5 wsec">点添加到&lt;li&gt;元素。接着使用appendChild()将&lt;li&gt;元素添加到文档片段中。循环结束后，再调用</div><div class="t m0 x0 h4 y1c42 ff5f fs1 fc0 sc0 ls9 ws2">appendChild()并传入文档片段，将所有列表项添加到&lt;ul&gt;元素中。此时，文档片段的所有子节点都</div><div class="t m0 x0 hc y1c43 ff5e fs2 fc0 sc0 ls8 wseb">被删除并转移到了&lt;ul&gt;元素中。 </div><div class="t m0 x0 h20 y1c44 ff5c fs3 fc0 sc0 ls248 ws214">10.1.9 Attr类型 </div><div class="t m0 x0 h5 y1c45 ff5e fs2 fc0 sc0 ls8 wseb">元素的特性在DOM中以Attr类型来表示。在所有浏览器中（包括 IE8），都可以访问Attr类型</div><div class="t m0 x0 h1e y1c46 ff5e fs2 fc0 sc0 ls8 wseb">的构造函数和原型。从技术角度讲，特性就是存在于元素的attributes属性中的节点。特性节点具有</div><div class="t m0 x0 h5 y1c47 ff5e fs2 fc0 sc0 ls8 wseb">下列特征： </div><div class="t m0 x0 h5 y1c48 ff5d fs1 fc0 sc0 ls2"> nodeType的值为2； </div><div class="t m0 x0 h5 y14d9 ff5d fs1 fc0 sc0 ls2"> nodeName的值是特性的名称； </div><div class="t m0 x0 h5 y1c49 ff5d fs1 fc0 sc0 ls2"> nodeValue的值是特性的值； </div><div class="t m0 x0 h5 y1c4a ff5d fs1 fc0 sc0 ls2"> parentNode的值为null； </div><div class="t m0 x0 h5 y1c4b ff5d fs1 fc0 sc0 ls2"> 在HTML中不支持（没有）子节点； </div><div class="t m0 x0 h5 y1c4c ff5d fs1 fc0 sc0 ls2"> 在XML中子节点可以是Text或EntityReference。 </div><div class="t m0 x0 h5 y1c4d ff5e fs2 fc0 sc0 ls8 wseb">尽管它们也是节点，但特性却不被认为是DOM文档树的一部分。开发人员最常使用的是getAt- </div><div class="t m0 x0 h21 y1c4e ff5f fs1 fc0 sc0 ls9 ws2">tribute()、setAttribute()和remveAttribute()方法，很少直接引用特性节点。 </div></div></div>
<div id="pf127" class="pf w0 h0" data-page-no="127"><div class="pc pc127 w0 h0"><div class="t m0 x2 h2 y1 ff57 fs0 fc0 sc0 ls7 ws0">10.2 DOM操作技术   277 </div><div class="t m0 x0 h3 y2 ff57 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff59 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff59 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff59 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff59 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff59 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff59 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff59 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff59 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff59 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff59 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff59 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff59 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff59 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff5f fs1 fc0 sc0 ls9 ws2">Attr对象有3个属性：name、value和specified。其中，name是特性名称（与 nodeName的</div><div class="t m0 x0 h1e y4d ff5e fs2 fc0 sc0 ls8 wseb">值相同），value是特性的值（与nodeValue的值相同），而specified是一个布尔值，用以区别特</div><div class="t m0 x0 h5 y5 ff5e fs2 fc0 sc0 ls8 wseb">性是在代码中指定的，还是默认的。 </div><div class="t m0 x0 h1e y6 ff5e fs2 fc0 sc0 ls8 wseb">使用document.createAttribute()并传入特性的名称可以创建新的特性节点。例如，要为元素</div><div class="t m0 x0 hc y15d ff5e fs2 fc0 sc0 ls8 wseb">添加align特性，可以使用下列代码： </div><div class="t m0 x5 hb y4ef ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1c4f ff5f fs6 fc0 sc0 ls21 wsb">var attr = document.createAttribute(&quot;align&quot;); </div><div class="t m0 x0 hb y1c50 ff5f fs6 fc0 sc0 ls21 wsb">attr.value = &quot;left&quot;; </div><div class="t m0 x0 hb y1c51 ff5f fs6 fc0 sc0 ls21 wsb">element.setAttributeNode(attr); </div><div class="t m0 x0 hb y1c52 ff5f fs6 fc0 sc0 ls21 wsb">alert(element.attributes[&quot;align&quot;].value);       //&quot;left&quot; </div><div class="t m0 x0 hb y1c53 ff5f fs6 fc0 sc0 ls21 wsb">alert(element.getAttributeNode(&quot;align&quot;).value); //&quot;left&quot; </div><div class="t m0 x0 hb y1c54 ff5f fs6 fc0 sc0 ls21 wsb">alert(element.getAttribute(&quot;align&quot;));           //&quot;left&quot; </div><div class="t m0 x5 hb y1c55 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1c56 ff66 fs2 fc0 sc0 ls2b wsb">AttrExample01.htm </div><div class="t m0 x0 h4 y1c57 ff5e fs2 fc0 sc0 ls8 wseb">这个例子创建了一个新的特性节点。由于在调用createAttribute()时已经为name属性赋了值，</div><div class="t m0 x0 h1e y1c58 ff5e fs2 fc0 sc0 ls8 wseb">所以后面就不必给它赋值了。之后，又把value属性的值设置为&quot;left&quot;。为了将新创建的特性添加到</div><div class="t m0 x0 h4 y1c59 ff5e fs2 fc0 sc0 ls8 wseb">元素中，必须使用元素的setAttributeNode()方法。添加特性之后，可以通过下列任何方式访问该</div><div class="t m0 x0 h1e y1c5a ff5e fs2 fc0 sc0 ls8 wseb">特性：attributes属性、getAttributeNode()方法以及getAttribute()方法。其中，attributes</div><div class="t m0 x0 h5 y1c5b ff5e fs2 fc0 sc0 ls2c">和getAttributeNode()都会返回对应特性的Attr节点，而getAttribute()则只返回特性的值。 </div><div class="t m0 x5 ha7 y1c5c ff58 fs2 fc0 sc0 ls5c ws23f">我们并不建议直接访问特性节点。实际上，使用getAttribute()、setAttribute()</div><div class="t m0 x5 h5 y1c5d ff58 fs2 fc0 sc0 ls2c">和removeAttribute()方法远比操作特性节点更为方便。 </div><div class="t m0 x0 hd y55e ff5c fs7 fc0 sc0 ls245">10.2 DOM操作技术 </div><div class="t m0 x0 h5 y411 ff5e fs2 fc0 sc0 ls8 wseb">很多时候，DOM操作都比较简明，因此用JavaScript生成那些通常原本是用HTML 代码生成的内</div><div class="t m0 x0 h5 y412 ff5e fs2 fc0 sc0 ls8 wseb">容并不麻烦。不过，也有一些时候，操作DOM并不像表面上看起来那么简单。由于浏览器中充斥着隐</div><div class="t m0 x0 h5 y1c5e ff5e fs2 fc0 sc0 ls8 wseb">藏的陷阱和不兼容问题，用JavaScript代码处理DOM的某些部分要比处理其他部分更复杂一些。 </div><div class="t m0 x0 h20 y1c5f ff5c fs3 fc0 sc0 ls248 ws214">10.2.1 动态脚本 </div><div class="t m0 x0 h5 y7eb ff5e fs2 fc0 sc0 ls8 wseb">使用&lt;script&gt;元素可以向页面中插入JavaScript代码，一种方式是通过其src特性包含外部文件，</div><div class="t m0 x0 h4 y19f8 ff5e fs2 fc0 sc0 ls8 wseb">另一种方式就是用这个元素本身来包含代码。而这一节要讨论的动态脚本，指的是在页面加载时不存在，</div><div class="t m0 x0 h5 y1c60 ff5e fs2 fc0 sc0 ls8 wseb">但将来的某一时刻通过修改DOM动态添加的脚本。跟操作HTML元素一样，创建动态脚本也有两种方</div><div class="t m0 x0 h5 y1c61 ff5e fs2 fc0 sc0 ls8 wseb">式：插入外部文件和直接插入JavaScript代码。 </div><div class="t m0 x0 h14 y1c62 ff5e fs2 fc0 sc0 ls8 wseb">动态加载的外部JavaScript文件能够立即运行，比如下面的&lt;script&gt;元素： </div><div class="t m0 x5 hb y1c63 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1c64 ff5f fs6 fc0 sc0 ls21 wsb">&lt;script type=&quot;text/javascript&quot; src=&quot;client.js&quot;&gt;&lt;/script&gt; </div><div class="t m0 x5 hb y1c65 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1c66 ff5e fs2 fc0 sc0 ls8 wseb">这个&lt;script&gt;元素包含了第9章的客户端检测脚本。而创建这个节点的DOM代码如下所示： </div><div class="t m0 x5 hb yf8b ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1c67 ff5f fs6 fc0 sc0 ls21 wsb">var script = document.createElement(&quot;script&quot;); </div><div class="t m0 x0 hb y1c68 ff5f fs6 fc0 sc0 ls21 wsb">script.type = &quot;text/javascript&quot;; </div></div></div>
<div id="pf128" class="pf w0 h0" data-page-no="128"><div class="pc pc128 w0 h0"><div class="t m0 x0 h2 y1 ff57 fs0 fc0 sc0 ls7 ws0">278  第10章 DOM </div><div class="t m0 x0 h3 y2 ff57 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 ff5f fs6 fc0 sc0 ls21 wsb">script.src = &quot;client.js&quot;; </div><div class="t m0 x0 hb y7a ff5f fs6 fc0 sc0 ls21 wsb">document.body.appendChild(script); </div><div class="t m0 x0 hb y1c6a ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1c6b ff5e fs2 fc0 sc0 ls8 wseb">显然，这里的DOM代码如实反映了相应的HTML代码。不过，在执行最后一行代码把&lt;script&gt;</div><div class="t m0 x0 h4 y106 ff5e fs2 fc0 sc0 ls8 wseb">元素添加到页面中之前，是不会下载外部文件的。也可以把这个元素添加到&lt;head&gt;元素中，效果相同。</div><div class="t m0 x0 h5 y1c6c ff5e fs2 fc0 sc0 ls8 wseb">整个过程可以使用下面的函数来封装： </div><div class="t m0 x0 hb y1c6d ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1c6e ff5f fs6 fc0 sc0 ls21 wsb">function loadScript(url){ </div><div class="t m0 x0 hb y1c6f ff5f fs6 fc0 sc0 ls21 wsb">    var script = document.createElement(&quot;script&quot;); </div><div class="t m0 x0 hb y1c70 ff5f fs6 fc0 sc0 ls21 wsb">    script.type = &quot;text/javascript&quot;; </div><div class="t m0 x0 hb y1c71 ff5f fs6 fc0 sc0 ls21 wsb">    script.src = url; </div><div class="t m0 x0 hb y1c72 ff5f fs6 fc0 sc0 ls21 wsb">    document.body.appendChild(script); </div><div class="t m0 x0 hb y1c73 ff5f fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h5 y641 ff5e fs2 fc0 sc0 ls8 wseb">然后，就可以通过调用这个函数来加载外部的JavaScript文件了： </div><div class="t m0 x0 hb y642 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y643 ff5f fs6 fc0 sc0 ls21 wsb">loadScript(&quot;client.js&quot;); </div><div class="t m0 x0 hb y1c74 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1c75 ff5e fs2 fc0 sc0 ls8 wseb">加载完成后，就可以在页面中的其他地方使用这个脚本了。问题只有一个：怎么知道脚本加载完成</div><div class="t m0 x0 h4 y193b ff5e fs2 fc0 sc0 ls8 wseb">呢？遗憾的是，并没有什么标准方式来探知这一点。不过，与此相关的一些事件倒是可以派上用场，但</div><div class="t m0 x0 h5 y1c76 ff5e fs2 fc0 sc0 ls8 wseb">要取决于所用的浏览器，详细讨论请见第13章。 </div><div class="t m0 x0 h5 y1c77 ff5e fs2 fc0 sc0 ls8 wseb">另一种指定JavaScript代码的方式是行内方式，如下面的例子所示： </div><div class="t m0 x0 hb y17ae ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1c78 ff5f fs6 fc0 sc0 ls21 wsb">&lt;script type=&quot;text/javascript&quot;&gt; </div><div class="t m0 x0 hb y1c79 ff5f fs6 fc0 sc0 ls21 wsb">    function sayHi(){ </div><div class="t m0 x0 hb y1c7a ff5f fs6 fc0 sc0 ls21 wsb">        alert(&quot;hi&quot;); </div><div class="t m0 x0 hb y1c7b ff5f fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y1c7c ff5f fs6 fc0 sc0 ls21 wsb">&lt;/script&gt; </div><div class="t m0 x0 hb y1c7d ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y14cd ff5e fs2 fc0 sc0 ls8 wseb">从逻辑上讲，下面的DOM代码是有效的： </div><div class="t m0 x0 hb y1c7e ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1c7f ff5f fs6 fc0 sc0 ls21 wsb">var script = document.createElement(&quot;script&quot;); </div><div class="t m0 x0 hb y1c80 ff5f fs6 fc0 sc0 ls21 wsb">script.type = &quot;text/javascript&quot;; </div><div class="t m0 x0 hb y1c81 ff5f fs6 fc0 sc0 ls21 wsb">script.appendChild(document.createTextNode(&quot;function sayHi(){alert(&apos;hi&apos;);}&quot;)); </div><div class="t m0 x0 hb y1c82 ff5f fs6 fc0 sc0 ls21 wsb">document.body.appendChild(script); </div><div class="t m0 x0 hb y1c83 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1c84 ff5e fs2 fc0 sc0 ls3b">在Firefox、Safari、Chrome和Opera中，这些DOM代码可以正常运行。但在IE中，则会导致错误。</div><div class="t m0 x0 hc y1c85 ff57 fs2 fc0 sc0 lse ws9">IE将&lt;script&gt;视为一个特殊的元素，不允许DOM访问其子节点。不过，可以使用&lt;script&gt;元素的</div><div class="t m0 x0 h5 y1c86 ff5f fs1 fc0 sc0 ls9 ws2">text属性来指定JavaScript代码，像下面的例子这样： </div><div class="t m0 x0 hb y1c87 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1c88 ff5f fs6 fc0 sc0 ls21 wsb">var script = document.createElement(&quot;script&quot;); </div><div class="t m0 x0 hb y1c89 ff5f fs6 fc0 sc0 ls21 wsb">script.type = &quot;text/javascript&quot;; </div><div class="t m0 x0 h15 y1c8a ff63 fs6 fc0 sc0 ls21 wsb">script.text = &quot;function sayHi(){alert(&apos;hi&apos;);}&quot;; </div><div class="t m0 x0 hb y1c8b ff5f fs6 fc0 sc0 ls21 wsb">document.body.appendChild(script); </div><div class="t m0 x0 hb y1c8c ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1c8d ff66 fs2 fc0 sc0 ls8 wsb">DynamicScriptExample01.htm </div><div class="t m0 x0 h5 y1c8e ff5e fs2 fc0 sc0 ls8 wseb">经过这样修改之后的代码可以在IE、Firefox、Opera和Safari 3及之后版本中运行。Safari 3.0之前</div><div class="t m0 x0 h1e y1c8f ff5e fs2 fc0 sc0 ls8 wseb">的版本虽然不能正确地支持text属性，但却允许使用文本节点技术来指定代码。如果需要兼容早期版</div><div class="t m0 x0 h5 y1c90 ff5e fs2 fc0 sc0 ls8 wseb">本的Safari，可以使用下列代码： </div><div class="t m0 x0 hb y7f0 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1c91 ff5f fs6 fc0 sc0 ls21 wsb">var script = document.createElement(&quot;script&quot;); </div><div class="t m0 x0 hb y1c92 ff5f fs6 fc0 sc0 ls21 wsb">script.type = &quot;text/javascript&quot;; </div><div class="t m0 x0 h15 y1c93 ff63 fs6 fc0 sc0 ls21 wsb">var code = &quot;function sayHi(){alert(&apos;hi&apos;);}&quot;; </div></div></div>
<div id="pf129" class="pf w0 h0" data-page-no="129"><div class="pc pc129 w0 h0"><div class="t m0 x2 h2 y1 ff57 fs0 fc0 sc0 ls7 ws0">10.2 DOM操作技术   279 </div><div class="t m0 x0 h3 y2 ff57 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff59 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff59 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff59 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff59 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff59 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff59 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff59 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff59 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff59 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff59 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff59 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff59 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff59 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h15 y8f5 ff63 fs6 fc0 sc0 ls21 wsb">try { </div><div class="t m0 x0 h15 y8f6 ff63 fs6 fc0 sc0 ls21 wsb">    script.appendChild(document.createTextNode(&quot;code&quot;)); </div><div class="t m0 x0 h15 y8f7 ff63 fs6 fc0 sc0 ls21 wsb">} catch (ex){ </div><div class="t m0 x0 h15 y8f8 ff63 fs6 fc0 sc0 ls21 wsb">    script.text = &quot;code&quot;; </div><div class="t m0 x0 h15 y8f9 ff63 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y8fa ff5f fs6 fc0 sc0 ls21 wsb">document.body.appendChild(script); </div><div class="t m0 x5 hb y1c94 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1c95 ff5e fs2 fc0 sc0 ls8 wseb">这里，首先尝试标准的DOM文本节点方法，因为除了IE（在IE中会导致抛出错误），所有浏览器</div><div class="t m0 x0 h5 y1c96 ff5e fs2 fc0 sc0 ls8 wseb">都支持这种方式。如果这行代码抛出了错误，那么说明是IE，于是就必须使用text属性了。整个过程</div><div class="t m0 x0 h5 y1c97 ff5e fs2 fc0 sc0 ls8 wseb">可以用以下函数来表示： </div><div class="t m0 x0 hb y1452 ff5f fs6 fc0 sc0 ls21 wsb">function loadScriptString(code){ </div><div class="t m0 x0 hb y1c98 ff5f fs6 fc0 sc0 ls21 wsb">    var script = document.createElement(&quot;script&quot;); </div><div class="t m0 x0 hb y1c99 ff5f fs6 fc0 sc0 ls21 wsb">    script.type = &quot;text/javascript&quot;; </div><div class="t m0 x0 hb y1c9a ff5f fs6 fc0 sc0 ls21 wsb">    try { </div><div class="t m0 x0 hb y1c9b ff5f fs6 fc0 sc0 ls21 wsb">        script.appendChild(document.createTextNode(code)); </div><div class="t m0 x0 hb y1c9c ff5f fs6 fc0 sc0 ls21 wsb">    } catch (ex){ </div><div class="t m0 x0 hb y1c9d ff5f fs6 fc0 sc0 ls21 wsb">        script.text = code; </div><div class="t m0 x0 hb y1c9e ff5f fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y1c9f ff5f fs6 fc0 sc0 ls21 wsb">    document.body.appendChild(script); </div><div class="t m0 x0 hb y1ca0 ff5f fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h5 y1ca1 ff5e fs2 fc0 sc0 ls8 wseb">下面是调用这个函数的示例： </div><div class="t m0 x5 hb y1ca2 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1ca3 ff5f fs6 fc0 sc0 ls21 wsb">loadScriptString(&quot;function sayHi(){alert(&apos;hi&apos;);}&quot;); </div><div class="t m0 x5 hb y1ca4 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1ca5 ff66 fs2 fc0 sc0 ls8 wsb">DynamicScriptExample02.htm </div><div class="t m0 x0 h4 y1ca6 ff5e fs2 fc0 sc0 ls8 wseb">以这种方式加载的代码会在全局作用域中执行，而且当脚本执行后将立即可用。实际上，这样执行</div><div class="t m0 x0 hc y1ca7 ff5e fs2 fc0 sc0 ls8 wseb">代码与在全局作用域中把相同的字符串传递给eval()是一样的。 </div><div class="t m0 x0 h20 y25 ff5c fs3 fc0 sc0 ls248 ws214">10.2.2 动态样式 </div><div class="t m0 x0 h5 y1ca8 ff5e fs2 fc0 sc0 ls8 wseb">能够把CSS样式包含到HTML页面中的元素有两个。其中，&lt;link&gt;元素用于包含来自外部的文件，</div><div class="t m0 x0 h4 y1ca9 ff5e fs2 fc0 sc0 ls291">而&lt;style&gt;元素用于指定嵌入的样式。与动态脚本类似，所谓动态样式是指在页面刚加载时不存在的样</div><div class="t m0 x0 h5 y1caa ff5e fs2 fc0 sc0 ls8 wseb">式；动态样式是在页面加载完成后动态添加到页面中的。 </div><div class="t m0 x0 he y1cab ff5e fs2 fc0 sc0 ls8 wseb">我们以下面这个典型的&lt;link&gt;元素为例： </div><div class="t m0 x5 hb y1cac ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1cad ff5f fs6 fc0 sc0 ls21 wsb">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;styles.css&quot;&gt; </div><div class="t m0 x5 hb y1cae ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1caf ff5e fs2 fc0 sc0 ls8 wseb">使用DOM代码可以很容易地动态创建出这个元素： </div><div class="t m0 x5 hb y1cb0 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1cb1 ff5f fs6 fc0 sc0 ls21 wsb">var link = document.createElement(&quot;link&quot;); </div><div class="t m0 x0 hb y1cb2 ff5f fs6 fc0 sc0 ls21 wsb">link.rel = &quot;stylesheet&quot;; </div><div class="t m0 x0 hb y1cb3 ff5f fs6 fc0 sc0 ls21 wsb">link.type = &quot;text/css&quot;; </div><div class="t m0 x0 hb y1cb4 ff5f fs6 fc0 sc0 ls21 wsb">link.href = &quot;style.css&quot;; </div><div class="t m0 x0 hb y1cb5 ff5f fs6 fc0 sc0 ls21 wsb">var head = document.getElementsByTagName(&quot;head&quot;)[0]; </div><div class="t m0 x0 hb y1cb6 ff5f fs6 fc0 sc0 ls21 wsb">head.appendChild(link); </div><div class="t m0 x5 hb y1cb7 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1b07 ff5e fs2 fc0 sc0 ls8 wseb">以上代码在所有主流浏览器中都可以正常运行。需要注意的是，必须将&lt;link&gt;元素添加到&lt;head&gt;</div><div class="t m0 x0 h5 y1cb8 ff5e fs2 fc0 sc0 ls8 wseb">而不是&lt;body&gt;元素，才能保证在所有浏览器中的行为一致。整个过程可以用以下函数来表示： </div><div class="t m0 x5 hb ya7f ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1cb9 ff5f fs6 fc0 sc0 ls21 wsb">function loadStyles(url){ </div><div class="t m0 x0 hb y1cba ff5f fs6 fc0 sc0 ls21 wsb">    var link = document.createElement(&quot;link&quot;); </div></div></div>
<div id="pf12a" class="pf w0 h0" data-page-no="12a"><div class="pc pc12a w0 h0"><div class="t m0 x0 h2 y1 ff57 fs0 fc0 sc0 ls7 ws0">280  第10章 DOM </div><div class="t m0 x0 h3 y2 ff57 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y8f5 ff5f fs6 fc0 sc0 ls21 wsb">    link.rel = &quot;stylesheet&quot;; </div><div class="t m0 x0 hb y8f6 ff5f fs6 fc0 sc0 ls21 wsb">    link.type = &quot;text/css&quot;; </div><div class="t m0 x0 hb y8f7 ff5f fs6 fc0 sc0 ls21 wsb">    link.href = url; </div><div class="t m0 x0 hb y8f8 ff5f fs6 fc0 sc0 ls21 wsb">    var head = document.getElementsByTagName(&quot;head&quot;)[0]; </div><div class="t m0 x0 hb y8f9 ff5f fs6 fc0 sc0 ls21 wsb">    head.appendChild(link); </div><div class="t m0 x0 hb y8fa ff5f fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h5 y1c95 ff5e fs2 fc0 sc0 ls8 wseb">调用loadStyles()函数的代码如下所示： </div><div class="t m0 x0 hb y132 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yc0b ff5f fs6 fc0 sc0 ls21 wsb">loadStyles(&quot;styles.css&quot;); </div><div class="t m0 x0 hb y1cbb ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1cbc ff5e fs2 fc0 sc0 ls8 wseb">加载外部样式文件的过程是异步的，也就是加载样式与执行JavaScript代码的过程没有固定的次序。</div><div class="t m0 x0 h4 y13d8 ff5e fs2 fc0 sc0 ls8 wseb">一般来说，知不知道样式已经加载完成并不重要；不过，也存在几种利用事件来检测这个过程是否完成</div><div class="t m0 x0 h5 y1cbd ff5e fs2 fc0 sc0 ls8 wseb">的技术，这些技术将在第13章讨论。 </div><div class="t m0 x0 he y1cbe ff5e fs2 fc0 sc0 ls8 wseb">另一种定义样式的方式是使用&lt;style&gt;元素来包含嵌入式CSS，如下所示： </div><div class="t m0 x0 hb y1cbf ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1cc0 ff5f fs6 fc0 sc0 ls21 wsb">&lt;style type=&quot;text/css&quot;&gt; </div><div class="t m0 x0 hb y1cc1 ff5f fs6 fc0 sc0 ls21 wsb">body { </div><div class="t m0 x0 hb y1cc2 ff5f fs6 fc0 sc0 ls21 wsb">    background-color: red; </div><div class="t m0 x0 hb y1cc3 ff5f fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y1cc4 ff5f fs6 fc0 sc0 ls21 wsb">&lt;/style&gt; </div><div class="t m0 x0 hb y1cc5 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1cc6 ff5e fs2 fc0 sc0 ls8 wseb">按照相同的逻辑，下列DOM代码应该是有效的： </div><div class="t m0 x0 hb y1cc7 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1cc8 ff5f fs6 fc0 sc0 ls21 wsb">var style = document.createElement(&quot;style&quot;); </div><div class="t m0 x0 hb y1cc9 ff5f fs6 fc0 sc0 ls21 wsb">style.type = &quot;text/css&quot;; </div><div class="t m0 x0 hb y1cca ff5f fs6 fc0 sc0 ls21 wsb">style.appendChild(document.createTextNode(&quot;body{background-color:red}&quot;));  </div><div class="t m0 x0 hb y1ccb ff5f fs6 fc0 sc0 ls21 wsb">var head = document.getElementsByTagName(&quot;head&quot;)[0]; </div><div class="t m0 x0 hb y1ccc ff5f fs6 fc0 sc0 ls21 wsb">head.appendChild(style); </div><div class="t m0 x0 hb y1ccd ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1809 ff66 fs2 fc0 sc0 ls5e wsb">DynamicStyleExample01.htm </div><div class="t m0 x0 h5 y1cce ff5e fs2 fc0 sc0 ls8 wseb">以上代码可以在Firefox、Safari、Chrome和Opera中运行，在IE 中则会报错。IE将&lt;style&gt;视为</div><div class="t m0 x0 h5 y1ccf ff5e fs2 fc0 sc0 ls8 wseb">一个特殊的、与&lt;script&gt;类似的节点，不允许访问其子节点。事实上，IE 此时抛出的错误与向&lt;script&gt;</div><div class="t m0 x0 h5 y1cd0 ff5e fs2 fc0 sc0 ls8 wseb">元素添加子节点时抛出的错误相同。解决IE中这个问题的办法，就是访问元素的styleSheet属性，</div><div class="t m0 x0 hc y1cd1 ff5e fs2 fc0 sc0 ls8 wseb">该属性又有一个cssText属性，可以接受CSS代码（第 13章将进一步讨论这两个属性），如下面的例</div><div class="t m0 x0 h5 y15cf ff5e fs2 fc0 sc0 ls8">子所示。 </div><div class="t m0 x0 hb y1cd2 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1cd3 ff5f fs6 fc0 sc0 ls21 wsb">var style = document.createElement(&quot;style&quot;); </div><div class="t m0 x0 hb y1cd4 ff5f fs6 fc0 sc0 ls21 wsb">style.type = &quot;text/css&quot;; </div><div class="t m0 x0 h15 y1cd5 ff63 fs6 fc0 sc0 ls21 wsb">try{ </div><div class="t m0 x0 hb y1cd6 ff5f fs6 fc0 sc0 ls21 wsb">    style.appendChild(document.createTextNode(&quot;body{background-color:red}&quot;)); </div><div class="t m0 x0 h15 y1cd7 ff63 fs6 fc0 sc0 ls21 wsb">} catch (ex){ </div><div class="t m0 x0 h15 y1cd8 ff63 fs6 fc0 sc0 ls21 wsb">    style.styleSheet.cssText = &quot;body{background-color:red}&quot;; </div><div class="t m0 x0 h15 y1cd9 ff63 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y1cda ff5f fs6 fc0 sc0 ls21 wsb">var head = document.getElementsByTagName(&quot;head&quot;)[0]; </div><div class="t m0 x0 hb y1cdb ff5f fs6 fc0 sc0 ls21 wsb">head.appendChild(style); </div><div class="t m0 x0 hb y1cdc ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1cdd ff5e fs2 fc0 sc0 ls8 wseb">与动态添加嵌入式脚本类似，重写后的代码使用了try-catch语句来捕获IE抛出的错误，然后再</div><div class="t m0 x0 h5 y1cde ff5e fs2 fc0 sc0 ls8 wseb">使用针对IE的特殊方式来设置样式。因此，通用的解决方案如下。 </div><div class="t m0 x0 hb y1cdf ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1ce0 ff5f fs6 fc0 sc0 ls21 wsb">function loadStyleString(css){ </div><div class="t m0 x0 hb y1ce1 ff5f fs6 fc0 sc0 ls21 wsb">    var style = document.createElement(&quot;style&quot;); </div></div></div>
<div id="pf12b" class="pf w0 h0" data-page-no="12b"><div class="pc pc12b w0 h0"><div class="t m0 x2 h2 y1 ff57 fs0 fc0 sc0 ls7 ws0">10.2 DOM操作技术   281 </div><div class="t m0 x0 h3 y2 ff57 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff59 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff59 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff59 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff59 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff59 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff59 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff59 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff59 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff59 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff59 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff59 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff59 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff59 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y79 ff5f fs6 fc0 sc0 ls21 wsb">    style.type = &quot;text/css&quot;; </div><div class="t m0 x0 hb y7a ff5f fs6 fc0 sc0 ls21 wsb">    try{ </div><div class="t m0 x0 hb y7b ff5f fs6 fc0 sc0 ls21 wsb">        style.appendChild(document.createTextNode(css)); </div><div class="t m0 x0 hb y7c ff5f fs6 fc0 sc0 ls21 wsb">    } catch (ex){ </div><div class="t m0 x0 hb y7d ff5f fs6 fc0 sc0 ls21 wsb">        style.styleSheet.cssText = css; </div><div class="t m0 x0 hb y7e ff5f fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y7f ff5f fs6 fc0 sc0 ls21 wsb">    var head = document.getElementsByTagName(&quot;head&quot;)[0]; </div><div class="t m0 x0 hb y80 ff5f fs6 fc0 sc0 ls21 wsb">    head.appendChild(style); </div><div class="t m0 x0 hb y81 ff5f fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y82 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y153e ff66 fs2 fc0 sc0 ls8 wsb">DynamicStyleExample02.htm </div><div class="t m0 x0 h5 y1ce2 ff5e fs2 fc0 sc0 ls8 wseb">调用这个函数的示例如下： </div><div class="t m0 x5 hb y1431 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1ce3 ff5f fs6 fc0 sc0 ls21 wsb">loadStyleString(&quot;body{background-color:red}&quot;); </div><div class="t m0 x5 hb y1ce4 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1ce5 ff5e fs2 fc0 sc0 ls8 wseb">这种方式会实时地向页面中添加样式，因此能够马上看到变化。 </div><div class="t m0 x5 h5 y1ce6 ff58 fs2 fc0 sc0 ls8 ws14">如果专门针对IE编写代码，务必小心使用styleSheet.cssText属性。在重用</div><div class="t m0 x5 ha y1ce7 ff58 fs2 fc0 sc0 ls30 ws12c">同一个&lt;style&gt;元素并再次设置这个属性时，有可能会导致浏览器崩溃。同样，将</div><div class="t m0 x5 h5 y1ce8 ff5f fs1 fc0 sc0 ls9 ws2">cssText属性设置为空字符串也可能导致浏览器崩溃。我们希望IE中的这个bug 能</div><div class="t m0 x5 h5 y1ce9 ff58 fs2 fc0 sc0 ls8 ws14">够在将来被修复。 </div><div class="t m0 x0 h20 y1cea ff5c fs3 fc0 sc0 ls248 ws214">10.2.3 操作表格 </div><div class="t m0 x0 h5 y1ceb ff5f fs1 fc0 sc0 ls9 ws2">&lt;table&gt;元素是HTML中最复杂的结构之一。要想创建表格，一般都必须涉及表示表格行、单元格、</div><div class="t m0 x0 h5 y1cec ff5e fs2 fc0 sc0 ls8 wseb">表头等方面的标签。由于涉及的标签多，因而使用核心DOM方法创建和修改表格往往都免不了要编写</div><div class="t m0 x0 h5 y1ced ff5e fs2 fc0 sc0 ls8 wseb">大量的代码。假设我们要使用DOM来创建下面的HTML表格。 </div><div class="t m0 x5 hb y1cee ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1cef ff5f fs6 fc0 sc0 ls21 wsb">&lt;table border=&quot;1&quot; width=&quot;100%&quot;&gt; </div><div class="t m0 x0 hb y1cf0 ff5f fs6 fc0 sc0 ls21 wsb">    &lt;tbody&gt; </div><div class="t m0 x0 hb y1cf1 ff5f fs6 fc0 sc0 ls21 wsb">        &lt;tr&gt; </div><div class="t m0 x0 hb y1cf2 ff5f fs6 fc0 sc0 ls21 wsb">            &lt;td&gt;Cell 1,1&lt;/td&gt; </div><div class="t m0 x0 hb y1cf3 ff5f fs6 fc0 sc0 ls21 wsb">            &lt;td&gt;Cell 2,1&lt;/td&gt; </div><div class="t m0 x0 hb y1cf4 ff5f fs6 fc0 sc0 ls21 wsb">        &lt;/tr&gt; </div><div class="t m0 x0 hb y1cf5 ff5f fs6 fc0 sc0 ls21 wsb">        &lt;tr&gt; </div><div class="t m0 x0 hb y1cf6 ff5f fs6 fc0 sc0 ls21 wsb">            &lt;td&gt;Cell 1,2&lt;/td&gt; </div><div class="t m0 x0 hb y1cf7 ff5f fs6 fc0 sc0 ls21 wsb">            &lt;td&gt;Cell 2,2&lt;/td&gt; </div><div class="t m0 x0 hb y1cf8 ff5f fs6 fc0 sc0 ls21 wsb">        &lt;/tr&gt; </div><div class="t m0 x0 hb y1cf9 ff5f fs6 fc0 sc0 ls21 wsb">    &lt;/tbody&gt; </div><div class="t m0 x0 hb y1cfa ff5f fs6 fc0 sc0 ls21 wsb">&lt;/table&gt; </div><div class="t m0 x0 hb y1cfb ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1cfc ff5e fs2 fc0 sc0 ls8 wseb">要使用核心DOM方法创建这些元素，得需要像下面这么多的代码： </div><div class="t m0 x0 hb y1cfd ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1cfe ff5f fs6 fc0 sc0 ls21">//创建table </div><div class="t m0 x0 hb y1cff ff5f fs6 fc0 sc0 ls21 wsb">var table = document.createElement(&quot;table&quot;); </div><div class="t m0 x0 hb y1d00 ff5f fs6 fc0 sc0 ls21 wsb">table.border = 1; </div><div class="t m0 x0 hb y1d01 ff5f fs6 fc0 sc0 ls21 wsb">table.width = &quot;100%&quot;; </div><div class="t m0 x0 hb y1d02 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1d03 ff5f fs6 fc0 sc0 ls21">//创建tbody </div><div class="t m0 x0 hb y1d04 ff5f fs6 fc0 sc0 ls21 wsb">var tbody = document.createElement(&quot;tbody&quot;); </div></div></div>
<div id="pf12c" class="pf w0 h0" data-page-no="12c"><div class="pc pc12c w0 h0"><div class="t m0 x0 h2 y1 ff57 fs0 fc0 sc0 ls7 ws0">282  第10章 DOM </div><div class="t m0 x0 h3 y2 ff57 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y8f5 ff5f fs6 fc0 sc0 ls21 wsb">table.appendChild(tbody); </div><div class="t m0 x0 hb y8f6 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y8f7 ff5f fs6 fc0 sc0 ls21">//创建第一行 </div><div class="t m0 x0 hb y8f8 ff5f fs6 fc0 sc0 ls21 wsb">var row1 = document.createElement(&quot;tr&quot;); </div><div class="t m0 x0 hb y8f9 ff5f fs6 fc0 sc0 ls21 wsb">tbody.appendChild(row1); </div><div class="t m0 x0 hb y8fa ff5f fs6 fc0 sc0 ls21 wsb">var cell1_1 = document.createElement(&quot;td&quot;); </div><div class="t m0 x0 hb y8fb ff5f fs6 fc0 sc0 ls21 wsb">cell1_1.appendChild(document.createTextNode(&quot;Cell 1,1&quot;)); </div><div class="t m0 x0 hb y8fc ff5f fs6 fc0 sc0 ls21 wsb">row1.appendChild(cell1_1); </div><div class="t m0 x0 hb y8fd ff5f fs6 fc0 sc0 ls21 wsb">var cell2_1 = document.createElement(&quot;td&quot;); </div><div class="t m0 x0 hb y1037 ff5f fs6 fc0 sc0 ls21 wsb">cell2_1.appendChild(document.createTextNode(&quot;Cell 2,1&quot;)); </div><div class="t m0 x0 hb y1038 ff5f fs6 fc0 sc0 ls21 wsb">row1.appendChild(cell2_1); </div><div class="t m0 x0 hb y1039 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y16a9 ff5f fs6 fc0 sc0 ls21">//创建第二行 </div><div class="t m0 x0 hb y16aa ff5f fs6 fc0 sc0 ls21 wsb">var row2 = document.createElement(&quot;tr&quot;); </div><div class="t m0 x0 hb y16ab ff5f fs6 fc0 sc0 ls21 wsb">tbody.appendChild(row2); </div><div class="t m0 x0 hb y16ac ff5f fs6 fc0 sc0 ls21 wsb">var cell1_2 = document.createElement(&quot;td&quot;); </div><div class="t m0 x0 hb y16ad ff5f fs6 fc0 sc0 ls21 wsb">cell1_2.appendChild(document.createTextNode(&quot;Cell 1,2&quot;)); </div><div class="t m0 x0 hb y16ae ff5f fs6 fc0 sc0 ls21 wsb">row2.appendChild(cell1_2); </div><div class="t m0 x0 hb y16af ff5f fs6 fc0 sc0 ls21 wsb">var cell2_2= document.createElement(&quot;td&quot;); </div><div class="t m0 x0 hb y16b0 ff5f fs6 fc0 sc0 ls21 wsb">cell2_2.appendChild(document.createTextNode(&quot;Cell 2,2&quot;)); </div><div class="t m0 x0 hb y16b1 ff5f fs6 fc0 sc0 ls21 wsb">row2.appendChild(cell2_2); </div><div class="t m0 x0 hb y16b2 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y16b3 ff5f fs6 fc0 sc0 ls21">//将表格添加到文档主体中 </div><div class="t m0 x0 hb y16b4 ff5f fs6 fc0 sc0 ls21 wsb">document.body.appendChild(table); </div><div class="t m0 x0 hb y1d05 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1d06 ff5e fs2 fc0 sc0 ls8 wseb">显然，DOM代码很长，还有点不太好懂。为了方便构建表格，HTML DOM还为&lt;table&gt;、&lt;tbody&gt;</div><div class="t m0 x0 h5 y1d07 ff5e fs2 fc0 sc0 ls8 wseb">和&lt;tr&gt;元素添加了一些属性和方法。 </div><div class="t m0 x0 hc y1d08 ff5e fs2 fc0 sc0 ls8 wseb">为&lt;table&gt;元素添加的属性和方法如下。 </div><div class="t m0 x0 h5 y1d09 ff5d fs1 fc0 sc0 ls2"> caption：保存着对&lt;caption&gt;元素（如果有）的指针。 </div><div class="t m0 x0 h5 y1d0a ff5d fs1 fc0 sc0 ls2"> tBodies：是一个&lt;tbody&gt;元素的HTMLCollection。 </div><div class="t m0 x0 h5 y1d0b ff5d fs1 fc0 sc0 ls2"> tFoot：保存着对&lt;tfoot&gt;元素（如果有）的指针。 </div><div class="t m0 x0 h5 y1b84 ff5d fs1 fc0 sc0 ls2"> tHead：保存着对&lt;thead&gt;元素（如果有）的指针。 </div><div class="t m0 x0 h5 y141b ff5d fs1 fc0 sc0 ls2"> rows：是一个表格中所有行的HTMLCollection。 </div><div class="t m0 x0 h5 y1d0c ff5d fs1 fc0 sc0 ls2"> createTHead()：创建&lt;thead&gt;元素，将其放到表格中，返回引用。 </div><div class="t m0 x0 h5 y1d0d ff5d fs1 fc0 sc0 ls2"> createTFoot()：创建&lt;tfoot&gt;元素，将其放到表格中，返回引用。 </div><div class="t m0 x0 h5 y1b86 ff5d fs1 fc0 sc0 ls2"> createCaption()：创建&lt;caption&gt;元素，将其放到表格中，返回引用。 </div><div class="t m0 x0 h5 y1d0e ff5d fs1 fc0 sc0 ls2"> deleteTHead()：删除&lt;thead&gt;元素。 </div><div class="t m0 x0 h5 y418 ff5d fs1 fc0 sc0 ls2"> deleteTFoot()：删除&lt;tfoot&gt;元素。 </div><div class="t m0 x0 h5 y1d0f ff5d fs1 fc0 sc0 ls2"> deleteCaption()：删除&lt;caption&gt;元素。 </div><div class="t m0 x0 h5 y1d10 ff5d fs1 fc0 sc0 ls2"> deleteRow(pos)：删除指定位置的行。 </div><div class="t m0 x0 h5 y7ed ff5d fs1 fc0 sc0 ls2"> insertRow(pos)：向rows集合中的指定位置插入一行。 </div><div class="t m0 x0 h5 yd60 ff5e fs2 fc0 sc0 ls8 wseb">为&lt;tbody&gt;元素添加的属性和方法如下。 </div><div class="t m0 x0 h5 y1d11 ff5d fs1 fc0 sc0 ls2"> rows：保存着&lt;tbody&gt;元素中行的HTMLCollection。 </div><div class="t m0 x0 h5 y1d12 ff5d fs1 fc0 sc0 ls2"> deleteRow(pos)：删除指定位置的行。 </div><div class="t m0 x0 h5 y1d13 ff5d fs1 fc0 sc0 ls2"> insertRow(pos)：向rows集合中的指定位置插入一行，返回对新插入行的引用。 </div><div class="t m0 x0 h5 y1d14 ff5e fs2 fc0 sc0 ls8 wseb">为&lt;tr&gt;元素添加的属性和方法如下。 </div></div></div>
<div id="pf12d" class="pf w0 h0" data-page-no="12d"><div class="pc pc12d w0 h0"><div class="t m0 x2 h2 y1 ff57 fs0 fc0 sc0 ls7 ws0">10.2 DOM操作技术   283 </div><div class="t m0 x0 h3 y2 ff57 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff59 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff59 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff59 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff59 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff59 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff59 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff59 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff59 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff59 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff59 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff59 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff59 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff59 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff5d fs1 fc0 sc0 ls2"> cells：保存着&lt;tr&gt;元素中单元格的HTMLCollection。 </div><div class="t m0 x0 h5 y4 ff5d fs1 fc0 sc0 ls2"> deleteCell(pos)：删除指定位置的单元格。 </div><div class="t m0 x0 h5 y4e ff5d fs1 fc0 sc0 ls8 ws134"> insertCell(pos)：向cells集合中的指定位置插入一个单元格，返回对新插入单元格的引用。 </div><div class="t m0 x0 h4 yd9 ff5e fs2 fc0 sc0 ls8 wseb">使用这些属性和方法，可以极大地减少创建表格所需的代码数量。例如，使用这些属性和方法可以</div><div class="t m0 x0 h5 y15d ff5e fs2 fc0 sc0 ls8 wseb">将前面的代码重写如下（加阴影的部分是重写后的代码）。 </div><div class="t m0 x0 h16 y1d15 ff5f fs6 fc0 sc0 ls21">//创建table </div><div class="t m0 x0 hb y1d16 ff5f fs6 fc0 sc0 ls21 wsb">var table = document.createElement(&quot;table&quot;); </div><div class="t m0 x0 hb y1d17 ff5f fs6 fc0 sc0 ls21 wsb">table.border = 1; </div><div class="t m0 x0 hb y1d18 ff5f fs6 fc0 sc0 ls21 wsb">table.width = &quot;100%&quot;; </div><div class="t m0 x0 hb y1d19 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1d1a ff5f fs6 fc0 sc0 ls21">//创建tbody </div><div class="t m0 x0 hb y1d1b ff5f fs6 fc0 sc0 ls21 wsb">var tbody = document.createElement(&quot;tbody&quot;); </div><div class="t m0 x0 hb y1d1c ff5f fs6 fc0 sc0 ls21 wsb">table.appendChild(tbody); </div><div class="t m0 x0 hb y1d1d ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1d1e ff63 fs6 fc0 sc0 ls21 ws34">//创建第一行 </div><div class="t m0 x0 h15 y1d1f ff63 fs6 fc0 sc0 ls21 wsb">tbody.insertRow(0); </div><div class="t m0 x0 h15 y1d20 ff63 fs6 fc0 sc0 ls21 wsb">tbody.rows[0].insertCell(0); </div><div class="t m0 x0 h15 y1d21 ff63 fs6 fc0 sc0 ls21 wsb">tbody.rows[0].cells[0].appendChild(document.createTextNode(&quot;Cell 1,1&quot;)); </div><div class="t m0 x0 h15 y1d22 ff63 fs6 fc0 sc0 ls21 wsb">tbody.rows[0].insertCell(1); </div><div class="t m0 x0 h15 y1d23 ff63 fs6 fc0 sc0 ls21 wsb">tbody.rows[0].cells[1].appendChild(document.createTextNode(&quot;Cell 2,1&quot;)); </div><div class="t m0 x0 h15 y1d24 ff63 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1d25 ff63 fs6 fc0 sc0 ls21 ws34">//创建第二行 </div><div class="t m0 x0 h15 y1d26 ff63 fs6 fc0 sc0 ls21 wsb">tbody.insertRow(1); </div><div class="t m0 x0 h15 y1d27 ff63 fs6 fc0 sc0 ls21 wsb">tbody.rows[1].insertCell(0); </div><div class="t m0 x0 h15 y1d28 ff63 fs6 fc0 sc0 ls21 wsb">tbody.rows[1].cells[0].appendChild(document.createTextNode(&quot;Cell 1,2&quot;)); </div><div class="t m0 x0 h15 y1d29 ff63 fs6 fc0 sc0 ls21 wsb">tbody.rows[1].insertCell(1); </div><div class="t m0 x0 h15 y1d2a ff63 fs6 fc0 sc0 ls21 wsb">tbody.rows[1].cells[1].appendChild(document.createTextNode(&quot;Cell 2,2&quot;)); </div><div class="t m0 x0 h15 y1d2b ff63 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1d2c ff5f fs6 fc0 sc0 ls21">//将表格添加到文档主体中 </div><div class="t m0 x0 hb y1d2d ff5f fs6 fc0 sc0 ls21 wsb">document.body.appendChild(table); </div><div class="t m0 x5 hb y1d2e ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1d2f ff5e fs2 fc0 sc0 ls8 wseb">在这次的代码中，创建&lt;table&gt;和&lt;tbody&gt;的代码没有变化。不同的是创建两行的部分，其中使用</div><div class="t m0 x0 h5 y1d30 ff5e fs2 fc0 sc0 ls6e">了HTML DOM定义的表格属性和方法。在创建第一行时，通过&lt;tbody&gt;元素调用了insertRow()方</div><div class="t m0 x0 h5 y1d31 ff5e fs2 fc0 sc0 ls8 wseb">法，传入了参数0——表示应该将插入的行放在什么位置上。执行这一行代码后，就会自动创建一行并</div><div class="t m0 x0 he y1d32 ff5e fs2 fc0 sc0 ls8 wseb">将其插入到&lt;tbody&gt;元素的位置0上，因此就可以马上通过tbody.rows[0]来引用新插入的行。 </div><div class="t m0 x0 h4 y1d33 ff5e fs2 fc0 sc0 ls6 wsf7">创建单元格的方式也十分相似，即通过&lt;tr&gt;元素调用insertCell()方法并传入放置单元格的位</div><div class="t m0 x0 h1e y1d34 ff5e fs2 fc0 sc0 ls8 wseb">置。然后，就可以通过tbody.rows[0].cells[0]来引用新插入的单元格，因为新创建的单元格被插</div><div class="t m0 x0 h5 y1d35 ff5e fs2 fc0 sc0 ls8 wseb">入到了这一行的位置0上。 </div><div class="t m0 x0 h4 y1d36 ff5e fs2 fc0 sc0 ls8 wseb">总之，使用这些属性和方法创建表格的逻辑性更强，也更容易看懂，尽管技术上这两套代码都是正</div><div class="t m0 x0 h5 y1d37 ff5e fs2 fc0 sc0 ls8">确的。 </div><div class="t m0 x0 h20 y1d38 ff5c fs3 fc0 sc0 ls248 ws214">10.2.4 使用NodeList </div><div class="t m0 x0 h5 y1d39 ff5e fs2 fc0 sc0 ls8 wseb">理解NodeList及其“近亲”NamedNodeMap和HTMLCollection，是从整体上透彻理解DOM的</div><div class="t m0 x0 h4 y1d3a ff5e fs2 fc0 sc0 ls6 wsf7">关键所在。这三个集合都是“动态的”；换句话说，每当文档结构发生变化时，它们都会得到更新。因</div><div class="t m0 x0 he y1d3b ff5e fs2 fc0 sc0 ls8 wseb">此，它们始终都会保存着最新、最准确的信息。从本质上说，所有NodeList对象都是在访问DOM文</div><div class="t m0 x0 h5 y6e3 ff5e fs2 fc0 sc0 ls8 wseb">档时实时运行的查询。例如，下列代码会导致无限循环： </div><div class="t m0 x5 hb y1d3c ff5f fs6 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf12e" class="pf w0 h0" data-page-no="12e"><div class="pc pc12e w0 h0"><div class="t m0 x0 h2 y1 ff57 fs0 fc0 sc0 ls7 ws0">284  第10章 DOM </div><div class="t m0 x0 h3 y2 ff57 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 ff5f fs6 fc0 sc0 ls21 wsb">var divs = document.getElementsByTagName(&quot;div&quot;), </div><div class="t m0 x0 hb y7a ff5f fs6 fc0 sc0 ls21 wsb">    i,  </div><div class="t m0 x0 hb y7b ff5f fs6 fc0 sc0 ls21 wsb">    div; </div><div class="t m0 x0 hb y7c ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y7d ff5f fs6 fc0 sc0 ls21 wsb">for (i=0; i &lt; divs.length; i++){ </div><div class="t m0 x0 hb y7e ff5f fs6 fc0 sc0 ls21 wsb">    div = document.createElement(&quot;div&quot;); </div><div class="t m0 x0 hb y7f ff5f fs6 fc0 sc0 ls21 wsb">    document.body.appendChild(div); </div><div class="t m0 x0 hb y80 ff5f fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 h4 y1d3d ff5e fs2 fc0 sc0 ls5 wsec">第一行代码会取得文档中所有&lt;div&gt;元素的HTMLCollection。由于这个集合是“动态的”，因此</div><div class="t m0 x0 h1e y1d3e ff5e fs2 fc0 sc0 ls30 wsf6">只要有新&lt;div&gt;元素被添加到页面中，这个元素也会被添加到该集合中。浏览器不会将创建的所有集</div><div class="t m0 x0 h4 y1d3f ff5e fs2 fc0 sc0 ls24">合都保存在一个列表中，而是在下一次访问集合时再更新集合。结果，在遇到上例中所示的循环代码</div><div class="t m0 x0 h1c y1d40 ff5e fs2 fc0 sc0 ls5 wsec">时，就会导致一个有趣的问题。每次循环都要对条件i &lt; divs.length求值，意味着会运行取得所</div><div class="t m0 x0 h1e y1d41 ff5e fs2 fc0 sc0 ls294">有&lt;div&gt;元素的查询。考虑到循环体每次都会创建一个新&lt;div&gt;元素并将其添加到文档中，因此</div><div class="t m0 x0 h4 y5a4 ff5f fs1 fc0 sc0 ls16 ws17">divs.length的值在每次循环后都会递增。既然i和divs.length每次都会同时递增，结果它们的</div><div class="t m0 x0 h5 y1d42 ff5e fs2 fc0 sc0 ls5">值永远也不会相等。 </div><div class="t m0 x0 h1c y1d43 ff5e fs2 fc0 sc0 ls8 wseb">如果想要迭代一个NodeList，最好是使用length属性初始化第二个变量，然后将迭代器与该变</div><div class="t m0 x0 h5 y1d44 ff5e fs2 fc0 sc0 ls8 wseb">量进行比较，如下面的例子所示： </div><div class="t m0 x0 hb y1d45 ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1d46 ff5f fs6 fc0 sc0 ls21 wsb">var divs = document.getElementsByTagName(&quot;div&quot;), </div><div class="t m0 x0 hb y1d47 ff5f fs6 fc0 sc0 ls21 wsb">    i, </div><div class="t m0 x0 hb y1d48 ff5f fs6 fc0 sc0 ls21 wsb">    len, </div><div class="t m0 x0 hb y1d49 ff5f fs6 fc0 sc0 ls21 wsb">    div; </div><div class="t m0 x0 hb y1d4a ff5f fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y1d4b ff63 fs6 fc0 sc0 ls21 wsb">for (i=0, len=divs.length; i &lt; len; i++){ </div><div class="t m0 x0 hb y1d4c ff5f fs6 fc0 sc0 ls21 wsb">    div = document.createElement(&quot;div&quot;); </div><div class="t m0 x0 hb y1d4d ff5f fs6 fc0 sc0 ls21 wsb">    document.body.appendChild(div); </div><div class="t m0 x0 hb y1d4e ff5f fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h4 ye98 ff5e fs2 fc0 sc0 ls8 wseb">这个例子中初始化了第二个变量len。由于len中保存着对 divs.length在循环开始时的一个快</div><div class="t m0 x0 h1e y1d4f ff5e fs2 fc0 sc0 ls8 wseb">照，因此就会避免上一个例子中出现的无限循环问题。在本章演示迭代NodeList对象的例子中，使用</div><div class="t m0 x0 h5 y9f5 ff5e fs2 fc0 sc0 ls8 wseb">的都是这种更为保险的方式。 </div><div class="t m0 x0 h1c y9f6 ff5e fs2 fc0 sc0 ls8 wseb">一般来说，应该尽量减少访问NodeList的次数。因为每次访问NodeList，都会运行一次基于文</div><div class="t m0 x0 h5 y1716 ff5e fs2 fc0 sc0 ls8 wseb">档的查询。所以，可以考虑将从NodeList中取得的值缓存起来。 </div><div class="t m0 x0 hd y120 ff5c fs7 fc0 sc0 ls245">10.3 小结 </div><div class="t m0 x0 h5 y1d50 ff57 fs2 fc0 sc0 ls81 ws76">DOM是语言中立的API，用于访问和操作HTML和XML文档。DO M1级将HTML和XML文档</div><div class="t m0 x0 h5 y1d51 ff5e fs2 fc0 sc0 ls8 wseb">形象地看作一个层次化的节点树，可以使用JavaScript来操作这个节点树，进而改变底层文档的外观和</div><div class="t m0 x0 h5 y1d52 ff5e fs2 fc0 sc0 ls8">结构。 </div><div class="t m0 x0 h5 y1d53 ff57 fs2 fc0 sc0 ls81 ws76">DOM由各种节点构成，简要总结如下。 </div><div class="t m0 x0 h4 y1d54 ff5d fs1 fc0 sc0 ls2"> 最基本的节点类型是Node，用于抽象地表示文档中一个独立的部分；所有其他类型都继承自</div><div class="t m0 x0 h5 y1d55 ff5f fs1 fc0 sc0 ls9 ws2">Node。 </div><div class="t m0 x0 h5 y1d56 ff5d fs1 fc0 sc0 ls2"> Document类型表示整个文档，是一组分层节点的根节点。在JavaScript中，document对象是</div><div class="t m0 x0 h5 y1d57 ff5f fs1 fc0 sc0 ls9 ws2">Document的一个实例。使用document对象，有很多种方式可以查询和取得节点。 </div><div class="t m0 x0 h5 y1b0a ff5d fs1 fc0 sc0 ls2"> Element节点表示文档中的所有HTML或XML元素，可以用来操作这些元素的内容和特性。 </div><div class="t m0 x0 h5 yeac ff5d fs1 fc0 sc0 ls2"> 另外还有一些节点类型，分别表示文本内容、注释、文档类型、CDATA区域和文档片段。 </div></div></div>
<div id="pf12f" class="pf w0 h0" data-page-no="12f"><div class="pc pc12f w0 h0"><div class="t m0 x2 h2 y1 ff57 fs0 fc0 sc0 ls7 ws0">10.3 小结  285 </div><div class="t m0 x0 h3 y2 ff57 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff59 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff59 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff59 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff59 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff59 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff59 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff59 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff59 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff59 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff59 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff59 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff59 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff59 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff5e fs2 fc0 sc0 ls8 wseb">访问DOM的操作在多数情况下都很直观，不过在处理&lt;script&gt;和&lt;style&gt;元素时还是存在一些</div><div class="t m0 x0 h4 y4d ff5e fs2 fc0 sc0 ls8 wseb">复杂性。由于这两个元素分别包含脚本和样式信息，因此浏览器通常会将它们与其他元素区别对待。这</div><div class="t m0 x0 he yd8 ff5e fs2 fc0 sc0 ls8 wseb">些区别导致了在针对这些元素使用innerHTML时，以及在创建新元素时的一些问题。 </div><div class="t m0 x0 h5 yd9 ff5e fs2 fc0 sc0 ls8 wseb">理解DOM的关键，就是理解DOM对性能的影响。DOM操作往往是 JavaScript程序中开销最大的</div><div class="t m0 x0 h1e y15d ff5e fs2 fc0 sc0 ls8 wseb">部分，而因访问NodeList导致的问题为最多。NodeList对象都是“动态的”，这就意味着每次访问</div><div class="t m0 x0 h5 y8 ff5f fs1 fc0 sc0 ls9 ws2">NodeList对象，都会运行一次查询。有鉴于此，最好的办法就是尽量减少DOM操作。 </div><div class="t m0 x0 h5 y1d58 ff57 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1d59 ff57 fs2 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf130" class="pf w0 h0" data-page-no="130"><div class="pc pc130 w0 h0"><div class="t m0 x0 h2 y1 ff69 fs0 fc0 sc0 ls7 ws0">286  第11章 DOM扩展 </div><div class="t m0 x0 h3 y2 ff69 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h9 y2a ff6b fs5 fc0 sc0 ls12 wsb">DOM扩展 </div><div class="t m0 x0 h3c y2b ff6c fs2 fc0 sc0 ls8">本章内容 </div><div class="t m0 x0 h5 y2c ff6e fs1 fc0 sc0 ls2"> 理解Selectors API </div><div class="t m0 x0 h5 y2d ff6e fs1 fc0 sc0 ls2"> 使用HTML5 DOM扩展 </div><div class="t m0 x0 h5 y2e ff6e fs1 fc0 sc0 ls2"> 了解专有的DOM扩展 </div><div class="t m0 x0 h5 y8d9 ff69 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y8da ff6f fs2 fc0 sc0 ls61">管DOM作为API已经非常完善了，但为了实现更多的功能，仍然会有一些标准或专有的扩</div><div class="t m0 x0 h5 y8db ff6f fs2 fc0 sc0 ls8 ws1">展。2008年之前，浏览器中几乎所有的DOM扩展都是专有的。此后，W3C着手将一些已经</div><div class="t m0 x0 h5 y8dc ff6f fs2 fc0 sc0 ls8 ws1">成为事实标准的专有扩展标准化并写入规范当中。 </div><div class="t m0 x0 h5 y8dd ff6f fs2 fc0 sc0 ls3b">对DOM的两个主要的扩展是Selectors API（选择符API）和HTML5。这两个扩展都源自开发社区，</div><div class="t m0 x0 h5 y8de ff6f fs2 fc0 sc0 ls8 ws1">而将某些常见做法及API标准化一直是众望所归。此外，还有一个不那么引人瞩目的Element Traversal</div><div class="t m0 x0 h5 y8df ff6f fs2 fc0 sc0 ls8 ws1">（元素遍历）规范，为DOM添加了一些属性。虽然前述两个主要规范（特别是HTML5）已经涵盖了大</div><div class="t m0 x0 h5 y8e0 ff6f fs2 fc0 sc0 ls8 ws1">量的DOM扩展，但专有扩展依然存在。本章也会介绍专有的DOM扩展。 </div><div class="t m0 x0 hd yef7 ff6d fs7 fc0 sc0 ls245">11.1 选择符API </div><div class="t m0 x0 h5 y10ca ff6f fs2 fc0 sc0 ls8 ws1">众多JavaScript库中最常用的一项功能，就是根据CSS选择符选择与某个模式匹配的 DOM元素。</div><div class="t m0 x0 h5 y10cb ff6f fs2 fc0 sc0 ls8">实际上，jQuery（www.jquery.com）的核心就是通过CSS选择符查询DOM文档取得元素的引用，从而</div><div class="t m0 x0 hc y10cc ff6f fs2 fc0 sc0 ls8 ws1">抛开了getElementById()和getElementsByTagName()。 </div><div class="t m0 x0 h5 y8e5 ff69 fs2 fc0 sc0 ls138 ws1ab">Selectors API（www.w3.org/TR/selectors-api/）是由W3C发起制定的一个标准，致力于让浏览器原</div><div class="t m0 x0 h5 y1d5b ff6f fs2 fc0 sc0 ls8 ws1">生支持CSS查询。所有实现这一功能的JavaScript库都会写一个基础的CSS解析器，然后再使用已有的</div><div class="t m0 x0 h5 y1d5c ff69 fs2 fc0 sc0 ls81 ws76">DOM方法查询文档并找到匹配的节点。尽管库开发人员在不知疲倦地改进这一过程的性能，但到头来</div><div class="t m0 x0 h5 y1d5d ff6f fs2 fc0 sc0 ls8 ws1">都只能通过运行JavaScript代码来完成查询操作。而把这个功能变成原生API之后，解析和树查询操作</div><div class="t m0 x0 h5 y1d5e ff6f fs2 fc0 sc0 ls8 ws1">可以在浏览器内部通过编译后的代码来完成，极大地改善了性能。 </div><div class="t m0 x0 h5 y1d5f ff69 fs2 fc0 sc0 ls25a ws25b">Selectors API Level 1的核心是两个方法：querySelector()和querySelectorAll()。在兼容的浏</div><div class="t m0 x0 h5 y1d60 ff6f fs2 fc0 sc0 ls42 ws30">览器中，可以通过Document及Element类型的实例调用它们。目前已完全支持Selectors API  Level 1</div><div class="t m0 x0 h5 y1d61 ff6f fs2 fc0 sc0 ls42 ws30">的浏览器有IE 8+、Firefox 3.5+、Safari 3.1+、Chrome和Opera 10+。 </div><div class="t m0 x0 h20 y1d62 ff6d fs3 fc0 sc0 ls248 ws214">11.1.1 querySelector()方法 </div><div class="t m0 x0 h5 y1d63 ff70 fs1 fc0 sc0 ls9 ws2">querySelector()方法接收一个CSS选择符，返回与该模式匹配的第一个元素，如果没有找到匹</div><div class="t m0 x0 hc y1d64 ff6f fs2 fc0 sc0 ls8 ws1">配的元素，返回null。请看下面的例子。 </div><div class="t m0 x0 hb y1d65 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1d66 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h10 y8f4 ff6c fs9 fc0 sc0 ls8 wsb">尽 </div><div class="t m0 x0 h11 y4b ff72 fsa fc0 sc0 ls8">第</div><div class="t m1 x0 h12 y4b ff73 fsb fc3 sc0 ls247">11</div><div class="t m0 x5 h9 y4b ff72 fsa fc0 sc0 ls8 ws1d">章 </div></div></div>
<div id="pf131" class="pf w0 h0" data-page-no="131"><div class="pc pc131 w0 h0"><div class="t m0 x2 h2 y1 ff69 fs0 fc0 sc0 lsc2 wsa0">11.1 选择符API  287 </div><div class="t m0 x0 h3 y2 ff69 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff74 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff74 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff74 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff74 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff74 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff74 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff74 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff74 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff74 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff74 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff74 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ff74 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff74 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h34 y79 ff70 fs6 fc0 sc0 ls21">//取得body元素 </div><div class="t m0 x0 hb y7a ff70 fs6 fc0 sc0 ls21 wsb">var body = document.querySelector(&quot;body&quot;); </div><div class="t m0 x0 hb y1d67 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y1d68 ff70 fs6 fc0 sc0 ls21">//取得ID为&quot;myDiv&quot;的元素 </div><div class="t m0 x0 hb y1d69 ff70 fs6 fc0 sc0 ls21 wsb">var myDiv = document.querySelector(&quot;#myDiv&quot;); </div><div class="t m0 x0 hb y1d6a ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y1d6b ff70 fs6 fc0 sc0 ls21">//取得类为&quot;selected&quot;的第一个元素 </div><div class="t m0 x0 hb y1d6c ff70 fs6 fc0 sc0 ls21 wsb">var selected = document.querySelector(&quot;.selected&quot;); </div><div class="t m0 x0 hb y1d6d ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y1d6e ff70 fs6 fc0 sc0 ls21">//取得类为&quot;button&quot;的第一个图像元素 </div><div class="t m0 x0 hb y1d6f ff70 fs6 fc0 sc0 ls21 wsb">var img = document.body.querySelector(&quot;img.button&quot;); </div><div class="t m0 x0 hb y1d70 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1d71 ff75 fs2 fc0 sc0 ls79 wsb">SelectorsAPIExample01.htm </div><div class="t m0 x0 h4 y1d72 ff6f fs2 fc0 sc0 ls8 ws1">通过Document类型调用querySelector()方法时，会在文档元素的范围内查找匹配的元素。而</div><div class="t m0 x0 hc y1d73 ff6f fs2 fc0 sc0 ls8 ws1">通过Element类型调用querySelector()方法时，只会在该元素后代元素的范围内查找匹配的元素。 </div><div class="t m0 x0 h5 y743 ff69 fs2 fc0 sc0 ls14d ws11a">CSS选择符可以简单也可以复杂，视情况而定。如果传入了不被支持的选择符，querySelector()</div><div class="t m0 x0 h5 y1d74 ff6f fs2 fc0 sc0 ls8 ws1">会抛出错误。 </div><div class="t m0 x0 h20 y1d75 ff6d fs3 fc0 sc0 ls248 ws214">11.1.2 querySelectorAll()方法 </div><div class="t m0 x0 h5 y1d76 ff70 fs1 fc0 sc0 ls9 ws2">querySelectorAll()方法接收的参数与querySelector()方法一样，都是一个CSS选择符，但</div><div class="t m0 x0 hc y5d ff6f fs2 fc0 sc0 ls8 ws1">返回的是所有匹配的元素而不仅仅是一个元素。这个方法返回的是一个NodeList的实例。 </div><div class="t m0 x0 h4 y1d77 ff6f fs2 fc0 sc0 ls8 ws1">具体来说，返回的值实际上是带有所有属性和方法的NodeList，而其底层实现则类似于一组元素</div><div class="t m0 x0 h1e y1d78 ff6f fs2 fc0 sc0 ls8 ws1">的快照，而非不断对文档进行搜索的动态查询。这样实现可以避免使用NodeList对象通常会引起的大</div><div class="t m0 x0 h5 y1d79 ff6f fs2 fc0 sc0 ls8 ws1">多数性能问题。 </div><div class="t m0 x0 he y1d7a ff6f fs2 fc0 sc0 ls8 ws1">只要传给querySelectorAll()方法的CSS选择符有效，该方法都会返回一个NodeList对象，</div><div class="t m0 x0 h5 y1d7b ff6f fs2 fc0 sc0 ls8 ws1">而不管找到多少匹配的元素。如果没有找到匹配的元素，NodeList就是空的。 </div><div class="t m0 x0 h1e y1d7c ff6f fs2 fc0 sc0 ls29f">与querySelector()类似，能够调用querySelectorAll()方法的类型包括Document 、</div><div class="t m0 x0 h5 y833 ff70 fs1 fc0 sc0 ls9 ws2">DocumentFragment和Element。下面是几个例子。 </div><div class="t m0 x0 hb y1d7d ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y1d7e ff70 fs6 fc0 sc0 ls21">//取得某&lt;div&gt;中的所有&lt;em&gt;元素（类似于getElementsByTagName(&quot;em&quot;)） </div><div class="t m0 x0 hb y1d7f ff70 fs6 fc0 sc0 ls21 wsb">var ems = document.getElementById(&quot;myDiv&quot;).querySelectorAll(&quot;em&quot;); </div><div class="t m0 x0 hb y1d80 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y1d81 ff70 fs6 fc0 sc0 ls21">//取得类为&quot;selected&quot;的所有元素 </div><div class="t m0 x0 hb y1d82 ff70 fs6 fc0 sc0 ls21 wsb">var selecteds = document.querySelectorAll(&quot;.selected&quot;); </div><div class="t m0 x0 hb y1d83 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y1d84 ff70 fs6 fc0 sc0 ls21">//取得所有&lt;p&gt;元素中的所有&lt;strong&gt;元素 </div><div class="t m0 x0 hb y1d85 ff70 fs6 fc0 sc0 ls21 wsb">var strongs = document.querySelectorAll(&quot;p strong&quot;); </div><div class="t m0 x0 hb y1d86 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1d87 ff75 fs2 fc0 sc0 ls79 wsb">SelectorsAPIExample02.htm </div><div class="t m0 x0 h5 y18e3 ff6f fs2 fc0 sc0 ls8 ws1">要取得返回的NodeList中的每一个元素，可以使用item()方法，也可以使用方括号语法，比如： </div><div class="t m0 x0 hb y1d88 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1d89 ff70 fs6 fc0 sc0 ls21 wsb">var i, len, strong; </div><div class="t m0 x0 hb y1d8a ff70 fs6 fc0 sc0 ls21 wsb">for (i=0, len=strongs.length; i &lt; len; i++){  </div><div class="t m0 x0 h34 y1d8b ff70 fs6 fc0 sc0 ls21 wsb">    strong = strongs[i];   //或者strongs.item(i) </div><div class="t m0 x0 hb y1d8c ff70 fs6 fc0 sc0 ls21 wsb">    strong.className = &quot;important&quot;; </div><div class="t m0 x0 hb y1d8d ff70 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y1d8e ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 yb19 ff6f fs2 fc0 sc0 ls30 ws2a">同样与querySelector()类似，如果传入了浏览器不支持的选择符或者选择符中有语法错误，</div><div class="t m0 x0 h5 y1d8f ff70 fs1 fc0 sc0 ls9 ws2">querySelectorAll()会抛出错误。 </div></div></div>
<div id="pf132" class="pf w0 h0" data-page-no="132"><div class="pc pc132 w0 h0"><div class="t m0 x0 h2 y1 ff69 fs0 fc0 sc0 ls7 ws0">288  第11章 DOM扩展 </div><div class="t m0 x0 h3 y2 ff69 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h20 y12d ff6d fs3 fc0 sc0 ls248 ws214">11.1.3 matchesSelector()方法 </div><div class="t m0 x0 h5 y12e ff69 fs2 fc0 sc0 ls1b ws263">Selectors API Level 2规范为Element类型新增了一个方法matchesSelector()。这个方法接收</div><div class="t m0 x0 h5 y12f ff6f fs2 fc0 sc0 ls8 ws1">一个参数，即CSS选择符，如果调用元素与该选择符匹配，返回true；否则，返回false。看例子。 </div><div class="t m0 x0 hb y49e ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1476 ff70 fs6 fc0 sc0 ls21 wsb">if (document.body.matchesSelector(&quot;body.page1&quot;)){  </div><div class="t m0 x0 hb y1477 ff70 fs6 fc0 sc0 ls21 wsb">    //true </div><div class="t m0 x0 hb y1478 ff70 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y1d91 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 yd44 ff6f fs2 fc0 sc0 ls30 ws2a">在取得某个元素引用的情况下，使用这个方法能够方便地检测它是否会被querySelector()或</div><div class="t m0 x0 h5 y1d92 ff70 fs1 fc0 sc0 ls9 ws2">querySelectorAll()方法返回。 </div><div class="t m0 x0 h5 y1d93 ff6f fs2 fc0 sc0 ls8 ws1">截至2011年年中，还没有浏览器支持matchesSelector()方法；不过，也有一些实验性的实现。</div><div class="t m0 x0 h5 y1d94 ff69 fs2 fc0 sc0 ls46 ws264">IE 9+通过msMatchesSelector()支持该方法，Firefox 3.6+通过mozMatchesSelector()支持该方法，</div><div class="t m0 x0 h5 y1d95 ff69 fs2 fc0 sc0 ls2f ws265">Safari 5+和Chrome通过webkitMatchesSelector()支持该方法。因此，如果你想使用这个方法，最</div><div class="t m0 x0 h5 y1d96 ff6f fs2 fc0 sc0 ls8 ws1">好是编写一个包装函数。 </div><div class="t m0 x0 hb y1d97 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1d98 ff70 fs6 fc0 sc0 ls21 wsb">function matchesSelector(element, selector){  </div><div class="t m0 x0 hb y1d99 ff70 fs6 fc0 sc0 ls21 wsb">    if (element.matchesSelector){ </div><div class="t m0 x0 hb y1d9a ff70 fs6 fc0 sc0 ls21 wsb">        return element.matchesSelector(selector); </div><div class="t m0 x0 hb y1d9b ff70 fs6 fc0 sc0 ls21 wsb">    } else if (element.msMatchesSelector){ </div><div class="t m0 x0 hb y1d9c ff70 fs6 fc0 sc0 ls21 wsb">        return element.msMatchesSelector(selector); </div><div class="t m0 x0 hb y1d9d ff70 fs6 fc0 sc0 ls21 wsb">    } else if (element.mozMatchesSelector){ </div><div class="t m0 x0 hb y1d9e ff70 fs6 fc0 sc0 ls21 wsb">        return element.mozMatchesSelector(selector); </div><div class="t m0 x0 hb y1d9f ff70 fs6 fc0 sc0 ls21 wsb">    } else if (element.webkitMatchesSelector){ </div><div class="t m0 x0 hb y1da0 ff70 fs6 fc0 sc0 ls21 wsb">        return element.webkitMatchesSelector(selector); </div><div class="t m0 x0 hb y1da1 ff70 fs6 fc0 sc0 ls21 wsb">    } else { </div><div class="t m0 x0 hb y1da2 ff70 fs6 fc0 sc0 ls21 wsb">        throw new Error(&quot;Not supported.&quot;); </div><div class="t m0 x0 hb y1da3 ff70 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y1da4 ff70 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y1da5 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1da6 ff70 fs6 fc0 sc0 ls21 wsb">if (matchesSelector(document.body, &quot;body.page1&quot;)){ </div><div class="t m0 x0 h34 y1da7 ff70 fs6 fc0 sc0 ls21 wsb">    //执行操作 </div><div class="t m0 x0 hb y1da8 ff70 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y1da9 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf ye03 ff75 fs2 fc0 sc0 ls79 wsb">SelectorsAPIExample03.htm </div><div class="t m0 x0 hd y1daa ff6d fs7 fc0 sc0 ls245">11.2 元素遍历 </div><div class="t m0 x0 h5 y1dab ff6f fs2 fc0 sc0 ls42 ws30">对于元素间的空格，IE9及之前版本不会返回文本节点，而其他所有浏览器都会返回文本节点。这样，</div><div class="t m0 x0 h4 y1dac ff6f fs2 fc0 sc0 ls42 ws30">就导致了在使用childNodes和firstChild等属性时的行为不一致。为了弥补这一差异，而同时又保</div><div class="t m0 x0 h5 y1dad ff6f fs2 fc0 sc0 lsee">持DOM规范不变，Element Traversal规范（www.w3.org/TR/ElementTraversal/）新定义了一组属性。 </div><div class="t m0 x0 h5 y1dae ff69 fs2 fc0 sc0 ls5e ws267">Element Traversal API为DOM元素添加了以下5个属性。 </div><div class="t m0 x0 h5 y499 ff6e fs1 fc0 sc0 ls2"> childElementCount：返回子元素（不包括文本节点和注释）的个数。 </div><div class="t m0 x0 h5 y1daf ff6e fs1 fc0 sc0 ls2"> firstElementChild：指向第一个子元素；firstChild的元素版。 </div><div class="t m0 x0 h5 y1a65 ff6e fs1 fc0 sc0 ls2"> lastElementChild：指向最后一个子元素；lastChild的元素版。 </div><div class="t m0 x0 h5 y1db0 ff6e fs1 fc0 sc0 ls2"> previousElementSibling：指向前一个同辈元素；previousSibling的元素版。 </div><div class="t m0 x0 h5 y49d ff6e fs1 fc0 sc0 ls2"> nextElementSibling：指向后一个同辈元素；nextSibling的元素版。 </div><div class="t m0 x0 h5 y1db1 ff6f fs2 fc0 sc0 ls8 ws1">支持的浏览器为DOM元素添加了这些属性，利用这些元素不必担心空白文本节点，从而可以更方</div></div></div>
<div id="pf133" class="pf w0 h0" data-page-no="133"><div class="pc pc133 w0 h0"><div class="t m0 x2 h2 y1db2 ff69 fs0 fc0 sc0 lsc2 wsa0">11.3 HTML5  289 </div><div class="t m0 x0 h3 y2 ff69 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff74 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff74 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff74 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff74 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff74 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff74 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff74 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff74 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff74 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff74 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff74 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ff74 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff74 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff6f fs2 fc0 sc0 ls8 ws1">便地查找DOM元素了。 </div><div class="t m0 x0 h5 y4d ff6f fs2 fc0 sc0 ls8 ws1">下面来看一个例子。过去，要跨浏览器遍历某元素的所有子元素，需要像下面这样写代码。 </div><div class="t m0 x0 hb y2d8 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2d9 ff70 fs6 fc0 sc0 ls21 wsb">var i,  </div><div class="t m0 x0 hb y2da ff70 fs6 fc0 sc0 ls21 wsb">    len, </div><div class="t m0 x0 hb y2db ff70 fs6 fc0 sc0 ls21 wsb">    child = element.firstChild; </div><div class="t m0 x0 hb y2dc ff70 fs6 fc0 sc0 ls21 wsb">while(child != element.lastChild){ </div><div class="t m0 x0 h34 y2dd ff70 fs6 fc0 sc0 ls21 wsb">    if (child.nodeType == 1){   //检查是不是元素 </div><div class="t m0 x0 hb y9e2 ff70 fs6 fc0 sc0 ls21 wsb">       processChild(child); </div><div class="t m0 x0 hb y9e3 ff70 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y9e4 ff70 fs6 fc0 sc0 ls21 wsb">    child = child.nextSibling; </div><div class="t m0 x0 hb y9e5 ff70 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y1db3 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1af ff6f fs2 fc0 sc0 ls8 ws1">而使用Element Traversal新增的元素，代码会更简洁。 </div><div class="t m0 x0 hb y1db4 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1db5 ff70 fs6 fc0 sc0 ls21 wsb">var i,  </div><div class="t m0 x0 hb y1db6 ff70 fs6 fc0 sc0 ls21 wsb">    len, </div><div class="t m0 x0 hb y1db7 ff70 fs6 fc0 sc0 ls21 wsb">    child = element.firstElementChild; </div><div class="t m0 x0 hb y1db8 ff70 fs6 fc0 sc0 ls21 wsb">while(child != element.lastElementChild){ </div><div class="t m0 x0 h34 y1db9 ff70 fs6 fc0 sc0 ls21 wsb">    processChild(child);   //已知其是元素 </div><div class="t m0 x0 hb y1dba ff70 fs6 fc0 sc0 ls21 wsb">    child = child.nextElementSibling; </div><div class="t m0 x0 hb y1dbb ff70 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y1dbc ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1dbd ff6f fs2 fc0 sc0 ls8 ws1">支持Element Traversal规范的浏览器有IE 9+、Firefox 3.5+、Safari 4+、Chrome和Opera 10+。 </div><div class="t m0 x0 hd y1dbe ff6d fs7 fc0 sc0 ls245">11.3 HTML5 </div><div class="t m0 x0 h5 yfee ff6f fs2 fc0 sc0 ls8 ws1">对于传统HTML而言，HTML5是一个叛逆。所有之前的版本对JavaScript 接口的描述都不过三言</div><div class="t m0 x0 h5 yfef ff6f fs2 fc0 sc0 ls8 ws1">两语，主要篇幅都用于定义标记，与JavaScript相关的内容一概交由DOM规范去定义。 </div><div class="t m0 x0 h5 y1dbf ff6f fs2 fc0 sc0 ls3b">而HTML5规范则围绕如何使用新增标记定义了大量JavaScript API。其中一些API与DOM重叠，</div><div class="t m0 x0 h5 y1dc0 ff6f fs2 fc0 sc0 ls8 ws1">定义了浏览器应该支持的DOM扩展。 </div><div class="t m0 x5 h5 y1dc1 ff6a fs2 fc0 sc0 ls8 ws14">因为HTML5涉及的面非常广，本节只讨论与DOM节点相关的内容。HTML5的</div><div class="t m0 x5 h5 y1dc2 ff6a fs2 fc0 sc0 ls8 ws14">其他相关内容将在本书其他章节中穿插介绍。 </div><div class="t m0 x0 h20 y1dc3 ff6d fs3 fc0 sc0 ls248 ws214">11.3.1 与类相关的扩充 </div><div class="t m0 x0 h5 y1dc4 ff69 fs2 fc0 sc0 ls2f ws8a">HTML4在Web开发领域得到广泛采用后导致了一个很大的变化，即class属性用得越来越多，一</div><div class="t m0 x0 h5 y1dc5 ff6f fs2 fc0 sc0 ls8 ws1">方面可以通过它为元素添加样式，另一方面还可以用它表示元素的语义。于是，自然就有很多JavaScript</div><div class="t m0 x0 h5 y1dc6 ff6f fs2 fc0 sc0 ls8 ws1">代码会来操作CSS类，比如动态修改类或者搜索文档中具有给定类或给定的一组类的元素，等等。为了</div><div class="t m0 x0 h14 y1dc7 ff6f fs2 fc0 sc0 ls8 ws1">让开发人员适应并增加对class属性的新认识，HTML5新增了很多API，致力于简化CSS 类的用法。 </div><div class="t m0 x0 hab y1dc8 ff6d fs2 fc0 sc0 ls2e wsb">1. getElementsByClassName()方法 </div><div class="t m0 x0 h5 y1dc9 ff69 fs2 fc0 sc0 ls2f ws8a">HTML5添加的getElementsByClassName()方法是最受人欢迎的一个方法，可以通过document</div><div class="t m0 x0 h5 y1dca ff6f fs2 fc0 sc0 ls8 ws1">对象及所有HTML元素调用该方法。这个方法最早出现在JavaScript库中，是通过既有的DOM 功能实</div><div class="t m0 x0 h5 y1dcb ff6f fs2 fc0 sc0 ls8 ws1">现的，而原生的实现具有极大的性能优势。 </div><div class="t m0 x0 h4 y1dcc ff70 fs1 fc0 sc0 ls9 ws2">getElementsByClassName()方法接收一个参数，即一个包含一或多个类名的字符串，返回带有</div><div class="t m0 x0 hc y1dcd ff6f fs2 fc0 sc0 ls8 ws1">指定类的所有元素的NodeList。传入多个类名时，类名的先后顺序不重要。来看下面的例子。 </div></div></div>
<div id="pf134" class="pf w0 h0" data-page-no="134"><div class="pc pc134 w0 h0"><div class="t m0 x0 h2 y1 ff69 fs0 fc0 sc0 ls7 ws0">290  第11章 DOM扩展 </div><div class="t m0 x0 h3 y2 ff69 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y79 ff70 fs6 fc0 sc0 ls21">//取得所有类中包含&quot;username&quot;和&quot;current&quot;的元素，类名的先后顺序无所谓 </div><div class="t m0 x0 hb y7a ff70 fs6 fc0 sc0 ls21 wsb">var allCurrentUsernames = document.getElementsByClassName(&quot;username current&quot;); </div><div class="t m0 x0 hb y7b ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h36 y7c ff70 fs6 fc0 sc0 ls21">//取得ID为&quot;myDiv&quot;的元素中带有类名&quot;selected&quot;的所有元素 </div><div class="t m0 x0 hb y7d ff70 fs6 fc0 sc0 ls21 wsb">var selected = document.getElementById(&quot;myDiv&quot;).getElementsByClassName(&quot;selected&quot;); </div><div class="t m0 x0 hb y3fc ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1dce ff6f fs2 fc0 sc0 ls221 ws1d9">调用这个方法时，只有位于调用元素子树中的元素才会返回。在document对象上调用</div><div class="t m0 x0 h4 y1dcf ff70 fs1 fc0 sc0 ls9 ws2">getElementsByClassName()始终会返回与类名匹配的所有元素，在元素上调用该方法就只会返回后</div><div class="t m0 x0 h5 y1dd0 ff6f fs2 fc0 sc0 ls8 ws1">代元素中匹配的元素。 </div><div class="t m0 x0 h5 y1dd1 ff6f fs2 fc0 sc0 ls42 ws30">使用这个方法可以更方便地为带有某些类的元素添加事件处理程序，从而不必再局限于使用ID或标</div><div class="t m0 x0 h4b y1dd2 ff6f fs2 fc0 sc0 ls44 ws32">签名。不过别忘了，因为返回的对象是NodeList，所以使用这个方法与使用getElementsByTagName()</div><div class="t m0 x0 h5 y1dd3 ff6f fs2 fc0 sc0 ls8 ws1">以及其他返回NodeList的DOM方法都具有同样的性能问题。 </div><div class="t m0 x0 hc y1dd4 ff6f fs2 fc0 sc0 ls5 ws4">支持getElementsByClassName()方法的浏览器有IE 9+、Firefox 3+、Safari 3.1+、Chrome和</div><div class="t m0 x0 h5 y1dd5 ff69 fs2 fc0 sc0 ls156 wsa5">Opera 9.5+。 </div><div class="t m0 x0 h4e y1dd6 ff6d fs2 fc0 sc0 ls2e wsb">2. classList属性 </div><div class="t m0 x0 h4 y1dd7 ff6f fs2 fc0 sc0 ls8 ws1">在操作类名时，需要通过className属性添加、删除和替换类名。因为className 中是一个字</div><div class="t m0 x0 h5 y1dd8 ff6f fs2 fc0 sc0 ls8 ws1">符串，所以即使只修改字符串一部分，也必须每次都设置整个字符串的值。比如，以下面的HTML代</div><div class="t m0 x0 h5 y1dd9 ff6f fs2 fc0 sc0 ls8">码为例。 </div><div class="t m0 x0 hb y1dda ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1ddb ff70 fs6 fc0 sc0 ls21 wsb">&lt;div class=&quot;bd user disabled&quot;&gt;...&lt;/div&gt; </div><div class="t m0 x0 hb y1ddc ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1ddd ff6f fs2 fc0 sc0 ls8 ws1">这个&lt;div&gt;元素一共有三个类名。要从中删除一个类名，需要把这三个类名拆开，删除不想要的那</div><div class="t m0 x0 h5 y1dde ff6f fs2 fc0 sc0 ls8 ws1">个，然后再把其他类名拼成一个新字符串。请看下面的例子。 </div><div class="t m0 x0 hb y1ddf ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y1de0 ff70 fs6 fc0 sc0 ls21">//删除&quot;user&quot;类 </div><div class="t m0 x0 hb y1de1 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y1de2 ff70 fs6 fc0 sc0 ls21">//首先，取得类名字符串并拆分成数组 </div><div class="t m0 x0 hb y1de3 ff70 fs6 fc0 sc0 ls21 wsb">var classNames = div.className.split(/\s+/); </div><div class="t m0 x0 hb y1de4 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y1de5 ff70 fs6 fc0 sc0 ls21">//找到要删的类名 </div><div class="t m0 x0 hb y1de6 ff70 fs6 fc0 sc0 ls21 wsb">var pos = -1,  </div><div class="t m0 x0 hb y1de7 ff70 fs6 fc0 sc0 ls21 wsb">    i, </div><div class="t m0 x0 hb y1de8 ff70 fs6 fc0 sc0 ls21 wsb">    len; </div><div class="t m0 x0 hb y1de9 ff70 fs6 fc0 sc0 ls21 wsb">for (i=0, len=classNames.length; i &lt; len; i++){ </div><div class="t m0 x0 hb y1dea ff70 fs6 fc0 sc0 ls21 wsb">    if (classNames[i] == &quot;user&quot;){ </div><div class="t m0 x0 hb y1deb ff70 fs6 fc0 sc0 ls21 wsb">        pos = i; </div><div class="t m0 x0 hb y1dec ff70 fs6 fc0 sc0 ls21 wsb">        break; </div><div class="t m0 x0 hb y1ded ff70 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y1dee ff70 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y1def ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y1df0 ff70 fs6 fc0 sc0 ls21">//删除类名 </div><div class="t m0 x0 hb y1df1 ff70 fs6 fc0 sc0 ls21 wsb">classNames.splice(i,1); </div><div class="t m0 x0 hb y1df2 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y1df3 ff70 fs6 fc0 sc0 ls21">//把剩下的类名拼成字符串并重新设置 </div><div class="t m0 x0 hb y1df4 ff70 fs6 fc0 sc0 ls21 wsb">div.className = classNames.join(&quot; &quot;); </div><div class="t m0 x0 hb y1df5 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1df6 ff6f fs2 fc0 sc0 ls8 ws1">为了从&lt;div&gt;元素的class属性中删除&quot;user&quot;，以上这些代码都是必需的。必须得通过类似的算</div><div class="t m0 x0 h4 y1df7 ff6f fs2 fc0 sc0 ls8 ws1">法替换类名并确认元素中是否包含该类名。添加类名可以通过拼接字符串完成，但必须要通过检测确定</div><div class="t m0 x0 h5 y1df8 ff6f fs2 fc0 sc0 ls8 ws1">不会多次添加相同的类名。很多JavaScript库都实现了这个方法，以简化这些操作。 </div><div class="t m0 x0 h5 y1df9 ff69 fs2 fc0 sc0 ls2f ws8a">HTML5新增了一种操作类名的方式，可以让操作更简单也更安全，那就是为所有元素添加</div><div class="t m0 x0 h5 y1dfa ff70 fs1 fc0 sc0 ls9 ws2">classList属性。这个classList属性是新集合类型DOMTokenList的实例。与其他DOM集合类似，</div></div></div>
<div id="pf135" class="pf w0 h0" data-page-no="135"><div class="pc pc135 w0 h0"><div class="t m0 x2 h2 y1db2 ff69 fs0 fc0 sc0 lsc2 wsa0">11.3 HTML5  291 </div><div class="t m0 x0 h3 y2 ff69 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff74 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff74 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff74 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff74 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff74 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff74 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff74 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff74 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff74 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff74 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff74 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ff74 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff74 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h4 y3 ff70 fs1 fc0 sc0 ls9 ws2">DOMTokenList有一个表示自己包含多少元素的length属性，而要取得每个元素可以使用item()方</div><div class="t m0 x0 h5 y4d ff6f fs2 fc0 sc0 ls8 ws1">法，也可以使用方括号语法。此外，这个新类型还定义如下方法。 </div><div class="t m0 x0 h5 y4e ff6e fs1 fc0 sc0 ls2"> add(value)：将给定的字符串值添加到列表中。如果值已经存在，就不添加了。 </div><div class="t m0 x0 h5 yd9 ff6e fs1 fc0 sc0 ls2"> contains(value)：表示列表中是否存在给定的值，如果存在则返回true，否则返回false。 </div><div class="t m0 x0 h5 y219 ff6e fs1 fc0 sc0 ls2"> remove(value)：从列表中删除给定的字符串。 </div><div class="t m0 x0 h5 y8 ff6e fs1 fc0 sc0 ls2"> toggle(value)：如果列表中已经存在给定的值，删除它；如果列表中没有给定的值，添加它。 </div><div class="t m0 x0 h5 y15e ff6f fs2 fc0 sc0 ls8 ws1">这样，前面那么多行代码用下面这一行代码就可以代替了： </div><div class="t m0 x0 hb ycf5 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ycf6 ff70 fs6 fc0 sc0 ls21 wsb">div.classList.remove(&quot;user&quot;); </div><div class="t m0 x0 hb y1dfb ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1dfc ff6f fs2 fc0 sc0 ls24 ws1e">以上代码能够确保其他类名不受此次修改的影响。其他方法也能极大地减少类似基本操作的复杂</div><div class="t m0 x0 h5 y1dfd ff6f fs2 fc0 sc0 ls8 ws1">性，如下面的例子所示。 </div><div class="t m0 x0 hb y1dfe ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y1dff ff70 fs6 fc0 sc0 ls21">//删除&quot;disabled&quot;类 </div><div class="t m0 x0 hb y1e00 ff70 fs6 fc0 sc0 ls21 wsb">div.classList.remove(&quot;disabled&quot;); </div><div class="t m0 x0 hb y1e01 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y1e02 ff70 fs6 fc0 sc0 ls21">//添加&quot;current&quot;类 </div><div class="t m0 x0 hb y1e03 ff70 fs6 fc0 sc0 ls21 wsb">div.classList.add(&quot;current&quot;); </div><div class="t m0 x0 hb y1e04 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y1e05 ff70 fs6 fc0 sc0 ls21">//切换&quot;user&quot;类 </div><div class="t m0 x0 hb y1e06 ff70 fs6 fc0 sc0 ls21 wsb">div.classList.toggle(&quot;user&quot;); </div><div class="t m0 x0 hb y1e07 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y1e08 ff70 fs6 fc0 sc0 ls21">//确定元素中是否包含既定的类名 </div><div class="t m0 x0 hb y1e09 ff70 fs6 fc0 sc0 ls21 wsb">if (div.classList.contains(&quot;bd&quot;) &amp;&amp; !div.classList.contains(&quot;disabled&quot;)){ </div><div class="t m0 x0 h34 y1e0a ff70 fs6 fc0 sc0 ls21 wsb">    //执行操作 </div><div class="t m0 x0 hb y1e0b ff70 fs6 fc0 sc0 ls21 wsb">) </div><div class="t m0 x0 hb y1e0c ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y1e0d ff70 fs6 fc0 sc0 ls21">//迭代类名 </div><div class="t m0 x0 hb y1e0e ff70 fs6 fc0 sc0 ls21 wsb">for (var i=0, len=div.classList.length; i &lt; len; i++){ </div><div class="t m0 x0 hb y1e0f ff70 fs6 fc0 sc0 ls21 wsb">    doSomething(div.classList[i]); </div><div class="t m0 x0 hb y1e10 ff70 fs6 fc0 sc0 ls16f">} </div><div class="t m0 x0 hb y1e11 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1e12 ff6f fs2 fc0 sc0 ls8 ws1">有了classList属性，除非你需要全部删除所有类名，或者完全重写元素的class属性，否则也</div><div class="t m0 x0 h5 y11b ff6f fs2 fc0 sc0 ls8 ws1">就用不到className属性了。 </div><div class="t m0 x0 hc y1e13 ff6f fs2 fc0 sc0 ls8 ws1">支持classList属性的浏览器有Firefox 3.6+和Chrome。 </div><div class="t m0 x0 h20 y1e14 ff6d fs3 fc0 sc0 ls248 ws214">11.3.2 焦点管理 </div><div class="t m0 x0 h5 y8b8 ff69 fs2 fc0 sc0 ls2f ws8a">HTML5也添加了辅助管理DOM焦点的功能。首先就是document.activeElement 属性，这个</div><div class="t m0 x0 h5 y8b9 ff6f fs2 fc0 sc0 ls8 ws1">属性始终会引用DOM中当前获得了焦点的元素。元素获得焦点的方式有页面加载、用户输入（通常是</div><div class="t m0 x0 he y1e15 ff6f fs2 fc0 sc0 ls8 ws1">通过按Tab键）和在代码中调用focus()方法。来看几个例子。 </div><div class="t m0 x0 hb y1e16 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1e17 ff70 fs6 fc0 sc0 ls21 wsb">var button = document.getElementById(&quot;myButton&quot;); </div><div class="t m0 x0 hb y1e18 ff70 fs6 fc0 sc0 ls21 wsb">button.focus(); </div><div class="t m0 x0 hb y1e19 ff70 fs6 fc0 sc0 ls21 wsb">alert(document.activeElement === button);   //true </div><div class="t m0 x0 hb y1e1a ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1e1b ff6f fs2 fc0 sc0 ls8 ws1">默认情况下，文档刚刚加载完成时，document.activeElement中保存的是document.body元</div><div class="t m0 x0 hc y1e1c ff6f fs2 fc0 sc0 ls8 ws1">素的引用。文档加载期间，document.activeElement的值为null。 </div><div class="t m0 x0 hc y1e1d ff6f fs2 fc0 sc0 ls8 ws1">另外就是新增了document.hasFocus()方法，这个方法用于确定文档是否获得了焦点。 </div><div class="t m0 x0 hb y1e1e ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1e1f ff70 fs6 fc0 sc0 ls21 wsb">var button = document.getElementById(&quot;myButton&quot;); </div></div></div>
<div id="pf136" class="pf w0 h0" data-page-no="136"><div class="pc pc136 w0 h0"><div class="t m0 x0 h2 y1 ff69 fs0 fc0 sc0 ls7 ws0">292  第11章 DOM扩展 </div><div class="t m0 x0 h3 y2 ff69 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 ff70 fs6 fc0 sc0 ls21 wsb">button.focus(); </div><div class="t m0 x0 hb y7a ff70 fs6 fc0 sc0 ls21 wsb">alert(document.hasFocus());  //true </div><div class="t m0 x0 hb y1c6a ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1c6b ff6f fs2 fc0 sc0 ls8 ws1">通过检测文档是否获得了焦点，可以知道用户是不是正在与页面交互。 </div><div class="t m0 x0 h4 y1e20 ff6f fs2 fc0 sc0 ls8 ws1">查询文档获知哪个元素获得了焦点，以及确定文档是否获得了焦点，这两个功能最重要的用途是提</div><div class="t m0 x0 h5 y1e21 ff6f fs2 fc0 sc0 lsc9">高Web应用的无障碍性。无障碍Web应用的一个主要标志就是恰当的焦点管理，而确切地知道哪个元</div><div class="t m0 x0 h5 y1e22 ff6f fs2 fc0 sc0 ls8 ws1">素获得了焦点是一个极大的进步，至少我们不用再像过去那样靠猜测了。 </div><div class="t m0 x0 h5 y1e23 ff6f fs2 fc0 sc0 ls8 ws1">实现了这两个属性的浏览器的包括IE 4+、Firefox 3+、Safari 4+、Chrome和Opera 8+。 </div><div class="t m0 x0 h20 y1e24 ff6d fs3 fc0 sc0 ls248 ws214">11.3.3 HTMLDocument的变化 </div><div class="t m0 x0 h5 y1e25 ff69 fs2 fc0 sc0 ls2f ws8a">HTML5扩展了HTMLDocument，增加了新的功能。与HTML5中新增的其他DOM扩展类似，这些</div><div class="t m0 x0 h4 y1e26 ff6f fs2 fc0 sc0 ls8 ws1">变化同样基于那些已经得到很多浏览器完美支持的专有扩展。所以，尽管这些扩展被写入标准的时间相</div><div class="t m0 x0 h5 y1e27 ff6f fs2 fc0 sc0 ls8 ws1">对不长，但很多浏览器很早就已经支持这些功能了。 </div><div class="t m0 x0 hac y1e28 ff6d fs2 fc0 sc0 ls2e wsb">1. readyState属性 </div><div class="t m0 x0 h5 y1e29 ff69 fs2 fc0 sc0 ls2a ws21">IE4最早为document对象引入了readyState属性。然后，其他浏览器也都陆续 添加这个属性，</div><div class="t m0 x0 hc y1e2a ff6f fs2 fc0 sc0 ls8 ws1">最终HTML5把这个属性纳入了标准当中。Document的readyState属性有两个可能的值： </div><div class="t m0 x0 h5 y1e2b ff6e fs1 fc0 sc0 ls2"> loading，正在加载文档； </div><div class="t m0 x0 h5 y1807 ff6e fs1 fc0 sc0 ls2"> complete，已经加载完文档。 </div><div class="t m0 x0 h1e y4d4 ff6f fs2 fc0 sc0 ls8 ws1">使用document.readyState的最恰当方式，就是通过它来实现一个指示文档已经加载完成的指</div><div class="t m0 x0 h1e y1e2c ff6f fs2 fc0 sc0 ls8 ws1">示器。在这个属性得到广泛支持之前，要实现这样一个指示器，必须借助onload事件处理程序设置一</div><div class="t m0 x0 h5 y1e2d ff6f fs2 fc0 sc0 ls8 ws1">个标签，表明文档已经加载完毕。document.readyState属性的基本用法如下。 </div><div class="t m0 x0 hb y1e2e ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1e2f ff70 fs6 fc0 sc0 ls21 wsb">if (document.readyState == &quot;complete&quot;){  </div><div class="t m0 x0 h34 y1e30 ff70 fs6 fc0 sc0 ls21 wsb">    //执行操作 </div><div class="t m0 x0 hb y1e31 ff70 fs6 fc0 sc0 ls16f">} </div><div class="t m0 x0 hb y1e32 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1a93 ff6f fs2 fc0 sc0 ls8 ws1">支持readyState属性的浏览器有IE4+、Firefox 3.6+、Safari、Chrome和Opera 9+。 </div><div class="t m0 x0 h3c y1e33 ff6d fs2 fc0 sc0 ls2e wsb">2. 兼容模式 </div><div class="t m0 x0 h5 y1e34 ff6f fs2 fc0 sc0 ls8 ws1">自从IE6开始区分渲染页面的模式是标准的还是混杂的，检测页面的兼容模式就成为浏览器的必要</div><div class="t m0 x0 h5 y1e35 ff6f fs2 fc0 sc0 ls8">功能。IE为此给document添加了一个名为compatMode 的属性，这个属性就是为了告诉开发人员浏</div><div class="t m0 x0 h1e y1e36 ff6f fs2 fc0 sc0 ls8 ws1">览器采用了哪种渲染模式。就像下面例子中所展示的那样，在标准模式下，document.compatMode的</div><div class="t m0 x0 h5 y1e37 ff6f fs2 fc0 sc0 ls8 ws1">值等于&quot;CSS1Compat&quot;，而在混杂模式下，document.compatMode的值等于&quot;BackCompat&quot;。 </div><div class="t m0 x0 hb y18bc ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1e38 ff70 fs6 fc0 sc0 ls21 wsb">if (document.compatMode == &quot;CSS1Compat&quot;){ </div><div class="t m0 x0 hb y1e39 ff70 fs6 fc0 sc0 ls21 wsb">    alert(&quot;Standards mode&quot;); </div><div class="t m0 x0 hb y1e3a ff70 fs6 fc0 sc0 ls21 wsb">} else { </div><div class="t m0 x0 hb y1e3b ff70 fs6 fc0 sc0 ls21 wsb">    alert(&quot;Quirks mode&quot;); </div><div class="t m0 x0 hb y1e3c ff70 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y1e3d ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y144a ff6f fs2 fc0 sc0 ls8 ws1">后来，陆续实现这个属性的浏览器有Firefox、Safari 3.1+、Opera和Chrome。最终，HTML5也把</div><div class="t m0 x0 h5 y1e3e ff6f fs2 fc0 sc0 ls8 ws1">这个属性纳入标准，对其实现做出了明确规定。 </div><div class="t m0 x0 h4e y1e3f ff6d fs2 fc0 sc0 ls2e wsb">3. head属性 </div><div class="t m0 x0 had y1e40 ff6f fs2 fc0 sc0 ls8 ws1">作为对document.body引用文档的&lt;body&gt;元素的补充，HTML5新增了document.head属性，</div><div class="t m0 x0 hc y1e41 ff6f fs2 fc0 sc0 ls8 ws1">引用文档的&lt;head&gt;元素。要引用文档的&lt;head&gt;元素，可以结合使用这个属性和另一种后备方法。 </div><div class="t m0 x0 hb y1e42 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1e43 ff70 fs6 fc0 sc0 ls21 wsb">var head = document.head || document.getElementsByTagName(&quot;head&quot;)[0]; </div></div></div>
<div id="pf137" class="pf w0 h0" data-page-no="137"><div class="pc pc137 w0 h0"><div class="t m0 x2 h2 y1db2 ff69 fs0 fc0 sc0 lsc2 wsa0">11.3 HTML5  293 </div><div class="t m0 x0 h3 y2 ff69 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff74 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff74 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff74 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff74 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff74 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff74 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff74 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff74 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff74 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff74 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff74 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ff74 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff74 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff6f fs2 fc0 sc0 ls8 ws1">如果可用，就使用document.head，否则仍然使用getElementsByTagName()方法。 </div><div class="t m0 x0 hc y4d ff6f fs2 fc0 sc0 ls8 ws1">实现document.head属性的浏览器包括Chrome和Safari 5。 </div><div class="t m0 x0 h20 y1f2 ff6d fs3 fc0 sc0 ls248 ws214">11.3.4 字符集属性 </div><div class="t m0 x0 h5 y1f3 ff69 fs2 fc0 sc0 ls2f ws8a">HTML5新增了几个与文档字符集有关的属性。其中，charset属性表示文档中实际使用的字符集，</div><div class="t m0 x0 h4 y1f4 ff6f fs2 fc0 sc0 ls8 ws1">也可以用来指定新字符集。默认情况下，这个属性的值为&quot;UTF-16&quot;，但可以通过&lt;meta&gt;元素、响应头</div><div class="t m0 x0 hc y1f5 ff6f fs2 fc0 sc0 ls8 ws1">部或直接设置charset属性修改这个值。来看一个例子。 </div><div class="t m0 x0 hb yc80 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1e44 ff70 fs6 fc0 sc0 ls21 wsb">alert(document.charset); //&quot;UTF-16&quot; </div><div class="t m0 x0 hb y1e45 ff70 fs6 fc0 sc0 ls21 wsb">document.charset = &quot;UTF-8&quot;; </div><div class="t m0 x0 hb y1e46 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1e47 ff6f fs2 fc0 sc0 ls8 ws1">另一个属性是defaultCharset，表示根据默认浏览器及操作系统的设置，当前文档默认的字符集</div><div class="t m0 x0 h1e y1e48 ff6f fs2 fc0 sc0 ls8 ws1">应该是什么。如果文档没有使用默认的字符集，那charset和defaultCharset属性的值可能会不一</div><div class="t m0 x0 h5 y1e49 ff6f fs2 fc0 sc0 ls8 ws1">样，例如： </div><div class="t m0 x0 hb y1e4a ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1e4b ff70 fs6 fc0 sc0 ls21 wsb">if (document.charset != document.defaultCharset){  </div><div class="t m0 x0 hb y1e4c ff70 fs6 fc0 sc0 ls21 wsb">    alert(&quot;Custom character set being used.&quot;); </div><div class="t m0 x0 hb y1e4d ff70 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y1e4e ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1e4f ff6f fs2 fc0 sc0 ls8 ws1">通过这两个属性可以得到文档使用的字符编码的具体信息，也能对字符编码进行准确地控制。运行</div><div class="t m0 x0 h5 y1b7e ff6f fs2 fc0 sc0 ls8 ws1">适当的情况下，可以保证用户正常查看页面或使用应用。 </div><div class="t m0 x0 hc y1e50 ff6f fs2 fc0 sc0 ls28b ws273">支持document.charset属性的浏览器有 IE、Firefox、Safari、Opera和Chrome。支持</div><div class="t m0 x0 h5 y1b7f ff70 fs1 fc0 sc0 ls9 ws2">document.defaultCharset属性的浏览器有IE、Safari和Chrome。 </div><div class="t m0 x0 h20 y1e51 ff6d fs3 fc0 sc0 ls248 ws214">11.3.5 自定义数据属性 </div><div class="t m0 x0 h5 y1e52 ff69 fs2 fc0 sc0 ls2ae ws274">HTML5规定可以为元素添加非标准的属性，但要添加前缀data-，目的是为元素提供与渲染无关的</div><div class="t m0 x0 h5 y1e53 ff6f fs2 fc0 sc0 ls42 ws30">信息，或者提供语义信息。这些属性可以任意添加、随便命名，只要以data-开头即可。来看一个例子。 </div><div class="t m0 x0 hb y1e54 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1e55 ff70 fs6 fc0 sc0 ls21 wsb">&lt;div id=&quot;myDiv&quot; data-appId=&quot;12345&quot; data-myname=&quot;Nicholas&quot;&gt;&lt;/div&gt; </div><div class="t m0 x0 hb y1e56 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1695 ff6f fs2 fc0 sc0 ls8 ws1">添加了自定义属性之后，可以通过元素的dataset属性来访问自定义属性的值。dataset属性的</div><div class="t m0 x0 h1e y1e57 ff6f fs2 fc0 sc0 ls8 ws1">值是DOMStringMap的一个实例，也就是一个名值对儿的映射。在这个映射中，每个data-name形式</div><div class="t m0 x0 h4 y1e58 ff6f fs2 fc0 sc0 ls8 ws1">的属性都会有一个对应的属性，只不过属性名没有data-前缀（比如，自定义属性是data-myname，</div><div class="t m0 x0 hc y1e59 ff6f fs2 fc0 sc0 ls8 ws1">那映射中对应的属性就是myname）。还是看一个例子吧。 </div><div class="t m0 x0 hb y1e5a ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y1e5b ff70 fs6 fc0 sc0 ls21">//本例中使用的方法仅用于演示 </div><div class="t m0 x0 hb y1e5c ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1e5d ff70 fs6 fc0 sc0 ls21 wsb">var div = document.getElementById(&quot;myDiv&quot;); </div><div class="t m0 x0 hb y1e5e ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y1e5f ff70 fs6 fc0 sc0 ls21">//取得自定义属性的值 </div><div class="t m0 x0 hb y1e60 ff70 fs6 fc0 sc0 ls21 wsb">var appId = div.dataset.appId; </div><div class="t m0 x0 hb y1e61 ff70 fs6 fc0 sc0 ls21 wsb">var myName = div.dataset.myname; </div><div class="t m0 x0 hb y1e62 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y1e63 ff70 fs6 fc0 sc0 ls21">//设置值 </div><div class="t m0 x0 hb y1e64 ff70 fs6 fc0 sc0 ls21 wsb">div.dataset.appId = 23456; </div><div class="t m0 x0 hb y1e65 ff70 fs6 fc0 sc0 ls21 wsb">div.dataset.myname = &quot;Michael&quot;; </div><div class="t m0 x0 hb y1e66 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y1e67 ff70 fs6 fc0 sc0 ls21">//有没有&quot;myname&quot;值呢？ </div><div class="t m0 x0 hb y1e68 ff70 fs6 fc0 sc0 ls21 wsb">if (div.dataset.myname){ </div></div></div>
<div id="pf138" class="pf w0 h0" data-page-no="138"><div class="pc pc138 w0 h0"><div class="t m0 x0 h2 y1 ff69 fs0 fc0 sc0 ls7 ws0">294  第11章 DOM扩展 </div><div class="t m0 x0 h3 y2 ff69 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 ff70 fs6 fc0 sc0 ls21 wsb">    alert(&quot;Hello, &quot; + div.dataset.myname); </div><div class="t m0 x0 hb y7a ff70 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y1c6a ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1c6b ff6f fs2 fc0 sc0 ls8 ws1">如果需要给元素添加一些不可见的数据以便进行其他处理，那就要用到自定义数据属性。在跟踪链</div><div class="t m0 x0 h5 y1e20 ff6f fs2 fc0 sc0 ls8 ws1">接或混搭应用中，通过自定义数据属性能方便地知道点击来自页面中的哪个部分。 </div><div class="t m0 x0 h5 y1e21 ff6f fs2 fc0 sc0 ls8 ws1">在编写本书时，支持自定义数据属性的浏览器有Firefox 6+和Chrome。 </div><div class="t m0 x0 h20 y1e69 ff6d fs3 fc0 sc0 ls248 ws214">11.3.6 插入标记 </div><div class="t m0 x0 h5 y1e6a ff6f fs2 fc0 sc0 ls8 ws1">虽然DOM为操作节点提供了细致入微的控制手段，但在需要给文档插入大量新HTML标记的情况</div><div class="t m0 x0 h5 y1e6b ff6f fs2 fc0 sc0 ls8 ws1">下，通过DOM操作仍然非常麻烦，因为不仅要创建一系列DOM节点，而且还要小心地按照正确的顺</div><div class="t m0 x0 h5 y1e6c ff6f fs2 fc0 sc0 ls8 ws1">序把它们连接起来。相对而言，使用插入标记的技术，直接插入HTML字符串不仅更简单，速度也更</div><div class="t m0 x0 h5 y1e6d ff6f fs2 fc0 sc0 ls8 ws1">快。以下与插入标记相关的DOM扩展已经纳入了HTML5规范。 </div><div class="t m0 x0 hac y1e6e ff6d fs2 fc0 sc0 ls2e wsb">1. innerHTML属性 </div><div class="t m0 x0 h4 y1e6f ff6f fs2 fc0 sc0 ls6 ws6">在读模式下，innerHTML属性返回与调用元素的所有子节点（包括元素、注释和文本节点）对应</div><div class="t m0 x0 hc y1e70 ff6f fs2 fc0 sc0 ls3b">的HTML标记。在写模式下，innerHTML会根据指定的值创建新的DOM树，然后用这个DOM树完全</div><div class="t m0 x0 h5 y1e2a ff6f fs2 fc0 sc0 ls8 ws1">替换调用元素原先的所有子节点。下面是一个例子。 </div><div class="t m0 x0 hb y1e71 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1e72 ff70 fs6 fc0 sc0 ls21 wsb">&lt;div id=&quot;content&quot;&gt;  </div><div class="t m0 x0 hb y1e73 ff70 fs6 fc0 sc0 ls21 wsb">    &lt;p&gt;This is a &lt;strong&gt;paragraph&lt;/strong&gt; with a list following it.&lt;/p&gt; </div><div class="t m0 x0 hb y1e74 ff70 fs6 fc0 sc0 ls21 wsb">    &lt;ul&gt; </div><div class="t m0 x0 hb y1e75 ff70 fs6 fc0 sc0 ls21 wsb">        &lt;li&gt;Item 1&lt;/li&gt; </div><div class="t m0 x0 hb y1e76 ff70 fs6 fc0 sc0 ls21 wsb">        &lt;li&gt;Item 2&lt;/li&gt; </div><div class="t m0 x0 hb y1e77 ff70 fs6 fc0 sc0 ls21 wsb">        &lt;li&gt;Item 3&lt;/li&gt; </div><div class="t m0 x0 hb y1e78 ff70 fs6 fc0 sc0 ls21 wsb">    &lt;/ul&gt; </div><div class="t m0 x0 hb y1e79 ff70 fs6 fc0 sc0 ls21 wsb">&lt;/div&gt; </div><div class="t m0 x0 hb y1e7a ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y368 ff6f fs2 fc0 sc0 ls8 ws1">对于上面的&lt;div&gt;元素来说，它的innerHTML属性会返回如下字符串。 </div><div class="t m0 x0 hb y1e7b ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1e7c ff70 fs6 fc0 sc0 ls21 wsb">&lt;p&gt;This is a &lt;strong&gt;paragraph&lt;/strong&gt; with a list following it.&lt;/p&gt;  </div><div class="t m0 x0 hb y1e7d ff70 fs6 fc0 sc0 ls21 wsb">&lt;ul&gt; </div><div class="t m0 x0 hb y1e7e ff70 fs6 fc0 sc0 ls21 wsb">    &lt;li&gt;Item 1&lt;/li&gt; </div><div class="t m0 x0 hb y1e7f ff70 fs6 fc0 sc0 ls21 wsb">    &lt;li&gt;Item 2&lt;/li&gt; </div><div class="t m0 x0 hb y1e80 ff70 fs6 fc0 sc0 ls21 wsb">    &lt;li&gt;Item 3&lt;/li&gt; </div><div class="t m0 x0 hb y1e81 ff70 fs6 fc0 sc0 ls21 wsb">&lt;/ul&gt; </div><div class="t m0 x0 hb y1e82 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1e83 ff6f fs2 fc0 sc0 ls8 ws1">但是，不同浏览器返回的文本格式会有所不同。IE和Opera会将所有标签转换为大写形式，而Safari、</div><div class="t m0 x0 h5 y1e84 ff69 fs2 fc0 sc0 ls50 ws41">Chrome和Firefox则会原原本本地按照原先文档中（或指定这些标签时）的格式返回HTML，包括空格</div><div class="t m0 x0 he y1e85 ff6f fs2 fc0 sc0 ls8 ws1">和缩进。不要指望所有浏览器返回的innerHTML值完全相同。 </div><div class="t m0 x0 hc y1e86 ff6f fs2 fc0 sc0 ls8 ws1">在写模式下，innerHTML的值会被解析为DOM子树，替换调用元素原来的所有子节点。因为它的</div><div class="t m0 x0 h5 y1e87 ff6f fs2 fc0 sc0 ls8 ws1">值被认为是HTML，所以其中的所有标签都会按照浏览器处理HTML的标准方式转换为元素（同样，</div><div class="t m0 x0 h5 y1e88 ff6f fs2 fc0 sc0 ls8 ws1">这里的转换结果也因浏览器而异）。如果设置的值仅是文本而没有HTML标签，那么结果就是设置纯文</div><div class="t m0 x0 h5 y1e89 ff6f fs2 fc0 sc0 ls8 ws1">本，如下所示。 </div><div class="t m0 x0 hb y1e8a ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1e8b ff70 fs6 fc0 sc0 ls21 wsb">div.innerHTML = &quot;Hello world!&quot;; </div><div class="t m0 x0 hb y1e8c ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 yfd6 ff6f fs2 fc0 sc0 lsb4">为innerHTML设置的包含HTML的字符串值与解析后innerHTML 的值大不相同。来看下面的</div><div class="t m0 x0 h5 y1e8d ff6f fs2 fc0 sc0 ls24 ws1e">例子。 </div><div class="t m0 x0 hb y1e8e ff70 fs6 fc0 sc0 ls21 wsb">div.innerHTML = &quot;Hello &amp; welcome, &lt;b&gt;\&quot;reader\&quot;!&lt;/b&gt;&quot;; </div><div class="t m0 x0 hb y1e8f ff70 fs6 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf139" class="pf w0 h0" data-page-no="139"><div class="pc pc139 w0 h0"><div class="t m0 x2 h2 y1db2 ff69 fs0 fc0 sc0 lsc2 wsa0">11.3 HTML5  295 </div><div class="t m0 x0 h3 y2 ff69 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff74 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff74 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff74 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff74 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff74 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff74 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff74 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff74 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff74 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff74 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff74 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ff74 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff74 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff6f fs2 fc0 sc0 ls8 ws1">以上操作得到的结果如下： </div><div class="t m0 x0 hb yfb2 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yfb3 ff70 fs6 fc0 sc0 ls21 wsb">&lt;div id=&quot;content&quot;&gt;Hello &amp;amp; welcome, &lt;b&gt;&amp;quot;reader&amp;quot;!&lt;/b&gt;&lt;/div&gt; </div><div class="t m0 x0 hb y1510 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1511 ff6f fs2 fc0 sc0 ls8 ws1">设置了innerHTML之后，可以像访问文档中的其他节点一样访问新创建的节点。 </div><div class="t m0 x5 hae y1e90 ff6a fs2 fc0 sc0 ls2b1">为innerHTML设置HTML字符串后，浏览器会将这个字符串解析为相应的DOM</div><div class="t m0 x5 haf y1e91 ff6a fs2 fc0 sc0 ls8 ws14">树。因此设置了innerHTML之后，再从中读取HTML字符串，会得到与设置时不一</div><div class="t m0 x5 h5 y1e92 ff6a fs2 fc0 sc0 ls8 ws14">样的结果。原因在于返回的字符串是根据原始HTML字符串创建的DOM树经过序列</div><div class="t m0 x5 h5 y1e93 ff6a fs2 fc0 sc0 ls8 ws14">化之后的结果。 </div><div class="t m0 x0 hb0 y1e94 ff6f fs2 fc0 sc0 ls8 ws1">使用innerHTML属性也有一些限制。比如，在大多数浏览器中，通过innerHTML插入&lt;script&gt;</div><div class="t m0 x0 h5 yd ff6f fs2 fc0 sc0 ls8 ws1">元素并不会执行其中的脚本。IE8及更早版本是唯一能在这种情况下执行脚本的浏览器，但必须满足一</div><div class="t m0 x0 h1e ye ff6f fs2 fc0 sc0 ls8 ws1">些条件。一是必须为&lt;script&gt;元素指定defer属性，二是&lt;script&gt;元素必须位于（微软所谓的）“有</div><div class="t m0 x0 hc y1e95 ff6f fs2 fc0 sc0 ls8 ws1">作用域的元素”（scoped element）之后。&lt;script&gt;元素被认为是“无作用域的元素”（NoScope element），</div><div class="t m0 x0 h4 y10 ff6f fs2 fc0 sc0 ls8 ws1">也就是在页面中看不到的元素，与&lt;style&gt;元素或注释类似。如果通过innerHTML插入的字符串开头</div><div class="t m0 x0 h5 y1e96 ff6f fs2 fc0 sc0 ls8 ws1">就是一个“无作用域的元素”，那么IE会在解析这个字符串前先删除该元素。换句话说，以下代码达不</div><div class="t m0 x0 h5 y1e97 ff6f fs2 fc0 sc0 ls8">到目的： </div><div class="t m0 x0 hb ya48 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y1e98 ff70 fs6 fc0 sc0 ls21 wsb">div.innerHTML = &quot;&lt;script defer&gt;alert(&apos;hi&apos;);&lt;\/script&gt;&quot;; //无效 </div><div class="t m0 x0 hb y1e99 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1e9a ff6f fs2 fc0 sc0 ls8 ws1">此时，innerHTML字符串一开始（而且整个）就是一个“无作用域的元素”，所以这个字符串会变</div><div class="t m0 x0 h4 y1e9b ff6f fs2 fc0 sc0 ls6 ws6">成空字符串。如果想插入这段脚本，必须在前面添加一个“有作用域的元素”，可以是一个文本节点，</div><div class="t m0 x0 he y1e9c ff6f fs2 fc0 sc0 ls8 ws1">也可以是一个没有结束标签的元素如&lt;input&gt;。例如，下面这几行代码都可以正常执行： </div><div class="t m0 x0 hb y10bd ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1e9d ff70 fs6 fc0 sc0 ls21 wsb">div.innerHTML = &quot;_&lt;script defer&gt;alert(&apos;hi&apos;);&lt;\/script&gt;&quot;; </div><div class="t m0 x0 hb y1e9e ff70 fs6 fc0 sc0 ls21 wsb">div.innerHTML = &quot;&lt;div&gt;&amp;nbsp;&lt;/div&gt;&lt;script defer&gt;alert(&apos;hi&apos;);&lt;\/script&gt;&quot;; </div><div class="t m0 x0 hb y1e9f ff70 fs6 fc0 sc0 ls21 wsb">div.innerHTML = &quot;&lt;input type=\&quot;hidden\&quot;&gt;&lt;script defer&gt;alert(&apos;hi&apos;);&lt;\/script&gt;&quot;; </div><div class="t m0 x0 hb y1ea0 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1ea1 ff6f fs2 fc0 sc0 ls6 ws6">第一行代码会在&lt;script&gt;元素前插入一个文本节点。事后，为了不影响页面显示，你可能需要移</div><div class="t m0 x0 h4 y1551 ff6f fs2 fc0 sc0 ls8 ws1">除这个文本节点。第二行代码采用的方法类似，只不过使用的是一个包含非换行空格的&lt;div&gt;元素。如</div><div class="t m0 x0 h1e y1ea2 ff6f fs2 fc0 sc0 ls8 ws1">果仅仅插入一个空的&lt;div&gt;元素，还是不行；必须要包含一点儿内容，浏览器才会创建文本节点。同样，</div><div class="t m0 x0 h1e y1ea3 ff6f fs2 fc0 sc0 ls8 ws1">为了不影响页面布局，恐怕还得移除这个节点。第三行代码使用的是一个隐藏的&lt;input&gt;域，也能达到</div><div class="t m0 x0 hc y1ea4 ff6f fs2 fc0 sc0 ls8 ws1">相同的效果。不过，由于隐藏的&lt;input&gt;域不影响页面布局，因此这种方式在大多数情况下都是首选。 </div><div class="t m0 x0 hc y1ea5 ff6f fs2 fc0 sc0 ls8 ws1">大多数浏览器都支持以直观的方式通过innerHTML插入&lt;style&gt;元素，例如： </div><div class="t m0 x0 hb y1ea6 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1ea7 ff70 fs6 fc0 sc0 ls21 wsb">div.innerHTML = &quot;&lt;style type=\&quot;text/css\&quot;&gt;body {background-color: red; }&lt;/style&gt;&quot;; </div><div class="t m0 x0 hb y1ea8 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y511 ff6f fs2 fc0 sc0 ls8 ws1">但在IE8及更早版本中，&lt;style&gt;也是一个“没有作用域的元素”，因此必须像下面这样给它前置</div><div class="t m0 x0 h5 y512 ff6f fs2 fc0 sc0 ls8 ws1">一个“有作用域的元素”： </div><div class="t m0 x0 hb y13f1 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y13f2 ff70 fs6 fc0 sc0 ls21 wsb">div.innerHTML = &quot;_&lt;style type=\&quot;text/css\&quot;&gt;body {background-color: red; }&lt;/style&gt;&quot;; </div><div class="t m0 x0 hb y1ea9 ff70 fs6 fc0 sc0 ls21 wsb">div.removeChild(div.firstChild); </div><div class="t m0 x0 hb y1eaa ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1eab ff6f fs2 fc0 sc0 ls8 ws1">并不是所有元素都支持innerHTML属性。不支持innerHTML的元素有：&lt;col&gt;、&lt;colgroup&gt;、</div><div class="t m0 x0 h4 y1eac ff70 fs1 fc0 sc0 ls9 ws2">&lt;frameset&gt;、&lt;head&gt;、&lt;html&gt;、&lt;style&gt;、&lt;table&gt;、&lt;tbody&gt;、&lt;thead&gt;、&lt;tfoot&gt;和&lt;tr&gt;。此</div><div class="t m0 x0 h5 y1ead ff6f fs2 fc0 sc0 ls8 ws1">外，在IE8及更早版本中，&lt;title&gt;元素也没有innerHTML属性。 </div><div class="t m0 x0 hb y1eae ff70 fs6 fc0 sc0 ls8 wsb">  </div></div></div>
<div id="pf13a" class="pf w0 h0" data-page-no="13a"><div class="pc pc13a w0 h0"><div class="t m0 x0 h2 y1 ff69 fs0 fc0 sc0 ls7 ws0">296  第11章 DOM扩展 </div><div class="t m0 x0 h3 y2 ff69 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1eb0 ff69 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x5 h5 y1eb1 ff69 fs2 fc0 sc0 ls47 ws38">Firefox对在内容类型为application/xhtml+xml的XHTML文档中设置innerHTML</div><div class="t m0 x0 h5 y6bd ff6a fs2 fc0 sc0 ls8 ws14">有严格的限制。在XHTML文档中使用innerHTML 时，XHTML代码必须完全符合</div><div class="t m0 x0 h18 y1eb2 ff6a fs2 fc0 sc0 ls8 ws14">要求。如果代码格式不正确，设置innerHTML将会静默地失败。 </div><div class="t m0 x0 h54 y1eb3 ff6f fs2 fc0 sc0 ls8 ws1">无论什么时候，只要使用innerHTML从外部插入HTML，都应该首先以可靠的方式处理HTML。</div><div class="t m0 x0 hc y1eb4 ff69 fs2 fc0 sc0 ls2a ws21">IE8为此提供了window.toStaticHTML()方法，这个方法接收一个参数，即一个HTML字符串；返回</div><div class="t m0 x0 h5 y1eb5 ff6f fs2 fc0 sc0 ls8 ws1">一个经过无害处理后的版本——从源HTML中删除所有脚本节点和事件处理程序属性。下面就是一个</div><div class="t m0 x0 h5 y1eb6 ff6f fs2 fc0 sc0 ls8">例子： </div><div class="t m0 x0 hb y999 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1eb7 ff70 fs6 fc0 sc0 ls21 wsb">var text = &quot;&lt;a href=\&quot;#\&quot; onclick=\&quot;alert(&apos;hi&apos;)\&quot;&gt;Click Me&lt;/a&gt;&quot;; </div><div class="t m0 x0 hb y1eb8 ff70 fs6 fc0 sc0 ls21 wsb">var sanitized = window.toStaticHTML(text);       //Internet Explorer 8 only </div><div class="t m0 x0 hb y1eb9 ff70 fs6 fc0 sc0 ls21 wsb">alert(sanitized);   //&quot;&lt;a href=\&quot;#\&quot;&gt;Click Me&lt;/a&gt;&quot; </div><div class="t m0 x0 hb y1eba ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1ebb ff6f fs2 fc0 sc0 ls57 wsa9">这个例子将一个HTML链接字符串传给了 toStaticHTML()方法，得到的无害版本中去掉了</div><div class="t m0 x0 h5 y139f ff70 fs1 fc0 sc0 ls9 ws2">onclick属性。虽然目前只有IE8原生支持这个方法，但我们还是建议读者在通过innerHTML插入代</div><div class="t m0 x0 h5 y316 ff6f fs2 fc0 sc0 ls8 ws1">码之前，尽可能先手工检查一下其中的文本内容。 </div><div class="t m0 x0 h4e y1ebc ff6d fs2 fc0 sc0 ls2e wsb">2. outerHTML属性 </div><div class="t m0 x0 had y1ebd ff6f fs2 fc0 sc0 ls8 ws1">在读模式下，outerHTML返回调用它的元素及所有子节点的HTML标签。在写模式下，outerHTML</div><div class="t m0 x0 h5 y1ebe ff6f fs2 fc0 sc0 ls8 ws1">会根据指定的HTML字符串创建新的DOM子树，然后用这个DOM 子树完全替换调用元素。下面是一</div><div class="t m0 x0 h5 y1ebf ff6f fs2 fc0 sc0 ls8">个例子。 </div><div class="t m0 x0 hb y1ddf ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1ec0 ff70 fs6 fc0 sc0 ls21 wsb">&lt;div id=&quot;content&quot;&gt; </div><div class="t m0 x0 hb y1ec1 ff70 fs6 fc0 sc0 ls21 wsb">    &lt;p&gt;This is a &lt;strong&gt;paragraph&lt;/strong&gt; with a list following it.&lt;/p&gt; </div><div class="t m0 x0 hb y1ec2 ff70 fs6 fc0 sc0 ls21 wsb">    &lt;ul&gt; </div><div class="t m0 x0 hb y1ec3 ff70 fs6 fc0 sc0 ls21 wsb">        &lt;li&gt;Item 1&lt;/li&gt; </div><div class="t m0 x0 hb y1ec4 ff70 fs6 fc0 sc0 ls21 wsb">        &lt;li&gt;Item 2&lt;/li&gt; </div><div class="t m0 x0 hb y1ec5 ff70 fs6 fc0 sc0 ls21 wsb">        &lt;li&gt;Item 3&lt;/li&gt; </div><div class="t m0 x0 hb y1ec6 ff70 fs6 fc0 sc0 ls21 wsb">    &lt;/ul&gt; </div><div class="t m0 x0 hb y1ec7 ff70 fs6 fc0 sc0 ls21 wsb">&lt;/div&gt; </div><div class="t m0 x0 hb y1ec8 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y96 ff75 fs2 fc0 sc0 ls7a wsb">OuterHTMLExample01.htm </div><div class="t m0 x0 h4 y1ec9 ff6f fs2 fc0 sc0 ls8 ws1">如果在&lt;div&gt;元素上调用outerHTML，会返回与上面相同的代码，包括&lt;div&gt;本身。不过，由于浏</div><div class="t m0 x0 h5 y1c87 ff6f fs2 fc0 sc0 ls8 ws1">览器解析和解释HTML标记的不同，结果也可能会有所不同。（这里的不同与使用innerHTML属性时</div><div class="t m0 x0 h5 y1eca ff6f fs2 fc0 sc0 ls8 ws1">存在的差异性质是一样的。） </div><div class="t m0 x0 he y1ecb ff6f fs2 fc0 sc0 ls8 ws1">使用outerHTML属性以下面这种方式设置值： </div><div class="t m0 x0 hb y1ecc ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1ecd ff70 fs6 fc0 sc0 ls21 wsb">div.outerHTML = &quot;&lt;p&gt;This is a paragraph.&lt;/p&gt;&quot;; </div><div class="t m0 x0 hb y1ece ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1ecf ff6f fs2 fc0 sc0 ls8 ws1">这行代码完成的操作与下面这些DOM脚本代码一样： </div><div class="t m0 x0 hb yb14 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yb15 ff70 fs6 fc0 sc0 ls21 wsb">var p = document.createElement(&quot;p&quot;); </div><div class="t m0 x0 hb yb16 ff70 fs6 fc0 sc0 ls21 wsb">p.appendChild(document.createTextNode(&quot;This is a paragraph.&quot;)); </div><div class="t m0 x0 hb yb17 ff70 fs6 fc0 sc0 ls21 wsb">div.parentNode.replaceChild(p, div); </div><div class="t m0 x0 hb y1ed0 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 yb18 ff6f fs2 fc0 sc0 ls8 ws1">结果，就是新创建的&lt;p&gt;元素会取代DOM树中的&lt;div&gt;元素。 </div><div class="t m0 x0 hc y1139 ff6f fs2 fc0 sc0 ls8 ws1">支持outerHTML属性的浏览器有IE4+、Safari 4+、Chrome和Opera 8+。Firefox 7及之前版本都不</div><div class="t m0 x0 h5 y59d ff6f fs2 fc0 sc0 ls8 ws1">支持outerHTML属性。 </div></div></div>
<div id="pf13b" class="pf w0 h0" data-page-no="13b"><div class="pc pc13b w0 h0"><div class="t m0 x2 h2 y1db2 ff69 fs0 fc0 sc0 lsc2 wsa0">11.3 HTML5  297 </div><div class="t m0 x0 h3 y2 ff69 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff74 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff74 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff74 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff74 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff74 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff74 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff74 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff74 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff74 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff74 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff74 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ff74 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff74 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h3c y68b ff6d fs2 fc0 sc0 ls2e wsb">3. insertAdjacentHTML()方法 </div><div class="t m0 x0 had y68c ff6f fs2 fc0 sc0 ls8 ws1">插入标记的最后一个新增方式是insertAdjacentHTML()方法。这个方法最早也是在IE中出现的，</div><div class="t m0 x0 h5 y68d ff6f fs2 fc0 sc0 ls8 ws1">它接收两个参数：插入位置和要插入的HTML文本。第一个参数必须是下列值之一： </div><div class="t m0 x0 h5 y1ed1 ff6e fs1 fc0 sc0 ls2"> &quot;beforebegin&quot;，在当前元素之前插入一个紧邻的同辈元素； </div><div class="t m0 x0 h5 y1bd7 ff6e fs1 fc0 sc0 ls8 ws134"> &quot;afterbegin&quot;，在当前元素之下插入一个新的子元素或在第一个子元素之前再插入新的子元素； </div><div class="t m0 x0 h5 y1ed2 ff6e fs1 fc0 sc0 ls8 ws134"> &quot;beforeend&quot;，在当前元素之下插入一个新的子元素或在最后一个子元素之后再插入新的子元素； </div><div class="t m0 x0 h5 y1ed3 ff6e fs1 fc0 sc0 ls2"> &quot;afterend&quot;，在当前元素之后插入一个紧邻的同辈元素。 </div><div class="t m0 x0 h5 y1ed4 ff6f fs2 fc0 sc0 ls8 ws1">注意，这些值都必须是小写形式。第二个参数是一个HTML字符串（与innerHTML和outerHTML</div><div class="t m0 x0 h5 yf6c ff6f fs2 fc0 sc0 ls8 ws1">的值相同），如果浏览器无法解析该字符串，就会抛出错误。以下是这个方法的基本用法示例。 </div><div class="t m0 x0 hb y1dfc ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y1ed5 ff70 fs6 fc0 sc0 ls21">//作为前一个同辈元素插入 </div><div class="t m0 x0 hb y1ed6 ff70 fs6 fc0 sc0 ls21 wsb">element.insertAdjacentHTML(&quot;beforebegin&quot;, &quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;); </div><div class="t m0 x0 hb y1ed7 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y1ed8 ff70 fs6 fc0 sc0 ls21">//作为第一个子元素插入 </div><div class="t m0 x0 hb y1ed9 ff70 fs6 fc0 sc0 ls21 wsb">element.insertAdjacentHTML(&quot;afterbegin&quot;, &quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;); </div><div class="t m0 x0 hb y1eda ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y1edb ff70 fs6 fc0 sc0 ls21">//作为最后一个子元素插入 </div><div class="t m0 x0 hb y1edc ff70 fs6 fc0 sc0 ls21 wsb">element.insertAdjacentHTML(&quot;beforeend&quot;, &quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;); </div><div class="t m0 x0 hb y1edd ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y1ede ff70 fs6 fc0 sc0 ls21">//作为后一个同辈元素插入 </div><div class="t m0 x0 hb y1edf ff70 fs6 fc0 sc0 ls21 wsb">element.insertAdjacentHTML(&quot;afterend&quot;, &quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;); </div><div class="t m0 x0 hb y1ee0 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y13f ff6f fs2 fc0 sc0 ls8 ws1">支持insertAdjacentHTML()方法的浏览器有IE、Firefox 8+、Safari、Opera和Chrome。 </div><div class="t m0 x0 h3c y1ee1 ff6d fs2 fc0 sc0 ls2e wsb">4. 内存与性能问题 </div><div class="t m0 x0 h5 y1ee2 ff6f fs2 fc0 sc0 ls8 ws1">使用本节介绍的方法替换子节点可能会导致浏览器的内存占用问题，尤其是在IE中，问题更加明</div><div class="t m0 x0 h5 y1ee3 ff6f fs2 fc0 sc0 ls8 ws1">显。在删除带有事件处理程序或引用了其他JavaScript对象子树时，就有可能导致内存占用问题。假设</div><div class="t m0 x0 h5 y1ee4 ff6f fs2 fc0 sc0 ls8 ws1">某个元素有一个事件处理程序（或者引用了一个JavaScript对象作为属性），在使用前述某个属性将该元</div><div class="t m0 x0 h5 y1ee5 ff6f fs2 fc0 sc0 ls8 ws1">素从文档树中删除后，元素与事件处理程序（或JavaScript对象）之间的绑定关系在内存中并没有一并</div><div class="t m0 x0 hb2 y1ee6 ff6f fs2 fc0 sc0 ls57 wsa9">删除。如果这种情况频繁出现，页面占用的内存数量就会明显增加。因此，在使用innerHTML、</div><div class="t m0 x0 h4 y1ee7 ff70 fs1 fc0 sc0 ls9 ws2">outerHTML属性和insertAdjacentHTML()方法时，最好先手工删除要被替换的元素的所有事件处理</div><div class="t m0 x0 h5 y3c ff6f fs2 fc0 sc0 ls8 ws1">程序和JavaScript对象属性（第13章将进一步讨论事件处理程序）。 </div><div class="t m0 x0 h5 y3d ff6f fs2 fc0 sc0 ls6">不过，使用这几个属性——特别是使用innerHTML，仍然还是可以为我们提供很多便利的。一般</div><div class="t m0 x0 hc y1ee8 ff6f fs2 fc0 sc0 ls8 ws1">来说，在插入大量新HTML标记时，使用innerHTML属性与通过多次 DOM操作先创建节点再指定它</div><div class="t m0 x0 hc y1ee9 ff6f fs2 fc0 sc0 ls8 ws1">们之间的关系相比，效率要高得多。这是因为在设置innerHTML或outerHTML时，就会创建一个HTML</div><div class="t m0 x0 h5 y3f ff6f fs2 fc0 sc0 ls8 ws1">解析器。这个解析器是在浏览器级别的代码（通常是C++编写的）基础上运行的，因此比执行JavaScript</div><div class="t m0 x0 h5 y1eea ff6f fs2 fc0 sc0 ls8 ws1">快得多。不可避免地，创建和销毁HTML解析器也会带来性能损失，所以最好能够将设置innerHTML</div><div class="t m0 x0 h5 y1eeb ff6f fs2 fc0 sc0 ls2c">或outerHTML的次数控制在合理的范围内。例如，下列代码使用innerHTML创建了很多列表项： </div><div class="t m0 x0 hb y6b5 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1eec ff70 fs6 fc0 sc0 ls21 wsb">for (var i=0, len=values.length; i &lt; len; i++){  </div><div class="t m0 x0 h34 y1eed ff70 fs6 fc0 sc0 ls21 wsb">    ul.innerHTML += &quot;&lt;li&gt;&quot; + values[i] + &quot;&lt;/li&gt;&quot;; //要避免这种频繁操作！！ </div><div class="t m0 x0 hb y1eee ff70 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y1eef ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1ef0 ff6f fs2 fc0 sc0 ls8 ws1">这种每次循环都设置一次innerHTML的做法效率很低。而且，每次循环还要从innerHTML 中读</div><div class="t m0 x0 h4 y1ef1 ff6f fs2 fc0 sc0 ls6 ws6">取一次信息，就意味着每次循环要访问两次innerHTML。最好的做法是单独构建字符串，然后再一次</div><div class="t m0 x0 hc y1ef2 ff6f fs2 fc0 sc0 ls8 ws1">性地将结果字符串赋值给innerHTML，像下面这样： </div><div class="t m0 x0 hb y2d6 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1ef3 ff71 fs6 fc0 sc0 ls21 wsb">var itemsHtml = &quot;&quot;; </div></div></div>
<div id="pf13c" class="pf w0 h0" data-page-no="13c"><div class="pc pc13c w0 h0"><div class="t m0 x0 h2 y1 ff69 fs0 fc0 sc0 ls7 ws0">298  第11章 DOM扩展 </div><div class="t m0 x0 h3 y2 ff69 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 ff70 fs6 fc0 sc0 ls21 wsb">for (var i=0, len=values.length; i &lt; len; i++){ </div><div class="t m0 x0 h15 y7a ff71 fs6 fc0 sc0 ls21 wsb">    itemsHtml += &quot;&lt;li&gt;&quot; + values[i] + &quot;&lt;/li&gt;&quot;; </div><div class="t m0 x0 hb y7b ff70 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 h15 y7c ff71 fs6 fc0 sc0 ls21 wsb">ul.innerHTML = itemsHtml; </div><div class="t m0 x0 hb y1991 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y142b ff6f fs2 fc0 sc0 ls8 ws1">这个例子的效率要高得多，因为它只对innerHTML执行了一次赋值操作。 </div><div class="t m0 x0 h20 y1ef4 ff6d fs3 fc0 sc0 ls248 ws214">11.3.7 scrollIntoView()方法 </div><div class="t m0 x0 h5 y1ef5 ff6f fs2 fc0 sc0 ls8 ws1">如何滚动页面也是DOM规范没有解决的一个问题。为了解决这个问题，浏览器实现了一些方法，</div><div class="t m0 x0 h5 y1ef6 ff6f fs2 fc0 sc0 ls8 ws1">以方便开发人员更好地控制页面滚动。在各种专有方法中，HTML5最终选择了scrollIntoView()作</div><div class="t m0 x0 h5 y1ef7 ff6f fs2 fc0 sc0 ls8 ws1">为标准方法。 </div><div class="t m0 x0 h5 y1ef8 ff70 fs1 fc0 sc0 ls9 ws2">scrollIntoView()可以在所有HTML元素上调用，通过滚动浏览器窗口或某个容器元素，调用</div><div class="t m0 x0 h1e y1ef9 ff6f fs2 fc0 sc0 ls8 ws1">元素就可以出现在视口中。如果给这个方法传入true作为参数，或者不传入任何参数，那么窗口滚动</div><div class="t m0 x0 h4 y403 ff6f fs2 fc0 sc0 ls8 ws1">之后会让调用元素的顶部与视口顶部尽可能平齐。如果传入false作为参数，调用元素会尽可能全部</div><div class="t m0 x0 h5 y1efa ff6f fs2 fc0 sc0 ls8 ws1">出现在视口中，（可能的话，调用元素的底部会与视口顶部平齐。）不过顶部不一定平齐，例如： </div><div class="t m0 x0 hb y1efb ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y1efc ff70 fs6 fc0 sc0 ls21">//让元素可见 </div><div class="t m0 x0 hb y1efd ff70 fs6 fc0 sc0 ls21 wsb">document.forms[0].scrollIntoView(); </div><div class="t m0 x0 hb y1efe ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1eff ff6f fs2 fc0 sc0 ls8 ws1">当页面发生变化时，一般会用这个方法来吸引用户的注意力。实际上，为某个元素设置焦点也会导</div><div class="t m0 x0 h5 y1f00 ff6f fs2 fc0 sc0 ls8 ws1">致浏览器滚动并显示出获得焦点的元素。 </div><div class="t m0 x0 he y1f01 ff6f fs2 fc0 sc0 ls8 ws1">支持scrollIntoView()方法的浏览器有IE、Firefox、Safari和Opera。 </div><div class="t m0 x0 hd y1f02 ff6d fs7 fc0 sc0 ls245">11.4 专有扩展 </div><div class="t m0 x0 h4 y1f03 ff6f fs2 fc0 sc0 ls8 ws1">虽然所有浏览器开发商都知晓坚持标准的重要性，但在发现某项功能缺失时，这些开发商都会一如</div><div class="t m0 x0 h5 y1f04 ff6f fs2 fc0 sc0 ls8 ws1">既往地向DOM中添加专有扩展，以弥补功能上的不足。表面上看，这种各行其事的做法似乎不太好，</div><div class="t m0 x0 h5 y1f05 ff6f fs2 fc0 sc0 ls8 ws1">但实际上专有扩展为Web开发领域提供了很多重要的功能，这些功能最终都在HTML5规范中得到了标</div><div class="t m0 x0 h5 y1f06 ff6f fs2 fc0 sc0 ls8">准化。 </div><div class="t m0 x0 h5 y1f07 ff6f fs2 fc0 sc0 ls8 ws1">即便如此，仍然还有大量专有的DOM扩展没有成为标准。但这并不是说它们将来不会被写进标准，</div><div class="t m0 x0 h5 y1f08 ff6f fs2 fc0 sc0 ls8 ws1">而只是说在编写本书的时候，它们还是专有功能，而且只得到了少数浏览器的支持。 </div><div class="t m0 x0 h20 y1f09 ff6d fs3 fc0 sc0 ls248 ws214">11.4.1 文档模式 </div><div class="t m0 x0 h5 y1f0a ff69 fs2 fc0 sc0 ls2a ws21">IE8引入了一个新的概念叫“文档模式”（document mode）。页面的文档模式决定了可以使用什么功</div><div class="t m0 x0 h5 y1f0b ff6f fs2 fc0 sc0 ls8 ws1">能。换句话说，文档模式决定了你可以使用哪个级别的CSS，可以在JavaScript中使用哪些API，以及</div><div class="t m0 x0 h5 y1f0c ff6f fs2 fc0 sc0 ls8 ws1">如何对待文档类型（doctype）。到了IE9，总共有以下4种文档模式。 </div><div class="t m0 x0 h5 y1f0d ff6e fs1 fc0 sc0 ls2"> IE5：以混杂模式渲染页面（IE5的默认模式就是混杂模式）。IE8及更高版本中的新功能都无法</div><div class="t m0 x0 h5 y1f0e ff6f fs2 fc0 sc0 ls8">使用。 </div><div class="t m0 x0 h5 y1f0f ff6e fs1 fc0 sc0 ls2"> IE7：以IE7标准模式渲染页面。IE8及更高版本中的新功能都无法使用。 </div><div class="t m0 x0 h5 y1f10 ff6e fs1 fc0 sc0 ls2"> IE8：以IE8标准模式渲染页面。IE8中的新功能都可以使用，因此可以使用Selectors API、更多</div><div class="t m0 x0 h5 y1f11 ff69 fs2 fc0 sc0 ls8 ws20">CSS2级选择符和某些CSS3功能，还有一些HTML5的功能。不过 IE9中的新功能无法使用。 </div><div class="t m0 x0 h5 y1f12 ff6e fs1 fc0 sc0 ls2"> IE9：以IE9标准模式渲染页面。IE9中的新功能都可以使用，比如ECMAScript 5、完整的CSS3</div><div class="t m0 x0 h5 y1f13 ff6f fs2 fc0 sc0 ls8 ws1">以及更多HTML5功能。这个文档模式是最高级的模式。 </div></div></div>
<div id="pf13d" class="pf w0 h0" data-page-no="13d"><div class="pc pc13d w0 h0"><div class="t m0 x2 h2 y1 ff69 fs0 fc0 sc0 lsc2 wsa0">11.4 专有扩展   299 </div><div class="t m0 x0 h3 y2 ff69 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff74 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff74 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff74 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff74 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff74 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff74 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff74 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff74 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff74 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff74 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff74 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ff74 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff74 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff6f fs2 fc0 sc0 ls8 ws1">要理解IE8及更高版本的工作原理，必须理解文档模式。 </div><div class="t m0 x0 h5 y4d ff6f fs2 fc0 sc0 ls8 ws1">要强制浏览器以某种模式渲染页面，可以使用HTTP头部信息X-UA-Compatible，或通过等价的</div><div class="t m0 x0 h5 y4e ff70 fs1 fc0 sc0 ls9 ws2">&lt;meta&gt;标签来设置： </div><div class="t m0 x0 hb y6bd ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y6be ff70 fs6 fc0 sc0 ls21 wsb">&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=IEVersion&quot;&gt; </div><div class="t m0 x0 hb y153b ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y6e5 ff6f fs2 fc0 sc0 ls8 ws1">注意，这里IE的版本（IEVersion）有以下一些不同的值，而且这些值并不一定与上述4种文档</div><div class="t m0 x0 h5 y1727 ff6f fs2 fc0 sc0 ls8 ws1">模式对应。 </div><div class="t m0 x0 h5 yd44 ff6e fs1 fc0 sc0 ls2"> Edge：始终以最新的文档模式来渲染页面。忽略文档类型声明。对于IE8，始终保持以IE8标</div><div class="t m0 x5 h5 y14e4 ff6f fs2 fc0 sc0 ls8 ws1">准模式渲染页面。对于IE9，则以IE9标准模式渲染页面。 </div><div class="t m0 x0 h5 y1dfc ff6e fs1 fc0 sc0 ls2"> EmulateIE9：如果有文档类型声明，则以IE9标准模式渲染页面，否则将文档模式设置为IE5。 </div><div class="t m0 x0 h5 y1d94 ff6e fs1 fc0 sc0 ls2"> EmulateIE8：如果有文档类型声明，则以IE8标准模式渲染页面，否则将文档模式设置为IE5。 </div><div class="t m0 x0 h5 y1f14 ff6e fs1 fc0 sc0 ls2"> EmulateIE7：如果有文档类型声明，则以IE7标准模式渲染页面，否则将文档模式设置为IE5。 </div><div class="t m0 x0 h5 y1f15 ff6e fs1 fc0 sc0 ls2"> 9：强制以IE9标准模式渲染页面，忽略文档类型声明。 </div><div class="t m0 x0 h5 y337 ff6e fs1 fc0 sc0 ls2"> 8：强制以IE8标准模式渲染页面，忽略文档类型声明。 </div><div class="t m0 x0 h5 y1f16 ff6e fs1 fc0 sc0 ls2"> 7：强制以IE7标准模式渲染页面，忽略文档类型声明。 </div><div class="t m0 x0 h5 y1f17 ff6e fs1 fc0 sc0 ls2"> 5：强制将文档模式设置为IE5，忽略文档类型声明。 </div><div class="t m0 x0 h5 y1f18 ff6f fs2 fc0 sc0 ls8 ws1">比如，要想让文档模式像在IE7中一样，可以使用下面这行代码： </div><div class="t m0 x0 hb y1f19 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1f1a ff70 fs6 fc0 sc0 ls21 wsb">&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=EmulateIE7&quot;&gt; </div><div class="t m0 x0 hb y1f1b ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1f1c ff6f fs2 fc0 sc0 ls8 ws1">如果不打算考虑文档类型声明，而直接使用IE7标准模式，那么可以使用下面这行代码： </div><div class="t m0 x0 hb y13e2 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1f1d ff70 fs6 fc0 sc0 ls21 wsb">&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=7&quot;&gt; </div><div class="t m0 x0 hb y1f1e ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1f1f ff6f fs2 fc0 sc0 ls8 ws1">没有规定说必须在页面中设置X-UA-Compatible。默认情况下，浏览器会通过文档类型声明来确</div><div class="t m0 x0 h5 y1f20 ff6f fs2 fc0 sc0 ls8 ws1">定是使用最佳的可用文档模式，还是使用混杂模式。 </div><div class="t m0 x0 he y1f21 ff6f fs2 fc0 sc0 ls8 ws1">通过document.documentMode属性可以知道给定页面使用的是什么文档模式。这个属性是 IE8</div><div class="t m0 x0 hc y1f22 ff6f fs2 fc0 sc0 ls8 ws1">中新增的，它会返回使用的文档模式的版本号（在IE9中，可能返回的版本号为5、7、8、9）： </div><div class="t m0 x0 hb y834 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1f23 ff70 fs6 fc0 sc0 ls21 wsb">var mode = document.documentMode; </div><div class="t m0 x0 hb y1f24 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1f25 ff6f fs2 fc0 sc0 ls8 ws1">知道页面采用的是什么文档模式，有助于理解页面的行为方式。无论在什么文档模式下，都可以访</div><div class="t m0 x0 h5 y1f26 ff6f fs2 fc0 sc0 ls8 ws1">问这个属性。 </div><div class="t m0 x0 h20 y1f27 ff6d fs3 fc0 sc0 ls248 ws214">11.4.2 children属性 </div><div class="t m0 x0 h5 y1f28 ff6f fs2 fc0 sc0 ls8 ws1">由于IE9之前的版本与其他浏览器在处理文本节点中的空白符时有差异，因此就出现了children</div><div class="t m0 x0 h4 y1f29 ff6f fs2 fc0 sc0 ls60 ws198">属性。这个属性是HTMLCollection的实例，只包含元素中同样还是元素的子节点。除此之外，</div><div class="t m0 x0 h4 y1f2a ff70 fs1 fc0 sc0 ls9 ws2">children属性与childNodes没有什么区别，即在元素只包含元素子节点时，这两个属性的值相同。</div><div class="t m0 x0 hc y1f2b ff6f fs2 fc0 sc0 ls8 ws1">下面是访问children属性的示例代码： </div><div class="t m0 x0 hb y1f2c ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1f2d ff70 fs6 fc0 sc0 ls21 wsb">var childCount = element.children.length; </div><div class="t m0 x0 hb y1f2e ff70 fs6 fc0 sc0 ls21 wsb">var firstChild = element.children[0]; </div><div class="t m0 x0 hb y1f2f ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1f30 ff6f fs2 fc0 sc0 ls8 ws1">支持children属性的浏览器有IE5、Firefox 3.5、Safari 2（但有bug）、Safari 3（完全支持）、Opera8</div><div class="t m0 x0 hc y1f31 ff6f fs2 fc0 sc0 lscd">和Chrome（所有版本）。IE8及更早版本的children属性中也会包含注释节点，但IE9之后的版本则</div><div class="t m0 x0 h5 y3a3 ff6f fs2 fc0 sc0 ls8 ws1">只返回元素节点。 </div></div></div>
<div id="pf13e" class="pf w0 h0" data-page-no="13e"><div class="pc pc13e w0 h0"><div class="t m0 x0 h2 y1 ff69 fs0 fc0 sc0 ls7 ws0">300  第11章 DOM扩展 </div><div class="t m0 x0 h3 y2 ff69 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h20 y12d ff6d fs3 fc0 sc0 ls248 ws214">11.4.3 contains()方法 </div><div class="t m0 x0 h5 y12e ff6f fs2 fc0 sc0 ls8 ws1">在实际开发中，经常需要知道某个节点是不是另一个节点的后代。IE为此率先引入了contains()</div><div class="t m0 x0 h5 y12f ff6f fs2 fc0 sc0 ls8 ws1">方法，以便不通过在DOM文档树中查找即可获得这个信息。调用contains()方法的应该是祖先节点，</div><div class="t m0 x0 h4 y130 ff6f fs2 fc0 sc0 ls8 ws1">也就是搜索开始的节点，这个方法接收一个参数，即要检测的后代节点。如果被检测的节点是后代节点，</div><div class="t m0 x0 he yc0a ff6f fs2 fc0 sc0 ls8 ws1">该方法返回true；否则，返回false。以下是一个例子： </div><div class="t m0 x0 hb y132 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yc0b ff70 fs6 fc0 sc0 ls21 wsb">alert(document.documentElement.contains(document.body));    //true </div><div class="t m0 x0 hb y1f33 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1f34 ff6f fs2 fc0 sc0 ls8 ws1">这个例子测试了&lt;body&gt;元素是不是&lt;html&gt;元素的后代，在格式正确的HTML页面中，以上代码返</div><div class="t m0 x0 hc y1f35 ff6f fs2 fc0 sc0 ls2b6">回true。支持contains()方法的浏览器有IE、Firefox 9+、Safari、Opera和Chrome。 </div><div class="t m0 x0 h5 y1cbd ff6f fs2 fc0 sc0 ls8 ws1">使用DOM Level 3 compareDocumentPosition()也能够确定节点间的关系。支持这个方法的浏</div><div class="t m0 x0 h5 y1f36 ff6f fs2 fc0 sc0 ls8 ws1">览器有IE9+、Firefox、Safari、Opera 9.5+和Chrome。如前所述，这个方法用于确定两个节点间的关系，</div><div class="t m0 x0 h5 y1f37 ff6f fs2 fc0 sc0 ls8 ws1">返回一个表示该关系的位掩码（ bitmask）。下表列出了这个位掩码的值。 </div><div class="t m0 x0 hb4 y1348 ff6d fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h31 y1f38 ff6c fs6 fc0 sc0 ls8">掩码 节点关系 </div><div class="t m0 x0 h36 y1f39 ff69 fs6 fc0 sc0 lsa1 wsb">1  无关（给定的节点不在当前文档中） </div><div class="t m0 x0 h36 y647 ff69 fs6 fc0 sc0 lsa1 wsb">2  居前（给定的节点在DOM树中位于参考节点之前） </div><div class="t m0 x0 h36 y1f3a ff69 fs6 fc0 sc0 lsa1 wsb">4  居后（给定的节点在DOM树中位于参考节点之后） </div><div class="t m0 x0 h36 y1f3b ff69 fs6 fc0 sc0 lsa1 wsb">8  包含（给定的节点是参考节点的祖先） </div><div class="t m0 x0 h36 y1f3c ff69 fs6 fc0 sc0 lsa1 wsb">16  被包含（给定的节点是参考节点的后代） </div><div class="t m0 x0 h5 y1f3d ff69 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb5 y1f3e ff6f fs2 fc0 sc0 ls8 ws1">为模仿contains()方法，应该关注的是掩码16。可以对compareDocumentPosition()的结果</div><div class="t m0 x0 h1e y1f3f ff6f fs2 fc0 sc0 ls8 ws1">执行按位与，以确定参考节点（调用compareDocumentPosition()方法的当前节点）是否包含给定</div><div class="t m0 x0 h5 y1f40 ff6f fs2 fc0 sc0 ls8 ws1">的节点（传入的节点）。来看下面的例子： </div><div class="t m0 x0 hb y1f41 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1f42 ff70 fs6 fc0 sc0 ls21 wsb">var result = document.documentElement.compareDocumentPosition(document.body); </div><div class="t m0 x0 hb y1f43 ff70 fs6 fc0 sc0 ls21 wsb">alert(!!(result &amp; 16)); </div><div class="t m0 x0 hb y1f44 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1f45 ff6f fs2 fc0 sc0 ls8 ws1">执行上面的代码后，结果会变成20（表示“居后”的4加上表示“被包含”的16）。对掩码16执</div><div class="t m0 x0 h5 y1f46 ff6f fs2 fc0 sc0 ls8 ws1">行按位操作会返回一个非零数值，而两个逻辑非操作符会将该数值转换成布尔值。 </div><div class="t m0 x0 hc y1f47 ff6f fs2 fc0 sc0 ls8 ws1">使用一些浏览器及能力检测，就可以写出如下所示的一个通用的contains函数： </div><div class="t m0 x0 hb y1f48 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1f49 ff70 fs6 fc0 sc0 ls21 wsb">function contains(refNode, otherNode){  </div><div class="t m0 x0 hb y1f4a ff70 fs6 fc0 sc0 ls21 wsb">    if (typeof refNode.contains == &quot;function&quot; &amp;&amp; </div><div class="t m0 x0 hb y1f4b ff70 fs6 fc0 sc0 ls21 wsb">            (!client.engine.webkit || client.engine.webkit &gt;= 522)){ </div><div class="t m0 x0 hb y1f4c ff70 fs6 fc0 sc0 ls21 wsb">        return refNode.contains(otherNode); </div><div class="t m0 x0 hb y1f4d ff70 fs6 fc0 sc0 ls21 wsb">    } else if (typeof refNode.compareDocumentPosition == &quot;function&quot;){ </div><div class="t m0 x0 hb y1f4e ff70 fs6 fc0 sc0 ls21 wsb">        return !!(refNode.compareDocumentPosition(otherNode) &amp; 16); </div><div class="t m0 x0 hb y1f4f ff70 fs6 fc0 sc0 ls21 wsb">    } else { </div><div class="t m0 x0 hb y1f50 ff70 fs6 fc0 sc0 ls21 wsb">        var node = otherNode.parentNode; </div><div class="t m0 x0 hb y1f51 ff70 fs6 fc0 sc0 ls21 wsb">        do { </div><div class="t m0 x0 hb y1f52 ff70 fs6 fc0 sc0 ls21 wsb">            if (node === refNode){ </div><div class="t m0 x0 hb y1f53 ff70 fs6 fc0 sc0 ls21 wsb">                return true; </div><div class="t m0 x0 hb y1f54 ff70 fs6 fc0 sc0 ls21 wsb">            } else { </div><div class="t m0 x0 hb y1f55 ff70 fs6 fc0 sc0 ls21 wsb">                node = node.parentNode; </div><div class="t m0 x0 hb y1f56 ff70 fs6 fc0 sc0 ls21 wsb">            } </div><div class="t m0 x0 hb y1f57 ff70 fs6 fc0 sc0 ls21 wsb">        } while (node !== null); </div></div></div>
<div id="pf13f" class="pf w0 h0" data-page-no="13f"><div class="pc pc13f w0 h0"><div class="t m0 x2 h2 y1 ff69 fs0 fc0 sc0 lsc2 wsa0">11.4 专有扩展   301 </div><div class="t m0 x0 h3 y2 ff69 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff74 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff74 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff74 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff74 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff74 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff74 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff74 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff74 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff74 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff74 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff74 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ff74 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff74 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y79 ff70 fs6 fc0 sc0 ls21 wsb">        return false; </div><div class="t m0 x0 hb y7a ff70 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y7b ff70 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y105 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y106 ff75 fs2 fc0 sc0 ls1b wsb">ContainsExample02.htm </div><div class="t m0 x0 h4 y107 ff6f fs2 fc0 sc0 ls8 ws1">这个函数组合使用了三种方式来确定一个节点是不是另一个节点的后代。函数的第一个参数是参考</div><div class="t m0 x0 h1e y108 ff6f fs2 fc0 sc0 ls8 ws1">节点，第二个参数是要检查的节点。在函数体内，首先检测refNode中是否存在contains()方法（能</div><div class="t m0 x0 h5 y1f58 ff6f fs2 fc0 sc0 ls24 ws1e">力检测）。这一部分代码还检查了当前浏览器所用的WebKit版本号。如果方法存在而且不是We bKit</div><div class="t m0 x0 hc y13fe ff6f fs2 fc0 sc0 ls8 ws1">（!client.engine.webkit），则继续执行代码。否则，如果浏览器是WebKit且至少是Safari 3（WebKit</div><div class="t m0 x0 h5 y10b ff6f fs2 fc0 sc0 ls6 ws6">版本号为522或更高），那么也可以继续执行代码。在WebKit 版本号小于522的Safari浏览器中，</div><div class="t m0 x0 h5 y1f59 ff70 fs1 fc0 sc0 ls9 ws2">contains()方法不能正常使用。 </div><div class="t m0 x0 h1e y1f5a ff6f fs2 fc0 sc0 ls8 ws1">接下来检查是否存在compareDocumentPosition()方法，而函数的最后一步则是自otherNode</div><div class="t m0 x0 h5 y1f5b ff6f fs2 fc0 sc0 ls8 ws1">开始向上遍历DOM结构，以递归方式取得parentNode，并检查其是否与refNode相等。在文档树的</div><div class="t m0 x0 hc y1f5c ff6f fs2 fc0 sc0 ls8 ws1">顶端，parentNode的值等于null，于是循环结束。这是针对旧版本Safari设计的一个后备策略。 </div><div class="t m0 x0 h20 y11 ff6d fs3 fc0 sc0 ls248 ws214">11.4.4 插入文本 </div><div class="t m0 x0 h5 y1484 ff6f fs2 fc0 sc0 ls8 ws1">前面介绍过，IE原来专有的插入标记的属性innerHTML和outerHTML已经被HTML5 纳入规范。</div><div class="t m0 x0 h5 y1f5d ff6f fs2 fc0 sc0 ls8 ws1">但另外两个插入文本的专有属性则没有这么好的运气。这两个没有被HTML5看中的属性是innerText</div><div class="t m0 x0 h5 y364 ff6f fs2 fc0 sc0 ls2c">和outerText。 </div><div class="t m0 x0 h47 y1f5e ff6d fs2 fc0 sc0 ls2e wsb">1. innerText属性 </div><div class="t m0 x0 h4 y1f5f ff6f fs2 fc0 sc0 lsa ws53">通过innertText属性可以操作元素中包含的所有文本内容，包括子文档树中的文本。在通过</div><div class="t m0 x0 h4 y134f ff70 fs1 fc0 sc0 ls9 ws2">innerText读取值时，它会按照由浅入深的顺序，将子文档树中的所有文本拼接起来。在通过</div><div class="t m0 x0 h4 y1f60 ff70 fs1 fc0 sc0 ls9 ws2">innerText写入值时，结果会删除元素的所有子节点，插入包含相应文本值的文本节点。来看下面这</div><div class="t m0 x0 h5 y1f61 ff6f fs2 fc0 sc0 ls3b">个HTML代码示例。 </div><div class="t m0 x0 hb y1352 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1f62 ff70 fs6 fc0 sc0 ls21 wsb">&lt;div id=&quot;content&quot;&gt; </div><div class="t m0 x0 hb y1f63 ff70 fs6 fc0 sc0 ls21 wsb">    &lt;p&gt;This is a &lt;strong&gt;paragraph&lt;/strong&gt; with a list following it.&lt;/p&gt; </div><div class="t m0 x0 hb y1f64 ff70 fs6 fc0 sc0 ls21 wsb">    &lt;ul&gt; </div><div class="t m0 x0 hb y1f65 ff70 fs6 fc0 sc0 ls21 wsb">        &lt;li&gt;Item 1&lt;/li&gt; </div><div class="t m0 x0 hb y1f66 ff70 fs6 fc0 sc0 ls21 wsb">        &lt;li&gt;Item 2&lt;/li&gt; </div><div class="t m0 x0 hb y1f67 ff70 fs6 fc0 sc0 ls21 wsb">        &lt;li&gt;Item 3&lt;/li&gt; </div><div class="t m0 x0 hb y1f68 ff70 fs6 fc0 sc0 ls21 wsb">    &lt;/ul&gt; </div><div class="t m0 x0 hb y1f69 ff70 fs6 fc0 sc0 ls21 wsb">&lt;/div&gt; </div><div class="t m0 x0 hb y1f6a ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1f6b ff75 fs2 fc0 sc0 ls1b wsb">InnerTextExample01.htm </div><div class="t m0 x0 h5 y1f6c ff6f fs2 fc0 sc0 ls8 ws1">对于这个例子中的&lt;div&gt;元素而言，其innerText属性会返回下列字符串： </div><div class="t m0 x0 hb y969 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1f6d ff70 fs6 fc0 sc0 ls21 wsb">This is a paragraph with a list following it. </div><div class="t m0 x0 hb y1f6e ff70 fs6 fc0 sc0 ls21 wsb">Item 1 </div><div class="t m0 x0 hb y1f6f ff70 fs6 fc0 sc0 ls21 wsb">Item 2 </div><div class="t m0 x0 hb y1f70 ff70 fs6 fc0 sc0 ls21 wsb">Item 3 </div><div class="t m0 x0 hb y1f71 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1f72 ff6f fs2 fc0 sc0 ls8 ws1">由于不同浏览器处理空白符的方式不同，因此输出的文本可能会也可能不会包含原始HTML代码</div><div class="t m0 x0 h5 y1f73 ff6f fs2 fc0 sc0 ls8 ws1">中的缩进。 </div><div class="t m0 x0 he y1f74 ff6f fs2 fc0 sc0 ls8 ws1">使用innerText属性设置这个&lt;div&gt;元素的内容，则只需一行代码： </div></div></div>
<div id="pf140" class="pf w0 h0" data-page-no="140"><div class="pc pc140 w0 h0"><div class="t m0 x0 h2 y1 ff69 fs0 fc0 sc0 ls7 ws0">302  第11章 DOM扩展 </div><div class="t m0 x0 h3 y2 ff69 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y866 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y867 ff70 fs6 fc0 sc0 ls21 wsb">div.innerText = &quot;Hello world!&quot;; </div><div class="t m0 x0 hb ya34 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1f75 ff75 fs2 fc0 sc0 ls1b wsb">InnerTextExample02.htm </div><div class="t m0 x0 h5 y1f76 ff6f fs2 fc0 sc0 ls8 ws1">执行这行代码后，页面的HTML代码就会变成如下所示。 </div><div class="t m0 x0 hb y1f77 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1f78 ff70 fs6 fc0 sc0 ls21 wsb">&lt;div id=&quot;content&quot;&gt;Hello world!&lt;/div&gt; </div><div class="t m0 x0 hb y1f79 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1f7a ff6f fs2 fc0 sc0 ls8 ws1">设置innerText属性移除了先前存在的所有子节点，完全改变了DOM子树。此外，设置innerText</div><div class="t m0 x0 h5 y1f7b ff6f fs2 fc0 sc0 ls8 ws1">属性的同时，也对文本中存在的HTML语法字符（小于号、大于号、引号及和号）进行了编码。再看</div><div class="t m0 x0 h5 y1f7c ff6f fs2 fc0 sc0 ls8 ws1">一个例子。 </div><div class="t m0 x0 hb y1f7d ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1f7e ff70 fs6 fc0 sc0 ls21 wsb">div.innerText = &quot;Hello &amp; welcome, &lt;b&gt;\&quot;reader\&quot;!&lt;/b&gt;&quot;; </div><div class="t m0 x0 hb y1f7f ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1f80 ff75 fs2 fc0 sc0 ls1b wsb">InnerTextExample03.htm </div><div class="t m0 x0 h5 y1f81 ff6f fs2 fc0 sc0 ls8 ws1">运行以上代码之后，会得到如下所示的结果。 </div><div class="t m0 x0 hb y1f82 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1f83 ff70 fs6 fc0 sc0 ls21 wsb">&lt;div id=&quot;content&quot;&gt;Hello &amp;amp; welcome, &amp;lt;b&amp;gt;&amp;quot;reader&amp;quot;!&amp;lt;/b&amp;gt;&lt;/div&gt; </div><div class="t m0 x0 hb y1f84 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 yb27 ff6f fs2 fc0 sc0 ls8 ws1">设置innerText永远只会生成当前节点的一个子文本节点，而为了确保只生成一个子文本节点，</div><div class="t m0 x0 hc yb28 ff6f fs2 fc0 sc0 ls8 ws1">就必须要对文本进行HTML编码。利用这一点，可以通过innerText属性过滤掉HTML标签。方法是</div><div class="t m0 x0 hc y790 ff6f fs2 fc0 sc0 ls2b8">将innerText设置为等于innerText，这样就可以去掉所有HTML标签，比如： </div><div class="t m0 x0 hb y1f85 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1f86 ff70 fs6 fc0 sc0 ls21 wsb">div.innerText = div.innerText; </div><div class="t m0 x0 hb y1f87 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1f88 ff6f fs2 fc0 sc0 ls8 ws1">执行这行代码后，就用原来的文本内容替换了容器元素中的所有内容（包括子节点，因而也就去掉</div><div class="t m0 x0 h5 y1f89 ff6f fs2 fc0 sc0 ls3b">了HTML标签）。 </div><div class="t m0 x0 he y1f8a ff6f fs2 fc0 sc0 ls6 ws6">支持innerText属性的浏览器包括 IE4+、Safari 3+、Opera 8+和Chrome。Firefox虽然不支持</div><div class="t m0 x0 hc y1f8b ff69 fs2 fc0 sc0 ls7a ws89">innerText，但支持作用类似的textContent属性。textContent是DOM Level 3规定的一个属性，其</div><div class="t m0 x0 h5 y1f8c ff6f fs2 fc0 sc0 ls8 ws1">他支持textContent属性的浏览器还有IE9+、Safari 3+、Opera 10+和Chrome。为了确保跨浏览器兼</div><div class="t m0 x0 h5 y1f8d ff6f fs2 fc0 sc0 ls8 ws1">容，有必要编写一个类似于下面的函数来检测可以使用哪个属性。 </div><div class="t m0 x0 hb y1f8e ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1f8f ff70 fs6 fc0 sc0 ls21 wsb">function getInnerText(element){ </div><div class="t m0 x0 hb y1f90 ff70 fs6 fc0 sc0 ls21 wsb">    return (typeof element.textContent == &quot;string&quot;) ? </div><div class="t m0 x0 hb y1f91 ff70 fs6 fc0 sc0 ls21 wsb">        element.textContent : element.innerText; </div><div class="t m0 x0 hb y1f92 ff70 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y1f93 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1f94 ff70 fs6 fc0 sc0 ls21 wsb">function setInnerText(element, text){ </div><div class="t m0 x0 hb y1f95 ff70 fs6 fc0 sc0 ls21 wsb">    if (typeof element.textContent == &quot;string&quot;){ </div><div class="t m0 x0 hb y1f96 ff70 fs6 fc0 sc0 ls21 wsb">        element.textContent = text; </div><div class="t m0 x0 hb y1f97 ff70 fs6 fc0 sc0 ls21 wsb">    } else { </div><div class="t m0 x0 hb y1f98 ff70 fs6 fc0 sc0 ls21 wsb">        element.innerText = text; </div><div class="t m0 x0 hb y1f99 ff70 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y1f9a ff70 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y1f9b ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y179f ff75 fs2 fc0 sc0 ls1b wsb">InnerTextExample05.htm </div><div class="t m0 x0 h4 y1f9c ff6f fs2 fc0 sc0 ls8 ws1">这两个函数都接收一个元素作为参数，然后检查这个元素是不是有textContent属性。如果有，</div><div class="t m0 x0 h1e y1f9d ff6f fs2 fc0 sc0 ls5 ws4">那么typeof element.textContent应该是&quot;string&quot;；如果没有，那么这两个函数就会改为使用</div><div class="t m0 x0 h5 y1f9e ff70 fs1 fc0 sc0 ls9 ws2">innerText。可以像下面这样调用这两个函数。 </div><div class="t m0 x0 hb y1f9f ff70 fs6 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf141" class="pf w0 h0" data-page-no="141"><div class="pc pc141 w0 h0"><div class="t m0 x2 h2 y1 ff69 fs0 fc0 sc0 lsc2 wsa0">11.4 专有扩展   303 </div><div class="t m0 x0 h3 y2 ff69 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff74 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff74 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff74 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff74 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff74 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff74 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff74 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff74 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff74 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff74 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff74 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ff74 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff74 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y79 ff70 fs6 fc0 sc0 ls21 wsb">setInnerText(div, &quot;Hello world!&quot;); </div><div class="t m0 x0 hb y7a ff70 fs6 fc0 sc0 ls21 wsb">alert(getInnerText(div));    //&quot;Hello world!&quot; </div><div class="t m0 x0 hb y1c6a ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1c6b ff6f fs2 fc0 sc0 ls8 ws1">使用这两个函数可以确保在不同的浏览器中使用正确的属性。 </div><div class="t m0 x5 ha y1fa0 ff6a fs2 fc0 sc0 ls26 ws282">实际上，innerText与textContent 返回的内容并不完全一样。比如，</div><div class="t m0 x5 ha y1fa1 ff70 fs1 fc0 sc0 ls9 ws2">innerText会忽略行内的样式和脚本，而textContent则会像返回其他文本一样返</div><div class="t m0 x5 ha y1fa2 ff6a fs2 fc0 sc0 ls8 ws14">回行内的样式和脚本代码。避免跨浏览器兼容问题的最佳途径，就是从不包含行内样</div><div class="t m0 x5 h5 y1fa3 ff6a fs2 fc0 sc0 ls8 ws14">式或行内脚本的DOM子树副本或DOM片段中读取文本。 </div><div class="t m0 x0 h4c y1fa4 ff6d fs2 fc0 sc0 ls2e wsb">2. outerText属性 </div><div class="t m0 x0 h4 y1fa5 ff6f fs2 fc0 sc0 ls8 ws1">除了作用范围扩大到了包含调用它的节点之外，outerText与innerText基本上没有多大区别。</div><div class="t m0 x0 h1e y1fa6 ff6f fs2 fc0 sc0 ls8 ws1">在读取文本值时，outerText与innerText的结果完全一样。但在写模式下，outerText就完全不</div><div class="t m0 x0 hc yf29 ff6f fs2 fc0 sc0 ls8 ws1">同了：outerText不只是替换调用它的元素的子节点，而是会替换整个元素（包括子节点）。比如： </div><div class="t m0 x0 hb yf2a ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yf2b ff70 fs6 fc0 sc0 ls21 wsb">div.outerText = &quot;Hello world!&quot;; </div><div class="t m0 x0 hb y1fa7 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1fa8 ff6f fs2 fc0 sc0 ls8 ws1">这行代码实际上相当于如下两行代码： </div><div class="t m0 x0 hb y1fa9 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1faa ff70 fs6 fc0 sc0 ls21 wsb">var text = document.createTextNode(&quot;Hello world!&quot;); </div><div class="t m0 x0 hb y1fab ff70 fs6 fc0 sc0 ls21 wsb">div.parentNode.replaceChild(text, div); </div><div class="t m0 x0 hb y1fac ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y6a1 ff6f fs2 fc0 sc0 ls8 ws1">本质上，新的文本节点会完全取代调用outerText的元素。此后，该元素就从文档中被删除，无</div><div class="t m0 x0 h5 y1fad ff6f fs2 fc0 sc0 ls8">法访问。 </div><div class="t m0 x0 hc y1fae ff6f fs2 fc0 sc0 ls8 ws1">支持outerText属性的浏览器有IE4+、Safari 3+、Opera 8+和Chrome。由于这个属性会导致调用</div><div class="t m0 x0 h5 y1faf ff6f fs2 fc0 sc0 ls8 ws1">它的元素不存在，因此并不常用。我们也建议读者尽可能不要使用这个属性。 </div><div class="t m0 x0 h20 y1bec ff6d fs3 fc0 sc0 ls248 ws214">11.4.5 滚动 </div><div class="t m0 x0 h5 y1fb0 ff6f fs2 fc0 sc0 ls5 ws4">如前所述，HTML5之前的规范并没有就与页面滚动相关的API做出任何规定。但 HTML5在将</div><div class="t m0 x0 h4 y1fb1 ff70 fs1 fc0 sc0 ls9 ws2">scrollIntoView()纳入规范之后，仍然还有其他几个专有方法可以在不同的浏览器中使用。下面列出</div><div class="t m0 x0 hc y1fb2 ff6f fs2 fc0 sc0 ls8 ws1">的几个方法都是对HTMLElement类型的扩展，因此在所有元素中都可以调用。 </div><div class="t m0 x0 h4 y1fb3 ff6e fs1 fc0 sc0 ls2"> scrollIntoViewIfNeeded(alignCenter)：只在当前元素在视口中不可见的情况下，才滚</div><div class="t m0 x5 h4 y1fb4 ff6f fs2 fc0 sc0 ls8 ws1">动浏览器窗口或容器元素，最终让它可见。如果当前元素在视口中可见，这个方法什么也不做。</div><div class="t m0 x5 h1e y1fb5 ff6f fs2 fc0 sc0 ls8 ws1">如果将可选的alignCenter参数设置为true，则表示尽量将元素显示在视口中部（垂直方向）。</div><div class="t m0 x5 h5 y1fb6 ff69 fs2 fc0 sc0 ls48 ws39">Safari和Chrome实现了这个方法。 </div><div class="t m0 x0 h4 y1fb7 ff6e fs1 fc0 sc0 ls2"> scrollByLines(lineCount)：将元素的内容滚动指定的行高，lineCount值可以是正值，</div><div class="t m0 x5 h5 y1fb8 ff6f fs2 fc0 sc0 ls8 ws1">也可以是负值。Safari和Chrome实现了这个方法。 </div><div class="t m0 x0 h4 ya00 ff6e fs1 fc0 sc0 ls2"> scrollByPages(pageCount)：将元素的内容滚动指定的页面高度，具体高度由元素的高度决</div><div class="t m0 x5 h5 y1fb9 ff6f fs2 fc0 sc0 ls8">定。Safari和Chrome实现了这个方法。 </div><div class="t m0 x0 h1c y1fba ff6f fs2 fc0 sc0 ls8 ws1">希望大家要注意的是，scrollIntoView()和scrollIntoViewIfNeeded()的作用对象是元素的</div><div class="t m0 x0 hc y1fbb ff6f fs2 fc0 sc0 ls8 ws1">容器，而scrollByLines()和scrollByPages()影响的则是元素自身。下面还是来看几个示例吧。 </div><div class="t m0 x0 hb y18c4 ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y18c5 ff70 fs6 fc0 sc0 ls21">//将页面主体滚动5行 </div><div class="t m0 x0 hb y1fbc ff70 fs6 fc0 sc0 ls21 wsb">document.body.scrollByLines(5); </div><div class="t m0 x0 hb y1fbd ff70 fs6 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf142" class="pf w0 h0" data-page-no="142"><div class="pc pc142 w0 h0"><div class="t m0 x0 h2 y1 ff69 fs0 fc0 sc0 ls7 ws0">304  第11章 DOM扩展 </div><div class="t m0 x0 h3 y2 ff69 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y79 ff70 fs6 fc0 sc0 ls21">//在当前元素不可见的时候，让它进入浏览器的视口 </div><div class="t m0 x0 hb y7a ff70 fs6 fc0 sc0 ls21 wsb">document.images[0].scrollIntoViewIfNeeded(); </div><div class="t m0 x0 hb y7b ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y7c ff70 fs6 fc0 sc0 ls21">//将页面主体往回滚动1页 </div><div class="t m0 x0 hb y7d ff70 fs6 fc0 sc0 ls21 wsb">document.body.scrollByPages(-1); </div><div class="t m0 x0 hb y3fc ff70 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1dce ff6f fs2 fc0 sc0 ls8 ws1">由于scrollIntoView()是唯一一个所有浏览器都支持的方法，因此还是这个方法最常用。 </div><div class="t m0 x0 hd y1fbe ff6d fs7 fc0 sc0 ls245">11.5 小结 </div><div class="t m0 x0 h5 y149c ff6f fs2 fc0 sc0 ls8 ws1">虽然DOM为与XML及HTML文档交互制定了一系列核心 API，但仍然有几个规范对标准的DOM</div><div class="t m0 x0 h4 y1fbf ff6f fs2 fc0 sc0 ls8 ws1">进行了扩展。这些扩展中有很多原来是浏览器专有的，但后来成为了事实标准，于是其他浏览器也都提</div><div class="t m0 x0 h5 y1fc0 ff6f fs2 fc0 sc0 ls8 ws1">供了相同的实现。本章介绍的三个这方面的规范如下。 </div><div class="t m0 x0 h5 y1fc1 ff6e fs1 fc0 sc0 ls2"> Selectors API，定义了两个方法，让开发人员能够基于CSS选择符从DOM中取得元素，这两个</div><div class="t m0 x0 hc y1fc2 ff6f fs2 fc0 sc0 ls8 ws1">方法是querySelector()和querySelectorAll()。 </div><div class="t m0 x0 h5 y1fc3 ff6e fs1 fc0 sc0 ls2"> Element Traversal，为DOM元素定义了额外的属性，让开发人员能够更方便地从一个元素跳到</div><div class="t m0 x0 h5 y1fc4 ff6f fs2 fc0 sc0 ls8 ws1">另一个元素。之所以会出现这个扩展，是因为浏览器处理DOM元素间空白符的方式不一样。 </div><div class="t m0 x0 h5 y1fc5 ff6e fs1 fc0 sc0 ls2"> HTML5，为标准的DOM定义了很多扩展功能。其中包括在innerHTML属性这样的事实标准基</div><div class="t m0 x0 h5 y1fc6 ff6f fs2 fc0 sc0 ls8 ws1">础上提供的标准定义，以及为管理焦点、设置字符集、滚动页面而规定的扩展API。 </div><div class="t m0 x0 h5 y1fc7 ff6f fs2 fc0 sc0 ls8 ws1">虽然目前DOM扩展的数量还不多，但随着Web技术的发展，相信一定还会涌现出更多扩展来。很</div><div class="t m0 x0 h4 y1fc8 ff6f fs2 fc0 sc0 ls8 ws1">多浏览器都在试验专有的扩展，而这些扩展一旦获得认可，就能成为“伪”标准，甚至会被收录到规范</div><div class="t m0 x0 h5 y1fc9 ff6f fs2 fc0 sc0 ls8 ws1">的更新版本中。 </div><div class="t m0 x0 h5 y1fca ff69 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1fcb ff69 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1fcc ff69 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1fcd ff69 fs2 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf143" class="pf w0 h0" data-page-no="143"><div class="pc pc143 w0 h0"><div class="t m0 x2 h2 y1 ff78 fs0 fc0 sc0 ls7 ws0">12.1 DOM变化   305 </div><div class="t m0 x0 h3 y2 ff78 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff7a fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff7a fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff7a fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff7a fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff7a fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff7a fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff7a fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff7a fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff7a fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff7a fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff7a fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff7a fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff7a fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h9 y2a ff7b fs5 fc0 sc0 lsa6 wsb">DOM2和DOM3 </div><div class="t m0 x0 h3c y2b ff7c fs2 fc0 sc0 ls8">本章内容 </div><div class="t m0 x0 h5 y2c ff7e fs1 fc0 sc0 ls2"> DOM2和DOM3的变化 </div><div class="t m0 x0 h5 y2d ff7e fs1 fc0 sc0 ls2"> 操作样式的DOM API </div><div class="t m0 x0 h5 y2e ff7e fs1 fc0 sc0 ls2"> DOM遍历与范围 </div><div class="t m0 x0 h5 y8d9 ff78 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x5 h5 y8da ff78 fs2 fc0 sc0 ls81 ws76">OM1级主要定义的是HTML和XML文档的底层结构。DOM2 和DOM3级则在这个结构</div><div class="t m0 x5 h5 y8db ff7f fs2 fc0 sc0 lsa ws10a">的基础上引入了更多的交互能力，也支持了更高级的XML特性。为此，DOM2和DOM3</div><div class="t m0 x0 h5 y8dc ff7f fs2 fc0 sc0 ls60 ws140">级分为许多模块（模块之间具有某种关联），分别描述了DOM的某个非常具体的子集。这些模块 </div><div class="t m0 x0 h5 y8dd ff7f fs2 fc0 sc0 lsa">如下。 </div><div class="t m0 x0 h5 y13e0 ff7e fs1 fc0 sc0 ls2"> DOM2级核心（DOM Level 2 Core）：在1级核心基础上构建，为节点添加了更多方法和属性。 </div><div class="t m0 x0 h5 y13e1 ff7e fs1 fc0 sc0 ls2"> DOM2级视图（DOM Level 2 Views）：为文档定义了基于样式信息的不同视图。 </div><div class="t m0 x0 h5 y1fcf ff7e fs1 fc0 sc0 ls2"> DOM2级事件（DOM Level 2 Events）：说明了如何使用事件与DOM文档交互。 </div><div class="t m0 x0 h5 y1fd0 ff7e fs1 fc0 sc0 ls2"> DOM2级样式（DOM Level 2 Style）：定义了如何以编程方式来访问和改变CSS样式信息。 </div><div class="t m0 x0 h5 yef7 ff7e fs1 fc0 sc0 ls2"> DOM2级遍历和范围（DOM Level 2 Traversal and Range）：引入了遍历DOM文档和选择其特定</div><div class="t m0 x5 h5 yef8 ff7f fs2 fc0 sc0 ls8 wseb">部分的新接口。 </div><div class="t m0 x0 h5 y8e3 ff7e fs1 fc0 sc0 ls2"> DOM2级 HTML（DOM Level 2 HTML）：在1级HTML基础上构建，添加了更多属性、方法和</div><div class="t m0 x5 h5 y1fd1 ff7f fs2 fc0 sc0 ls8">新接口。 </div><div class="t m0 x0 h5 y1fd2 ff7f fs2 fc0 sc0 ls8 wseb">本章探讨除“DOM2级事件”之外的所有模块，“DOM2级事件”模块将在第13章进行全面讲解。 </div><div class="t m0 x5 h5 y1fd3 ff78 fs2 fc0 sc0 ls24a ws215">DOM3级又增加了“XPath”模块和“加载与保存”（Load and Save）模块。这</div><div class="t m0 x5 h5 y1fd4 ff79 fs2 fc0 sc0 ls8 ws14">些模块将在第18章讨论。 </div><div class="t m0 x0 hd y1fd5 ff7d fs7 fc0 sc0 ls245">12.1 DOM变化 </div><div class="t m0 x0 h5 y1fd6 ff78 fs2 fc0 sc0 ls24a ws215">DOM2级和3级的目的在于扩展DOM API，以满足操作XML的所有需求，同时提供更好的错误处</div><div class="t m0 x0 h5 y1fd7 ff7f fs2 fc0 sc0 ls8 wseb">理及特性检测能力。从某种意义上讲，实现这一目的很大程度意味着对命名空间的支持。“DOM2级核</div><div class="t m0 x0 h5 y1fd8 ff7f fs2 fc0 sc0 ls8 wseb">心”没有引入新类型，它只是在DOM1级的基础上通过增加新方法和新属性来增强了既有类型。“DOM3</div><div class="t m0 x0 h5 y1fd9 ff7f fs2 fc0 sc0 ls8 wseb">级核心”同样增强了既有类型，但也引入了一些新类型。 </div><div class="t m0 x0 h5 y1fda ff7f fs2 fc0 sc0 ls8 wseb">类似地，“DOM2级视图”和“DOM2级HTML”模块也增强了DOM接口，提供了新的属性和方</div><div class="t m0 x0 h5 y1fdb ff7f fs2 fc0 sc0 ls8 wseb">法。由于这两个模块很小，因此我们将把它们与“DOM2级核心”放在一起，讨论基本JavaScript对象</div><div class="t m0 x0 h5 y1fdc ff7f fs2 fc0 sc0 ls8 wseb">的变化。可以通过下列代码来确定浏览器是否支持这些DOM模块。 </div><div class="t m0 x0 h78 y12c6 ff80 fs11 fc0 sc0 ls246 wsb">D </div><div class="t m0 x0 h11 y4b ff81 fsa fc0 sc0 ls8">第</div><div class="t m1 x0 h12 y4b ff82 fsb fc3 sc0 ls247">12</div><div class="t m0 x5 h11 y4b ff81 fsa fc0 sc0 ls8 ws1d">章 第</div><div class="t m1 x0 h12 y4b ff82 fsb fc3 sc0 ls247">12</div><div class="t m0 x5 h11 y4b ff81 fsa fc0 sc0 ls8 ws1d">章 </div></div></div>
<div id="pf144" class="pf w0 h0" data-page-no="144"><div class="pc pc144 w0 h0"><div class="t m0 x0 h2 y1 ff78 fs0 fc0 sc0 ls7 ws0">306  第12章 DOM2和DOM3 </div><div class="t m0 x0 h3 y2 ff78 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 ff83 fs6 fc0 sc0 ls21 wsb">var supportsDOM2Core = document.implementation.hasFeature(&quot;Core&quot;, &quot;2.0&quot;);  </div><div class="t m0 x0 hb y7a ff83 fs6 fc0 sc0 ls21 wsb">var supportsDOM3Core = document.implementation.hasFeature(&quot;Core&quot;, &quot;3.0&quot;); </div><div class="t m0 x0 hb y7b ff83 fs6 fc0 sc0 ls21 wsb">var supportsDOM2HTML = document.implementation.hasFeature(&quot;HTML&quot;, &quot;2.0&quot;); </div><div class="t m0 x0 hb y7c ff83 fs6 fc0 sc0 ls21 wsb">var supportsDOM2Views = document.implementation.hasFeature(&quot;Views&quot;, &quot;2.0&quot;); </div><div class="t m0 x0 hb y7d ff83 fs6 fc0 sc0 ls21 wsb">var supportsDOM2XML = document.implementation.hasFeature(&quot;XML&quot;, &quot;2.0&quot;); </div><div class="t m0 x5 ha y1fde ff79 fs2 fc0 sc0 ls8 ws14">本章只讨论那些已经有浏览器实现的部分，任何浏览器都没有实现的部分将不作</div><div class="t m0 x0 h5 y1fdf ff79 fs2 fc0 sc0 ls8">讨论。 </div><div class="t m0 x0 h20 y1fe0 ff7d fs3 fc0 sc0 ls248 ws214">12.1.1 针对XML命名空间的变化 </div><div class="t m0 x0 h5 y1fe1 ff7f fs2 fc0 sc0 ls8 wseb">有了XML命名空间，不同XML 文档的元素就可以混合在一起，共同构成格式良好的文档，而不</div><div class="t m0 x0 h5 y8a0 ff7f fs2 fc0 sc0 ls8 wseb">必担心发生命名冲突。从技术上说，HTML不支持XML命名空间，但XHTML 支持XML命名空间。</div><div class="t m0 x0 h5 y8a1 ff7f fs2 fc0 sc0 ls8 wseb">因此，本节给出的都是XHTML的示例。 </div><div class="t m0 x0 he y1fe2 ff7f fs2 fc0 sc0 ls8 wseb">命名空间要使用xmlns特性来指定。XHTML的命名空间是http://www.w3.org/1999/xhtml，在任何</div><div class="t m0 x0 hc y1fe3 ff7f fs2 fc0 sc0 ls8 wseb">格式良好XHTML页面中，都应该将其包含在&lt;html&gt;元素中，如下面的例子所示。 </div><div class="t m0 x0 hb y1fe4 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1fe5 ff83 fs6 fc0 sc0 ls21 wsb">&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; </div><div class="t m0 x0 hb y1fe6 ff83 fs6 fc0 sc0 ls21 wsb">    &lt;head&gt; </div><div class="t m0 x0 hb y1fe7 ff83 fs6 fc0 sc0 ls21 wsb">        &lt;title&gt;Example XHTML page&lt;/title&gt; </div><div class="t m0 x0 hb y1fe8 ff83 fs6 fc0 sc0 ls21 wsb">    &lt;/head&gt; </div><div class="t m0 x0 hb y1fe9 ff83 fs6 fc0 sc0 ls21 wsb">    &lt;body&gt; </div><div class="t m0 x0 hb y1fea ff83 fs6 fc0 sc0 ls21 wsb">        Hello world! </div><div class="t m0 x0 hb y1feb ff83 fs6 fc0 sc0 ls21 wsb">    &lt;/body&gt; </div><div class="t m0 x0 hb y1fec ff83 fs6 fc0 sc0 ls21 wsb">&lt;/html&gt; </div><div class="t m0 x0 hb y1fed ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y8d4 ff7f fs2 fc0 sc0 ls8 wseb">对这个例子而言，其中的所有元素默认都被视为XHTML命名空间中的元素。要想明确地为XML</div><div class="t m0 x0 h5 y1fee ff7f fs2 fc0 sc0 ls8 wseb">命名空间创建前缀，可以使用xmlns后跟冒号，再后跟前缀，如下所示。 </div><div class="t m0 x0 hb y1fef ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1ff0 ff83 fs6 fc0 sc0 ls21 wsb">&lt;xhtml:html xmlns:xhtml=&quot;http://www.w3.org/1999/xhtml&quot;&gt; </div><div class="t m0 x0 hb y1ff1 ff83 fs6 fc0 sc0 ls21 wsb">    &lt;xhtml:head&gt; </div><div class="t m0 x0 hb y1ff2 ff83 fs6 fc0 sc0 ls21 wsb">        &lt;xhtml:title&gt;Example XHTML page&lt;/xhtml:title&gt; </div><div class="t m0 x0 hb y1ff3 ff83 fs6 fc0 sc0 ls21 wsb">    &lt;/xhtml:head&gt; </div><div class="t m0 x0 hb y1ff4 ff83 fs6 fc0 sc0 ls21 wsb">    &lt;xhtml:body&gt; </div><div class="t m0 x0 hb y1ff5 ff83 fs6 fc0 sc0 ls21 wsb">        Hello world! </div><div class="t m0 x0 hb y1ff6 ff83 fs6 fc0 sc0 ls21 wsb">    &lt;/xhtml:body&gt; </div><div class="t m0 x0 hb y1ff7 ff83 fs6 fc0 sc0 ls21 wsb">&lt;/xhtml:html&gt; </div><div class="t m0 x0 hb y1ff8 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1ff9 ff7f fs2 fc0 sc0 ls8 wseb">这里为XHTML的命名空间定义了一个名为xhtml的前缀，并要求所有 XHTML元素都以该前缀</div><div class="t m0 x0 h5 y1ffa ff7f fs2 fc0 sc0 ls8 wseb">开头。有时候为了避免不同语言间的冲突，也需要使用命名空间来限定特性，如下面的例子所示。 </div><div class="t m0 x0 hb y1ffb ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1ffc ff83 fs6 fc0 sc0 ls21 wsb">&lt;xhtml:html xmlns:xhtml=&quot;http://www.w3.org/1999/xhtml&quot;&gt; </div><div class="t m0 x0 hb y1ffd ff83 fs6 fc0 sc0 ls21 wsb">    &lt;xhtml:head&gt; </div><div class="t m0 x0 hb y1ffe ff83 fs6 fc0 sc0 ls21 wsb">        &lt;xhtml:title&gt;Example XHTML page&lt;/xhtml:title&gt; </div><div class="t m0 x0 hb y1fff ff83 fs6 fc0 sc0 ls21 wsb">    &lt;/xhtml:head&gt; </div><div class="t m0 x0 h15 y2000 ff84 fs6 fc0 sc0 ls21 wsb">    &lt;xhtml:body xhtml:class=&quot;home&quot;&gt; </div><div class="t m0 x0 hb y2001 ff83 fs6 fc0 sc0 ls21 wsb">        Hello world! </div><div class="t m0 x0 hb y2002 ff83 fs6 fc0 sc0 ls21 wsb">    &lt;/xhtml:body&gt; </div><div class="t m0 x0 hb y2003 ff83 fs6 fc0 sc0 ls21 wsb">&lt;/xhtml:html&gt; </div><div class="t m0 x0 hb y2004 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y49d ff7f fs2 fc0 sc0 ls8 wseb">这个例子中的特性class带有一个xhtml 前缀。在只基于一种语言编写XML文档的情况下，命</div><div class="t m0 x0 h4 y1db1 ff7f fs2 fc0 sc0 ls8 wseb">名空间实际上也没有什么用。不过，在混合使用两种语言的情况下，命名空间的用处就非常大了。来看</div></div></div>
<div id="pf145" class="pf w0 h0" data-page-no="145"><div class="pc pc145 w0 h0"><div class="t m0 x2 h2 y1 ff78 fs0 fc0 sc0 ls7 ws0">12.1 DOM变化   307 </div><div class="t m0 x0 h3 y2 ff78 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff7a fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff7a fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff7a fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff7a fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff7a fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff7a fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff7a fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff7a fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff7a fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff7a fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff7a fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff7a fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff7a fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff7f fs2 fc0 sc0 ls8 wseb">一看下面这个混合了XHTML和SVG语言的文档： </div><div class="t m0 x5 hb yfb2 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yfb3 ff83 fs6 fc0 sc0 ls21 wsb">&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; </div><div class="t m0 x0 hb yfb4 ff83 fs6 fc0 sc0 ls21 wsb">    &lt;head&gt; </div><div class="t m0 x0 hb yfb5 ff83 fs6 fc0 sc0 ls21 wsb">        &lt;title&gt;Example XHTML page&lt;/title&gt; </div><div class="t m0 x0 hb yfb6 ff83 fs6 fc0 sc0 ls21 wsb">    &lt;/head&gt; </div><div class="t m0 x0 hb yfb7 ff83 fs6 fc0 sc0 ls21 wsb">    &lt;body&gt; </div><div class="t m0 x0 h15 yfb8 ff84 fs6 fc0 sc0 ls21 wsb">        &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; </div><div class="t m0 x0 h15 yfb9 ff84 fs6 fc0 sc0 ls21 wsb">             viewBox=&quot;0 0 100 100&quot; style=&quot;width:100%; height:100%&quot;&gt; </div><div class="t m0 x0 h15 yfba ff84 fs6 fc0 sc0 ls21 wsb">            &lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;100&quot; height=&quot;100&quot; style=&quot;fill:red&quot;/&gt; </div><div class="t m0 x0 h15 yfbb ff84 fs6 fc0 sc0 ls21 wsb">        &lt;/svg&gt; </div><div class="t m0 x0 hb y2005 ff83 fs6 fc0 sc0 ls21 wsb">    &lt;/body&gt; </div><div class="t m0 x0 hb y2006 ff83 fs6 fc0 sc0 ls21 wsb">&lt;/html&gt; </div><div class="t m0 x5 hb y2007 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y103b ff7f fs2 fc0 sc0 ls1f ws108">在这个例子中，通过设置命名空间，将&lt;svg&gt;标识为了与包含文档无关的元素。此时，&lt;svg&gt;元素的</div><div class="t m0 x0 h1e y2008 ff7f fs2 fc0 sc0 ls5f ws10b">所有子元素，以及这些元素的所有特性，都被认为属于http://www.w3.org/2000/svg命名空间。即</div><div class="t m0 x0 h5 yed5 ff7f fs2 fc0 sc0 ls5f ws10b">使这个文档从技术上说是一个XHTML文档，但因为有了命名空间，其中的SVG代码也仍然是有效的。 </div><div class="t m0 x0 h4 y2009 ff7f fs2 fc0 sc0 ls8 wseb">对于类似这样的文档来说，最有意思的事发生在调用方法操作文档节点的情况下。例如，在创建一</div><div class="t m0 x0 h4 y200a ff7f fs2 fc0 sc0 ls8 wseb">个元素时，这个元素属于哪个命名空间呢？在查询一个特殊标签名时，应该将结果包含在哪个命名空间</div><div class="t m0 x0 h5 y200b ff7f fs2 fc0 sc0 ls8 wseb">中呢？“DOM2级核心”通过为大多数DOM1级方法提供特定于命名空间的版本解决了这个问题。 </div><div class="t m0 x0 hb7 y200c ff7d fs2 fc0 sc0 ls2e wsb">1. Node类型的变化 </div><div class="t m0 x0 h5 y200d ff7f fs2 fc0 sc0 ls3b">在DOM2级中，Node类型包含下列特定于命名空间的属性。 </div><div class="t m0 x0 h5 y13f ff7e fs1 fc0 sc0 ls2"> localName：不带命名空间前缀的节点名称。 </div><div class="t m0 x0 h5 y200e ff7e fs1 fc0 sc0 ls2"> namespaceURI：命名空间URI或者（在未指定的情况下是）null。 </div><div class="t m0 x0 h5 y200f ff7e fs1 fc0 sc0 ls2"> prefix：命名空间前缀或者（在未指定的情况下是）null。 </div><div class="t m0 x0 hc y2010 ff7f fs2 fc0 sc0 ls42 wsf0">当节点使用了命名空间前缀时，其nodeName等于prefix+&quot;:&quot;+ localName。以下面的文档为例： </div><div class="t m0 x5 hb y14cd ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2011 ff83 fs6 fc0 sc0 ls21 wsb">&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; </div><div class="t m0 x0 hb y2012 ff83 fs6 fc0 sc0 ls21 wsb">    &lt;head&gt; </div><div class="t m0 x0 hb y2013 ff83 fs6 fc0 sc0 ls21 wsb">        &lt;title&gt;Example XHTML page&lt;/title&gt; </div><div class="t m0 x0 hb y2014 ff83 fs6 fc0 sc0 ls21 wsb">    &lt;/head&gt; </div><div class="t m0 x0 hb y2015 ff83 fs6 fc0 sc0 ls21 wsb">    &lt;body&gt; </div><div class="t m0 x0 h15 y2016 ff84 fs6 fc0 sc0 ls21 wsb">        &lt;s:svg xmlns:s=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; </div><div class="t m0 x0 h15 y2017 ff84 fs6 fc0 sc0 ls21 wsb">             viewBox=&quot;0 0 100 100&quot; style=&quot;width:100%; height:100%&quot;&gt; </div><div class="t m0 x0 h15 y2018 ff84 fs6 fc0 sc0 ls21 wsb">            &lt;s:rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;100&quot; height=&quot;100&quot; style=&quot;fill:red&quot;/&gt; </div><div class="t m0 x0 h15 y2019 ff84 fs6 fc0 sc0 ls21 wsb">        &lt;/s:svg&gt; </div><div class="t m0 x0 hb y201a ff83 fs6 fc0 sc0 ls21 wsb">    &lt;/body&gt; </div><div class="t m0 x0 hb y201b ff83 fs6 fc0 sc0 ls21 wsb">&lt;/html&gt; </div><div class="t m0 x5 hb y201c ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y811 ff85 fs2 fc0 sc0 ls138 wsb">NamespaceExample.xml </div><div class="t m0 x0 h4 y1a62 ff7f fs2 fc0 sc0 ls8 wseb">对于&lt;html&gt;元素来说，它的localName和tagName是&quot;html&quot;，namespaceURI是&quot;http://www. </div><div class="t m0 x0 h42 y201d ff83 fs1 fc0 sc0 ls9 ws2">w3.org/1999/xhtml&quot;，而prefix是null。对于&lt;s:svg&gt;元素而言，它的localName 是&quot;svg&quot;，</div><div class="t m0 x0 h5 y201e ff83 fs1 fc0 sc0 ls9 ws2">tagName是&quot;s:svg&quot;，namespaceURI是&quot;http://www.w3.org/2000/svg&quot;，而prefix是&quot;s&quot;。 </div><div class="t m0 x0 h5 y301 ff78 fs2 fc0 sc0 ls24a ws215">DOM3级在此基础上更进一步，又引入了下列与命名空间有关的方法。 </div><div class="t m0 x0 h4 y201f ff7e fs1 fc0 sc0 ls2"> isDefaultNamespace(namespaceURI)：在指定的namespaceURI是当前节点的默认命名空</div><div class="t m0 x5 hc y2020 ff7f fs2 fc0 sc0 ls8 wseb">间的情况下返回true。 </div><div class="t m0 x0 h5 y1aca ff7e fs1 fc0 sc0 ls2"> lookupNamespaceURI(prefix)：返回给定prefix的命名空间。 </div><div class="t m0 x0 h5 y2021 ff7e fs1 fc0 sc0 ls2"> lookupPrefix(namespaceURI)：返回给定namespaceURI的前缀。 </div></div></div>
<div id="pf146" class="pf w0 h0" data-page-no="146"><div class="pc pc146 w0 h0"><div class="t m0 x0 h2 y1 ff78 fs0 fc0 sc0 ls7 ws0">308  第12章 DOM2和DOM3 </div><div class="t m0 x0 h3 y2 ff78 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff7f fs2 fc0 sc0 ls8 wseb">针对前面的例子，可以执行下列代码： </div><div class="t m0 x0 hb yfb2 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yfb3 ff83 fs6 fc0 sc0 ls21 wsb">alert(document.body.isDefaultNamespace(&quot;http://www.w3.org/1999/xhtml&quot;); //true </div><div class="t m0 x0 hb yfb4 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 yfb5 ff83 fs6 fc0 sc0 ls21">//假设svg中包含着对&lt;s:svg&gt;的引用 </div><div class="t m0 x0 hb yfb6 ff83 fs6 fc0 sc0 ls21 wsb">alert(svg.lookupPrefix(&quot;http://www.w3.org/2000/svg&quot;)); //&quot;s&quot; </div><div class="t m0 x0 hb yfb7 ff83 fs6 fc0 sc0 ls21 wsb">alert(svg.lookupNamespaceURI(&quot;s&quot;)); //&quot;http://www.w3.org/2000/svg&quot; </div><div class="t m0 x0 hb y1931 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1932 ff7f fs2 fc0 sc0 ls8 wseb">在取得了一个节点，但不知道该节点与文档其他元素之间关系的情况下，这些方法是很有用的。 </div><div class="t m0 x0 h47 y2022 ff7d fs2 fc0 sc0 ls2e wsb">2. Document类型的变化 </div><div class="t m0 x0 h5 y2023 ff78 fs2 fc0 sc0 ls24a ws215">DOM2级中的Document类型也发生了变化，包含了下列与命名空间有关的方法。 </div><div class="t m0 x0 h4 y2024 ff7e fs1 fc0 sc0 ls2"> createElementNS(namespaceURI, tagName)：使用给定的tagName创建一个属于命名空</div><div class="t m0 x0 hc y2025 ff7f fs2 fc0 sc0 ls2c5">间namespaceURI的新元素。 </div><div class="t m0 x0 h4 y2026 ff7e fs1 fc0 sc0 ls2"> createAttributeNS(namespaceURI, attributeName)：使用给定的attributeName创</div><div class="t m0 x0 hc y2027 ff7f fs2 fc0 sc0 ls8 wseb">建一个属于命名空间namespaceURI的新特性。 </div><div class="t m0 x0 h4 y1348 ff7e fs1 fc0 sc0 ls2"> getElementsByTagNameNS(namespaceURI, tagName)：返回属于命名空间namespaceURI</div><div class="t m0 x0 h5 y2028 ff7f fs2 fc0 sc0 ls2c">的tagName元素的NodeList。 </div><div class="t m0 x0 h5 y2029 ff7f fs2 fc0 sc0 ls8 wseb">使用这些方法时需要传入表示命名空间的URI（而不是命名空间前缀），如下面的例子所示。 </div><div class="t m0 x0 hb y202a ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y202b ff83 fs6 fc0 sc0 ls21">//创建一个新的SVG元素 </div><div class="t m0 x0 hb y202c ff83 fs6 fc0 sc0 ls21 wsb">var svg = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;,&quot;svg&quot;); </div><div class="t m0 x0 hb y202d ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y202e ff83 fs6 fc0 sc0 ls21">//创建一个属于某个命名空间的新特性 </div><div class="t m0 x0 hb y202f ff83 fs6 fc0 sc0 ls21 wsb">var att = document.createAttributeNS(&quot;http://www.somewhere.com&quot;, &quot;random&quot;); </div><div class="t m0 x0 hb y2030 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2031 ff83 fs6 fc0 sc0 ls21">//取得所有XHTML元素 </div><div class="t m0 x0 hb y2032 ff83 fs6 fc0 sc0 ls21 wsb">var elems = document.getElementsByTagNameNS(&quot;http://www.w3.org/1999/xhtml&quot;, &quot;*&quot;); </div><div class="t m0 x0 hb y2033 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 ye98 ff7f fs2 fc0 sc0 ls8 wseb">只有在文档中存在两个或多个命名空间时，这些与命名空间有关的方法才是必需的。 </div><div class="t m0 x0 h47 y2034 ff7d fs2 fc0 sc0 ls2e wsb">3. Element类型的变化 </div><div class="t m0 x0 h5 y2035 ff7f fs2 fc0 sc0 ls8">“DOM2级核心”中有关Element的变化，主要涉及操作特性。新增的方法如下。 </div><div class="t m0 x0 h4 y11b ff7e fs1 fc0 sc0 ls2"> getAttributeNS(namespaceURI,localName)：取得属于命名空间namespaceURI且名为</div><div class="t m0 x0 h5 y8b5 ff86 fs1 fc0 sc0 ls9 ws2">localName的特性。 </div><div class="t m0 x0 h4 y2036 ff7e fs1 fc0 sc0 ls2"> getAttributeNodeNS(namespaceURI,localName)：取得属于命名空间namespaceURI且</div><div class="t m0 x0 hc y2037 ff7f fs2 fc0 sc0 ls1f ws108">名为localName的特性节点。 </div><div class="t m0 x0 h4 y2038 ff7e fs1 fc0 sc0 ls2"> getElementsByTagNameNS(namespaceURI, tagName)：返回属于命名空间namespaceURI</div><div class="t m0 x0 h5 y2039 ff7f fs2 fc0 sc0 ls58">的tagName元素的NodeList。 </div><div class="t m0 x0 h4 y203a ff7e fs1 fc0 sc0 ls2"> hasAttributeNS(namespaceURI,localName)：确定当前元素是否有一个名为localName</div><div class="t m0 x0 h5 y860 ff7f fs2 fc0 sc0 ls4 ws10d">的特性，而且该特性的命名空间是namespaceURI。注意，“DOM2级核心”也增加了一个</div><div class="t m0 x0 h5 y203b ff83 fs1 fc0 sc0 ls9 ws2">hasAttribute()方法，用于不考虑命名空间的情况。 </div><div class="t m0 x0 h4 y203c ff7e fs1 fc0 sc0 ls2"> removeAttriubteNS(namespaceURI,localName)：删除属于命名空间namespaceURI且名</div><div class="t m0 x0 h5 y203d ff7f fs2 fc0 sc0 ls2c8">为localName的特性。 </div><div class="t m0 x0 h4 y203e ff7e fs1 fc0 sc0 ls8 ws134"> setAttributeNS(namespaceURI,qualifiedName,value)：设置属于命名空间namespace- </div><div class="t m0 x0 h21 y203f ff86 fs1 fc0 sc0 ls43 ws31">URI且名为qualifiedName的特性的值为value。 </div><div class="t m0 x0 h5 y2040 ff7e fs1 fc0 sc0 ls2"> setAttributeNodeNS(attNode)：设置属于命名空间namespaceURI的特性节点。 </div></div></div>
<div id="pf147" class="pf w0 h0" data-page-no="147"><div class="pc pc147 w0 h0"><div class="t m0 x2 h2 y1 ff78 fs0 fc0 sc0 ls7 ws0">12.1 DOM变化   309 </div><div class="t m0 x0 h3 y2 ff78 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff7a fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff7a fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff7a fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff7a fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff7a fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff7a fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff7a fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff7a fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff7a fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff7a fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff7a fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff7a fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff7a fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff7f fs2 fc0 sc0 ls8 wseb">除了第一个参数之外，这些方法与DOM1级中相关方法的作用相同；第一个参数始终都是一个命</div><div class="t m0 x0 h5 y4d ff7f fs2 fc0 sc0 ls8 wseb">名空间URI。 </div><div class="t m0 x0 h4e y2041 ff7d fs2 fc0 sc0 ls2e wsb">4. NamedNodeMap类型的变化 </div><div class="t m0 x0 h4 y1ed1 ff83 fs1 fc0 sc0 ls9 ws2">NamedNodeMap类型也新增了下列与命名空间有关的方法。由于特性是通过NamedNodeMap表示</div><div class="t m0 x0 h5 y6e4 ff7f fs2 fc0 sc0 ls8 wseb">的，因此这些方法多数情况下只针对特性使用。 </div><div class="t m0 x0 h4 y1ed2 ff7e fs1 fc0 sc0 ls2"> getNamedItemNS(namespaceURI,localName)：取得属于命名空间namespaceURI且名为</div><div class="t m0 x5 h5 y1ed3 ff86 fs1 fc0 sc0 ls9 ws2">localName的项。 </div><div class="t m0 x0 h4 y1aa7 ff7e fs1 fc0 sc0 ls2"> removeNamedItemNS(namespaceURI,localName)：移除属于命名空间namespaceURI且名</div><div class="t m0 x5 hc y2042 ff7f fs2 fc0 sc0 ls2c9">为localName的项。 </div><div class="t m0 x0 h5 y2043 ff7e fs1 fc0 sc0 ls2"> setNamedItemNS(node)：添加node，这个节点已经事先指定了命名空间信息。 </div><div class="t m0 x0 h5 ycbd ff7f fs2 fc0 sc0 ls8 wseb">由于一般都是通过元素访问特性，所以这些方法很少使用。 </div><div class="t m0 x0 h20 y2044 ff7d fs3 fc0 sc0 ls248 ws214">12.1.2 其他方面的变化 </div><div class="t m0 x0 h5 y1a8b ff78 fs2 fc0 sc0 ls81 ws76">DOM的其他部分在“DOM2级核心”中也发生了一些变化。这些变化与XML命名空间无关，而是</div><div class="t m0 x0 h5 y2045 ff7f fs2 fc0 sc0 ls8 wseb">更倾向于确保API的可靠性及完整性。 </div><div class="t m0 x0 h4e y2046 ff7d fs2 fc0 sc0 ls2e wsb">1. DocumentType类型的变化 </div><div class="t m0 x0 h5 y2047 ff83 fs1 fc0 sc0 ls9 ws2">DocumentType类型新增了3个属性：publicId、systemId和internalSubset。其中，前两</div><div class="t m0 x0 h5 y2048 ff7f fs2 fc0 sc0 ls8 wseb">个属性表示的是文档类型声明中的两个信息段，这两个信息段在DOM1级中是没有办法访问到的。以</div><div class="t m0 x0 h5 y2049 ff7f fs2 fc0 sc0 ls8 wseb">下面的HTML文档类型声明为例。 </div><div class="t m0 x5 hb y204a ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y204b ff83 fs6 fc0 sc0 ls21 wsb">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; </div><div class="t m0 x0 hb y204c ff83 fs6 fc0 sc0 ls21 wsb">    &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt; </div><div class="t m0 x5 hb y204d ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y204e ff7f fs2 fc0 sc0 ls8 wseb">对这个文档类型声明而言，publicId是&quot;-//W3C//DTD HTML 4.01//EN&quot;，而systemId是&quot;http: </div><div class="t m0 x0 h21 y204f ff83 fs1 fc0 sc0 ls9 ws2">//www.w3.org/TR/html4/strict.dtd&quot;。在支持DOM2级的浏览器中，应该可以运行下列代码。 </div><div class="t m0 x5 hb y2050 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2051 ff83 fs6 fc0 sc0 ls21 wsb">alert(document.doctype.publicId); </div><div class="t m0 x0 hb y2052 ff83 fs6 fc0 sc0 ls21 wsb">alert(document.doctype.systemId); </div><div class="t m0 x5 hb y2053 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y2054 ff7f fs2 fc0 sc0 ls8 wseb">实际上，很少需要在网页中访问此类信息。 </div><div class="t m0 x0 hc y2055 ff7f fs2 fc0 sc0 ls1f ws108">最后一个属性internalSubset，用于访问包含在文档类型声明中的额外定义，以下面的代码为例。 </div><div class="t m0 x5 hb y2056 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2057 ff83 fs6 fc0 sc0 ls21 wsb">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; </div><div class="t m0 x0 hb y2058 ff83 fs6 fc0 sc0 ls21 wsb">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot; </div><div class="t m0 x0 hb y2059 ff83 fs6 fc0 sc0 ls21 wsb">[&lt;!ELEMENT name (#PCDATA)&gt;] &gt; </div><div class="t m0 x5 hb y205a ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y681 ff7f fs2 fc0 sc0 ls1f ws108">访问document.doctype.internalSubset将得到&quot;&lt;!ELEMENT name (#PCDATA)&gt;&quot;。这种内部</div><div class="t m0 x0 h5 y682 ff7f fs2 fc0 sc0 ls1f">子集（internal subset）在HTML中极少用到，在XML中可能会更常见一些。 </div><div class="t m0 x0 h47 y205b ff7d fs2 fc0 sc0 ls2e wsb">2. Document类型的变化 </div><div class="t m0 x0 h4 y205c ff83 fs1 fc0 sc0 ls9 ws2">Document类型的变化中唯一与命名空间无关的方法是importNode()。这个方法的用途是从一个</div><div class="t m0 x0 h4 y15f9 ff7f fs2 fc0 sc0 ls8 wseb">文档中取得一个节点，然后将其导入到另一个文档，使其成为这个文档结构的一部分。需要注意的是，</div><div class="t m0 x0 h1c y205d ff7f fs2 fc0 sc0 ls8 wseb">每个节点都有一个ownerDocument属性，表示所属的文档。如果调用appendChild()时传入的节点</div><div class="t m0 x0 h1e y205e ff7f fs2 fc0 sc0 ls8 wseb">属于不同的文档（ownerDocument属性的值不一样），则会导致错误。但在调用importNode()时传入</div><div class="t m0 x0 h5 y205f ff7f fs2 fc0 sc0 ls8 wseb">不同文档的节点则会返回一个新节点，这个新节点的所有权归当前文档所有。 </div><div class="t m0 x0 h1e y2060 ff7f fs2 fc0 sc0 ls8 wseb">说起来，importNode()方法与Element的cloneNode()方法非常相似，它接受两个参数：要复</div></div></div>
<div id="pf148" class="pf w0 h0" data-page-no="148"><div class="pc pc148 w0 h0"><div class="t m0 x0 h2 y1 ff78 fs0 fc0 sc0 ls7 ws0">310  第12章 DOM2和DOM3 </div><div class="t m0 x0 h3 y2 ff78 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ff7f fs2 fc0 sc0 ls8 wseb">制的节点和一个表示是否复制子节点的布尔值。返回的结果是原来节点的副本，但能够在当前文档中使</div><div class="t m0 x0 h5 y4d ff7f fs2 fc0 sc0 ls8 wseb">用。来看下面的例子： </div><div class="t m0 x0 hb y2d8 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2d9 ff83 fs6 fc0 sc0 ls21 wsb">var newNode = document.importNode(oldNode, true); //导入节点及其所有子节点 </div><div class="t m0 x0 hb y2da ff83 fs6 fc0 sc0 ls21 wsb">document.body.appendChild(newNode); </div><div class="t m0 x0 hb y2061 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y2062 ff7f fs2 fc0 sc0 ls8 wseb">这个方法在HTML文档中并不常用，在XML文档中用得比较多（更多讨论请参见第18 章）。 </div><div class="t m0 x0 h5 y118c ff7f fs2 fc0 sc0 ls8">“DOM2级视图”模块添加了一个名为defaultView的属性，其中保存着一个指针，指向拥有给</div><div class="t m0 x0 h4 y2063 ff7f fs2 fc0 sc0 ls8 wseb">定文档的窗口（或框架）。除此之外，“视图”规范没有提供什么时候其他视图可用的信息，因而这是唯</div><div class="t m0 x0 hc y2064 ff7f fs2 fc0 sc0 ls8 wseb">一一个新增的属性。除IE之外的所有浏览器都支持defaultView属性。在 IE中有一个等价的属性名</div><div class="t m0 x0 hc ya87 ff7f fs2 fc0 sc0 ls2ca">叫parentWindow（Opera也支持这个属性）。因此，要确定文档的归属窗口，可以使用以下代码。 </div><div class="t m0 x0 hb y2065 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2066 ff83 fs6 fc0 sc0 ls21 wsb">var parentWindow = document.defaultView || document.parentWindow; </div><div class="t m0 x0 hb y2067 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y19bd ff7f fs2 fc0 sc0 ls5f ws10b">除了上述一个方法和一个属性之外，“DOM2级核心”还为document.implementation对象规定了</div><div class="t m0 x0 h4 y19be ff7f fs2 fc0 sc0 ls5f ws10b">两个新方法：createDocumentType()和createDocument()。前者用于创建一个新的DocumentType</div><div class="t m0 x0 h5 y1193 ff7f fs2 fc0 sc0 ls8 wseb">节点，接受3个参数：文档类型名称、publicId、systemId。例如，下列代码会创建一个新的HTML </div><div class="t m0 x0 h5 y19c0 ff78 fs2 fc0 sc0 ls7a ws5b">4.01 Strict文档类型。 </div><div class="t m0 x0 hb y2068 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2069 ff83 fs6 fc0 sc0 ls21 wsb">var doctype = document.implementation.createDocumentType(&quot;html&quot;, </div><div class="t m0 x0 hb y206a ff83 fs6 fc0 sc0 ls21 wsb">                  &quot;-//W3C//DTD HTML 4.01//EN&quot;, </div><div class="t m0 x0 hb y206b ff83 fs6 fc0 sc0 ls21 wsb">                  &quot;http://www.w3.org/TR/html4/strict.dtd&quot;); </div><div class="t m0 x0 hb y206c ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y206d ff7f fs2 fc0 sc0 ls8 wseb">由于既有文档的文档类型不能改变，因此createDocumentType()只在创建新文档时有用；创建</div><div class="t m0 x0 h5 y24a ff7f fs2 fc0 sc0 ls5 wsec">新文档时需要用到createDocument()方法。这个方法接受3个参数：针对文档中元素的 namesp- </div><div class="t m0 x0 h21 y206e ff83 fs1 fc0 sc0 ls9 ws2">aceURI、文档元素的标签名、新文档的文档类型。下面这行代码将会创建一个空的新XML文档。 </div><div class="t m0 x0 hb y206f ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2070 ff83 fs6 fc0 sc0 ls21 wsb">var doc = document.implementation.createDocument(&quot;&quot;, &quot;root&quot;, null); </div><div class="t m0 x0 hb y2071 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y19f0 ff7f fs2 fc0 sc0 ls5 wsec">这行代码会创建一个没有命名空间的新文档，文档元素为&lt;root&gt;，而且没有指定文档类型。要想</div><div class="t m0 x0 h5 y2072 ff7f fs2 fc0 sc0 ls8 wseb">创建一个XHTML文档，可以使用以下代码。 </div><div class="t m0 x0 hb y2073 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2074 ff83 fs6 fc0 sc0 ls21 wsb">var doctype = document.implementation.createDocumentType(&quot;html&quot;, </div><div class="t m0 x0 hb y2075 ff83 fs6 fc0 sc0 ls21 wsb">                  &quot; -//W3C//DTD XHTML 1.0 Strict//EN&quot;, </div><div class="t m0 x0 hb y2076 ff83 fs6 fc0 sc0 ls21 wsb">                  &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;); </div><div class="t m0 x0 hb y2077 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2078 ff83 fs6 fc0 sc0 ls21 wsb">var doc = document.implementation.createDocument(&quot;http://www.w3.org/1999/xhtml&quot;,  </div><div class="t m0 x5 hb y2079 ff83 fs6 fc0 sc0 ls21 wsb">&quot;html&quot;, doctype); </div><div class="t m0 x0 hb y207a ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y207b ff7f fs2 fc0 sc0 ls8 wseb">这样，就创建了一个带有适当命名空间和文档类型的新XHTML文档。不过，新文档当前只有文档</div><div class="t m0 x0 hc y207c ff7f fs2 fc0 sc0 ls8 wseb">元素&lt;html&gt;，剩下的所有元素都需要继续添加。 </div><div class="t m0 x0 h5 y207d ff7f fs2 fc0 sc0 ls8">“DOM2级HTML”模块也为document.implementation新增了一个方法，名叫createHTML- </div><div class="t m0 x0 h5 y207e ff83 fs1 fc0 sc0 ls9 ws2">Document()。这个方法的用途是创建一个完整的HTML文档，包括&lt;html&gt;、&lt;head&gt;、&lt;title&gt;和</div><div class="t m0 x0 h4 y207f ff83 fs1 fc0 sc0 ls9 ws2">&lt;body&gt;元素。这个方法只接受一个参数，即新创建文档的标题（放在&lt;title&gt;元素中的字符串），返回</div><div class="t m0 x0 h5 y2080 ff7f fs2 fc0 sc0 ls8 wseb">新的HTML文档，如下所示： </div><div class="t m0 x0 hb y2081 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2082 ff83 fs6 fc0 sc0 ls21 wsb">var htmldoc = document.implementation.createHTMLDocument(&quot;New Doc&quot;); </div><div class="t m0 x0 hb y2083 ff83 fs6 fc0 sc0 ls21 wsb">alert(htmldoc.title);            //&quot;New Doc&quot; </div><div class="t m0 x0 hb y2084 ff83 fs6 fc0 sc0 ls21 wsb">alert(typeof htmldoc.body);      //&quot;object&quot; </div><div class="t m0 x0 hb y2085 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf y2086 ff85 fs2 fc0 sc0 ls1b wsb">CreateHTMLDocumentExample.htm </div></div></div>
<div id="pf149" class="pf w0 h0" data-page-no="149"><div class="pc pc149 w0 h0"><div class="t m0 x2 h2 y1 ff78 fs0 fc0 sc0 ls7 ws0">12.1 DOM变化   311 </div><div class="t m0 x0 h3 y2 ff78 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff7a fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff7a fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff7a fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff7a fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff7a fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff7a fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff7a fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff7a fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff7a fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff7a fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff7a fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff7a fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff7a fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h4 y3 ff7f fs2 fc0 sc0 ls8 wseb">通过调用createHTMLDocument()创建的这个文档，是HTMLDocument类型的实例，因而具有该</div><div class="t m0 x0 hc y4d ff7f fs2 fc0 sc0 ls8 wseb">类型的所有属性和方法，包括title和body属性。只有Opera和Safari 支持这个方法。 </div><div class="t m0 x0 h47 y17cd ff7d fs2 fc0 sc0 ls2e wsb">3. Node类型的变化 </div><div class="t m0 x0 h5 y1ed1 ff83 fs1 fc0 sc0 ls9 ws2">Node类型中唯一与命名空间无关的变化，就是添加了isSupported()方法。与DOM1级为docum- </div><div class="t m0 x0 h42 y2087 ff83 fs1 fc0 sc0 ls9 ws2">ent.implementation引入的hasFeature()方法类似，isSupported()方法用于确定当前节点具有</div><div class="t m0 x0 h4 y1ed2 ff7f fs2 fc0 sc0 ls8 wseb">什么能力。这个方法也接受相同的两个参数：特性名和特性版本号。如果浏览器实现了相应特性，而且</div><div class="t m0 x0 hc y2088 ff7f fs2 fc0 sc0 ls8 wseb">能够基于给定节点执行该特性，isSupported()就返回true。来看一个例子： </div><div class="t m0 x5 hb yd44 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yd45 ff83 fs6 fc0 sc0 ls21 wsb">if (document.body.isSupported(&quot;HTML&quot;, &quot;2.0&quot;)){ </div><div class="t m0 x0 h16 yd46 ff83 fs6 fc0 sc0 ls21 wsb">    //执行只有&quot;DOM2级HTML&quot;才支持的操作 </div><div class="t m0 x0 hb yd47 ff83 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h4 y3d7 ff7f fs2 fc0 sc0 ls127 ws226">由于不同实现在决定对什么特性返回true或false时并不一致，这个方法同样也存在与hasFeature()</div><div class="t m0 x0 h5 y2089 ff7f fs2 fc0 sc0 ls8 wseb">方法相同的问题。为此，我们建议在确定某个特性是否可用时，最好还是使用能力检测。 </div><div class="t m0 x0 h5 y208a ff78 fs2 fc0 sc0 ls2ce ws297">DOM3级引入了两个辅助比较节点的方法：isSameNode()和isEqualNode()。这两个方法都接受</div><div class="t m0 x0 h1e y208b ff7f fs2 fc0 sc0 ls42 wsf0">一个节点参数，并在传入节点与引用的节点相同或相等时返回true。所谓相同，指的是两个节点引用的</div><div class="t m0 x0 h1e y208c ff7f fs2 fc0 sc0 ls42 wsf0">是同一个对象。所谓相等，指的是两个节点是相同的类型，具有相等的属性（nodeName、nodeValue，</div><div class="t m0 x0 hc y208d ff7f fs2 fc0 sc0 ls44 wsef">等等），而且它们的attributes和childNodes属性也相等（相同位置包含相同的值）。来看一个例子。 </div><div class="t m0 x5 hb y208e ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y208f ff83 fs6 fc0 sc0 ls21 wsb">var div1 = document.createElement(&quot;div&quot;); </div><div class="t m0 x0 hb y2090 ff83 fs6 fc0 sc0 ls21 wsb">div1.setAttribute(&quot;class&quot;, &quot;box&quot;); </div><div class="t m0 x0 hb y2091 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2092 ff83 fs6 fc0 sc0 ls21 wsb">var div2 = document.createElement(&quot;div&quot;); </div><div class="t m0 x0 hb y2093 ff83 fs6 fc0 sc0 ls21 wsb">div2.setAttribute(&quot;class&quot;, &quot;box&quot;); </div><div class="t m0 x0 hb y2094 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2095 ff83 fs6 fc0 sc0 ls21 wsb">alert(div1.isSameNode(div1));  //true </div><div class="t m0 x0 hb y2096 ff83 fs6 fc0 sc0 ls21 ws298">alert(div1.isEqualNode(div2)); //true </div><div class="t m0 x0 hb y2097 ff83 fs6 fc0 sc0 ls21 wsb">alert(div1.isSameNode(div2));  //false </div><div class="t m0 x5 hb y2098 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1cee ff7f fs2 fc0 sc0 ls8 wseb">这里创建了两个具有相同特性的&lt;div&gt;元素。这两个元素相等，但不相同。 </div><div class="t m0 x0 h5 y85a ff78 fs2 fc0 sc0 ls24a ws215">DOM3级还针对为DOM节点添加额外数据引入了新方法。其中，setUserData()方法会将数据指</div><div class="t m0 x0 h5 y19f3 ff7f fs2 fc0 sc0 ls8 wseb">定给节点，它接受3个参数：要设置的键、实际的数据（可以是任何数据类型）和处理函数。以下代码</div><div class="t m0 x0 h5 y2099 ff7f fs2 fc0 sc0 ls8 wseb">可以将数据指定给一个节点。 </div><div class="t m0 x5 hb y209a ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y209b ff83 fs6 fc0 sc0 ls21 wsb">document.body.setUserData(&quot;name&quot;, &quot;Nicholas&quot;, function(){}); </div><div class="t m0 x5 hb y209c ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1611 ff7f fs2 fc0 sc0 ls8 wseb">然后，使用getUserData()并传入相同的键，就可以取得该数据，如下所示： </div><div class="t m0 x5 hb y209d ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y209e ff83 fs6 fc0 sc0 ls21 wsb">var value = document.body.getUserData(&quot;name&quot;); </div><div class="t m0 x5 hb y209f ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y20a0 ff7f fs2 fc0 sc0 ls8 wseb">传入setUserData()中的处理函数会在带有数据的节点被复制、删除、重命名或引入一个文档时</div><div class="t m0 x0 h5 y20a1 ff7f fs2 fc0 sc0 ls8 wseb">调用，因而你可以事先决定在上述操作发生时如何处理用户数据。处理函数接受5个参数：表示操作类</div><div class="t m0 x0 h5 y20a2 ff7f fs2 fc0 sc0 ls8 wseb">型的数值（1表示复制，2表示导入，3表示删除，4表示重命名）、数据键、数据值、源节点和目标节</div><div class="t m0 x0 h1c y20a3 ff7f fs2 fc0 sc0 ls8 wseb">点。在删除节点时，源节点是null；除在复制节点时，目标节点均为null。在函数内部，你可以决定</div><div class="t m0 x0 h5 y20a4 ff7f fs2 fc0 sc0 ls8 wseb">如何存储数据。来看下面的例子。 </div><div class="t m0 x5 hb y20a5 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y20a6 ff83 fs6 fc0 sc0 ls21 wsb">var div = document.createElement(&quot;div&quot;); </div><div class="t m0 x0 hb y20a7 ff83 fs6 fc0 sc0 ls21 wsb">div.setUserData(&quot;name&quot;, &quot;Nicholas&quot;, function(operation, key, value, src, dest){ </div><div class="t m0 x0 hb y20a8 ff83 fs6 fc0 sc0 ls21 wsb">    if (operation == 1){ </div><div class="t m0 x0 hb y20a9 ff83 fs6 fc0 sc0 ls21 wsb">        dest.setUserData(key, value, function(){});   } </div></div></div>
<div id="pf14a" class="pf w0 h0" data-page-no="14a"><div class="pc pc14a w0 h0"><div class="t m0 x0 h2 y1 ff78 fs0 fc0 sc0 ls7 ws0">312  第12章 DOM2和DOM3 </div><div class="t m0 x0 h3 y2 ff78 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y8f5 ff83 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 hb y8f6 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y8f7 ff83 fs6 fc0 sc0 ls21 wsb">var newDiv = div.cloneNode(true); </div><div class="t m0 x0 hb y8f8 ff83 fs6 fc0 sc0 ls21 wsb">alert(newDiv.getUserData(&quot;name&quot;));      //&quot;Nicholas&quot; </div><div class="t m0 x0 hb y20aa ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y20ab ff85 fs2 fc0 sc0 ls2b wsb">UserDataExample.htm </div><div class="t m0 x0 h4 y20ac ff7f fs2 fc0 sc0 ls8 wseb">这里，先创建了一个&lt;div&gt;元素，然后又为它添加了一些数据（用户数据）。在使用cloneNode()</div><div class="t m0 x0 h4 y20ad ff7f fs2 fc0 sc0 ls24 wsf5">复制这个元素时，就会调用处理函数，从而将数据自动复制到了副本节点。结果在通过副本节点调用</div><div class="t m0 x0 h5 y20ae ff83 fs1 fc0 sc0 ls9 ws2">getUserData()时，就会返回与原始节点中包含的相同的值。 </div><div class="t m0 x0 h3c y20af ff7d fs2 fc0 sc0 ls2e wsb">4. 框架的变化 </div><div class="t m0 x0 hb8 y20b0 ff7f fs2 fc0 sc0 ls5f ws10b">框架和内嵌框架分别用HTMLFrameElement和HTMLIFrameElement表示，它们在DOM2级中都有</div><div class="t m0 x0 h1e y20b1 ff7f fs2 fc0 sc0 ls5f ws10b">了一个新属性，名叫contentDocument。这个属性包含一个指针，指向表示框架内容的文档对象。在此</div><div class="t m0 x0 h5 y20b2 ff7f fs2 fc0 sc0 ls5f ws10b">之前，无法直接通过元素取得这个文档对象（只能使用frames集合）。可以像下面这样使用这个属性。 </div><div class="t m0 x0 hb y20b3 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1aac ff83 fs6 fc0 sc0 ls21 wsb">var iframe = document.getElementById(&quot;myIframe&quot;); </div><div class="t m0 x0 h36 y20b4 ff83 fs6 fc0 sc0 ls21 wsb">var iframeDoc = iframe.contentDocument;     //在IE8以前的版本中无效 </div><div class="t m0 x0 hb y20b5 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y20b6 ff85 fs2 fc0 sc0 ls1b wsb">IFrameElementExample.htm </div><div class="t m0 x0 h5 y20b7 ff7f fs2 fc0 sc0 ls8 wseb">由于contentDocument属性是Document 类型的实例，因此可以像使用其他HTML文档一样使</div><div class="t m0 x0 h5 y20b8 ff7f fs2 fc0 sc0 ls8 wseb">用它，包括所有属性和方法。Opera、Firefox、Safari和Chrome支持这个属性。IE8之前不支持框架中</div><div class="t m0 x0 h1c y20b9 ff7f fs2 fc0 sc0 ls2cf">的contentDocument属性，但支持一个名叫contentWindow的属性，该属性返回框架的window对</div><div class="t m0 x0 h4 y20ba ff7f fs2 fc0 sc0 ls8 wseb">象，而这个window对象又有一个document属性。因此，要想在上述所有浏览器中访问内嵌框架的文</div><div class="t m0 x0 h5 y20bb ff7f fs2 fc0 sc0 ls8 wseb">档对象，可以使用下列代码。 </div><div class="t m0 x0 hb y20bc ff83 fs6 fc0 sc0 ls21 wsb">var iframe = document.getElementById(&quot;myIframe&quot;); </div><div class="t m0 x0 hb y20bd ff83 fs6 fc0 sc0 ls21 wsb">var iframeDoc = iframe.contentDocument || iframe.contentWindow.document; </div><div class="t m0 x0 hb y20be ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y19f1 ff85 fs2 fc0 sc0 ls2b wsb">IFrameElementExample2.htm </div><div class="t m0 x0 h5 y189b ff7f fs2 fc0 sc0 ls8 wseb">所有浏览器都支持contentWindow属性。 </div><div class="t m0 x5 ha y20bf ff79 fs2 fc0 sc0 ls8 ws14">访问框架或内嵌框架的文档对象要受到跨域安全策略的限制。如果某个框架中的</div><div class="t m0 x0 ha y20c0 ff79 fs2 fc0 sc0 ls8 ws14">页面来自其他域或不同子域，或者使用了不同的协议，那么要访问这个框架的文档对</div><div class="t m0 x0 h5 y20c1 ff79 fs2 fc0 sc0 ls8 ws14">象就会导致错误。 </div><div class="t m0 x0 hd y419 ff7d fs7 fc0 sc0 ls245">12.2 样式 </div><div class="t m0 x0 h5 y1ecf ff7f fs2 fc0 sc0 ls3b">在HTML中定义样式的方式有3种：通过&lt;link/&gt;元素包含外部样式表文件、使用&lt;style/&gt;元素</div><div class="t m0 x0 hc y20c2 ff7f fs2 fc0 sc0 ls44 wsef">定义嵌入式样式，以及使用style特性定义针对特定元素的样式。“DOM2级样式”模块围绕这3种应用</div><div class="t m0 x0 h5 y20c3 ff7f fs2 fc0 sc0 ls1f ws108">样式的机制提供了一套API。要确定浏览器是否支持DOM2级定义的CSS能力，可以使用下列代码。 </div><div class="t m0 x0 hb y20c4 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y20c5 ff83 fs6 fc0 sc0 ls21 wsb">var supportsDOM2CSS = document.implementation.hasFeature(&quot;CSS&quot;, &quot;2.0&quot;); </div><div class="t m0 x0 hb y20c6 ff83 fs6 fc0 sc0 ls21 wsb">var supportsDOM2CSS2 = document.implementation.hasFeature(&quot;CSS2&quot;, &quot;2.0&quot;); </div><div class="t m0 x0 hb y20c7 ff83 fs6 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf14b" class="pf w0 h0" data-page-no="14b"><div class="pc pc14b w0 h0"><div class="t m0 x2 h2 y1 ff78 fs0 fc0 sc0 ls7 ws0">12.2 样式  313 </div><div class="t m0 x0 h3 y2 ff78 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff7a fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff7a fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff7a fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff7a fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff7a fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff7a fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff7a fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff7a fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff7a fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff7a fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff7a fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff7a fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff7a fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h20 y12d ff7d fs3 fc0 sc0 ls248 ws214">12.2.1 访问元素的样式 </div><div class="t m0 x0 h5 y12e ff7f fs2 fc0 sc0 ls8 wseb">任何支持style特性的HTML元素在JavaScript 中都有一个对应的style属性。这个style对象</div><div class="t m0 x0 h5 y12f ff7f fs2 fc0 sc0 lsd9">是CSSStyleDeclaration的实例，包含着通过HTML的style特性指定的所有样式信息，但不包含</div><div class="t m0 x0 hc y130 ff7f fs2 fc0 sc0 ls8 wseb">与外部样式表或嵌入样式表经层叠而来的样式。在style特性中指定的任何CSS属性都将表现为这个</div><div class="t m0 x0 h5 y1c95 ff83 fs1 fc0 sc0 ls9 ws2">style对象的相应属性。对于使用短划线（分隔不同的词汇，例如background-image）的CSS属性</div><div class="t m0 x0 h5 y1c96 ff7f fs2 fc0 sc0 ls8 wseb">名，必须将其转换成驼峰大小写形式，才能通过JavaScript来访问。下表列出了几个常见的CSS属性及</div><div class="t m0 x0 hc y20c8 ff7f fs2 fc0 sc0 ls8 wseb">其在style对象中对应的属性名。 </div><div class="t m0 x5 hb y20c9 ff83 fs6 fc0 sc0 ls8 wsb">  </div><div class="t m0 x1 h31 y20ca ff7d fs6 fc0 sc0 ls1aa ws29c">CSS属性 JavaScript属性 </div><div class="t m0 x5 h32 y20cb ff83 fsc fc0 sc0 lsa8 ws2a0">background-image style.backgroundImage </div><div class="t m0 x5 h32 y20cc ff83 fsc fc0 sc0 lsa8 ws2a1">color style.color </div><div class="t m0 x5 h32 y20cd ff83 fsc fc0 sc0 lsa8 ws2a2">display style.display </div><div class="t m0 x5 h32 y2bb ff83 fsc fc0 sc0 lsa8 ws2a3">font-family style.fontFamily </div><div class="t m0 x5 hb y20ce ff83 fs6 fc0 sc0 ls8 wsb">  </div><div class="t m0 x0 h5 y20cf ff7f fs2 fc0 sc0 ls8 wseb">多数情况下，都可以通过简单地转换属性名的格式来实现转换。其中一个不能直接转换的CSS属性</div><div class="t m0 x0 hc y20d0 ff7f fs2 fc0 sc0 ls8 wseb">就是float。由于float是JavaScript中的保留字，因此不能用作属性名。“DOM2级样式”规范规定</div><div class="t m0 x0 hc y20d1 ff7f fs2 fc0 sc0 ls8 wseb">样式对象上相应的属性名应该是cssFloat；Firefox、Safari、Opera和Chrome都支持这个属性，而IE</div><div class="t m0 x0 h5 y20d2 ff7f fs2 fc0 sc0 ls8 wseb">支持的则是styleFloat。 </div><div class="t m0 x0 h5 y20d3 ff7f fs2 fc0 sc0 ls42 wsf0">只要取得一个有效的DOM元素的引用，就可以随时使用JavaScript为其设置样式。以下是几个例子。 </div><div class="t m0 x5 hb y20d4 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y20d5 ff83 fs6 fc0 sc0 ls21 wsb">var myDiv = document.getElementById(&quot;myDiv&quot;); </div><div class="t m0 x0 hb y20d6 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y20d7 ff83 fs6 fc0 sc0 ls21">//设置背景颜色 </div><div class="t m0 x0 hb y20d8 ff83 fs6 fc0 sc0 ls21 wsb">myDiv.style.backgroundColor = &quot;red&quot;; </div><div class="t m0 x0 hb y20d9 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y20da ff83 fs6 fc0 sc0 ls21">//改变大小 </div><div class="t m0 x0 hb y20db ff83 fs6 fc0 sc0 ls21 wsb">myDiv.style.width = &quot;100px&quot;; </div><div class="t m0 x0 hb y20dc ff83 fs6 fc0 sc0 ls21 wsb">myDiv.style.height = &quot;200px&quot;; </div><div class="t m0 x0 hb y20dd ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y20de ff83 fs6 fc0 sc0 ls21">//指定边框 </div><div class="t m0 x0 hb y20df ff83 fs6 fc0 sc0 ls21 wsb">myDiv.style.border = &quot;1px solid black&quot;; </div><div class="t m0 x0 h5 y20e0 ff7f fs2 fc0 sc0 ls8 wseb">在以这种方式改变样式时，元素的外观会自动被更新。 </div><div class="t m0 x5 ha y20e1 ff79 fs2 fc0 sc0 ls30">在标准模式下，所有度量值都必须指定一个度量单位。在混杂模式下，可以将</div><div class="t m0 x5 ha yf63 ff83 fs1 fc0 sc0 ls9 ws2">style.width设置为&quot;20&quot;，浏览器会假设它是&quot;20px&quot;；但在标准模式下，将</div><div class="t m0 x5 ha y46d ff83 fs1 fc0 sc0 ls9 ws2">style.width设置为&quot;20&quot;会导致被忽略——因为没有度量单位。在实践中，最好始</div><div class="t m0 x5 h5 y20e2 ff79 fs2 fc0 sc0 ls8 ws14">终都指定度量单位。 </div><div class="t m0 x0 h44 y20e3 ff7f fs2 fc0 sc0 ls8 wseb">通过style对象同样可以取得在style特性中指定的样式。以下面的 HTML代码为例。 </div><div class="t m0 x5 hb y20e4 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y20e5 ff83 fs6 fc0 sc0 ls21 wsb">&lt;div id=&quot;myDiv&quot; style=&quot;background-color:blue; width:10px; height:25px&quot;&gt;&lt;/div&gt; </div><div class="t m0 x5 hb y20e6 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y20e7 ff7f fs2 fc0 sc0 ls2c">在style特性中指定的样式信息可以通过下列代码取得。 </div><div class="t m0 x5 hb y20e8 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y20e9 ff83 fs6 fc0 sc0 ls21 wsb">alert(myDiv.style.backgroundColor);       //&quot;blue&quot; </div><div class="t m0 x0 hb y20ea ff83 fs6 fc0 sc0 ls21 wsb">alert(myDiv.style.width);                 //&quot;10px&quot; </div><div class="t m0 x0 hb y20eb ff83 fs6 fc0 sc0 ls21 wsb">alert(myDiv.style.height);                //&quot;25px&quot; </div><div class="t m0 x5 hb y20ec ff83 fs6 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf14c" class="pf w0 h0" data-page-no="14c"><div class="pc pc14c w0 h0"><div class="t m0 x0 h2 y1 ff78 fs0 fc0 sc0 ls7 ws0">314  第12章 DOM2和DOM3 </div><div class="t m0 x0 h3 y2 ff78 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ff7f fs2 fc0 sc0 ls8 wseb">如果没有为元素设置style特性，那么style对象中可能会包含一些默认的值，但这些值并不能</div><div class="t m0 x0 h5 y4d ff7f fs2 fc0 sc0 ls8 wseb">准确地反映该元素的样式信息。 </div><div class="t m0 x0 h3c y2041 ff7d fs2 fc0 sc0 ls79 ws7e">1. DOM样式属性和方法 </div><div class="t m0 x0 h5 y20ed ff7f fs2 fc0 sc0 ls8">“DOM2级样式”规范还为style对象定义了一些属性和方法。这些属性和方法在提供元素的style</div><div class="t m0 x0 h5 y1bd7 ff7f fs2 fc0 sc0 ls8 wseb">特性值的同时，也可以修改样式。下面列出了这些属性和方法。 </div><div class="t m0 x0 h5 y1ed2 ff7e fs1 fc0 sc0 ls2"> cssText：如前所述，通过它能够访问到style特性中的CSS代码。 </div><div class="t m0 x0 h5 y1ed3 ff7e fs1 fc0 sc0 ls2"> length：应用给元素的CSS属性的数量。 </div><div class="t m0 x0 h5 y1aa7 ff7e fs1 fc0 sc0 ls2"> parentRule：表示CSS信息的CSSRule对象。本节后面将讨论CSSRule 类型。 </div><div class="t m0 x0 h5 yf6c ff7e fs1 fc0 sc0 ls2"> getPropertyCSSValue(propertyName)：返回包含给定属性值的CSSValue对象。 </div><div class="t m0 x0 h4 y2043 ff7e fs1 fc0 sc0 ls2"> getPropertyPriority(propertyName)：如果给定的属性使用了!important设置，则返回</div><div class="t m0 x0 h5 y20ee ff83 fs1 fc0 sc0 ls9 ws2">&quot;important&quot;；否则，返回空字符串。 </div><div class="t m0 x0 h5 y20ef ff7e fs1 fc0 sc0 ls2"> getPropertyValue(propertyName)：返回给定属性的字符串值。 </div><div class="t m0 x0 h5 ycbf ff7e fs1 fc0 sc0 ls2"> item(index)：返回给定位置的CSS属性的名称。 </div><div class="t m0 x0 h5 y20f0 ff7e fs1 fc0 sc0 ls2"> removeProperty(propertyName)：从样式中删除给定属性。 </div><div class="t m0 x0 h4 y1349 ff7e fs1 fc0 sc0 ls2"> setProperty(propertyName,value,priority)：将给定属性设置为相应的值，并加上优先</div><div class="t m0 x0 hc y20f1 ff7f fs2 fc0 sc0 ls8 wseb">权标志（&quot;important&quot;或者一个空字符串）。 </div><div class="t m0 x0 hc y20f2 ff7f fs2 fc0 sc0 ls8 wseb">通过cssText属性可以访问style特性中的CSS代码。在读取模式下，cssText返回浏览器对style</div><div class="t m0 x0 h5 y485 ff7f fs2 fc0 sc0 ls8 wseb">特性中CSS代码的内部表示。在写入模式下，赋给cssText的值会重写整个style 特性的值；也就是</div><div class="t m0 x0 h4 y20f3 ff7f fs2 fc0 sc0 ls8 wseb">说，以前通过style特性指定的样式信息都将丢失。例如，如果通过style特性为元素设置了边框，</div><div class="t m0 x0 h1e y20f4 ff7f fs2 fc0 sc0 ls8 wseb">然后再以不包含边框的规则重写cssText，那么就会抹去元素上的边框。下面是使用cssText属性的</div><div class="t m0 x0 h5 y20f5 ff7f fs2 fc0 sc0 ls8 wseb">一个例子。 </div><div class="t m0 x0 hb y20f6 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y20f7 ff83 fs6 fc0 sc0 ls21 wsb">myDiv.style.cssText = &quot;width: 25px; height: 100px; background-color: green&quot;; </div><div class="t m0 x0 hb y20f8 ff83 fs6 fc0 sc0 ls21 wsb">alert(myDiv.style.cssText); </div><div class="t m0 x0 hb y20f9 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y341 ff7f fs2 fc0 sc0 ls8 wseb">设置cssText是为元素应用多项变化最快捷的方式，因为可以一次性地应用所有变化。 </div><div class="t m0 x0 h5 y20fa ff7f fs2 fc0 sc0 ls8 wseb">设计length属性的目的，就是将其与item()方法配套使用，以便迭代在元素中定义的CSS属性。</div><div class="t m0 x0 h1e y20fb ff7f fs2 fc0 sc0 ls8 wseb">在使用length和item()时，style 对象实际上就相当于一个集合，都可以使用方括号语法来代替</div><div class="t m0 x0 h5 y20fc ff83 fs1 fc0 sc0 ls9 ws2">item()来取得给定位置的CSS属性，如下面的例子所示。 </div><div class="t m0 x0 hb y20fd ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y20fe ff83 fs6 fc0 sc0 ls21 wsb">for (var i=0, len=myDiv.style.length; i &lt; len; i++){ </div><div class="t m0 x0 h16 y20ff ff83 fs6 fc0 sc0 ls21 wsb">    alert(myDiv.style[i]); //或者myDiv.style.item(i) </div><div class="t m0 x0 hb y2100 ff83 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h5 y2101 ff7f fs2 fc0 sc0 ls8 wseb">无论是使用方括号语法还是使用item()方法，都可以取得CSS属性名（&quot;background-color&quot;，</div><div class="t m0 x0 h1e y2102 ff7f fs2 fc0 sc0 ls8 wseb">不是&quot;backgroundColor&quot;）。然后，就可以在getPropertyValue()中使用取得的属性名进一步取得</div><div class="t m0 x0 h5 y2103 ff7f fs2 fc0 sc0 ls8 wseb">属性的值，如下所示。 </div><div class="t m0 x0 hb y1ac2 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y2104 ff84 fs6 fc0 sc0 ls21 wsb">var prop, value, i, len;  </div><div class="t m0 x0 hb y2105 ff83 fs6 fc0 sc0 ls21 wsb">for (i=0, len=myDiv.style.length; i &lt; len; i++){ </div><div class="t m0 x0 h16 y2106 ff84 fs6 fc0 sc0 ls21 wsb">    prop = myDiv.style[i];    //或者 myDiv.style.item(i) </div><div class="t m0 x0 h15 y2107 ff84 fs6 fc0 sc0 ls21 wsb">    value = myDiv.style.getPropertyValue(prop); </div><div class="t m0 x0 h15 y2108 ff84 fs6 fc0 sc0 ls21 wsb">    alert(prop + &quot; : &quot; + value); </div><div class="t m0 x0 hb y2109 ff83 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 h5 ycb8 ff83 fs1 fc0 sc0 ls9 ws2">getPropertyValue()方法取得的始终都是CSS属性值的字符串表示。如果你需要更多信息，可</div><div class="t m0 x0 h1e ycb9 ff7f fs2 fc0 sc0 ls8 wseb">以使用getPropertyCSSValue()方法，它返回一个包含两个属性的CSSValue 对象，这两个属性分</div></div></div>
<div id="pf14d" class="pf w0 h0" data-page-no="14d"><div class="pc pc14d w0 h0"><div class="t m0 x2 h2 y1 ff78 fs0 fc0 sc0 ls7 ws0">12.2 样式  315 </div><div class="t m0 x0 h3 y2 ff78 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff7a fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff7a fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff7a fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff7a fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff7a fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff7a fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff7a fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff7a fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff7a fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff7a fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff7a fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff7a fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff7a fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h4 y3 ff7f fs2 fc0 sc0 ls8 wseb">别是：cssText和cssValueType。其中，cssText属性的值与getPropertyValue()返回的值相同，</div><div class="t m0 x0 hc y4d ff7f fs2 fc0 sc0 ls2d5">而cssValueType属性则是一个数值常量，表示值的类型：0表示继承的值，1表示基本的值，2表示</div><div class="t m0 x0 h5 y5 ff7f fs2 fc0 sc0 ls8">值列表，3表示自定义的值。以下代码既输出CSS属性值，也输出值的类型。 </div><div class="t m0 x5 hb y4f ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y210a ff83 fs6 fc0 sc0 ls21 wsb">var prop, value, i, len; </div><div class="t m0 x0 hb y210b ff83 fs6 fc0 sc0 ls21 wsb">for (i=0, len=myDiv.style.length; i &lt; len; i++){ </div><div class="t m0 x0 h16 y210c ff84 fs6 fc0 sc0 ls21 wsb">    prop = myDiv.style[i]; //或者myDiv.style.item(i) </div><div class="t m0 x0 h15 y210d ff84 fs6 fc0 sc0 ls21 wsb">    value = myDiv.style.getPropertyCSSValue(prop); </div><div class="t m0 x0 h15 y210e ff84 fs6 fc0 sc0 ls21 wsb">    alert(prop + &quot; : &quot; + value.cssText + &quot; (&quot; + value.cssValueType + &quot;)&quot;); </div><div class="t m0 x0 hb y210f ff83 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x2 hf y2b7 ff85 fs2 fc0 sc0 ls2b wsb">DOMStyleObjectExample.htm </div><div class="t m0 x0 h5 y2b8 ff7f fs2 fc0 sc0 ls8 wseb">在实际开发中，getPropertyCSSValue()使用得比getPropertyValue()少得多。IE9+、Safarie </div><div class="t m0 x0 hc y2110 ff78 fs2 fc0 sc0 ls8 ws20">3+以及Chrome支持这个方法。Firefox 7及之前版本也提供这个访问，但调用总返回null。 </div><div class="t m0 x0 h5 y2111 ff7f fs2 fc0 sc0 ls8 wseb">要从元素的样式中移除某个CSS属性，需要使用removeProperty()方法。使用这个方法移除一</div><div class="t m0 x0 h4 y2112 ff7f fs2 fc0 sc0 ls8 wseb">个属性，意味着将会为该属性应用默认的样式（从其他样式表经层叠而来）。例如，要移除通过style</div><div class="t m0 x0 h5 y2113 ff7f fs2 fc0 sc0 ls8 wseb">特性设置的 border属性，可以使用下面的代码。 </div><div class="t m0 x5 hb y2114 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2115 ff83 fs6 fc0 sc0 ls21 wsb">myDiv.style.removeProperty(&quot;border&quot;); </div><div class="t m0 x5 hb y2116 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y2117 ff7f fs2 fc0 sc0 ls8 wseb">在不确定某个给定的CSS属性拥有什么默认值的情况下，就可以使用这个方法。只要移除相应的属</div><div class="t m0 x0 h5 y6cd ff7f fs2 fc0 sc0 ls8 wseb">性，就可以为元素应用默认值。 </div><div class="t m0 x5 h5 y2118 ff79 fs2 fc0 sc0 ls8 ws14">除非另有说明，本节讨论的属性和方法都得到了IE9+、Firefox、Safari、Opera 9+</div><div class="t m0 x5 h5 y2119 ff79 fs2 fc0 sc0 ls8 ws14">以及Chrome的支持。 </div><div class="t m0 x0 h3c y211a ff7d fs2 fc0 sc0 ls2e wsb">2. 计算的样式 </div><div class="t m0 x0 h4 y211b ff7f fs2 fc0 sc0 ls8 wseb">虽然style对象能够提供支持style特性的任何元素的样式信息，但它不包含那些从其他样式表</div><div class="t m0 x0 h5 y211c ff7f fs2 fc0 sc0 ls6 wsf7">层叠而来并影响到当前元素的样式信息。“DOM2级样式”增强了document.defaultView，提供了</div><div class="t m0 x0 h4 y211d ff83 fs1 fc0 sc0 ls9 ws2">getComputedStyle()方法。这个方法接受两个参数：要取得计算样式的元素和一个伪元素字符串（例</div><div class="t m0 x0 h1e y211e ff7f fs2 fc0 sc0 ls8 wseb">如&quot;:after&quot;）。如果不需要伪元素信息，第二个参数可以是null。getComputedStyle()方法返回一</div><div class="t m0 x0 h1e y211f ff7f fs2 fc0 sc0 ls2d8">个CSSStyleDeclaration对象（与style属性的类型相同），其中包含当前元素的所有计算的样式。</div><div class="t m0 x0 h5 y2120 ff7f fs2 fc0 sc0 ls8 wseb">以下面这个HTML页面为例。 </div><div class="t m0 x0 hb y2121 ff83 fs6 fc0 sc0 ls21 wsb">&lt;!DOCTYPE html&gt; </div><div class="t m0 x0 hb y2122 ff83 fs6 fc0 sc0 ls21 wsb">&lt;html&gt; </div><div class="t m0 x0 hb y2123 ff83 fs6 fc0 sc0 ls21 wsb">&lt;head&gt; </div><div class="t m0 x0 hb y2124 ff83 fs6 fc0 sc0 ls21 wsb">    &lt;title&gt;Computed Styles Example&lt;/title&gt; </div><div class="t m0 x0 hb y2125 ff83 fs6 fc0 sc0 ls21 wsb">    &lt;style type=&quot;text/css&quot;&gt; </div><div class="t m0 x0 hb y2126 ff83 fs6 fc0 sc0 ls21 wsb">        #myDiv { </div><div class="t m0 x0 hb y2127 ff83 fs6 fc0 sc0 ls21 wsb">            background-color: blue; </div><div class="t m0 x0 hb y2128 ff83 fs6 fc0 sc0 ls21 wsb">            width: 100px; </div><div class="t m0 x0 hb y2129 ff83 fs6 fc0 sc0 ls21 wsb">            height: 200px; </div><div class="t m0 x0 hb y212a ff83 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y212b ff83 fs6 fc0 sc0 ls21 wsb">    &lt;/style&gt; </div><div class="t m0 x0 hb y212c ff83 fs6 fc0 sc0 ls21 wsb">&lt;/head&gt; </div><div class="t m0 x0 hb y212d ff83 fs6 fc0 sc0 ls21 wsb">&lt;body&gt; </div><div class="t m0 x0 hb y212e ff83 fs6 fc0 sc0 ls21 wsb">    &lt;div id=&quot;myDiv&quot; style=&quot;background-color: red; border: 1px solid black&quot;&gt;&lt;/div&gt; </div><div class="t m0 x0 hb y212f ff83 fs6 fc0 sc0 ls21 wsb">&lt;/body&gt; </div><div class="t m0 x0 hb y2130 ff83 fs6 fc0 sc0 ls21 wsb">&lt;/html&gt; </div><div class="t m0 x2 hf y2131 ff85 fs2 fc0 sc0 ls8 wsb">ComputedStylesExample.htm </div></div></div>
<div id="pf14e" class="pf w0 h0" data-page-no="14e"><div class="pc pc14e w0 h0"><div class="t m0 x0 h2 y1 ff78 fs0 fc0 sc0 ls7 ws0">316  第12章 DOM2和DOM3 </div><div class="t m0 x0 h3 y2 ff78 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ff7f fs2 fc0 sc0 ls5 wsec">应用给这个例子中&lt;div&gt;元素的样式一方面来自嵌入式样式表（&lt;style&gt;元素中的样式），另一方</div><div class="t m0 x0 h1e y4d ff7f fs2 fc0 sc0 ls8 wseb">面来自其style特性。但是，style特性中设置了 backgroundColor和border，没有设置width</div><div class="t m0 x0 h5 y4e ff7f fs2 fc0 sc0 ls2c">和height，后者是通过样式表规则应用的。以下代码可以取得这个元素计算后的样式。 </div><div class="t m0 x0 hb y4f ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2132 ff83 fs6 fc0 sc0 ls21 wsb">var myDiv = document.getElementById(&quot;myDiv&quot;); </div><div class="t m0 x0 hb y2133 ff83 fs6 fc0 sc0 ls21 wsb">var computedStyle = document.defaultView.getComputedStyle(myDiv, null); </div><div class="t m0 x0 hb y2134 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2135 ff83 fs6 fc0 sc0 ls21 wsb">alert(computedStyle.backgroundColor);  // &quot;red&quot; </div><div class="t m0 x0 hb y2136 ff83 fs6 fc0 sc0 ls21 wsbc">alert(computedStyle.width);    // &quot;100px&quot; </div><div class="t m0 x0 hb y2137 ff83 fs6 fc0 sc0 ls21 wsbc">alert(computedStyle.height);    // &quot;200px&quot; </div><div class="t m0 x0 h16 y2138 ff83 fs6 fc0 sc0 ls21 wsbc">alert(computedStyle.border);    // 在某些浏览器中是&quot;1px solid black&quot; </div><div class="t m0 x0 hb y2139 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y213a ff85 fs2 fc0 sc0 ls8 wsb">ComputedStylesExample.htm </div><div class="t m0 x0 h4 y213b ff7f fs2 fc0 sc0 ls8 wseb">在这个元素计算后的样式中，背景颜色的值是&quot;red&quot;，宽度值是&quot;100px&quot;，高度值是&quot;200px&quot;。我</div><div class="t m0 x0 h1e y213c ff7f fs2 fc0 sc0 ls8 wseb">们注意到，背景颜色不是&quot;blue&quot;，因为这个样式在自身的style特性中已经被覆盖了。边框属性可能</div><div class="t m0 x0 hc y213d ff7f fs2 fc0 sc0 ls8 wseb">会也可能不会返回样式表中实际的border规则（Opera会返回，但其他浏览器不会）。存在这个差别的</div><div class="t m0 x0 h5 y213e ff7f fs2 fc0 sc0 ls8 wseb">原因是不同浏览器解释综合（rollup）属性（如border）的方式不同，因为设置这种属性实际上会涉及</div><div class="t m0 x0 h4 y213f ff7f fs2 fc0 sc0 ls2d9 ws2a4">很多其他属性。在设置border时，实际上是设置了四个边的边框宽度、颜色、样式属性</div><div class="t m0 x0 h1e y2140 ff7f fs2 fc0 sc0 ls2da">（border-left-width、border-top-color、border-bottom-style，等等）。因此，即使</div><div class="t m0 x0 h4 y2141 ff83 fs1 fc0 sc0 ls9 ws2">computedStyle.border不会在所有浏览器中都返回值，但computedStyle.borderLeftWidth会</div><div class="t m0 x0 h5 y2142 ff7f fs2 fc0 sc0 ls8">返回值。 </div><div class="t m0 x5 ha y2143 ff79 fs2 fc0 sc0 ls8 ws14">需要注意的是，即使有些浏览器支持这种功能，但表示值的方式可能会有所区别。</div><div class="t m0 x0 h5 y2144 ff79 fs2 fc0 sc0 ls8 ws14">例如，Firefox和Safari会将所有颜色转换成RGB格式（例如红色是rgb(255,0,0)）。</div><div class="t m0 x0 h18 y2145 ff79 fs2 fc0 sc0 ls8 ws14">因此，在使用getComputedStyle()方法时，最好多在几种浏览器中测试一下。 </div><div class="t m0 x0 h5 y2146 ff78 fs2 fc0 sc0 lse ws9">IE不支持getComputedStyle()方法，但它有一种类似的概念。在IE中，每个具有 style属性</div><div class="t m0 x0 h4 y2147 ff7f fs2 fc0 sc0 ls8 wseb">的元素还有一个currentStyle属性。这个属性是CSSStyleDeclaration的实例，包含当前元素全</div><div class="t m0 x0 h5 y2148 ff7f fs2 fc0 sc0 ls8 wseb">部计算后的样式。取得这些样式的方式也差不多，如下面的例子所示。 </div><div class="t m0 x0 hb y2149 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y214a ff83 fs6 fc0 sc0 ls21 wsb">var myDiv = document.getElementById(&quot;myDiv&quot;); </div><div class="t m0 x0 h15 y214b ff84 fs6 fc0 sc0 ls21 wsb">var computedStyle = myDiv.currentStyle; </div><div class="t m0 x0 hb y214c ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y214d ff83 fs6 fc0 sc0 ls21 wsb">alert(computedStyle.backgroundColor);     //&quot;red&quot; </div><div class="t m0 x0 hb y214e ff83 fs6 fc0 sc0 ls21 wsb">alert(computedStyle.width);               //&quot;100px&quot; </div><div class="t m0 x0 hb y214f ff83 fs6 fc0 sc0 ls21 wsb">alert(computedStyle.height);              //&quot;200px&quot; </div><div class="t m0 x0 hb y2150 ff83 fs6 fc0 sc0 ls21 wsb">alert(computedStyle.border);              //undefined </div><div class="t m0 x0 hb y2151 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y46e ff85 fs2 fc0 sc0 ls1b wsb">IEComputedStylesExample.htm </div><div class="t m0 x0 h5 y2152 ff7f fs2 fc0 sc0 ls3b">与DOM版本的方式一样，IE也没有返回border样式，因为这是一个综合属性。 </div><div class="t m0 x0 h4 y2153 ff7f fs2 fc0 sc0 ls8 wseb">无论在哪个浏览器中，最重要的一条是要记住所有计算的样式都是只读的；不能修改计算后样式对</div><div class="t m0 x0 h5 y2154 ff7f fs2 fc0 sc0 ls8 wseb">象中的CSS属性。此外，计算后的样式也包含属于浏览器内部样式表的样式信息，因此任何具有默认值</div><div class="t m0 x0 h5 y2155 ff7f fs2 fc0 sc0 ls21d">的CSS属性都会表现在计算后的样式中。例如，所有浏览器中的visibility属性都有一个默认值，</div><div class="t m0 x0 h1e ye11 ff7f fs2 fc0 sc0 ls8 wseb">但这个值会因实现而异。在默认情况下，有的浏览器将visibility属性设置为&quot;visible&quot;，而有的</div><div class="t m0 x0 hb9 ye12 ff7f fs2 fc0 sc0 ls8 wseb">浏览器则将其设置为&quot;inherit&quot;。换句话说，不能指望某个CSS属性的默认值在不同浏览器中是相同</div><div class="t m0 x0 h5 y2156 ff7f fs2 fc0 sc0 ls8 wseb">的。如果你需要元素具有某个特定的默认值，应该手工在样式表中指定该值。 </div></div></div>
<div id="pf14f" class="pf w0 h0" data-page-no="14f"><div class="pc pc14f w0 h0"><div class="t m0 x2 h2 y1 ff78 fs0 fc0 sc0 ls7 ws0">12.2 样式  317 </div><div class="t m0 x0 h3 y2 ff78 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff7a fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff7a fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff7a fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff7a fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff7a fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff7a fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff7a fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff7a fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff7a fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff7a fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff7a fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff7a fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff7a fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h20 y12d ff7d fs3 fc0 sc0 ls248 ws214">12.2.2 操作样式表 </div><div class="t m0 x0 h4 y12e ff83 fs1 fc0 sc0 ls20 ws16">CSSStyleSheet类型表示的是样式表，包括通过&lt;link&gt;元素包含的样式表和在&lt;style&gt;元素中定义</div><div class="t m0 x0 h4 y12f ff7f fs2 fc0 sc0 ls1f ws108">的样式表。有读者可能记得，这两个元素本身分别是由HTMLLinkElement和HTMLStyleElement类型</div><div class="t m0 x0 hc y130 ff7f fs2 fc0 sc0 ls1f ws108">表示的。但是，CSSStyleSheet类型相对更加通用一些，它只表示样式表，而不管这些样式表在HTML</div><div class="t m0 x0 h5 y131 ff7f fs2 fc0 sc0 ls1f ws108">中是如何定义的。此外，上述两个针对元素的类型允许修改HTML特性，但CSSStyleSheet对象则是一</div><div class="t m0 x0 h5 y1c96 ff7f fs2 fc0 sc0 ls1f ws108">套只读的接口（有一个属性例外）。使用下面的代码可以确定浏览器是否支持DOM2级样式表。 </div><div class="t m0 x5 hb y2157 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2158 ff83 fs6 fc0 sc0 ls21 wsb">var supportsDOM2StyleSheets =  </div><div class="t m0 x1 hb y2159 ff83 fs6 fc0 sc0 ls21 wsb">document.implementation.hasFeature(&quot;StyleSheets&quot;, &quot;2.0&quot;); </div><div class="t m0 x5 hb y215a ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y215b ff83 fs1 fc0 sc0 ls9 ws2">CSSStyleSheet继承自StyleSheet，后者可以作为一个基础接口来定义非 CSS样式表。从</div><div class="t m0 x0 h5 y215c ff83 fs1 fc0 sc0 ls9 ws2">StyleSheet接口继承而来的属性如下。 </div><div class="t m0 x0 h5 y215d ff7e fs1 fc0 sc0 ls2"> disabled：表示样式表是否被禁用的布尔值。这个属性是可读/写的，将这个值设置为true可</div><div class="t m0 x5 h5 y215e ff7f fs2 fc0 sc0 ls8 wseb">以禁用样式表。 </div><div class="t m0 x0 h5 y215f ff7e fs1 fc0 sc0 ls2"> href：如果样式表是通过&lt;link&gt;包含的，则是样式表的URL；否则，是null。 </div><div class="t m0 x0 h5 y2160 ff7e fs1 fc0 sc0 ls2"> media：当前样式表支持的所有媒体类型的集合。与所有DOM集合一样，这个集合也有一个</div><div class="t m0 x5 h4 y2161 ff83 fs1 fc0 sc0 ls9 ws2">length属性和一个item()方法。也可以使用方括号语法取得集合中特定的项。如果集合是空</div><div class="t m0 x5 h5 y2162 ff7f fs2 fc0 sc0 ls8 wseb">列表，表示样式表适用于所有媒体。在IE中，media是一个反映&lt;link&gt;和&lt;style&gt;元素media</div><div class="t m0 x5 h5 y2163 ff7f fs2 fc0 sc0 ls8 wseb">特性值的字符串。 </div><div class="t m0 x0 h5 y1198 ff7e fs1 fc0 sc0 ls2"> ownerNode：指向拥有当前样式表的节点的指针，样式表可能是在HTML中通过&lt;link&gt;或</div><div class="t m0 x5 h5 y2164 ff83 fs1 fc0 sc0 ls9 ws2">&lt;style/&gt;引入的（在XML中可能是通过处理指令引入的）。如果当前样式表是其他样式表通过</div><div class="t m0 x5 h5 y2165 ff83 fs1 fc0 sc0 ls9 ws2">@import导入的，则这个属性值为null。IE不支持这个属性。 </div><div class="t m0 x0 h4 y2166 ff7e fs1 fc0 sc0 ls2"> parentStyleSheet：在当前样式表是通过@import导入的情况下，这个属性是一个指向导入</div><div class="t m0 x5 h5 y2167 ff7f fs2 fc0 sc0 ls8 wseb">它的样式表的指针。 </div><div class="t m0 x0 h5 y986 ff7e fs1 fc0 sc0 ls2"> title：ownerNode中title属性的值。 </div><div class="t m0 x0 h5 y2168 ff7e fs1 fc0 sc0 ls2"> type：表示样式表类型的字符串。对CSS样式表而言，这个字符串是&quot;type/css&quot;。 </div><div class="t m0 x0 h1e y2169 ff7f fs2 fc0 sc0 ls221 ws21e">除了disabled属性之外，其他属性都是只读的。在支持以上所有这些属性的基础上，</div><div class="t m0 x0 h5 y85c ff83 fs1 fc0 sc0 ls9 ws2">CSSStyleSheet类型还支持下列属性和方法： </div><div class="t m0 x0 h5 y216a ff7e fs1 fc0 sc0 ls2"> cssRules：样式表中包含的样式规则的集合。IE不支持这个属性，但有一个类似的rules属性。 </div><div class="t m0 x0 h5 y216b ff7e fs1 fc0 sc0 ls2"> ownerRule：如果样式表是通过@import导入的，这个属性就是一个指针，指向表示导入的规</div><div class="t m0 x5 hc y216c ff7f fs2 fc0 sc0 ls8 wseb">则；否则，值为null。IE不支持这个属性。 </div><div class="t m0 x0 h5 y1ffa ff7e fs1 fc0 sc0 ls2"> deleteRule(index)：删除cssRules集合中指定位置的规则。IE不支持这个方法，但支持</div><div class="t m0 x5 hc y216d ff7f fs2 fc0 sc0 ls8 wseb">一个类似的removeRule()方法。 </div><div class="t m0 x0 h5 y216e ff7e fs1 fc0 sc0 ls2"> insertRule(rule,index)：向cssRules集合中指定的位置插入rule字符串。IE不支持这</div><div class="t m0 x5 hc y216f ff7f fs2 fc0 sc0 ls8 wseb">个方法，但支持一个类似的addRule()方法。 </div><div class="t m0 x0 h1e y2170 ff7f fs2 fc0 sc0 ls1f ws108">应用于文档的所有样式表是通过document.styleSheets集合来表示的。通过这个集合的length</div><div class="t m0 x0 h4 y2171 ff7f fs2 fc0 sc0 ls1f ws108">属性可以获知文档中样式表的数量，而通过方括号语法或item()方法可以访问每一个样式表。来看一个</div><div class="t m0 x0 h5 y2172 ff7f fs2 fc0 sc0 ls1f">例子。 </div><div class="t m0 x5 hb y2173 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2174 ff83 fs6 fc0 sc0 ls21 wsb">var sheet = null; </div><div class="t m0 x0 hb y2175 ff83 fs6 fc0 sc0 ls21 wsb">for (var i=0, len=document.styleSheets.length; i &lt; len; i++){ </div></div></div>
<div id="pf150" class="pf w0 h0" data-page-no="150"><div class="pc pc150 w0 h0"><div class="t m0 x0 h2 y1 ff78 fs0 fc0 sc0 ls7 ws0">318  第12章 DOM2和DOM3 </div><div class="t m0 x0 h3 y2 ff78 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 ff83 fs6 fc0 sc0 ls21 wsb">    sheet = document.styleSheets[i]; </div><div class="t m0 x0 hb y7a ff83 fs6 fc0 sc0 ls21 wsb">    alert(sheet.href); </div><div class="t m0 x0 hb y7b ff83 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x2 hf y106 ff85 fs2 fc0 sc0 ls5e wsb">StyleSheetsExample.htm </div><div class="t m0 x0 h4 y107 ff7f fs2 fc0 sc0 ls55 wsfc">以上代码可以输出文档中使用的每一个样式表的href属性（&lt;style&gt;元素包含的样式表没有</div><div class="t m0 x0 h5 y2177 ff83 fs1 fc0 sc0 ls16 ws17">href属性）。 </div><div class="t m0 x0 h1e y1f58 ff7f fs2 fc0 sc0 ls8 wseb">不同浏览器的document.styleSheets返回的样式表也不同。所有浏览器都会包含&lt;style&gt;元素</div><div class="t m0 x0 h5 y10a ff7f fs2 fc0 sc0 lsd9">和rel特性被设置为&quot;stylesheet&quot;的&lt;link&gt;元素引入的样式表。IE和Opera也包含rel特性被设置</div><div class="t m0 x0 hc y10b ff7f fs2 fc0 sc0 ls8 wseb">为&quot;alternate stylesheet&quot;的&lt;link&gt;元素引入的样式表。 </div><div class="t m0 x0 hc y2178 ff7f fs2 fc0 sc0 lsed ws221">也可以直接通过&lt;link&gt;或&lt;style&gt;元素取得CSSStyleSheet 对象。DOM规定了一个包含</div><div class="t m0 x0 h5 y1543 ff83 fs1 fc0 sc0 ls9 ws2">CSSStyleSheet对象的属性，名叫sheet；除了 IE，其他浏览器都支持这个属性。IE支持的是</div><div class="t m0 x0 h5 y1f5b ff83 fs1 fc0 sc0 ls9 ws2">styleSheet属性。要想在不同浏览器中都能取得样式表对象，可以使用下列代码。 </div><div class="t m0 x0 hb y1c57 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2179 ff83 fs6 fc0 sc0 ls21 wsb">function getStyleSheet(element){ </div><div class="t m0 x0 hb y217a ff83 fs6 fc0 sc0 ls21 wsb">    return element.sheet || element.styleSheet; </div><div class="t m0 x0 hb y217b ff83 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y217c ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y217d ff83 fs6 fc0 sc0 ls21">//取得第一个&lt;link/&gt;元素引入的样式表 </div><div class="t m0 x0 hb y217e ff83 fs6 fc0 sc0 ls21 wsb">var link = document.getElementsByTagName(&quot;link&quot;)[0]; </div><div class="t m0 x0 hb y217f ff83 fs6 fc0 sc0 ls21 wsb">var sheet = getStylesheet(link); </div><div class="t m0 x0 hb y2180 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y74d ff85 fs2 fc0 sc0 ls5e wsb">StyleSheetsExample2.htm </div><div class="t m0 x0 h5 y16b ff7f fs2 fc0 sc0 ls75 wsfd">这里的getStyleSheet()返回的样式表对象与document.styleSheets集合中的样式表对象相同。 </div><div class="t m0 x0 h3c y2181 ff7d fs2 fc0 sc0 lsb ws2ac">1. CSS规则 </div><div class="t m0 x0 h4 y1173 ff83 fs1 fc0 sc0 ls9 ws2">CSSRule对象表示样式表中的每一条规则。实际上，CSSRule是一个供其他多种类型继承的基类</div><div class="t m0 x0 h4 y2182 ff7f fs2 fc0 sc0 ls8 wseb">型，其中最常见的就是CSSStyleRule类型，表示样式信息（其他规则还有@import、@font-face、</div><div class="t m0 x0 h5 y2183 ff83 fs1 fc0 sc0 ls9 ws2">@page和@charset，但这些规则很少有必要通过脚本来访问）。CSSStyleRule对象包含下列属性。 </div><div class="t m0 x0 h4 y2184 ff7e fs1 fc0 sc0 ls2"> cssText：返回整条规则对应的文本。由于浏览器对样式表的内部处理方式不同，返回的文本</div><div class="t m0 x0 h5 yd87 ff7f fs2 fc0 sc0 ls5 wsec">可能会与样式表中实际的文本不一样；Safari始终都会将文本转换成全部小写。IE不支持这个</div><div class="t m0 x0 h5 y2185 ff7f fs2 fc0 sc0 ls5 wsec">属性。 </div><div class="t m0 x0 h4 y324 ff7e fs1 fc0 sc0 ls2"> parentRule：如果当前规则是导入的规则，这个属性引用的就是导入规则；否则，这个值为</div><div class="t m0 x0 h5 y325 ff83 fs1 fc0 sc0 ls9 ws2">null。IE不支持这个属性。 </div><div class="t m0 x0 h5 y326 ff7e fs1 fc0 sc0 ls2"> parentStyleSheet：当前规则所属的样式表。IE不支持这个属性。 </div><div class="t m0 x0 h4 y327 ff7e fs1 fc0 sc0 ls2"> selectorText：返回当前规则的选择符文本。由于浏览器对样式表的内部处理方式不同，返回</div><div class="t m0 x0 h5 y1217 ff7f fs2 fc0 sc0 ls8 wseb">的文本可能会与样式表中实际的文本不一样（例如，Safari 3之前的版本始终会将文本转换成全</div><div class="t m0 x0 hc y1218 ff7f fs2 fc0 sc0 ls5f ws10b">部小写）。在Firefox、Safari、Chrome和IE中这个属性是只读的。Opera允许修改selectorText。 </div><div class="t m0 x0 h5 y2186 ff7e fs1 fc0 sc0 ls2"> style：一个CSSStyleDeclaration对象，可以通过它设置和取得规则中特定的样式值。 </div><div class="t m0 x0 h5 y2187 ff7e fs1 fc0 sc0 ls2"> type：表示规则类型的常量值。对于样式规则，这个值是1。IE不支持这个属性。 </div><div class="t m0 x0 h4 y6e1 ff7f fs2 fc0 sc0 ls8 wseb">其中三个最常用的属性是cssText、selectorText和style。cssText属性与style.cssText</div><div class="t m0 x0 h4 y2188 ff7f fs2 fc0 sc0 ls8 wseb">属性类似，但并不相同。前者包含选择符文本和围绕样式信息的花括号，后者只包含样式信息（类似于</div><div class="t m0 x0 hc y6e3 ff7f fs2 fc0 sc0 ls8 wseb">元素的style.cssText）。此外，cssText是只读的，而style.cssText也可以被重写。 </div></div></div>
<div id="pf151" class="pf w0 h0" data-page-no="151"><div class="pc pc151 w0 h0"><div class="t m0 x2 h2 y1 ff78 fs0 fc0 sc0 ls7 ws0">12.2 样式  319 </div><div class="t m0 x0 h3 y2 ff78 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff7a fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff7a fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff7a fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff7a fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff7a fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff7a fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff7a fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff7a fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff7a fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff7a fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff7a fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff7a fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff7a fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h4 y3 ff7f fs2 fc0 sc0 ls8 wseb">大多数情况下，仅使用style属性就可以满足所有操作样式规则的需求了。这个对象就像每个元</div><div class="t m0 x0 hc y4d ff7f fs2 fc0 sc0 ls8 wseb">素上的style属性一样，可以通过它读取和修改规则中的样式信息。以下面的CSS规则为例。 </div><div class="t m0 x5 hb y1701 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2189 ff83 fs6 fc0 sc0 ls21 wsb">div.box { </div><div class="t m0 x0 hb y218a ff83 fs6 fc0 sc0 ls21 wsb">    background-color: blue; </div><div class="t m0 x0 hb y218b ff83 fs6 fc0 sc0 ls21 wsb">    width: 100px; </div><div class="t m0 x0 hb y218c ff83 fs6 fc0 sc0 ls21 wsb">    height: 200px; </div><div class="t m0 x0 hb y218d ff83 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x2 hf y218e ff85 fs2 fc0 sc0 ls2b wsb">CSSRulesExample.htm </div><div class="t m0 x0 h4 y218f ff7f fs2 fc0 sc0 ls8 wseb">假设这条规则位于页面中的第一个样式表中，而且这个样式表中只有这一条样式规则，那么通过下</div><div class="t m0 x0 h5 y2190 ff7f fs2 fc0 sc0 ls8 wseb">列代码可以取得这条规则的各种信息。 </div><div class="t m0 x5 hb y2191 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2192 ff83 fs6 fc0 sc0 ls21 wsb">var sheet = document.styleSheets[0]; </div><div class="t m0 x0 h16 y2193 ff83 fs6 fc0 sc0 ls21 wsb">var rules = sheet.cssRules || sheet.rules;    //取得规则列表 </div><div class="t m0 x0 h16 y2194 ff83 fs6 fc0 sc0 ls21 wsb">var rule = rules[0];                        //取得第一条规则 </div><div class="t m0 x0 hb y2195 ff83 fs6 fc0 sc0 ls21 wsb">alert(rule.selectorText);                   //&quot;div.box&quot; </div><div class="t m0 x0 h16 y2196 ff83 fs6 fc0 sc0 ls21 wsb">alert(rule.style.cssText);                   //完整的CSS代码 </div><div class="t m0 x0 hb y2197 ff83 fs6 fc0 sc0 ls21 wsb">alert(rule.style.backgroundColor);           //&quot;blue&quot; </div><div class="t m0 x0 hb y2198 ff83 fs6 fc0 sc0 ls21 wsb">alert(rule.style.width);                    //&quot;100px&quot; </div><div class="t m0 x0 hb y2199 ff83 fs6 fc0 sc0 ls21 wsb">alert(rule.style.height);                   //&quot;200px&quot; </div><div class="t m0 x5 hb y219a ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y219b ff85 fs2 fc0 sc0 ls2b wsb">CSSRulesExample.htm </div><div class="t m0 x0 h4 y219c ff7f fs2 fc0 sc0 ls8 wseb">使用这种方式，可以像确定元素的行内样式信息一样，确定与规则相关的样式信息。与使用元素的</div><div class="t m0 x0 h5 y219d ff7f fs2 fc0 sc0 ls8 wseb">方式一样，在这种方式下也可以修改样式信息，如下面的例子所示。 </div><div class="t m0 x5 hb y219e ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y219f ff83 fs6 fc0 sc0 ls21 wsb">var sheet = document.styleSheets[0]; </div><div class="t m0 x0 h16 y21a0 ff83 fs6 fc0 sc0 ls21 wsb">var rules = sheet.cssRules || sheet.rules;      //取得规则列表 </div><div class="t m0 x0 h16 y21a1 ff83 fs6 fc0 sc0 ls21 wsb">var rule = rules[0];                        //取得第一条规则 </div><div class="t m0 x0 h15 y21a2 ff84 fs6 fc0 sc0 ls21 wsb">rule.style.backgroundColor = &quot;red&quot; </div><div class="t m0 x5 hb y21a3 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y21a4 ff85 fs2 fc0 sc0 ls2b wsb">CSSRulesExample.htm </div><div class="t m0 x0 h4 y21a5 ff7f fs2 fc0 sc0 ls8 wseb">必须要注意的是，以这种方式修改规则会影响页面中适用于该规则的所有元素。换句话说，如果有</div><div class="t m0 x0 hc y21a6 ff7f fs2 fc0 sc0 ls8 wseb">两个带有box类的&lt;div&gt;元素，那么这两个元素都会应用修改后的样式。 </div><div class="t m0 x0 h3c y21a7 ff7d fs2 fc0 sc0 ls2e wsb">2. 创建规则 </div><div class="t m0 x0 h5 y21a8 ff78 fs2 fc0 sc0 ls81 ws76">DOM规定，要向现有样式表中添加新规则，需要使用insertRule()方法。这个方法接受两个参</div><div class="t m0 x0 h5 y21a9 ff7f fs2 fc0 sc0 ls8 wseb">数：规则文本和表示在哪里插入规则的索引。下面是一个例子。 </div><div class="t m0 x5 hb y21aa ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h36 y21ab ff83 fs6 fc0 sc0 ls21 wsb">sheet.insertRule(&quot;body { background-color: silver }&quot;, 0); //DOM方法 </div><div class="t m0 x5 hb y21ac ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y21ad ff7f fs2 fc0 sc0 ls8 wseb">这个例子插入的规则会改变元素的背景颜色。插入的规则将成为样式表中的第一条规则（插入到了</div><div class="t m0 x0 h5 y21ae ff7f fs2 fc0 sc0 ls8 wseb">位置0）——规则的次序在确定层叠之后应用到文档的规则时至关重要。Firefox、Safari、Opera和Chrome</div><div class="t m0 x0 hc y21af ff7f fs2 fc0 sc0 ls8 wseb">都支持insertRule()方法。 </div><div class="t m0 x0 hc y21b0 ff78 fs2 fc0 sc0 ls2a ws21">IE8及更早版本支持一个类似的方法，名叫addRule()，也接收两必选参数：选择符文本和 CSS</div><div class="t m0 x0 h5 y21b1 ff7f fs2 fc0 sc0 ls8 wseb">样式信息；一个可选参数：插入规则的位置。在IE中插入与前面例子相同的规则，可使用如下代码。 </div><div class="t m0 x5 hb y21b2 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h36 y21b3 ff83 fs6 fc0 sc0 ls21 wsb">sheet.addRule(&quot;body&quot;, &quot;background-color: silver&quot;, 0); //仅对IE有效 </div><div class="t m0 x5 hb y21b4 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y21b5 ff7f fs2 fc0 sc0 ls8 wseb">有关这个方法的规定中说，最多可以使用addRule()添加4 095条样式规则。超出这个上限的调用</div><div class="t m0 x0 h5 y21b6 ff7f fs2 fc0 sc0 ls8 wseb">将会导致错误。 </div></div></div>
<div id="pf152" class="pf w0 h0" data-page-no="152"><div class="pc pc152 w0 h0"><div class="t m0 x0 h2 y1 ff78 fs0 fc0 sc0 ls7 ws0">320  第12章 DOM2和DOM3 </div><div class="t m0 x0 h3 y2 ff78 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff7f fs2 fc0 sc0 ls8 wseb">要以跨浏览器的方式向样式表中插入规则，可以使用下面的函数。这个函数接受4个参数：要向其</div><div class="t m0 x0 hc y4d ff7f fs2 fc0 sc0 ls8 wseb">中添加规则的样式表以及与addRule()相同的3个参数，如下所示。 </div><div class="t m0 x0 hb y1701 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2189 ff83 fs6 fc0 sc0 ls21 wsb">function insertRule(sheet, selectorText, cssText, position){ </div><div class="t m0 x0 hb y218a ff83 fs6 fc0 sc0 ls21 wsb">    if (sheet.insertRule){ </div><div class="t m0 x0 hb y218b ff83 fs6 fc0 sc0 ls21 wsb">        sheet.insertRule(selectorText + &quot;{&quot; + cssText + &quot;}&quot;, position); </div><div class="t m0 x0 hb y218c ff83 fs6 fc0 sc0 ls21 wsb">    } else if (sheet.addRule){ </div><div class="t m0 x0 hb y218d ff83 fs6 fc0 sc0 ls21 wsb">        sheet.addRule(selectorText, cssText, position); </div><div class="t m0 x0 hb y21b8 ff83 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y21b9 ff83 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x2 hf y1aa8 ff85 fs2 fc0 sc0 ls79 wsb">CSSRulesExample2.htm </div><div class="t m0 x0 h5 y21ba ff7f fs2 fc0 sc0 ls8 wseb">下面是调用这个函数的示例代码。 </div><div class="t m0 x0 hb ya89 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y21bb ff83 fs6 fc0 sc0 ls21 wsb">insertRule(document.styleSheets[0], &quot;body&quot;, &quot;background-color: silver&quot;, 0); </div><div class="t m0 x0 hb y21bc ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 yccf ff7f fs2 fc0 sc0 ls8 wseb">虽然可以像这样来添加规则，但随着要添加规则的增多，这种方法就会变得非常繁琐。因此，如果</div><div class="t m0 x0 h5 y21bd ff7f fs2 fc0 sc0 ls8 wseb">要添加的规则非常多，我们建议还是采用第10章介绍过的动态加载样式表的技术。 </div><div class="t m0 x0 h3c y21be ff7d fs2 fc0 sc0 ls2e wsb">3. 删除规则 </div><div class="t m0 x0 h4 y21bf ff7f fs2 fc0 sc0 ls8 wseb">从样式表中删除规则的方法是deleteRule()，这个方法接受一个参数：要删除的规则的位置。例</div><div class="t m0 x0 h5 y21c0 ff7f fs2 fc0 sc0 ls8 wseb">如，要删除样式表中的第一条规则，可以使用以下代码。 </div><div class="t m0 x0 hb y1f19 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h36 y1f1a ff83 fs6 fc0 sc0 ls21 wsb">sheet.deleteRule(0);    //DOM方法 </div><div class="t m0 x0 hb y1f1b ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1f1c ff78 fs2 fc0 sc0 lse ws9">IE支持的类似方法叫removeRule()，使用方法相同，如下所示： </div><div class="t m0 x0 hb y21c1 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h36 y21c2 ff83 fs6 fc0 sc0 ls21 wsb">sheet.removeRule(0);    //仅对IE有效 </div><div class="t m0 x0 hb y21c3 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y21c4 ff7f fs2 fc0 sc0 ls8 wseb">下面是一个能够跨浏览器删除规则的函数。第一个参数是要操作的样式表，第二个参数是要删除的</div><div class="t m0 x0 h5 y21c5 ff7f fs2 fc0 sc0 ls8 wseb">规则的索引。 </div><div class="t m0 x0 hb y21c6 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y21c7 ff83 fs6 fc0 sc0 ls21 wsb">function deleteRule(sheet, index){ </div><div class="t m0 x0 hb y21c8 ff83 fs6 fc0 sc0 ls21 wsb">    if (sheet.deleteRule){ </div><div class="t m0 x0 hb y21c9 ff83 fs6 fc0 sc0 ls21 wsb">        sheet.deleteRule(index); </div><div class="t m0 x0 hb y21ca ff83 fs6 fc0 sc0 ls21 wsb">    } else if (sheet.removeRule){ </div><div class="t m0 x0 hb y21cb ff83 fs6 fc0 sc0 ls21 wsb">        sheet.removeRule(index); </div><div class="t m0 x0 hb y21cc ff83 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y21cd ff83 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x2 hf y21ce ff85 fs2 fc0 sc0 ls79 wsb">CSSRulesExample2.htm </div><div class="t m0 x0 h5 y21cf ff7f fs2 fc0 sc0 ls8 wseb">调用这个函数的方式如下。 </div><div class="t m0 x0 hb y21d0 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y21d1 ff83 fs6 fc0 sc0 ls21 wsb">deleteRule(document.styleSheets[0], 0); </div><div class="t m0 x0 hb y21d2 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y216e ff7f fs2 fc0 sc0 ls8 wseb">与添加规则相似，删除规则也不是实际Web开发中常见的做法。考虑到删除规则可能会影响 CSS</div><div class="t m0 x0 h5 y216f ff7f fs2 fc0 sc0 ls8 wseb">层叠的效果，因此请大家慎重使用。 </div><div class="t m0 x0 h20 y21d3 ff7d fs3 fc0 sc0 ls248 ws214">12.2.3 元素大小 </div><div class="t m0 x0 h5 y192f ff7f fs2 fc0 sc0 ls8 wseb">本节介绍的属性和方法并不属于“DOM2级样式”规范，但却与HTML元素的样式息息相关。DOM</div><div class="t m0 x0 h5 y11ac ff7f fs2 fc0 sc0 ls8 wseb">中没有规定如何确定页面中元素的大小。IE为此率先引入了一些属性，以便开发人员使用。目前，所有</div><div class="t m0 x0 h5 y21d4 ff7f fs2 fc0 sc0 ls8 wseb">主要的浏览器都已经支持这些属性。 </div></div></div>
<div id="pf153" class="pf w0 h0" data-page-no="153"><div class="pc pc153 w0 h0"><div class="t m0 x2 h2 y1 ff78 fs0 fc0 sc0 ls7 ws0">12.2 样式  321 </div><div class="t m0 x0 h3 y2 ff78 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff7a fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff7a fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff7a fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff7a fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff7a fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff7a fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff7a fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff7a fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff7a fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff7a fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff7a fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff7a fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff7a fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h3c y68b ff7d fs2 fc0 sc0 ls2e wsb">1. 偏移量 </div><div class="t m0 x0 h5 y68c ff7f fs2 fc0 sc0 ls8 wseb">首先要介绍的属性涉及偏移量（offset dimension），包括元素在屏幕上占用的所有可见的空间。元素</div><div class="t m0 x0 h4 y15dc ff7f fs2 fc0 sc0 ls6 wsf7">的可见大小由其高度、宽度决定，包括所有内边距、滚动条和边框大小（注意，不包括外边距）。通过</div><div class="t m0 x0 h5 y15dd ff7f fs2 fc0 sc0 ls8 wseb">下列4个属性可以取得元素的偏移量。 </div><div class="t m0 x0 h4 y1bd7 ff7e fs1 fc0 sc0 ls2"> offsetHeight：元素在垂直方向上占用的空间大小，以像素计。包括元素的高度、（可见的）</div><div class="t m0 x5 h5 y1ed2 ff7f fs2 fc0 sc0 ls8 wseb">水平滚动条的高度、上边框高度和下边框高度。 </div><div class="t m0 x0 h4 y1ed3 ff7e fs1 fc0 sc0 ls2"> offsetWidth：元素在水平方向上占用的空间大小，以像素计。包括元素的宽度、（可见的）垂</div><div class="t m0 x5 h5 y1ed4 ff7f fs2 fc0 sc0 ls8 wseb">直滚动条的宽度、左边框宽度和右边框宽度。 </div><div class="t m0 x0 h5 yf6c ff7e fs1 fc0 sc0 ls2"> offsetLeft：元素的左外边框至包含元素的左内边框之间的像素距离。 </div><div class="t m0 x0 h5 y2043 ff7e fs1 fc0 sc0 ls2"> offsetTop：元素的上外边框至包含元素的上内边框之间的像素距离。 </div><div class="t m0 x0 h1e ycbd ff7f fs2 fc0 sc0 ls8 wseb">其中，offsetLeft和offsetTop属性与包含元素有关，包含元素的引用保存在offsetParent</div><div class="t m0 x0 h4 y20ef ff7f fs2 fc0 sc0 ls8 wseb">属性中。offsetParent属性不一定与parentNode的值相等。例如，&lt;td&gt;元素的offsetParent是</div><div class="t m0 x0 hc y21d5 ff7f fs2 fc0 sc0 ls8 wseb">作为其祖先元素的&lt;table&gt;元素，因为&lt;table&gt;是在DOM层次中距&lt;td&gt;最近的一个具有大小的元素。</div><div class="t m0 x0 h5 ycc0 ff7f fs2 fc0 sc0 ls3b">图12-1形象地展示了上面几个属性表示的不同大小。 </div><div class="t m0 x2 h5 y11c5 ff78 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 h3 y21d6 ff7f fs1 fc0 sc0 ls8 wsb">图 12-1 </div><div class="t m0 x0 h4 y21d7 ff7f fs2 fc0 sc0 ls5c ws10f">要想知道某个元素在页面上的偏移量，将这个元素的offsetLeft和offsetTop与其of fsetParent</div><div class="t m0 x0 h4 y21d8 ff7f fs2 fc0 sc0 ls8 wseb">的相同属性相加，如此循环直至根元素，就可以得到一个基本准确的值。以下两个函数就可以用于分别</div><div class="t m0 x0 h5 y21d9 ff7f fs2 fc0 sc0 ls8 wseb">取得元素的左和上偏移量。 </div><div class="t m0 x5 hb yb63 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y21da ff83 fs6 fc0 sc0 ls21 wsb">function getElementLeft(element){ </div><div class="t m0 x0 hb y21db ff83 fs6 fc0 sc0 ls21 wsb">    var actualLeft = element.offsetLeft; </div><div class="t m0 x0 hb y21dc ff83 fs6 fc0 sc0 ls21 wsb">    var current = element.offsetParent; </div><div class="t m0 x0 hb y21dd ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y21de ff83 fs6 fc0 sc0 ls21 wsb">    while (current !== null){         </div><div class="t m0 x0 hb y21df ff83 fs6 fc0 sc0 ls21 wsb">        actualLeft += current.offsetLeft; </div><div class="t m0 x0 hb y21e0 ff83 fs6 fc0 sc0 ls21 wsb">        current = current.offsetParent; </div><div class="t m0 x0 hb y21e1 ff83 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y21e2 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y21e3 ff83 fs6 fc0 sc0 ls21 wsb">    return actualLeft; </div><div class="t m0 x0 hb y21e4 ff83 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y21e5 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x7 h36 y21e6 ff7f fs6 fc2 sc0 ls31">边框 </div><div class="t m0 x7 h36 y21e7 ff7f fs6 fc0 sc0 ls31 ws125">内边距 </div><div class="t m0 x7 hbc y21e8 ff7f fs6 fc0 sc0 ls31">内容 OffsetHeight </div><div class="t m0 x7 hb y21e9 ff83 fs6 fc0 sc0 ls21">offsetWidth</div><div class="c x4 y21ea w15 hbd"><div class="t m0 x0 hb y21eb ff83 fs6 fc0 sc0 ls8 wsb"> </div></div><div class="t m0 x4 hb y21ec ff83 fs6 fc0 sc0 ls21 wsb">offsetTop </div><div class="t m0 x1 hb y21ed ff83 fs6 fc0 sc0 ls21 wsb">offsetLeft </div><div class="t m0 x5 h15 y21ee ff84 fs6 fc0 sc0 ls21">offsetParent</div><div class="c x7 y21ef w16 hbe"><div class="t m0 x0 h15 y21f0 ff84 fs6 fc0 sc0 ls8 wsb"> </div></div></div></div>
<div id="pf154" class="pf w0 h0" data-page-no="154"><div class="pc pc154 w0 h0"><div class="t m0 x0 h2 y1 ff78 fs0 fc0 sc0 ls7 ws0">322  第12章 DOM2和DOM3 </div><div class="t m0 x0 h3 y2 ff78 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y8f5 ff83 fs6 fc0 sc0 ls21 wsb">function getElementTop(element){ </div><div class="t m0 x0 hb y8f6 ff83 fs6 fc0 sc0 ls21 wsb">    var actualTop = element.offsetTop; </div><div class="t m0 x0 hb y8f7 ff83 fs6 fc0 sc0 ls21 wsb">    var current = element.offsetParent; </div><div class="t m0 x0 hb y8f8 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y8f9 ff83 fs6 fc0 sc0 ls21 wsb">    while (current !== null){         </div><div class="t m0 x0 hb y8fa ff83 fs6 fc0 sc0 ls21 wsb">        actualTop += current. offsetTop; </div><div class="t m0 x0 hb y8fb ff83 fs6 fc0 sc0 ls21 wsb">        current = current.offsetParent; </div><div class="t m0 x0 hb y8fc ff83 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y8fd ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1037 ff83 fs6 fc0 sc0 ls21 wsb">    return actualTop; </div><div class="t m0 x0 hb y1038 ff83 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x2 hf y21f2 ff85 fs2 fc0 sc0 lsb wsb">OffsetDimensionsExample.htm </div><div class="t m0 x0 h5 y21f3 ff7f fs2 fc0 sc0 ls30 wsf6">这两个函数利用offsetParent属性在DOM层次中逐级向上回溯，将每个层次中的偏移量属性</div><div class="t m0 x0 h5 y21f4 ff7f fs2 fc0 sc0 ls30 wsf6">合计到一块。对于简单的CSS布局的页面，这两函数可以得到非常精确的结果。对于使用表格和内嵌</div><div class="t m0 x0 h4 y21f5 ff7f fs2 fc0 sc0 ls30 wsf6">框架布局的页面，由于不同浏览器实现这些元素的方式不同，因此得到的值就不太精确了。一般来说，</div><div class="t m0 x0 h1c y21f6 ff7f fs2 fc0 sc0 ls6f ws113">页面中的所有元素都会被包含在几个&lt;div&gt;元素中，而这些&lt;div&gt;元素的offsetParent又是</div><div class="t m0 x0 h4 y1783 ff83 fs1 fc0 sc0 ls3d ws2b">&lt;body&gt;元素，所以getElementLeft()与getElementTop()会返回与offsetLeft和offsetTop</div><div class="t m0 x0 h5 y1e2b ff7f fs2 fc0 sc0 ls30 wsf6">相同的值。 </div><div class="t m0 x5 ha y21f7 ff79 fs2 fc0 sc0 ls8 ws14">所有这些偏移量属性都是只读的，而且每次访问它们都需要重新计算。因此，应</div><div class="t m0 x0 ha y21f8 ff79 fs2 fc0 sc0 ls8 ws14">该尽量避免重复访问这些属性；如果需要重复使用其中某些属性的值，可以将它们保</div><div class="t m0 x0 h5 y21f9 ff79 fs2 fc0 sc0 ls8 ws14">存在局部变量中，以提高性能。 </div><div class="t m0 x0 h3c y21fa ff7d fs2 fc0 sc0 ls2e wsb">2. 客户区大小 </div><div class="t m0 x0 h5 y21fb ff7f fs2 fc0 sc0 ls8">元素的客户区大小（client dimension），指的是元素内容及其内边距所占据的空间大小。有关客户区</div><div class="t m0 x0 h4 y21fc ff7f fs2 fc0 sc0 ls8 wseb">大小的属性有两个：clientWidth和clientHeight。其中，clientWidth属性是元素内容区宽度加</div><div class="t m0 x0 hc y21fd ff7f fs2 fc0 sc0 ls8 wseb">上左右内边距宽度；clientHeight属性是元素内容区高度加上上下内边距高度。图12-2形象地说明</div><div class="t m0 x0 h5 y21fe ff7f fs2 fc0 sc0 ls8 wseb">了这些属性表示的大小。 </div><div class="t m0 x2 h5 y21ff ff78 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x7 h3 y2200 ff7f fs1 fc0 sc0 ls8 wsb">图 12-2 </div><div class="t m0 x7 h36 y2201 ff7f fs6 fc2 sc0 ls31">边框 </div><div class="t m0 x7 h36 y2202 ff7f fs6 fc0 sc0 ls31 ws125">内边距 </div><div class="t m0 x7 hc0 y2203 ff7f fs6 fc0 sc0 ls31">内容 clientHeight</div><div class="c x2 y2204 w17 hbd"><div class="t m0 x0 hb y21eb ff83 fs6 fc0 sc0 ls8 wsb"> </div></div><div class="t m0 x1 hb y2205 ff83 fs6 fc0 sc0 ls21">clientWidth</div><div class="c x7 y2206 w15 hbd"><div class="t m0 x0 hb y21eb ff83 fs6 fc0 sc0 ls8 wsb"> </div></div><div class="t m0 x5 h15 y1716 ff84 fs6 fc0 sc0 ls21">offsetParent</div><div class="c x1 y2207 w16 hbe"><div class="t m0 x0 h15 y21f0 ff84 fs6 fc0 sc0 ls8 wsb"> </div></div></div></div>
<div id="pf155" class="pf w0 h0" data-page-no="155"><div class="pc pc155 w0 h0"><div class="t m0 x2 h2 y1 ff78 fs0 fc0 sc0 ls7 ws0">12.2 样式  323 </div><div class="t m0 x0 h3 y2 ff78 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff7a fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff7a fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff7a fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff7a fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff7a fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff7a fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff7a fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff7a fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff7a fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff7a fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff7a fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff7a fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff7a fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h4 y3 ff7f fs2 fc0 sc0 ls8 wseb">从字面上看，客户区大小就是元素内部的空间大小，因此滚动条占用的空间不计算在内。最常用到</div><div class="t m0 x0 h5 y4d ff7f fs2 fc0 sc0 ls8 wseb">这些属性的情况，就是像第8章讨论的确定浏览器视口大小的时候。如下面的例子所示，要确定浏览器</div><div class="t m0 x0 he yd8 ff7f fs2 fc0 sc0 ls8 wseb">视口大小，可以使用document.documentElement或document.body（在 IE7之前的版本中）的</div><div class="t m0 x0 h5 yd9 ff83 fs1 fc0 sc0 ls9 ws2">clientWidth和clientHeight。 </div><div class="t m0 x5 hb ye5c ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ye5d ff83 fs6 fc0 sc0 ls21 wsb">function getViewport(){ </div><div class="t m0 x0 hb ye5e ff83 fs6 fc0 sc0 ls21 wsb">    if (document.compatMode == &quot;BackCompat&quot;){ </div><div class="t m0 x0 hb ye5f ff83 fs6 fc0 sc0 ls21 wsb">        return { </div><div class="t m0 x0 hb ye60 ff83 fs6 fc0 sc0 ls21 wsb">            width: document.body.clientWidth, </div><div class="t m0 x0 hb y2208 ff83 fs6 fc0 sc0 ls21 wsb">            height: document.body.clientHeight </div><div class="t m0 x0 hb y2209 ff83 fs6 fc0 sc0 ls21 wsb">        }; </div><div class="t m0 x0 hb y220a ff83 fs6 fc0 sc0 ls21 wsb">    } else { </div><div class="t m0 x0 hb y220b ff83 fs6 fc0 sc0 ls21 wsb">        return { </div><div class="t m0 x0 hb y220c ff83 fs6 fc0 sc0 ls21 wsb">            width: document.documentElement.clientWidth, </div><div class="t m0 x0 hb y220d ff83 fs6 fc0 sc0 ls21 wsb">            height: document.documentElement.clientHeight </div><div class="t m0 x0 hb y220e ff83 fs6 fc0 sc0 ls21 wsb">        }; </div><div class="t m0 x0 hb y220f ff83 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y2210 ff83 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h5 y2211 ff7f fs2 fc0 sc0 ls8 wseb">这个函数首先检查document.compatMode属性，以确定浏览器是否运行在混杂模式。Safari 3.1</div><div class="t m0 x0 h5 y11b8 ff7f fs2 fc0 sc0 ls8 wseb">之前的版本不支持这个属性，因此就会自动执行else语句。Chrome、Opera和Firefox大多数情况下都</div><div class="t m0 x0 h1e y11b9 ff7f fs2 fc0 sc0 ls8 wseb">运行在标准模式下，因此它们也会前进到else语句。这个函数会返回一个对象，包含两个属性：width</div><div class="t m0 x0 h5 yc5f ff7f fs2 fc0 sc0 ls2c">和height；表示浏览器视口（&lt;html&gt;或&lt;body&gt;元素）的大小。 </div><div class="t m0 x5 h5 y2212 ff79 fs2 fc0 sc0 ls8 ws14">与偏移量相似，客户区大小也是只读的，也是每次访问都要重新计算的。 </div><div class="t m0 x0 h3c y2213 ff7d fs2 fc0 sc0 ls2e wsb">3. 滚动大小 </div><div class="t m0 x0 h5 y2214 ff7f fs2 fc0 sc0 ls8 wseb">最后要介绍的是滚动大小（scroll dimension），指的是包含滚动内容的元素的大小。有些元素（例如</div><div class="t m0 x0 h5 y2215 ff83 fs1 fc0 sc0 ls9 ws2">&lt;html&gt;元素），即使没有执行任何代码也能自动地添加滚动条；但另外一些元素，则需要通过CSS的</div><div class="t m0 x0 h5 y2216 ff83 fs1 fc0 sc0 ls9 ws2">overflow属性进行设置才能滚动。以下是4个与滚动大小相关的属性。 </div><div class="t m0 x0 h5 y16bc ff7e fs1 fc0 sc0 ls2"> scrollHeight：在没有滚动条的情况下，元素内容的总高度。 </div><div class="t m0 x0 h5 y1695 ff7e fs1 fc0 sc0 ls2"> scrollWidth：在没有滚动条的情况下，元素内容的总宽度。 </div><div class="t m0 x0 h5 y2217 ff7e fs1 fc0 sc0 ls2"> scrollLeft：被隐藏在内容区域左侧的像素数。通过设置这个属性可以改变元素的滚动位置。 </div><div class="t m0 x0 h5 y1e58 ff7e fs1 fc0 sc0 ls2"> scrollTop：被隐藏在内容区域上方的像素数。通过设置这个属性可以改变元素的滚动位置。 </div><div class="t m0 x0 h5 y1e59 ff7f fs2 fc0 sc0 ls3b">图12-3展示了这些属性代表的大小。 </div><div class="t m0 x0 h4 y2218 ff83 fs1 fc0 sc0 ls9 ws2">scrollWidth和scrollHeight主要用于确定元素内容的实际大小。例如，通常认为&lt;html&gt;元素</div><div class="t m0 x0 h5 y2219 ff7f fs2 fc0 sc0 ls8 wseb">是在Web浏览器的视口中滚动的元素（IE6之前版本运行在混杂模式下时是&lt;body&gt;元素）。因此，带有</div><div class="t m0 x0 h5 y221a ff7f fs2 fc0 sc0 ls8 wseb">垂直滚动条的页面总高度就是document.documentElement.scrollHeight。 </div><div class="t m0 x0 h1e y221b ff7f fs2 fc0 sc0 ls253 ws21b">对于不包含滚动条的页面而言，scrollWidth和scrollHeight 与clientWidth和</div><div class="t m0 x0 h4 y221c ff83 fs1 fc0 sc0 ls9 ws2">clientHeight之间的关系并不十分清晰。在这种情况下，基于document.documentElement 查看</div><div class="t m0 x0 h5 y221d ff7f fs2 fc0 sc0 ls8 wseb">这些属性会在不同浏览器间发现一些不一致性问题，如下所述。 </div><div class="t m0 x0 h5 y221e ff7e fs1 fc0 sc0 ls2"> Firefox中这两组属性始终都是相等的，但大小代表的是文档内容区域的实际尺寸，而非视口的</div><div class="t m0 x5 h5 y221f ff7f fs2 fc0 sc0 ls8">尺寸。 </div><div class="t m0 x0 h5 y21b5 ff7e fs1 fc0 sc0 ls2"> Opera、Safari 3.1及更高版本、Chrome中的这两组属性是有差别的，其中 scrollWidth和</div><div class="t m0 x5 h5 y2220 ff83 fs1 fc0 sc0 ls9 ws2">scrollHeight等于视口大小，而clientWidth和clientHeight等于文档内容区域的大小。 </div></div></div>
<div id="pf156" class="pf w0 h0" data-page-no="156"><div class="pc pc156 w0 h0"><div class="t m0 x0 h2 y1 ff78 fs0 fc0 sc0 ls7 ws0">324  第12章 DOM2和DOM3 </div><div class="t m0 x0 h3 y2 ff78 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff7e fs1 fc0 sc0 ls2"> IE（在标准模式）中的这两组属性不相等，其中scrollWidth和scrollHeight等于文档内</div><div class="t m0 x0 hc y4d ff7f fs2 fc0 sc0 ls8 wseb">容区域的大小，而clientWidth和clientHeight等于视口大小。 </div><div class="t m0 x2 h5 y2222 ff78 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x7 h3 y2223 ff7f fs1 fc0 sc0 ls8 wsb">图 12-3 </div><div class="t m0 x0 h4 y2224 ff7f fs2 fc0 sc0 ls8 wseb">在确定文档的总高度时（包括基于视口的最小高度时），必须取得scrollWidth/clientWidth和</div><div class="t m0 x0 h4 y2225 ff83 fs1 fc0 sc0 ls9 ws2">scrollHeight/clientHeight中的最大值，才能保证在跨浏览器的环境下得到精确的结果。下面就</div><div class="t m0 x0 h5 y2226 ff7f fs2 fc0 sc0 ls8 wseb">是这样一个例子。 </div><div class="t m0 x0 hb y2227 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2228 ff83 fs6 fc0 sc0 ls21 wsb">var docHeight = Math.max(document.documentElement.scrollHeight, </div><div class="t m0 x0 hb y2229 ff83 fs6 fc0 sc0 ls21 ws211">            document.documentElement.clientHeight); </div><div class="t m0 x0 hb y222a ff83 fs6 fc0 sc0 ls21 wsb">var docWidth = Math.max(document.documentElement.scrollWidth, </div><div class="t m0 x0 hb y222b ff83 fs6 fc0 sc0 ls21 ws211">            document.documentElement.clientWidth); </div><div class="t m0 x0 hb y222c ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y589 ff7f fs2 fc0 sc0 ls60 ws140">注意，对于运行在混杂模式下的IE，则需要用document.body 代替document.document- </div><div class="t m0 x0 h5 y222d ff83 fs1 fc0 sc0 ls9 ws2">Element。 </div><div class="t m0 x0 h1e y222e ff7f fs2 fc0 sc0 ls8 wseb">通过scrollLeft和scrollTop属性既可以确定元素当前滚动的状态，也可以设置元素的滚动位</div><div class="t m0 x0 h5 y222f ff7f fs2 fc0 sc0 ls8 wseb">置。在元素尚未被滚动时，这两个属性的值都等于0。如果元素被垂直滚动了，那么scrollTop的值</div><div class="t m0 x0 h5 y2230 ff7f fs2 fc0 sc0 ls8 wseb">会大于0，且表示元素上方不可见内容的像素高度。如果元素被水平滚动了，那么scrollLeft的值会</div><div class="t m0 x0 h5 y2231 ff7f fs2 fc0 sc0 ls6f ws113">大于0，且表示元素左侧不可见内容的像素宽度。这两个属性都是可以设置的，因此将元素的</div><div class="t m0 x0 h5 y2232 ff83 fs1 fc0 sc0 ls9 ws2">scrollLeft和scrollTop设置为0，就可以重置元素的滚动位置。下面这个函数会检测元素是否位</div><div class="t m0 x0 h5 y2233 ff7f fs2 fc0 sc0 ls8 wseb">于顶部，如果不是就将其回滚到顶部。 </div><div class="t m0 x0 hb y2234 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2235 ff83 fs6 fc0 sc0 ls21 wsb">function scrollToTop(element){ </div><div class="t m0 x0 hb y2236 ff83 fs6 fc0 sc0 ls21 wsb">    if (element.scrollTop != 0){ </div><div class="t m0 x0 hb y2237 ff83 fs6 fc0 sc0 ls21 wsb">        element.scrollTop = 0; </div><div class="t m0 x0 hb y2238 ff83 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y2239 ff83 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h5 y223a ff7f fs2 fc0 sc0 ls8 wseb">这个函数既取得了scrollTop的值，也设置了它的值。 </div><div class="t m0 x0 h3c y223b ff7d fs2 fc0 sc0 ls2e wsb">4. 确定元素大小 </div><div class="t m0 x0 h5 y223c ff78 fs2 fc0 sc0 ls27f ws241">IE、Firefox 3+、Safari 4+、Opera 9.5及Chrome为每个元素都提供了一个getBoundingClientRect()方</div><div class="t m0 x0 h5 y223d ff7f fs2 fc0 sc0 ls8 wseb">法。这个方法返回会一个矩形对象，包含4个属性：left、top、right和bottom。这些属性给出了</div></div></div>
<div id="pf157" class="pf w0 h0" data-page-no="157"><div class="pc pc157 w0 h0"><div class="t m0 x2 h2 y1 ff78 fs0 fc0 sc0 ls7 ws0">12.2 样式  325 </div><div class="t m0 x0 h3 y2 ff78 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff7a fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff7a fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff7a fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff7a fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff7a fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff7a fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff7a fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff7a fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff7a fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff7a fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff7a fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff7a fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff7a fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff7f fs2 fc0 sc0 ls8 wseb">元素在页面中相对于视口的位置。但是，浏览器的实现稍有不同。IE8及更早版本认为文档的左上角坐</div><div class="t m0 x0 h5 y4d ff7f fs2 fc0 sc0 ls8">标是(2, 2)，而其他浏览器包括IE9则将传统的(0,0)作为起点坐标。因此，就需要在一开始检查一下位于</div><div class="t m0 x0 h5 yd8 ff78 fs2 fc0 sc0 ls46 ws37">(0,0)处的元素的位置，在IE8及更早版本中，会返回(2,2)，而在其他浏览器中会返回(0,0)。来看下面的</div><div class="t m0 x0 h5 y28b ff7f fs2 fc0 sc0 ls8">函数： </div><div class="t m0 x5 hb ya81 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ya82 ff83 fs6 fc0 sc0 ls21 wsb">function getBoundingClientRect(element){ </div><div class="t m0 x0 hb ya83 ff83 fs6 fc0 sc0 ls21 wsb">    if (typeof arguments.callee.offset != &quot;number&quot;){ </div><div class="t m0 x0 hb y1908 ff83 fs6 fc0 sc0 ls21 wsb">        var scrollTop = document.documentElement.scrollTop; </div><div class="t m0 x0 hb y1909 ff83 fs6 fc0 sc0 ls21 wsb">        var temp = document.createElement(&quot;div&quot;); </div><div class="t m0 x0 hb y190a ff83 fs6 fc0 sc0 ls21 wsb">        temp.style.cssText = &quot;position:absolute;left:0;top:0;&quot;; </div><div class="t m0 x0 hb y190b ff83 fs6 fc0 sc0 ls21 wsb">        document.body.appendChild(temp); </div><div class="t m0 x0 hb y190c ff83 fs6 fc0 sc0 ls21 wsb">        arguments.callee.offset = -temp.getBoundingClientRect().top - scrollTop; </div><div class="t m0 x0 hb y190d ff83 fs6 fc0 sc0 ls21 wsb">        document.body.removeChild(temp); </div><div class="t m0 x0 hb y190e ff83 fs6 fc0 sc0 ls21 wsb">        temp = null; </div><div class="t m0 x0 hb y190f ff83 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y1910 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1911 ff83 fs6 fc0 sc0 ls21 wsb">    var rect = element.getBoundingClientRect(); </div><div class="t m0 x0 hb y223e ff83 fs6 fc0 sc0 ls21 wsb">    var offset = arguments.callee.offset; </div><div class="t m0 x0 hb y223f ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2240 ff83 fs6 fc0 sc0 ls21 wsb">    return { </div><div class="t m0 x0 hb y2241 ff83 fs6 fc0 sc0 ls21 wsb">        left: rect.left + offset, </div><div class="t m0 x0 hb y2242 ff83 fs6 fc0 sc0 ls21 wsb">        right: rect.right + offset, </div><div class="t m0 x0 hb y2243 ff83 fs6 fc0 sc0 ls21 wsb">        top: rect.top + offset, </div><div class="t m0 x0 hb y2244 ff83 fs6 fc0 sc0 ls21 wsb">        bottom: rect.bottom + offset </div><div class="t m0 x0 hb y2245 ff83 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 hb y2246 ff83 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x2 hf y2247 ff85 fs2 fc0 sc0 ls25 wsb">GetBoundingClientRectExample.htm </div><div class="t m0 x0 h4 y2248 ff7f fs2 fc0 sc0 ls8 wseb">这个函数使用了它自身的属性来确定是否要对坐标进行调整。第一步是检测属性是否有定义，如果</div><div class="t m0 x0 hc2 y2249 ff7f fs2 fc0 sc0 ls8 wseb">没有就定义一个。最终的offset会被设置为新元素上坐标的负值，实际上就是在IE 中设置为2，在</div><div class="t m0 x0 h25 y224a ff78 fs2 fc0 sc0 ls47 ws38">Firefox和Opera中设置为0。为此，需要创建一个临时的元素，将其位置设置在(0,0)，然后再调用其</div><div class="t m0 x0 h4 y1ccf ff83 fs1 fc0 sc0 ls9 ws2">getBoundingClientRect()。而之所以要减去视口的scrollTop，是为了防止调用这个函数时窗口</div><div class="t m0 x0 h1e y224b ff7f fs2 fc0 sc0 ls6 wsf7">被滚动了。这样编写代码，就无需每次调用这个函数都执行两次getBoundingClientRect()了。接</div><div class="t m0 x0 h5 y1cd1 ff7f fs2 fc0 sc0 ls8 wseb">下来，再在传入的元素上调用这个方法并基于新的计算公式创建一个对象。 </div><div class="t m0 x0 h1c y224c ff7f fs2 fc0 sc0 ls6 wsf7">对于不支持getBoundingClientRect()的浏览器，可以通过其他手段取得相同的信息。一般来</div><div class="t m0 x0 h4 y224d ff7f fs2 fc0 sc0 ls8 wseb">说，right和left的差值与offsetWidth 的值相等，而bottom和top的差值与offsetHeight</div><div class="t m0 x0 h4 y224e ff7f fs2 fc0 sc0 ls8 wseb">相等。而且，left和top属性大致等于使用本章前面定义的getElementLeft()和getElementTop()</div><div class="t m0 x0 h5 y171c ff7f fs2 fc0 sc0 ls8 wseb">函数取得的值。综合上述，就可以创建出下面这个跨浏览器的函数： </div><div class="t m0 x5 hb y224f ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2250 ff83 fs6 fc0 sc0 ls21 wsb">function getBoundingClientRect(element){ </div><div class="t m0 x0 hb y2251 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y2252 ff84 fs6 fc0 sc0 ls21 wsb">    var scrollTop = document.documentElement.scrollTop; </div><div class="t m0 x0 h15 y2253 ff84 fs6 fc0 sc0 ls21 wsb">    var scrollLeft = document.documentElement.scrollLeft; </div><div class="t m0 x0 h15 y2254 ff84 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 h15 y2255 ff84 fs6 fc0 sc0 ls21 wsb">    if (element.getBoundingClientRect){ </div><div class="t m0 x0 hb y2256 ff83 fs6 fc0 sc0 ls21 wsb">        if (typeof arguments.callee.offset != &quot;number&quot;){ </div><div class="t m0 x0 hb y2257 ff83 fs6 fc0 sc0 ls21 wsb">            var temp = document.createElement(&quot;div&quot;); </div><div class="t m0 x0 hb y2258 ff83 fs6 fc0 sc0 ls21 wsb">            temp.style.cssText = &quot;position:absolute;left:0;top:0;&quot;; </div><div class="t m0 x0 hb y2259 ff83 fs6 fc0 sc0 ls21 wsb">            document.body.appendChild(temp); </div><div class="t m0 x0 hb y225a ff83 fs6 fc0 sc0 ls21 wsb">            arguments.callee.offset = -temp.getBoundingClientRect().top - scrollTop; </div><div class="t m0 x0 hb y225b ff83 fs6 fc0 sc0 ls21 wsb">            document.body.removeChild(temp); </div></div></div>
<div id="pf158" class="pf w0 h0" data-page-no="158"><div class="pc pc158 w0 h0"><div class="t m0 x0 h2 y1 ff78 fs0 fc0 sc0 ls7 ws0">326  第12章 DOM2和DOM3 </div><div class="t m0 x0 h3 y2 ff78 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y225d ff83 fs6 fc0 sc0 ls21 wsb">            temp = null; </div><div class="t m0 x0 hb y225e ff83 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y225f ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2260 ff83 fs6 fc0 sc0 ls21 wsb">        var rect = element.getBoundingClientRect(); </div><div class="t m0 x0 hb y2261 ff83 fs6 fc0 sc0 ls21 wsb">        var offset = arguments.callee.offset; </div><div class="t m0 x0 hb y2262 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2263 ff83 fs6 fc0 sc0 ls21 wsb">        return { </div><div class="t m0 x0 hb y2264 ff83 fs6 fc0 sc0 ls21 wsb">            left: rect.left + offset, </div><div class="t m0 x0 hb y2265 ff83 fs6 fc0 sc0 ls21 wsb">            right: rect.right + offset, </div><div class="t m0 x0 hb y2266 ff83 fs6 fc0 sc0 ls21 wsb">            top: rect.top + offset, </div><div class="t m0 x0 hb y2267 ff83 fs6 fc0 sc0 ls21 wsb">            bottom: rect.bottom + offset </div><div class="t m0 x0 hb y2268 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2269 ff83 fs6 fc0 sc0 ls21 wsb">        }; </div><div class="t m0 x0 h15 y226a ff84 fs6 fc0 sc0 ls21 wsb">    } else { </div><div class="t m0 x0 h15 y226b ff84 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y226c ff84 fs6 fc0 sc0 ls21 wsb">        var actualLeft = getElementLeft(element); </div><div class="t m0 x0 h15 y226d ff84 fs6 fc0 sc0 ls21 wsb">        var actualTop = getElementTop(element); </div><div class="t m0 x0 h15 y226e ff84 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y226f ff84 fs6 fc0 sc0 ls21 wsb">       return { </div><div class="t m0 x0 h15 y2270 ff84 fs6 fc0 sc0 ls21 wsb">            left: actualLeft - scrollLeft, </div><div class="t m0 x0 h15 y2271 ff84 fs6 fc0 sc0 ls21 wsb">            right: actualLeft + element.offsetWidth - scrollLeft, </div><div class="t m0 x0 h15 y2272 ff84 fs6 fc0 sc0 ls21 wsb">            top: actualTop - scrollTop, </div><div class="t m0 x0 h15 y2273 ff84 fs6 fc0 sc0 ls21 wsb">            bottom: actualTop + element.offsetHeight - scrollTop </div><div class="t m0 x0 h15 y2274 ff84 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 h15 y2275 ff84 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y2276 ff83 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x4 hf y2277 ff85 fs2 fc0 sc0 ls25 wsb">GetBoundingClientRectExample.htm </div><div class="t m0 x0 h4 y2278 ff7f fs2 fc0 sc0 ls6 wsf7">这个函数在getBoundingClientRect()有效时，就使用这个原生方法，而在这个方法无效时则</div><div class="t m0 x0 h4 y2279 ff7f fs2 fc0 sc0 ls8 wseb">使用默认的计算公式。在某些情况下，这个函数返回的值可能会有所不同，例如使用表格布局或使用滚</div><div class="t m0 x0 h5 y227a ff7f fs2 fc0 sc0 ls8 wseb">动元素的情况下。 </div><div class="t m0 x5 h17 y227b ff79 fs2 fc0 sc0 ls8 ws14">由于这里使用了arguments.callee，所以这个方法不能在严格模式下使用。 </div><div class="t m0 x0 hd y227c ff7d fs7 fc0 sc0 ls245">12.3 遍历 </div><div class="t m0 x0 h5 y227d ff7f fs2 fc0 sc0 ls8">“DOM2级遍历和范围”模块定义了两个用于辅助完成顺序遍历DOM结构的类型：NodeIterator</div><div class="t m0 x0 h5 y227e ff7f fs2 fc0 sc0 ls2c">和TreeWalker。这两个类型能够基于给定的起点对DOM结构执行深度优先（depth-first）的遍历操作。</div><div class="t m0 x0 h5 y227f ff7f fs2 fc0 sc0 ls8 wseb">在与DOM兼容的浏览器中（Firefox 1及更高版本、Safari 1.3及更高版本、Opera 7.6及更高版本、Chrome </div><div class="t m0 x0 h5 y2280 ff78 fs2 fc0 sc0 lsd2 ws19b">0.2及更高版本），都可以访问到这些类型的对象。IE不支持DOM遍历。使用下列代码可以检测浏览器</div><div class="t m0 x0 h5 y2281 ff7f fs2 fc0 sc0 ls3b">对DOM2级遍历能力的支持情况。 </div><div class="t m0 x0 hb y2282 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2283 ff83 fs6 fc0 sc0 ls21 wsb">var supportsTraversals = document.implementation.hasFeature(&quot;Traversal&quot;, &quot;2.0&quot;); </div><div class="t m0 x0 hb y2284 ff83 fs6 fc0 sc0 ls21 wsb">var supportsNodeIterator = (typeof document.createNodeIterator == &quot;function&quot;); </div><div class="t m0 x0 hb y2285 ff83 fs6 fc0 sc0 ls21 wsb">var supportsTreeWalker = (typeof document.createTreeWalker == &quot;function&quot;); </div><div class="t m0 x0 hb y2286 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 yb3d ff7f fs2 fc0 sc0 ls30 wsf6">如前所述，DOM遍历是深度优先的DOM结构遍历，也就是说，移动的方向至少有两个（取决</div><div class="t m0 x0 h5 y2287 ff7f fs2 fc0 sc0 ls30 wsf6">于使用的遍历类型）。遍历以给定节点为根，不可能向上超出DOM树的根节点。以下面的HTML页</div><div class="t m0 x0 h5 y2288 ff7f fs2 fc0 sc0 ls30 wsf6">面为例。 </div></div></div>
<div id="pf159" class="pf w0 h0" data-page-no="159"><div class="pc pc159 w0 h0"><div class="t m0 x2 h2 y1 ff78 fs0 fc0 sc0 ls7 ws0">12.3 遍历  327 </div><div class="t m0 x0 h3 y2 ff78 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff7a fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff7a fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff7a fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff7a fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff7a fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff7a fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff7a fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff7a fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff7a fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff7a fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff7a fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff7a fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff7a fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y79 ff83 fs6 fc0 sc0 ls21 wsb">&lt;!DOCTYPE html&gt; </div><div class="t m0 x0 hb y7a ff83 fs6 fc0 sc0 ls21 wsb">&lt;html&gt; </div><div class="t m0 x0 hb y7b ff83 fs6 fc0 sc0 ls21 wsb">    &lt;head&gt; </div><div class="t m0 x0 hb y7c ff83 fs6 fc0 sc0 ls21 wsb">        &lt;title&gt;Example&lt;/title&gt; </div><div class="t m0 x0 hb y7d ff83 fs6 fc0 sc0 ls21 wsb">    &lt;/head&gt; </div><div class="t m0 x0 hb y7e ff83 fs6 fc0 sc0 ls21 wsb">    &lt;body&gt; </div><div class="t m0 x0 hb y7f ff83 fs6 fc0 sc0 ls21 wsb">        &lt;p&gt;&lt;b&gt;Hello&lt;/b&gt; world!&lt;/p&gt; </div><div class="t m0 x0 hb y80 ff83 fs6 fc0 sc0 ls21 wsb">    &lt;/body&gt; </div><div class="t m0 x0 hb y81 ff83 fs6 fc0 sc0 ls21 wsb">&lt;/html&gt; </div><div class="t m0 x5 hb y1107 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y2289 ff7f fs2 fc0 sc0 ls3b">图12-4展示了这个页面的DOM树。 </div><div class="t m0 x2 h5 y14ca ff78 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 h3 y228a ff7f fs1 fc0 sc0 ls8 wsb">图 12-4 </div><div class="t m0 x0 h4 y228b ff7f fs2 fc0 sc0 ls42 wsf0">任何节点都可以作为遍历的根节点。如果假设&lt;body&gt;元素为根节点，那么遍历的第一步就是访问&lt;p&gt;</div><div class="t m0 x0 h4 y228c ff7f fs2 fc0 sc0 ls42 wsf0">元素，然后再访问同为&lt;body&gt;元素后代的两个文本节点。不过，这次遍历永远不会到达&lt;html&gt;、&lt;head&gt;</div><div class="t m0 x0 h4 y228d ff7f fs2 fc0 sc0 ls42 wsf0">元素，也不会到达不属于&lt;body&gt;元素子树的任何节点。而以document为根节点的遍历则可以访问到文</div><div class="t m0 x0 hc y228e ff7f fs2 fc0 sc0 ls42 wsf0">档中的全部节点。图12-5展示了对以document为根节点的DOM 树进行深度优先遍历的先后顺序。 </div><div class="t m0 x2 h5 y1dcc ff78 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 h3 ya80 ff7f fs1 fc0 sc0 ls8 wsb">图 12-5 </div></div></div>
<div id="pf15a" class="pf w0 h0" data-page-no="15a"><div class="pc pc15a w0 h0"><div class="t m0 x0 h2 y1 ff78 fs0 fc0 sc0 ls7 ws0">328  第12章 DOM2和DOM3 </div><div class="t m0 x0 h3 y2 ff78 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ff7f fs2 fc0 sc0 ls2f0">从document开始依序向前，访问的第一个节点是document，访问的最后一个节点是包含</div><div class="t m0 x0 h5 y4 ff83 fs1 fc0 sc0 ls9 ws2">&quot;world!&quot;的文本节点。从文档最后的文本节点开始，遍历可以反向移动到DOM树的顶端。此时，访</div><div class="t m0 x0 h1e y5 ff7f fs2 fc0 sc0 ls8 wseb">问的第一个节点是包含&quot;Hello&quot;的文本节点，访问的最后一个节点是document节点。NodeIterator</div><div class="t m0 x0 h5 yd9 ff7f fs2 fc0 sc0 ls2c">和TreeWalker都以这种方式执行遍历。 </div><div class="t m0 x0 h20 y228f ff7d fs3 fc0 sc0 ls248 ws214">12.3.1 NodeIterator </div><div class="t m0 x0 h4 y2290 ff83 fs1 fc0 sc0 ls9 ws2">NodeIterator类型是两者中比较简单的一个，可以使用document.createNodeIterator()方</div><div class="t m0 x0 h5 y2291 ff7f fs2 fc0 sc0 ls8 wseb">法创建它的新实例。这个方法接受下列4个参数。 </div><div class="t m0 x0 h5 y2292 ff7e fs1 fc0 sc0 ls2"> root：想要作为搜索起点的树中的节点。 </div><div class="t m0 x0 h5 y2293 ff7e fs1 fc0 sc0 ls2"> whatToShow：表示要访问哪些节点的数字代码。 </div><div class="t m0 x0 h5 y2294 ff7e fs1 fc0 sc0 ls2"> filter：是一个NodeFilter对象，或者一个表示应该接受还是拒绝某种特定节点的函数。 </div><div class="t m0 x0 h5 y7d6 ff7e fs1 fc0 sc0 ls2"> entityReferenceExpansion：布尔值，表示是否要扩展实体引用。这个参数在HTML页面</div><div class="t m0 x0 h5 y7d7 ff7f fs2 fc0 sc0 ls8 wseb">中没有用，因为其中的实体引用不能扩展。 </div><div class="t m0 x0 h5 y1a8b ff83 fs1 fc0 sc0 ls9 ws2">whatToShow参数是一个位掩码，通过应用一或多个过滤器（filter）来确定要访问哪些节点。这个</div><div class="t m0 x0 h5 y2295 ff7f fs2 fc0 sc0 ls8 wseb">参数的值以常量形式在NodeFilter类型中定义，如下所示。 </div><div class="t m0 x0 h5 y2296 ff7e fs1 fc0 sc0 ls2"> NodeFilter.SHOW_ALL：显示所有类型的节点。 </div><div class="t m0 x0 h5 y7db ff7e fs1 fc0 sc0 ls2"> NodeFilter.SHOW_ELEMENT：显示元素节点。 </div><div class="t m0 x0 h5 y2297 ff7e fs1 fc0 sc0 ls8 ws134"> NodeFilter.SHOW_ATTRIBUTE：显示特性节点。由于DOM结构原因，实际上不能使用这个值。 </div><div class="t m0 x0 h5 y2298 ff7e fs1 fc0 sc0 ls2"> NodeFilter.SHOW_TEXT：显示文本节点。 </div><div class="t m0 x0 h5 y1c5d ff7e fs1 fc0 sc0 ls2"> NodeFilter.SHOW_CDATA_SECTION：显示CDATA节点。对HTML页面没有用。 </div><div class="t m0 x0 h5 y831 ff7e fs1 fc0 sc0 ls2"> NodeFilter.SHOW_ENTITY_REFERENCE：显示实体引用节点。对HTML页面没有用。 </div><div class="t m0 x0 h5 y278 ff7e fs1 fc0 sc0 ls2"> NodeFilter.SHOW_ENTITYE：显示实体节点。对HTML页面没有用。 </div><div class="t m0 x0 h5 y2299 ff7e fs1 fc0 sc0 ls2"> NodeFilter.SHOW_PROCESSING_INSTRUCTION：显示处理指令节点。对HTML页面没有用。 </div><div class="t m0 x0 h5 y229a ff7e fs1 fc0 sc0 ls2"> NodeFilter.SHOW_COMMENT：显示注释节点。 </div><div class="t m0 x0 h5 y15cd ff7e fs1 fc0 sc0 ls2"> NodeFilter.SHOW_DOCUMENT：显示文档节点。 </div><div class="t m0 x0 h5 y16bd ff7e fs1 fc0 sc0 ls2"> NodeFilter.SHOW_DOCUMENT_TYPE：显示文档类型节点。 </div><div class="t m0 x0 h5 y229b ff7e fs1 fc0 sc0 ls2"> NodeFilter.SHOW_DOCUMENT_FRAGMENT：显示文档片段节点。对HTML页面没有用。 </div><div class="t m0 x0 h5 y229c ff7e fs1 fc0 sc0 ls2"> NodeFilter.SHOW_NOTATION：显示符号节点。对HTML页面没有用。 </div><div class="t m0 x0 hc y229d ff7f fs2 fc0 sc0 ls8 wseb">除了NodeFilter.SHOW_ALL之外，可以使用按位或操作符来组合多个选项，如下面的例子所示： </div><div class="t m0 x0 hb y79e ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y229e ff83 fs6 fc0 sc0 ls21 wsb">var whatToShow = NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT; </div><div class="t m0 x0 hb y229f ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y22a0 ff7f fs2 fc0 sc0 ls8 wseb">可以通过createNodeIterator()方法的filter参数来指定自定义的NodeFilter 对象，或者</div><div class="t m0 x0 h5 y22a1 ff7f fs2 fc0 sc0 ls8 wseb">指定一个功能类似节点过滤器（node filter）的函数。每个NodeFilter 对象只有一个方法，即accept- </div><div class="t m0 x0 h42 y22a2 ff83 fs1 fc0 sc0 ls9 ws2">Node()；如果应该访问给定的节点，该方法返回NodeFilter.FILTER_ACCEPT，如果不应该访问给</div><div class="t m0 x0 h1e y22a3 ff7f fs2 fc0 sc0 ls8 wseb">定的节点，该方法返回NodeFilter.FILTER_SKIP。由于NodeFilter是一个抽象的类型，因此不能</div><div class="t m0 x0 h1e y22a4 ff7f fs2 fc0 sc0 ls5 wsec">直接创建它的实例。在必要时，只要创建一个包含acceptNode()方法的对象，然后将这个对象传入</div><div class="t m0 x0 h5 y22a5 ff83 fs1 fc0 sc0 ls9 ws2">createNodeIterator()中即可。例如，下列代码展示了如何创建一个只显示&lt;p&gt;元素的节点迭代器。 </div><div class="t m0 x0 hb y1168 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y22a6 ff83 fs6 fc0 sc0 ls21 wsb">var filter = { </div><div class="t m0 x0 hb y22a7 ff83 fs6 fc0 sc0 ls21 wsb">    acceptNode: function(node){ </div><div class="t m0 x0 hb y22a8 ff83 fs6 fc0 sc0 ls21 wsb">        return node.tagName.toLowerCase() == &quot;p&quot; ? </div></div></div>
<div id="pf15b" class="pf w0 h0" data-page-no="15b"><div class="pc pc15b w0 h0"><div class="t m0 x2 h2 y1 ff78 fs0 fc0 sc0 ls7 ws0">12.3 遍历  329 </div><div class="t m0 x0 h3 y2 ff78 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff7a fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff7a fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff7a fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff7a fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff7a fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff7a fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff7a fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff7a fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff7a fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff7a fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff7a fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff7a fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff7a fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y44f ff83 fs6 fc0 sc0 ls21 wsb">               NodeFilter.FILTER_ACCEPT : </div><div class="t m0 x0 hb y450 ff83 fs6 fc0 sc0 ls21 wsb">               NodeFilter.FILTER_SKIP; </div><div class="t m0 x0 hb y451 ff83 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y452 ff83 fs6 fc0 sc0 ls21 wsb">};  </div><div class="t m0 x0 hb y7ae ff83 fs6 fc0 sc0 ls21 wsb">var iterator = document.createNodeIterator(root, NodeFilter.SHOW_ELEMENT, </div><div class="t m0 x0 hb y7af ff83 fs6 fc0 sc0 ls21 wsb">                   filter, false); </div><div class="t m0 x5 hb y7b0 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y22a9 ff7f fs2 fc0 sc0 ls8 wseb">第三个参数也可以是一个与acceptNode()方法类似的函数，如下所示。 </div><div class="t m0 x5 hb y1ac ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y22aa ff84 fs6 fc0 sc0 ls21 wsb">var filter = function(node){ </div><div class="t m0 x0 h15 y22ab ff84 fs6 fc0 sc0 ls21 wsb">        return node.tagName.toLowerCase() == &quot;p&quot; ? </div><div class="t m0 x0 h15 y22ac ff84 fs6 fc0 sc0 ls21 wsb">               NodeFilter.FILTER_ACCEPT : </div><div class="t m0 x0 h15 y22ad ff84 fs6 fc0 sc0 ls21 wsb">               NodeFilter.FILTER_SKIP; </div><div class="t m0 x0 h15 y22ae ff84 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y22af ff83 fs6 fc0 sc0 ls21 wsb">var iterator = document.createNodeIterator(root, NodeFilter.SHOW_ELEMENT, </div><div class="t m0 x0 hb y22b0 ff84 fs6 fc0 sc0 ls21 wsb">                   filter, false); </div><div class="t m0 x5 hb y22b1 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y22b2 ff7f fs2 fc0 sc0 ls60 ws140">一般来说，这就是在JavaScript中使用这个方法的形式，这种形式比较简单，而且也跟其他的</div><div class="t m0 x0 hc y22b3 ff78 fs2 fc0 sc0 lsb ws5">JavaScript代码很相似。如果不指定过滤器，那么应该在第三个参数的位置上传入null。 </div><div class="t m0 x0 hc y22b4 ff7f fs2 fc0 sc0 ls8 wseb">下面的代码创建了一个能够访问所有类型节点的简单的NodeIterator。 </div><div class="t m0 x5 hb y22b5 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y22b6 ff83 fs6 fc0 sc0 ls21 wsb">var iterator = document.createNodeIterator(document, NodeFilter.SHOW_ALL, </div><div class="t m0 x0 hb y22b7 ff83 fs6 fc0 sc0 ls21 wsb">                   null, false); </div><div class="t m0 x5 hb y22b8 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y22b9 ff83 fs1 fc0 sc0 ls9 ws2">NodeIterator类型的两个主要方法是nextNode()和previousNode()。顾名思义，在深度优先</div><div class="t m0 x0 h5 y22ba ff7f fs2 fc0 sc0 ls141">的DOM子树遍历中，nextNode()方法用于向前前进一步，而previousNode()用于向后后退一步。</div><div class="t m0 x0 h1e y22bb ff7f fs2 fc0 sc0 ls8 wseb">在刚刚创建的NodeIterator对象中，有一个内部指针指向根节点，因此第一次调用nextNode() 会</div><div class="t m0 x0 h5 y22bc ff7f fs2 fc0 sc0 ls8 wseb">返回根节点。当遍历到DOM子树的最后一个节点时，nextNode()返回null。previousNode()方法</div><div class="t m0 x0 h5 y22bd ff7f fs2 fc0 sc0 ls8 wseb">的工作机制类似。当遍历到DOM子树的最后一个节点，且previousNode()返回根节点之后，再次调</div><div class="t m0 x0 hc y22be ff7f fs2 fc0 sc0 ls8 wseb">用它就会返回null。 </div><div class="t m0 x0 h5 y22bf ff7f fs2 fc0 sc0 ls8 wseb">以下面的HTML片段为例。 </div><div class="t m0 x5 h5 y22c0 ff78 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y22c1 ff83 fs6 fc0 sc0 ls21 wsb">&lt;div id=&quot;div1&quot;&gt; </div><div class="t m0 x0 hb y22c2 ff83 fs6 fc0 sc0 ls21 wsb">    &lt;p&gt;&lt;b&gt;Hello&lt;/b&gt; world!&lt;/p&gt; </div><div class="t m0 x0 hb y22c3 ff83 fs6 fc0 sc0 ls21 wsb">    &lt;ul&gt; </div><div class="t m0 x0 hb y22c4 ff83 fs6 fc0 sc0 ls21 wsb">        &lt;li&gt;List item 1&lt;/li&gt; </div><div class="t m0 x0 hb y22c5 ff83 fs6 fc0 sc0 ls21 wsb">        &lt;li&gt;List item 2&lt;/li&gt; </div><div class="t m0 x0 hb y22c6 ff83 fs6 fc0 sc0 ls21 wsb">        &lt;li&gt;List item 3&lt;/li&gt; </div><div class="t m0 x0 hb y22c7 ff83 fs6 fc0 sc0 ls21 wsb">    &lt;/ul&gt; </div><div class="t m0 x0 hb y22c8 ff83 fs6 fc0 sc0 ls21 wsb">&lt;/div&gt; </div><div class="t m0 x5 hb y22c9 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y22ca ff85 fs2 fc0 sc0 ls7a wsb">NodeIteratorExample1.htm </div><div class="t m0 x0 h5 y22cb ff7f fs2 fc0 sc0 ls8 wseb">假设我们想要遍历&lt;div&gt;元素中的所有元素，那么可以使用下列代码。 </div><div class="t m0 x5 hb y20a1 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y22cc ff83 fs6 fc0 sc0 ls21 wsb">var div = document.getElementById(&quot;div1&quot;); </div><div class="t m0 x0 hb y22cd ff83 fs6 fc0 sc0 ls21 wsb">var iterator = document.createNodeIterator(div, NodeFilter.SHOW_ELEMENT, </div><div class="t m0 x0 hb y22ce ff83 fs6 fc0 sc0 ls21 wsb">                   null, false); </div><div class="t m0 x0 hb y22cf ff83 fs6 fc0 sc0 ls21 wsb">var node = iterator.nextNode(); </div><div class="t m0 x0 hb y22d0 ff83 fs6 fc0 sc0 ls21 wsb">while (node !== null) { </div><div class="t m0 x0 h16 y22d1 ff83 fs6 fc0 sc0 ls21 wsb">    alert(node.tagName);        //输出标签名 </div><div class="t m0 x0 hb y22d2 ff83 fs6 fc0 sc0 ls21 wsb">    node = iterator.nextNode(); </div><div class="t m0 x0 hb y22d3 ff83 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x2 hf y22d4 ff85 fs2 fc0 sc0 ls7a wsb">NodeIteratorExample1.htm </div></div></div>
<div id="pf15c" class="pf w0 h0" data-page-no="15c"><div class="pc pc15c w0 h0"><div class="t m0 x0 h2 y1 ff78 fs0 fc0 sc0 ls7 ws0">330  第12章 DOM2和DOM3 </div><div class="t m0 x0 h3 y2 ff78 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff7f fs2 fc0 sc0 ls8 wseb">在这个例子中，第一次调用nextNode()返回&lt;p&gt;元素。因为在到达DOM子树末端时nextNode()</div><div class="t m0 x0 h4 y4 ff7f fs2 fc0 sc0 ls8 wseb">返回null，所以这里使用了while语句在每次循环时检查对 nextNode()的调用是否返回了null。</div><div class="t m0 x0 h5 y5 ff7f fs2 fc0 sc0 ls8 wseb">执行上面的代码会显示如下标签名： </div><div class="t m0 x0 hb y6bd ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y22d6 ff83 fs6 fc0 sc0 ls21 wsb">DIV </div><div class="t m0 x0 hb y22d7 ff83 fs6 fc0 sc0 ls21 wsb">P </div><div class="t m0 x0 hb y22d8 ff83 fs6 fc0 sc0 ls21 wsb">B </div><div class="t m0 x0 hb y22d9 ff83 fs6 fc0 sc0 ls21 wsb">UL </div><div class="t m0 x0 hb y22da ff83 fs6 fc0 sc0 ls21 wsb">LI </div><div class="t m0 x0 hb y22db ff83 fs6 fc0 sc0 ls21 wsb">LI </div><div class="t m0 x0 hb y22dc ff83 fs6 fc0 sc0 ls21 wsb">LI  </div><div class="t m0 x0 h4 y22dd ff7f fs2 fc0 sc0 ls5 wsec">也许用不着显示那么多信息，你只想返回遍历中遇到的&lt;li&gt;元素。很简单，只要使用一个过滤器</div><div class="t m0 x0 h5 y22de ff7f fs2 fc0 sc0 ls8 wseb">即可，如下面的例子所示。 </div><div class="t m0 x0 hb y1453 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y22df ff83 fs6 fc0 sc0 ls21 wsb">var div = document.getElementById(&quot;div1&quot;); </div><div class="t m0 x0 h15 y22e0 ff84 fs6 fc0 sc0 ls21 wsb">var filter = function(node){ </div><div class="t m0 x0 h15 y22e1 ff84 fs6 fc0 sc0 ls21 wsb">    return node.tagName.toLowerCase() == &quot;li&quot; ?  </div><div class="t m0 x0 h15 y22e2 ff84 fs6 fc0 sc0 ls21 wsb">        NodeFilter.FILTER_ACCEPT :  </div><div class="t m0 x0 h15 y22e3 ff84 fs6 fc0 sc0 ls21 wsb">        NodeFilter.FILTER_SKIP; </div><div class="t m0 x0 h15 y22e4 ff84 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 h15 y22e5 ff84 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y22e6 ff84 fs6 fc0 sc0 ls21 wsb">var iterator = document.createNodeIterator(div, NodeFilter.SHOW_ELEMENT,  </div><div class="t m0 x0 h15 y22e7 ff84 fs6 fc0 sc0 ls21 wsb">                   filter, false); </div><div class="t m0 x0 hb y22e8 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y22e9 ff83 fs6 fc0 sc0 ls21 wsb">var node = iterator.nextNode(); </div><div class="t m0 x0 hb y22ea ff83 fs6 fc0 sc0 ls21 wsb">while (node !== null) { </div><div class="t m0 x0 h16 y22eb ff83 fs6 fc0 sc0 ls21 wsb">    alert(node.tagName);        //输出标签名 </div><div class="t m0 x0 hb y22ec ff83 fs6 fc0 sc0 ls21 wsb">    node = iterator.nextNode(); </div><div class="t m0 x0 hb y22ed ff83 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x2 hf y206 ff85 fs2 fc0 sc0 ls7a wsb">NodeIteratorExample2.htm </div><div class="t m0 x0 h5 y67a ff7f fs2 fc0 sc0 ls8 wseb">在这个例子中，迭代器只会返回&lt;li&gt;元素。 </div><div class="t m0 x0 hc y22ee ff7f fs2 fc0 sc0 ls8 wseb">由于nextNode()和previousNode()方法都基于NodeIterator在DOM 结构中的内部指针工</div><div class="t m0 x0 h5 y22ef ff7f fs2 fc0 sc0 ls8 wseb">作，所以DOM结构的变化会反映在遍历的结果中。 </div><div class="t m0 x5 h5 y22f0 ff78 fs2 fc0 sc0 ls47 wsaa">Firefox 3.5之前的版本没有实现createNodeIterator()方法，但却支持下一</div><div class="t m0 x0 h18 y22f1 ff79 fs2 fc0 sc0 ls8 ws14">节要讨论的createTreeWalker()方法。 </div><div class="t m0 x0 h20 y22f2 ff7d fs3 fc0 sc0 ls248 ws214">12.3.2 TreeWalker </div><div class="t m0 x0 h4 y1a1 ff83 fs1 fc0 sc0 ls9 ws2">TreeWalker是NodeIterator的一个更高级的版本。除了包括nextNode()和previousNode()</div><div class="t m0 x0 h5 y1a2 ff7f fs2 fc0 sc0 ls8 wseb">在内的相同的功能之外，这个类型还提供了下列用于在不同方向上遍历DOM结构的方法。 </div><div class="t m0 x0 h5 y22f3 ff7e fs1 fc0 sc0 ls2"> parentNode()：遍历到当前节点的父节点； </div><div class="t m0 x0 h5 y22f4 ff7e fs1 fc0 sc0 ls2"> firstChild()：遍历到当前节点的第一个子节点； </div><div class="t m0 x0 h5 y22f5 ff7e fs1 fc0 sc0 ls2"> lastChild()：遍历到当前节点的最后一个子节点； </div><div class="t m0 x0 h5 y22f6 ff7e fs1 fc0 sc0 ls2"> nextSibling()：遍历到当前节点的下一个同辈节点； </div><div class="t m0 x0 h5 y22f7 ff7e fs1 fc0 sc0 ls2"> previousSibling()：遍历到当前节点的上一个同辈节点。 </div></div></div>
<div id="pf15d" class="pf w0 h0" data-page-no="15d"><div class="pc pc15d w0 h0"><div class="t m0 x2 h2 y1 ff78 fs0 fc0 sc0 ls7 ws0">12.3 遍历  331 </div><div class="t m0 x0 h3 y2 ff78 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff7a fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff7a fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff7a fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff7a fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff7a fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff7a fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff7a fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff7a fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff7a fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff7a fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff7a fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff7a fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff7a fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff7f fs2 fc0 sc0 ls8 wseb">创建TreeWalker对象要使用document.createTreeWalker()方法，这个方法接受的4个参数</div><div class="t m0 x0 h1e y4d ff7f fs2 fc0 sc0 ls2f1">与document.createNodeIterator()方法相同：作为遍历起点的根节点、要显示的节点类型、过滤</div><div class="t m0 x0 h4 y5 ff7f fs2 fc0 sc0 ls24 wsf5">器和一个表示是否扩展实体引用的布尔值。由于这两个创建方法很相似，所以很容易用TreeWalker</div><div class="t m0 x0 h5 yd9 ff7f fs2 fc0 sc0 ls8 wseb">来代替NodeIterator，如下面的例子所示。 </div><div class="t m0 x5 hb y5e9 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y22f8 ff83 fs6 fc0 sc0 ls21 wsb">var div = document.getElementById(&quot;div1&quot;); </div><div class="t m0 x0 hb y22f9 ff83 fs6 fc0 sc0 ls21 wsb">var filter = function(node){ </div><div class="t m0 x0 hb y22fa ff83 fs6 fc0 sc0 ls21 wsb">    return node.tagName.toLowerCase() == &quot;li&quot;?  </div><div class="t m0 x0 hb y22fb ff83 fs6 fc0 sc0 ls21 wsb">        NodeFilter.FILTER_ACCEPT :  </div><div class="t m0 x0 hb y22fc ff83 fs6 fc0 sc0 ls21 wsb">        NodeFilter.FILTER_SKIP; </div><div class="t m0 x0 hb y22fd ff83 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y22fe ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y22ff ff84 fs6 fc0 sc0 ls21 wsb">var walker= document.createTreeWalker(div, NodeFilter.SHOW_ELEMENT, </div><div class="t m0 x0 h15 y2300 ff84 fs6 fc0 sc0 ls21 wsb">                filter, false); </div><div class="t m0 x0 hb y2301 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2302 ff83 fs6 fc0 sc0 ls21 wsb">var node = iterator.nextNode(); </div><div class="t m0 x0 hb y2303 ff83 fs6 fc0 sc0 ls21 wsb">while (node !== null) { </div><div class="t m0 x0 h16 y2304 ff83 fs6 fc0 sc0 ls21 wsb">    alert(node.tagName);        //输出标签名 </div><div class="t m0 x0 hb y2305 ff83 fs6 fc0 sc0 ls21 wsb">    node = iterator.nextNode(); </div><div class="t m0 x0 hb y2306 ff83 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x2 hf y2307 ff85 fs2 fc0 sc0 ls1b wsb">TreeWalkerExample1.htm </div><div class="t m0 x0 h4 y2308 ff7f fs2 fc0 sc0 ls42 wsf0">在这里，filter可以返回的值有所不同。除了NodeFilter.FILTER_ACCEPT 和NodeFilter. </div><div class="t m0 x0 h42 y2309 ff83 fs1 fc0 sc0 ls43 ws31">FILTER_SKIP之外，还可以使用NodeFilter.FILTER_REJECT。在使用 NodeIterator对象时，</div><div class="t m0 x0 h4 y230a ff83 fs1 fc0 sc0 ls43 ws31">NodeFilter.FILTER_SKIP与NodeFilter.FILTER_REJECT的作用相同：跳过指定的节点。但在使</div><div class="t m0 x0 h1e ya4b ff7f fs2 fc0 sc0 ls2f3">用TreeWalker对象时，NodeFilter.FILTER_SKIP会跳过相应节点继续前进到子树中的下一个节点，</div><div class="t m0 x0 h1e y230b ff7f fs2 fc0 sc0 ls140">而NodeFilter.FILTER_REJECT则会跳过相应节点及该节点的整个子树。例如，将前面例子中的</div><div class="t m0 x0 h4 y230c ff83 fs1 fc0 sc0 ls43 ws31">NodeFilter.FILTER_SKIP修改成NodeFilter.FILTER_REJECT，结果就是不会访问任何节点。这是</div><div class="t m0 x0 h4 y19c8 ff7f fs2 fc0 sc0 ls42 wsf0">因为第一个返回的节点是&lt;div&gt;，它的标签名不是&quot;li&quot;，于是就会返回NodeFilter.FILTER_REJECT，</div><div class="t m0 x0 hc y230d ff7f fs2 fc0 sc0 ls42 wsf0">这意味着遍历会跳过整个子树。在这个例子中，&lt;div&gt;元素是遍历的根节点，于是结果就会停止遍历。 </div><div class="t m0 x0 hc y230e ff7f fs2 fc0 sc0 ls8 wseb">当然，TreeWalker真正强大的地方在于能够在DOM结构中沿任何方向移动。使用TreeWalker</div><div class="t m0 x0 h5 y1576 ff7f fs2 fc0 sc0 ls8 wseb">遍历DOM树，即使不定义过滤器，也可以取得所有&lt;li&gt;元素，如下面的代码所示。 </div><div class="t m0 x5 hb y230f ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2310 ff83 fs6 fc0 sc0 ls21 wsb">var div = document.getElementById(&quot;div1&quot;); </div><div class="t m0 x0 hb y2311 ff83 fs6 fc0 sc0 ls21 wsb">var walker = document.createTreeWalker(div, NodeFilter.SHOW_ELEMENT, null, false); </div><div class="t m0 x0 hb y2312 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2313 ff84 fs6 fc0 sc0 ls21 wsb">walker.firstChild();              //转到&lt;p&gt; </div><div class="t m0 x0 h16 y2314 ff84 fs6 fc0 sc0 ls21 wsb">walker.nextSibling();         //转到&lt;ul&gt; </div><div class="t m0 x0 h15 y2315 ff84 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2316 ff84 fs6 fc0 sc0 ls21 wsb">var node = walker.firstChild();        //转到第一个&lt;li&gt; </div><div class="t m0 x0 hb y2317 ff83 fs6 fc0 sc0 ls21 wsb">while (node !== null) { </div><div class="t m0 x0 hb y2318 ff83 fs6 fc0 sc0 ls21 wsb">    alert(node.tagName); </div><div class="t m0 x0 h15 y2319 ff84 fs6 fc0 sc0 ls21 wsb">    node = walker.nextSibling(); </div><div class="t m0 x0 hb y231a ff83 fs6 fc0 sc0 ls21 wsb">}   </div><div class="t m0 x2 hf y231b ff85 fs2 fc0 sc0 ls1b wsb">TreeWalkerExample2.htm </div><div class="t m0 x0 h4 y231c ff7f fs2 fc0 sc0 ls6 wsf7">因为我们知道&lt;li&gt;元素在文档结构中的位置，所以可以直接定位到那里，即使用firstChild()</div><div class="t m0 x0 h4 y231d ff7f fs2 fc0 sc0 ls8 wseb">转到&lt;p&gt;元素，使用nextSibling()转到&lt;ul&gt;元素，然后再使用firstChild()转到第一个&lt;li&gt;元素。</div><div class="t m0 x0 h84 y231e ff7f fs2 fc0 sc0 ls8 wseb">注意，此处TreeWalker只返回元素（由传入到createTreeWalker()的第二个参数决定）。因此，可</div><div class="t m0 x0 hc5 y231f ff7f fs2 fc0 sc0 ls8 wseb">以放心地使用nextSibling()访问每一个&lt;li&gt;元素，直至这个方法最后返回null。 </div></div></div>
<div id="pf15e" class="pf w0 h0" data-page-no="15e"><div class="pc pc15e w0 h0"><div class="t m0 x0 h2 y1 ff78 fs0 fc0 sc0 ls7 ws0">332  第12章 DOM2和DOM3 </div><div class="t m0 x0 h3 y2 ff78 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ff83 fs1 fc0 sc0 ls9 ws2">TreeWalker类型还有一个属性，名叫currentNode，表示任何遍历方法在上一次遍历中返回的</div><div class="t m0 x0 h5 y4d ff7f fs2 fc0 sc0 ls8 wseb">节点。通过设置这个属性也可以修改遍历继续进行的起点，如下面的例子所示。 </div><div class="t m0 x0 hb y2d8 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2d9 ff83 fs6 fc0 sc0 ls21 wsb">var node = walker.nextNode(); </div><div class="t m0 x0 hb y2da ff83 fs6 fc0 sc0 ls21 wsb">alert(node === walker.currentNode);     //true </div><div class="t m0 x0 h16 y2db ff83 fs6 fc0 sc0 ls21 wsb">walker.currentNode = document.body;     //修改起点 </div><div class="t m0 x0 hb y2320 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y22a9 ff7f fs2 fc0 sc0 ls63">与NodeIterator相比，TreeWalker类型在遍历DOM时拥有更大的灵活性。由于 IE中没有对</div><div class="t m0 x0 h5 y2321 ff7f fs2 fc0 sc0 ls8 wseb">应的类型和方法，所以使用遍历的跨浏览器解决方案非常少见。 </div><div class="t m0 x0 hd y147c ff7d fs7 fc0 sc0 ls245">12.4 范围 </div><div class="t m0 x0 h5 y2322 ff7f fs2 fc0 sc0 ls8 wseb">为了让开发人员更方便地控制页面，“DOM2级遍历和范围”模块定义了“范围”（range）接口。通</div><div class="t m0 x0 h4 y6ec ff7f fs2 fc0 sc0 ls6 wsf7">过范围可以选择文档中的一个区域，而不必考虑节点的界限（选择在后台完成，对用户是不可见的）。</div><div class="t m0 x0 h5 y6ed ff7f fs2 fc0 sc0 ls8 wseb">在常规的DOM操作不能更有效地修改文档时，使用范围往往可以达到目的。Firefox、Opera、Safari和</div><div class="t m0 x0 h5 y2323 ff78 fs2 fc0 sc0 ls50 ws41">Chrome都支持DOM范围。IE以专有方式实现了自己的范围特性。 </div><div class="t m0 x0 h20 y2324 ff7d fs3 fc0 sc0 ls248 ws214">12.4.1 DOM中的范围 </div><div class="t m0 x0 h5 y1196 ff78 fs2 fc0 sc0 ls24a ws215">DOM2级在Document类型中定义了createRange()方法。在兼容 DOM的浏览器中，这个方法</div><div class="t m0 x0 h5 y2325 ff7f fs2 fc0 sc0 ls8 wseb">属于document对象。使用hasFeature()或者直接检测该方法，都可以确定浏览器是否支持范围。 </div><div class="t m0 x0 hb y2326 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2327 ff83 fs6 fc0 sc0 ls21 wsb">var supportsRange = document.implementation.hasFeature(&quot;Range&quot;, &quot;2.0&quot;); </div><div class="t m0 x0 hb y2328 ff83 fs6 fc0 sc0 ls21 wsb">var alsoSupportsRange = (typeof document.createRange == &quot;function&quot;); </div><div class="t m0 x0 hb y2329 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y232a ff7f fs2 fc0 sc0 ls8 wseb">如果浏览器支持范围，那么就可以使用createRange()来创建DOM范围，如下所示： </div><div class="t m0 x0 hb y232b ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y232c ff83 fs6 fc0 sc0 ls21 wsb">var range = document.createRange(); </div><div class="t m0 x0 hb y232d ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y232e ff7f fs2 fc0 sc0 ls8 wseb">与节点类似，新创建的范围也直接与创建它的文档关联在一起，不能用于其他文档。创建了范围之</div><div class="t m0 x0 h4 y232f ff7f fs2 fc0 sc0 ls8 wseb">后，接下来就可以使用它在后台选择文档中的特定部分。而创建范围并设置了其位置之后，还可以针对</div><div class="t m0 x0 h5 y2330 ff7f fs2 fc0 sc0 ls8 wseb">范围的内容执行很多种操作，从而实现对底层DOM树的更精细的控制。 </div><div class="t m0 x0 h1c y2331 ff7f fs2 fc0 sc0 ls8 wseb">每个范围由一个Range类型的实例表示，这个实例拥有很多属性和方法。下列属性提供了当前范</div><div class="t m0 x0 h5 y2332 ff7f fs2 fc0 sc0 ls8 wseb">围在文档中的位置信息。 </div><div class="t m0 x0 h5 y2333 ff7e fs1 fc0 sc0 ls2"> startContainer：包含范围起点的节点（即选区中第一个节点的父节点）。 </div><div class="t m0 x0 h4 y1928 ff7e fs1 fc0 sc0 ls2"> startOffset：范围在startContainer中起点的偏移量。如果startContainer是文本节</div><div class="t m0 x0 h5 y2334 ff7f fs2 fc0 sc0 ls8 wseb">点、注释节点或CDATA节点，那么startOffset就是范围起点之前跳过的字符数量。否则，</div><div class="t m0 x0 h5 y1a9a ff83 fs1 fc0 sc0 ls9 ws2">startOffset就是范围中第一个子节点的索引。 </div><div class="t m0 x0 h5 y2335 ff7e fs1 fc0 sc0 ls2"> endContainer：包含范围终点的节点（即选区中最后一个节点的父节点）。 </div><div class="t m0 x0 h5 y192c ff7e fs1 fc0 sc0 ls2"> endOffset：范围在endContainer中终点的偏移量（与startOffset遵循相同的取值规则）。 </div><div class="t m0 x0 h4 y2336 ff7e fs1 fc0 sc0 ls2"> commonAncestorContainer：startContainer和endContainer共同的祖先节点在文档树</div><div class="t m0 x0 h5 y2337 ff7f fs2 fc0 sc0 ls8 wseb">中位置最深的那个。 </div><div class="t m0 x0 h5 y2338 ff7f fs2 fc0 sc0 ls8 wseb">在把范围放到文档中特定的位置时，这些属性都会被赋值。 </div><div class="t m0 x0 h3c y2339 ff7d fs2 fc0 sc0 ls2e wsb">1. 用DOM范围实现简单选择 </div><div class="t m0 x0 ha4 y233a ff7f fs2 fc0 sc0 ls127 ws226">要使用范围来选择文档中的一部分，最简的方式就是使用selectNode()或selectNodeContents()。</div><div class="t m0 x0 h5 y1930 ff7f fs2 fc0 sc0 ls4c wsfa">这两个方法都接受一个参数，即一个DOM节点，然后使用该节点中的信息来填充范围。其中，</div></div></div>
<div id="pf15f" class="pf w0 h0" data-page-no="15f"><div class="pc pc15f w0 h0"><div class="t m0 x2 h2 y1 ff78 fs0 fc0 sc0 ls7 ws0">12.4 范围  333 </div><div class="t m0 x0 h3 y2 ff78 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff7a fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff7a fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff7a fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff7a fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff7a fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff7a fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff7a fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff7a fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff7a fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff7a fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff7a fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff7a fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff7a fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h4 y3 ff83 fs1 fc0 sc0 ls9 ws2">selectNode()方法选择整个节点，包括其子节点；而selectNodeContents()方法则只选择节点的</div><div class="t m0 x0 h5 y4d ff7f fs2 fc0 sc0 ls8 wseb">子节点。以下面的HTML代码为例。 </div><div class="t m0 x5 hb y2d8 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y639 ff83 fs6 fc0 sc0 ls21 wsb">&lt;!DOCTYPE html&gt; </div><div class="t m0 x0 hb y63a ff83 fs6 fc0 sc0 ls21 wsb">&lt;html&gt; </div><div class="t m0 x0 hb y63b ff83 fs6 fc0 sc0 ls21 wsb">    &lt;body&gt;     </div><div class="t m0 x0 hb y63c ff83 fs6 fc0 sc0 ls21 wsb">        &lt;p id=&quot;p1&quot;&gt;&lt;b&gt;Hello&lt;/b&gt; world!&lt;/p&gt; </div><div class="t m0 x0 hb y63d ff83 fs6 fc0 sc0 ls21 wsb">    &lt;/body&gt; </div><div class="t m0 x0 hb y63e ff83 fs6 fc0 sc0 ls21 wsb">&lt;/html&gt; </div><div class="t m0 x5 hb y63f ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y233b ff7f fs2 fc0 sc0 ls8 wseb">我们可以使用下列代码来创建范围： </div><div class="t m0 x5 hb y233c ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y233d ff83 fs6 fc0 sc0 ls21 wsb">var range1 = document.createRange(); </div><div class="t m0 x0 hb y233e ff83 fs6 fc0 sc0 ls21 wsb">    range2 = document.createRange(); </div><div class="t m0 x0 hb y233f ff83 fs6 fc0 sc0 ls21 wsb">    p1 = document.getElementById(&quot;p1&quot;); </div><div class="t m0 x0 hb y2340 ff83 fs6 fc0 sc0 ls21 wsb">range1.selectNode(p1); </div><div class="t m0 x0 hb y2341 ff83 fs6 fc0 sc0 ls21 wsb">range2.selectNodeContents(p1); </div><div class="t m0 x5 hb y2342 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y2343 ff85 fs2 fc0 sc0 ls7a wsb">DOMRangeExample.htm </div><div class="t m0 x0 h4 y2344 ff7f fs2 fc0 sc0 ls8 wseb">这里创建的两个范围包含文档中不同的部分：rang1包含&lt;p/&gt;元素及其所有子元素，而rang2包</div><div class="t m0 x0 hc y2345 ff7f fs2 fc0 sc0 ls8 wseb">含&lt;b/&gt;元素、文本节点&quot;Hello&quot;和文本节点&quot;world!&quot;（如图12-6所示）。 </div><div class="t m0 x2 h5 y219d ff78 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 h3 y1e2e ff7f fs1 fc0 sc0 ls8 wsb">图 12-6 </div><div class="t m0 x0 h4 y1f03 ff7f fs2 fc0 sc0 ls8 wseb">在调用selectNode()时，startContainer、endContainer和commonAncestorContainer</div><div class="t m0 x0 h4 y2346 ff7f fs2 fc0 sc0 ls8 wseb">都等于传入节点的父节点，也就是这个例子中的document.body。而startOffset属性等于给定节</div><div class="t m0 x0 hc y2347 ff7f fs2 fc0 sc0 ls8 wseb">点在其父节点的childNodes集合中的索引（在这个例子中是1——因为兼容DOM 的浏览器将空格算</div><div class="t m0 x0 h5 y2348 ff7f fs2 fc0 sc0 ls8 wseb">作一个文本节点），endOffset等于startOffset加1（因为只选择了一个节点）。 </div><div class="t m0 x0 h1e y2349 ff7f fs2 fc0 sc0 ls1f ws108">在调用selectNodeContents()时，startContainer、endContainer和commonAncestorConta- </div><div class="t m0 x0 h21 y234a ff83 fs1 fc0 sc0 ls20 ws16">iner等于传入的节点，即这个例子中的&lt;p&gt;元素。而startOffset属性始终等于0，因为范围从给定节</div><div class="t m0 x0 h1e y234b ff7f fs2 fc0 sc0 ls1f ws108">点的第一个子节点开始。最后，endOffset等于子节点的数量（node.childNodes.length），在这个例</div><div class="t m0 x0 h5 y234c ff7f fs2 fc0 sc0 ls1f ws108">子中是2。 </div><div class="t m0 x0 h5 y234d ff7f fs2 fc0 sc0 ls8 wseb">此外，为了更精细地控制将哪些节点包含在范围中，还可以使用下列方法。 </div><div class="t m0 x0 h4 y234e ff7e fs1 fc0 sc0 ls2"> setStartBefore(refNode)：将范围的起点设置在refNode之前，因此refNode也就是范围</div><div class="t m0 x5 h1e y234f ff7f fs2 fc0 sc0 ls8 wseb">选区中的第一个子节点。同时会将startContainer属性设置为 refNode.parentNode，将</div><div class="t m0 x5 h5 y1266 ff83 fs1 fc0 sc0 ls9 ws2">startOffset属性设置为refNode在其父节点的childNodes 集合中的索引。 </div><div class="t m0 x0 h4 y2350 ff7e fs1 fc0 sc0 ls2"> setStartAfter(refNode)：将范围的起点设置在refNode之后，因此refNode 也就不在范</div><div class="t m0 x5 h1e y2351 ff7f fs2 fc0 sc0 ls8 wseb">围之内了，其下一个同辈节点才是范围选区中的第一个子节点。同时会将startContainer属</div><div class="t m0 x5 h1e y2352 ff7f fs2 fc0 sc0 ls6f ws113">性设置为refNode.parentNode，将startOffset 属性设置为refNode在其父节点的</div><div class="t m0 x5 h5 y2353 ff83 fs1 fc0 sc0 ls9 ws2">childNodes集合中的索引加1。 </div><div class="t m0 x0 h4 y2354 ff7e fs1 fc0 sc0 ls2"> setEndBefore(refNode)：将范围的终点设置在refNode之前，因此refNode也就不在范围</div><div class="t m0 x5 h1e y2355 ff7f fs2 fc0 sc0 ls8 wseb">之内了，其上一个同辈节点才是范围选区中的最后一个子节点。同时会将endContainer属性</div></div></div>
<div id="pf160" class="pf w0 h0" data-page-no="160"><div class="pc pc160 w0 h0"><div class="t m0 x0 h2 y1 ff78 fs0 fc0 sc0 ls7 ws0">334  第12章 DOM2和DOM3 </div><div class="t m0 x0 h3 y2 ff78 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ff7f fs2 fc0 sc0 ls8 wseb">设置为refNode.parentNode，将endOffset属性设置为refNode在其父节点的childNodes</div><div class="t m0 x0 h5 y4 ff7f fs2 fc0 sc0 ls8 wseb">集合中的索引。 </div><div class="t m0 x0 h4 y4e ff7e fs1 fc0 sc0 ls2"> setEndAfter(refNode)：将范围的终点设置在refNode之后，因此refNode也就是范围选区</div><div class="t m0 x0 h4 yd9 ff7f fs2 fc0 sc0 lsed ws221">中的最后一个子节点。同时会将endContainer属性设置为 refNode.parentNode，将</div><div class="t m0 x0 h5 y219 ff83 fs1 fc0 sc0 ls9 ws2">endOffset属性设置为refNode在其父节点的childNodes 集合中的索引加1。 </div><div class="t m0 x0 h4 y21a ff7f fs2 fc0 sc0 ls8 wseb">在调用这些方法时，所有属性都会自动为你设置好。不过，要想创建复杂的范围选区，也可以直接</div><div class="t m0 x0 h5 y5c8 ff7f fs2 fc0 sc0 ls8 wseb">指定这些属性的值。 </div><div class="t m0 x0 h3c y2357 ff7d fs2 fc0 sc0 ls2e wsb">2. 用DOM范围实现复杂选择 </div><div class="t m0 x0 ha4 y2358 ff7f fs2 fc0 sc0 ls8 wseb">要创建复杂的范围就得使用setStart()和setEnd()方法。这两个方法都接受两个参数：一个参</div><div class="t m0 x0 h4 y2043 ff7f fs2 fc0 sc0 ls44 wsef">照节点和一个偏移量值。对setStart()来说，参照节点会变成startContainer，而偏移量值会变成</div><div class="t m0 x0 h5 y20ee ff83 fs1 fc0 sc0 ls20 ws16">startOffset。对于setEnd()来说，参照节点会变成endContainer，而偏移量值会变成endOffset。 </div><div class="t m0 x0 hc ycbe ff7f fs2 fc0 sc0 ls8 wseb">可以使用这两个方法来模仿selectNode()和selectNodeContents()。来看下面的例子： </div><div class="t m0 x0 hb y2359 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y235a ff83 fs6 fc0 sc0 ls21 wsb">var range1 = document.createRange(); </div><div class="t m0 x0 hb y235b ff84 fs6 fc0 sc0 ls21 wsb">    range2 = document.createRange(); </div><div class="t m0 x0 hb y235c ff84 fs6 fc0 sc0 ls21 wsb">    p1 = document.getElementById(&quot;p1&quot;); </div><div class="t m0 x0 h15 y235d ff84 fs6 fc0 sc0 ls21 wsb">    p1Index = -1; </div><div class="t m0 x0 h15 y235e ff84 fs6 fc0 sc0 ls21 wsb">    i, len; </div><div class="t m0 x0 h15 y235f ff84 fs6 fc0 sc0 ls21 wsb">for (i=0, len=p1.parentNode.childNodes.length; i &lt; len; i++) { </div><div class="t m0 x0 h15 y2360 ff84 fs6 fc0 sc0 ls21 wsb">    if (p1.parentNode.childNodes[i] == p1) { </div><div class="t m0 x0 h15 y2361 ff84 fs6 fc0 sc0 ls21 wsb">        p1Index = i; </div><div class="t m0 x0 h15 y2362 ff84 fs6 fc0 sc0 ls21 wsb">        break; </div><div class="t m0 x0 h15 y2363 ff84 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 h15 y2364 ff84 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 h15 y2365 ff84 fs6 fc0 sc0 ls21 wsb">         </div><div class="t m0 x0 h15 y2366 ff84 fs6 fc0 sc0 ls21 wsb">range1.setStart(p1.parentNode, p1Index); </div><div class="t m0 x0 h15 y2367 ff84 fs6 fc0 sc0 ls21 wsb">range1.setEnd(p1.parentNode, p1Index + 1); </div><div class="t m0 x0 h15 y2368 ff84 fs6 fc0 sc0 ls21 wsb">range2.setStart(p1, 0); </div><div class="t m0 x0 hb y2369 ff84 fs6 fc0 sc0 ls21 wsb">range2.setEnd(p1, p1.childNodes.length); </div><div class="t m0 x0 hb y236a ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y236b ff85 fs2 fc0 sc0 ls7a wsb">DOMRangeExample2.htm </div><div class="t m0 x0 h4 y835 ff7f fs2 fc0 sc0 ls8 wseb">显然，要选择这个节点（使用range1），就必须确定当前节点（p1）在其父节点的childNodes</div><div class="t m0 x0 h4 y236c ff7f fs2 fc0 sc0 ls6 wsf7">集合中的索引。而要选择这个节点的内容（使用range2），也不必计算什么；只要通过setStart()</div><div class="t m0 x0 h4 y236d ff7f fs2 fc0 sc0 ls15f">和setEnd()设置默认值即可。模仿selectNode()和selectNodeContents()并不是setStart()</div><div class="t m0 x0 h5 y236e ff7f fs2 fc0 sc0 ls2c">和setEnd()的主要用途，它们更胜一筹的地方在于能够选择节点的一部分。 </div><div class="t m0 x0 h5 y236f ff7f fs2 fc0 sc0 ls8 wseb">假设你只想选择前面HTML示例代码中从&quot;Hello&quot;的&quot;llo&quot;到&quot;world!&quot;的&quot;o&quot;——很容易做到。</div><div class="t m0 x0 h5 y15ab ff7f fs2 fc0 sc0 ls8 wseb">第一步是取得所有节点的引用，如下面的例子所示： </div><div class="t m0 x0 hb y2ab ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2370 ff83 fs6 fc0 sc0 ls21 wsb">var p1 = document.getElementById(&quot;p1&quot;); </div><div class="t m0 x0 hb y2371 ff83 fs6 fc0 sc0 ls21 wsb">    helloNode = p1.firstChild.firstChild; </div><div class="t m0 x0 hb y2372 ff83 fs6 fc0 sc0 ls21 wsb">    worldNode = p1.lastChild;  </div><div class="t m0 x0 hb y2373 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1d11 ff85 fs2 fc0 sc0 ls7a wsb">DOMRangeExample3.htm </div><div class="t m0 x0 h4 y2374 ff7f fs2 fc0 sc0 ls5 wsec">实际上，&quot;Hello&quot;文本节点是&lt;p&gt;元素的孙子节点，因为它本身是&lt;b&gt;元素的一个子节点。因此，</div><div class="t m0 x0 h4 y2375 ff83 fs1 fc0 sc0 ls9 ws2">p1.firstChild取得的是&lt;b&gt;，而p1.firstChild.firstChild取得的才是这个文本节点。&quot;world!&quot;</div><div class="t m0 x0 h4 y2376 ff7f fs2 fc0 sc0 ls8 wseb">文本节点是&lt;p&gt;元素的第二个子节点（也是最后一个子节点），因此可以使用p1.lastChild取得该节</div></div></div>
<div id="pf161" class="pf w0 h0" data-page-no="161"><div class="pc pc161 w0 h0"><div class="t m0 x2 h2 y1 ff78 fs0 fc0 sc0 ls7 ws0">12.4 范围  335 </div><div class="t m0 x0 h3 y2 ff78 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff7a fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff7a fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff7a fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff7a fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff7a fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff7a fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff7a fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff7a fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff7a fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff7a fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff7a fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff7a fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff7a fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff7f fs2 fc0 sc0 ls8 wseb">点。然后，必须在创建范围时指定相应的起点和终点，如下面的例子所示。 </div><div class="t m0 x5 hb yfb2 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2377 ff83 fs6 fc0 sc0 ls21 wsb">var range = document.createRange(); </div><div class="t m0 x0 hb y2378 ff83 fs6 fc0 sc0 ls21 wsb">range.setStart(helloNode, 2); </div><div class="t m0 x0 hb y2379 ff83 fs6 fc0 sc0 ls21 wsb">range.setEnd(worldNode, 3); </div><div class="t m0 x5 hb y237a ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y237b ff85 fs2 fc0 sc0 ls7a wsb">DOMRangeExample3.htm </div><div class="t m0 x0 h4 y237c ff7f fs2 fc0 sc0 ls5 wsec">因为这个范围的选区应该从&quot;Hello&quot;中&quot;e&quot;的后面开始，所以在setStart()中传入helloNode</div><div class="t m0 x0 h5 y237d ff7f fs2 fc0 sc0 ls8 wseb">的同时，传入了偏移量2（即&quot;e&quot;的下一个位置；&quot;H&quot;的位置是0）。设置选区的终点时，在setEnd()</div><div class="t m0 x0 h5 y237e ff7f fs2 fc0 sc0 ls8 wseb">中传入worldNode的同时传入了偏移量3，表示选区之外的第一个字符的位置，这个字符是&quot;r&quot;，它的</div><div class="t m0 x0 h5 y237f ff7f fs2 fc0 sc0 ls8 wseb">位置是3（位置0上还有一个空格）。如图12-7所示。 </div><div class="t m0 x2 h5 y1403 ff78 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 h3 y114b ff7f fs1 fc0 sc0 ls8 wsb">图 12-7 </div><div class="t m0 x0 h4 y2380 ff7f fs2 fc0 sc0 ls8 wseb">由于helloNode和worldNode都是文本节点，因此它们分别变成了新建范围的startContainer</div><div class="t m0 x0 h4 y2381 ff7f fs2 fc0 sc0 ls2c">和endContainer。此时startOffset和endOffset分别用以确定两个节点所包含的文本中的位置，</div><div class="t m0 x0 h4 y2382 ff7f fs2 fc0 sc0 ls19 wsfb">而不是用以确定子节点的位置（就像传入的参数为元素节点时那样）。此时的commonAncestor- </div><div class="t m0 x0 h21 y2383 ff83 fs1 fc0 sc0 ls9 ws2">Container是&lt;p&gt;元素，也就是同时包含这两个节点的第一个祖先元素。 </div><div class="t m0 x0 h5 y2384 ff7f fs2 fc0 sc0 ls1f ws108">当然，仅仅是选择了文档中的某一部分用处并不大。但重要的是，选择之后才可以对选区进行操作。 </div><div class="t m0 x0 h3c y2385 ff7d fs2 fc0 sc0 ls2e wsb">3. 操作DOM范围中的内容 </div><div class="t m0 x0 h5 y2386 ff7f fs2 fc0 sc0 ls8 wseb">在创建范围时 ，内部会为这个范围创建一个文档片段，范围所属的全部节点都被添加到了这个文档</div><div class="t m0 x0 h4 y2387 ff7f fs2 fc0 sc0 ls8 wseb">片段中。为了创建这个文档片段，范围内容的格式必须正确有效。在前面的例子中，我们创建的选区分</div><div class="t m0 x0 h5 y2388 ff7f fs2 fc0 sc0 ls8 wseb">别开始和结束于两个文本节点的内部，因此不能算是格式良好的DOM结构，也就无法通过DOM来表</div><div class="t m0 x0 h5 y2389 ff7f fs2 fc0 sc0 ls8 wseb">示。但是，范围知道自身缺少哪些开标签和闭标签，它能够重新构建有效的DOM结构以便我们对其进</div><div class="t m0 x0 h5 y238a ff7f fs2 fc0 sc0 ls8">行操作。 </div><div class="t m0 x0 h7d y238b ff7f fs2 fc0 sc0 ls8 wseb">对于前面的例子而言，范围经过计算知道选区中缺少一个开始的&lt;b&gt;标签，因此就会在后台动态加</div><div class="t m0 x0 h5 y238c ff7f fs2 fc0 sc0 ls8 wseb">入一个该标签，同时还会在前面加入一个表示结束的&lt;/b&gt;标签以结束&quot;He&quot;。于是，修改后的DOM就</div><div class="t m0 x0 h5 y238d ff7f fs2 fc0 sc0 ls8 wseb">变成了如下所示。 </div><div class="t m0 x5 hb y238e ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y238f ff83 fs6 fc0 sc0 ls21 wsb">&lt;p&gt;&lt;b&gt;He&lt;/b&gt;&lt;b&gt;llo&lt;/b&gt; world!&lt;/p&gt; </div><div class="t m0 x5 hb y2390 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y21aa ff7f fs2 fc0 sc0 ls8 wseb">另外，文本节点&quot;world!&quot;也被拆分为两个文本节点，一个包含&quot;wo&quot;，另一个包含&quot;rld!&quot;。最终的</div><div class="t m0 x0 h5 y2391 ff78 fs2 fc0 sc0 ls81 ws76">DOM树如图12-8所示，右侧是表示范围的文档片段的内容。 </div><div class="t m0 x0 h4 y2392 ff7f fs2 fc0 sc0 ls8 wseb">像这样创建了范围之后，就可以使用各种方法对范围的内容进行操作了（注意，表示范围的内部文</div><div class="t m0 x0 h5 y2393 ff7f fs2 fc0 sc0 ls8 wseb">档片段中的所有节点，都只是指向文档中相应节点的指针）。 </div><div class="t m0 x0 h4b y2394 ff7f fs2 fc0 sc0 ls6 wsf7">第一个方法，也是最容易理解的方法，就是deleteContents()。这个方法能够从文档中删除范</div><div class="t m0 x0 h5 yff ff7f fs2 fc0 sc0 ls8 wseb">围所包含的内容。例如： </div><div class="t m0 x5 hb y1100 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2395 ff83 fs6 fc0 sc0 ls21 wsb">var p1 = document.getElementById(&quot;p1&quot;); </div><div class="t m0 x0 hb y2396 ff83 fs6 fc0 sc0 ls21 wsb">    helloNode = p1.firstChild.firstChild; </div><div class="t m0 x0 hb y2397 ff83 fs6 fc0 sc0 ls21 wsb">    worldNode = p1.lastChild;     </div><div class="t m0 x0 hb y2398 ff83 fs6 fc0 sc0 ls21 wsb">    range = document.createRange(); </div><div class="t m0 x0 hb y2399 ff83 fs6 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf162" class="pf w0 h0" data-page-no="162"><div class="pc pc162 w0 h0"><div class="t m0 x0 h2 y1 ff78 fs0 fc0 sc0 ls7 ws0">336  第12章 DOM2和DOM3 </div><div class="t m0 x0 h3 y2 ff78 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 ff83 fs6 fc0 sc0 ls21 wsb">range.setStart(helloNode, 2); </div><div class="t m0 x0 hb y7a ff83 fs6 fc0 sc0 ls21 wsb">range.setEnd(worldNode, 3); </div><div class="t m0 x0 hb y7b ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y7c ff84 fs6 fc0 sc0 ls21 wsb">range.deleteContents(); </div><div class="t m0 x0 hb y1991 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y239b ff85 fs2 fc0 sc0 ls7a wsb">DOMRangeExample4.htm </div><div class="t m0 x2 h5 y239c ff78 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x7 h3 y13c5 ff7f fs1 fc0 sc0 ls8 wsb">图 12-8 </div><div class="t m0 x0 h5 y239d ff7f fs2 fc0 sc0 ls8 wseb">执行以上代码后，页面中会显示如下HTML代码： </div><div class="t m0 x0 hb y1a5d ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y239e ff83 fs6 fc0 sc0 ls21 wsb">&lt;p&gt;&lt;b&gt;He&lt;/b&gt;rld!&lt;/p&gt;     </div><div class="t m0 x0 hb y239f ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y23a0 ff7f fs2 fc0 sc0 ls8 wseb">由于范围选区在修改底层DOM结构时能够保证格式良好，因此即使内容被删除了，最终的DOM</div><div class="t m0 x0 h5 y23a1 ff7f fs2 fc0 sc0 ls8 wseb">结构依旧是格式良好的。 </div><div class="t m0 x0 h1e y23a2 ff7f fs2 fc0 sc0 ls2f8">与deleteContents()方法相似，extractContents()也会从文档中移除范围选区。但这两个方</div><div class="t m0 x0 h1e y1c46 ff7f fs2 fc0 sc0 ls6 wsf7">法的区别在于，extractContents()会返回范围的文档片段。利用这个返回的值，可以将范围的内容</div><div class="t m0 x0 h5 y1c47 ff7f fs2 fc0 sc0 ls8 wseb">插入到文档中的其他地方。如下面的例子所示： </div><div class="t m0 x0 hb y1078 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y23a3 ff83 fs6 fc0 sc0 ls21 wsb">var p1 = document.getElementById(&quot;p1&quot;); </div><div class="t m0 x0 hb y23a4 ff83 fs6 fc0 sc0 ls21 wsb">    helloNode = p1.firstChild.firstChild; </div><div class="t m0 x0 hb y23a5 ff83 fs6 fc0 sc0 ls21 wsb">    worldNode = p1.lastChild; </div><div class="t m0 x0 hb y23a6 ff83 fs6 fc0 sc0 ls21 wsb">    range = document.createRange(); </div><div class="t m0 x0 hb y23a7 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y23a8 ff83 fs6 fc0 sc0 ls21 wsb">range.setStart(helloNode, 2); </div><div class="t m0 x0 hb y23a9 ff83 fs6 fc0 sc0 ls21 wsb">range.setEnd(worldNode, 3); </div><div class="t m0 x0 hb y23aa ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y23ab ff84 fs6 fc0 sc0 ls21 wsb">var fragment = range.extractContents(); </div><div class="t m0 x0 h15 y23ac ff84 fs6 fc0 sc0 ls21 wsb">p1.parentNode.appendChild(fragment); </div><div class="t m0 x2 hf y23ad ff85 fs2 fc0 sc0 ls7a wsb">DOMRangeExample5.htm </div></div></div>
<div id="pf163" class="pf w0 h0" data-page-no="163"><div class="pc pc163 w0 h0"><div class="t m0 x2 h2 y1 ff78 fs0 fc0 sc0 ls7 ws0">12.4 范围  337 </div><div class="t m0 x0 h3 y2 ff78 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff7a fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff7a fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff7a fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff7a fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff7a fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff7a fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff7a fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff7a fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff7a fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff7a fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff7a fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff7a fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff7a fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h4 y3 ff7f fs2 fc0 sc0 ls8 wseb">在这个例子中，我们将提取出来的文档片段添加到了文档&lt;body&gt;元素的末尾。（记住，在将文档片</div><div class="t m0 x0 h1e y4d ff7f fs2 fc0 sc0 ls8 wseb">段传入appendChild()方法中时，添加到文档中的只是片段的子节点，而非片段本身。）结果得到如下</div><div class="t m0 x0 h5 y5 ff78 fs2 fc0 sc0 lsfa wsc9">HTML代码： </div><div class="t m0 x5 hb y6bd ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y6be ff83 fs6 fc0 sc0 ls21 wsb">&lt;p&gt;&lt;b&gt;He&lt;/b&gt;rld!&lt;/p&gt; </div><div class="t m0 x0 hb y6bf ff83 fs6 fc0 sc0 ls21 wsb">&lt;b&gt;llo&lt;/b&gt; wo </div><div class="t m0 x5 hb y1aeb ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y7b1 ff7f fs2 fc0 sc0 ls8 wseb">还一种做法，即使用cloneContents()创建范围对象的一个副本，然后在文档的其他地方插入该</div><div class="t m0 x0 h5 y2063 ff7f fs2 fc0 sc0 ls8 wseb">副本。如下面的例子所示： </div><div class="t m0 x0 h5 y23ae ff78 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y23af ff83 fs6 fc0 sc0 ls21 wsb">var p1 = document.getElementById(&quot;p1&quot;), </div><div class="t m0 x0 hb y23b0 ff84 fs6 fc0 sc0 ls21 wsb">    helloNode = p1.firstChild.firstChild, </div><div class="t m0 x0 hb y23b1 ff84 fs6 fc0 sc0 ls21 wsb">    worldNode = p1.lastChild, </div><div class="t m0 x0 hb y23b2 ff84 fs6 fc0 sc0 ls21 wsb">    range = document.createRange(); </div><div class="t m0 x0 hb y23b3 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y23b4 ff83 fs6 fc0 sc0 ls21 wsb">range.setStart(helloNode, 2); </div><div class="t m0 x0 hb y23b5 ff83 fs6 fc0 sc0 ls21 wsb">range.setEnd(worldNode, 3); </div><div class="t m0 x0 h15 y23b6 ff84 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y23b7 ff84 fs6 fc0 sc0 ls21 wsb">var fragment = range.cloneContents(); </div><div class="t m0 x0 h15 y23b8 ff84 fs6 fc0 sc0 ls21 wsb">p1.parentNode.appendChild(fragment); </div><div class="t m0 x0 h15 y23b9 ff84 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y23ba ff85 fs2 fc0 sc0 ls7a wsb">DOMRangeExample6.htm </div><div class="t m0 x0 h4 y23bb ff7f fs2 fc0 sc0 ls24 wsf5">这个方法与extractContents()非常类似，因为它们都返回文档片段。它们的主要区别在于，</div><div class="t m0 x0 h4 y1d06 ff83 fs1 fc0 sc0 ls9 ws2">cloneContents()返回的文档片段包含的是范围中节点的副本，而不是实际的节点。执行上面的操作</div><div class="t m0 x0 h5 y23bc ff7f fs2 fc0 sc0 ls8 wseb">后，页面中的HTML代码应该如下所示： </div><div class="t m0 x0 h28 y1e2d ff83 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ybc9 ff83 fs6 fc0 sc0 ls21 wsb">&lt;p&gt;&lt;b&gt;Hello&lt;/b&gt; world!&lt;/p&gt; </div><div class="t m0 x0 hb y23bd ff83 fs6 fc0 sc0 ls21 wsb">&lt;b&gt;llo&lt;/b&gt; wo </div><div class="t m0 x0 hb y23be ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y23bf ff7f fs2 fc0 sc0 ls8 wseb">有一点请读者注意，那就是在调用上面介绍的方法之前，拆分的节点并不会产生格式良好的文档片</div><div class="t m0 x0 h5 y23c0 ff7f fs2 fc0 sc0 ls8 wseb">段。换句话说，原始的HTML在DOM被修改之前会始终保持不变。 </div><div class="t m0 x0 h3c y23c1 ff7d fs2 fc0 sc0 ls2e wsb">4. 插入DOM范围中的内容 </div><div class="t m0 x0 h4 y23c2 ff7f fs2 fc0 sc0 ls8 wseb">利用范围，可以删除或复制内容，还可以像前面介绍的那样操作范围中的内容。使用insertNode()</div><div class="t m0 x0 h5 y23c3 ff7f fs2 fc0 sc0 ls8 wseb">方法可以向范围选区的开始处插入一个节点。假设我们想在前面例子中的HTML前面插入以下HTML</div><div class="t m0 x0 h5 y23c4 ff7f fs2 fc0 sc0 ls8">代码：  </div><div class="t m0 x0 hb y23c5 ff83 fs6 fc0 sc0 ls21 wsb">&lt;span style=&quot;color: red&quot;&gt;Inserted text&lt;/span&gt; </div><div class="t m0 x5 hb y23c6 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y23c7 ff7f fs2 fc0 sc0 ls8 wseb">那么，就可以使用下列代码： </div><div class="t m0 x5 hb y23c8 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y23c9 ff83 fs6 fc0 sc0 ls21 wsb">var p1 = document.getElementById(&quot;p1&quot;);  </div><div class="t m0 x0 hb y23ca ff83 fs6 fc0 sc0 ls21 wsb">    helloNode = p1.firstChild.firstChild; </div><div class="t m0 x0 hb y23cb ff83 fs6 fc0 sc0 ls21 wsb">    worldNode = p1.lastChild; </div><div class="t m0 x0 hb y23cc ff83 fs6 fc0 sc0 ls21 wsb">    range = document.createRange(); </div><div class="t m0 x0 hb y23cd ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y23ce ff83 fs6 fc0 sc0 ls21 wsb">range.setStart(helloNode, 2); </div><div class="t m0 x0 hb y23cf ff83 fs6 fc0 sc0 ls21 wsb">range.setEnd(worldNode, 3); </div><div class="t m0 x5 hb y23d0 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y23d1 ff84 fs6 fc0 sc0 ls21 wsb">var span = document.createElement(&quot;span&quot;); </div><div class="t m0 x0 h15 y23d2 ff84 fs6 fc0 sc0 ls21 wsb">span.style.color = &quot;red&quot;; </div><div class="t m0 x0 h15 y23d3 ff84 fs6 fc0 sc0 ls21 wsb">span.appendChild(document.createTextNode(&quot;Inserted text&quot;)); </div><div class="t m0 x0 h15 y23d4 ff84 fs6 fc0 sc0 ls21 wsb">range.insertNode(span); </div><div class="t m0 x5 hb y23d5 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1310 ff85 fs2 fc0 sc0 ls7a wsb">DOMRangeExample7.htm </div></div></div>
<div id="pf164" class="pf w0 h0" data-page-no="164"><div class="pc pc164 w0 h0"><div class="t m0 x0 h2 y1 ff78 fs0 fc0 sc0 ls7 ws0">338  第12章 DOM2和DOM3 </div><div class="t m0 x0 h3 y2 ff78 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff7f fs2 fc0 sc0 ls8 wseb">运行以上JavaScript代码，就会得到如下HTML代码： </div><div class="t m0 x0 hb yfb2 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yfb3 ff83 fs6 fc0 sc0 ls21 wsb">&lt;p id=&quot;p1&quot;&gt;&lt;b&gt;He&lt;span style=&quot;color: red&quot;&gt;Inserted text&lt;/span&gt;llo&lt;/b&gt; world&lt;/p&gt;  </div><div class="t m0 x0 hb y1510 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1511 ff7f fs2 fc0 sc0 ls8 wseb">注意，&lt;span&gt;正好被插入到了&quot;Hello&quot;中的&quot;llo&quot;前面，而该位置就是范围选区的开始位置。还要</div><div class="t m0 x0 h5 y1512 ff7f fs2 fc0 sc0 ls8 wseb">注意的是，由于这里没有使用上一节介绍的方法，结果原始的HTML并没有添加或删除&lt;b&gt;元素。使用</div><div class="t m0 x0 h5 y15b3 ff7f fs2 fc0 sc0 ls8 wseb">这种技术可以插入一些帮助提示信息，例如在打开新窗口的链接旁边插入一幅图像。 </div><div class="t m0 x0 h4 y15b4 ff7f fs2 fc0 sc0 ls30 wsf6">除了向范围内部插入内容之外，还可以环绕范围插入内容，此时就要使用surroundContents()</div><div class="t m0 x0 h4 yd44 ff7f fs2 fc0 sc0 ls4 ws10d">方法。这个方法接受一个参数，即环绕范围内容的节点。在环绕范围插入内容时，后台会执行下列</div><div class="t m0 x0 h5 y14e4 ff7f fs2 fc0 sc0 lsa">步骤。 </div><div class="t m0 x0 hc y23d7 ff78 fs2 fc0 sc0 ls13 wsb">(1) 提取出范围中的内容（类似执行extractContent()）； </div><div class="t m0 x0 h5 y1dfd ff78 fs2 fc0 sc0 ls13 wsb">(2) 将给定节点插入到文档中原来范围所在的位置上； </div><div class="t m0 x0 h5 y23d8 ff78 fs2 fc0 sc0 ls13 wsb">(3) 将文档片段的内容添加到给定节点中。 </div><div class="t m0 x0 h5 y23d9 ff7f fs2 fc0 sc0 ls8 wseb">可以使用这种技术来突出显示网页中的某些词句，例如下列代码： </div><div class="t m0 x0 hb y23da ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y23db ff83 fs6 fc0 sc0 ls21 wsb">var p1 = document.getElementById(&quot;p1&quot;); </div><div class="t m0 x0 hb y23dc ff83 fs6 fc0 sc0 ls21 wsb">    helloNode = p1.firstChild.firstChild; </div><div class="t m0 x0 hb y23dd ff83 fs6 fc0 sc0 ls21 wsb">    worldNode = p1.lastChild; </div><div class="t m0 x0 hb y23de ff83 fs6 fc0 sc0 ls21 wsb">    range = document.createRange(); </div><div class="t m0 x0 hb y23df ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y23e0 ff84 fs6 fc0 sc0 ls21 wsb">range.selectNode(helloNode); </div><div class="t m0 x0 h15 y23e1 ff84 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y23e2 ff84 fs6 fc0 sc0 ls21 wsb">var span = document.createElement(&quot;span&quot;); </div><div class="t m0 x0 h15 y23e3 ff84 fs6 fc0 sc0 ls21 wsb">span.style.backgroundColor = &quot;yellow&quot;; </div><div class="t m0 x0 h15 y23e4 ff84 fs6 fc0 sc0 ls21 wsb">range.surroundContents(span); </div><div class="t m0 x0 hb y23e5 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y23e6 ff85 fs2 fc0 sc0 ls7a wsb">DOMRangeExample8.htm </div><div class="t m0 x0 h5 y23e7 ff7f fs2 fc0 sc0 ls8 wseb">会给范围选区加上一个黄色的背景。得到的HTML代码如下所示： </div><div class="t m0 x0 hb y23e8 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y23e9 ff83 fs6 fc0 sc0 ls21 wsb">&lt;p&gt;&lt;b&gt;&lt;span style=&quot;background-color:yellow&quot;&gt;Hello&lt;/span&gt;&lt;/b&gt; world!&lt;/p&gt; </div><div class="t m0 x0 hb y23ea ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y23a0 ff7f fs2 fc0 sc0 ls8 wseb">为了插入&lt;span&gt;，范围必须包含整个DOM选区（不能仅仅包含选中的DOM节点）。 </div><div class="t m0 x0 h3c y23eb ff7d fs2 fc0 sc0 ls2e wsb">5. 折叠DOM范围 </div><div class="t m0 x0 h4 y23ec ff7f fs2 fc0 sc0 ls8">所谓折叠范围，就是指范围中未选择文档的任何部分。可以用文本框来描述折叠范围的过程。假设</div><div class="t m0 x0 h4 y23ed ff7f fs2 fc0 sc0 ls8 wseb">文本框中有一行文本，你用鼠标选择了其中一个完整的单词。然后，你单击鼠标左键，选区消失，而光</div><div class="t m0 x0 h4 y23ee ff7f fs2 fc0 sc0 ls8 wseb">标则落在了其中两个字母之间。同样，在折叠范围时，其位置会落在文档中的两个部分之间，可能是范</div><div class="t m0 x0 h5 y23ef ff7f fs2 fc0 sc0 ls8 wseb">围选区的开始位置，也可能是结束位置。图12-9展示了折叠范围时发生的情形。 </div><div class="t m0 x0 hb2 y23f0 ff7f fs2 fc0 sc0 ls8 wseb">使用collapse()方法来折叠范围，这个方法接受一个参数，一个布尔值，表示要折叠到范围的哪</div><div class="t m0 x0 h1e y23f1 ff7f fs2 fc0 sc0 ls8 wseb">一端。参数true表示折叠到范围的起点，参数false表示折叠到范围的终点。要确定范围已经折叠完</div><div class="t m0 x0 h5 y23f2 ff7f fs2 fc0 sc0 ls8 wseb">毕，可以检查collapsed属性，如下所示： </div><div class="t m0 x0 hb y23f3 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y23f4 ff83 fs6 fc0 sc0 ls21 wsb">range.collapse(true);       //折叠到起点 </div><div class="t m0 x0 h16 y23f5 ff83 fs6 fc0 sc0 ls21 wsb">alert(range.collapsed);      //输出true </div><div class="t m0 x0 hb y23f6 ff83 fs6 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf165" class="pf w0 h0" data-page-no="165"><div class="pc pc165 w0 h0"><div class="t m0 x2 h2 y1 ff78 fs0 fc0 sc0 ls7 ws0">12.4 范围  339 </div><div class="t m0 x0 h3 y2 ff78 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff7a fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff7a fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff7a fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff7a fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff7a fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff7a fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff7a fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff7a fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff7a fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff7a fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff7a fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff7a fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff7a fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x2 h5 y23f7 ff78 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 h3 yb ff7f fs1 fc0 sc0 ls8 wsb">图 12-9 </div><div class="t m0 x0 h4 y23f8 ff7f fs2 fc0 sc0 ls8 wseb">检测某个范围是否处于折叠状态，可以帮我们确定范围中的两个节点是否紧密相邻。例如，对于下</div><div class="t m0 x0 h5 y23f9 ff7f fs2 fc0 sc0 ls8 wseb">面的HTML代码： </div><div class="t m0 x5 hb y23fa ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y23fb ff83 fs6 fc0 sc0 ls21 wsb">&lt;p id=&quot;p1&quot;&gt;Paragraph 1&lt;/p&gt;&lt;p id=&quot;p2&quot;&gt;Paragraph 2&lt;/p&gt; </div><div class="t m0 x5 hb y23fc ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y23fd ff7f fs2 fc0 sc0 ls42 wsf0">如果我们不知道其实际构成（比如说，这行代码是动态生成的），那么可以像下面这样创建一个范围。 </div><div class="t m0 x5 hb y166 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y23fe ff83 fs6 fc0 sc0 ls21 wsb">var p1 = document.getElementById(&quot;p1&quot;), </div><div class="t m0 x0 hb y23ff ff83 fs6 fc0 sc0 ls21 wsb">    p2 = document.getElementById(&quot;p2&quot;), </div><div class="t m0 x0 hb y2400 ff83 fs6 fc0 sc0 ls21 wsb">    range = document.createRange(); </div><div class="t m0 x0 hb y2401 ff83 fs6 fc0 sc0 ls21 wsb">range.setStartAfter(p1); </div><div class="t m0 x0 hb y2402 ff83 fs6 fc0 sc0 ls21 wsb">range.setStartBefore(p2); </div><div class="t m0 x0 h16 y2403 ff83 fs6 fc0 sc0 ls21 wsb">alert(range.collapsed);     //输出true </div><div class="t m0 x5 hb y2404 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y2405 ff7f fs2 fc0 sc0 ls8 wseb">在这个例子中，新创建的范围是折叠的，因为p1的后面和p2的前面什么也没有。 </div><div class="t m0 x0 h3c y2406 ff7d fs2 fc0 sc0 ls2e wsb">6. 比较DOM范围 </div><div class="t m0 x0 h4 y2407 ff7f fs2 fc0 sc0 ls6 wsf7">在有多个范围的情况下，可以使用compareBoundaryPoints()方法来确定这些范围是否有公共</div><div class="t m0 x0 h4 y19ef ff7f fs2 fc0 sc0 ls6 wsf7">的边界（起点或终点）。这个方法接受两个参数：表示比较方式的常量值和要比较的范围。表示比较方</div><div class="t m0 x0 h5 y2408 ff7f fs2 fc0 sc0 ls8 wseb">式的常量值如下所示。 </div><div class="t m0 x0 h5 y2409 ff7e fs1 fc0 sc0 ls2"> Range.START_TO_START(0)：比较第一个范围和第二个范围的起点； </div><div class="t m0 x0 h5 y240a ff7e fs1 fc0 sc0 ls2"> Range.START_TO_END(1)：比较第一个范围的起点和第二个范围的终点； </div><div class="t m0 x0 h5 y240b ff7e fs1 fc0 sc0 ls2"> Range.END_TO_END(2)：比较第一个范围和第二个范围的终点； </div><div class="t m0 x0 h5 y240c ff7e fs1 fc0 sc0 ls2"> Range.END_TO_START(3)：比较第一个范围的终点和第一个范围的起点。 </div><div class="t m0 x0 h4 y240d ff83 fs1 fc0 sc0 ls9 ws2">compareBoundaryPoints()方法可能的返回值如下：如果第一个范围中的点位于第二个范围中的</div><div class="t m0 x0 h1e y240e ff7f fs2 fc0 sc0 ls8 wseb">点之前，返回-1；如果两个点相等，返回0；如果第一个范围中的点位于第二个范围中的点之后，返回</div><div class="t m0 x0 h5 y240f ff83 fs1 fc0 sc0 ls8 ws23">1。来看下面的例子。 </div><div class="t m0 x5 hb y2410 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2411 ff83 fs6 fc0 sc0 ls21 wsb">var range1 = document.createRange(); </div><div class="t m0 x0 hb y2412 ff83 fs6 fc0 sc0 ls21 wsb">var range2 = document.createRange(); </div><div class="t m0 x0 hb y2413 ff83 fs6 fc0 sc0 ls21 wsb">var p1 = document.getElementById(&quot;p1&quot;); </div><div class="t m0 x0 hb y2414 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2415 ff83 fs6 fc0 sc0 ls21 wsb">range1.selectNodeContents(p1); </div><div class="t m0 x0 hb y2416 ff83 fs6 fc0 sc0 ls21 wsb">range2.selectNodeContents(p1); </div><div class="t m0 x0 hb y2417 ff83 fs6 fc0 sc0 ls21 wsb">range2.setEndBefore(p1.lastChild); </div><div class="t m0 x0 hb y2418 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2419 ff83 fs6 fc0 sc0 ls21 wsb">alert(range1.compareBoundaryPoints(Range.START_TO_START, range2));     //0 </div><div class="t m0 x0 hb y241a ff83 fs6 fc0 sc0 ls21 wsb">alert(range1.compareBoundaryPoints(Range.END_TO_END, range2));         //1 </div><div class="t m0 x0 hb y241b ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y241c ff85 fs2 fc0 sc0 ls7a wsb">DOMRangeExample9.htm </div><div class="t m0 x4 h36 y241d ff7f fs6 fc0 sc0 ls8 ws124">原始范围 </div><div class="t m0 x7 h36 y241e ff7f fs6 fc0 sc0 ls8 ws124">折叠到开始位置 </div><div class="t m0 x7 h36 y241f ff7f fs6 fc0 sc0 ls8 ws124">折叠到结束位置 </div></div></div>
<div id="pf166" class="pf w0 h0" data-page-no="166"><div class="pc pc166 w0 h0"><div class="t m0 x0 h2 y1 ff78 fs0 fc0 sc0 ls7 ws0">340  第12章 DOM2和DOM3 </div><div class="t m0 x0 h3 y2 ff78 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ff7f fs2 fc0 sc0 ls8 wseb">在这个例子中，两个范围的起点实际上是相同的，因为它们的起点都是由selectNodeContents()</div><div class="t m0 x0 h4 y4 ff7f fs2 fc0 sc0 ls8 wseb">方法设置的默认值来指定的。因此，第一次比较返回0。但是，range2的终点由于调用 setEndBefore()</div><div class="t m0 x0 h5 y4e ff7f fs2 fc0 sc0 ls8 wseb">已经改变了，结果是range1的终点位于range2的终点后面（见图 12-10），因此第二次比较返回1。 </div><div class="t m0 x2 h5 y2420 ff78 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x7 h3 y2421 ff7f fs1 fc0 sc0 ls8 wsb">图 12-10 </div><div class="t m0 x0 h3c y2422 ff7d fs2 fc0 sc0 ls2e wsb">7. 复制DOM范围 </div><div class="t m0 x0 had y2423 ff7f fs2 fc0 sc0 ls8 wseb">可以使用cloneRange()方法复制范围。这个方法会创建调用它的范围的一个副本。 </div><div class="t m0 x0 hb y2424 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2425 ff83 fs6 fc0 sc0 ls21 wsb">var newRange = range.cloneRange(); </div><div class="t m0 x0 hb y2426 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y13be ff7f fs2 fc0 sc0 ls8 wseb">新创建的范围与原来的范围包含相同的属性，而修改它的端点不会影响原来的范围。 </div><div class="t m0 x0 h3c y2427 ff7d fs2 fc0 sc0 ls2e wsb">8. 清理DOM范围 </div><div class="t m0 x0 h4 y2428 ff7f fs2 fc0 sc0 ls30 wsf6">在使用完范围之后，最好是调用detach()方法，以便从创建范围的文档中分离出该范围。调用</div><div class="t m0 x0 h4 y2429 ff83 fs1 fc0 sc0 ls3d ws2b">detach()之后，就可以放心地解除对范围的引用，从而让垃圾回收机制回收其内存了。来看下面的</div><div class="t m0 x0 h5 y242a ff7f fs2 fc0 sc0 ls24 wsf5">例子。 </div><div class="t m0 x0 hb y242b ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y242c ff83 fs6 fc0 sc0 ls21 wsb">range.detach();      //从文档中分离 </div><div class="t m0 x0 h16 y242d ff83 fs6 fc0 sc0 ls21 wsb">range = null;         //解除引用 </div><div class="t m0 x0 hb y242e ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y242f ff7f fs2 fc0 sc0 ls8 wseb">在使用范围的最后再执行这两个步骤是我们推荐的方式。一旦分离范围，就不能再恢复使用了。 </div><div class="t m0 x0 h20 y2430 ff7d fs3 fc0 sc0 ls248 ws214">12.4.2 IE8及更早版本中的范围 </div><div class="t m0 x0 h5 y2431 ff7f fs2 fc0 sc0 ls8 wseb">虽然IE9支持DOM范围，但IE8及之前版本不支持 DOM范围。不过，IE8及早期版本支持一种类</div><div class="t m0 x0 h5 y2432 ff7f fs2 fc0 sc0 ls8 wseb">似的概念，即文本范围（text range）。文本范围是IE专有的特性，其他浏览器都不支持。顾名思义，文</div><div class="t m0 x0 h5 y2433 ff7f fs2 fc0 sc0 ls8 wseb">本范围处理的主要是文本（不一定是DOM节点）。通过&lt;body&gt;、&lt;button&gt;、&lt;input&gt;和&lt;textarea&gt;</div><div class="t m0 x0 h5 y2434 ff7f fs2 fc0 sc0 ls8 wseb">等这几个元素，可以调用createTextRange()方法来创建文本范围。以下是一个例子： </div><div class="t m0 x0 hb y2435 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2436 ff83 fs6 fc0 sc0 ls21 wsb">var range = document.body.createTextRange(); </div><div class="t m0 x0 hb y2437 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y2438 ff7f fs2 fc0 sc0 ls8 wseb">像这样通过document创建的范围可以在页面中的任何地方使用（通过其他元素创建的范围则只能</div><div class="t m0 x0 h5 y2439 ff7f fs2 fc0 sc0 ls8 wseb">在相应的元素中使用）。与DOM范围类似，使用IE文本范围的方式也有很多种。 </div><div class="t m0 x0 h3c y243a ff7d fs2 fc0 sc0 ls2e wsb">1. 用IE范围实现简单的选择 </div><div class="t m0 x0 h4 y243b ff7f fs2 fc0 sc0 ls8 wseb">选择页面中某一区域的最简单方式，就是使用范围的findText()方法。这个方法会找到第一次出</div><div class="t m0 x0 h1e y243c ff7f fs2 fc0 sc0 ls5 wsec">现的给定文本，并将范围移过来以环绕该文本。如果没有找到文本，这个方法返回false；否则返回</div><div class="t m0 x0 h5 y243d ff83 fs1 fc0 sc0 ls9 ws2">true。同样，仍然以下面的HTML代码为例。 </div><div class="t m0 x0 hb ycb4 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y243e ff83 fs6 fc0 sc0 ls21 wsb">&lt;p id=&quot;p1&quot;&gt;&lt;b&gt;Hello&lt;/b&gt; world!&lt;/p&gt; </div><div class="t m0 x0 hb y243f ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1425 ff7f fs2 fc0 sc0 ls8 wseb">要选择&quot;Hello&quot;，可以使用下列代码。 </div><div class="t m0 x0 hb y231c ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2440 ff83 fs6 fc0 sc0 ls21 wsb">var range = document.body.createTextRange(); </div><div class="t m0 x0 hb y2441 ff83 fs6 fc0 sc0 ls21 wsb">var found = range.findText(&quot;Hello&quot;);</div><div class="t m4 x7 hc9 y9e0 ff8a fs13 fc0 sc1 ls8 wsb"> </div><div class="t m0 x0 hb y2442 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y241c ff85 fs2 fc0 sc0 ls2e wsb">IERangeExample1.htm </div></div></div>
<div id="pf167" class="pf w0 h0" data-page-no="167"><div class="pc pc167 w0 h0"><div class="t m0 x2 h2 y1 ff78 fs0 fc0 sc0 ls7 ws0">12.4 范围  341 </div><div class="t m0 x0 h3 y2 ff78 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff7a fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff7a fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff7a fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff7a fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff7a fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff7a fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff7a fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff7a fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff7a fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff7a fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff7a fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff7a fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff7a fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h4 y3 ff7f fs2 fc0 sc0 ls8 wseb">在执行完第二行代码之后，文本&quot;Hello&quot;就被包围在范围之内了。为此，可以检查范围的text属</div><div class="t m0 x0 h1e y4d ff7f fs2 fc0 sc0 ls6 wsf7">性来确认（这个属性返回范围中包含的文本），或者也可以检查findText()的返回值——在找到了文</div><div class="t m0 x0 hc y5 ff7f fs2 fc0 sc0 ls8 wseb">本的情况下返回值为true。例如： </div><div class="t m0 x5 hb y41f ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y897 ff83 fs6 fc0 sc0 ls21 wsb">alert(found);           //true </div><div class="t m0 x0 hb y2443 ff83 fs6 fc0 sc0 ls21 wsb">alert(range.text);      //&quot;Hello&quot; </div><div class="t m0 x5 hb y2444 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1ef4 ff7f fs2 fc0 sc0 ls8 wseb">还可以为findText()传入另一个参数，即一个表示向哪个方向继续搜索的数值。负值表示应该从</div><div class="t m0 x0 h1e y2445 ff7f fs2 fc0 sc0 ls8 wseb">当前位置向后搜索，而正值表示应该从当前位置向前搜索。因此，要查找文档中前两个&quot;Hello&quot;的实例，</div><div class="t m0 x0 h5 y2446 ff7f fs2 fc0 sc0 ls8 wseb">应该使用下列代码。 </div><div class="t m0 x5 hb yf4c ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2447 ff83 fs6 fc0 sc0 ls21 wsb">var found = range.findText(&quot;Hello&quot;); </div><div class="t m0 x0 hb y2448 ff83 fs6 fc0 sc0 ls21 wsb">var foundAgain = range.findText(&quot;Hello&quot;, 1); </div><div class="t m0 x5 hb y2449 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y22df ff78 fs2 fc0 sc0 lse ws9">IE中与DOM中的selectNode()方法最接近的方法是moveToElementText()，这个方法接受一</div><div class="t m0 x0 h5 y244a ff7f fs2 fc0 sc0 ls3b">个DOM元素，并选择该元素的所有文本，包括HTML标签。下面是一个例子。 </div><div class="t m0 x0 hb y244b ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y244c ff83 fs6 fc0 sc0 ls21 wsb">var range = document.body.createTextRange(); </div><div class="t m0 x0 hb y244d ff83 fs6 fc0 sc0 ls21 wsb">var p1 = document.getElementById(&quot;p1&quot;); </div><div class="t m0 x0 hb y244e ff83 fs6 fc0 sc0 ls21 wsb">range.moveToElementText(p1); </div><div class="t m0 x0 hb y244f ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1a57 ff85 fs2 fc0 sc0 ls2e wsb">IERangeExample2.htm </div><div class="t m0 x0 h5 y2450 ff7f fs2 fc0 sc0 ls8 wseb">在文本范围中包含HTML的情况下，可以使用htmlText属性取得范围的全部内容，包括 HTML</div><div class="t m0 x0 h5 y2451 ff7f fs2 fc0 sc0 ls8 wseb">和文本，如下面的例子所示。 </div><div class="t m0 x5 hb y2452 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2453 ff83 fs6 fc0 sc0 ls21 wsb">alert(range.htmlText); </div><div class="t m0 x5 hb y2454 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y2455 ff78 fs2 fc0 sc0 lse ws9">IE的范围没有任何属性可以随着范围选区的变化而动态更新。不过，其parentElement()方法倒</div><div class="t m0 x0 h5 y2456 ff7f fs2 fc0 sc0 ls8 wseb">是与DOM的commonAncestorContainer属性类似。 </div><div class="t m0 x5 hb y2457 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2458 ff83 fs6 fc0 sc0 ls21 wsb">var ancestor = range.parentElement(); </div><div class="t m0 x0 hb y2459 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1f8c ff7f fs2 fc0 sc0 ls8 wseb">这样得到的父元素始终都可以反映文本选区的父节点。 </div><div class="t m0 x0 h3c y245a ff7d fs2 fc0 sc0 ls2e wsb">2. 使用IE范围实现复杂的选择 </div><div class="t m0 x0 h5 y245b ff7f fs2 fc0 sc0 lsb7">在IE中创建复杂范围的方法，就是以特定的增量向四周移动范围。为此，IE提供了4个方法：</div><div class="t m0 x0 h4 yb8a ff83 fs1 fc0 sc0 ls9 ws2">move()、moveStart()、moveEnd()和expand()。这些方法都接受两个参数：移动单位和移动单位</div><div class="t m0 x0 h5 yb8b ff7f fs2 fc0 sc0 ls8 wseb">的数量。其中，移动单位是下列一种字符串值。 </div><div class="t m0 x0 h5 y245c ff7e fs1 fc0 sc0 ls2"> &quot;character&quot;：逐个字符地移动。 </div><div class="t m0 x0 h5 y245d ff7e fs1 fc0 sc0 ls2"> &quot;word&quot;：逐个单词（一系列非空格字符）地移动。 </div><div class="t m0 x0 h5 y245e ff7e fs1 fc0 sc0 ls2"> &quot;sentence&quot;：逐个句子（一系列以句号、问号或叹号结尾的字符）地移动。 </div><div class="t m0 x0 h5 y245f ff7e fs1 fc0 sc0 ls2"> &quot;textedit&quot;：移动到当前范围选区的开始或结束位置。 </div><div class="t m0 x0 h1e y2460 ff7f fs2 fc0 sc0 ls8 wseb">通过moveStart()方法可以移动范围的起点，通过moveEnd()方法可以移动范围的终点，移动的</div><div class="t m0 x0 h5 y2461 ff7f fs2 fc0 sc0 ls8 wseb">幅度由单位数量指定，如下面的例子所示。 </div><div class="t m0 x5 hb y2462 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2463 ff83 fs6 fc0 sc0 ls21 wsb">range.moveStart(&quot;word&quot;, 2);        //起点移动2个单词 </div><div class="t m0 x0 h16 y2464 ff83 fs6 fc0 sc0 ls21 wsb">range.moveEnd(&quot;character&quot;, 1);     //终点移动1个字符 </div><div class="t m0 x5 hb y2465 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1f30 ff7f fs2 fc0 sc0 ls6 wsf7">使用expand()方法可以将范围规范化。换句话说，expand()方法的作用是将任何部分选择的文</div><div class="t m0 x0 h1e y1f31 ff7f fs2 fc0 sc0 ls8 wseb">本全部选中。例如，当前选择的是一个单词中间的两个字符，调用expand(&quot;word&quot;)可以将整个单词都</div><div class="t m0 x0 h5 y865 ff7f fs2 fc0 sc0 ls8 wseb">包含在范围之内。 </div></div></div>
<div id="pf168" class="pf w0 h0" data-page-no="168"><div class="pc pc168 w0 h0"><div class="t m0 x0 h2 y1 ff78 fs0 fc0 sc0 ls7 ws0">342  第12章 DOM2和DOM3 </div><div class="t m0 x0 h3 y2 ff78 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ff7f fs2 fc0 sc0 ls2c">而move()方法则首先会折叠当前范围（让起点和终点相等），然后再将范围移动指定的单位数量，</div><div class="t m0 x0 h5 y4d ff7f fs2 fc0 sc0 ls8 wseb">如下面的例子所示。 </div><div class="t m0 x0 hb y2d8 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2d9 ff83 fs6 fc0 sc0 ls21 wsb">range.move(&quot;character&quot;, 5);     //移动5个字符 </div><div class="t m0 x0 hb y1bfe ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1512 ff7f fs2 fc0 sc0 ls8 wseb">调用move()之后，范围的起点和终点相同，因此必须再使用moveStart()或moveEnd()创建新</div><div class="t m0 x0 h5 y15b3 ff7f fs2 fc0 sc0 ls8">的选区。 </div><div class="t m0 x0 h3c y2467 ff7d fs2 fc0 sc0 ls2e wsb">3. 操作IE范围中的内容 </div><div class="t m0 x0 h5 y2468 ff7f fs2 fc0 sc0 ls21b">在IE中操作范围中的内容可以使用text属性或pasteHTML()方法。如前所述，通过 text属性</div><div class="t m0 x0 h5 y2469 ff7f fs2 fc0 sc0 ls8 wseb">可以取得范围中的内容文本；但是，也可以通过这个属性设置范围中的内容文本。来看一个例子。 </div><div class="t m0 x0 hb y1a04 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y246a ff83 fs6 fc0 sc0 ls21 wsb">var range = document.body.createTextRange(); </div><div class="t m0 x0 hb y246b ff83 fs6 fc0 sc0 ls21 wsb">range.findText(&quot;Hello&quot;); </div><div class="t m0 x0 hb y246c ff83 fs6 fc0 sc0 ls21 wsb">range.text = &quot;Howdy&quot;; </div><div class="t m0 x0 hb y246d ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y246e ff7f fs2 fc0 sc0 ls8 wseb">如果仍以前面的Hello World代码为例，执行以上代码后的HTML代码如下。 </div><div class="t m0 x0 hb y246f ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2470 ff83 fs6 fc0 sc0 ls21 wsb">&lt;p id=&quot;p1&quot;&gt;&lt;b&gt;Howdy&lt;/b&gt; world!&lt;/p&gt; </div><div class="t m0 x0 hb y2471 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y2472 ff7f fs2 fc0 sc0 ls8 wseb">注意，在设置text属性的情况下，HTML标签保持不变。 </div><div class="t m0 x0 h5 y2473 ff7f fs2 fc0 sc0 ls8 wseb">要向范围中插入HTML代码，就得使用pasteHTML()方法，如下面的例子所示。 </div><div class="t m0 x0 hb y2474 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2475 ff83 fs6 fc0 sc0 ls21 wsb">var range = document.body.createTextRange(); </div><div class="t m0 x0 hb y2476 ff83 fs6 fc0 sc0 ls21 wsb">range.findText(&quot;Hello&quot;); </div><div class="t m0 x0 h15 y2477 ff84 fs6 fc0 sc0 ls21 wsb">range.pasteHTML(&quot;&lt;em&gt;Howdy&lt;/em&gt;&quot;); </div><div class="t m0 x0 hb y2478 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y2479 ff85 fs2 fc0 sc0 ls2e wsb">IERangeExample3.htm </div><div class="t m0 x0 h5 y1beb ff7f fs2 fc0 sc0 ls8 wseb">执行这些代码后，会得到如下HTML。 </div><div class="t m0 x0 hb y247a ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y247b ff83 fs6 fc0 sc0 ls21 wsb">&lt;p id=&quot;p1&quot;&gt;&lt;b&gt;&lt;em&gt;Howdy&lt;/em&gt;&lt;/b&gt; world!&lt;/p&gt; </div><div class="t m0 x0 hb y247c ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y247d ff7f fs2 fc0 sc0 ls8 wseb">不过，在范围中包含HTML代码时，不应该使用pasteHTML()，因为这样很容易导致不可预料的</div><div class="t m0 x0 h5 y5dc ff7f fs2 fc0 sc0 ls8 wseb">结果——很可能是格式不正确的HTML。 </div><div class="t m0 x0 h3c y247e ff7d fs2 fc0 sc0 ls2e wsb">4. 折叠IE范围 </div><div class="t m0 x0 h5 y247f ff78 fs2 fc0 sc0 lse ws9">IE为范围提供的collapse()方法与相应的DOM方法用法一样：传入true 把范围折叠到起点，</div><div class="t m0 x0 hc y2480 ff7f fs2 fc0 sc0 ls8 wseb">传入false把范围折叠到终点。例如： </div><div class="t m0 x0 hb y2481 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2482 ff83 fs6 fc0 sc0 ls21 wsb">range.collapse(true);     //折叠到起点 </div><div class="t m0 x0 hb y2483 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y19f ff7f fs2 fc0 sc0 ls4 ws10d">可惜的是，没有对应的collapsed属性让我们知道范围是否已经折叠完毕。为此，必须使用</div><div class="t m0 x0 h5 y2484 ff83 fs1 fc0 sc0 ls9 ws2">boundingWidth属性，该属性返回范围的宽度（以像素为单位）。如果boundingWidth属性等于0，</div><div class="t m0 x0 h5 y2485 ff7f fs2 fc0 sc0 ls8 wseb">就说明范围已经折叠了： </div><div class="t m0 x0 hb y88e ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2486 ff83 fs6 fc0 sc0 ls21 wsb">var isCollapsed = (range.boundingWidth == 0); </div><div class="t m0 x0 hb y2487 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y2488 ff7f fs2 fc0 sc0 ls26 ws101">此外，还有boundingHeight、boundingLeft和boundingTop 等属性，虽然它们都不像</div><div class="t m0 x0 h5 y8c0 ff83 fs1 fc0 sc0 ls9 ws2">boundingWidth那么有用，但也可以提供一些有关范围位置的信息。 </div><div class="t m0 x0 h3c y2489 ff7d fs2 fc0 sc0 ls2e wsb">5. 比较IE范围 </div><div class="t m0 x0 h5 y248a ff78 fs2 fc0 sc0 lse ws9">IE中的compareEndPoints()方法与DOM范围的compareBoundaryPoints()方法类似。这个</div><div class="t m0 x0 h4 y248b ff7f fs2 fc0 sc0 ls6f ws113">方法接受两个参数：比较的类型和要比较的范围。比较类型的取值范围是下列几个字符串值：</div></div></div>
<div id="pf169" class="pf w0 h0" data-page-no="169"><div class="pc pc169 w0 h0"><div class="t m0 x2 h2 y1 ff78 fs0 fc0 sc0 ls7 ws0">12.5 小结  343 </div><div class="t m0 x0 h3 y2 ff78 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff7a fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff7a fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff7a fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff7a fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff7a fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff7a fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff7a fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff7a fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff7a fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff7a fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff7a fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff7a fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff7a fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff83 fs1 fc0 sc0 ls9 ws2">&quot;StartToStart&quot;、&quot;StartToEnd&quot;、&quot;EndToEnd&quot;和&quot;EndToStart&quot;。这几种比较类型与比较DOM范</div><div class="t m0 x0 h5 y4d ff7f fs2 fc0 sc0 ls8 wseb">围时使用的几个值是相同的。 </div><div class="t m0 x0 h5 yd8 ff7f fs2 fc0 sc0 ls8 wseb">同样与DOM类似的是，compareEndPoints()方法也会按照相同的规则返回值，即如果第一个范</div><div class="t m0 x0 h4 yd9 ff7f fs2 fc0 sc0 ls8 wseb">围的边界位于第二个范围的边界前面，返回-1；如果二者边界相同，返回0；如果第一个范围的边界位</div><div class="t m0 x0 hc y15d ff7f fs2 fc0 sc0 ls8 wseb">于第二个范围的边界后面，返回1。仍以前面的Hello World代码为例，下列代码将创建两个范围，一个</div><div class="t m0 x0 hc y21a ff7f fs2 fc0 sc0 ls8 wseb">选择&quot;Hello world!&quot;（包括&lt;b&gt;标签），另一个选择&quot;Hello&quot;。 </div><div class="t m0 x5 hb y1b77 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1b78 ff83 fs6 fc0 sc0 ls21 wsb">var range1 = document.body.createTextRange(); </div><div class="t m0 x0 hb y1b79 ff83 fs6 fc0 sc0 ls21 wsb">var range2 = document.body.createTextRange(); </div><div class="t m0 x0 hb y248c ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y248d ff83 fs6 fc0 sc0 ls21 wsb">range1.findText(&quot;Hello world!&quot;); </div><div class="t m0 x0 hb y248e ff83 fs6 fc0 sc0 ls21 wsb">range2.findText(&quot;Hello&quot;); </div><div class="t m0 x0 hb y248f ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2490 ff83 fs6 fc0 sc0 ls21 wsb">alert(range1.compareEndPoints(&quot;StartToStart&quot;, range2));      //0 </div><div class="t m0 x0 hb y2491 ff83 fs6 fc0 sc0 ls21 wsb">alert(range1.compareEndPoints(&quot;EndToEnd&quot;, range2));        //1 </div><div class="t m0 x5 hb y2492 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y2493 ff85 fs2 fc0 sc0 ls2e wsb">IERangeExample5.htm </div><div class="t m0 x0 h4 y2494 ff7f fs2 fc0 sc0 ls6 wsf7">由于这两个范围共享同一个起点，所以使用compareEndPoints()比较起点返回0。而 range1</div><div class="t m0 x0 h5 y2495 ff7f fs2 fc0 sc0 ls8 wseb">的终点在range2的终点后面，所以compareEndPoints()返回1。 </div><div class="t m0 x0 h5 y2496 ff78 fs2 fc0 sc0 lse ws9">IE中还有两个方法，也是用于比较范围的：isEqual()用于确定两个范围是否相等，inRange()</div><div class="t m0 x0 h5 y2497 ff7f fs2 fc0 sc0 ls8 wseb">用于确定一个范围是否包含另一个范围。下面是相应的示例。 </div><div class="t m0 x5 hb y2498 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2499 ff83 fs6 fc0 sc0 ls21 wsb">var range1 = document.body.createTextRange(); </div><div class="t m0 x0 hb y249a ff83 fs6 fc0 sc0 ls21 wsb">var range2 = document.body.createTextRange(); </div><div class="t m0 x0 hb y249b ff83 fs6 fc0 sc0 ls21 wsb">range1.findText(&quot;Hello World&quot;); </div><div class="t m0 x0 hb y249c ff83 fs6 fc0 sc0 ls21 wsb">range2.findText(&quot;Hello&quot;); </div><div class="t m0 x0 h15 y249d ff84 fs6 fc0 sc0 ls21 wsb">alert(&quot;range1.isEqual(range2): &quot; + range1.isEqual(range2));  //false </div><div class="t m0 x0 h15 y249e ff84 fs6 fc0 sc0 ls21 wsb">alert(&quot;range1.inRange(range2):&quot; + range1.inRange(range2));    //true </div><div class="t m0 x5 hb y249f ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1a78 ff85 fs2 fc0 sc0 ls2e wsb">IERangeExample6.htm </div><div class="t m0 x0 h4 y24a0 ff7f fs2 fc0 sc0 ls8 wseb">这个例子使用了与前面相同的范围来示范这两个方法。由于这两个范围的终点不同，所以它们不相</div><div class="t m0 x0 h4 y24a1 ff7f fs2 fc0 sc0 ls8 wseb">等，调用isEqual()返回false。由于range2实际位 于range1内部，它的终点位于后者的终点之</div><div class="t m0 x0 hc y24a2 ff7f fs2 fc0 sc0 ls8 wseb">前、起点之后，所以range2被包含在range1内部，调用 inRange()返回true。 </div><div class="t m0 x0 h3c y24a3 ff7d fs2 fc0 sc0 ls2e wsb">6. 复制IE范围 </div><div class="t m0 x0 h5 y24a4 ff7f fs2 fc0 sc0 ls3b">在IE中使用duplicate()方法可以复制文本范围，结果会创建原范围的一个副本，如下面的例子</div><div class="t m0 x0 h5 y24a5 ff7f fs2 fc0 sc0 ls8">所示。 </div><div class="t m0 x5 hb y24a6 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y24a7 ff83 fs6 fc0 sc0 ls21 wsb">var newRange = range.duplicate(); </div><div class="t m0 x5 hb y24a8 ff83 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y28 ff7f fs2 fc0 sc0 ls8 wseb">新创建的范围会带有与原范围完全相同的属性。 </div><div class="t m0 x0 hd y24a9 ff7d fs7 fc0 sc0 ls245">12.5 小结 </div><div class="t m0 x0 h5 y514 ff78 fs2 fc0 sc0 ls2e wsf4">DOM2级规范定义了一些模块，用于增强DOM1级。“DOM2级核心”为不同的DOM类型引入了</div><div class="t m0 x0 h5 y7f0 ff7f fs2 fc0 sc0 ls8 wseb">一些与XML命名空间有关的方法。这些变化只在使用XML或XHTML文档时才有用；对于 HTML文</div><div class="t m0 x0 h5 y7f1 ff7f fs2 fc0 sc0 ls30 wsf6">档没有实际意义。除了与XML命名空间有关的方法外，“DOM2级核心”还定义了以编程方式创建</div><div class="t m0 x0 h5 y517 ff83 fs1 fc0 sc0 ls9 ws2">Document实例的方法，也支持了创建DocumentType对象。 </div></div></div>
<div id="pf16a" class="pf w0 h0" data-page-no="16a"><div class="pc pc16a w0 h0"><div class="t m0 x0 h2 y1 ff78 fs0 fc0 sc0 ls7 ws0">344  第12章 DOM2和DOM3 </div><div class="t m0 x0 h3 y2 ff78 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff7f fs2 fc0 sc0 ls8">“DOM2级样式”模块主要针对操作元素的样式信息而开发，其特性简要总结如下。 </div><div class="t m0 x0 h5 y4 ff7e fs1 fc0 sc0 ls2"> 每个元素都有一个关联的style对象，可以用来确定和修改行内的样式。 </div><div class="t m0 x0 h5 y4e ff7e fs1 fc0 sc0 ls2"> 要确定某个元素的计算样式（包括应用给它的所有CSS规则），可以使用getComputedStyle()</div><div class="t m0 x0 h5 yd9 ff7f fs2 fc0 sc0 ls8">方法。 </div><div class="t m0 x0 h5 y219 ff7e fs1 fc0 sc0 ls2"> IE不支持getComputedStyle()方法，但为所有元素都提供了能够返回相同信息currentStyle</div><div class="t m0 x0 h5 y8 ff7f fs2 fc0 sc0 ls8">属性。 </div><div class="t m0 x0 h5 y9 ff7e fs1 fc0 sc0 ls2"> 可以通过document.styleSheets集合访问样式表。 </div><div class="t m0 x0 h5 ya ff7e fs1 fc0 sc0 ls2"> 除IE之外的所有浏览器都支持针对样式表的这个接口，IE也为几乎所有相应的DOM功能提供</div><div class="t m0 x0 h5 yb ff7f fs2 fc0 sc0 ls8 wseb">了自己的一套属性和方法。 </div><div class="t m0 x0 h5 y78a ff7f fs2 fc0 sc0 ls8">“DOM2级遍历和范围”模块提供了与DOM结构交互的不同方式，简要总结如下。 </div><div class="t m0 x0 h5 yd ff7e fs1 fc0 sc0 ls2"> 遍历即使用NodeIterator或TreeWalker对DOM执行深度优先的遍历。 </div><div class="t m0 x0 h4 y21b ff7e fs1 fc0 sc0 ls2"> NodeIterator是一个简单的接口，只允许以一个节点的步幅前后移动。而TreeWalker在提</div><div class="t m0 x0 h5 y21c ff7f fs2 fc0 sc0 ls8 wseb">供相同功能的同时，还支持在DOM结构的各个方向上移动，包括父节点、同辈节点和子节点等</div><div class="t m0 x0 h5 y116c ff7f fs2 fc0 sc0 ls8">方向。 </div><div class="t m0 x0 h5 y11 ff7e fs1 fc0 sc0 ls2"> 范围是选择DOM结构中特定部分，然后再执行相应操作的一种手段。 </div><div class="t m0 x0 h4 y1a57 ff7e fs1 fc0 sc0 ls2"> 使用范围选区可以在删除文档中某些部分的同时，保持文档结构的格式良好，或者复制文档中</div><div class="t m0 x0 h5 y13 ff7f fs2 fc0 sc0 ls8 wseb">的相应部分。 </div><div class="t m0 x0 h5 y24aa ff7e fs1 fc0 sc0 ls2"> IE8及更早版本不支持“DOM2级遍历和范围”模块，但它提供了一个专有的文本范围对象，可</div><div class="t m0 x0 h5 y24ab ff7f fs2 fc0 sc0 ls8 wseb">以用来完成简单的基于文本的范围操作。IE9完全支持DOM遍历。 </div><div class="t m0 x0 h5 y24ac ff78 fs2 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf16b" class="pf w0 h0" data-page-no="16b"><div class="pc pc16b w0 h0"><div class="t m0 x2 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">13.1 事件流    345 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff8d fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff8d fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff8d fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff8d fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff8d fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff8d fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff8d fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff8d fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff8d fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff8d fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff8d fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff8d fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff8d fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h9 y2a ff8e fs5 fc0 sc0 ls2fe wsb">事  件 </div><div class="t m0 x0 h3c y2b ff8f fs2 fc0 sc0 ls8">本章内容 </div><div class="t m0 x0 h5 y2c ff91 fs1 fc0 sc0 ls2"> 理解事件流 </div><div class="t m0 x0 h5 y2d ff91 fs1 fc0 sc0 ls2"> 使用事件处理程序 </div><div class="t m0 x0 h5 y2e ff91 fs1 fc0 sc0 ls2"> 不同的事件类型 </div><div class="t m0 x0 h5 y8d9 ff8b fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x5 h5 y8da ff8b fs2 fc0 sc0 ls1b ws6e">avaScript与HTML之间的交互是通过事件实现的。事件，就是文档或浏览器窗口中发生的一些</div><div class="t m0 x5 h4 y8db ff92 fs2 fc0 sc0 ls8 wseb">特定的交互瞬间。可以使用侦听器（或处理程序）来预订事件，以便事件发生时执行相应的代</div><div class="t m0 x5 h5 y8dc ff92 fs2 fc0 sc0 ls8 wseb">码。这种在传统软件工程中被称为观察员模式的模型，支持页面的行为（JavaScript代码）与页</div><div class="t m0 x0 h5 y8dd ff92 fs2 fc0 sc0 ls8 wseb">面的外观（HTML和CSS代码）之间的松散耦合。 </div><div class="t m0 x0 h5 y8de ff92 fs2 fc0 sc0 ls8 wseb">事件最早是在IE3和Netscape Navigator 2中出现的，当时是作为分担服务器运算负载的一种手段。</div><div class="t m0 x0 h5 y8df ff92 fs2 fc0 sc0 ls3b">在IE4和Navigator 4发布时，这两种浏览器都提供了相似但不相同的API，这些API并存经过了好几个</div><div class="t m0 x0 h5 y8e0 ff92 fs2 fc0 sc0 ls8 wseb">主要版本。DOM2级规范开始尝试以一种符合逻辑的方式来标准化DOM事件。IE9、Firefox、Opera、</div><div class="t m0 x0 h5 y8e1 ff8b fs2 fc0 sc0 ls48 ws39">Safari和Chrome全都已经实现了“DOM2级事件”模块的核心部分。IE8是最后一个仍然使用其专有事</div><div class="t m0 x0 h5 y8e2 ff92 fs2 fc0 sc0 ls8 wseb">件系统的主要浏览器。 </div><div class="t m0 x0 h5 y1419 ff92 fs2 fc0 sc0 ls8 wseb">浏览器的事件系统相对比较复杂。尽管所有主要浏览器已经实现了“DOM2级事件”，但这个规范</div><div class="t m0 x0 h5 y141a ff92 fs2 fc0 sc0 ls5 wsec">本身并没有涵盖所有事件类型。浏览器对象模型（BOM）也支持一些事件，这些事件与文档对象模型</div><div class="t m0 x0 h5 y24ad ff92 fs2 fc0 sc0 ls8">（DOM）事件之间的关系并不十分清晰，因为BOM事件长期没有规范可以遵循（HTML5后来给出了详</div><div class="t m0 x0 h5 y24ae ff92 fs2 fc0 sc0 ls8 wseb">细的说明）。随着DOM3级的出现，增强后的DOM事件API变得更加繁琐。使用事件有时相对简单，</div><div class="t m0 x0 h5 y24af ff92 fs2 fc0 sc0 ls8 wseb">有时则非常复杂，难易程度会因你的需求而不同。不过，有关事件的一些核心概念是一定要理解的。 </div><div class="t m0 x0 hd y24b0 ff90 fs7 fc0 sc0 ls245">13.1 事件流 </div><div class="t m0 x0 h5 y2101 ff92 fs2 fc0 sc0 ls8 wseb">当浏览器发展到第四代时（IE4及Netscape Communicator 4），浏览器开发团队遇到了一个很有意思</div><div class="t m0 x0 h4 y2102 ff92 fs2 fc0 sc0 ls8 wseb">的问题：页面的哪一部分会拥有某个特定的事件？要明白这个问题问的是什么，可以想象画在一张纸上</div><div class="t m0 x0 h4 y18bf ff92 fs2 fc0 sc0 ls8 wseb">的一组同心圆。如果你把手指放在圆心上，那么你的手指指向的不是一个圆，而是纸上的所有圆。两家</div><div class="t m0 x0 h4 y24b1 ff92 fs2 fc0 sc0 ls8 wseb">公司的浏览器开发团队在看待浏览器事件方面还是一致的。如果你单击了某个按钮，他们都认为单击事</div><div class="t m0 x0 h4 y24b2 ff92 fs2 fc0 sc0 ls8 wseb">件不仅仅发生在按钮上。换句话说，在单击按钮的同时，你也单击了按钮的容器元素，甚至也单击了整</div><div class="t m0 x0 h5 y24b3 ff92 fs2 fc0 sc0 ls8">个页面。 </div><div class="t m0 x0 h5 y24b4 ff8f fs2 fc0 sc0 ls8">事件流描述的是从页面中接收事件的顺序。但有意思的是，IE和Netscape开发团队居然提出了差</div><div class="t m0 x0 h5 y24b5 ff92 fs2 fc0 sc0 ls8 wseb">不多是完全相反的事件流的概念。IE的事件流是事件冒泡流，而Netscape Communicator的事件流是事</div><div class="t m0 x0 h5 y24b6 ff92 fs2 fc0 sc0 ls8 wseb">件捕获流。 </div><div class="t m0 x0 h78 y7ff ff93 fs11 fc0 sc0 ls8 wsb">J </div><div class="t m0 x0 h11 y4b ff94 fsa fc0 sc0 ls8">第</div><div class="t m1 x0 h12 y4b ff95 fsb fc3 sc0 ls247">13</div><div class="t m0 x5 h11 y4b ff94 fsa fc0 sc0 ls8 ws1d">章 </div></div></div>
<div id="pf16c" class="pf w0 h0" data-page-no="16c"><div class="pc pc16c w0 h0"><div class="t m0 x0 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">346  第13章 事件 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h20 y12d ff90 fs3 fc0 sc0 ls248 ws214">13.1.1 事件冒泡 </div><div class="t m0 x0 h5 y12e ff8b fs2 fc0 sc0 lse ws9">IE的事件流叫做事件冒泡（event bubbling），即事件开始时由最具体的元素（文档中嵌套层次最深</div><div class="t m0 x0 h5 y12f ff92 fs2 fc0 sc0 ls8 wseb">的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。以下面的HTML页面为例： </div><div class="t m0 x0 hb y24b8 ff96 fs6 fc0 sc0 ls21 wsb">&lt;!DOCTYPE html&gt; </div><div class="t m0 x0 hb y24b9 ff96 fs6 fc0 sc0 ls21 wsb">&lt;html&gt; </div><div class="t m0 x0 hb y24ba ff96 fs6 fc0 sc0 ls21 wsb">&lt;head&gt; </div><div class="t m0 x0 hb y24bb ff96 fs6 fc0 sc0 ls21 wsb">    &lt;title&gt;Event Bubbling Example&lt;/title&gt; </div><div class="t m0 x0 hb y24bc ff96 fs6 fc0 sc0 ls21 wsb">&lt;/head&gt; </div><div class="t m0 x0 hb y24bd ff96 fs6 fc0 sc0 ls21 wsb">&lt;body&gt; </div><div class="t m0 x0 hb y24be ff96 fs6 fc0 sc0 ls21 wsb">    &lt;div id=&quot;myDiv&quot;&gt;Click Me&lt;/div&gt; </div><div class="t m0 x0 hb y24bf ff96 fs6 fc0 sc0 ls21 wsb">&lt;/body&gt; </div><div class="t m0 x0 hb y24c0 ff96 fs6 fc0 sc0 ls21 wsb">&lt;/html&gt; </div><div class="t m0 x0 hb y24c1 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y24c2 ff92 fs2 fc0 sc0 ls8 wseb">如果你单击了页面中的&lt;div&gt;元素，那么这个click事件会按照如下顺序传播： </div><div class="t m0 x0 h5 y24c3 ff8b fs2 fc0 sc0 ls13 wsb">(1) &lt;div&gt; </div><div class="t m0 x0 h5 y24c4 ff8b fs2 fc0 sc0 ls13 wsb">(2) &lt;body&gt; </div><div class="t m0 x0 h5 y24c5 ff8b fs2 fc0 sc0 ls13 wsb">(3) &lt;html&gt; </div><div class="t m0 x0 h5 y24c6 ff8b fs2 fc0 sc0 ls13 wsb">(4) document </div><div class="t m0 x0 h4 y24c7 ff92 fs2 fc0 sc0 ls8 wseb">也就是说，click事件首先在&lt;div&gt;元素上发生，而这个元素就是我们单击的元素。然后，click</div><div class="t m0 x0 h5 y24c8 ff92 fs2 fc0 sc0 ls8 wseb">事件沿DOM树向上传播，在每一级节点上都会发生，直至传播到document对象。图13-1展示了事件</div><div class="t m0 x0 h5 y24c9 ff92 fs2 fc0 sc0 ls8 wseb">冒泡的过程。 </div><div class="t m0 x4 h5 y24ca ff8b fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x7 h3 yf15 ff92 fs1 fc0 sc0 ls8 wsb">图 13-1 </div><div class="t m0 x0 h5 y18fa ff92 fs2 fc0 sc0 ls6 wsf7">所有现代浏览器都支持事件冒泡，但在具体实现上还是有一些差别。IE5.5及更早版本中的事件冒</div><div class="t m0 x0 hc y24cb ff92 fs2 fc0 sc0 ls8 wseb">泡会跳过&lt;html&gt;元素（从&lt;body&gt;直接跳到document）。IE9、Firefox、Chrome和Safari则将事件一直</div><div class="t m0 x0 hc y24cc ff92 fs2 fc0 sc0 ls8 wseb">冒泡到window对象。 </div><div class="t m0 x0 h20 y24cd ff90 fs3 fc0 sc0 ls248 ws214">13.1.2 事件捕获 </div><div class="t m0 x0 h5 y1722 ff8b fs2 fc0 sc0 ls2b ws2c1">Netscape Communicator团队提出的另一种事件流叫做事件捕获（event capturing）。事件捕获的思想</div><div class="t m0 x0 h4 y24ce ff92 fs2 fc0 sc0 ls8 wseb">是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。事件捕获的用意在于在</div><div class="t m0 x0 h5 y24cf ff92 fs2 fc0 sc0 ls8 wseb">事件到达预定目标之前捕获它。如果仍以前面的HTML页面作为演示事件捕获的例子，那么单击&lt;div&gt;</div><div class="t m0 x0 h5 y24d0 ff92 fs2 fc0 sc0 ls8 wseb">元素就会以下列顺序触发click事件。 </div><div class="t m0 x0 h5 y24d1 ff8b fs2 fc0 sc0 ls13 wsb">(1) document </div></div></div>
<div id="pf16d" class="pf w0 h0" data-page-no="16d"><div class="pc pc16d w0 h0"><div class="t m0 x2 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">13.1 事件流    347 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff8d fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff8d fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff8d fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff8d fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff8d fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff8d fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff8d fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff8d fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff8d fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff8d fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff8d fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff8d fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff8d fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y24d2 ff8b fs2 fc0 sc0 ls13 wsb">(2) &lt;html&gt; </div><div class="t m0 x0 h5 y24d3 ff8b fs2 fc0 sc0 ls5a ws4f">(3) &lt;body&gt; </div><div class="t m0 x0 h5 y24d4 ff8b fs2 fc0 sc0 ls13 wsb">(4) &lt;div&gt; </div><div class="t m0 x0 h5 y24d5 ff92 fs2 fc0 sc0 ls8 wseb">在事件捕获过程中，document对象首先接收到click事件，然后事件沿DOM树依次向下，一直</div><div class="t m0 x0 hc y24d6 ff92 fs2 fc0 sc0 ls8 wseb">传播到事件的实际目标，即&lt;div&gt;元素。图13-2展示了事件捕获的过程。 </div><div class="t m0 x2 h5 y35e ff8b fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 h3 y24d7 ff92 fs1 fc0 sc0 ls8 wsb">图 13-2 </div><div class="t m0 x0 h5 y24d8 ff92 fs2 fc0 sc0 ls8 wseb">虽然事件捕获是Netscape Communicator唯一支持的事件流模型，但IE9、Safari、Chrome、Opera</div><div class="t m0 x0 h5 y24d9 ff92 fs2 fc0 sc0 ls71">和Firefox目前也都支持这种事件流模型。尽管“DOM2级事件”规范要求事件应该从document对象</div><div class="t m0 x0 h5 y24da ff92 fs2 fc0 sc0 ls8 wseb">开始传播，但这些浏览器都是从window对象开始捕获事件的。 </div><div class="t m0 x0 h4 y24db ff92 fs2 fc0 sc0 ls8 wseb">由于老版本的浏览器不支持，因此很少有人使用事件捕获。我们也建议读者放心地使用事件冒泡，</div><div class="t m0 x0 h5 y24dc ff92 fs2 fc0 sc0 ls8 wseb">在有特殊需要时再使用事件捕获。 </div><div class="t m0 x0 h20 y24dd ff90 fs3 fc0 sc0 ls248 ws214">13.1.3 DOM事件流 </div><div class="t m0 x0 h5 y24de ff92 fs2 fc0 sc0 ls14">“DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。首</div><div class="t m0 x0 h4 y24df ff92 fs2 fc0 sc0 ls8 wseb">先发生的是事件捕获，为截获事件提供了机会。然后是实际的目标接收到事件。最后一个阶段是冒泡阶</div><div class="t m0 x0 hc y24e0 ff92 fs2 fc0 sc0 ls8 wseb">段，可以在这个阶段对事件做出响应。以前面简单的HTML页面为例，单击&lt;div&gt;元素会按照图13-3所</div><div class="t m0 x0 h5 y24e1 ff92 fs2 fc0 sc0 ls8 wseb">示顺序触发事件。 </div><div class="t m0 x2 h5 y93e ff8b fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 h3 y24e2 ff92 fs1 fc0 sc0 ls8 wsb">图 13-3 </div><div class="t m0 x0 h5 y18a5 ff92 fs2 fc0 sc0 ls3b">在DOM事件流中，实际的目标（&lt;div&gt;元素）在捕获阶段不会接收到事件。这意味着在捕获阶段，</div><div class="t m0 x0 h1e y24e3 ff92 fs2 fc0 sc0 ls8 wseb">事件从document到&lt;html&gt;再到&lt;body&gt;后就停止了。下一个阶段是“处于目标”阶段，于是事件在&lt;div&gt;</div><div class="t m0 x0 h4 y24e4 ff92 fs2 fc0 sc0 ls8 wseb">上发生，并在事件处理（后面将会讨论这个概念）中被看成冒泡阶段的一部分。然后，冒泡阶段发生，</div><div class="t m0 x0 h5 y18a8 ff92 fs2 fc0 sc0 ls8 wseb">事件又传播回文档。 </div></div></div>
<div id="pf16e" class="pf w0 h0" data-page-no="16e"><div class="pc pc16e w0 h0"><div class="t m0 x0 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">348  第13章 事件 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff92 fs2 fc0 sc0 ls8 wseb">多数支持DOM事件流的浏览器都实现了一种特定的行为；即使“DOM2级事件”规范明确要求捕</div><div class="t m0 x0 h5 y4d ff92 fs2 fc0 sc0 ls8 wseb">获阶段不会涉及事件目标，但IE9、Safari、Chrome、Firefox和Opera 9.5及更高版本都会在捕获阶段触</div><div class="t m0 x0 h5 yd8 ff92 fs2 fc0 sc0 ls8 wseb">发事件对象上的事件。结果，就是有两个机会在目标对象上面操作事件。 </div><div class="t m0 x5 h5 y24e6 ff8b fs2 fc0 sc0 ls2a ws21">IE9、Opera、Firefox、Chrome和Safari都支持DOM事件流；IE8及更早版本不</div><div class="t m0 x0 h5 y24e7 ff8c fs2 fc0 sc0 ls8 ws14">支持DOM事件流。 </div><div class="t m0 x0 hd y24e8 ff90 fs7 fc0 sc0 ls245">13.2 事件处理程序 </div><div class="t m0 x0 h4 y24e9 ff92 fs2 fc0 sc0 ls8 wseb">事件就是用户或浏览器自身执行的某种动作。诸如click、load和mouseover，都是事件的名字。</div><div class="t m0 x0 h1e y24ea ff92 fs2 fc0 sc0 ls8 wseb">而响应某个事件的函数就叫做事件处理程序（或事件侦听器）。事件处理程序的名字以&quot;on&quot;开头，因此</div><div class="t m0 x0 h4 y24eb ff96 fs1 fc0 sc0 ls9 ws2">click事件的事件处理程序就是onclick，load事件的事件处理程序就是onload。为事件指定处理</div><div class="t m0 x0 h5 y24ec ff92 fs2 fc0 sc0 ls8 wseb">程序的方式有好几种。 </div><div class="t m0 x0 h20 y24ed ff90 fs3 fc0 sc0 ls248 ws214">13.2.1 HTML事件处理程序 </div><div class="t m0 x0 h5 y19c2 ff92 fs2 fc0 sc0 ls8 wseb">某个元素支持的每种事件，都可以使用一个与相应事件处理程序同名的HTML特性来指定。这个</div><div class="t m0 x0 h5 y19c3 ff92 fs2 fc0 sc0 ls8 wseb">特性的值应该是能够执行的JavaScript代码。例如，要在按钮被单击时执行一些JavaScript，可以像下面</div><div class="t m0 x0 h5 y24ee ff92 fs2 fc0 sc0 ls8 wseb">这样编写代码： </div><div class="t m0 x0 hb y24ef ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y24f0 ff96 fs6 fc0 sc0 ls21 wsb">&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;alert(&apos;Clicked&apos;)&quot; /&gt; </div><div class="t m0 x0 hb y24f1 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 ydfe ff92 fs2 fc0 sc0 ls8 wseb">当单击这个按钮时，就会显示一个警告框。这个操作是通过指定onclick特性并将一些JavaScript</div><div class="t m0 x0 h5 y24f2 ff92 fs2 fc0 sc0 ls8 wseb">代码作为它的值来定义的。由于这个值是JavaScript，因此不能在其中使用未经转义的HTML语法字符，</div><div class="t m0 x0 h5 y24f3 ff92 fs2 fc0 sc0 ls8 wseb">例如和号（&amp;）、双引号（&quot;&quot;）、小于号（&lt;）或大于号（&gt;）。为了避免使用 HTML实体，这里使用了单</div><div class="t m0 x0 h5 y24f4 ff92 fs2 fc0 sc0 ls8 wseb">引号。如果想要使用双引号，那么就要将代码改写成如下所示： </div><div class="t m0 x0 hb y1046 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y24f5 ff96 fs6 fc0 sc0 ls21 wsb">&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;alert(&amp;quot;Clicked&amp;quot;)&quot; /&gt; </div><div class="t m0 x0 hb y24f6 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y910 ff92 fs2 fc0 sc0 lsd0">在HTML中定义的事件处理程序可以包含要执行的具体动作，也可以调用在页面其他地方定义的</div><div class="t m0 x0 h5 y911 ff92 fs2 fc0 sc0 ls8 wseb">脚本，如下面的例子所示： </div><div class="t m0 x0 hb y24f7 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y24f8 ff96 fs6 fc0 sc0 ls21 wsb">&lt;script type=&quot;text/javascript&quot;&gt; </div><div class="t m0 x0 hb y24f9 ff96 fs6 fc0 sc0 ls21 wsb">    function showMessage(){     </div><div class="t m0 x0 hb y24fa ff96 fs6 fc0 sc0 ls21 wsb">        alert(&quot;Hello world!&quot;); </div><div class="t m0 x0 hb y24fb ff96 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y24fc ff96 fs6 fc0 sc0 ls21 wsb">&lt;/script&gt; </div><div class="t m0 x0 hb y24fd ff96 fs6 fc0 sc0 ls21 wsb">&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;showMessage()&quot; /&gt; </div><div class="t m0 x0 hb y24fe ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf y24ff ff97 fs2 fc0 sc0 ls1b wsb">HTMLEventHandlerExample01.htm </div><div class="t m0 x0 h4 y11a9 ff92 fs2 fc0 sc0 ls8 wseb">在这个例子中，单击按钮就会调用showMessage()函数。这个函数是在一个独立的&lt;script&gt;元素</div><div class="t m0 x0 h4 y11aa ff92 fs2 fc0 sc0 ls8 wseb">中定义的，当然也可以被包含在一个外部文件中。事件处理程序中的代码在执行时，有权访问全局作用</div><div class="t m0 x0 h5 y11ab ff92 fs2 fc0 sc0 ls8 wseb">域中的任何代码。 </div><div class="t m0 x0 h4 y2500 ff92 fs2 fc0 sc0 ls8 wseb">这样指定事件处理程序具有一些独到之处。首先，这样会创建一个封装着元素属性值的函数。这个</div><div class="t m0 x0 h14 y2501 ff92 fs2 fc0 sc0 ls8 wseb">函数中有一个局部变量event，也就是事件对象（本章稍后讨论）： </div></div></div>
<div id="pf16f" class="pf w0 h0" data-page-no="16f"><div class="pc pc16f w0 h0"><div class="t m0 x2 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">13.2 事件处理程序    349 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff8d fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff8d fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff8d fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff8d fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff8d fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff8d fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff8d fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff8d fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff8d fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff8d fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff8d fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff8d fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff8d fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h16 y79 ff96 fs6 fc0 sc0 ls21 wsb">&lt;!-- 输出 &quot;click&quot; --&gt; </div><div class="t m0 x0 hb y7a ff96 fs6 fc0 sc0 ls21 wsb">&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;alert(event.type)&quot;&gt; </div><div class="t m0 x0 h5 y133b ff8b fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hcd y2502 ff92 fs2 fc0 sc0 ls8 wseb">通过event变量，可以直接访问事件对象，你不用自己定义它，也不用从函数的参数列表中读取。 </div><div class="t m0 x0 h5 y2503 ff92 fs2 fc0 sc0 ls8 wseb">在这个函数内部，this值等于事件的目标元素，例如： </div><div class="t m0 x0 hb y2504 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2505 ff96 fs6 fc0 sc0 ls21 wsb">&lt;!-- 输出 &quot;Click Me&quot; --&gt; </div><div class="t m0 x0 hb y2506 ff96 fs6 fc0 sc0 ls21 wsb">&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;alert(this.value)&quot;&gt; </div><div class="t m0 x0 h5 y2507 ff8b fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y2508 ff92 fs2 fc0 sc0 ls8 wseb">关于这个动态创建的函数，另一个有意思的地方是它扩展作用域的方式。在这个函数内部，可以像</div><div class="t m0 x0 hcd y2509 ff92 fs2 fc0 sc0 ls8 wseb">访问局部变量一样访问document及该元素本身的成员。这个函数使用with像下面这样扩展作用域： </div><div class="t m0 x0 hb y250a ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y250b ff96 fs6 fc0 sc0 ls21 wsb">function(){ </div><div class="t m0 x0 hb y250c ff96 fs6 fc0 sc0 ls21 wsb">    with(document){ </div><div class="t m0 x0 hb y250d ff96 fs6 fc0 sc0 ls21 wsb">        with(this){ </div><div class="t m0 x0 h16 y250e ff96 fs6 fc0 sc0 ls21 wsb">            //元素属性值 </div><div class="t m0 x0 hb y250f ff96 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y2510 ff96 fs6 fc0 sc0 ls21 wsb">    }  </div><div class="t m0 x0 hb y2511 ff96 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 h5 y2512 ff8b fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y2513 ff92 fs2 fc0 sc0 ls8 wseb">如此一来，事件处理程序要访问自己的属性就简单多了。下面这行代码与前面的例子效果相同： </div><div class="t m0 x0 hb y2514 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2515 ff96 fs6 fc0 sc0 ls21 wsb">&lt;!-- 输出 &quot;Click Me&quot; --&gt; </div><div class="t m0 x0 hb y2516 ff96 fs6 fc0 sc0 ls21 wsb">&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;alert(value)&quot;&gt; </div><div class="t m0 x0 hb y2517 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1c3e ff92 fs2 fc0 sc0 ls8 wseb">如果当前元素是一个表单输入元素，则作用域中还会包含访问表单元素（父元素）的入口，这个函</div><div class="t m0 x0 h5 y2518 ff92 fs2 fc0 sc0 ls8 wseb">数就变成了如下所示： </div><div class="t m0 x0 hb y2519 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y251a ff96 fs6 fc0 sc0 ls21 wsb">function(){ </div><div class="t m0 x0 hb y251b ff96 fs6 fc0 sc0 ls21 wsb">    with(document){  </div><div class="t m0 x0 hb y251c ff96 fs6 fc0 sc0 ls21 wsb">        with(this.form){ </div><div class="t m0 x0 hb y251d ff96 fs6 fc0 sc0 ls21 wsb">            with(this){ </div><div class="t m0 x0 h16 y251e ff96 fs6 fc0 sc0 ls21 wsb">                //元素属性值 </div><div class="t m0 x0 hb y251f ff96 fs6 fc0 sc0 ls21 wsb">            } </div><div class="t m0 x0 hb y2520 ff96 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y2521 ff96 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y2522 ff96 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y2523 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y85e ff92 fs2 fc0 sc0 ls8 wseb">实际上，这样扩展作用域的方式，无非就是想让事件处理程序无需引用表单元素就能访问其他表单</div><div class="t m0 x0 h5 y2524 ff92 fs2 fc0 sc0 ls8 wseb">字段。例如： </div><div class="t m0 x0 hb y196b ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2525 ff96 fs6 fc0 sc0 ls21 wsb">&lt;form method=&quot;post&quot;&gt; </div><div class="t m0 x0 hb y2526 ff96 fs6 fc0 sc0 ls21 wsb">    &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;&quot;&gt; </div><div class="t m0 x0 hb y2527 ff96 fs6 fc0 sc0 ls21 wsb">    &lt;input type=&quot;button&quot; value=&quot;Echo Username&quot; onclick=&quot;alert(username.value)&quot;&gt; </div><div class="t m0 x0 hb y2528 ff96 fs6 fc0 sc0 ls21 wsb">&lt;/form&gt;  </div><div class="t m0 x0 hb y2529 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y940 ff97 fs2 fc0 sc0 ls1b wsb">HTMLEventHandlerExample04.htm </div><div class="t m0 x0 h5 y252a ff92 fs2 fc0 sc0 ls8 wseb">在这个例子中，单击按钮会显示文本框中的文本。值得注意的是，这里直接引用了username元素。 </div><div class="t m0 x0 h5 y252b ff92 fs2 fc0 sc0 ls8 wseb">不过，在HTML中指定事件处理程序有两个缺点。首先，存在一个时差问题。因为用户可能会在</div><div class="t m0 x0 h5 y252c ff8b fs2 fc0 sc0 lsfa wsc9">HTML元素一出现在页面上就触发相应的事件，但当时的事件处理程序有可能尚不具备执行条件。以前</div></div></div>
<div id="pf170" class="pf w0 h0" data-page-no="170"><div class="pc pc170 w0 h0"><div class="t m0 x0 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">350  第13章 事件 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ff92 fs2 fc0 sc0 ls8 wseb">面的例子来说明，假设showMessage()函数是在按钮下方、页面的最底部定义的。如果用户在页面解</div><div class="t m0 x0 hc y4d ff92 fs2 fc0 sc0 lsda">析showMessage()函数之前就单击了按钮，就会引发错误。为此，很多HTML事件处理程序都会被封</div><div class="t m0 x0 hc y5 ff92 fs2 fc0 sc0 ls8 wseb">装在一个try-catch块中，以便错误不会浮出水面，如下面的例子所示： </div><div class="t m0 x0 hb y6bd ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y6be ff96 fs6 fc0 sc0 ls21 wsb">&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;try{showMessage();}catch(ex){}&quot;&gt; </div><div class="t m0 x0 hb y153b ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y6e5 ff92 fs2 fc0 sc0 ls8 wseb">这样，如果在showMessage()函数有定义之前单击了按钮，用户将不会看到JavaScript错误，因为</div><div class="t m0 x0 h5 y1727 ff92 fs2 fc0 sc0 ls8 wseb">在浏览器有机会处理错误之前，错误就被捕获了。 </div><div class="t m0 x0 h5 y1728 ff92 fs2 fc0 sc0 ls8 wseb">另一个缺点是，这样扩展事件处理程序的作用域链在不同浏览器中会导致不同结果。不同JavaScript</div><div class="t m0 x0 h5 y252e ff92 fs2 fc0 sc0 ls8 wseb">引擎遵循的标识符解析规则略有差异，很可能会在访问非限定对象成员时出错。 </div><div class="t m0 x0 h5 y252f ff92 fs2 fc0 sc0 ls8 wseb">通过HTML指定事件处理程序的最后一个缺点是HTML与JavaScript代码紧密耦合。如果要更换事</div><div class="t m0 x0 h5 y2530 ff92 fs2 fc0 sc0 ls8 wseb">件处理程序，就要改动两个地方：HTML代码和JavaScript代码。而这正是许多开发人员摒弃HTML事</div><div class="t m0 x0 h5 y2531 ff92 fs2 fc0 sc0 ls8 wseb">件处理程序，转而使用JavaScript指定事件处理程序的原因所在。 </div><div class="t m0 x5 h5 y2532 ff8c fs2 fc0 sc0 ls8 ws14">要了解关于HTML事件处理程序缺点的更多信息，请参考Garrett Smith的文章</div><div class="t m0 x0 h5 y2533 ff8c fs2 fc0 sc0 ls8">“Event Handler Scope”（www.jibbering.com/faq/names/event_handler.html）。 </div><div class="t m0 x0 h20 y2534 ff90 fs3 fc0 sc0 ls248 ws214">13.2.2 DOM0级事件处理程序 </div><div class="t m0 x0 h5 y791 ff92 fs2 fc0 sc0 ls8 wseb">通过JavaScript指定事件处理程序的传统方式，就是将一个函数赋值给一个事件处理程序属性。这</div><div class="t m0 x0 h5 y792 ff92 fs2 fc0 sc0 ls8 wseb">种为事件处理程序赋值的方法是在第四代Web浏览器中出现的，而且至今仍然为所有现代浏览器所支</div><div class="t m0 x0 h5 yb29 ff92 fs2 fc0 sc0 ls8 wseb">持。原因一是简单，二是具有跨浏览器的优势。要使用JavaScript指定事件处理程序，首先必须取得一</div><div class="t m0 x0 h5 y2535 ff92 fs2 fc0 sc0 ls8 wseb">个要操作的对象的引用。 </div><div class="t m0 x0 h4b y2536 ff92 fs2 fc0 sc0 ls8 wseb">每个元素（包括window和document）都有自己的事件处理程序属性，这些属性通常全部小写，</div><div class="t m0 x0 h5 y2537 ff92 fs2 fc0 sc0 ls8 wseb">例如onclick。将这种属性的值设置为一个函数，就可以指定事件处理程序，如下所示： </div><div class="t m0 x0 hb y229a ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2538 ff96 fs6 fc0 sc0 ls21 wsb">var btn = document.getElementById(&quot;myBtn&quot;); </div><div class="t m0 x0 hb y2539 ff96 fs6 fc0 sc0 ls21 wsb">btn.onclick = function(){ </div><div class="t m0 x0 hb y253a ff96 fs6 fc0 sc0 ls21 wsb">    alert(&quot;Clicked&quot;); </div><div class="t m0 x0 hb y253b ff96 fs6 fc0 sc0 ls21 wsb">};  </div><div class="t m0 x0 h4 y253c ff92 fs2 fc0 sc0 ls8 wseb">在此，我们通过文档对象取得了一个按钮的引用，然后为它指定了onclick事件处理程序。但要</div><div class="t m0 x0 h4 y253d ff92 fs2 fc0 sc0 ls8 wseb">注意，在这些代码运行以前不会指定事件处理程序，因此如果这些代码在页面中位于按钮后面，就有可</div><div class="t m0 x0 h5 y253e ff92 fs2 fc0 sc0 ls8 wseb">能在一段时间内怎么单击都没有反应。 </div><div class="t m0 x0 h5 y253f ff92 fs2 fc0 sc0 ls8 wseb">使用DOM0级方法指定的事件处理程序被认为是元素的方法。因此，这时候的事件处理程序是在</div><div class="t m0 x0 h14 y2540 ff92 fs2 fc0 sc0 ls8 wseb">元素的作用域中运行；换句话说，程序中的this引用当前元素。来看一个例子。 </div><div class="t m0 x0 hb y2541 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2542 ff96 fs6 fc0 sc0 ls21 wsb">var btn = document.getElementById(&quot;myBtn&quot;); </div><div class="t m0 x0 hb y2543 ff96 fs6 fc0 sc0 ls21 wsb">btn.onclick = function(){ </div><div class="t m0 x0 h15 y2544 ff99 fs6 fc0 sc0 ls21 wsb">    alert(this.id);    //&quot;myBtn&quot; </div><div class="t m0 x0 hb y2545 ff96 fs6 fc0 sc0 ls21 wsb">};  </div><div class="t m0 x4 hf y2546 ff97 fs2 fc0 sc0 ls1b wsb">DOMLevel0EventHandlerExample01.htm </div><div class="t m0 x0 h5 y2547 ff92 fs2 fc0 sc0 ls8 wseb">单击按钮显示的是元素的ID，这个ID是通过this.id 取得的。不仅仅是ID，实际上可以在事件</div><div class="t m0 x0 hcf y231f ff92 fs2 fc0 sc0 ls8 wseb">处理程序中通过this访问元素的任何属性和方法。以这种方式添加的事件处理程序会在事件流的冒泡</div></div></div>
<div id="pf171" class="pf w0 h0" data-page-no="171"><div class="pc pc171 w0 h0"><div class="t m0 x2 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">13.2 事件处理程序    351 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff8d fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff8d fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff8d fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff8d fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff8d fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff8d fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff8d fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff8d fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff8d fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff8d fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff8d fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff8d fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff8d fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff92 fs2 fc0 sc0 ls8 wseb">阶段被处理。 </div><div class="t m0 x0 h5 y4d ff92 fs2 fc0 sc0 ls8 wseb">也可以删除通过DOM0级方法指定的事件处理程序，只要像下面这样将事件处理程序属性的值设</div><div class="t m0 x0 he yd8 ff92 fs2 fc0 sc0 ls8 wseb">置为null即可： </div><div class="t m0 x5 hb y6bd ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y6be ff96 fs6 fc0 sc0 ls21 wsb">btn.onclick = null;     //删除事件处理程序 </div><div class="t m0 x5 hb y153b ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y6e5 ff92 fs2 fc0 sc0 ls8 wseb">将事件处理程序设置为null之后，再单击按钮将不会有任何动作发生。 </div><div class="t m0 x5 h5 y2548 ff8c fs2 fc0 sc0 ls8 ws14">如果你使用HTML指定事件处理程序，那么onclick属性的值就是一个包含着</div><div class="t m0 x5 h5 y2549 ff8c fs2 fc0 sc0 ls8 ws14">在同名HTML特性中指定的代码的函数。而将相应的属性设置为null，也可以删除</div><div class="t m0 x5 h5 y254a ff8c fs2 fc0 sc0 ls8 ws14">以这种方式指定的事件处理程序。 </div><div class="t m0 x0 h20 y254b ff90 fs3 fc0 sc0 ls248 ws214">13.2.3 DOM2级事件处理程序 </div><div class="t m0 x0 h5 y254c ff92 fs2 fc0 sc0 ls8 wseb">“DOM2级事件”定义了两个方法，用于处理指定和删除事件处理程序的操作：addEventListener()</div><div class="t m0 x0 h5 y254d ff92 fs2 fc0 sc0 ls2c">和removeEventListener()。所有DOM节点中都包含这两个方法，并且它们都接受3个参数：要处</div><div class="t m0 x0 h4 y4a ff92 fs2 fc0 sc0 ls8 wseb">理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是true，表示在捕获</div><div class="t m0 x0 hc y254e ff92 fs2 fc0 sc0 ls8 wseb">阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。 </div><div class="t m0 x0 hc y20b8 ff92 fs2 fc0 sc0 ls8 wseb">要在按钮上为click事件添加事件处理程序，可以使用下列代码： </div><div class="t m0 x5 hb y254f ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2550 ff96 fs6 fc0 sc0 ls21 wsb">var btn = document.getElementById(&quot;myBtn&quot;); </div><div class="t m0 x0 h15 y2551 ff99 fs6 fc0 sc0 ls21 wsb">btn.addEventListener(&quot;click&quot;, function(){ </div><div class="t m0 x0 h15 y2552 ff99 fs6 fc0 sc0 ls21 wsb">    alert(this.id); </div><div class="t m0 x0 h15 y2553 ff99 fs6 fc0 sc0 ls21 wsb">}, false); </div><div class="t m0 x5 hb y2554 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y2555 ff92 fs2 fc0 sc0 ls8 wseb">上面的代码为一个按钮添加了onclick事件处理程序，而且该事件会在冒泡阶段被触发（因为最</div><div class="t m0 x0 hc y2556 ff92 fs2 fc0 sc0 ls8 wseb">后一个参数是false）。与DOM0级方法一样，这里添加的事件处理程序也是在其依附的元素的作用域</div><div class="t m0 x0 h5 y2557 ff92 fs2 fc0 sc0 ls8 wseb">中运行。使用DOM2级方法添加事件处理程序的主要好处是可以添加多个事件处理程序。来看下面的</div><div class="t m0 x0 h5 y2558 ff92 fs2 fc0 sc0 ls8">例子。 </div><div class="t m0 x5 hb y2559 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y255a ff96 fs6 fc0 sc0 ls21 wsb">var btn = document.getElementById(&quot;myBtn&quot;); </div><div class="t m0 x0 hb y255b ff96 fs6 fc0 sc0 ls21 wsb">btn.addEventListener(&quot;click&quot;, function(){ </div><div class="t m0 x0 hb y255c ff96 fs6 fc0 sc0 ls21 wsb">    alert(this.id); </div><div class="t m0 x0 hb y255d ff96 fs6 fc0 sc0 ls21 wsb">}, false); </div><div class="t m0 x0 h15 y255e ff99 fs6 fc0 sc0 ls21 wsb">btn.addEventListener(&quot;click&quot;, function(){ </div><div class="t m0 x0 h15 y255f ff99 fs6 fc0 sc0 ls21 wsb">    alert(&quot;Hello world!&quot;); </div><div class="t m0 x0 h15 y2560 ff99 fs6 fc0 sc0 ls21 wsb">}, false); </div><div class="t m0 x5 hb y2561 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf y40 ff97 fs2 fc0 sc0 ls1b wsb">DOMLevel2EventHandlerExample01.htm </div><div class="t m0 x0 h4 ydbd ff92 fs2 fc0 sc0 ls8 wseb">这里为按钮添加了两个事件处理程序。这两个事件处理程序会按照添加它们的顺序触发，因此首先</div><div class="t m0 x0 h5 y2562 ff92 fs2 fc0 sc0 ls8 wseb">会显示元素的ID，其次会显示&quot;Hello world!&quot;消息。 </div><div class="t m0 x0 h1e y2563 ff92 fs2 fc0 sc0 ls8 wseb">通过addEventListener()添加的事件处理程序只能使用removeEventListener()来移除；移</div><div class="t m0 x0 h1e y2564 ff92 fs2 fc0 sc0 ls8 wseb">除时传入的参数与添加处理程序时使用的参数相同。这也意味着通过addEventListener()添加的匿</div><div class="t m0 x0 h5 y2565 ff92 fs2 fc0 sc0 ls8 wseb">名函数将无法移除，如下面的例子所示。 </div><div class="t m0 x5 hb y1a68 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2566 ff96 fs6 fc0 sc0 ls21 wsb">var btn = document.getElementById(&quot;myBtn&quot;); </div><div class="t m0 x0 hb y2567 ff96 fs6 fc0 sc0 ls21 wsb">btn.addEventListener(&quot;click&quot;, function(){ </div><div class="t m0 x0 hb y2568 ff96 fs6 fc0 sc0 ls21 wsb">    alert(this.id); </div></div></div>
<div id="pf172" class="pf w0 h0" data-page-no="172"><div class="pc pc172 w0 h0"><div class="t m0 x0 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">352  第13章 事件 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y12e1 ff96 fs6 fc0 sc0 ls21 wsb">}, false); </div><div class="t m0 x0 hb y12e2 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y256a ff99 fs6 fc0 sc0 ls21 ws34">//这里省略了其他代码 </div><div class="t m0 x0 h15 y256b ff99 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y256c ff99 fs6 fc0 sc0 ls21 wsb">btn.removeEventListener(&quot;click&quot;, function(){ //没有用！ </div><div class="t m0 x0 h15 y256d ff99 fs6 fc0 sc0 ls21 wsb">    alert(this.id); </div><div class="t m0 x0 h15 y256e ff99 fs6 fc0 sc0 ls21 wsb">}, false); </div><div class="t m0 x0 hb y256f ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y2570 ff92 fs2 fc0 sc0 ls24 wsf5">在这个例子中，我们使用addEventListener()添加了一个事件处理程序。虽然调用remove- </div><div class="t m0 x0 h42 y2571 ff96 fs1 fc0 sc0 ls9 ws2">EventListener()时看似使用了相同的参数，但实际上，第二个参数与传入addEventListener()中</div><div class="t m0 x0 h4 y2572 ff92 fs2 fc0 sc0 ls4 ws10d">的那一个是完全不同的函数。而传入removeEventListener()中的事件处理程序函数必须与传入</div><div class="t m0 x0 h5 y2573 ff96 fs1 fc0 sc0 ls9 ws2">addEventListener()中的相同，如下面的例子所示。 </div><div class="t m0 x0 hb y2574 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2575 ff96 fs6 fc0 sc0 ls21 wsb">var btn = document.getElementById(&quot;myBtn&quot;); </div><div class="t m0 x0 h15 y2576 ff99 fs6 fc0 sc0 ls21 wsb">var handler = function(){ </div><div class="t m0 x0 h15 y2577 ff99 fs6 fc0 sc0 ls21 wsb">    alert(this.id); </div><div class="t m0 x0 h15 y2578 ff99 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 h15 y2579 ff99 fs6 fc0 sc0 ls21 wsb">btn.addEventListener(&quot;click&quot;, handler, false); </div><div class="t m0 x0 h15 y257a ff99 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y257b ff99 fs6 fc0 sc0 ls21 ws34">//这里省略了其他代码 </div><div class="t m0 x0 h15 y257c ff99 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y257d ff99 fs6 fc0 sc0 ls21 wsb">btn.removeEventListener(&quot;click&quot;, handler, false); //有效！ </div><div class="t m0 x0 hb y257e ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf y257f ff97 fs2 fc0 sc0 ls1b wsb">DOMLevel2EventHandlerExample01.htm </div><div class="t m0 x0 h4 y2580 ff92 fs2 fc0 sc0 ls8 wseb">重写后的这个例子没有问题，是因为在addEventListener()和removeEventListener()中使</div><div class="t m0 x0 h5 y2581 ff92 fs2 fc0 sc0 ls8 wseb">用了相同的函数。 </div><div class="t m0 x0 h4 y1152 ff92 fs2 fc0 sc0 ls8 wseb">大多数情况下，都是将事件处理程序添加到事件流的冒泡阶段，这样可以最大限度地兼容各种浏览</div><div class="t m0 x0 h4 y1153 ff92 fs2 fc0 sc0 ls8 wseb">器。最好只在需要在事件到达目标之前截获它的时候将事件处理程序添加到捕获阶段。如果不是特别需</div><div class="t m0 x0 h5 y2582 ff92 fs2 fc0 sc0 ls8 wseb">要，我们不建议在事件捕获阶段注册事件处理程序。 </div><div class="t m0 x5 h5 y2583 ff8b fs2 fc0 sc0 ls2a ws21">IE9、Firefox、Safari、Chrome和Opera支持DOM2级事件处理程序。 </div><div class="t m0 x0 h20 y2584 ff90 fs3 fc0 sc0 ls248 ws214">13.2.4 IE事件处理程序 </div><div class="t m0 x0 h5 y1a98 ff8b fs2 fc0 sc0 lse ws9">IE实现了与DOM中类似的两个方法：attachEvent()和detachEvent()。这两个方法接受相同</div><div class="t m0 x0 h5 y2585 ff92 fs2 fc0 sc0 ls44 wsef">的两个参数：事件处理程序名称与事件处理程序函数。由于IE8及更早版本只支持事件冒泡，所以通过</div><div class="t m0 x0 h5 y2586 ff96 fs1 fc0 sc0 ls20 ws16">attachEvent()添加的事件处理程序都会被添加到冒泡阶段。 </div><div class="t m0 x0 hc y2587 ff92 fs2 fc0 sc0 ls8 wseb">要使用attachEvent()为按钮添加一个事件处理程序，可以使用以下代码。 </div><div class="t m0 x0 hb y2588 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2589 ff96 fs6 fc0 sc0 ls21 wsb">var btn = document.getElementById(&quot;myBtn&quot;); </div><div class="t m0 x0 h15 y258a ff99 fs6 fc0 sc0 ls21 wsb">btn.attachEvent(&quot;onclick&quot;, function(){ </div><div class="t m0 x0 h15 y258b ff99 fs6 fc0 sc0 ls21 wsb">    alert(&quot;Clicked&quot;); </div><div class="t m0 x0 h15 y258c ff99 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 hb y258d ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf ycb7 ff97 fs2 fc0 sc0 ls79 wsb">IEEventHandlerExample01.htm </div><div class="t m0 x0 h5 y2354 ff92 fs2 fc0 sc0 ls8 wseb">注意，attachEvent()的第一个参数是&quot;onclick&quot;，而非DOM的addEventListener()方法中</div><div class="t m0 x0 h5 y126c ff92 fs2 fc0 sc0 ls8 wseb">的&quot;click&quot;。 </div></div></div>
<div id="pf173" class="pf w0 h0" data-page-no="173"><div class="pc pc173 w0 h0"><div class="t m0 x2 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">13.2 事件处理程序    353 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff8d fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff8d fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff8d fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff8d fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff8d fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff8d fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff8d fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff8d fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff8d fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff8d fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff8d fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff8d fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff8d fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff92 fs2 fc0 sc0 lsdc">在IE中使用attachEvent()与使用DOM0级方法的主要区别在于事件处理程序的作用域。在使</div><div class="t m0 x0 h5 y4d ff92 fs2 fc0 sc0 ls3b">用DOM0级方法的情况下，事件处理程序会在其所属元素的作用域内运行；在使用attachEvent()方</div><div class="t m0 x0 hc y5 ff92 fs2 fc0 sc0 ls8 wseb">法的情况下，事件处理程序会在全局作用域中运行，因此this等于window。来看下面的例子。 </div><div class="t m0 x5 hb y258e ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y258f ff96 fs6 fc0 sc0 ls21 wsb">var btn = document.getElementById(&quot;myBtn&quot;); </div><div class="t m0 x0 hb y2590 ff96 fs6 fc0 sc0 ls21 wsb">btn.attachEvent(&quot;onclick&quot;, function(){ </div><div class="t m0 x0 h15 y2591 ff99 fs6 fc0 sc0 ls21 wsb">    alert(this === window);  //true </div><div class="t m0 x0 hb y2592 ff96 fs6 fc0 sc0 ls21 wsb">});  </div><div class="t m0 x0 h5 y2593 ff92 fs2 fc0 sc0 ls8 wseb">在编写跨浏览器的代码时，牢记这一区别非常重要。 </div><div class="t m0 x0 h1e y2064 ff92 fs2 fc0 sc0 ls2c">与addEventListener()类似，attachEvent()方法也可以用来为一个元素添加多个事件处理程</div><div class="t m0 x0 h5 ya87 ff92 fs2 fc0 sc0 ls8 wseb">序。来看下面的例子。 </div><div class="t m0 x5 hb y5a2 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2594 ff96 fs6 fc0 sc0 ls21 wsb">var btn = document.getElementById(&quot;myBtn&quot;); </div><div class="t m0 x0 hb y2595 ff96 fs6 fc0 sc0 ls21 wsb">btn.attachEvent(&quot;onclick&quot;, function(){ </div><div class="t m0 x0 hb y2596 ff96 fs6 fc0 sc0 ls21 wsb">    alert(&quot;Clicked&quot;); </div><div class="t m0 x0 hb y2597 ff96 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 h15 y2598 ff99 fs6 fc0 sc0 ls21 wsb">btn.attachEvent(&quot;onclick&quot;, function(){ </div><div class="t m0 x0 h15 y2599 ff99 fs6 fc0 sc0 ls21 wsb">    alert(&quot;Hello world!&quot;); </div><div class="t m0 x0 h15 y259a ff99 fs6 fc0 sc0 ls21 wsb">});  </div><div class="t m0 x2 hf y259b ff97 fs2 fc0 sc0 ls79 wsb">IEEventHandlerExample01.htm </div><div class="t m0 x0 h5 y259c ff92 fs2 fc0 sc0 ls8 wseb">这里调用了两次attachEvent()，为同一个按钮添加了两个不同的事件处理程序。不过，与DOM</div><div class="t m0 x0 h4 y259d ff92 fs2 fc0 sc0 ls8 wseb">方法不同的是，这些事件处理程序不是以添加它们的顺序执行，而是以相反的顺序被触发。单击这个例</div><div class="t m0 x0 he y259e ff92 fs2 fc0 sc0 ls8 wseb">子中的按钮，首先看到的是&quot;Hello world!&quot;，然后才是&quot;Clicked&quot;。 </div><div class="t m0 x0 h4 y1f88 ff92 fs2 fc0 sc0 ls8 wseb">使用attachEvent()添加的事件可以通过detachEvent()来移除，条件是必须提供相同的参数。</div><div class="t m0 x0 h5 y1f89 ff92 fs2 fc0 sc0 ls3b">与DOM方法一样，这也意味着添加的匿名函数将不能被移除。不过，只要能够将对相同函数的引用传</div><div class="t m0 x0 he y1f8a ff92 fs2 fc0 sc0 ls2d8">给detachEvent()，就可以移除相应的事件处理程序。例如： </div><div class="t m0 x5 hb y1fee ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y259f ff96 fs6 fc0 sc0 ls21 wsb">var btn = document.getElementById(&quot;myBtn&quot;); </div><div class="t m0 x0 h15 y25a0 ff99 fs6 fc0 sc0 ls21 wsb">var handler = function(){ </div><div class="t m0 x0 h15 y25a1 ff99 fs6 fc0 sc0 ls21 wsb">    alert(&quot;Clicked&quot;); </div><div class="t m0 x0 h15 y25a2 ff99 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 h15 y25a3 ff99 fs6 fc0 sc0 ls21 wsb">btn.attachEvent(&quot;onclick&quot;, handler); </div><div class="t m0 x0 h15 y25a4 ff99 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y25a5 ff99 fs6 fc0 sc0 ls21 ws34">//这里省略了其他代码 </div><div class="t m0 x0 h15 y25a6 ff99 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y25a7 ff99 fs6 fc0 sc0 ls21 wsb">btn.detachEvent(&quot;onclick&quot;, handler); </div><div class="t m0 x0 h15 y25a8 ff99 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y171a ff97 fs2 fc0 sc0 ls79 wsb">IEEventHandlerExample02.htm </div><div class="t m0 x0 h4 y347 ff92 fs2 fc0 sc0 ls8 wseb">这个例子将保存在变量handler中的函数作为事件处理程序。因此，后面的detachEvent()可以</div><div class="t m0 x0 h5 y25a9 ff92 fs2 fc0 sc0 ls8 wseb">使用相同的函数来移除事件处理程序。 </div><div class="t m0 x5 h5 y25aa ff8c fs2 fc0 sc0 ls8 ws14">支持IE事件处理程序的浏览器有IE和Opera。 </div><div class="t m0 x0 h20 y25ab ff90 fs3 fc0 sc0 ls248 ws214">13.2.5 跨浏览器的事件处理程序 </div><div class="t m0 x0 h5 y7d1 ff92 fs2 fc0 sc0 ls8 wseb">为了以跨浏览器的方式处理事件，不少开发人员会使用能够隔离浏览器差异的JavaScript库，还有</div><div class="t m0 x0 h4 y25ac ff92 fs2 fc0 sc0 ls8 wseb">一些开发人员会自己开发最合适的事件处理的方法。自己编写代码其实也不难，只要恰当地使用能力检</div></div></div>
<div id="pf174" class="pf w0 h0" data-page-no="174"><div class="pc pc174 w0 h0"><div class="t m0 x0 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">354  第13章 事件 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff92 fs2 fc0 sc0 ls8 wseb">测即可（能力检测在第9章介绍过）。要保证处理事件的代码能在大多数浏览器下一致地运行，只需关</div><div class="t m0 x0 h5 y4d ff92 fs2 fc0 sc0 ls8 wseb">注冒泡阶段。 </div><div class="t m0 x0 he yd8 ff92 fs2 fc0 sc0 ls8 wseb">第一个要创建的方法是addHandler()，它的职责是视情况分别使用DOM0级方法、DOM2级方</div><div class="t m0 x0 h5 yd9 ff92 fs2 fc0 sc0 ls8 wseb">法或IE方法来添加事件。这个方法属于一个名叫EventUtil的对象，本书将使用这个对象来处理浏览</div><div class="t m0 x0 hc y15d ff92 fs2 fc0 sc0 ls8 wseb">器间的差异。addHandler()方法接受3个参数：要操作的元素、事件名称和事件处理程序函数。 </div><div class="t m0 x0 h1e y21a ff92 fs2 fc0 sc0 ls2d8">与addHandler()对应的方法是removeHandler()，它也接受相同的参数。这个方法的职责是移</div><div class="t m0 x0 h4 y15e ff92 fs2 fc0 sc0 ls8 wseb">除之前添加的事件处理程序——无论该事件处理程序是采取什么方式添加到元素中的，如果其他方法无</div><div class="t m0 x0 h5 y1561 ff92 fs2 fc0 sc0 ls8 wseb">效，默认采用DOM0级方法。 </div><div class="t m0 x0 h5 yb ff96 fs1 fc0 sc0 ls9 ws2">EventUtil的用法如下所示。 </div><div class="t m0 x0 hb y160 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y25ae ff96 fs6 fc0 sc0 ls21 wsb">var EventUtil = { </div><div class="t m0 x0 hb y25af ff96 fs6 fc0 sc0 ls21 wsb">  </div><div class="t m0 x0 hb y25b0 ff96 fs6 fc0 sc0 ls21 wsb">    addHandler: function(element, type, handler){ </div><div class="t m0 x0 hb y25b1 ff96 fs6 fc0 sc0 ls21 wsb">        if (element.addEventListener){ </div><div class="t m0 x0 hb y25b2 ff96 fs6 fc0 sc0 ls21 wsb">            element.addEventListener(type, handler, false); </div><div class="t m0 x0 hb y25b3 ff96 fs6 fc0 sc0 ls21 wsb">        } else if (element.attachEvent){ </div><div class="t m0 x0 hb y25b4 ff96 fs6 fc0 sc0 ls21 wsb">            element.attachEvent(&quot;on&quot; + type, handler); </div><div class="t m0 x0 hb y25b5 ff96 fs6 fc0 sc0 ls21 wsb">        } else { </div><div class="t m0 x0 hb y25b6 ff96 fs6 fc0 sc0 ls21 wsb">            element[&quot;on&quot; + type] = handler; </div><div class="t m0 x0 hb y25b7 ff96 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y25b8 ff96 fs6 fc0 sc0 ls21 wsb">    }, </div><div class="t m0 x0 hb y25b9 ff96 fs6 fc0 sc0 ls21 wsb">    removeHandler: function(element, type, handler){ </div><div class="t m0 x0 hb y25ba ff96 fs6 fc0 sc0 ls21 wsb">        if (element.removeEventListener){ </div><div class="t m0 x0 hb y25bb ff96 fs6 fc0 sc0 ls21 wsb">            element.removeEventListener(type, handler, false); </div><div class="t m0 x0 hb y25bc ff96 fs6 fc0 sc0 ls21 wsb">        } else if (element.detachEvent){ </div><div class="t m0 x0 hb y25bd ff96 fs6 fc0 sc0 ls21 wsb">            element.detachEvent(&quot;on&quot; + type, handler); </div><div class="t m0 x0 hb y25be ff96 fs6 fc0 sc0 ls21 wsb">        } else { </div><div class="t m0 x0 hb y25bf ff96 fs6 fc0 sc0 ls21 wsb">            element[&quot;on&quot; + type] = null; </div><div class="t m0 x0 hb y25c0 ff96 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y25c1 ff96 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y25c2 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y25c3 ff96 fs6 fc0 sc0 ls21 wsb">};     </div><div class="t m0 x0 hb y25c4 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y25c5 ff97 fs2 fc0 sc0 ls2b wsb">EventUtil.js </div><div class="t m0 x0 h5 y25c6 ff92 fs2 fc0 sc0 ls8 wseb">这两个方法首先都会检测传入的元素中是否存在DOM2级方法。如果存在DOM2级方法，则使用</div><div class="t m0 x0 hc y25c7 ff92 fs2 fc0 sc0 ls8 wseb">该方法：传入事件类型、事件处理程序函数和第三个参数false（表示冒泡阶段）。如果存在的是IE的</div><div class="t m0 x0 h5 y25c8 ff92 fs2 fc0 sc0 ls8 wseb">方法，则采取第二种方案。注意，为了在IE8及更早版本中运行，此时的事件类型必须加上&quot;on&quot;前缀。</div><div class="t m0 x0 h5 y25c9 ff92 fs2 fc0 sc0 ls8 wseb">最后一种可能就是使用DOM0级方法（在现代浏览器中，应该不会执行这里的代码）。此时，我们使用</div><div class="t m0 x0 hc y25ca ff92 fs2 fc0 sc0 ls8 wseb">的是方括号语法来将属性名指定为事件处理程序，或者将属性设置为null。 </div><div class="t m0 x0 hc y25cb ff92 fs2 fc0 sc0 ls8 wseb">可以像下面这样使用EventUtil对象： </div><div class="t m0 x0 hb y25cc ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y25cd ff96 fs6 fc0 sc0 ls21 wsb">var btn = document.getElementById(&quot;myBtn&quot;); </div><div class="t m0 x0 hb y25ce ff96 fs6 fc0 sc0 ls21 wsb">var handler = function(){ </div><div class="t m0 x0 hb y25cf ff96 fs6 fc0 sc0 ls21 wsb">    alert(&quot;Clicked&quot;); </div><div class="t m0 x0 hb y25d0 ff96 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 h15 y25d1 ff99 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(btn, &quot;click&quot;, handler);  </div><div class="t m0 x0 h15 y25d2 ff99 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y25d3 ff99 fs6 fc0 sc0 ls21 ws34">//这里省略了其他代码 </div><div class="t m0 x0 h15 y25d4 ff99 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y25d5 ff99 fs6 fc0 sc0 ls21 wsb">EventUtil.removeHandler(btn, &quot;click&quot;, handler);  </div><div class="t m0 x4 hf y25d6 ff97 fs2 fc0 sc0 ls5e wsb">CrossBrowserEventHandlerExample01.htm </div></div></div>
<div id="pf175" class="pf w0 h0" data-page-no="175"><div class="pc pc175 w0 h0"><div class="t m0 x2 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">13.3 事件对象    355 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff8d fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff8d fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff8d fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff8d fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff8d fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff8d fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff8d fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff8d fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff8d fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff8d fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff8d fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff8d fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff8d fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff96 fs1 fc0 sc0 ls16 ws17">addHandler()和removeHandler()没有考虑到所有的浏览器问题，例如在IE中的作用域问题。</div><div class="t m0 x0 h5 y4d ff92 fs2 fc0 sc0 ls5 wsec">不过，使用它们添加和移除事件处理程序还是足够了。此外还要注意，DOM0级对每个事件只支持一</div><div class="t m0 x0 h5 yd8 ff92 fs2 fc0 sc0 ls5 wsec">个事件处理程序。好在，只支持DOM0级的浏览器已经没有那么多了，因此这对你而言应该不是什么</div><div class="t m0 x0 h5 y28b ff92 fs2 fc0 sc0 ls5">问题。 </div><div class="t m0 x0 hd y8 ff90 fs7 fc0 sc0 ls245">13.3 事件对象 </div><div class="t m0 x0 h5 y1f ff92 fs2 fc0 sc0 ls8 wseb">在触发DOM上的某个事件时，会产生一个事件对象event，这个对象中包含着所有与事件有关的</div><div class="t m0 x0 h4 y8c9 ff92 fs2 fc0 sc0 ls8 wseb">信息。包括导致事件的元素、事件的类型以及其他与特定事件相关的信息。例如，鼠标操作导致的事件</div><div class="t m0 x0 h4 y25d7 ff92 fs2 fc0 sc0 ls8 wseb">对象中，会包含鼠标位置的信息，而键盘操作导致的事件对象中，会包含与按下的键有关的信息。所有</div><div class="t m0 x0 he y25d8 ff92 fs2 fc0 sc0 ls8 wseb">浏览器都支持event对象，但支持方式不同。 </div><div class="t m0 x0 h20 y25d9 ff90 fs3 fc0 sc0 ls248 ws214">13.3.1 DOM中的事件对象 </div><div class="t m0 x0 h5 y1f38 ff92 fs2 fc0 sc0 ls8 wseb">兼容DOM的浏览器会将一个event对象传入到事件处理程序中。无论指定事件处理程序时使用什</div><div class="t m0 x0 h5 y99d ff92 fs2 fc0 sc0 ls8 wseb">么方法（DOM0级或DOM2级），都会传入event对象。来看下面的例子。 </div><div class="t m0 x5 hb y25da ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y25db ff96 fs6 fc0 sc0 ls21 wsb">var btn = document.getElementById(&quot;myBtn&quot;); </div><div class="t m0 x0 h15 y25dc ff99 fs6 fc0 sc0 ls21 wsb">btn.onclick = function(event){ </div><div class="t m0 x0 h15 y25dd ff99 fs6 fc0 sc0 ls21 wsb">    alert(event.type);     //&quot;click&quot; </div><div class="t m0 x0 h15 y25de ff99 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 h15 y25df ff99 fs6 fc0 sc0 ls21 wsb">btn.addEventListener(&quot;click&quot;, function(event){ </div><div class="t m0 x0 h15 y25e0 ff99 fs6 fc0 sc0 ls21 wsb">    alert(event.type);     //&quot;click&quot; </div><div class="t m0 x0 h15 y25e1 ff99 fs6 fc0 sc0 ls21 wsb">}, false);     </div><div class="t m0 x5 hb y25e2 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1570 ff92 fs2 fc0 sc0 ls8 wseb">这个例子中的两个事件处理程序都会弹出一个警告框，显示由event.type属性表示的事件类型。</div><div class="t m0 x0 h1e y1571 ff92 fs2 fc0 sc0 ls2d9 ws2a4">这个属性始终都会包含被触发的事件类型，例如&quot;click&quot;（与传入addEventListener()和</div><div class="t m0 x0 h5 y14ae ff96 fs1 fc0 sc0 ls9 ws2">removeEventListener()中的事件类型一致）。 </div><div class="t m0 x0 hc y25e3 ff92 fs2 fc0 sc0 ls8 wseb">在通过HTML特性指定事件处理程序时，变量event中保存着event 对象。请看下面的例子。 </div><div class="t m0 x5 hb y25e4 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y25e5 ff96 fs6 fc0 sc0 ls21 wsb">&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;alert(event.type)&quot;/&gt; </div><div class="t m0 x5 hb y25e6 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y127b ff92 fs2 fc0 sc0 ls8 wseb">以这种方式提供event对象，可以让HTML特性事件处理程序与JavaScript 函数执行相同的操作。 </div><div class="t m0 x0 h4 y25e7 ff96 fs1 fc0 sc0 ls9 ws2">event对象包含与创建它的特定事件有关的属性和方法。触发的事件类型不一样，可用的属性和方</div><div class="t m0 x0 h5 y25e8 ff92 fs2 fc0 sc0 ls8 wseb">法也不一样。不过，所有事件都会有下表列出的成员。 </div><div class="t m0 x5 hb y25e9 ff96 fs6 fc0 sc0 ls8 wsb">  </div><div class="t m0 x5 h31 y25ea ff8f fs6 fc0 sc0 ls8">属性/方法 类  型 读/写 说  明 </div><div class="t m0 x0 h32 y14d8 ff96 fsc fc0 sc0 lsa8 wsb">bubbles  Boolean  只读 表明事件是否冒泡 </div><div class="t m0 x0 h32 y25eb ff96 fsc fc0 sc0 lsa8 wsb">cancelable  Boolean  只读 表明是否可以取消事件的默认行为 </div><div class="t m0 x0 h32 y25ec ff96 fsc fc0 sc0 lsa8 wsb">currentTarget  Element  只读 其事件处理程序当前正在处理事件的那个元素 </div><div class="t m0 x0 h32 y25ed ff96 fsc fc0 sc0 lsa8 wsb">defaultPrevented  Boolean  只读 为true表示已经调用了preventDefault()</div><div class="t m0 x4 h36 y25ee ff92 fs6 fc0 sc0 ls95">（DOM3级事件中新增） </div><div class="t m0 x0 h32 y22f5 ff96 fsc fc0 sc0 lsa8 wsb">detail  Integer  只读 与事件相关的细节信息 </div><div class="t m0 x0 h32 y8c3 ff96 fsc fc0 sc0 lsa8 wsb">eventPhase  Integer  只读 调用事件处理程序的阶段：1表示捕获阶段，2表</div><div class="t m0 x4 h36 y25ef ff92 fs6 fc0 sc0 ls8 ws124">示“处于目标”，3表示冒泡阶段 </div></div></div>
<div id="pf176" class="pf w0 h0" data-page-no="176"><div class="pc pc176 w0 h0"><div class="t m0 x0 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">356  第13章 事件 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x6 h3 y34f ff92 fs1 fc0 sc0 ls8">（续） </div><div class="t m0 x0 h31 y350 ff8f fs6 fc0 sc0 ls8">属性/方法 类  型 读/写 说  明 </div><div class="t m0 x0 h32 y25f0 ff96 fsc fc0 sc0 lsa8 wsb">preventDefault()  Function  只读 取消事件的默认行为。如果cancelable是</div><div class="t m0 x4 h36 y25f1 ff96 fsc fc0 sc0 lsa8 ws80">true，则可以使用这个方法 </div><div class="t m0 x0 h32 y25f2 ff96 fsc fc0 sc0 lsa8 wsb">stopImmediatePropagation()  Function  只读 取消事件的进一步捕获或冒泡，同时阻止任何</div><div class="t m0 x4 h36 y25f3 ff92 fs6 fc0 sc0 ls8 ws124">事件处理程序被调用（DOM3级事件中新增） </div><div class="t m0 x0 h32 y25f4 ff96 fsc fc0 sc0 lsa8 wsb">stopPropagation()  Function  只读 取消事件的进一步捕获或冒泡。如果bubbles</div><div class="t m0 x4 h36 y25f5 ff92 fs6 fc0 sc0 ls6c">为true，则可以使用这个方法 </div><div class="t m0 x0 h32 y1ef6 ff96 fsc fc0 sc0 lsa8 wsb">target  Element  只读 事件的目标 </div><div class="t m0 x0 h32 y25f6 ff96 fsc fc0 sc0 lsa8 wsb">trusted  Boolean  只读 为true表示事件是浏览器生成的。为false表</div><div class="t m0 x4 h36 y25f7 ff92 fs6 fc0 sc0 ls314 ws2cb">示事件是由开发人员通过JavaScript创建的</div><div class="t m0 x4 h36 y25f8 ff92 fs6 fc0 sc0 ls95">（DOM3级事件中新增） </div><div class="t m0 x0 h32 y384 ff96 fsc fc0 sc0 lsa8 wsb">type  String  只读 被触发的事件的类 型 </div><div class="t m0 x0 h32 y25f9 ff96 fsc fc0 sc0 lsa8 wsb">view  AbstractView</div><div class="c x7 y25fa w18 hbd"><div class="t m0 x0 hb y21eb ff96 fs6 fc0 sc0 ls8 wsb"> </div></div><div class="t m0 x4 h36 y25fb ff92 fs6 fc0 sc0 ls31">只读 与事件关联的抽象视图。等同于发生事件的</div><div class="t m0 x4 h36 y25fc ff96 fsc fc0 sc0 lsa8 ws80">window对象 </div><div class="t m0 x0 hb y24c6 ff96 fs6 fc0 sc0 ls8 wsb">  </div><div class="t m0 x0 h4 y25fd ff92 fs2 fc0 sc0 ls8 wseb">在事件处理程序内部，对象this始终等于currentTarget的值，而 target则只包含事件的实</div><div class="t m0 x0 h4 y20d2 ff92 fs2 fc0 sc0 ls8 wseb">际目标。如果直接将事件处理程序指定给了目标元素，则this、currentTarget和target包含相同</div><div class="t m0 x0 h5 y20d3 ff92 fs2 fc0 sc0 ls8 wseb">的值。来看下面的例子。 </div><div class="t m0 x0 hb y20d4 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y20d5 ff96 fs6 fc0 sc0 ls21 wsb">var btn = document.getElementById(&quot;myBtn&quot;); </div><div class="t m0 x0 h15 y20d6 ff99 fs6 fc0 sc0 ls21 wsb">btn.onclick = function(event){ </div><div class="t m0 x0 h15 y20d7 ff99 fs6 fc0 sc0 ls21 wsb">    alert(event.currentTarget === this);    //true </div><div class="t m0 x0 h15 y20d8 ff99 fs6 fc0 sc0 ls21 wsb">    alert(event.target === this);         //true </div><div class="t m0 x0 h15 y20d9 ff99 fs6 fc0 sc0 ls21 wsb">};  </div><div class="t m0 x2 hf y25fe ff97 fs2 fc0 sc0 ls1b wsb">DOMEventObjectExample01.htm </div><div class="t m0 x0 h4 y1d7d ff92 fs2 fc0 sc0 ls8 wseb">这个例子检测了currentTarget和target与this的值。由于click 事件的目标是按钮，因此</div><div class="t m0 x0 h1e y25ff ff92 fs2 fc0 sc0 ls8 wseb">这三个值是相等的。如果事件处理程序存在于按钮的父节点中（例如document.body），那么这些值是</div><div class="t m0 x0 h5 y2600 ff92 fs2 fc0 sc0 ls8 wseb">不相同的。再看下面的例子。 </div><div class="t m0 x0 hb y2601 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2602 ff96 fs6 fc0 sc0 ls21 wsb">document.body.onclick = function(event){ </div><div class="t m0 x0 hb y2603 ff96 fs6 fc0 sc0 ls21 wsb">    alert(event.currentTarget === document.body);   //true </div><div class="t m0 x0 hb y2604 ff96 fs6 fc0 sc0 ls21 wsb">    alert(this === document.body);                  //true </div><div class="t m0 x0 hb y2605 ff96 fs6 fc0 sc0 ls21 wsb">    alert(event.target === document.getElementById(&quot;myBtn&quot;));    //true </div><div class="t m0 x0 hb y2606 ff96 fs6 fc0 sc0 ls21 wsb">};  </div><div class="t m0 x2 hf y1c5 ff97 fs2 fc0 sc0 ls1b wsb">DOMEventObjectExample02.htm </div><div class="t m0 x0 h4 y1c6 ff92 fs2 fc0 sc0 ls8 wseb">当单击这个例子中的按钮时，this和currentTarget都等于document.body，因为事件处理程</div><div class="t m0 x0 h4 y2607 ff92 fs2 fc0 sc0 ls8 wseb">序是注册到这个元素上的。然而，target元素却等于按钮元素，因为它是click事件真正的目标。由</div><div class="t m0 x0 h1e y2608 ff92 fs2 fc0 sc0 ls8 wseb">于按钮上并没有注册事件处理程序，结果click事件就冒泡到了document.body，在那里事件才得到</div><div class="t m0 x0 h5 y2609 ff92 fs2 fc0 sc0 ls8">了处理。 </div><div class="t m0 x0 he y260a ff92 fs2 fc0 sc0 ls8 wseb">在需要通过一个函数处理多个事件时，可以使用type属性。例如： </div><div class="t m0 x0 hb ycb8 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y260b ff96 fs6 fc0 sc0 ls21 wsb">var btn = document.getElementById(&quot;myBtn&quot;); </div><div class="t m0 x0 h15 y260c ff99 fs6 fc0 sc0 ls21 wsb">var handler = function(event){ </div></div></div>
<div id="pf177" class="pf w0 h0" data-page-no="177"><div class="pc pc177 w0 h0"><div class="t m0 x2 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">13.3 事件对象    357 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff8d fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff8d fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff8d fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff8d fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff8d fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff8d fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff8d fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff8d fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff8d fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff8d fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff8d fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff8d fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff8d fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h15 y79 ff99 fs6 fc0 sc0 ls21 wsb">    switch(event.type){ </div><div class="t m0 x0 h15 y7a ff99 fs6 fc0 sc0 ls21 wsb">        case &quot;click&quot;: </div><div class="t m0 x0 h15 y7b ff99 fs6 fc0 sc0 ls21 wsb">            alert(&quot;Clicked&quot;); </div><div class="t m0 x0 h15 y7c ff99 fs6 fc0 sc0 ls21 wsb">            break; </div><div class="t m0 x0 h15 y7d ff99 fs6 fc0 sc0 ls21 wsb">             </div><div class="t m0 x0 h15 y7e ff99 fs6 fc0 sc0 ls21 wsb">        case &quot;mouseover&quot;: </div><div class="t m0 x0 h15 y7f ff99 fs6 fc0 sc0 ls21 wsb">            event.target.style.backgroundColor = &quot;red&quot;; </div><div class="t m0 x0 h15 y80 ff99 fs6 fc0 sc0 ls21 wsb">            break; </div><div class="t m0 x0 h15 y81 ff99 fs6 fc0 sc0 ls21 wsb">             </div><div class="t m0 x0 h15 y82 ff99 fs6 fc0 sc0 ls21 wsb">        case &quot;mouseout&quot;: </div><div class="t m0 x0 h15 y83 ff99 fs6 fc0 sc0 ls21 wsb">            event.target.style.backgroundColor = &quot;&quot;; </div><div class="t m0 x0 h15 y84 ff99 fs6 fc0 sc0 ls21 wsb">            break;                         </div><div class="t m0 x0 h15 y85 ff99 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 h15 y86 ff99 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 h15 y87 ff99 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y88 ff99 fs6 fc0 sc0 ls21 wsb">btn.onclick = handler; </div><div class="t m0 x0 h15 y89 ff99 fs6 fc0 sc0 ls21 wsb">btn.onmouseover = handler; </div><div class="t m0 x0 h15 y8a ff99 fs6 fc0 sc0 ls21 wsb">btn.onmouseout = handler; </div><div class="t m0 x5 hb y260d ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y260e ff97 fs2 fc0 sc0 ls1b wsb">DOMEventObjectExample03.htm </div><div class="t m0 x0 h5 yb9 ff92 fs2 fc0 sc0 ls8 wseb">这个例子定义了一个名为handler的函数，用于处理3种事件：click、mouseover和mouseout。</div><div class="t m0 x0 h4 y260f ff92 fs2 fc0 sc0 ls8 wseb">当单击按钮时，会出现一个与前面例子中一样的警告框。当按钮移动到按钮上面时，背景颜色应该会变</div><div class="t m0 x0 h4 y2610 ff92 fs2 fc0 sc0 ls24 wsf5">成红色，而当鼠标移动出按钮的范围时，背景颜色应该会恢复为默认值。这里通过检测event.type</div><div class="t m0 x0 h5 y2611 ff92 fs2 fc0 sc0 ls8 wseb">属性，让函数能够确定发生了什么事件，并执行相应的操作。 </div><div class="t m0 x0 h1e y2612 ff92 fs2 fc0 sc0 ls6 wsf7">要阻止特定事件的默认行为，可以使用preventDefault()方法。例如，链接的默认行为就是在</div><div class="t m0 x0 hc y2613 ff92 fs2 fc0 sc0 ls8 wseb">被单击时会导航到其href特性指定的 URL。如果你想阻止链接导航这一默认行为，那么通过链接的</div><div class="t m0 x0 h5 yf9a ff96 fs1 fc0 sc0 ls9 ws2">onclick事件处理程序可以取消它，如下面的例子所示。 </div><div class="t m0 x5 hb y2614 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2615 ff96 fs6 fc0 sc0 ls21 wsb">var link = document.getElementById(&quot;myLink&quot;); </div><div class="t m0 x0 hb y2616 ff96 fs6 fc0 sc0 ls21 wsb">link.onclick = function(event){ </div><div class="t m0 x0 hb y2617 ff96 fs6 fc0 sc0 ls21 wsb">    event.preventDefault(); </div><div class="t m0 x0 hb y2618 ff96 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x5 hb y2619 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y261a ff97 fs2 fc0 sc0 ls1b wsb">DOMEventObjectExample04.htm </div><div class="t m0 x0 h5 y261b ff92 fs2 fc0 sc0 ls8 wseb">只有cancelable属性设置为true的事件，才可以使用preventDefault()来取消其默认行为。 </div><div class="t m0 x0 hc y261c ff92 fs2 fc0 sc0 ls8 wseb">另外，stopPropagation()方法用于立即停止事件在DOM层次中的传播，即取消进一步的事件</div><div class="t m0 x0 h1e y261d ff92 fs2 fc0 sc0 ls8 wseb">捕获或冒泡。例如，直接添加到一个按钮的事件处理程序可以调用stopPropagation()，从而避免触</div><div class="t m0 x0 h5 y261e ff92 fs2 fc0 sc0 ls8 wseb">发注册在document.body上面的事件处理程序，如下面的例子所示。 </div><div class="t m0 x5 hb y261f ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2620 ff96 fs6 fc0 sc0 ls21 wsb">var btn = document.getElementById(&quot;myBtn&quot;); </div><div class="t m0 x0 hb y2621 ff96 fs6 fc0 sc0 ls21 wsb">btn.onclick = function(event){ </div><div class="t m0 x0 hb y2622 ff96 fs6 fc0 sc0 ls21 wsb">    alert(&quot;Clicked&quot;); </div><div class="t m0 x0 h15 y2623 ff99 fs6 fc0 sc0 ls21 wsb">    event.stopPropagation(); </div><div class="t m0 x0 hb y2624 ff96 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y2625 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y2626 ff99 fs6 fc0 sc0 ls21 wsb">document.body.onclick = function(event){ </div><div class="t m0 x0 h15 y2627 ff99 fs6 fc0 sc0 ls21 wsb">    alert(&quot;Body clicked&quot;); </div><div class="t m0 x0 h15 y2628 ff99 fs6 fc0 sc0 ls21 wsb">};  </div><div class="t m0 x2 hf y2629 ff97 fs2 fc0 sc0 ls1b wsb">DOMEventObjectExample05.htm </div></div></div>
<div id="pf178" class="pf w0 h0" data-page-no="178"><div class="pc pc178 w0 h0"><div class="t m0 x0 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">358  第13章 事件 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ff92 fs2 fc0 sc0 ls8 wseb">对于这个例子而言，如果不调用stopPropagation()，就会在单击按钮时出现两个警告框。可是，</div><div class="t m0 x0 h1e y4d ff92 fs2 fc0 sc0 ls8 wseb">由于click事件根本不会传播到document.body，因此就不会触发注册在这个元素上的onclick 事</div><div class="t m0 x0 h5 y5 ff92 fs2 fc0 sc0 ls8 wseb">件处理程序。 </div><div class="t m0 x0 h1e y6 ff92 fs2 fc0 sc0 ls8 wseb">事件对象的eventPhase属性，可以用来确定事件当前正位于事件流的哪个阶段。如果是在捕获阶</div><div class="t m0 x0 h1e y15d ff92 fs2 fc0 sc0 ls8 wseb">段调用的事件处理程序，那么eventPhase等于 1；如果事件处理程序处于目标对象上，则event- </div><div class="t m0 x0 h42 y262b ff96 fs1 fc0 sc0 ls9 ws2">Phase等于2；如果是在冒泡阶段调用的事件处理程序，eventPhase等于3。这里要注意的是，尽管</div><div class="t m0 x0 hc y15e ff92 fs2 fc0 sc0 ls8 wseb">“处于目标”发生在冒泡阶段，但eventPhase仍然一直等于2。来看下面的例子。 </div><div class="t m0 x0 hb ycf5 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ycf6 ff96 fs6 fc0 sc0 ls21 wsb">var btn = document.getElementById(&quot;myBtn&quot;); </div><div class="t m0 x0 hb ycf7 ff96 fs6 fc0 sc0 ls21 wsb">btn.onclick = function(event){ </div><div class="t m0 x0 h15 ycf8 ff99 fs6 fc0 sc0 ls21 wsb">    alert(event.eventPhase); //2 </div><div class="t m0 x0 hb ycf9 ff96 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb ycfa ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 ycfb ff99 fs6 fc0 sc0 ls21 wsb">document.body.addEventListener(&quot;click&quot;, function(event){ </div><div class="t m0 x0 h15 ycfc ff99 fs6 fc0 sc0 ls21 wsb">    alert(event.eventPhase); //1 </div><div class="t m0 x0 h15 ycfd ff99 fs6 fc0 sc0 ls21 wsb">}, true); </div><div class="t m0 x0 h15 ycfe ff99 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 ycff ff99 fs6 fc0 sc0 ls21 wsb">document.body.onclick = function(event){ </div><div class="t m0 x0 h15 yd00 ff99 fs6 fc0 sc0 ls21 wsb">    alert(event.eventPhase); //3 </div><div class="t m0 x0 h15 yd01 ff99 fs6 fc0 sc0 ls21 wsb">};  </div><div class="t m0 x2 hf y9c9 ff97 fs2 fc0 sc0 ls1b wsb">DOMEventObjectExample06.htm </div><div class="t m0 x0 h4 y262c ff92 fs2 fc0 sc0 ls10b ws10c">当单击这个例子中的按钮时，首先执行的事件处理程序是在捕获阶段触发的添加到document.body</div><div class="t m0 x0 h4 y262d ff92 fs2 fc0 sc0 ls8 wseb">中的那一个，结果会弹出一个警告框显示表示eventPhase的1。接着，会触发在按钮上注册的事件处</div><div class="t m0 x0 h1e y262e ff92 fs2 fc0 sc0 ls8 wseb">理程序，此时的eventPhase值为 2。最后一个被触发的事件处理程序，是在冒泡阶段执行的添加到</div><div class="t m0 x0 h4 y262f ff96 fs1 fc0 sc0 ls9 ws2">document.body上的那一个，显示eventPhase的值为3。而当eventPhase等于2时，this、target</div><div class="t m0 x0 h5 y2630 ff92 fs2 fc0 sc0 ls2c">和currentTarget始终都是相等的。 </div><div class="t m0 x5 ha y2631 ff8c fs2 fc0 sc0 ls8 ws14">只有在事件处理程序执行期间，event对象才会存在；一旦事件处理程序执行完</div><div class="t m0 x0 h18 y2632 ff8c fs2 fc0 sc0 ls8 ws14">成，event对象就会被销毁。 </div><div class="t m0 x0 h20 y1796 ff90 fs3 fc0 sc0 ls248 ws214">13.3.2 IE中的事件对象 </div><div class="t m0 x0 h5 y2633 ff92 fs2 fc0 sc0 ls8 wseb">与访问DOM中的event对象不同，要访问IE 中的event对象有几种不同的方式，取决于指定事</div><div class="t m0 x0 h5 y2634 ff92 fs2 fc0 sc0 ls8 wseb">件处理程序的方法。在使用DOM0级方法添加事件处理程序时，event对象作为 window对象的一个</div><div class="t m0 x0 h5 y2635 ff92 fs2 fc0 sc0 ls8 wseb">属性存在。来看下面的例子。 </div><div class="t m0 x0 hb y1217 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2636 ff96 fs6 fc0 sc0 ls21 wsb">var btn = document.getElementById(&quot;myBtn&quot;); </div><div class="t m0 x0 h15 y2637 ff99 fs6 fc0 sc0 ls21 wsb">btn.onclick = function(){ </div><div class="t m0 x0 h15 y2638 ff99 fs6 fc0 sc0 ls21 wsb">    var event = window.event; </div><div class="t m0 x0 h15 y2639 ff99 fs6 fc0 sc0 ls21 wsb">    alert(event.type);     //&quot;click&quot; </div><div class="t m0 x0 h15 y263a ff99 fs6 fc0 sc0 ls21 wsb">};  </div><div class="t m0 x0 h5 y263b ff92 fs2 fc0 sc0 ls8 wseb">在此，我们通过window.event取得了event 对象，并检测了被触发事件的类型（IE中的type</div><div class="t m0 x0 h5 y263c ff92 fs2 fc0 sc0 ls8 wseb">属性与DOM中的type属性是相同的）。可是，如果事件处理程序是使用attachEvent()添加的，那</div><div class="t m0 x0 h5 y9e1 ff92 fs2 fc0 sc0 ls8 wseb">么就会有一个event对象作为参数被传入事件处理程序函数中，如下所示。 </div></div></div>
<div id="pf179" class="pf w0 h0" data-page-no="179"><div class="pc pc179 w0 h0"><div class="t m0 x2 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">13.3 事件对象    359 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff8d fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff8d fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff8d fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff8d fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff8d fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff8d fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff8d fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff8d fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff8d fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff8d fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff8d fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff8d fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff8d fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y79 ff96 fs6 fc0 sc0 ls21 wsb">var btn = document.getElementById(&quot;myBtn&quot;); </div><div class="t m0 x0 h15 y7a ff99 fs6 fc0 sc0 ls21 wsb">btn.attachEvent(&quot;onclick&quot;, function(event){ </div><div class="t m0 x0 h15 y7b ff99 fs6 fc0 sc0 ls21 wsb">    alert(event.type);  //&quot;click&quot; </div><div class="t m0 x0 h15 y7c ff99 fs6 fc0 sc0 ls21 wsb">});  </div><div class="t m0 x0 h4 y142b ff92 fs2 fc0 sc0 ls8 wseb">在像这样使用attachEvent()的情况下，也可以通过window对象来访问event对象，就像使用</div><div class="t m0 x0 h5 y1992 ff8b fs2 fc0 sc0 ls24a ws215">DOM0级方法时一样。不过为方便起见，同一个对象也会作为参数传递。 </div><div class="t m0 x0 h5 y263d ff92 fs2 fc0 sc0 ls8 wseb">如果是通过HTML特性指定的事件处理程序，那么还可以通过一个名叫event的变量来访问event</div><div class="t m0 x0 h5 y263e ff92 fs2 fc0 sc0 ls8 wseb">对象（与DOM中的事件模型相同）。再看一个例子。 </div><div class="t m0 x5 hb y263f ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2640 ff96 fs6 fc0 sc0 ls21 wsb">&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;alert(event.type)&quot;&gt; </div><div class="t m0 x5 hb y2641 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y2642 ff8b fs2 fc0 sc0 lse ws9">IE的event对象同样也包含与创建它的事件相关的属性和方法。其中很多属性和方法都有对应的</div><div class="t m0 x0 h5 y2643 ff92 fs2 fc0 sc0 ls8 wseb">或者相关的DOM属性和方法。与DOM的event对象一样，这些属性和方法也会因为事件类型的不同</div><div class="t m0 x0 h5 y2644 ff92 fs2 fc0 sc0 ls8 wseb">而不同，但所有事件对象都会包含下表所列的属性和方法。 </div><div class="t m0 x5 hb y2645 ff96 fs6 fc0 sc0 ls8 wsb">  </div><div class="t m0 x0 h31 y2646 ff8f fs6 fc0 sc0 ls8">属性/方法 类  型 读/写 说  明 </div><div class="t m0 x0 h32 y2647 ff96 fsc fc0 sc0 lsa8 wsb">cancelBubble  Boolean  读/写 默认值为false，但将其设置为true就可以取消事件冒泡（与DOM中</div><div class="t m0 x7 hd3 y2648 ff92 fs6 fc0 sc0 ls31c">的stopPropagation()方法的作用相同） </div><div class="t m0 x0 h32 y2649 ff96 fsc fc0 sc0 lsa8 wsb">returnValue  Boolean  读/写 默认值为true，但将其设置为false就可以取消事件的默认行为（与</div><div class="t m0 x7 h36 y264a ff8b fs6 fc0 sc0 ls1ca ws227">DOM中的preventDefault()方法的作用相同） </div><div class="t m0 x0 h32 y264b ff96 fsc fc0 sc0 lsa8 wsb">srcElement  Element  只读 事件的目标（与DOM中的target属性相同） </div><div class="t m0 x0 h32 y200e ff96 fsc fc0 sc0 lsa8 wsb">type  String  只读 被触发的事件的类型 </div><div class="t m0 x5 hb y264c ff96 fs6 fc0 sc0 ls8 wsb">  </div><div class="t m0 x0 h4 y264d ff92 fs2 fc0 sc0 ls8 wseb">因为事件处理程序的作用域是根据指定它的方式来确定的，所以不能认为this会始终等于事件目</div><div class="t m0 x0 h5 y264e ff92 fs2 fc0 sc0 ls8 wseb">标。故而，最好还是使用event.srcElement比较保险。例如： </div><div class="t m0 x5 hb y264f ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2650 ff96 fs6 fc0 sc0 ls21 wsb">var btn = document.getElementById(&quot;myBtn&quot;); </div><div class="t m0 x0 h15 y2651 ff99 fs6 fc0 sc0 ls21 wsb">btn.onclick = function(){ </div><div class="t m0 x0 h15 y2652 ff99 fs6 fc0 sc0 ls21 wsb">    alert(window.event.srcElement === this);  //true </div><div class="t m0 x0 h15 y2653 ff99 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 h15 y2654 ff99 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y2655 ff99 fs6 fc0 sc0 ls21 wsb">btn.attachEvent(&quot;onclick&quot;, function(event){ </div><div class="t m0 x0 h15 y2656 ff99 fs6 fc0 sc0 ls21 wsb">    alert(event.srcElement === this);     //false </div><div class="t m0 x0 h15 y2657 ff99 fs6 fc0 sc0 ls21 wsb">});  </div><div class="t m0 x2 hf y8b8 ff97 fs2 fc0 sc0 ls79 wsb">IEEventObjectExample01.htm </div><div class="t m0 x0 h5 y2658 ff92 fs2 fc0 sc0 ls8 wseb">在第一个事件处理程序中（使用DOM0级方法指定的），srcElement属性等于this，但在第二</div><div class="t m0 x0 h5 y2659 ff92 fs2 fc0 sc0 ls8 wseb">个事件处理程序中，这两者的值不相同。 </div><div class="t m0 x0 he y265a ff92 fs2 fc0 sc0 ls8 wseb">如前所述，returnValue属性相当于DOM中的preventDefault()方法，它们的作用都是取消</div><div class="t m0 x0 hc y265b ff92 fs2 fc0 sc0 ls8 wseb">给定事件的默认行为。只要将returnValue设置为false，就可以阻止默认行为。来看下面的例子。 </div><div class="t m0 x5 hb y265c ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y265d ff96 fs6 fc0 sc0 ls21 wsb">var link = document.getElementById(&quot;myLink&quot;); </div><div class="t m0 x0 hb y265e ff96 fs6 fc0 sc0 ls21 wsb">link.onclick = function(){ </div><div class="t m0 x0 hb y265f ff96 fs6 fc0 sc0 ls21 wsb">    window.event.returnValue = false; </div><div class="t m0 x0 hb y2660 ff96 fs6 fc0 sc0 ls21 wsb">};  </div><div class="t m0 x2 hf y2661 ff97 fs2 fc0 sc0 ls79 wsb">IEEventObjectExample02.htm </div></div></div>
<div id="pf17a" class="pf w0 h0" data-page-no="17a"><div class="pc pc17a w0 h0"><div class="t m0 x0 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">360  第13章 事件 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff92 fs2 fc0 sc0 ls8 wseb">这个例子在onclick事件处理程序中使用returnValue达到了阻止链接默认行为的目的。与DOM</div><div class="t m0 x0 h5 y4d ff92 fs2 fc0 sc0 ls8 wseb">不同的是，在此没有办法确定事件是否能被取消。 </div><div class="t m0 x0 he yd8 ff92 fs2 fc0 sc0 ls8 wseb">相应地，cancelBubble属性与DOM中的stopPropagation()方法作用相同，都是用来停止事</div><div class="t m0 x0 h5 yd9 ff92 fs2 fc0 sc0 ls8 wseb">件冒泡的。由于IE不支持事件捕获，因而只能取消事件冒泡；但stopPropagatioin()可以同时取消</div><div class="t m0 x0 h5 y15d ff92 fs2 fc0 sc0 ls8 wseb">事件捕获和冒泡。例如： </div><div class="t m0 x0 hb y181 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2663 ff96 fs6 fc0 sc0 ls21 wsb">var btn = document.getElementById(&quot;myBtn&quot;); </div><div class="t m0 x0 hb y25f4 ff96 fs6 fc0 sc0 ls21 wsb">btn.onclick = function(){ </div><div class="t m0 x0 hb y2664 ff96 fs6 fc0 sc0 ls21 wsb">    alert(&quot;Clicked&quot;); </div><div class="t m0 x0 h15 y2665 ff99 fs6 fc0 sc0 ls21 wsb">    window.event.cancelBubble = true; </div><div class="t m0 x0 hb y2666 ff96 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y2667 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y2668 ff99 fs6 fc0 sc0 ls21 wsb">document.body.onclick = function(){ </div><div class="t m0 x0 h15 y2669 ff99 fs6 fc0 sc0 ls21 wsb">    alert(&quot;Body clicked&quot;); </div><div class="t m0 x0 h15 y266a ff99 fs6 fc0 sc0 ls21 wsb">};  </div><div class="t m0 x2 hf y19e1 ff97 fs2 fc0 sc0 ls79 wsb">IEEventObjectExample03.htm </div><div class="t m0 x0 h4 y266b ff92 fs2 fc0 sc0 ls8 wseb">通过在onclick事件处理程序中将cancelBubble 设置为true，就可阻止事件通过冒泡而触发</div><div class="t m0 x0 h5 y266c ff96 fs1 fc0 sc0 ls9 ws2">document.body中注册的事件处理程序。结果，在单击按钮之后，只会显示一个警告框。 </div><div class="t m0 x0 h20 y1eff ff90 fs3 fc0 sc0 ls248 ws214">13.3.3 跨浏览器的事件对象 </div><div class="t m0 x0 h5 y266d ff92 fs2 fc0 sc0 ls8 wseb">虽然DOM和IE中的event对象不同，但基于它们之间的相似性依旧可以拿出跨浏览器的方案来。</div><div class="t m0 x0 hc y266e ff8b fs2 fc0 sc0 lse ws9">IE中event对象的全部信息和方法DOM对象中都 有，只不过实现方式不一样。不过，这种对应关系</div><div class="t m0 x0 h1e y266f ff92 fs2 fc0 sc0 ls8 wseb">让实现两种事件模型之间的映射非常容易。可以对前面介绍的EventUtil对象加以增强，添加如下方</div><div class="t m0 x0 h5 y2670 ff92 fs2 fc0 sc0 ls8 wseb">法以求同存异。 </div><div class="t m0 x0 hb y2671 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2672 ff96 fs6 fc0 sc0 ls21 wsb">var EventUtil = { </div><div class="t m0 x0 hb y2673 ff96 fs6 fc0 sc0 ls21 wsb">  </div><div class="t m0 x0 hb y2674 ff96 fs6 fc0 sc0 ls21 wsb">    addHandler: function(element, type, handler){ </div><div class="t m0 x0 h16 y2675 ff96 fs6 fc0 sc0 ls21 wsb">        //省略的代码 </div><div class="t m0 x0 hb y2676 ff96 fs6 fc0 sc0 ls21 wsb">    }, </div><div class="t m0 x0 hb y2677 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y2678 ff99 fs6 fc0 sc0 ls21 wsb">    getEvent: function(event){ </div><div class="t m0 x0 h15 y2679 ff99 fs6 fc0 sc0 ls21 wsb">        return event ? event : window.event; </div><div class="t m0 x0 h15 y267a ff99 fs6 fc0 sc0 ls21 wsb">    }, </div><div class="t m0 x0 h15 y267b ff99 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y267c ff99 fs6 fc0 sc0 ls21 wsb">    getTarget: function(event){ </div><div class="t m0 x0 h15 y267d ff99 fs6 fc0 sc0 ls21 wsb">        return event.target || event.srcElement; </div><div class="t m0 x0 h15 y267e ff99 fs6 fc0 sc0 ls21 wsb">    }, </div><div class="t m0 x0 h15 y267f ff99 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 h15 y2680 ff99 fs6 fc0 sc0 ls21 wsb">    preventDefault: function(event){ </div><div class="t m0 x0 h15 y2681 ff99 fs6 fc0 sc0 ls21 wsb">        if (event.preventDefault){ </div><div class="t m0 x0 h15 y2682 ff99 fs6 fc0 sc0 ls21 wsb">            event.preventDefault(); </div><div class="t m0 x0 h15 y2683 ff99 fs6 fc0 sc0 ls21 wsb">        } else { </div><div class="t m0 x0 h15 y2684 ff99 fs6 fc0 sc0 ls21 wsb">            event.returnValue = false; </div><div class="t m0 x0 h15 y2685 ff99 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 h15 y2686 ff99 fs6 fc0 sc0 ls21 wsb">    }, </div><div class="t m0 x0 hb y2687 ff96 fs6 fc0 sc0 ls21 wsb">  </div><div class="t m0 x0 hb y2688 ff96 fs6 fc0 sc0 ls21 wsb">    removeHandler: function(element, type, handler){ </div><div class="t m0 x0 h16 y2689 ff96 fs6 fc0 sc0 ls21 wsb">        //省略的代码 </div><div class="t m0 x0 hb y268a ff96 fs6 fc0 sc0 ls21 wsb">    }, </div><div class="t m0 x0 h15 y268b ff99 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y268c ff99 fs6 fc0 sc0 ls21 wsb">    stopPropagation: function(event){ </div></div></div>
<div id="pf17b" class="pf w0 h0" data-page-no="17b"><div class="pc pc17b w0 h0"><div class="t m0 x2 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">13.3 事件对象    361 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff8d fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff8d fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff8d fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff8d fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff8d fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff8d fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff8d fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff8d fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff8d fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff8d fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff8d fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff8d fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff8d fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h15 y79 ff99 fs6 fc0 sc0 ls21 wsb">        if (event.stopPropagation){ </div><div class="t m0 x0 h15 y7a ff99 fs6 fc0 sc0 ls21 wsb">            event.stopPropagation(); </div><div class="t m0 x0 h15 y7b ff99 fs6 fc0 sc0 ls21 wsb">        } else { </div><div class="t m0 x0 h15 y7c ff99 fs6 fc0 sc0 ls21 wsb">            event.cancelBubble = true; </div><div class="t m0 x0 h15 y7d ff99 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 h15 y7e ff99 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y268d ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y268e ff96 fs6 fc0 sc0 ls21 wsb">};  </div><div class="t m0 x6 hf y268f ff97 fs2 fc0 sc0 ls2b wsb">EventUtil.js </div><div class="t m0 x0 h5 y2690 ff92 fs2 fc0 sc0 ls8 wseb">以上代码显示，我们为EventUtil添加了4个新方法。第一个是getEvent()，它返回对 event</div><div class="t m0 x0 h5 y2691 ff92 fs2 fc0 sc0 ls8 wseb">对象的引用。考虑到IE中事件对象的位置不同，可以使用这个方法来取得event对象，而不必担心指</div><div class="t m0 x0 h4 y2692 ff92 fs2 fc0 sc0 ls8 wseb">定事件处理程序的方式。在使用这个方法时，必须假设有一个事件对象传入到事件处理程序中，而且要</div><div class="t m0 x0 h5 y2693 ff92 fs2 fc0 sc0 ls8 wseb">把该变量传给这个方法，如下所示。 </div><div class="t m0 x5 hb y2694 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2695 ff96 fs6 fc0 sc0 ls21 wsb">btn.onclick = function(event){ </div><div class="t m0 x0 hb y2696 ff96 fs6 fc0 sc0 ls21 wsb">    event = EventUtil.getEvent(event); </div><div class="t m0 x0 hb y2697 ff96 fs6 fc0 sc0 ls21 wsb">};  </div><div class="t m0 x4 hf y2698 ff97 fs2 fc0 sc0 lsb wsb">CrossBrowserEventObjectExample01.htm </div><div class="t m0 x0 h5 y2699 ff92 fs2 fc0 sc0 ls8 wseb">在兼容DOM的浏览器中，event变量只是简单地传入和返回。而在IE 中，event参数是未定义</div><div class="t m0 x0 h5 y269a ff92 fs2 fc0 sc0 ls8">的（undefined），因此就会返回window.event。将这一行代码添加到事件处理程序的开头，就可以确</div><div class="t m0 x0 hc y2049 ff92 fs2 fc0 sc0 ls8 wseb">保随时都能使用event对象，而不必担心用户使用的是什么浏览器。 </div><div class="t m0 x0 h4 y219e ff92 fs2 fc0 sc0 ls8 wseb">第二个方法是getTarget()，它返回事件的目标。在这个方法内部，会检测event对象的target</div><div class="t m0 x0 h5 y269b ff92 fs2 fc0 sc0 ls1f ws108">属性，如果存在则返回该属性的值；否则，返回srcElement属性的值。可以像下面这样使用这个方法。 </div><div class="t m0 x5 hb y269c ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y269d ff96 fs6 fc0 sc0 ls21 wsb">btn.onclick = function(event){ </div><div class="t m0 x0 hb y269e ff96 fs6 fc0 sc0 ls21 wsb">    event = EventUtil.getEvent(event); </div><div class="t m0 x0 h15 y269f ff99 fs6 fc0 sc0 ls21 wsb">    var target = EventUtil.getTarget(event); </div><div class="t m0 x0 hb y26a0 ff96 fs6 fc0 sc0 ls21 wsb">};  </div><div class="t m0 x4 hf y119f ff97 fs2 fc0 sc0 lsb wsb">CrossBrowserEventObjectExample01.htm </div><div class="t m0 x0 h4 y26a1 ff92 fs2 fc0 sc0 ls8 wseb">第三个方法是preventDefault()，用于取消事件的默认行为。在传入event对象后，这个方法</div><div class="t m0 x0 h1e y26a2 ff92 fs2 fc0 sc0 ls8 wseb">会检查是否存在preventDefault()方法，如果存在则调用该方法。如果preventDefault()方法不</div><div class="t m0 x0 hc y26a3 ff92 fs2 fc0 sc0 ls8 wseb">存在，则将returnValue设置为false。下面是使用这个方法的例子。 </div><div class="t m0 x5 hb y26a4 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y26a5 ff96 fs6 fc0 sc0 ls21 wsb">var link = document.getElementById(&quot;myLink&quot;); </div><div class="t m0 x0 h15 y26a6 ff99 fs6 fc0 sc0 ls21 wsb">link.onclick = function(event){ </div><div class="t m0 x0 h15 y26a7 ff99 fs6 fc0 sc0 ls21 wsb">    event = EventUtil.getEvent(event); </div><div class="t m0 x0 h15 y26a8 ff99 fs6 fc0 sc0 ls21 wsb">    EventUtil.preventDefault(event); </div><div class="t m0 x0 h15 y26a9 ff99 fs6 fc0 sc0 ls21 wsb">};  </div><div class="t m0 x4 hf y26aa ff97 fs2 fc0 sc0 lsb wsb">CrossBrowserEventObjectExample02.htm </div><div class="t m0 x0 h4 y26ab ff92 fs2 fc0 sc0 ls24 wsf5">以上代码可以确保在所有浏览器中单击该链接都不会打开另一个页面。首先，使用EventUtil. </div><div class="t m0 x0 h21 y26ac ff96 fs1 fc0 sc0 ls9 ws2">getEvent()取得event对象，然后将其传入到EventUtil.preventDefault()以取消默认行为。 </div><div class="t m0 x0 hc y11f7 ff92 fs2 fc0 sc0 ls8 wseb">第四个方法是stopPropagation()，其实现方式类似。首先尝试使用DOM方法阻止事件流，否</div><div class="t m0 x0 hc y1930 ff92 fs2 fc0 sc0 ls8 wseb">则就使用cancelBubble属性。下面看一个例子。 </div></div></div>
<div id="pf17c" class="pf w0 h0" data-page-no="17c"><div class="pc pc17c w0 h0"><div class="t m0 x0 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">362  第13章 事件 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y866 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y867 ff96 fs6 fc0 sc0 ls21 wsb">var btn = document.getElementById(&quot;myBtn&quot;); </div><div class="t m0 x0 hb y868 ff96 fs6 fc0 sc0 ls21 wsb">btn.onclick = function(event){ </div><div class="t m0 x0 hb y869 ff96 fs6 fc0 sc0 ls21 wsb">    alert(&quot;Clicked&quot;); </div><div class="t m0 x0 h15 y86a ff99 fs6 fc0 sc0 ls21 wsb">    event = EventUtil.getEvent(event); </div><div class="t m0 x0 h15 y86b ff99 fs6 fc0 sc0 ls21 wsb">    EventUtil.stopPropagation(event); </div><div class="t m0 x0 hb yb1b ff96 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb yb1c ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yb1d ff96 fs6 fc0 sc0 ls21 wsb">document.body.onclick = function(event){ </div><div class="t m0 x0 hb yb1e ff96 fs6 fc0 sc0 ls21 wsb">    alert(&quot;Body clicked&quot;); </div><div class="t m0 x0 hb yb1f ff96 fs6 fc0 sc0 ls21 wsb">};  </div><div class="t m0 x4 hf y26ae ff97 fs2 fc0 sc0 lsb wsb">CrossBrowserEventObjectExample03.htm </div><div class="t m0 x0 h4 y26af ff92 fs2 fc0 sc0 ls8 wseb">在此，首先使用EventUtil.getEvent()取得了event 对象，然后又将其传入到EventUtil. </div><div class="t m0 x0 h21 y26b0 ff96 fs1 fc0 sc0 ls9 ws2">stopPropagation()。别忘了由于IE不支持事件捕获，因此这个方法在跨浏览器的情况下，也只能用</div><div class="t m0 x0 h5 y26b1 ff92 fs2 fc0 sc0 ls8 wseb">来阻止事件冒泡。 </div><div class="t m0 x0 hd y26b2 ff90 fs7 fc0 sc0 ls245">13.4 事件类型 </div><div class="t m0 x0 h5 y26b3 ff8b fs2 fc0 sc0 lsfd wscc">Web浏览器中可能发生的事件有很多类型。如前所述，不同的事件类型具有不同的信息，而“DOM3</div><div class="t m0 x0 h5 y20f2 ff92 fs2 fc0 sc0 ls8 wseb">级事件”规定了以下几类事件。 </div><div class="t m0 x0 h5 y485 ff91 fs1 fc0 sc0 ls2"> UI（User Interface，用户界面）事件，当用户与页面上的元素交互时触发； </div><div class="t m0 x0 h5 y20f3 ff91 fs1 fc0 sc0 ls2"> 焦点事件，当元素获得或失去焦点时触发； </div><div class="t m0 x0 h5 y26b4 ff91 fs1 fc0 sc0 ls2"> 鼠标事件，当用户通过鼠标在页面上执行操作时触发； </div><div class="t m0 x0 h5 y26b5 ff91 fs1 fc0 sc0 ls2"> 滚轮事件，当使用鼠标滚轮（或类似设备）时触发； </div><div class="t m0 x0 h5 y1a5c ff91 fs1 fc0 sc0 ls2"> 文本事件，当在文档中输入文本时触发； </div><div class="t m0 x0 h5 y26b6 ff91 fs1 fc0 sc0 ls2"> 键盘事件，当用户通过键盘在页面上执行操作时触发； </div><div class="t m0 x0 h5 y26b7 ff91 fs1 fc0 sc0 ls2"> 合成事件，当为IME（Input Method Editor，输入法编辑器）输入字符时触发； </div><div class="t m0 x0 h5 y26b8 ff91 fs1 fc0 sc0 ls2"> 变动（mutation）事件，当底层DOM结构发生变化时触发。 </div><div class="t m0 x0 h4 y26b9 ff91 fs1 fc0 sc0 ls2"> 变动名称事件，当元素或属性名变动时触发。此类事件已经被废弃，没有任何浏览器实现它们，</div><div class="t m0 x0 h5 y26ba ff92 fs2 fc0 sc0 ls8 wseb">因此本章不做介绍。 </div><div class="t m0 x0 h5 y26bb ff92 fs2 fc0 sc0 ls8 wseb">除了这几类事件之外，HTML5也定义了一组事件，而有些浏览器还会在DOM和BOM中实现其他</div><div class="t m0 x0 h4 y26bc ff92 fs2 fc0 sc0 ls8 wseb">专有事件。这些专有的事件一般都是根据开发人员需求定制的，没有什么规范，因此不同浏览器的实现</div><div class="t m0 x0 h5 y26bd ff92 fs2 fc0 sc0 ls8 wseb">有可能不一致。 </div><div class="t m0 x0 h5 y26be ff8b fs2 fc0 sc0 ls2e wsf4">DOM3级事件模块在DOM2级事件模块基础上重新定义了这些事件，也添加了一些新事件。包括</div><div class="t m0 x0 h5 y26bf ff8b fs2 fc0 sc0 ls2a ws21">IE9在内的所有主流浏览器都支持DOM2级事件。IE9也支持DOM3 级事件。 </div><div class="t m0 x0 h20 y26c0 ff90 fs3 fc0 sc0 ls248 ws214">13.4.1 UI事件 </div><div class="t m0 x0 h5 y26c1 ff8b fs2 fc0 sc0 ls81 ws76">UI事件指的是那些不一定与用户操作有关的事件。这些事件在DOM规范出现之前，都是以这种或</div><div class="t m0 x0 h5 y26c2 ff92 fs2 fc0 sc0 ls8 wseb">那种形式存在的，而在DOM规范中保留是为了向后兼容。现有的UI事件如下。 </div><div class="t m0 x0 h5 y221f ff91 fs1 fc0 sc0 ls31f"> DOMActivate：表示元素已经被用户操作（通过鼠标或键盘）激活。这个事件在DOM3级事</div><div class="t m0 x0 h5 y26c3 ff92 fs2 fc0 sc0 ls5 wsec">件中被废弃，但Firefox 2+和Chrome支持它。考虑到不同浏览器实现的差异，不建议使用这个</div><div class="t m0 x0 h5 y26c4 ff92 fs2 fc0 sc0 ls5">事件。 </div></div></div>
<div id="pf17d" class="pf w0 h0" data-page-no="17d"><div class="pc pc17d w0 h0"><div class="t m0 x2 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">13.4 事件类型    363 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff8d fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff8d fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff8d fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff8d fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff8d fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff8d fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff8d fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff8d fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff8d fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff8d fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff8d fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff8d fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff8d fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h4 y3 ff91 fs1 fc0 sc0 ls2"> load：当页面完全加载后在window上面触发，当所有框架都加载完毕时在框架集上面触发，</div><div class="t m0 x5 h1e y4d ff92 fs2 fc0 sc0 ls8 wseb">当图像加载完毕时在&lt;img&gt;元素上面触发，或者当嵌入的内容加载完毕时在&lt;object&gt;元素上面</div><div class="t m0 x5 h5 y5 ff92 fs2 fc0 sc0 ls8">触发。 </div><div class="t m0 x0 h4 yd9 ff91 fs1 fc0 sc0 ls2"> unload：当页面完全卸载后在window上面触发，当所有框架都卸载后在框架集上面触发，或</div><div class="t m0 x5 hc y15d ff92 fs2 fc0 sc0 ls8 wseb">者当嵌入的内容卸载完毕后在&lt;object&gt;元素上面触发。 </div><div class="t m0 x0 h5 y8 ff91 fs1 fc0 sc0 ls2"> abort：在用户停止下载过程时，如果嵌入的内容没有加载完，则在&lt;object&gt;元素上面触发。 </div><div class="t m0 x0 h5 y9 ff91 fs1 fc0 sc0 ls2"> error：当发生JavaScript错误时在window上面触发，当无法加载图像时在&lt;img&gt;元素上面触</div><div class="t m0 x5 h1e y15f ff92 fs2 fc0 sc0 ls8 wseb">发，当无法加载嵌入内容时在&lt;object&gt;元素上面触发，或者当有一或多个框架无法加载时在框</div><div class="t m0 x5 h5 yb ff92 fs2 fc0 sc0 ls8 wseb">架集上面触发。第17章将继续讨论这个事件。 </div><div class="t m0 x0 h5 yc ff91 fs1 fc0 sc0 ls2"> select：当用户选择文本框（&lt;input&gt;或&lt;texterea&gt;）中的一或多个字符时触发。第14章将</div><div class="t m0 x5 h5 y116b ff92 fs2 fc0 sc0 ls8 wseb">继续讨论这个事件。 </div><div class="t m0 x0 h5 y21b ff91 fs1 fc0 sc0 ls2"> resize：当窗口或框架的大小变化时在window或框架上面触发。 </div><div class="t m0 x0 h4 y21c ff91 fs1 fc0 sc0 ls2"> scroll：当用户滚动带滚动条的元素中的内容时，在该元素上面触发。&lt;body&gt;元素中包含所加</div><div class="t m0 x5 h5 y116c ff92 fs2 fc0 sc0 ls8 wseb">载页面的滚动条。 </div><div class="t m0 x0 he y26c5 ff92 fs2 fc0 sc0 ls8 wseb">多数这些事件都与window对象或表单控件相关。 </div><div class="t m0 x0 hc y12 ff92 fs2 fc0 sc0 ls8 wseb">除了DOMActivate之外，其他事件在DOM2级事件中都归为HTML事件（DOMActivate在DOM2</div><div class="t m0 x0 h5 y13 ff92 fs2 fc0 sc0 ls8 wseb">级中仍然属于UI事件）。要确定浏览器是否支持DOM2级事件规定的HTML事件，可以使用如下代码： </div><div class="t m0 x5 hb y26c6 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y26c7 ff96 fs6 fc0 sc0 ls21 wsb">var isSupported = document.implementation.hasFeature(&quot;HTMLEvents&quot;, &quot;2.0&quot;); </div><div class="t m0 x5 hb y26c8 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y26c9 ff92 fs2 fc0 sc0 ls8 wseb">注意，只有根据“DOM2级事件”实现这些事件的浏览器才会返回true。而以非标准方式支持这</div><div class="t m0 x0 hc y26ca ff92 fs2 fc0 sc0 ls8 wseb">些事件的浏览器则会返回false。要确定浏览器是否支持“DOM3级事件”定义的事件，可以使用如下</div><div class="t m0 x0 h5 y2671 ff92 fs2 fc0 sc0 ls8">代码： </div><div class="t m0 x0 hb y26cb ff96 fs6 fc0 sc0 ls21 wsb">var isSupported = document.implementation.hasFeature(&quot;UIEvent&quot;, &quot;3.0&quot;); </div><div class="t m0 x0 h3c y18b7 ff90 fs2 fc0 sc0 ls2e wsb">1. load事件 </div><div class="t m0 x0 h5 y26cc ff8b fs2 fc0 sc0 lsb ws5">JavaScript中最常用的一个事件就是load。当页面完全加载后（包括所有图像、JavaScript文件、</div><div class="t m0 x0 h5 y26cd ff8b fs2 fc0 sc0 ls14d ws11a">CSS文件等外部资源），就会触发window上面的load事件。有两种定义onload事件处理程序的方式。</div><div class="t m0 x0 h5 y26ce ff92 fs2 fc0 sc0 ls8 wseb">第一种方式是使用如下所示的JavaScript代码： </div><div class="t m0 x5 hb y344 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y26cf ff96 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(window, &quot;load&quot;, function(event){ </div><div class="t m0 x0 hb y26d0 ff96 fs6 fc0 sc0 ls21 wsb">    alert(&quot;Loaded!&quot;);  </div><div class="t m0 x0 hb y26d1 ff96 fs6 fc0 sc0 ls21 wsb">});  </div><div class="t m0 x2 hf y26d2 ff97 fs2 fc0 sc0 ls2b wsb">LoadEventExample01.htm </div><div class="t m0 x0 h5 y232 ff92 fs2 fc0 sc0 ls8 wseb">这是通过JavaScript来指定事件处理程序的方式，使用了本章前面定义的跨浏览器的 EventUtil</div><div class="t m0 x0 h4 y26d3 ff92 fs2 fc0 sc0 ls8 wseb">对象。与添加其他事件一样，这里也给事件处理程序传入了一个event对象。这个event对象中不包</div><div class="t m0 x0 h5 y26d4 ff92 fs2 fc0 sc0 ls6 wsf7">含有关这个事件的任何附加信息，但在兼容DOM的浏览器中，event.target 属性的值会被设置为</div><div class="t m0 x0 h5 y23f3 ff96 fs1 fc0 sc0 ls9 ws2">document，而IE并不会为这个事件设置srcElement属性。 </div><div class="t m0 x0 h4 y26d5 ff92 fs2 fc0 sc0 ls8 wseb">第二种指定onload事件处理程序的方式是为&lt;body&gt;元素添加一个onload 特性，如下面的例子</div><div class="t m0 x0 h5 y26d6 ff92 fs2 fc0 sc0 ls8">所示： </div><div class="t m0 x0 hb y26d7 ff96 fs6 fc0 sc0 ls21 wsb">&lt;!DOCTYPE html&gt; </div><div class="t m0 x0 hb y26d8 ff96 fs6 fc0 sc0 ls21 wsb">&lt;html&gt; </div><div class="t m0 x0 hb y26d9 ff96 fs6 fc0 sc0 ls21 wsb">&lt;head&gt; </div></div></div>
<div id="pf17e" class="pf w0 h0" data-page-no="17e"><div class="pc pc17e w0 h0"><div class="t m0 x0 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">364  第13章 事件 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 ff96 fs6 fc0 sc0 ls21 wsb">    &lt;title&gt;Load Event Example&lt;/title&gt; </div><div class="t m0 x0 hb y7a ff96 fs6 fc0 sc0 ls21 wsb">&lt;/head&gt; </div><div class="t m0 x0 hb y7b ff96 fs6 fc0 sc0 ls21 wsb">&lt;body onload=&quot;alert(&apos;Loaded!&apos;)&quot;&gt; </div><div class="t m0 x0 hb y7c ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y7d ff96 fs6 fc0 sc0 ls21 wsb">&lt;/body&gt; </div><div class="t m0 x0 hb y7e ff96 fs6 fc0 sc0 ls21 wsb">&lt;/html&gt; </div><div class="t m0 x0 hb y26da ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1dcf ff97 fs2 fc0 sc0 ls2b wsb">LoadEventExample02.htm </div><div class="t m0 x0 h4 y26db ff92 fs2 fc0 sc0 ls8 wseb">一般来说，在window上面发生的任何事件都可以在&lt;body&gt;元素中通过相应的特性来指定，因为</div><div class="t m0 x0 h5 y26dc ff92 fs2 fc0 sc0 ls3b">在HTML中无法访问window元素。实际上，这只是为了保证向后兼容的一种权宜之计，但所有浏览器</div><div class="t m0 x0 h5 y26dd ff92 fs2 fc0 sc0 ls8 wseb">都能很好地支持这种方式。我们建议读者尽可能使用JavaScript方式。 </div><div class="t m0 x5 h5 y26de ff8c fs2 fc0 sc0 ls8 ws14">根据“DOM2级事件”规范，应该在document而非window上面触发 load事</div><div class="t m0 x0 h18 y26df ff8c fs2 fc0 sc0 ls8 ws14">件。但是，所有浏览器都在window上面实现了该事件，以确保向后兼容。 </div><div class="t m0 x0 h54 y26e0 ff92 fs2 fc0 sc0 ls8 wseb">图像上面也可以触发load事件，无论是在DOM中的图像元素还是HTML 中的图像元素。因此，</div><div class="t m0 x0 hc y26e1 ff92 fs2 fc0 sc0 ls8 wseb">可以在HTML中为任何图像指定onload事件处理程序，例如： </div><div class="t m0 x0 hb y26e2 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y26e3 ff96 fs6 fc0 sc0 ls21 wsb">&lt;img src=&quot;smile.gif&quot; onload=&quot;alert(&apos;Image loaded.&apos;)&quot;&gt; </div><div class="t m0 x0 hb y26e4 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1197 ff97 fs2 fc0 sc0 ls2b wsb">LoadEventExample03.htm </div><div class="t m0 x0 h5 y26e5 ff92 fs2 fc0 sc0 ls8 wseb">这样，当例子中的图像加载完毕后就会显示一个警告框。同样的功能也可以使用JavaScript来实现，</div><div class="t m0 x0 h5 y26e6 ff92 fs2 fc0 sc0 ls8">例如： </div><div class="t m0 x0 hb y26e7 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y26e8 ff96 fs6 fc0 sc0 ls21 wsb">var image = document.getElementById(&quot;myImage&quot;); </div><div class="t m0 x0 hb y26e9 ff96 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(image, &quot;load&quot;, function(event){ </div><div class="t m0 x0 hb y26ea ff96 fs6 fc0 sc0 ls21 wsb">    event = EventUtil.getEvent(event); </div><div class="t m0 x0 hb y26eb ff96 fs6 fc0 sc0 ls21 wsb">    alert(EventUtil.getTarget(event).src); </div><div class="t m0 x0 hb y26ec ff96 fs6 fc0 sc0 ls21 wsb">});  </div><div class="t m0 x2 hf y26ed ff97 fs2 fc0 sc0 ls2b wsb">LoadEventExample04.htm </div><div class="t m0 x0 h5 y26ee ff92 fs2 fc0 sc0 ls8 wseb">这里，使用JavaScript指定了onload事件处理程序。同时也传入了event 对象，尽管它也不包含</div><div class="t m0 x0 h5 y26ef ff92 fs2 fc0 sc0 ls8 wseb">什么有用的信息。不过，事件的目标是&lt;img&gt;元素，因此可以通过src属性访问并显示该信息。 </div><div class="t m0 x0 h1e y26f0 ff92 fs2 fc0 sc0 ls8 wseb">在创建新的&lt;img&gt;元素时，可以为其指定一个事件处理程序，以便图像加载完毕后给出提示。此时，</div><div class="t m0 x0 hc y26f1 ff92 fs2 fc0 sc0 ls8 wseb">最重要的是要在指定src属性之前先指定事件，如下面的例子所示。 </div><div class="t m0 x0 hb y2cf ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y26f2 ff96 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(window, &quot;load&quot;, function(){ </div><div class="t m0 x0 hb y26f3 ff96 fs6 fc0 sc0 ls21 wsb">    var image = document.createElement(&quot;img&quot;); </div><div class="t m0 x0 hb y26f4 ff96 fs6 fc0 sc0 ls21 wsb">    EventUtil.addHandler(image, &quot;load&quot;, function(event){ </div><div class="t m0 x0 hb y26f5 ff96 fs6 fc0 sc0 ls21 wsb">        event = EventUtil.getEvent(event); </div><div class="t m0 x0 hb y26f6 ff96 fs6 fc0 sc0 ls21 wsb">        alert(EventUtil.getTarget(event).src); </div><div class="t m0 x0 hb y26f7 ff96 fs6 fc0 sc0 ls21 wsb">    }); </div><div class="t m0 x0 hb y26f8 ff96 fs6 fc0 sc0 ls21 wsb">    document.body.appendChild(image); </div><div class="t m0 x0 hb y26f9 ff96 fs6 fc0 sc0 ls21 wsb">    image.src = &quot;smile.gif&quot;;             </div><div class="t m0 x0 hb y26fa ff96 fs6 fc0 sc0 ls21 wsb">});  </div><div class="t m0 x2 hf y26fb ff97 fs2 fc0 sc0 ls2b wsb">LoadEventExample05.htm </div></div></div>
<div id="pf17f" class="pf w0 h0" data-page-no="17f"><div class="pc pc17f w0 h0"><div class="t m0 x2 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">13.4 事件类型    365 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff8d fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff8d fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff8d fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff8d fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff8d fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff8d fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff8d fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff8d fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff8d fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff8d fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff8d fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff8d fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff8d fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff92 fs2 fc0 sc0 ls8 wseb">在这个例子中，首先为window指定了onload事件处理程序。原因在于，我们是想向 DOM中添</div><div class="t m0 x0 h1e y4d ff92 fs2 fc0 sc0 ls8 wseb">加一个新元素，所以必须确定页面已经加载完毕——如果在页面加载前操作document.body会导致错</div><div class="t m0 x0 h1e y5 ff92 fs2 fc0 sc0 ls8 wseb">误。然后，创建了一个新的图像元素，并设置了其onload事件处理程序。最后又将这个图像添加到页</div><div class="t m0 x0 h4 yd9 ff92 fs2 fc0 sc0 ls8 wseb">面中，还设置了它的src属性。这里有一点需要格外注意：新图像元素不一定要从添加到文档后才开始</div><div class="t m0 x0 hc y15d ff92 fs2 fc0 sc0 ls8 wseb">下载，只要设置了src属性就会开始下载。 </div><div class="t m0 x0 hc y21a ff92 fs2 fc0 sc0 ls8 wseb">同样的功能也可以通过使用DOM0级的Image对象实现。在 DOM出现之前，开发人员经常使用</div><div class="t m0 x0 h4 y9 ff96 fs1 fc0 sc0 ls9 ws2">Image对象在客户端预先加载图像。可以像使用&lt;img&gt;元素一样使用Image对象，只不过无法将其添</div><div class="t m0 x0 h5 y15f ff92 fs2 fc0 sc0 ls8 wseb">加到DOM树中。下面来看一个例子。 </div><div class="t m0 x5 hb y766 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y767 ff96 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(window, &quot;load&quot;, function(){ </div><div class="t m0 x0 h15 y768 ff99 fs6 fc0 sc0 ls21 wsb">    var image = new Image(); </div><div class="t m0 x0 hb y769 ff96 fs6 fc0 sc0 ls21 wsb">    EventUtil.addHandler(image, &quot;load&quot;, function(event){ </div><div class="t m0 x0 hb y76a ff96 fs6 fc0 sc0 ls21 wsb">        alert(&quot;Image loaded!&quot;); </div><div class="t m0 x0 hb y76b ff96 fs6 fc0 sc0 ls21 wsb">    }); </div><div class="t m0 x0 hb y76c ff96 fs6 fc0 sc0 ls21 wsb">    image.src = &quot;smile.gif&quot;;             </div><div class="t m0 x0 hb y76d ff96 fs6 fc0 sc0 ls21 wsb">});  </div><div class="t m0 x2 hf y1c15 ff97 fs2 fc0 sc0 ls2b wsb">LoadEventExample06.htm </div><div class="t m0 x0 h4 y2117 ff92 fs2 fc0 sc0 ls8 wseb">在此，我们使用Image构造函数创建了一个新图像的实例，然后又为它指定了事件处理程序。有</div><div class="t m0 x0 hc y6cd ff92 fs2 fc0 sc0 ls8 wseb">的浏览器将Image对象实现为&lt;img&gt;元素，但并非所有浏览器都如此，所以最好将它们区别对待。 </div><div class="t m0 x5 h5 y26fc ff8c fs2 fc0 sc0 ls8 ws14">在不属于DOM文档的图像（包括未添加到文档的&lt;img&gt;元素和Image对象）上</div><div class="t m0 x5 h18 y26fd ff8c fs2 fc0 sc0 ls8 ws14">触发load事件时，IE8及之前版本不会生成event对象。IE9 修复了这个问题。 </div><div class="t m0 x0 h54 y26fe ff92 fs2 fc0 sc0 ls8 wseb">还有一些元素也以非标准的方式支持load事件。在IE9+、Firefox、Opera、Chrome和Safari 3+及</div><div class="t m0 x0 hc y154f ff92 fs2 fc0 sc0 ls8 wseb">更高版本中，&lt;script&gt;元素也会触发load事件，以便开发人员确定动态加载的JavaScript文件是否加</div><div class="t m0 x0 h1e y26ff ff92 fs2 fc0 sc0 ls8 wseb">载完毕。与图像不同，只有在设置了&lt;script&gt;元素的src属性并将该元素添加到文档后，才会开始下</div><div class="t m0 x0 h5 y2700 ff92 fs2 fc0 sc0 ls61">载JavaScript文件。换句话说，对于&lt;script&gt;元素而言，指定src属性和指定事件处理程序的先后顺</div><div class="t m0 x0 h5 y1a5e ff92 fs2 fc0 sc0 ls8 wseb">序就不重要了。以下代码展示了怎样为&lt;script&gt;元素指定事件处理程序。 </div><div class="t m0 x5 hb y2701 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2702 ff96 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(window, &quot;load&quot;, function(){ </div><div class="t m0 x0 h15 y2703 ff99 fs6 fc0 sc0 ls21 wsb">    var script = document.createElement(&quot;script&quot;); </div><div class="t m0 x0 h15 y2704 ff99 fs6 fc0 sc0 ls21 wsb">    EventUtil.addHandler(script, &quot;load&quot;, function(event){ </div><div class="t m0 x0 h15 y2705 ff99 fs6 fc0 sc0 ls21 wsb">        alert(&quot;Loaded&quot;); </div><div class="t m0 x0 h15 y2706 ff99 fs6 fc0 sc0 ls21 wsb">    }); </div><div class="t m0 x0 h15 y2707 ff99 fs6 fc0 sc0 ls21 wsb">    script.src = &quot;example.js&quot;; </div><div class="t m0 x0 h15 y2708 ff99 fs6 fc0 sc0 ls21 wsb">    document.body.appendChild(script); </div><div class="t m0 x0 h15 y2709 ff99 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 hb y270a ff96 fs6 fc0 sc0 ls21 wsb">});  </div><div class="t m0 x2 hf y270b ff97 fs2 fc0 sc0 ls2b wsb">LoadEventExample07.htm </div><div class="t m0 x0 h4 y270c ff92 fs2 fc0 sc0 ls8 wseb">这个例子使用了跨浏览器的EventUtil对象为新创建的&lt;script&gt;元素指定了onload事件处理程</div><div class="t m0 x0 hc y270d ff92 fs2 fc0 sc0 ls8 wseb">序。此时，大多数浏览器中event对象的target属性引用的都是&lt;script&gt;节点，而在Firefox 3 之前</div><div class="t m0 x0 hc y270e ff92 fs2 fc0 sc0 ls8 wseb">的版本中，引用的则是document。IE8及更早版本不支持&lt;script&gt;元素上的load事件。 </div><div class="t m0 x0 h5 y270f ff8b fs2 fc0 sc0 lse ws9">IE和Opera还支持&lt;link&gt;元素上的load事件，以便开发人员确定样式表是否加载完毕。例如： </div><div class="t m0 x5 hb y2710 ff96 fs6 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf180" class="pf w0 h0" data-page-no="180"><div class="pc pc180 w0 h0"><div class="t m0 x0 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">366  第13章 事件 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y44f ff96 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(window, &quot;load&quot;, function(){ </div><div class="t m0 x0 h15 y450 ff99 fs6 fc0 sc0 ls21 wsb">    var link = document.createElement(&quot;link&quot;); </div><div class="t m0 x0 h15 y451 ff99 fs6 fc0 sc0 ls21 wsb">    link.type = &quot;text/css&quot;; </div><div class="t m0 x0 h15 y452 ff99 fs6 fc0 sc0 ls21 wsb">    link.rel= &quot;stylesheet&quot;; </div><div class="t m0 x0 h15 y453 ff99 fs6 fc0 sc0 ls21 wsb">    EventUtil.addHandler(link, &quot;load&quot;, function(event){ </div><div class="t m0 x0 h15 y454 ff99 fs6 fc0 sc0 ls21 wsb">        alert(&quot;css loaded&quot;); </div><div class="t m0 x0 h15 y455 ff99 fs6 fc0 sc0 ls21 wsb">    }); </div><div class="t m0 x0 h15 y456 ff99 fs6 fc0 sc0 ls21 wsb">    link.href = &quot;example.css&quot;; </div><div class="t m0 x0 h15 ye88 ff99 fs6 fc0 sc0 ls21 wsb">    document.getElementsByTagName(&quot;head&quot;)[0].appendChild(link); </div><div class="t m0 x0 hb ye89 ff96 fs6 fc0 sc0 ls21 wsb">});  </div><div class="t m0 x2 hf y2712 ff97 fs2 fc0 sc0 ls2b wsb">LoadEventExample07.htm </div><div class="t m0 x0 h5 y2713 ff92 fs2 fc0 sc0 ls8 wseb">与&lt;script&gt;节点类似，在未指定href属性并将&lt;link&gt;元素添加到文档之前也不会开始下载样式表。 </div><div class="t m0 x0 hab y2714 ff90 fs2 fc0 sc0 ls2e wsb">2. unload事件 </div><div class="t m0 x0 h4 y2715 ff92 fs2 fc0 sc0 ls323">与load事件对应的是unload事件，这个事件在文档被完全卸载后触发。只要用户从一个页面切</div><div class="t m0 x0 h4 y2e4 ff92 fs2 fc0 sc0 ls8 wseb">换到另一个页面，就会发生unload事件。而利用这个事件最多的情况是清除引用，以避免内存泄漏。</div><div class="t m0 x0 hc y2716 ff92 fs2 fc0 sc0 ls324">与load事件类似，也有两种指定onunload事件处理程序的方式。第一种方式是使用 JavaScript，如</div><div class="t m0 x0 h5 y2717 ff92 fs2 fc0 sc0 ls8">下所示：  </div><div class="t m0 x0 hb y2718 ff96 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(window, &quot;unload&quot;, function(event){ </div><div class="t m0 x0 hb y2719 ff96 fs6 fc0 sc0 ls21 wsb">    alert(&quot;Unloaded&quot;); </div><div class="t m0 x0 hb y271a ff96 fs6 fc0 sc0 ls21 wsb">});  </div><div class="t m0 x0 h5 y271b ff92 fs2 fc0 sc0 ls8 wseb">此时生成的event对象在兼容DOM的浏览器中只包含target 属性（值为document）。IE8及之</div><div class="t m0 x0 hc y271c ff92 fs2 fc0 sc0 ls8 wseb">前版本则为这个事件对象提供了srcElement属性。 </div><div class="t m0 x0 h1e y271d ff92 fs2 fc0 sc0 ls8 wseb">指定事件处理程序的第二种方式，也是为&lt;body&gt;元素添加一个特性（与load事件相似），如下面</div><div class="t m0 x0 h5 y271e ff92 fs2 fc0 sc0 ls8 wseb">的例子所示： </div><div class="t m0 x0 hb y271f ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2720 ff96 fs6 fc0 sc0 ls21 wsb">&lt;!DOCTYPE html&gt; </div><div class="t m0 x0 hb y2721 ff96 fs6 fc0 sc0 ls21 wsb">&lt;html&gt; </div><div class="t m0 x0 hb y2722 ff96 fs6 fc0 sc0 ls21 wsb">&lt;head&gt; </div><div class="t m0 x0 hb y2723 ff96 fs6 fc0 sc0 ls21 wsb">    &lt;title&gt;Unload Event Example&lt;/title&gt; </div><div class="t m0 x0 hb y2724 ff96 fs6 fc0 sc0 ls21 wsb">&lt;/head&gt; </div><div class="t m0 x0 hb y2725 ff96 fs6 fc0 sc0 ls21 wsb">&lt;body onunload=&quot;alert(&apos;Unloaded!&apos;)&quot;&gt; </div><div class="t m0 x0 hb y2726 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2727 ff96 fs6 fc0 sc0 ls21 wsb">&lt;/body&gt; </div><div class="t m0 x0 hb y2728 ff96 fs6 fc0 sc0 ls21 wsb">&lt;/html&gt; </div><div class="t m0 x0 hb y2729 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y272a ff97 fs2 fc0 sc0 ls1b wsb">UnloadEventExample01.htm </div><div class="t m0 x0 h4 y2039 ff92 fs2 fc0 sc0 ls8 wseb">无论使用哪种方式，都要小心编写onunload事件处理程序中的代码。既然unload事件是在一切</div><div class="t m0 x0 h5 y203a ff92 fs2 fc0 sc0 ls8 wseb">都被卸载之后才触发，那么在页面加载后存在的那些对象，此时就不一定存在了。此时，操作DOM节</div><div class="t m0 x0 h5 y272b ff92 fs2 fc0 sc0 ls8 wseb">点或者元素的样式就会导致错误。 </div><div class="t m0 x5 h5 y272c ff8c fs2 fc0 sc0 ls8 ws14">根据“DOM2级事件”，应该在&lt;body&gt;元素而非window对象上面触发unload</div><div class="t m0 x0 h5 y272d ff8c fs2 fc0 sc0 ls8 ws14">事件。不过，所有浏览器都在window上实现了unload事件，以确保向后兼容。 </div><div class="t m0 x0 h50 y272e ff90 fs2 fc0 sc0 ls2e wsb">3. resize事件 </div><div class="t m0 x0 h4 y272f ff92 fs2 fc0 sc0 ls8 wseb">当浏览器窗口被调整到一个新的高度或宽度时，就会触发resize事件。这个事件在window（窗</div><div class="t m0 x0 h5 y2730 ff92 fs2 fc0 sc0 ls8 wseb">口）上面触发，因此可以通过JavaScript或者&lt;body&gt;元素中的onresize特性来指定事件处理程序。如</div></div></div>
<div id="pf181" class="pf w0 h0" data-page-no="181"><div class="pc pc181 w0 h0"><div class="t m0 x2 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">13.4 事件类型    367 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff8d fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff8d fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff8d fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff8d fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff8d fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff8d fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff8d fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff8d fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff8d fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff8d fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff8d fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff8d fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff8d fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff92 fs2 fc0 sc0 ls8 wseb">前所述，我们还是推荐使用如下所示的JavaScript方式： </div><div class="t m0 x5 hb yfb2 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yfb3 ff96 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(window, &quot;resize&quot;, function(event){ </div><div class="t m0 x0 hb yfb4 ff96 fs6 fc0 sc0 ls21 wsb">    alert(&quot;Resized&quot;); </div><div class="t m0 x0 hb yfb5 ff96 fs6 fc0 sc0 ls21 wsb">});  </div><div class="t m0 x0 h5 y2731 ff92 fs2 fc0 sc0 ls8 wseb">与其他发生在window上的事件类似，在兼容DOM的浏览器中，传入事件处理程序中的event对</div><div class="t m0 x0 hc y2732 ff92 fs2 fc0 sc0 ls8 wseb">象有一个target属性，值为document；而IE8及之前版本则未提供任何属性。 </div><div class="t m0 x0 h5 y2321 ff92 fs2 fc0 sc0 ls8 wseb">关于何时会触发resize事件，不同浏览器有不同的机制。IE、Safari、Chrome和Opera会在浏览</div><div class="t m0 x0 hc y2733 ff92 fs2 fc0 sc0 ls8 wseb">器窗口变化了1像素时就触发resize事件，然后随着变化不断重复触发。Firefox则只会在用户停止调</div><div class="t m0 x0 h1e y2734 ff92 fs2 fc0 sc0 ls8 wseb">整窗口大小时才会触发resize事件。由于存在这个差别，应该注意不要在这个事件的处理程序中加入</div><div class="t m0 x0 h5 y2735 ff92 fs2 fc0 sc0 ls8 wseb">大计算量的代码，因为这些代码有可能被频繁执行，从而导致浏览器反应明显变慢。 </div><div class="t m0 x5 h17 y2736 ff8c fs2 fc0 sc0 ls8 ws14">浏览器窗口最小化或最大化时也会触发resize事件。 </div><div class="t m0 x0 h50 y2737 ff90 fs2 fc0 sc0 ls2e wsb">4. scroll事件 </div><div class="t m0 x0 h4 y2738 ff92 fs2 fc0 sc0 ls8 wseb">虽然scroll事件是在window对象上发生的，但它实际表示的则是页面中相应元素的变化。在混</div><div class="t m0 x0 h4 y4a ff92 fs2 fc0 sc0 ls8 wseb">杂模式下，可以通过&lt;body&gt;元素的scrollLeft和scrollTop来监控到这一变化；而在标准模式下，</div><div class="t m0 x0 hc y254e ff92 fs2 fc0 sc0 ls325">除Safari之外的所有浏览器都会通过&lt;html&gt;元素来反映这一变化（Safari仍然基于&lt;body&gt;跟踪滚动位</div><div class="t m0 x0 h5 y20b8 ff92 fs2 fc0 sc0 ls8 wseb">置），如下面的例子所示： </div><div class="t m0 x5 hb y254f ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2550 ff96 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(window, &quot;scroll&quot;, function(event){ </div><div class="t m0 x0 hb y2551 ff96 fs6 fc0 sc0 ls21 wsb">    if (document.compatMode == &quot;CSS1Compat&quot;){ </div><div class="t m0 x0 hb y2552 ff96 fs6 fc0 sc0 ls21 wsb">        alert(document.documentElement.scrollTop); </div><div class="t m0 x0 hb y2553 ff96 fs6 fc0 sc0 ls21 wsb">    } else { </div><div class="t m0 x0 hb y2739 ff96 fs6 fc0 sc0 ls21 wsb">        alert(document.body.scrollTop); </div><div class="t m0 x0 hb y273a ff96 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y273b ff96 fs6 fc0 sc0 ls21 wsb">});  </div><div class="t m0 x2 hf y1279 ff97 fs2 fc0 sc0 ls7a wsb">ScrollEventExample01.htm </div><div class="t m0 x0 h4 y273c ff92 fs2 fc0 sc0 ls24 wsf5">以上代码指定的事件处理程序会输出页面的垂直滚动位置——根据呈现模式不同使用了不同的元</div><div class="t m0 x0 h5 y273d ff92 fs2 fc0 sc0 ls8 wseb">素。由于Safari 3.1之前的版本不支持document.compatMode，因此旧版本的浏览器就会满足第二个</div><div class="t m0 x0 h5 y273e ff92 fs2 fc0 sc0 ls8">条件。 </div><div class="t m0 x0 h1c y273f ff92 fs2 fc0 sc0 ls326">与resize事件类似，scroll事件也会在文档被滚动期间重复被触发，所以有必要尽量保持事件</div><div class="t m0 x0 h5 y2740 ff92 fs2 fc0 sc0 ls8 wseb">处理程序的代码简单。 </div><div class="t m0 x0 h20 y1a0 ff90 fs3 fc0 sc0 ls248 ws214">13.4.2 焦点事件 </div><div class="t m0 x0 h4 y2ac ff92 fs2 fc0 sc0 ls8 wseb">焦点事件会在页面元素获得或失去焦点时触发。利用这些事件并与document.hasFocus()方法及</div><div class="t m0 x0 h5 y2741 ff96 fs1 fc0 sc0 ls9 ws2">document.activeElement属性配合，可以知晓用户在页面上的行踪。有以下6个焦点事件。 </div><div class="t m0 x0 h5 y2742 ff91 fs1 fc0 sc0 ls2"> blur：在元素失去焦点时触发。这个事件不会冒泡；所有浏览器都支持它。 </div><div class="t m0 x0 h5 y2743 ff91 fs1 fc0 sc0 ls2"> DOMFocusIn：在元素获得焦点时触发。这个事件与HTML事件focus等价，但它冒泡。只有</div><div class="t m0 x5 hc y205e ff8b fs2 fc0 sc0 ls2b ws22">Opera支持这个事件。DOM3级事件废弃了DOMFocusIn，选择了focusin。 </div><div class="t m0 x0 h5 y893 ff91 fs1 fc0 sc0 ls2"> DOMFocusOut：在元素失去焦点时触发。这个事件是HTML事件blur的通用版本。只有Opera</div><div class="t m0 x5 hc y2b2 ff92 fs2 fc0 sc0 ls8 wseb">支持这个事件。DOM3级事件废弃了DOMFocusOut，选择了focusout。 </div></div></div>
<div id="pf182" class="pf w0 h0" data-page-no="182"><div class="pc pc182 w0 h0"><div class="t m0 x0 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">368  第13章 事件 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff91 fs1 fc0 sc0 ls2"> focus：在元素获得焦点时触发。这个事件不会冒泡；所有浏览器都支持它。 </div><div class="t m0 x0 h5 y4 ff91 fs1 fc0 sc0 ls2"> focusin：在元素获得焦点时触发。这个事件与HTML事件focus等价，但它冒泡。支持这个</div><div class="t m0 x0 h5 y5 ff92 fs2 fc0 sc0 ls8 wseb">事件的浏览器有IE5.5+、Safari 5.1+、Opera 11.5+和Chrome。 </div><div class="t m0 x0 h5 yd9 ff91 fs1 fc0 sc0 ls2"> focusout：在元素失去焦点时触发。这个事件是HTML事件blur的通用版本。支持这个事件</div><div class="t m0 x0 h5 y15d ff92 fs2 fc0 sc0 ls8 wseb">的浏览器有IE5.5+、Safari 5.1+、Opera 11.5+和Chrome。 </div><div class="t m0 x0 he y2b3 ff92 fs2 fc0 sc0 ls8 wseb">这一类事件中最主要的两个是focus和blur，它们都是JavaScript早期就得到所有浏览器支持的</div><div class="t m0 x0 hc y15e ff92 fs2 fc0 sc0 ls8 wseb">事件。这些事件的最大问题是它们不冒泡。因此，IE的focusin和focusout与Opera的DOMFocusIn</div><div class="t m0 x0 h5 ya ff92 fs2 fc0 sc0 ls3b">和DOMFocusOut才会发生重叠。IE的方式最后被DOM3级事件采纳为标准方式。 </div><div class="t m0 x0 h5 yb ff92 fs2 fc0 sc0 ls8 wseb">当焦点从页面中的一个元素移动到另一个元素，会依次触发下列事件： </div><div class="t m0 x0 h5 y78a ff8b fs2 fc0 sc0 ls5a ws4f">(1) focusout在失去焦点的元素上触发； </div><div class="t m0 x0 h5 yd ff8b fs2 fc0 sc0 ls13 wsb">(2) focusin在获得焦点的元素上触发； </div><div class="t m0 x0 h5 y21b ff8b fs2 fc0 sc0 ls13 wsb">(3) blur在失去焦点的元素上触发； </div><div class="t m0 x0 h5 y21c ff8b fs2 fc0 sc0 ls13 wsb">(4) DOMFocusOut在失去焦点的元素上触发； </div><div class="t m0 x0 h5 y10 ff8b fs2 fc0 sc0 ls13 wsb">(5) focus在获得焦点的元素上触发； </div><div class="t m0 x0 h5 y11 ff8b fs2 fc0 sc0 ls13 wsb">(6) DOMFocusIn在获得焦点的元素上触发。 </div><div class="t m0 x0 h4 y1a57 ff92 fs2 fc0 sc0 ls8 wseb">其中，blur、DOMFocusOut和focusout的事件目标是失去焦点的元素；而focus、DOMFocusIn</div><div class="t m0 x0 h5 y13 ff92 fs2 fc0 sc0 ls2c">和focusin的事件目标是获得焦点的元素。 </div><div class="t m0 x0 h5 y14 ff92 fs2 fc0 sc0 ls8 wseb">要确定浏览器是否支持这些事件，可以使用如下代码： </div><div class="t m0 x0 hb y1198 ff96 fs6 fc0 sc0 ls21 wsb">var isSupported = document.implementation.hasFeature(&quot;FocusEvent&quot;, &quot;3.0&quot;); </div><div class="t m0 x5 h5 y793 ff8c fs2 fc0 sc0 ls1f ws3b">即使focus和blur不冒泡，也可以在捕获阶段侦听到它们。Peter-Paul Koch就此</div><div class="t m0 x0 h5 y2745 ff8c fs2 fc0 sc0 ls1f">写过一篇非常棒的文章：www.quirksmode.org/blog/archives/2008/04/delegating_the.html。 </div><div class="t m0 x0 h20 y2746 ff90 fs3 fc0 sc0 ls248 ws214">13.4.3 鼠标与滚轮事件 </div><div class="t m0 x0 h5 y469 ff92 fs2 fc0 sc0 ls8 wseb">鼠标事件是Web开发中最常用的一类事件，毕竟鼠标还是最主要的定位设备。DOM3 级事件中定</div><div class="t m0 x0 h5 y18dc ff92 fs2 fc0 sc0 ls8 wseb">义了9个鼠标事件，简介如下。 </div><div class="t m0 x0 h4 y46b ff91 fs1 fc0 sc0 ls2"> click：在用户单击主鼠标按钮（一般是左边的按钮）或者按下回车键时触发。这一点对确保</div><div class="t m0 x0 hc y2747 ff92 fs2 fc0 sc0 ls8 wseb">易访问性很重要，意味着onclick事件处理程序既可以通过键盘也可以通过鼠标执行。 </div><div class="t m0 x0 h4 y2a8 ff91 fs1 fc0 sc0 ls2"> dblclick：在用户双击主鼠标按钮（一般是左边的按钮）时触发。从技术上说，这个事件并不</div><div class="t m0 x0 h5 y2748 ff92 fs2 fc0 sc0 ls3b">是DOM2级事件规范中规定的，但鉴于它得到了广泛支持，所以DOM3级事件将其纳入了标准。 </div><div class="t m0 x0 h5 y46e ff91 fs1 fc0 sc0 ls2"> mousedown：在用户按下了任意鼠标按钮时触发。不能通过键盘触发这个事件。 </div><div class="t m0 x0 h4 y46f ff91 fs1 fc0 sc0 ls2"> mouseenter：在鼠标光标从元素外部首次移动到元素范围之内时触发。这个事件不冒泡，而且</div><div class="t m0 x0 h5 y2749 ff92 fs2 fc0 sc0 ls8 wseb">在光标移动到后代元素上不会触发。DOM2级事件并没有定义这个事件，但DOM3级事件将它</div><div class="t m0 x0 h5 y274a ff92 fs2 fc0 sc0 ls8 wseb">纳入了规范。IE、Firefox 9+和Opera支持这个事件。 </div><div class="t m0 x0 h4 y274b ff91 fs1 fc0 sc0 ls2"> mouseleave：在位于元素上方的鼠标光标移动到元素范围之外时触发。这个事件不冒泡，而且</div><div class="t m0 x0 h5 y274c ff92 fs2 fc0 sc0 ls8 wseb">在光标移动到后代元素上不会触发。DOM2级事件并没有定义这个事件，但DOM3级事件将它</div><div class="t m0 x0 h5 y274d ff92 fs2 fc0 sc0 ls8 wseb">纳入了规范。IE、Firefox 9+和Opera支持这个事件。 </div><div class="t m0 x0 h21 y274e ff91 fs1 fc0 sc0 ls2"> mousemove：当鼠标指针在元素内部移动时重复地触发。不能通过键盘触发这个事件。 </div></div></div>
<div id="pf183" class="pf w0 h0" data-page-no="183"><div class="pc pc183 w0 h0"><div class="t m0 x2 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">13.4 事件类型    369 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff8d fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff8d fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff8d fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff8d fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff8d fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff8d fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff8d fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff8d fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff8d fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff8d fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff8d fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff8d fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff8d fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h4 y3 ff91 fs1 fc0 sc0 ls8 ws134"> mouseout：在鼠标指针位于一个元素上方，然后用户将其移入另一个元素时触发。又移入的另</div><div class="t m0 x5 h5 y4d ff92 fs2 fc0 sc0 ls42 wsf0">一个元素可能位于前一个元素的外部，也可能是这个元素的子元素。不能通过键盘触发这个事件。 </div><div class="t m0 x0 h4 y4e ff91 fs1 fc0 sc0 ls2"> mouseover：在鼠标指针位于一个元素外部，然后用户将其首次移入另一个元素边界之内时触</div><div class="t m0 x5 h5 yd9 ff92 fs2 fc0 sc0 ls8 wseb">发。不能通过键盘触发这个事件。 </div><div class="t m0 x0 h5 y219 ff91 fs1 fc0 sc0 ls2"> mouseup：在用户释放鼠标按钮时触发。不能通过键盘触发这个事件。 </div><div class="t m0 x0 h1e y21a ff92 fs2 fc0 sc0 ls8 wseb">页面上的所有元素都支持鼠标事件。除了mouseenter和mouseleave，所有鼠标事件都会冒泡，</div><div class="t m0 x0 h4 y15e ff92 fs2 fc0 sc0 ls8 wseb">也可以被取消，而取消鼠标事件将会影响浏览器的默认行为。取消鼠标事件的默认行为还会影响其他事</div><div class="t m0 x0 h5 y1561 ff92 fs2 fc0 sc0 ls8 wseb">件，因为鼠标事件与其他事件是密不可分的关系。 </div><div class="t m0 x0 h1c y1562 ff92 fs2 fc0 sc0 ls57 ws151">只有在同一个元素上相继触发mousedown和mouseup 事件，才会触发click事件；如果</div><div class="t m0 x0 h4 yc ff96 fs1 fc0 sc0 ls9 ws2">mousedown或mouseup中的一个被取消，就不会触发click事件。类似地，只有触发两次 click事</div><div class="t m0 x0 h1e y116b ff92 fs2 fc0 sc0 ls8 wseb">件，才会触发一次dblclick事件。如果有代码阻止了连续两次触发click事件（可能是直接取消click</div><div class="t m0 x0 h5 y21b ff92 fs2 fc0 sc0 ls8 wseb">事件，也可能通过取消mousedown或mouseup间接实现），那么就不会触发dblclick事件了。这 4</div><div class="t m0 x0 h5 y21c ff92 fs2 fc0 sc0 ls8 wseb">个事件触发的顺序始终如下： </div><div class="t m0 x0 h5 y274f ff8b fs2 fc0 sc0 ls5a ws4f">(1) mousedown </div><div class="t m0 x0 h5 y99d ff8b fs2 fc0 sc0 ls13 wsb">(2) mouseup </div><div class="t m0 x0 h5 y26b3 ff8b fs2 fc0 sc0 ls13 wsb">(3) click </div><div class="t m0 x0 h5 y2750 ff8b fs2 fc0 sc0 ls13 wsb">(4) mousedown </div><div class="t m0 x0 h5 y2751 ff8b fs2 fc0 sc0 ls13 wsb">(5) mouseup </div><div class="t m0 x0 h5 y2752 ff8b fs2 fc0 sc0 ls13 wsb">(6) click </div><div class="t m0 x0 h5 y2753 ff8b fs2 fc0 sc0 ls13 wsb">(7) dblclick </div><div class="t m0 x0 hd8 y2754 ff92 fs2 fc0 sc0 ls8 wseb">显然，click和dblclick事件都会依赖于其他先行事件的触发；而mousedown 和mouseup则</div><div class="t m0 x0 h5 y2755 ff92 fs2 fc0 sc0 ls8 wseb">不受其他事件的影响。 </div><div class="t m0 x0 h5 y2756 ff8b fs2 fc0 sc0 ls2a ws21">IE8及之前版本中的实现有一个小bug，因此在双击事件中，会跳过第二个mousedown 和click</div><div class="t m0 x0 h5 y2a2 ff92 fs2 fc0 sc0 ls8 wseb">事件，其顺序如下： </div><div class="t m0 x0 h5 y2757 ff8b fs2 fc0 sc0 ls5a ws4f">(1) mousedown </div><div class="t m0 x0 h5 y2758 ff8b fs2 fc0 sc0 ls13 wsb">(2) mouseup </div><div class="t m0 x0 h5 y2759 ff8b fs2 fc0 sc0 ls13 wsb">(3) click </div><div class="t m0 x0 h5 y14d3 ff8b fs2 fc0 sc0 ls13 wsb">(4) mouseup </div><div class="t m0 x0 h5 y275a ff8b fs2 fc0 sc0 ls13 wsb">(5) dblclick </div><div class="t m0 x0 h5 y275b ff8b fs2 fc0 sc0 ls2a ws21">IE9修复了这个bug，之后顺序就正确了。 </div><div class="t m0 x0 h5 y275c ff92 fs2 fc0 sc0 ls26 ws101">使用以下代码可以检测浏览器是否支持以上DOM2级事件（除 dbclick、mouseenter和</div><div class="t m0 x0 h5 y275d ff96 fs1 fc0 sc0 ls9 ws2">mouseleave之外）： </div><div class="t m0 x0 hb y1e87 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y275e ff96 fs6 fc0 sc0 ls21 wsb">var isSupported = document.implementation.hasFeature(&quot;MouseEvents&quot;, &quot;2.0&quot;); </div><div class="t m0 x0 hb y275f ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1d54 ff92 fs2 fc0 sc0 ls8 wseb">要检测浏览器是否支持上面的所有事件，可以使用以下代码： </div><div class="t m0 x0 hb y196f ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2760 ff96 fs6 fc0 sc0 ls21 wsb">var isSupported = document.implementation.hasFeature(&quot;MouseEvent&quot;, &quot;3.0&quot;) </div><div class="t m0 x0 hb y2761 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y7f0 ff92 fs2 fc0 sc0 ls8">注意，DOM3级事件的feature名是&quot;MouseEvent&quot;，而非&quot;MouseEvents&quot;。 </div><div class="t m0 x0 h1e y7f1 ff92 fs2 fc0 sc0 ls8 wseb">鼠标事件中还有一类滚轮事件。而说是一类事件，其实就是一个mousewheel事件。这个事件跟踪</div><div class="t m0 x0 h5 y2762 ff92 fs2 fc0 sc0 ls8 wseb">鼠标滚轮，类似于Mac的触控板。 </div></div></div>
<div id="pf184" class="pf w0 h0" data-page-no="184"><div class="pc pc184 w0 h0"><div class="t m0 x0 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">370  第13章 事件 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h3c y68b ff90 fs2 fc0 sc0 ls2e wsb">1. 客户区坐标位置 </div><div class="t m0 x0 h4 y68c ff92 fs2 fc0 sc0 ls8 wseb">鼠标事件都是在浏览器视口中的特定位置上发生的。这个位置信息保存在事件对象的clientX和</div><div class="t m0 x0 h4 y24d4 ff96 fs1 fc0 sc0 ls9 ws2">clientY属性中。所有浏览器都支持这两个属性，它们的值表示事件发生时鼠标指针在视口中的水平</div><div class="t m0 x0 h5 y68e ff92 fs2 fc0 sc0 ls8 wseb">和垂直坐标。图13-4展示了视口中客户区坐标位置的含义。 </div><div class="t m0 x2 h5 y2763 ff8b fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x7 h3 y2764 ff92 fs1 fc0 sc0 ls8 wsb">图 13-4 </div><div class="t m0 x0 h5 y728 ff92 fs2 fc0 sc0 ls8 wseb">可以使用类似下列代码取得鼠标事件的客户端坐标信息： </div><div class="t m0 x0 hb y278 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2765 ff96 fs6 fc0 sc0 ls21 wsb">var div = document.getElementById(&quot;myDiv&quot;); </div><div class="t m0 x0 hb y2766 ff96 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(div, &quot;click&quot;, function(event){ </div><div class="t m0 x0 hb y2767 ff96 fs6 fc0 sc0 ls21 wsb">    event = EventUtil.getEvent(event); </div><div class="t m0 x0 hb y2768 ff96 fs6 fc0 sc0 ls21 wsb">    alert(&quot;Client coordinates: &quot; + event.clientX + &quot;,&quot; + event.clientY);         </div><div class="t m0 x0 hb y2769 ff96 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x2 hf y276a ff97 fs2 fc0 sc0 ls5e wsb">ClientCoordinatesExample01.htm </div><div class="t m0 x0 h4 y1a60 ff92 fs2 fc0 sc0 ls8 wseb">这里为一个&lt;div&gt;元素指定了onclick事件处理程序。当用户单击这个元素时，就会看到事件的</div><div class="t m0 x0 h5 y276b ff92 fs2 fc0 sc0 ls8 wseb">客户端坐标信息。注意，这些值中不包括页面滚动的距离，因此这个位置并不表示鼠标在页面上的位置。 </div><div class="t m0 x0 h3c y276c ff90 fs2 fc0 sc0 ls2e wsb">2. 页面坐标位置 </div><div class="t m0 x0 h4 y276d ff92 fs2 fc0 sc0 ls8 wseb">通过客户区坐标能够知道鼠标是在视口中什么位置发生的，而页面坐标通过事件对象的pageX和</div><div class="t m0 x0 h4 y276e ff96 fs1 fc0 sc0 ls9 ws2">pageY属性，能告诉你事件是在页面中的什么位置发生的。换句话说，这两个属性表示鼠标光标在页面</div><div class="t m0 x0 h5 y276f ff92 fs2 fc0 sc0 ls8 wseb">中的位置，因此坐标是从页面本身而非视口的左边和顶边计算的。 </div><div class="t m0 x0 h5 y18e4 ff92 fs2 fc0 sc0 ls8 wseb">以下代码可以取得鼠标事件在页面中的坐标： </div><div class="t m0 x0 hb y2770 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2771 ff96 fs6 fc0 sc0 ls21 wsb">var div = document.getElementById(&quot;myDiv&quot;); </div><div class="t m0 x0 hb y2772 ff96 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(div, &quot;click&quot;, function(event){ </div><div class="t m0 x0 hb y2773 ff96 fs6 fc0 sc0 ls21 wsb">    event = EventUtil.getEvent(event); </div><div class="t m0 x0 hb y2774 ff96 fs6 fc0 sc0 ls21 wsb">    alert(&quot;Page coordinates: &quot; + event.pageX + &quot;,&quot; + event.pageY); </div><div class="t m0 x0 hb y2775 ff96 fs6 fc0 sc0 ls21 wsb">});  </div><div class="t m0 x2 hf y2776 ff97 fs2 fc0 sc0 ls25 wsb">PageCoordinatesExample01.htm </div><div class="t m0 x2 h36 y2777 ff92 fs6 fc0 sc0 ls31 ws125">客户区 </div></div></div>
<div id="pf185" class="pf w0 h0" data-page-no="185"><div class="pc pc185 w0 h0"><div class="t m0 x2 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">13.4 事件类型    371 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff8d fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff8d fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff8d fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff8d fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff8d fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff8d fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff8d fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff8d fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff8d fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff8d fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff8d fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff8d fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff8d fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff92 fs2 fc0 sc0 ls8 wseb">在页面没有滚动的情况下，pageX和pageY的值与clientX和clientY 的值相等。 </div><div class="t m0 x0 h5 y4d ff8b fs2 fc0 sc0 ls2a ws21">IE8及更早版本不支持事件对象上的页面坐标，不过使用客户区坐标和滚动信息可以计算出来。这</div><div class="t m0 x0 h1c yd8 ff92 fs2 fc0 sc0 ls26 ws101">时候需要用到document.body（混杂模式）或document.documentElement（标准模式）中的</div><div class="t m0 x0 h5 yd9 ff96 fs1 fc0 sc0 ls9 ws2">scrollLeft和scrollTop属性。计算过程如下所示： </div><div class="t m0 x0 hb y28c ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y28d ff96 fs6 fc0 sc0 ls21 wsb">var div = document.getElementById(&quot;myDiv&quot;); </div><div class="t m0 x0 hb y28e ff96 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(div, &quot;click&quot;, function(event){ </div><div class="t m0 x0 hb y28f ff96 fs6 fc0 sc0 ls21 wsb">    event = EventUtil.getEvent(event); </div><div class="t m0 x0 hb y290 ff96 fs6 fc0 sc0 ls21 wsb">    var pageX = event.pageX, </div><div class="t m0 x0 hb y2778 ff96 fs6 fc0 sc0 ls21 wsb">        pageY = event.pageY; </div><div class="t m0 x0 hb y2779 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y277a ff96 fs6 fc0 sc0 ls21 wsb">    if (pageX === undefined){ </div><div class="t m0 x0 hb y277b ff96 fs6 fc0 sc0 ls21 wsb">        pageX = event.clientX + (document.body.scrollLeft || </div><div class="t m0 x0 hb y277c ff96 fs6 fc0 sc0 ls21 wsb">                document.documentElement.scrollLeft); </div><div class="t m0 x0 hb y277d ff96 fs6 fc0 sc0 ls21 wsb">    }  </div><div class="t m0 x0 hb y277e ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y277f ff96 fs6 fc0 sc0 ls21 wsb">    if (pageY === undefined){ </div><div class="t m0 x0 hb y2780 ff96 fs6 fc0 sc0 ls21 wsb">        pageY = event.clientY + (document.body.scrollTop || </div><div class="t m0 x0 hb y2781 ff96 fs6 fc0 sc0 ls21 wsb">                document.documentElement.scrollTop); </div><div class="t m0 x0 hb y2782 ff96 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y2783 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2784 ff96 fs6 fc0 sc0 ls21 wsb">    alert(&quot;Page coordinates: &quot; + pageX + &quot;,&quot; + pageY); </div><div class="t m0 x0 hb y2785 ff96 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 hb y2786 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y2787 ff97 fs2 fc0 sc0 ls25 wsb">PageCoordinatesExample01.htm </div><div class="t m0 x0 h3c y2788 ff90 fs2 fc0 sc0 ls2e wsb">3. 屏幕坐标位置 </div><div class="t m0 x0 h4 y2789 ff92 fs2 fc0 sc0 ls8 wseb">鼠标事件发生时，不仅会有相对于浏览器窗口的位置，还有一个相对于整个电脑屏幕的位置。而通</div><div class="t m0 x0 h54 y278a ff92 fs2 fc0 sc0 ls32b">过screenX和screenY属性就可以确定鼠标事件发生时鼠标指针相对于整个屏幕的坐标信息。图13-5</div><div class="t m0 x0 h5 y278b ff92 fs2 fc0 sc0 ls8 wseb">展示了浏览器中屏幕坐标的含义。 </div><div class="t m0 x2 h5 y278c ff8b fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 h3 y2776 ff92 fs1 fc0 sc0 ls8 wsb">图 13-5 </div></div></div>
<div id="pf186" class="pf w0 h0" data-page-no="186"><div class="pc pc186 w0 h0"><div class="t m0 x0 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">372  第13章 事件 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff92 fs2 fc0 sc0 ls8 wseb">可以使用类似下面的代码取得鼠标事件的屏幕坐标： </div><div class="t m0 x0 hb yfb2 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yfb3 ff96 fs6 fc0 sc0 ls21 wsb">var div = document.getElementById(&quot;myDiv&quot;); </div><div class="t m0 x0 hb yfb4 ff96 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(div, &quot;click&quot;, function(event){ </div><div class="t m0 x0 hb yfb5 ff96 fs6 fc0 sc0 ls21 wsb">    event = EventUtil.getEvent(event); </div><div class="t m0 x0 h15 yfb6 ff99 fs6 fc0 sc0 ls21 wsb">    alert(&quot;Screen coordinates: &quot; + event.screenX + &quot;,&quot; + event.screenY);         </div><div class="t m0 x0 hb yfb7 ff96 fs6 fc0 sc0 ls21 wsb">});  </div><div class="t m0 x2 hf y1707 ff97 fs2 fc0 sc0 ls138 wsb">ScreenCoordinatesExample01.htm </div><div class="t m0 x0 h4 y278e ff92 fs2 fc0 sc0 ls8 wseb">与前一个例子类似，这里也是为&lt;div&gt;元素指定了一个onclick事件处理程序。当这个元素被单</div><div class="t m0 x0 h5 y870 ff92 fs2 fc0 sc0 ls8 wseb">击时，就会显示出事件的屏幕坐标信息了。 </div><div class="t m0 x0 h3c y278f ff90 fs2 fc0 sc0 ls2e wsb">4. 修改键 </div><div class="t m0 x0 h4 y2790 ff92 fs2 fc0 sc0 ls8 wseb">虽然鼠标事件主要是使用鼠标来触发的，但在按下鼠标时键盘上的某些键的状态也可以影响到所要</div><div class="t m0 x0 h5 y2791 ff92 fs2 fc0 sc0 ls8 wseb">采取的操作。这些修改键就是Shift、Ctrl、Alt和Meta（在Windows键盘中是Windows键，在苹果机中</div><div class="t m0 x0 h5 y2792 ff92 fs2 fc0 sc0 ls2ab">是Cmd键），它们经常被用来修改鼠标事件的行为。DOM为此规定了4个属性，表示这些修改键的状</div><div class="t m0 x0 hb2 y2793 ff92 fs2 fc0 sc0 ls8 wseb">态：shiftKey、ctrlKey、altKey和metaKey。这些属性中包含的都是布尔值，如果相应的键被按</div><div class="t m0 x0 h1e y2794 ff92 fs2 fc0 sc0 ls8 wseb">下了，则值为true，否则值为false。当某个鼠标事件发生时，通过检测这几个属性就可以确定用户</div><div class="t m0 x0 h5 y2795 ff92 fs2 fc0 sc0 ls8 wseb">是否同时按下了其中的键。来看下面的例子。 </div><div class="t m0 x0 hb y66f ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2796 ff96 fs6 fc0 sc0 ls21 wsb">var div = document.getElementById(&quot;myDiv&quot;); </div><div class="t m0 x0 hb y2797 ff96 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(div, &quot;click&quot;, function(event){ </div><div class="t m0 x0 hb y2798 ff96 fs6 fc0 sc0 ls21 wsb">    event = EventUtil.getEvent(event); </div><div class="t m0 x0 hb y2799 ff96 fs6 fc0 sc0 ls21 wsb">    var keys = new Array(); </div><div class="t m0 x0 hb y279a ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y279b ff96 fs6 fc0 sc0 ls21 wsb">    if (event.shiftKey){ </div><div class="t m0 x0 hb y279c ff96 fs6 fc0 sc0 ls21 wsb">        keys.push(&quot;shift&quot;); </div><div class="t m0 x0 hb y279d ff96 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y279e ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y279f ff96 fs6 fc0 sc0 ls21 wsb">    if (event.ctrlKey){ </div><div class="t m0 x0 hb y27a0 ff96 fs6 fc0 sc0 ls21 wsb">        keys.push(&quot;ctrl&quot;); </div><div class="t m0 x0 hb y27a1 ff96 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y27a2 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y27a3 ff96 fs6 fc0 sc0 ls21 wsb">    if (event.altKey){ </div><div class="t m0 x0 hb y27a4 ff96 fs6 fc0 sc0 ls21 wsb">        keys.push(&quot;alt&quot;); </div><div class="t m0 x0 hb y27a5 ff96 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y27a6 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y27a7 ff96 fs6 fc0 sc0 ls21 wsb">    if (event.metaKey){ </div><div class="t m0 x0 hb y27a8 ff96 fs6 fc0 sc0 ls21 wsb">        keys.push(&quot;meta&quot;); </div><div class="t m0 x0 hb y27a9 ff96 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y27aa ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y27ab ff96 fs6 fc0 sc0 ls21 wsb">    alert(&quot;Keys: &quot; + keys.join(&quot;,&quot;)); </div><div class="t m0 x0 hb y27ac ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y27ad ff96 fs6 fc0 sc0 ls21 wsb">});  </div><div class="t m0 x2 hf y27ae ff97 fs2 fc0 sc0 ls8 wsb">ModifierKeysExample01.htm </div><div class="t m0 x0 h4 y1903 ff92 fs2 fc0 sc0 ls8 wseb">在这个例子中，我们通过一个onclick事件处理程序检测了不同修改键的状态。数组keys 中包</div><div class="t m0 x0 h1e y27af ff92 fs2 fc0 sc0 ls8 wseb">含着被按下的修改键的名称。换句话说，如果有属性值为true，就会将对应修改键的名称添加到keys</div><div class="t m0 x0 h5 y27b0 ff92 fs2 fc0 sc0 ls8 wseb">数组中。在事件处理程序的最后，有一个警告框将检测到的键的信息显示给用户。 </div><div class="t m0 x0 h5 y27b1 ff8b fs2 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf187" class="pf w0 h0" data-page-no="187"><div class="pc pc187 w0 h0"><div class="t m0 x2 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">13.4 事件类型    373 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff8d fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff8d fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff8d fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff8d fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff8d fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff8d fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff8d fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff8d fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff8d fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff8d fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff8d fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff8d fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff8d fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y70f ff8b fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x5 h5 y945 ff8b fs2 fc0 sc0 ls2a ws21">IE9、Firefox、Safari、Chrome和Opera都支持这4个键。IE8及之前版本不支持</div><div class="t m0 x5 h5 y27b2 ff99 fs1 fc0 sc0 ls9 ws2">metaKey属性。 </div><div class="t m0 x0 h3c y27b3 ff90 fs2 fc0 sc0 ls2e wsb">5. 相关元素 </div><div class="t m0 x0 h4 y27b4 ff92 fs2 fc0 sc0 ls8 wseb">在发生mouseover和mouserout事件时，还会涉及更多的元素。这两个事件都会涉及把鼠标指</div><div class="t m0 x0 h1e y27b5 ff92 fs2 fc0 sc0 ls8 wseb">针从一个元素的边界之内移动到另一个元素的边界之内。对mouseover事件而言，事件的主目标是获</div><div class="t m0 x0 h1e y27b6 ff92 fs2 fc0 sc0 ls8 wseb">得光标的元素，而相关元素就是那个失去光标的元素。类似地，对mouseout事件而言，事件的主目标</div><div class="t m0 x0 h5 y126f ff92 fs2 fc0 sc0 ls8 wseb">是失去光标的元素，而相关元素则是获得光标的元素。来看下面的例子。 </div><div class="t m0 x5 hb y27b7 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y27b8 ff96 fs6 fc0 sc0 ls21 wsb">&lt;!DOCTYPE html&gt; </div><div class="t m0 x0 hb y27b9 ff96 fs6 fc0 sc0 ls21 wsb">&lt;html&gt; </div><div class="t m0 x0 hb y27ba ff96 fs6 fc0 sc0 ls21 wsb">&lt;head&gt; </div><div class="t m0 x0 hb y27bb ff96 fs6 fc0 sc0 ls21 wsb">    &lt;title&gt;Related Elements Example&lt;/title&gt; </div><div class="t m0 x0 hb y27bc ff96 fs6 fc0 sc0 ls21 wsb">&lt;/head&gt; </div><div class="t m0 x0 hb y27bd ff96 fs6 fc0 sc0 ls21 wsb">&lt;body&gt; </div><div class="t m0 x0 hb y27be ff96 fs6 fc0 sc0 ls21 wsb">    &lt;div id=&quot;myDiv&quot; style=&quot;background-color:red;height:100px;width:100px;&quot;&gt;&lt;/div&gt; </div><div class="t m0 x0 hb y27bf ff96 fs6 fc0 sc0 ls21 wsb">&lt;/body&gt; </div><div class="t m0 x0 hb y27c0 ff96 fs6 fc0 sc0 ls21 wsb">&lt;/html&gt; </div><div class="t m0 x5 hb y27c1 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y27c2 ff97 fs2 fc0 sc0 ls1b wsb">RelatedElementsExample01.htm </div><div class="t m0 x0 h4 y364 ff92 fs2 fc0 sc0 ls6 wsf7">这个例子会在页面上显示一个&lt;div&gt;元素。如果鼠标指针一开始位于这个&lt;div&gt;元素上，然后移出</div><div class="t m0 x0 h1e y27c3 ff92 fs2 fc0 sc0 ls8 wseb">了这个元素，那么就会在&lt;div&gt;元素上触发mouseout事件，相关元素就是&lt;body&gt;元素。与此同时，</div><div class="t m0 x0 h5 y27c4 ff96 fs1 fc0 sc0 ls9 ws2">&lt;body&gt;元素上面会触发mouseover事件，而相关元素变成了&lt;div&gt;。 </div><div class="t m0 x0 h5 y27c5 ff8b fs2 fc0 sc0 ls194 ws150">DOM通过event对象的relatedTarget属性提供了相关元素的信息。这个属性只对于mouseover</div><div class="t m0 x0 h5 y27c6 ff92 fs2 fc0 sc0 ls32c">和mouseout事件才包含值；对于其他事件，这个属性的值是null。IE8及之前版本不支持relatedTarget</div><div class="t m0 x0 h5 y2c5 ff92 fs2 fc0 sc0 ls1f ws108">属性，但提供了保存着同样信息的不同属性。在mouseover事件触发时，IE的fromElement属性中保</div><div class="t m0 x0 hc y2c6 ff92 fs2 fc0 sc0 ls1f ws108">存了相关元素；在mouseout事件触发时，IE的toElement属性中保存着相关元素。（IE9支持所有这些</div><div class="t m0 x0 h5 y27c7 ff92 fs2 fc0 sc0 ls1f ws108">属性。）可以把下面这个跨浏览器取得相关元素的方法添加到EventUtil对象中。 </div><div class="t m0 x5 hb y27c8 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y27c9 ff96 fs6 fc0 sc0 ls21 wsb">var EventUtil = { </div><div class="t m0 x0 hb y27ca ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y27cb ff96 fs6 fc0 sc0 ls21 wsb">    //省略了其他代码 </div><div class="t m0 x0 hb y27cc ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y27cd ff99 fs6 fc0 sc0 ls21 wsb">    getRelatedTarget: function(event){ </div><div class="t m0 x0 h15 y27ce ff99 fs6 fc0 sc0 ls21 wsb">        if (event.relatedTarget){ </div><div class="t m0 x0 h15 y27cf ff99 fs6 fc0 sc0 ls21 wsb">            return event.relatedTarget; </div><div class="t m0 x0 h15 y27d0 ff99 fs6 fc0 sc0 ls21 wsb">        } else if (event.toElement){ </div><div class="t m0 x0 h15 y27d1 ff99 fs6 fc0 sc0 ls21 wsb">            return event.toElement; </div><div class="t m0 x0 h15 y27d2 ff99 fs6 fc0 sc0 ls21 wsb">        } else if (event.fromElement){ </div><div class="t m0 x0 h15 y27d3 ff99 fs6 fc0 sc0 ls21 wsb">            return event.fromElement; </div><div class="t m0 x0 h15 y27d4 ff99 fs6 fc0 sc0 ls21 wsb">        } else { </div><div class="t m0 x0 h15 y27d5 ff99 fs6 fc0 sc0 ls21 wsb">            return null; </div><div class="t m0 x0 h15 y27d6 ff99 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 h15 y27d7 ff99 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 h15 y27d8 ff99 fs6 fc0 sc0 ls21 wsb">    }, </div><div class="t m0 x0 hb y27d9 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y27da ff96 fs6 fc0 sc0 ls21 wsb">    //省略了其他代码 </div><div class="t m0 x0 hb y27db ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y27dc ff96 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x6 hf y27dd ff97 fs2 fc0 sc0 ls2b wsb">EventUtil.js </div></div></div>
<div id="pf188" class="pf w0 h0" data-page-no="188"><div class="pc pc188 w0 h0"><div class="t m0 x0 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">374  第13章 事件 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ff92 fs2 fc0 sc0 ls8 wseb">与以前添加的跨浏览器方法一样，这个方法也使用了特性检测来确定返回哪个值。可以像下面这样</div><div class="t m0 x0 hc y4d ff92 fs2 fc0 sc0 ls8 wseb">使用EventUtil.getRelatedTarget()方法： </div><div class="t m0 x0 hb y113c ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y27de ff96 fs6 fc0 sc0 ls21 wsb">var div = document.getElementById(&quot;myDiv&quot;); </div><div class="t m0 x0 hb y27df ff96 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(div, &quot;mouseout&quot;, function(event){ </div><div class="t m0 x0 hb y27e0 ff96 fs6 fc0 sc0 ls21 wsb">    event = EventUtil.getEvent(event); </div><div class="t m0 x0 hb y27e1 ff96 fs6 fc0 sc0 ls21 wsb">    var target = EventUtil.getTarget(event); </div><div class="t m0 x0 hb y27e2 ff96 fs6 fc0 sc0 ls21 wsb">    var relatedTarget = EventUtil.getRelatedTarget(event); </div><div class="t m0 x0 hb y27e3 ff96 fs6 fc0 sc0 ls21 wsb">    alert(&quot;Moused out of &quot; + target.tagName + &quot; to &quot; + relatedTarget.tagName);         </div><div class="t m0 x0 hb y27e4 ff96 fs6 fc0 sc0 ls21 wsb">});   </div><div class="t m0 x2 hf y27e5 ff97 fs2 fc0 sc0 ls1b wsb">RelatedElementsExample01.htm </div><div class="t m0 x0 h4 y27e6 ff92 fs2 fc0 sc0 ls8 wseb">这个例子为&lt;div&gt;元素的mouseout事件注册了一个事件处理程序。当事件触发时，会有一个警告</div><div class="t m0 x0 h5 y27e7 ff92 fs2 fc0 sc0 ls8 wseb">框显示鼠标移出和移入的元素信息。 </div><div class="t m0 x0 h3c y27e8 ff90 fs2 fc0 sc0 ls2e wsb">6. 鼠标按钮 </div><div class="t m0 x0 h4 y27e9 ff92 fs2 fc0 sc0 ls8 wseb">只有在主鼠标按钮被单击（或键盘回车键被按下）时才会触发click事件，因此检测按钮的信息</div><div class="t m0 x0 h4 y1913 ff92 fs2 fc0 sc0 ls8 wseb">并不是必要的。但对于mousedown和mouseup事件来说，则在其event对象存在一个 button属性，</div><div class="t m0 x0 hc y1914 ff92 fs2 fc0 sc0 ls8 wseb">表示按下或释放的按钮。DOM的button属性可能有如下3个值：0表示主鼠标按钮，1表示中间的鼠</div><div class="t m0 x0 h1e y1915 ff92 fs2 fc0 sc0 ls6 wsf7">标按钮（鼠标滚轮按钮），2表示次鼠标按钮。在常规的设置中，主鼠标按钮就是鼠标左键，而次鼠标</div><div class="t m0 x0 h5 y27ea ff92 fs2 fc0 sc0 ls8 wseb">按钮就是鼠标右键。 </div><div class="t m0 x0 hc y27eb ff8b fs2 fc0 sc0 ls2a ws21">IE8及之前版本也提供了button属性，但这个属性的值与DOM的button 属性有很大差异。 </div><div class="t m0 x0 h5 y1604 ff91 fs1 fc0 sc0 ls2"> 0：表示没有按下按钮。 </div><div class="t m0 x0 h5 y27ec ff91 fs1 fc0 sc0 ls2"> 1：表示按下了主鼠标按钮。 </div><div class="t m0 x0 h5 y1a75 ff91 fs1 fc0 sc0 ls2"> 2：表示按下了次鼠标按钮。 </div><div class="t m0 x0 h5 y1a76 ff91 fs1 fc0 sc0 ls2"> 3：表示同时按下了主、次鼠标按钮。 </div><div class="t m0 x0 h5 y807 ff91 fs1 fc0 sc0 ls2"> 4：表示按下了中间的鼠标按钮。 </div><div class="t m0 x0 h5 y27ed ff91 fs1 fc0 sc0 ls2"> 5：表示同时按下了主鼠标按钮和中间的鼠标按钮。 </div><div class="t m0 x0 h5 y1a79 ff91 fs1 fc0 sc0 ls2"> 6：表示同时按下了次鼠标按钮和中间的鼠标按钮。 </div><div class="t m0 x0 h5 y27ee ff91 fs1 fc0 sc0 ls2"> 7：表示同时按下了三个鼠标按钮。 </div><div class="t m0 x0 h5 y27ef ff92 fs2 fc0 sc0 ls8 wseb">不难想见，DOM模型下的button属性比IE模型下的 button属性更简单也更为实用，因为同时</div><div class="t m0 x0 h5 y27f0 ff92 fs2 fc0 sc0 ls8 wseb">按下多个鼠标按钮的情形十分罕见。最常见的做法就是将IE模型规范化为DOM方式，毕竟除IE8及更</div><div class="t m0 x0 h5 y27f1 ff92 fs2 fc0 sc0 ls8 wseb">早版本之外的其他浏览器都原生支持DOM模型。而对主、中、次按钮的映射并不困难，只要将IE的其</div><div class="t m0 x0 h4 y27f2 ff92 fs2 fc0 sc0 ls8 wseb">他选项分别转换成如同按下这三个按键中的一个即可（同时将主按钮作为优先选取的对象）。换句话说，</div><div class="t m0 x0 h14 y27f3 ff8b fs2 fc0 sc0 lse ws9">IE中返回的5和7会被转换成DOM模型中的0。 </div><div class="t m0 x0 h1e y27f4 ff92 fs2 fc0 sc0 ls8 wseb">由于单独使用能力检测无法确定差异（两种模型有同名的button属性），因此必须另辟蹊径。我</div><div class="t m0 x0 h5 y512 ff92 fs2 fc0 sc0 ls26 ws101">们知道，支持DOM版鼠标事件的浏览器可以通过 hasFearture()方法来检测，所以可以再为</div><div class="t m0 x0 h5 y1b03 ff96 fs1 fc0 sc0 ls9 ws2">EventUtil对象添加如下getButton()方法。 </div><div class="t m0 x0 hb y27f5 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y27f6 ff96 fs6 fc0 sc0 ls21 wsb">var EventUtil = { </div><div class="t m0 x0 hb y27f7 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y27f8 ff96 fs6 fc0 sc0 ls21 wsb">    //省略了其他代码 </div><div class="t m0 x0 hb y27f9 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y27fa ff99 fs6 fc0 sc0 ls21 wsb">    getButton: function(event){ </div><div class="t m0 x0 h15 y27fb ff99 fs6 fc0 sc0 ls21 wsb">        if (document.implementation.hasFeature(&quot;MouseEvents&quot;, &quot;2.0&quot;)){ </div><div class="t m0 x0 h15 y27fc ff99 fs6 fc0 sc0 ls21 wsb">            return event.button; </div></div></div>
<div id="pf189" class="pf w0 h0" data-page-no="189"><div class="pc pc189 w0 h0"><div class="t m0 x2 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">13.4 事件类型    375 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff8d fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff8d fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff8d fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff8d fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff8d fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff8d fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff8d fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff8d fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff8d fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff8d fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff8d fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff8d fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff8d fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h15 y79 ff99 fs6 fc0 sc0 ls21 wsb">        } else { </div><div class="t m0 x0 h15 y7a ff99 fs6 fc0 sc0 ls21 wsb">            switch(event.button){ </div><div class="t m0 x0 h15 y7b ff99 fs6 fc0 sc0 ls21 wsb">                case 0: </div><div class="t m0 x0 h15 y7c ff99 fs6 fc0 sc0 ls21 wsb">                case 1: </div><div class="t m0 x0 h15 y7d ff99 fs6 fc0 sc0 ls21 wsb">                case 3: </div><div class="t m0 x0 h15 y7e ff99 fs6 fc0 sc0 ls21 wsb">                case 5: </div><div class="t m0 x0 h15 y7f ff99 fs6 fc0 sc0 ls21 wsb">                case 7: </div><div class="t m0 x0 h15 y80 ff99 fs6 fc0 sc0 ls21 wsb">                    return 0; </div><div class="t m0 x0 h15 y81 ff99 fs6 fc0 sc0 ls21 wsb">                case 2: </div><div class="t m0 x0 h15 y82 ff99 fs6 fc0 sc0 ls21 wsb">                case 6: </div><div class="t m0 x0 h15 y83 ff99 fs6 fc0 sc0 ls21 wsb">                    return 2; </div><div class="t m0 x0 h15 y84 ff99 fs6 fc0 sc0 ls21 wsb">                case 4:  </div><div class="t m0 x0 h15 y85 ff99 fs6 fc0 sc0 ls21 wsb">                    return 1; </div><div class="t m0 x0 h15 y86 ff99 fs6 fc0 sc0 ls21 wsb">            } </div><div class="t m0 x0 h15 y87 ff99 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 h15 y88 ff99 fs6 fc0 sc0 ls21 wsb">    }, </div><div class="t m0 x0 hb y89 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y8a ff96 fs6 fc0 sc0 ls21 wsb">    //省略了其他代码 </div><div class="t m0 x0 hb y1823 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1824 ff96 fs6 fc0 sc0 ls21 wsb">};  </div><div class="t m0 x6 hf y27fd ff97 fs2 fc0 sc0 ls2b wsb">EventUtil.js </div><div class="t m0 x0 h4 y27fe ff92 fs2 fc0 sc0 ls8 wseb">通过检测&quot;MouseEvents&quot;这个特性，就可以确定event对象中存在的button属性中是否包含正</div><div class="t m0 x0 h5 y790 ff92 fs2 fc0 sc0 ls8 wseb">确的值。如果测试失败，说明是IE，就必须对相应的值进行规范化。以下是使用该方法的示例。 </div><div class="t m0 x5 hb y1f85 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1f86 ff96 fs6 fc0 sc0 ls21 wsb">var div = document.getElementById(&quot;myDiv&quot;); </div><div class="t m0 x0 h15 y27ff ff99 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(div, &quot;mousedown&quot;, function(event){ </div><div class="t m0 x0 h15 y2800 ff99 fs6 fc0 sc0 ls21 wsb">    event = EventUtil.getEvent(event); </div><div class="t m0 x0 h15 y2801 ff99 fs6 fc0 sc0 ls21 wsb">    alert(EventUtil.getButton(event)); </div><div class="t m0 x0 h15 y2802 ff99 fs6 fc0 sc0 ls21 wsb">});  </div><div class="t m0 x2 hf y2803 ff97 fs2 fc0 sc0 ls7a wsb">ButtonExample01.htm </div><div class="t m0 x0 h4 y2804 ff92 fs2 fc0 sc0 ls8 wseb">在这个例子中，我们为一个&lt;div&gt;元素添加了一个onmousedown事件处理程序。当在这个元素上</div><div class="t m0 x0 h5 y2805 ff92 fs2 fc0 sc0 ls8 wseb">按下鼠标按钮时，会有警告框显示按钮的代码。 </div><div class="t m0 x5 h60 y2806 ff8c fs2 fc0 sc0 ls8 ws14">在使用onmouseup事件处理程序时，button的值表示释放的是哪个按钮。此</div><div class="t m0 x5 h5 y2807 ff8c fs2 fc0 sc0 ls5 wsd7">外，如果不是按下或释放了主鼠标按钮，Opera不会触发mouseup 或mousedown </div><div class="t m0 x5 h5 y2808 ff8c fs2 fc0 sc0 ls8">事件。 </div><div class="t m0 x0 h3c y2809 ff90 fs2 fc0 sc0 ls2e wsb">7. 更多的事件信息 </div><div class="t m0 x0 h5 y280a ff92 fs2 fc0 sc0 ls8">“DOM2级事件”规范在event对象中还提供了detail属性，用于给出有关事件的更多信息。对</div><div class="t m0 x0 h4 y1a63 ff92 fs2 fc0 sc0 ls8 wseb">于鼠标事件来说，detail中包含了一个数值，表示在给定位置上发生了多少次单击。在同一个元素上</div><div class="t m0 x0 h1e y300 ff92 fs2 fc0 sc0 ls8 wseb">相继地发生一次mousedown和一次mouseup事件算作一次单击。detail 属性从1开始计数，每次单</div><div class="t m0 x0 hc y280b ff92 fs2 fc0 sc0 ls5f ws10b">击发生后都会递增。如果鼠标在mousedown和mouseup之间移动了位置，则detail 会被重置为0。 </div><div class="t m0 x0 h5 y280c ff8b fs2 fc0 sc0 lse ws9">IE也通过下列属性为鼠标事件提供了更多信息。 </div><div class="t m0 x0 h5 y12de ff91 fs1 fc0 sc0 ls8 ws134"> altLeft：布尔值，表示是否按下了Alt键。如果altLeft的值为true，则altKey的值也为true。 </div><div class="t m0 x0 h5 y1aca ff91 fs1 fc0 sc0 ls2"> ctrlLeft：布尔值，表示是否按下了Ctrl键。如果ctrlLeft的值为true，则 ctrlKey的值</div><div class="t m0 x5 hc5 y2730 ff92 fs2 fc0 sc0 ls8 wseb">也为true。 </div></div></div>
<div id="pf18a" class="pf w0 h0" data-page-no="18a"><div class="pc pc18a w0 h0"><div class="t m0 x0 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">376  第13章 事件 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff91 fs1 fc0 sc0 ls2"> offsetX：光标相对于目标元素边界的x坐标。 </div><div class="t m0 x0 h5 y4 ff91 fs1 fc0 sc0 ls2"> offsetY：光标相对于目标元素边界的y坐标。 </div><div class="t m0 x0 h5 y4e ff91 fs1 fc0 sc0 ls2"> shiftLeft：布尔值，表示是否按下了Shift键。如果shiftLeft的值为true，则 shiftKey</div><div class="t m0 x0 h5 yd9 ff92 fs2 fc0 sc0 ls8 wseb">的值也为true。 </div><div class="t m0 x0 h5 y15d ff92 fs2 fc0 sc0 ls8 wseb">这些属性的用处并不大，原因一方面是只有IE支持它们，另一方是它们提供的信息要么没有什么</div><div class="t m0 x0 h5 y2b3 ff92 fs2 fc0 sc0 ls8 wseb">价值，要么可以通过其他方式计算得来。 </div><div class="t m0 x0 h3c y280d ff90 fs2 fc0 sc0 ls2e wsb">8. 鼠标滚轮事件 </div><div class="t m0 x0 hda y280e ff8b fs2 fc0 sc0 ls84 ws2d5">IE 6.0首先实现了mousewheel事件。此后，Opera、Chrome和Safari也都实现了这个事件。当用</div><div class="t m0 x0 h4 y2042 ff92 fs2 fc0 sc0 ls6 wsf7">户通过鼠标滚轮与页面交互、在垂直方向上滚动页面时（无论向上还是向下），就会触发mousewheel</div><div class="t m0 x0 h5 y2043 ff92 fs2 fc0 sc0 ls8 wseb">事件。这个事件可以在任何元素上面触发，最终会冒泡到document（IE8）或window（IE9、Opera、</div><div class="t m0 x0 h5 ycbd ff8b fs2 fc0 sc0 ls50 ws41">Chrome及Safari）对象。与mousewheel事件对应的event 对象除包含鼠标事件的所有标准信息外，</div><div class="t m0 x0 hc ycbe ff92 fs2 fc0 sc0 ls8 wseb">还包含一个特殊的wheelDelta属性。当用户向前滚动鼠标滚轮时，wheelDelta是120的倍数；当用</div><div class="t m0 x0 hc2 y21d5 ff92 fs2 fc0 sc0 ls8 wseb">户向后滚动鼠标滚轮时，wheelDelta是120的倍数。图13-6展示了这个属性。 </div><div class="t m0 x4 h5 y2519 ff8b fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x7 h3 y280f ff92 fs1 fc0 sc0 ls8 wsb">图 13-6 </div><div class="t m0 x0 h4 y21a4 ff92 fs2 fc0 sc0 ls110">将mousewheel事件处理程序指定给页面中的任何元素或document对象，即可处理鼠标滚轮的</div><div class="t m0 x0 h5 y2810 ff92 fs2 fc0 sc0 ls8 wseb">交互操作。来看下面的例子。 </div><div class="t m0 x0 hb y2811 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2812 ff96 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(document, &quot;mousewheel&quot;, function(event){ </div><div class="t m0 x0 hb y2813 ff96 fs6 fc0 sc0 ls21 wsb">    event = EventUtil.getEvent(event); </div><div class="t m0 x0 hb y2814 ff96 fs6 fc0 sc0 ls21 wsb">    alert(event.wheelDelta); </div><div class="t m0 x0 hb y2815 ff96 fs6 fc0 sc0 ls21 wsb">});  </div><div class="t m0 x0 h4 y1077 ff92 fs2 fc0 sc0 ls8 wseb">这个例子会在发生mousewheel事件时显示wheelDelta 的值。多数情况下，只要知道鼠标滚轮</div><div class="t m0 x0 hc y25ca ff92 fs2 fc0 sc0 ls8 wseb">滚动的方向就够了，而这通过检测wheelDelta的正负号就可以确定。 </div><div class="t m0 x0 h5 y2816 ff92 fs2 fc0 sc0 ls8 wseb">有一点要注意：在Opera 9.5之前的版本中，wheelDelta值的正负号是颠倒的。如果你打算支持</div><div class="t m0 x0 h5 y2817 ff92 fs2 fc0 sc0 ls8 wseb">早期的Opera版本，就需要使用浏览器检测技术来确定实际的值，如下面的例子所示。 </div><div class="t m0 x0 hb y2818 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2819 ff96 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(document, &quot;mousewheel&quot;, function(event){ </div><div class="t m0 x0 hb y281a ff96 fs6 fc0 sc0 ls21 wsb">    event = EventUtil.getEvent(event); </div><div class="t m0 x0 h15 y281b ff99 fs6 fc0 sc0 ls21 wsb">    var delta = (client.engine.opera &amp;&amp; client.engine.opera &lt; 9.5 ?  </div><div class="t m0 x0 h15 y281c ff99 fs6 fc0 sc0 ls21 wsb">                -event.wheelDelta : event.wheelDelta); </div><div class="t m0 x0 hb y281d ff96 fs6 fc0 sc0 ls21 wsb">    alert(delta); </div><div class="t m0 x0 hb y281e ff96 fs6 fc0 sc0 ls21 wsb">});  </div><div class="t m0 x2 hf y281f ff97 fs2 fc0 sc0 ls79 wsb">MouseWheelEventExample01.htm </div><div class="t m0 x1 h5 y2820 ff9c fs6 fc0 sc0 ls8">120 120 </div></div></div>
<div id="pf18b" class="pf w0 h0" data-page-no="18b"><div class="pc pc18b w0 h0"><div class="t m0 x2 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">13.4 事件类型    377 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff8d fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff8d fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff8d fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff8d fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff8d fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff8d fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff8d fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff8d fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff8d fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff8d fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff8d fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff8d fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff8d fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff92 fs2 fc0 sc0 ls8 wseb">以上代码使用第9章创建的client对象检测了浏览器是不是早期版本的Opera。 </div><div class="t m0 x5 h1d y2821 ff8c fs2 fc0 sc0 ls8 ws14">由于mousewheel事件非常流行，而且所有浏览器都支持它，所以HTML 5也加</div><div class="t m0 x5 h5 y2822 ff8c fs2 fc0 sc0 ls8 ws14">入了该事件。 </div><div class="t m0 x0 h5 y2823 ff8b fs2 fc0 sc0 ls47 ws38">Firefox支持一个名为DOMMouseScroll的类似事件，也是在鼠标滚轮滚动时触发。与mousewheel</div><div class="t m0 x0 h4 y2824 ff92 fs2 fc0 sc0 ls8 wseb">事件一样，DOMMouseScroll也被视为鼠标事件，因而包含与鼠标事件有关的所有属性。而有关鼠标滚</div><div class="t m0 x0 h4 y2825 ff92 fs2 fc0 sc0 ls8 wseb">轮的信息则保存在detail属性中，当向前滚动鼠标滚轮时，这个属性的值是-3的倍数，当向后滚动</div><div class="t m0 x0 hc y2826 ff92 fs2 fc0 sc0 ls8 wseb">鼠标滚轮时，这个属性的值是3的倍数。图13-7展示了这个属性。 </div><div class="t m0 x2 h5 y2827 ff8b fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 h3 y2828 ff92 fs1 fc0 sc0 ls8 wsb">图 13-7 </div><div class="t m0 x0 h4 y2829 ff92 fs2 fc0 sc0 ls8 wseb">可以将DOMMouseScroll事件添加到页面中的任何元素，而且该事件会冒泡到window 对象。因</div><div class="t m0 x0 h5 y282a ff92 fs2 fc0 sc0 ls8 wseb">此，可以像下面这样针对这个事件来添加事件处理程序。 </div><div class="t m0 x5 hb y8b0 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y282b ff96 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(window, &quot;DOMMouseScroll&quot;, function(event){ </div><div class="t m0 x0 hb y282c ff96 fs6 fc0 sc0 ls21 wsb">    event = EventUtil.getEvent(event); </div><div class="t m0 x0 hb y282d ff96 fs6 fc0 sc0 ls21 wsb">    alert(event.detail); </div><div class="t m0 x0 hb y282e ff96 fs6 fc0 sc0 ls21 wsb">});  </div><div class="t m0 x2 hf y282f ff97 fs2 fc0 sc0 ls7a wsb">DOMMouseScrollEventExample01.htm </div><div class="t m0 x0 h5 y1c5f ff92 fs2 fc0 sc0 ls8 wseb">这个简单的事件处理程序会在鼠标滚轮滚动时显示detail属性的值。 </div><div class="t m0 x0 h5 y245d ff92 fs2 fc0 sc0 ls8 wseb">若要给出跨浏览器环境下的解决方案，第一步就是创建一个能够取得鼠标滚轮增量值（delta）的方</div><div class="t m0 x0 hc yb8e ff92 fs2 fc0 sc0 ls8 wseb">法。下面是我们添加到EventUtil对象中的这个方法。 </div><div class="t m0 x5 hb y2830 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2831 ff96 fs6 fc0 sc0 ls21 wsb">var EventUtil = { </div><div class="t m0 x0 hb y2832 ff96 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 h16 y2833 ff96 fs6 fc0 sc0 ls21 wsb">    //省略了其他代码 </div><div class="t m0 x0 h15 y2834 ff99 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y2835 ff99 fs6 fc0 sc0 ls21 wsb">    getWheelDelta: function(event){ </div><div class="t m0 x0 h15 y2836 ff99 fs6 fc0 sc0 ls21 wsb">        if (event.wheelDelta){ </div><div class="t m0 x0 h15 y2837 ff99 fs6 fc0 sc0 ls21 wsb">            return (client.engine.opera &amp;&amp; client.engine.opera &lt; 9.5 ?  </div><div class="t m0 x0 h15 y2838 ff99 fs6 fc0 sc0 ls21 wsb">                    -event.wheelDelta : event.wheelDelta); </div><div class="t m0 x0 h15 y2839 ff99 fs6 fc0 sc0 ls21 wsb">        } else { </div><div class="t m0 x0 h15 y283a ff99 fs6 fc0 sc0 ls21 wsb">            return -event.detail * 40; </div><div class="t m0 x0 h15 y283b ff99 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x4 hdb yb4 ff9c fs6 fc0 sc0 ls8">33</div></div></div>
<div id="pf18c" class="pf w0 h0" data-page-no="18c"><div class="pc pc18c w0 h0"><div class="t m0 x0 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">378  第13章 事件 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y79 ff99 fs6 fc0 sc0 ls21 wsb">    }, </div><div class="t m0 x0 hb y7a ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y7b ff96 fs6 fc0 sc0 ls21 wsb">    //省略了其他代码 </div><div class="t m0 x0 hb y7c ff96 fs6 fc0 sc0 ls21 wsb">};  </div><div class="t m0 x2 hf y239b ff97 fs2 fc0 sc0 ls2b wsb">EventUtil.js </div><div class="t m0 x0 h4 y4cb ff92 fs2 fc0 sc0 ls8 wseb">这里，getWheelDelta()方法首先检测了事件对象是否包含wheelDelta属性，如果是则通过浏</div><div class="t m0 x0 h1e y4cc ff92 fs2 fc0 sc0 ls8 wseb">览器检测代码确定正确的值。如果wheelDelta不存在，则假设相应的值保存在detail属性中。由于</div><div class="t m0 x0 h5 y4cd ff8b fs2 fc0 sc0 ls47 ws38">Firefox的值有所不同，因此首先要将这个值的符号反向，然后再乘以40，就可以保证与其他浏览器的</div><div class="t m0 x0 h1e y4ce ff92 fs2 fc0 sc0 ls4 ws10d">值相同了。有了这个方法之后，就可以将相同的事件处理程序指定给mousewheel和DOMMouse- </div><div class="t m0 x0 h21 y283d ff96 fs1 fc0 sc0 ls9 ws2">Scroll事件了，例如： </div><div class="t m0 x0 hb y283e ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y283f ff96 fs6 fc0 sc0 ls21 wsb">(function(){ </div><div class="t m0 x0 hb y2840 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2841 ff96 fs6 fc0 sc0 ls21 wsb">    function handleMouseWheel(event){ </div><div class="t m0 x0 hb y2842 ff96 fs6 fc0 sc0 ls21 wsb">        event = EventUtil.getEvent(event); </div><div class="t m0 x0 hb y2843 ff96 fs6 fc0 sc0 ls21 wsb">        var delta = EventUtil.getWheelDelta(event); </div><div class="t m0 x0 hb y2844 ff96 fs6 fc0 sc0 ls21 wsb">        alert(delta); </div><div class="t m0 x0 hb y2845 ff96 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y2846 ff96 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 hb y2847 ff96 fs6 fc0 sc0 ls21 wsb">    EventUtil.addHandler(document, &quot;mousewheel&quot;, handleMouseWheel); </div><div class="t m0 x0 hb y2848 ff96 fs6 fc0 sc0 ls21 wsb">    EventUtil.addHandler(document, &quot;DOMMouseScroll&quot;, handleMouseWheel); </div><div class="t m0 x0 hb y2849 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y284a ff96 fs6 fc0 sc0 ls21 wsb">})(); </div><div class="t m0 x0 hb y284b ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf y284c ff97 fs2 fc0 sc0 ls1b wsb">CrossBrowserMouseWheelExample01.htm </div><div class="t m0 x0 h4 y930 ff92 fs2 fc0 sc0 ls8 wseb">我们将相关代码放在了一个私有作用域中，从而不会让新定义的函数干扰全局作用域。这里定义的</div><div class="t m0 x0 h4 y14f7 ff96 fs1 fc0 sc0 ls9 ws2">handleMouseWheel()函数可以用作两个事件的处理程序（如果指定的事件不存在，则为该事件指定处</div><div class="t m0 x0 h1e y932 ff92 fs2 fc0 sc0 ls8 wseb">理程序的代码就会静默地失败）。由于使用了EventUtil.getWheelDelta()方法，我们定义的这个事</div><div class="t m0 x0 h5 y284d ff92 fs2 fc0 sc0 ls8 wseb">件处理程序函数可以适用于任何一种情况。 </div><div class="t m0 x0 h3c y284e ff90 fs2 fc0 sc0 ls2e wsb">9. 触摸设备 </div><div class="t m0 x0 h5 y284f ff8b fs2 fc0 sc0 ls5 ws26e">iOS和Android设备的实现非常特别，因为这些设备没有鼠标。在面向iPhone和iPod中的 Safari</div><div class="t m0 x0 h5 y2850 ff92 fs2 fc0 sc0 ls8 wseb">开发时，要记住以下几点。 </div><div class="t m0 x0 h5 y2851 ff91 fs1 fc0 sc0 ls2"> 不支持dblclick事件。双击浏览器窗口会放大画面，而且没有办法改变该行为。 </div><div class="t m0 x0 h4 y2852 ff91 fs1 fc0 sc0 ls2"> 轻击可单击元素会触发mousemove事件。如果此操作会导致内容变化，将不再有其他事件发生；</div><div class="t m0 x0 h1e y2853 ff92 fs2 fc0 sc0 ls8 wseb">如果屏幕没有因此变化，那么会依次发生mousedown、mouseup和click事件。轻击不可单</div><div class="t m0 x0 h4 yc95 ff92 fs2 fc0 sc0 ls8 wseb">击的元素不会触发任何事件。可单击的元素是指那些单击可产生默认操作的元素（如链接），或</div><div class="t m0 x0 hc y2854 ff92 fs2 fc0 sc0 ls8 wseb">者那些已经被指定了onclick事件处理程序的元素。 </div><div class="t m0 x0 h5 y2855 ff91 fs1 fc0 sc0 ls2"> mousemove事件也会触发mouseover和mouseout事件。 </div><div class="t m0 x0 h5 y265c ff91 fs1 fc0 sc0 ls2"> 两个手指放在屏幕上且页面随手指移动而滚动时会触发mousewheel和scroll事件。 </div><div class="t m0 x0 h3c y2856 ff90 fs2 fc0 sc0 ls2e wsb">10. 无障碍性问题 </div><div class="t m0 x0 h5 y2857 ff92 fs2 fc0 sc0 ls8 wseb">如果你的Web应用程序或网站要确保残疾人特别是那些使用屏幕阅读器的人都能访问，那么在使</div><div class="t m0 x0 h4 y2858 ff92 fs2 fc0 sc0 ls8 wseb">用鼠标事件时就要格外小心。前面提到过，可以通过键盘上的回车键来触发click事件，但其他鼠标</div><div class="t m0 x0 h4 y2859 ff92 fs2 fc0 sc0 ls8 wseb">事件却无法通过键盘来触发。为此，我们不建议使用click之外的其他鼠标事件来展示功能或引发代</div></div></div>
<div id="pf18d" class="pf w0 h0" data-page-no="18d"><div class="pc pc18d w0 h0"><div class="t m0 x2 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">13.4 事件类型    379 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff8d fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff8d fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff8d fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff8d fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff8d fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff8d fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff8d fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff8d fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff8d fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff8d fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff8d fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff8d fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff8d fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h4 y3 ff92 fs2 fc0 sc0 ls8 wseb">码执行。因为这样会给盲人或视障用户造成极大不便。以下是在使用鼠标事件时应当注意的几个易访问</div><div class="t m0 x0 h5 y4d ff92 fs2 fc0 sc0 ls8">性问题。 </div><div class="t m0 x0 h4 y4e ff91 fs1 fc0 sc0 ls2"> 使用click事件执行代码。有人指出通过onmousedown执行代码会让人觉得速度更快，对视</div><div class="t m0 x5 h4 yd9 ff92 fs2 fc0 sc0 ls8 wseb">力正常的人来说这是没错的。但是，在屏幕阅读器中，由于无法触发mousedown事件，结果就</div><div class="t m0 x5 h5 y15d ff92 fs2 fc0 sc0 ls8 wseb">会造成代码无法执行。 </div><div class="t m0 x0 h4 y8 ff91 fs1 fc0 sc0 ls2"> 不要使用onmouseover向用户显示新的选项。原因同上，屏幕阅读器无法触发这个事件。如果</div><div class="t m0 x5 h5 y15e ff92 fs2 fc0 sc0 ls8 wseb">确实非要通过这种方式来显示新选项，可以考虑添加显示相同信息的键盘快捷方式。 </div><div class="t m0 x0 h5 ya ff91 fs1 fc0 sc0 ls2"> 不要使用dblclick执行重要的操作。键盘无法触发这个事件。 </div><div class="t m0 x0 h5 yb ff92 fs2 fc0 sc0 ls8 wseb">遵照以上提示可以极大地提升残疾人在访问你的Web应用程序或网站时的易访问性。 </div><div class="t m0 x5 h5 y285a ff8c fs2 fc0 sc0 ls339 ws2d8">要了解如何在网页中实现无障碍访问的内容，请访问www.webaim.org和</div><div class="t m0 x5 h5 y285b ff8b fs2 fc0 sc0 ls1b ws6e">http://yaccessibilityblog.com/。 </div><div class="t m0 x0 h20 y285c ff90 fs3 fc0 sc0 ls248 ws214">13.4.4 键盘与文本事件 </div><div class="t m0 x0 h5 y285d ff92 fs2 fc0 sc0 ls8 wseb">用户在使用键盘时会触发键盘事件。“DOM2级事件”最初规定了键盘事件，但在最终定稿之前又</div><div class="t m0 x0 h5 y285e ff92 fs2 fc0 sc0 ls8 wseb">删除了相应的内容。结果，对键盘事件的支持主要遵循的是DOM0级。 </div><div class="t m0 x0 h5 y285f ff92 fs2 fc0 sc0 ls8">“DOM3级事件”为键盘事件制定了规范，IE9率先完全实现了该规范。其他浏览器也在着手实现这</div><div class="t m0 x0 h5 y2860 ff92 fs2 fc0 sc0 ls8 wseb">一标准，但仍然有很多遗留的问题。 </div><div class="t m0 x0 h5 y2861 ff92 fs2 fc0 sc0 ls3b">有3个键盘事件，简述如下。 </div><div class="t m0 x0 h5 y2862 ff91 fs1 fc0 sc0 ls2"> keydown：当用户按下键盘上的任意键时触发，而且如果按住不放的话，会重复触发此事件。 </div><div class="t m0 x0 h4 y2555 ff91 fs1 fc0 sc0 ls2"> keypress：当用户按下键盘上的字符键时触发，而且如果按住不放的话，会重复触发此事件。</div><div class="t m0 x5 h5 y19f0 ff92 fs2 fc0 sc0 ls8 wseb">按下Esc键也会触发这个事件。Safari 3.1之前的版本也会在用户按下非字符键时触发keypress</div><div class="t m0 x5 h5 y2863 ff92 fs2 fc0 sc0 ls8">事件。 </div><div class="t m0 x0 h5 y2864 ff91 fs1 fc0 sc0 ls2"> keyup：当用户释放键盘上的键时触发。 </div><div class="t m0 x0 h5 y2865 ff92 fs2 fc0 sc0 ls8 wseb">虽然所有元素都支持以上3个事件，但只有在用户通过文本框输入文本时才最常用到。 </div><div class="t m0 x0 h1e y2866 ff92 fs2 fc0 sc0 ls8 wseb">只有一个文本事件：textInput。这个事件是对keypress的补充，用意是在将文本显示给用户之</div><div class="t m0 x0 hc y2867 ff92 fs2 fc0 sc0 ls8 wseb">前更容易拦截文本。在文本插入文本框之前会触发textInput事件。 </div><div class="t m0 x0 h1e y2868 ff92 fs2 fc0 sc0 ls8 wseb">在用户按了一下键盘上的字符键时，首先会触发keydown事件，然后紧跟着是keypress事件，</div><div class="t m0 x0 h1e y2869 ff92 fs2 fc0 sc0 ls8 wseb">最后会触发keyup事件。其中，keydown和keypress都是在文本框发生变化之前被触发的；而keyup</div><div class="t m0 x0 h4 y2fd ff92 fs2 fc0 sc0 ls19">事件则是在文本框已经发生变化之后被触发的。如果用户按下了一个字符键不放，就会重复触发</div><div class="t m0 x0 h5 y286a ff96 fs1 fc0 sc0 ls9 ws2">keydown和keypress事件，直到用户松开该键为止。 </div><div class="t m0 x0 h1e y286b ff92 fs2 fc0 sc0 ls8 wseb">如果用户按下的是一个非字符键，那么首先会触发keydown事件，然后就是keyup事件。如果按</div><div class="t m0 x0 h1e y286c ff92 fs2 fc0 sc0 ls8 wseb">住这个非字符键不放，那么就会一直重复触发keydown事件，直到用户松开这个键，此时会触发keyup</div><div class="t m0 x0 h5 y301 ff92 fs2 fc0 sc0 ls8">事件。 </div><div class="t m0 x5 ha y286d ff8c fs2 fc0 sc0 ls8 ws14">键盘事件与鼠标事件一样，都支持相同的修改键。而且，键盘事件的事件对象中</div><div class="t m0 x5 h9d y286e ff8c fs2 fc0 sc0 ls8 ws14">也有shiftKey、ctrlKey、altKey和metaKey属性。IE不支持metaKey。 </div></div></div>
<div id="pf18e" class="pf w0 h0" data-page-no="18e"><div class="pc pc18e w0 h0"><div class="t m0 x0 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">380  第13章 事件 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h3c y68b ff90 fs2 fc0 sc0 ls2e wsb">1. 键码 </div><div class="t m0 x0 h4 y68c ff92 fs2 fc0 sc0 ls8 wseb">在发生keydown和keyup事件时，event对象的 keyCode属性中会包含一个代码，与键盘上一</div><div class="t m0 x0 hc y68d ff92 fs2 fc0 sc0 ls8 wseb">个特定的键对应。对数字字母字符键，keyCode属性的值与ASCII码中对应小写字母或数字的编码相</div><div class="t m0 x0 hc y68e ff92 fs2 fc0 sc0 ls8 wseb">同。因此，数字键7的keyCode值为55，而字母A键的keyCode 值为65——与Shift键的状态无关。</div><div class="t m0 x0 hc y6e4 ff8b fs2 fc0 sc0 ls81 ws76">DOM和IE的event对象都支持keyCode属性。请看下面这个例子： </div><div class="t m0 x0 hb y6e5 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y6e6 ff96 fs6 fc0 sc0 ls21 wsb">var textbox = document.getElementById(&quot;myText&quot;); </div><div class="t m0 x0 hb y6e7 ff96 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(textbox, &quot;keyup&quot;, function(event){ </div><div class="t m0 x0 hb y6e8 ff96 fs6 fc0 sc0 ls21 wsb">    event = EventUtil.getEvent(event); </div><div class="t m0 x0 hb y286f ff96 fs6 fc0 sc0 ls21 wsb">    alert(event.keyCode);      </div><div class="t m0 x0 hb y2870 ff96 fs6 fc0 sc0 ls21 wsb">});  </div><div class="t m0 x2 hf y24e9 ff97 fs2 fc0 sc0 ls1b wsb">KeyUpEventExample01.htm </div><div class="t m0 x0 h4 y2871 ff92 fs2 fc0 sc0 ls8 wseb">在这个例子中，用户每次在文本框中按键触发keyup事件时，都会显示keyCode的值。下表列出</div><div class="t m0 x0 h5 y2872 ff92 fs2 fc0 sc0 ls8 wseb">了所有非字符键的键码。 </div><div class="t m0 x0 hb y2873 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x5 h31 y2874 ff8f fs6 fc0 sc0 ls8">键 键  码 键 键  码 </div><div class="t m0 x0 h97 y405 ff92 fs6 fc0 sc0 ls31 ws125">退格（Backspace） 8  数字小键盘1  97  </div><div class="t m0 x0 h97 y2875 ff92 fs6 fc0 sc0 ls31 ws125">制表（Tab） 9  数字小键盘2  98  </div><div class="t m0 x0 h97 y2450 ff92 fs6 fc0 sc0 ls31 ws125">回车（Enter） 13  数字小键盘3  99  </div><div class="t m0 x0 h97 y2876 ff92 fs6 fc0 sc0 ls31 ws125">上档（Shift） 16  数字小键盘4  100  </div><div class="t m0 x0 h97 y2877 ff92 fs6 fc0 sc0 ls31 ws125">控制（Ctrl） 17  数字小键盘5  101  </div><div class="t m0 x0 hdd y2878 ff8b fs6 fc0 sc0 ls209 ws2de">Alt   18   数字小键盘6   102  </div><div class="t m0 x0 h36 y2879 ff92 fs6 fc0 sc0 ls351">暂停/中断（Pause/Break）19   数字小键盘7   103  </div><div class="t m0 x0 h97 y287a ff92 fs6 fc0 sc0 ls8 ws124">大写锁定（Caps Lock）   20   数字小键盘8  104 </div><div class="t m0 x0 h97 y287b ff92 fs6 fc0 sc0 ls31 ws125">退出（Esc） 27   数字小键盘9  105 </div><div class="t m0 x0 h97 y287c ff92 fs6 fc0 sc0 ls8 ws124">上翻页（Page Up） 33   数字小键盘+  107 </div><div class="t m0 x0 h97 y287d ff92 fs6 fc0 sc0 ls8 ws124">下翻页（Page Down） 34   数字小键盘及大键盘上的-109 </div><div class="t m0 x0 h97 y287e ff92 fs6 fc0 sc0 ls31 ws125">结尾（End） 35   数字小键盘 .   110  </div><div class="t m0 x0 h36 y10ef ff92 fs6 fc0 sc0 ls31 ws125">开头（Home） 36   数字小键盘 /   111  </div><div class="t m0 x0 h36 y1a18 ff92 fs6 fc0 sc0 ls8 ws124">左箭头（Left Arrow） 37   F1   112  </div><div class="t m0 x0 h36 y10c3 ff92 fs6 fc0 sc0 ls8 ws124">上箭头（Up Arrow） 38   F2   113  </div><div class="t m0 x0 h36 y287f ff92 fs6 fc0 sc0 ls8 ws124">右箭头（Right Arrow） 39   F3   114  </div><div class="t m0 x0 h36 y186f ff92 fs6 fc0 sc0 ls8 ws124">下箭头（Down Arrow） 40   F4   115  </div><div class="t m0 x0 h36 ya0 ff92 fs6 fc0 sc0 ls31 ws125">插入（Ins） 45   F5   116  </div><div class="t m0 x0 h36 y2880 ff92 fs6 fc0 sc0 ls31 ws125">删除（Del） 46   F6   117  </div><div class="t m0 x0 h36 y2881 ff92 fs6 fc0 sc0 ls95">左Windows键 91   F7   118  </div><div class="t m0 x0 h36 y2882 ff92 fs6 fc0 sc0 ls95">右Windows键 92   F8   119  </div><div class="t m0 x0 h36 y2883 ff92 fs6 fc0 sc0 ls8 ws124">上下文菜单键 93   F9   120  </div><div class="t m0 x0 h36 y22f7 ff92 fs6 fc0 sc0 ls8 ws124">数字小键盘0  96   F10   121  </div></div></div>
<div id="pf18f" class="pf w0 h0" data-page-no="18f"><div class="pc pc18f w0 h0"><div class="t m0 x2 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">13.4 事件类型    381 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff8d fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff8d fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff8d fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff8d fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff8d fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff8d fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff8d fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff8d fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff8d fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff8d fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff8d fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff8d fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff8d fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x6 h3 y34f ff92 fs1 fc0 sc0 ls8">（续） </div><div class="t m0 x5 h31 y2884 ff8f fs6 fc0 sc0 ls8">键 键  码 键 键  码 </div><div class="t m0 x0 hdd y2885 ff8b fs6 fc0 sc0 ls223 ws2e4">F11   122   正斜杠 191  </div><div class="t m0 x0 hdd y2886 ff8b fs6 fc0 sc0 ls223 ws2e4">F12   123   沉音符（`） 192  </div><div class="t m0 x0 h36 y2887 ff92 fs6 fc0 sc0 ls8 ws124">数字锁（Num Lock） 144   等于 61  </div><div class="t m0 x0 h36 y2888 ff92 fs6 fc0 sc0 ls8 ws124">滚动锁（Scroll Lock） 145   左方括号 219  </div><div class="t m0 x0 h36 y2889 ff92 fs6 fc0 sc0 ls31 ws125">分号（IE/Safari/Chrome中） 186   反斜杠（\） 220  </div><div class="t m0 x0 h36 y288a ff92 fs6 fc0 sc0 ls31 ws125">分号（Opera/FF中） 59   右方括号 221  </div><div class="t m0 x0 h36 y459 ff92 fs6 fc0 sc0 ls31">小于 188   单引号 222  </div><div class="t m0 x0 h36 y288b ff92 fs6 fc0 sc0 ls31">大于 190     </div><div class="t m0 x5 hb y288c ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 ye8d ff92 fs2 fc0 sc0 ls8 wseb">无论keydown或keyup事件都会存在的一些特殊情况。在Firefox和Opera中，按分号键时keyCode</div><div class="t m0 x0 h5 y288d ff92 fs2 fc0 sc0 ls8 wseb">值为59，也就是ASCII中分号的编码；但IE和Safari 返回186，即键盘中按键的键码。 </div><div class="t m0 x0 h3c y288e ff90 fs2 fc0 sc0 ls2e wsb">2. 字符编码 </div><div class="t m0 x0 h4 y288f ff92 fs2 fc0 sc0 ls8 wseb">发生keypress事件意味着按下的键会影响到屏幕中文本的显示。在所有浏览器中，按下能够插入</div><div class="t m0 x0 h5 y647 ff92 fs2 fc0 sc0 ls8 wseb">或删除字符的键都会触发keypress事件；按下其他键能否触发此事件因浏览器而异。由于截止到2008</div><div class="t m0 x0 h5 y2890 ff92 fs2 fc0 sc0 ls8 wseb">年，尚无浏览器实现“DOM3级事件”规范，所以浏览器之间的键盘事件并没有多大的差异。 </div><div class="t m0 x0 h5 y2891 ff8b fs2 fc0 sc0 ls2a ws21">IE9、Firefox、Chrome和Safari的event对象都支持一个charCode 属性，这个属性只有在发生</div><div class="t m0 x0 h5 y1116 ff96 fs1 fc0 sc0 ls9 ws2">keypress事件时才包含值，而且这个值是按下的那个键所代表字符的ASCII编码。此时的 keyCode</div><div class="t m0 x0 h5 y2892 ff92 fs2 fc0 sc0 ls8 wseb">通常等于0或者也可能等于所按键的键码。IE8及之前版本和Opera则是在keyCode中保存字符的ASCII</div><div class="t m0 x0 h1e y2893 ff92 fs2 fc0 sc0 ls8 wseb">编码。要想以跨浏览器的方式取得字符编码，必须首先检测charCode属性是否可用，如果不可用则使</div><div class="t m0 x0 hc y1119 ff92 fs2 fc0 sc0 ls361">用keyCode，如下面的例子所示。 </div><div class="t m0 x5 hb y2894 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2895 ff96 fs6 fc0 sc0 ls21 wsb">var EventUtil = { </div><div class="t m0 x0 hb y2896 ff96 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 h16 y2897 ff96 fs6 fc0 sc0 ls21 wsb">    //省略的代码 </div><div class="t m0 x0 hb y2898 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y2899 ff99 fs6 fc0 sc0 ls21 wsb">    getCharCode: function(event){ </div><div class="t m0 x0 h15 y289a ff99 fs6 fc0 sc0 ls21 wsb">        if (typeof event.charCode == &quot;number&quot;){ </div><div class="t m0 x0 h15 y289b ff99 fs6 fc0 sc0 ls21 wsb">            return event.charCode; </div><div class="t m0 x0 h15 y289c ff99 fs6 fc0 sc0 ls21 wsb">        } else { </div><div class="t m0 x0 h15 y289d ff99 fs6 fc0 sc0 ls21 wsb">            return event.keyCode; </div><div class="t m0 x0 h15 y289e ff99 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 h15 y289f ff99 fs6 fc0 sc0 ls21 wsb">    }, </div><div class="t m0 x0 hb y28a0 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y28a1 ff96 fs6 fc0 sc0 ls21 wsb">    //省略的代码 </div><div class="t m0 x0 hb y28a2 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y28a3 ff96 fs6 fc0 sc0 ls21 wsb">};  </div><div class="t m0 x6 hf y28a4 ff97 fs2 fc0 sc0 ls2b wsb">EventUtil.js </div><div class="t m0 x0 h5 y28a5 ff92 fs2 fc0 sc0 ls8 wseb">这个方法首先检测charCode属性是否包含数值（在不支持这个属性的浏览器中，值为undefined），</div><div class="t m0 x0 h5 y130d ff92 fs2 fc0 sc0 ls8 wseb">如果是，则返回该值。否则，就返回keyCode属性值。下面是使用这个方法的示例。 </div><div class="t m0 x5 hb yc50 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y28a6 ff96 fs6 fc0 sc0 ls21 wsb">var textbox = document.getElementById(&quot;myText&quot;); </div><div class="t m0 x0 hb y28a7 ff96 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(textbox, &quot;keypress&quot;, function(event){ </div><div class="t m0 x0 hb y28a8 ff96 fs6 fc0 sc0 ls21 wsb">    event = EventUtil.getEvent(event); </div></div></div>
<div id="pf190" class="pf w0 h0" data-page-no="190"><div class="pc pc190 w0 h0"><div class="t m0 x0 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">382  第13章 事件 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y79 ff99 fs6 fc0 sc0 ls21 wsb">    alert(EventUtil.getCharCode(event)); </div><div class="t m0 x0 hb y7a ff96 fs6 fc0 sc0 ls21 wsb">});  </div><div class="t m0 x2 hf y10b0 ff97 fs2 fc0 sc0 lsb wsb">KeyPressEventExample01.htm </div><div class="t m0 x0 h5 y10b1 ff92 fs2 fc0 sc0 ls8 wseb">在取得了字符编码之后，就可以使用String.fromCharCode()将其转换成实际的字符。 </div><div class="t m0 x0 h3c y28aa ff90 fs2 fc0 sc0 ls96 ws7d">3. DOM3级变化 </div><div class="t m0 x0 h5 y28ab ff92 fs2 fc0 sc0 ls8 wseb">尽管所有浏览器都实现了某种形式的键盘事件，DOM3级事件还是做出了一些改变。比如，DOM3</div><div class="t m0 x0 hdf y28ac ff92 fs2 fc0 sc0 ls8 wseb">级事件中的键盘事件，不再包含charCode属性，而是包含两个新属性：key和char。 </div><div class="t m0 x0 h1e y28ad ff92 fs2 fc0 sc0 ls8 wseb">其中，key属性是为了取代keyCode而新增的，它的值是一个字符串。在按下某个字符键时，key</div><div class="t m0 x0 h5 y28ae ff92 fs2 fc0 sc0 ls8 wseb">的值就是相应的文本字符（如“k”或“M”）；在按下非字符键时， key的值是相应键的名（如“Shift”</div><div class="t m0 x0 h5 y24e9 ff92 fs2 fc0 sc0 ls8">或“Down”）。而char属性在按下字符键时的行为与key相同，但在按下非字符键时值为null。 </div><div class="t m0 x0 hc y24ea ff8b fs2 fc0 sc0 ls2a ws21">IE9支持key属性，但不支持char属性。Safari 5 和Chrome支持名为 keyIdentifier的属性，</div><div class="t m0 x0 h5 y28af ff92 fs2 fc0 sc0 ls8 wseb">在按下非字符键（例如Shift）的情况下与key的值相同。对于字符键，keyIdentifier返回一个格式</div><div class="t m0 x0 hc y193a ff92 fs2 fc0 sc0 ls8">类似“U+0000”的字符串，表示Unicode值。 </div><div class="t m0 x0 hb y28b0 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y28b1 ff96 fs6 fc0 sc0 ls21 wsb">var textbox = document.getElementById(&quot;myText&quot;); </div><div class="t m0 x0 hb y28b2 ff96 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(textbox, &quot;keypress&quot;, function(event){ </div><div class="t m0 x0 hb y28b3 ff99 fs6 fc0 sc0 ls21 wsb">    event = EventUtil.getEvent(event); </div><div class="t m0 x0 h15 y28b4 ff99 fs6 fc0 sc0 ls21 wsb">    var identifier = event.key || event.keyIdentifier; </div><div class="t m0 x0 h15 y28b5 ff99 fs6 fc0 sc0 ls21 wsb">    if (identifier){  </div><div class="t m0 x0 h15 y28b6 ff99 fs6 fc0 sc0 ls21 wsb">        alert(identifi er); </div><div class="t m0 x0 h15 y28b7 ff99 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y28b8 ff96 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x4 hf y28b9 ff97 fs2 fc0 sc0 ls25 wsb">DOMLevel3KeyPropertyExample01.htm </div><div class="t m0 x0 h5 y28ba ff92 fs2 fc0 sc0 ls8 wseb">由于存在跨浏览器问题，因此本书不推荐使用key、keyIdentifier或char。 </div><div class="t m0 x0 h5 y28bb ff8b fs2 fc0 sc0 ls24a ws215">DOM3级事件还添加了一个名为location的属性，这是一个数值，表示按下了什么位置上的键：</div><div class="t m0 x0 h5 y28bc ff8b fs2 fc0 sc0 ls38">0表示默认键盘，1表示左侧位置（例如左位的Alt键），2表示右侧位置（例如右侧的Shift键），3表示</div><div class="t m0 x0 h5 y28bd ff92 fs2 fc0 sc0 ls8 wseb">数字小键盘，4表示移动设备键盘（也就是虚拟键盘），5表示手柄（如任天堂Wii控制器）。IE9支持这</div><div class="t m0 x0 he y28be ff92 fs2 fc0 sc0 ls8">个属性。Safari和Chrome支持名为keyLocation的等价属性，但即有 bug——值始终是0，除非按下</div><div class="t m0 x0 h5 y28bf ff92 fs2 fc0 sc0 ls8 wseb">了数字键盘（此时，值 为3）；否则，不会是1、2、4、5。 </div><div class="t m0 x0 hb y12a0 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y28c0 ff96 fs6 fc0 sc0 ls21 wsb">var textbox = document.getElementById(&quot;myText&quot;); </div><div class="t m0 x0 hb y28c1 ff96 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(textbox, &quot;keypress&quot;, function(event){ </div><div class="t m0 x0 hb y28c2 ff99 fs6 fc0 sc0 ls21 wsb">    event = EventUtil.getEvent(event); </div><div class="t m0 x0 h15 y28c3 ff99 fs6 fc0 sc0 ls21 wsb">    var loc = event.location || event.keyLocation; </div><div class="t m0 x0 h15 y28c4 ff99 fs6 fc0 sc0 ls21 wsb">    if (loc){ </div><div class="t m0 x0 h15 y28c5 ff99 fs6 fc0 sc0 ls21 wsb">        alert(loc); </div><div class="t m0 x0 hb y28c6 ff99 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y28c7 ff96 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x4 hf y28c8 ff97 fs2 fc0 sc0 ls25 wsb">DOMLevel3LocationPropertyExample01.htm </div><div class="t m0 x0 h5 y28c9 ff92 fs2 fc0 sc0 ls2c">与key属性一样，支持location的浏览器也不多，所以在跨浏览器开发中不推荐使用。 </div><div class="t m0 x0 h1e y28ca ff92 fs2 fc0 sc0 ls8 wseb">最后是给event对象添加了getModifierState()方法。这个方法接收一个参数，即等于Shift、</div><div class="t m0 x0 h4 y28cb ff96 fs1 fc0 sc0 ls9 ws2">Control、AltGraph或Meta的字符串，表示要检测的修改键。如果指定的修改键是活动的（也就是</div><div class="t m0 x0 hc y28cc ff92 fs2 fc0 sc0 ls8 wseb">处于被按下的状态），这个方法返回true，否则返回false。 </div></div></div>
<div id="pf191" class="pf w0 h0" data-page-no="191"><div class="pc pc191 w0 h0"><div class="t m0 x2 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">13.4 事件类型    383 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff8d fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff8d fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff8d fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff8d fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff8d fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff8d fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff8d fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff8d fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff8d fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff8d fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff8d fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff8d fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff8d fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y79 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y7a ff96 fs6 fc0 sc0 ls21 wsb">var textbox = document.getElementById(&quot;myText&quot;); </div><div class="t m0 x0 hb y7b ff96 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(textbox, &quot;keypress&quot;, function(event){ </div><div class="t m0 x0 hb y7c ff99 fs6 fc0 sc0 ls21 wsb">    event = EventUtil.getEvent(event); </div><div class="t m0 x0 h15 y7d ff99 fs6 fc0 sc0 ls21 wsb">    if (event.getModifierState){ </div><div class="t m0 x0 h15 y7e ff99 fs6 fc0 sc0 ls21 wsb">        alert(event.getModifierState(&quot;Shift&quot;)); </div><div class="t m0 x0 h15 y7f ff99 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y80 ff96 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x4 hf y28cd ff97 fs2 fc0 sc0 ls25 wsb">DOMLevel3LocationGetModifierStateExample01.htm </div><div class="t m0 x0 h4 y28ce ff92 fs2 fc0 sc0 ls8 wseb">实际上，通过event对象的shiftKey、altKey、ctrlKey 和metaKey属性已经可以取得类似</div><div class="t m0 x0 hc y28cf ff92 fs2 fc0 sc0 ls8 wseb">的属性了。IE9是唯一支持getModifierState()方法的浏览器。 </div><div class="t m0 x0 h47 y28d0 ff90 fs2 fc0 sc0 ls2e wsb">4. textInput事件 </div><div class="t m0 x0 h5 y28d1 ff92 fs2 fc0 sc0 ls8">“DOM3级事件”规范中引入了一个新事件，名叫textInput。根据规范，当用户在可编辑区域中</div><div class="t m0 x0 h1e y28d2 ff92 fs2 fc0 sc0 ls8 wseb">输入字符时，就会触发这个事件。这个用于替代keypress的textInput事件的行为稍有不同。区别</div><div class="t m0 x0 h1e y28d3 ff92 fs2 fc0 sc0 ls8 wseb">之一就是任何可以获得焦点的元素都可以触发keypress事件，但只有可编辑区域才能触发textInput</div><div class="t m0 x0 h4 y28d4 ff92 fs2 fc0 sc0 ls8 wseb">事件。区别之二是textInput事件只会在用户按下能够输入实际字符的键时才会被触发，而keypress</div><div class="t m0 x0 h5 y28d5 ff92 fs2 fc0 sc0 ls8 wseb">事件则在按下那些能够影响文本显示的键时也会触发（例如退格键）。 </div><div class="t m0 x0 h1e y28d6 ff92 fs2 fc0 sc0 ls8 wseb">由于textInput事件主要考虑的是字符，因此它的event对象中还包含一个 data属性，这个属</div><div class="t m0 x0 h5 y28d7 ff92 fs2 fc0 sc0 ls8 wseb">性的值就是用户输入的字符（而非字符编码）。换句话说，用户在没有按上档键的情况下按下了S键，</div><div class="t m0 x0 h5 y28d8 ff96 fs1 fc0 sc0 ls9 ws2">data的值就是&quot;s&quot;，而如果在按住上档键时按下该键，data的值就是&quot;S&quot;。 </div><div class="t m0 x0 hc y28d9 ff92 fs2 fc0 sc0 ls8 wseb">以下是一个使用textInput事件的例子： </div><div class="t m0 x5 hb y1a90 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y28da ff96 fs6 fc0 sc0 ls21 wsb">var textbox = document.getElementById(&quot;myText&quot;); </div><div class="t m0 x0 h15 y28db ff99 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(textbox, &quot;textInput&quot;, function(event){ </div><div class="t m0 x0 h15 y28dc ff99 fs6 fc0 sc0 ls21 wsb">    event = EventUtil.getEvent(event); </div><div class="t m0 x0 h15 y28dd ff99 fs6 fc0 sc0 ls21 wsb">    alert(event.data); </div><div class="t m0 x0 h15 y28de ff99 fs6 fc0 sc0 ls21 wsb">});  </div><div class="t m0 x2 hf y28df ff97 fs2 fc0 sc0 ls79 wsb">TextInputEventExample01.htm </div><div class="t m0 x0 h5 y26ed ff92 fs2 fc0 sc0 ls8 wseb">在这个例子中，插入到文本框中的字符会通过一个警告框显示出来。 </div><div class="t m0 x0 hc y28e0 ff92 fs2 fc0 sc0 ls8 wseb">另外，event对象上还有一个属性，叫inputMethod，表示把文本输入到文本框中的方式。 </div><div class="t m0 x0 h5 y28e1 ff91 fs1 fc0 sc0 ls2"> 0，表示浏览器不确定是怎么输入的。 </div><div class="t m0 x0 h5 y1c22 ff91 fs1 fc0 sc0 ls2"> 1，表示是使用键盘输入的。 </div><div class="t m0 x0 h5 y28e2 ff91 fs1 fc0 sc0 ls2"> 2，表示文本是粘贴进来的。 </div><div class="t m0 x0 h5 y28e3 ff91 fs1 fc0 sc0 ls2"> 3，表示文本是拖放进来的。 </div><div class="t m0 x0 h5 y1c25 ff91 fs1 fc0 sc0 ls2"> 4，表示文本是使用IME输入的。 </div><div class="t m0 x0 h5 y1a9c ff91 fs1 fc0 sc0 ls2"> 5，表示文本是通过在表单中选择某一项输入的。 </div><div class="t m0 x0 h5 y28e4 ff91 fs1 fc0 sc0 ls2"> 6，表示文本是通过手写输入的（比如使用手写笔）。 </div><div class="t m0 x0 h5 y23f3 ff91 fs1 fc0 sc0 ls2"> 7，表示文本是通过语音输入的。 </div><div class="t m0 x0 h5 y28e5 ff91 fs1 fc0 sc0 ls2"> 8，表示文本是通过几种方法组合输入的。 </div><div class="t m0 x0 h5 y1c29 ff91 fs1 fc0 sc0 ls2"> 9，表示文本是通过脚本输入的。 </div><div class="t m0 x0 h4 y1896 ff92 fs2 fc0 sc0 ls8 wseb">使用这个属性可以确定文本是如何输入到控件中的，从而可以验证其有效性。支持textInput属</div><div class="t m0 x0 hc y28e6 ff92 fs2 fc0 sc0 ls8 wseb">性的浏览器有IE9+、Safari和Chrome。只有IE支持inputMethod 属性。 </div></div></div>
<div id="pf192" class="pf w0 h0" data-page-no="192"><div class="pc pc192 w0 h0"><div class="t m0 x0 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">384  第13章 事件 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h3c y68b ff90 fs2 fc0 sc0 ls2e wsb">5. 设备中的键盘事件 </div><div class="t m0 x0 h5 y68c ff92 fs2 fc0 sc0 ls8 wseb">任天堂Wii会在用户按下Wii遥控器上的按键时触发键盘事件。尽管没有办法访问 Wii遥控器中的</div><div class="t m0 x0 h5 y15dc ff92 fs2 fc0 sc0 ls8 wseb">所有按键，但还是有一些键可以触发键盘事件。图13-6展示了一些键的键码，通过这些键码可以知道</div><div class="t m0 x0 h5 y15dd ff92 fs2 fc0 sc0 ls8 wseb">用户按下了哪个键。 </div><div class="t m0 x2 h5 y28e8 ff8b fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x7 h3 y7c7 ff92 fs1 fc0 sc0 ls8 wsb">图 13-8 </div><div class="t m0 x0 h5 y28e9 ff92 fs2 fc0 sc0 ls8 wseb">当用户按下十字键盘（键码为175～178）、减号（170）、加号（174）、1（172）或2（173）键时就</div><div class="t m0 x0 h5 y28ea ff92 fs2 fc0 sc0 ls8 wseb">会触发键盘事件。但没有办法得知用户是否按下了电源开关、A、B或主页键。 </div><div class="t m0 x0 h5 y13ef ff8b fs2 fc0 sc0 ls8 ws20">iOS版Safari和Android版WebKit在使用屏幕键盘时会触发键盘事件。 </div><div class="t m0 x0 h20 y4e9 ff90 fs3 fc0 sc0 ls248 ws214">13.4.5 复合事件 </div><div class="t m0 x0 h5 y1d55 ff92 fs2 fc0 sc0 ls8 wseb">复合事件（composition event）是DOM3级事件中新添加的一类事件，用于处理IME 的输入序列。</div><div class="t m0 x0 h5 y2609 ff8b fs2 fc0 sc0 lse ws9">IME（Input Method Editor，输入法编辑器）可以让用户输入在物理键盘上找不到的字符。例如，使用拉</div><div class="t m0 x0 h5 y260a ff92 fs2 fc0 sc0 ls8 wseb">丁文键盘的用户通过IME照样能输入日文字符。IME通常需要同时按住多个键，但最终只输入一个字</div><div class="t m0 x0 h5 y28eb ff92 fs2 fc0 sc0 ls8 wseb">符。复合事件就是针对检测和处理这种输入而设计的。有以下三种复合事件。 </div><div class="t m0 x0 h5 yeac ff91 fs1 fc0 sc0 ls2"> compositionstart：在IME的文本复合系统打开时触发，表示要开始输入了。 </div><div class="c x4 y28ec w19 he1"><div class="t m0 x0 h58 y28ed ff92 fs6 fc0 sc0 ls8">（</div></div><div class="t m0 x4 h58 y28ee ff92 fs6 fc0 sc0 ls8 ws124">无法访问）</div><div class="c x7 y28ef w19 he1"><div class="t m0 x0 h58 y28ed ff92 fs6 fc0 sc0 ls8">（</div></div><div class="t m0 x7 h58 y28f0 ff92 fs6 fc0 sc0 ls8 ws124">无法访问）</div><div class="c x1 y28f1 w19 he1"><div class="t m0 x0 h58 y28ed ff92 fs6 fc0 sc0 ls8">（</div></div><div class="t m0 x1 h36 yf2a ff92 fs6 fc0 sc0 ls8 ws124">无法访问） </div></div></div>
<div id="pf193" class="pf w0 h0" data-page-no="193"><div class="pc pc193 w0 h0"><div class="t m0 x2 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">13.4 事件类型    385 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff8d fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff8d fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff8d fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff8d fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff8d fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff8d fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff8d fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff8d fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff8d fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff8d fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff8d fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff8d fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff8d fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff91 fs1 fc0 sc0 ls2"> compositionupdate：在向输入字段中插入新字符时触发。 </div><div class="t m0 x0 h5 y4 ff91 fs1 fc0 sc0 ls2"> compositionend：在IME的文本复合系统关闭时触发，表示返回正常键盘输入状态。 </div><div class="t m0 x0 h4 y5 ff92 fs2 fc0 sc0 ls8 wseb">复合事件与文本事件在很多方面都很相似。在触发复合事件时，目标是接收文本的输入字段。但它</div><div class="t m0 x0 hc y6 ff92 fs2 fc0 sc0 ls8 wseb">比文本事件的事件对象多一个属性data，其中包含以下几个值中的一个： </div><div class="t m0 x0 h4 y219 ff91 fs1 fc0 sc0 ls2"> 如果在compositionstart事件发生时访问，包含正在编辑的文本（例如，已经选中的需要马</div><div class="t m0 x5 h5 y21a ff92 fs2 fc0 sc0 ls8 wseb">上替换的文本）； </div><div class="t m0 x0 h5 y9 ff91 fs1 fc0 sc0 ls2"> 如果在compositionupdate事件发生时访问，包含正插入的新字符； </div><div class="t m0 x0 h5 ya ff91 fs1 fc0 sc0 ls2"> 如果在compositionend事件发生时访问，包含此次输入会话中插入的所有字符。 </div><div class="t m0 x0 h5 yb ff92 fs2 fc0 sc0 ls8 wseb">与文本事件一样，必要时可以利用复合事件来筛选输入。可以像下面这样使用它们： </div><div class="t m0 x0 hb y215b ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y28f2 ff96 fs6 fc0 sc0 ls21 wsb">var textbox = document.getElementById(&quot;myText&quot;); </div><div class="t m0 x0 h15 y28f3 ff99 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(textbox, &quot;compositionstart&quot;, function(event){ </div><div class="t m0 x0 h15 y28f4 ff99 fs6 fc0 sc0 ls21 wsb">    event = EventUtil.getEvent(event); </div><div class="t m0 x0 h15 y28f5 ff99 fs6 fc0 sc0 ls21 wsb">    alert(event.data); </div><div class="t m0 x0 h15 y28f6 ff99 fs6 fc0 sc0 ls21 wsb">});  </div><div class="t m0 x0 h15 y28f7 ff99 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y28f8 ff99 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(textbox, &quot;compositionupdate&quot;, function(event){ </div><div class="t m0 x0 h15 y28f9 ff99 fs6 fc0 sc0 ls21 wsb">    event = EventUtil.getEvent(event); </div><div class="t m0 x0 h15 y28fa ff99 fs6 fc0 sc0 ls21 wsb">    alert(event.data); </div><div class="t m0 x0 h15 y28fb ff99 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 h15 y28fc ff99 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y28fd ff99 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(textbox, &quot;compositionend&quot;, function(event){ </div><div class="t m0 x0 h15 y28fe ff99 fs6 fc0 sc0 ls21 wsb">    event = EventUtil.getEvent(event); </div><div class="t m0 x0 h15 y28ff ff99 fs6 fc0 sc0 ls21 wsb">    alert(event.data); </div><div class="t m0 x0 h15 y2900 ff99 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x2 hf y269b ff97 fs2 fc0 sc0 ls8 wsb">CompositionEventsExample01.htm </div><div class="t m0 x0 h5 y21c5 ff8b fs2 fc0 sc0 ls46 ws37">IE9+是到2011年唯一支持复合事件的浏览器。由于缺少支持，对于需要开发跨浏览器应用的开发</div><div class="t m0 x0 h5 y148c ff92 fs2 fc0 sc0 ls8 wseb">人员，它的用处不大。要确定浏览器是否支持复合事件，可以使用以下代码： </div><div class="t m0 x0 hb y2901 ff96 fs6 fc0 sc0 ls21 wsb">var isSupported = document.implementation.hasFeature(&quot;CompositionEvent&quot;, &quot;3.0&quot;); </div><div class="t m0 x0 h20 y343 ff90 fs3 fc0 sc0 ls248 ws214">13.4.6 变动事件 </div><div class="t m0 x0 h5 y2902 ff8b fs2 fc0 sc0 ls24a ws215">DOM2级的变动（mutation）事件能在DOM中的某一部分发生变化时给出提示。变动事件是为XML</div><div class="t m0 x0 h5 y2903 ff92 fs2 fc0 sc0 ls3b">或HTML DOM设计的，并不特定于某种语言。DOM2级定义了如下变动事件。 </div><div class="t m0 x0 h5 y2904 ff91 fs1 fc0 sc0 ls2"> DOMSubtreeModified：在DOM结构中发生任何变化时触发。这个事件在其他任何事件触发</div><div class="t m0 x5 h5 y2905 ff92 fs2 fc0 sc0 ls8 wseb">后都会触发。 </div><div class="t m0 x0 h5 y2906 ff91 fs1 fc0 sc0 ls2"> DOMNodeInserted：在一个节点作为子节点被插入到另一个节点中时触发。 </div><div class="t m0 x0 h5 y2d0 ff91 fs1 fc0 sc0 ls2"> DOMNodeRemoved：在节点从其父节点中被移除时触发。 </div><div class="t m0 x0 h4 y4c2 ff91 fs1 fc0 sc0 ls2"> DOMNodeInsertedIntoDocument：在一个节点被直接插入文档或通过子树间接插入文档之后</div><div class="t m0 x5 h5 y2d2 ff92 fs2 fc0 sc0 ls8 wseb">触发。这个事件在DOMNodeInserted之后触发。 </div><div class="t m0 x0 h4 y2881 ff91 fs1 fc0 sc0 ls2"> DOMNodeRemovedFromDocument：在一个节点被直接从文档中移除或通过子树间接从文档中移</div><div class="t m0 x5 hc y2907 ff92 fs2 fc0 sc0 ls8 wseb">除之前触发。这个事件在DOMNodeRemoved之后触发。 </div><div class="t m0 x0 h5 y2908 ff91 fs1 fc0 sc0 ls2"> DOMAttrModified：在特性被修改之后触发。 </div><div class="t m0 x0 h5 y2d6 ff91 fs1 fc0 sc0 ls2"> DOMCharacterDataModified：在文本节点的值发生变化时触发。 </div></div></div>
<div id="pf194" class="pf w0 h0" data-page-no="194"><div class="pc pc194 w0 h0"><div class="t m0 x0 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">386  第13章 事件 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff92 fs2 fc0 sc0 ls8 wseb">使用下列代码可以检测出浏览器是否支持变动事件： </div><div class="t m0 x0 hb y3a5 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3a6 ff96 fs6 fc0 sc0 ls21 wsb">var isSupported = document.implementation.hasFeature(&quot;MutationEvents&quot;, &quot;2.0&quot;); </div><div class="t m0 x0 hb y290a ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y290b ff8b fs2 fc0 sc0 ls2a ws21">IE8及更早版本不支持任何变动事件。下表列出了不同浏览器对不同变动事件的支持情况。 </div><div class="t m0 x0 hb y290c ff96 fs6 fc0 sc0 ls8 wsb">  </div><div class="t m0 x0 h31 y290d ff8f fs6 fc0 sc0 lsa7 wsb">事  件 Opera 9+  Firefox 3+  Safari 3+及Chrome  IE9+ </div><div class="t m0 x0 h32 y290e ff96 fsc fc0 sc0 ls238 wsb">DOMSubtreeModified  － 支持 支持 支持 </div><div class="t m0 x0 h32 y290f ff96 fsc fc0 sc0 ls238 wsb">DOMNodeInserted  支持 支持 支持 支持 </div><div class="t m0 x0 h32 y1aa7 ff96 fsc fc0 sc0 ls238 wsb">DOMNodeRemoved  支持 支持 支持 支持 </div><div class="t m0 x0 hb y1aa8 ff96 fs6 fc0 sc0 ls8 wsb">  </div><div class="t m0 x0 h5 y2910 ff92 fs2 fc0 sc0 ls8 wseb">由于DOM3级事件模块作废了很多变动事件，所以本节只介绍那些将来仍然会得到支持的事件。 </div><div class="t m0 x0 h3c y2911 ff90 fs2 fc0 sc0 ls2e wsb">1. 删除节点 </div><div class="t m0 x0 he3 y2912 ff92 fs2 fc0 sc0 ls8 wseb">在使用removeChild()或replaceChild()从DOM中删除节点时，首先会触发DOMNodeRemoved</div><div class="t m0 x0 h4 y2913 ff92 fs2 fc0 sc0 ls8 wseb">事件。这个事件的目标（event.target）是被删除的节点，而event.relatedNode属性中包含着对</div><div class="t m0 x0 h1e y2914 ff92 fs2 fc0 sc0 ls8 wseb">目标节点父节点的引用。在这个事件触发时，节点尚未从其父节点删除，因此其parentNode属性仍然</div><div class="t m0 x0 hc y2915 ff92 fs2 fc0 sc0 ls8 wseb">指向父节点（与event.relatedNode相同）。这个事件会冒泡，因而可以在DOM的任何层次上面处</div><div class="t m0 x0 h5 y12c7 ff92 fs2 fc0 sc0 ls8">理它。 </div><div class="t m0 x0 h4 y2916 ff92 fs2 fc0 sc0 ls147">如果被移除的节点包含子节点，那么在其所有子节点以及这个被移除的节点上会相继触发</div><div class="t m0 x0 h4 y2917 ff96 fs1 fc0 sc0 ls9 ws2">DOMNodeRemovedFromDocument事件。但这个事件不会冒泡，所以只有直接指定给其中一个子节点的</div><div class="t m0 x0 h4 y12ca ff92 fs2 fc0 sc0 ls5 wsec">事件处理程序才会被调用。这个事件的目标是相应的子节点或者那个被移除的节点，除此之外event</div><div class="t m0 x0 h5 y2918 ff92 fs2 fc0 sc0 ls8 wseb">对象中不包含其他信息。 </div><div class="t m0 x0 h4 y2919 ff92 fs2 fc0 sc0 ls8 wseb">紧随其后触发的是DOMSubtreeModified事件。这个事件的目标是被移除节点的父节点；此时的</div><div class="t m0 x0 h5 y291a ff96 fs1 fc0 sc0 ls9 ws2">event对象也不会提供与事件相关的其他信息。 </div><div class="t m0 x0 h5 y291b ff92 fs2 fc0 sc0 ls8 wseb">为了理解上述事件的触发过程，下面我们就以一个简单的HTML页面为例。 </div><div class="t m0 x0 hb y291c ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y291d ff96 fs6 fc0 sc0 ls21 wsb">&lt;! DOCTYPE html&gt; </div><div class="t m0 x0 hb y291e ff96 fs6 fc0 sc0 ls21 wsb">&lt;html&gt; </div><div class="t m0 x0 hb y291f ff96 fs6 fc0 sc0 ls21 wsb">&lt;head&gt; </div><div class="t m0 x0 hb y2920 ff96 fs6 fc0 sc0 ls21 wsb">    &lt;title&gt;Node Removal Events Example&lt;/title&gt; </div><div class="t m0 x0 hb y2921 ff96 fs6 fc0 sc0 ls21 wsb">&lt;/head&gt; </div><div class="t m0 x0 hb y2922 ff96 fs6 fc0 sc0 ls21 wsb">&lt;body&gt; </div><div class="t m0 x0 hb y2923 ff96 fs6 fc0 sc0 ls21 wsb">    &lt;ul id=&quot;myList&quot;&gt; </div><div class="t m0 x0 hb y2924 ff96 fs6 fc0 sc0 ls21 wsb">        &lt;li&gt;Item 1&lt;/li&gt; </div><div class="t m0 x0 hb y2925 ff96 fs6 fc0 sc0 ls21 wsb">        &lt;li&gt;Item 2&lt;/li&gt; </div><div class="t m0 x0 hb y2926 ff96 fs6 fc0 sc0 ls21 wsb">        &lt;li&gt;Item 3&lt;/li&gt; </div><div class="t m0 x0 hb y2927 ff96 fs6 fc0 sc0 ls21 wsb">    &lt;/ul&gt; </div><div class="t m0 x0 hb y2928 ff96 fs6 fc0 sc0 ls21 wsb">&lt;/body&gt; </div><div class="t m0 x0 hb y2929 ff96 fs6 fc0 sc0 ls21 wsb">&lt;/html&gt; </div><div class="t m0 x0 hb y292a ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y292b ff92 fs2 fc0 sc0 ls8 wseb">在这个例子中，我们假设要移除&lt;ul&gt;元素。此时，就会依次触发以下事件。 </div><div class="t m0 x0 h5 y292c ff8b fs2 fc0 sc0 ls13 wsb">(1) 在&lt;ul&gt;元素上触发DOMNodeRemoved事件。relatedNode属性等于document.body。 </div><div class="t m0 x0 hc y292d ff8b fs2 fc0 sc0 ls13 wsb">(2) 在&lt;ul&gt;元素上触发DOMNodeRemovedFromDocument事件。 </div><div class="t m0 x0 h5 y292e ff8b fs2 fc0 sc0 ls13 wsb">(3) 在身为&lt;ul&gt;元素子节点的每个&lt;li&gt;元素及文本节点上触发DOMNodeRemovedFromDocument</div><div class="t m0 x0 h5 y292f ff92 fs2 fc0 sc0 ls8">事件。 </div><div class="t m0 x0 h5 y2930 ff8b fs2 fc0 sc0 ls13 wsb">(4) 在document.body上触发DOMSubtreeModified 事件，因为&lt;ul&gt;元素是document.body</div><div class="t m0 x0 h5 y2661 ff92 fs2 fc0 sc0 ls8 wseb">的直接子元素。 </div></div></div>
<div id="pf195" class="pf w0 h0" data-page-no="195"><div class="pc pc195 w0 h0"><div class="t m0 x2 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">13.4 事件类型    387 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff8d fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff8d fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff8d fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff8d fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff8d fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff8d fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff8d fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff8d fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff8d fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff8d fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff8d fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff8d fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff8d fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff92 fs2 fc0 sc0 ls8 wseb">运行下列代码可以验证以上事件发生的顺序。 </div><div class="t m0 x5 hb yfb2 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2377 ff96 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(window, &quot;load&quot;, function(event){ </div><div class="t m0 x0 hb y2378 ff96 fs6 fc0 sc0 ls21 wsb">    var list = document.getElementById(&quot;myList&quot;); </div><div class="t m0 x0 hb y2379 ff96 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 hb y2931 ff96 fs6 fc0 sc0 ls21 wsb">    EventUtil.addHandler(document, &quot;DOMSubtreeModified&quot;, function(event){ </div><div class="t m0 x0 hb y2932 ff96 fs6 fc0 sc0 ls21 wsb">        alert(event.type); </div><div class="t m0 x0 hb y2933 ff96 fs6 fc0 sc0 ls21 wsb">        alert(event.target); </div><div class="t m0 x0 hb y2934 ff96 fs6 fc0 sc0 ls21 wsb">    }); </div><div class="t m0 x0 hb y2935 ff96 fs6 fc0 sc0 ls21 wsb">    EventUtil.addHandler(document, &quot;DOMNodeRemoved&quot;, function(event){ </div><div class="t m0 x0 hb y2936 ff96 fs6 fc0 sc0 ls21 wsb">        alert(event.type); </div><div class="t m0 x0 hb y2937 ff96 fs6 fc0 sc0 ls21 wsb">        alert(event.target); </div><div class="t m0 x0 hb y2938 ff96 fs6 fc0 sc0 ls21 wsb">        alert(event.relatedNode); </div><div class="t m0 x0 hb y2939 ff96 fs6 fc0 sc0 ls21 wsb">    }); </div><div class="t m0 x0 hb y293a ff96 fs6 fc0 sc0 ls1b0 wsb">    EventUtil.addHandler(list.firstChild, &quot;DOMNodeRemovedFromDocument&quot;, function(event){ </div><div class="t m0 x0 hb y293b ff96 fs6 fc0 sc0 ls21 wsb">        alert(event.type); </div><div class="t m0 x0 hb y293c ff96 fs6 fc0 sc0 ls21 wsb">        alert(event.target); </div><div class="t m0 x0 hb y293d ff96 fs6 fc0 sc0 ls21 wsb">    });             </div><div class="t m0 x0 hb y293e ff96 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 hb y293f ff96 fs6 fc0 sc0 ls21 wsb">    list.parentNode.removeChild(list); </div><div class="t m0 x0 hb y2940 ff96 fs6 fc0 sc0 ls21 wsb">});  </div><div class="t m0 x0 h4 y2941 ff92 fs2 fc0 sc0 ls8 wseb">以上代码为document添加了针对DOMSubtreeModified和DOMNodeRemoved事件的处理程序 ，</div><div class="t m0 x0 h1e y2942 ff92 fs2 fc0 sc0 ls8 wseb">以便在页面上处理这些事件。由于DOMNodeRemovedFromDocument不会冒泡，所以我们将针对它的</div><div class="t m0 x0 h5 y2943 ff92 fs2 fc0 sc0 ls8 wseb">事件处理程序直接添加给了&lt;ul&gt;元素的第一个子节点（在兼容DOM的浏览器中是一个文本节点）。在</div><div class="t m0 x0 hc y2944 ff92 fs2 fc0 sc0 ls8 wseb">设置了以上事件处理程序后，代码从文档中移除了&lt;ul&gt;元素。 </div><div class="t m0 x0 h3c y2945 ff90 fs2 fc0 sc0 ls2e wsb">2. 插入节点 </div><div class="t m0 x0 hb8 y2946 ff92 fs2 fc0 sc0 ls8 wseb">在使用appendChild()、replaceChild()或insertBefore()向DOM中插入节点时，首先会</div><div class="t m0 x0 h1e y2947 ff92 fs2 fc0 sc0 ls8 wseb">触发DOMNodeInserted事件。这个事件的目标是被插入的节点，而event.relatedNode属性中包含</div><div class="t m0 x0 h4 y2948 ff92 fs2 fc0 sc0 ls8 wseb">一个对父节点的引用。在这个事件触发时，节点已经被插入到了新的父节点中。这个事件是冒泡的，因</div><div class="t m0 x0 h5 y2949 ff92 fs2 fc0 sc0 ls8 wseb">此可以在DOM的各个层次上处理它。 </div><div class="t m0 x0 h1c y294a ff92 fs2 fc0 sc0 ls8 wseb">紧接着，会在新插入的节点上面触发DOMNodeInsertedIntoDocument事件。这个事件不冒泡，</div><div class="t m0 x0 h4 y294b ff92 fs2 fc0 sc0 ls4">因此必须在插入节点之前为它添加这个事件处理程序。这个事件的目标是被插入的节点，除此之外</div><div class="t m0 x0 h5 y7c5 ff96 fs1 fc0 sc0 ls9 ws2">event对象中不包含其他信息。 </div><div class="t m0 x0 hc y294c ff92 fs2 fc0 sc0 ls8 wseb">最后一个触发的事件是DOMSubtreeModified，触发于新插入节点的父节点。 </div><div class="t m0 x0 h5 y294d ff92 fs2 fc0 sc0 ls8 wseb">我们仍以前面的HTML文档为例，可以通过下列JavaScript代码来验证上述事件的触发顺序。 </div><div class="t m0 x5 hb y294e ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y294f ff96 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(window, &quot;load&quot;, function(event){ </div><div class="t m0 x0 hb y2950 ff96 fs6 fc0 sc0 ls21 wsb">    var list = document.getElementById(&quot;myList&quot;); </div><div class="t m0 x0 hb y2951 ff96 fs6 fc0 sc0 ls21 wsb">    var item = document.createElement(&quot;li&quot;); </div><div class="t m0 x0 hb y2952 ff96 fs6 fc0 sc0 ls21 wsb">    item.appendChild(document.createTextNode(&quot;Item 4&quot;)); </div><div class="t m0 x0 hb y2953 ff96 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 hb y2954 ff96 fs6 fc0 sc0 ls21 wsb">    EventUtil.addHandler(document, &quot;DOMSubtreeModified&quot;, function(event){ </div><div class="t m0 x0 hb y2955 ff96 fs6 fc0 sc0 ls21 wsb">        alert(event.type); </div><div class="t m0 x0 hb y2956 ff96 fs6 fc0 sc0 ls21 wsb">        alert(event.target); </div><div class="t m0 x0 hb y2957 ff96 fs6 fc0 sc0 ls21 wsb">    }); </div><div class="t m0 x0 hb y2958 ff96 fs6 fc0 sc0 ls21 wsb">    EventUtil.addHandler(document, &quot;DOMNodeInserted&quot;, function(event){ </div><div class="t m0 x0 hb y2959 ff96 fs6 fc0 sc0 ls21 wsb">        alert(event.type); </div><div class="t m0 x0 hb y295a ff96 fs6 fc0 sc0 ls21 wsb">        alert(event.target); </div><div class="t m0 x0 hb y295b ff96 fs6 fc0 sc0 ls21 wsb">        alert(event.relatedNode); </div><div class="t m0 x0 hb y295c ff96 fs6 fc0 sc0 ls21 wsb">    }); </div><div class="t m0 x0 hb y295d ff96 fs6 fc0 sc0 ls21 wsb">    EventUtil.addHandler(item, &quot;DOMNodeInsertedIntoDocument&quot;, function(event){ </div><div class="t m0 x0 hb y295e ff96 fs6 fc0 sc0 ls21 wsb">        alert(event.type); </div></div></div>
<div id="pf196" class="pf w0 h0" data-page-no="196"><div class="pc pc196 w0 h0"><div class="t m0 x0 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">388  第13章 事件 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y44f ff96 fs6 fc0 sc0 ls21 wsb">        alert(event.target); </div><div class="t m0 x0 hb y450 ff96 fs6 fc0 sc0 ls21 wsb">    });             </div><div class="t m0 x0 hb y295f ff96 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 hb y2960 ff96 fs6 fc0 sc0 ls21 wsb">    list.appendChild(item); </div><div class="t m0 x0 hb y7ad ff96 fs6 fc0 sc0 ls21 wsb">});  </div><div class="t m0 x0 h4 y2961 ff92 fs2 fc0 sc0 ls4c wsfa">以上代码首先创建了一个包含文本&quot;Item 4&quot;的新&lt;li&gt;元素。由于DOMSubtreeModified和</div><div class="t m0 x0 h4 y2962 ff96 fs1 fc0 sc0 ls9 ws2">DOMNodeInserted事件是冒泡的，所以把它们的事件处理程序添加到了文档中。在将列表项插入到其</div><div class="t m0 x0 h1e y2963 ff92 fs2 fc0 sc0 ls8 wseb">父节点之前，先将DOMNodeInsertedIntoDocument事件的事件处理程序添加给它。最后一步就是使</div><div class="t m0 x0 h1e y2964 ff92 fs2 fc0 sc0 ls36d">用appendChild()来添加这个列表项；此时，事件开始依次被触发。首先是在新&lt;li&gt;元素项上触发</div><div class="t m0 x0 h4 y2965 ff96 fs1 fc0 sc0 ls9 ws2">DOMNodeInserted事件，其relatedNode 是&lt;ul&gt;元素。然后是触发新&lt;li&gt;元素上的DOMNode- </div><div class="t m0 x0 h5 y2966 ff96 fs1 fc0 sc0 ls9 ws2">InsertedIntoDocument事件，最后触发的是&lt;ul&gt;元素上的DOMSubtreeModified事件。 </div><div class="t m0 x0 h20 y2967 ff90 fs3 fc0 sc0 ls248 ws214">13.4.7 HTML5事件 </div><div class="t m0 x0 h5 y8a2 ff8b fs2 fc0 sc0 ls81 ws76">DOM规范没有涵盖所有浏览器支持的所有事件。很多浏览器出于不同的目的——满足用户需求或</div><div class="t m0 x0 h5 y2968 ff92 fs2 fc0 sc0 ls8 wseb">解决特殊问题，还实现了一些自定义的事件。HTML5详尽列出了浏览器应该支持的所有事件。本节只</div><div class="t m0 x0 h5 y2969 ff92 fs2 fc0 sc0 ls8 wseb">讨论其中得到浏览器完善支持的事件，但并非全部事件。（其他事件会在本书其他章节讨论。） </div><div class="t m0 x0 h4e y296a ff90 fs2 fc0 sc0 ls2e wsb">1. contextmenu事件 </div><div class="t m0 x0 h5 y296b ff8b fs2 fc0 sc0 lsfa ws1aa">Windows 95在PC中引入了上下文菜单的概念，即通过单击鼠标右键可以调出上下文菜单。不久，</div><div class="t m0 x0 h5 y296c ff92 fs2 fc0 sc0 ls8 wseb">这个概念也被引入了Web领域。为了实现上下文菜单，开发人员面临的主要问题是如何确定应该显示</div><div class="t m0 x0 h5 y296d ff92 fs2 fc0 sc0 ls8 wseb">上下文菜单（在Windows中，是右键单击；在Mac中，是 Ctrl+单击），以及如何屏蔽与该操作关联的</div><div class="t m0 x0 he4 y296e ff92 fs2 fc0 sc0 ls8 wseb">默认上下文菜单。为解决这个问题，就出现了contextmenu这个事件，用以表示何时应该显示上下文</div><div class="t m0 x0 h5 y1171 ff92 fs2 fc0 sc0 ls8 wseb">菜单，以便开发人员取消默认的上下文菜单而提供自定义的菜单。 </div><div class="t m0 x0 h1e y296f ff92 fs2 fc0 sc0 ls8 wseb">由于contextmenu事件是冒泡的，因此可以为document指定一个事件处理程序，用以处理页面</div><div class="t m0 x0 h4 y2970 ff92 fs2 fc0 sc0 ls8 wseb">中发生的所有此类事件。这个事件的目标是发生用户操作的元素。在所有浏览器中都可以取消这个事件：</div><div class="t m0 x0 he y2971 ff92 fs2 fc0 sc0 ls8 wseb">在兼容DOM的浏览器中，使用event.preventDefalut()；在IE中，将event .returnValue的值</div><div class="t m0 x0 h1e y2972 ff92 fs2 fc0 sc0 ls8 wseb">设置为false。因为contextmenu事件属于鼠标事件，所以其事件对象中包含与光标位置有关的所有</div><div class="t m0 x0 h4 y1ca9 ff92 fs2 fc0 sc0 ls8 wseb">属性。通常使用contextmenu事件来显示自定义的上下文菜单，而使用onclick 事件处理程序来隐</div><div class="t m0 x0 h5 y1caa ff92 fs2 fc0 sc0 ls8 wseb">藏该菜单。以下面的HTML页面为例。 </div><div class="t m0 x0 hb y28e8 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2973 ff96 fs6 fc0 sc0 ls21 wsb">&lt;!DOCTYPE html&gt; </div><div class="t m0 x0 hb y2974 ff96 fs6 fc0 sc0 ls21 wsb">&lt;html&gt; </div><div class="t m0 x0 hb y2975 ff96 fs6 fc0 sc0 ls21 wsb">&lt;head&gt;  </div><div class="t m0 x0 hb y2976 ff96 fs6 fc0 sc0 ls21 wsb">    &lt;title&gt;ContextMenu Event Example&lt;/title&gt; </div><div class="t m0 x0 hb y2977 ff96 fs6 fc0 sc0 ls21 wsb">&lt;/head&gt; </div><div class="t m0 x0 hb y2978 ff96 fs6 fc0 sc0 ls21 wsb">&lt;body&gt; </div><div class="t m0 x0 hb y2979 ff96 fs6 fc0 sc0 ls21 wsb">    &lt;div id=&quot;myDiv&quot;&gt;Right click or Ctrl+click me to get a custom context menu. </div><div class="t m0 x0 hb y297a ff96 fs6 fc0 sc0 ls21 wsb">        Click anywhere else to get the default context menu.&lt;/div&gt; </div><div class="t m0 x0 hb y297b ff96 fs6 fc0 sc0 ls21 wsb">    &lt;ul id=&quot;myMenu&quot; style=&quot;position:absolute;visibility:hidden;background-color: </div><div class="t m0 x0 hb y297c ff96 fs6 fc0 sc0 ls21 wsb">        silver&quot;&gt; </div><div class="t m0 x0 h16 y297d ff96 fs6 fc0 sc0 ls21 wsb">        &lt;li&gt;&lt;a href=&quot;http://www.nczonline.net&quot;&gt;Nicholas’ site&lt;/a&gt;&lt;/li&gt; </div><div class="t m0 x0 hb y297e ff96 fs6 fc0 sc0 ls21 wsb">        &lt;li&gt;&lt;a href=&quot;http://www.wrox.com&quot;&gt;Wrox site&lt;/a&gt;&lt;/li&gt; </div><div class="t m0 x0 hb y297f ff96 fs6 fc0 sc0 ls21 wsb">        &lt;li&gt;&lt;a href=&quot;http://www.yahoo.com&quot;&gt;Yahoo!&lt;/a&gt;&lt;/li&gt; </div><div class="t m0 x0 hb y2980 ff96 fs6 fc0 sc0 ls21 wsb">    &lt;/ul&gt; </div><div class="t m0 x0 hb y2981 ff96 fs6 fc0 sc0 ls21 wsb">&lt;/body&gt; </div><div class="t m0 x0 hb y2982 ff96 fs6 fc0 sc0 ls21 wsb">&lt;/html&gt; </div><div class="t m0 x2 hf y2983 ff97 fs2 fc0 sc0 ls79 wsb">ContextMenuEventExample01.htm </div></div></div>
<div id="pf197" class="pf w0 h0" data-page-no="197"><div class="pc pc197 w0 h0"><div class="t m0 x2 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">13.4 事件类型    389 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff8d fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff8d fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff8d fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff8d fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff8d fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff8d fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff8d fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff8d fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff8d fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff8d fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff8d fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff8d fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff8d fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h4 y3 ff92 fs2 fc0 sc0 ls8 wseb">这里的&lt;div&gt;元素包含一个自定义的上下文菜单。其中，&lt;ul&gt;元素作为自定义上下文菜单，并且在</div><div class="t m0 x0 h5 y4d ff92 fs2 fc0 sc0 ls8 wseb">初始时是隐藏的。实现这个例子的JavaScript代码如下所示。 </div><div class="t m0 x0 hb y1701 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2984 ff96 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(window, &quot;load&quot;, function(event){ </div><div class="t m0 x0 hb y2985 ff96 fs6 fc0 sc0 ls21 wsb">    var div = document.getElementById(&quot;myDiv&quot;); </div><div class="t m0 x0 hb y2986 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2987 ff96 fs6 fc0 sc0 ls21 wsb">    EventUtil.addHandler(div, &quot;contextmenu&quot;, function(event){ </div><div class="t m0 x0 hb y2988 ff96 fs6 fc0 sc0 ls21 wsb">        event = EventUtil.getEvent(event); </div><div class="t m0 x0 hb y2989 ff96 fs6 fc0 sc0 ls21 wsb">        EventUtil.preventDefault(event); </div><div class="t m0 x0 hb y298a ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y298b ff96 fs6 fc0 sc0 ls21 wsb">        var menu = document.getElementById(&quot;myMenu&quot;); </div><div class="t m0 x0 hb y298c ff96 fs6 fc0 sc0 ls21 wsb">        menu.style.left = event.clientX + &quot;px&quot;; </div><div class="t m0 x0 hb y298d ff96 fs6 fc0 sc0 ls21 wsb">        menu.style.top = event.clientY + &quot;px&quot;; </div><div class="t m0 x0 hb y298e ff96 fs6 fc0 sc0 ls21 wsb">        menu.style.visibility = &quot;visible&quot;; </div><div class="t m0 x0 hb y298f ff96 fs6 fc0 sc0 ls21 wsb">    }); </div><div class="t m0 x0 hb y2990 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2991 ff96 fs6 fc0 sc0 ls21 wsb">    EventUtil.addHandler(document, &quot;click&quot;, function(event){ </div><div class="t m0 x0 hb y2992 ff96 fs6 fc0 sc0 ls21 wsb">        document.getElementById(&quot;myMenu&quot;).style.visibility = &quot;hidden&quot;; </div><div class="t m0 x0 hb y2993 ff96 fs6 fc0 sc0 ls21 wsb">    }); </div><div class="t m0 x0 hb y2994 ff96 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 hb y2995 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y2996 ff97 fs2 fc0 sc0 ls79 wsb">ContextMenuEventExample01.htm </div><div class="t m0 x0 h4 y648 ff92 fs2 fc0 sc0 ls8 wseb">在这个例子中，我们为&lt;div&gt;元素添加了oncontextmenu事件的处理程序。这个事件处理程序首</div><div class="t m0 x0 h1e y649 ff92 fs2 fc0 sc0 ls8 wseb">先会取消默认行为，以保证不显示浏览器默认的上下文菜单。然后，再根据event对象 clientX和</div><div class="t m0 x0 h4 y2997 ff96 fs1 fc0 sc0 ls9 ws2">clientY属性的值，来确定放置&lt;ul&gt;元素的位置。最后一步就是通过将visibility 属性设置为</div><div class="t m0 x0 h4 y2892 ff96 fs1 fc0 sc0 ls9 ws2">&quot;visible&quot;来显示自定义上下文菜单。另外，还为document添加了一个onclick事件处理程序，以</div><div class="t m0 x0 h5 y2998 ff92 fs2 fc0 sc0 ls8 wseb">便用户能够通过鼠标单击来隐藏菜单（单击也是隐藏系统上下文菜单的默认操作）。 </div><div class="t m0 x0 h5 y2999 ff92 fs2 fc0 sc0 ls8 wseb">虽然这个例子很简单，但它却展示了Web上所有自定义上下文菜单的基本结构。只需为这个例子</div><div class="t m0 x0 h5 y299a ff92 fs2 fc0 sc0 ls8 wseb">中的上下文菜单添加一些CSS样式，就可以得到非常棒的效果。 </div><div class="t m0 x0 h14 y299b ff92 fs2 fc0 sc0 ls8 wseb">支持contextmenu事件的浏览器有IE、Firefox、Safari、Chrome和Opera 11+。 </div><div class="t m0 x0 hab y299c ff90 fs2 fc0 sc0 ls94 ws2ef">2. beforeunload事件 </div><div class="t m0 x0 h4 y299d ff92 fs2 fc0 sc0 ls8 wseb">之所以有发生在window对象上的beforeunload 事件，是为了让开发人员有可能在页面卸载前</div><div class="t m0 x0 h4 y299e ff92 fs2 fc0 sc0 ls8 wseb">阻止这一操作。这个事件会在浏览器卸载页面之前触发，可以通过它来取消卸载并继续使用原有页面。</div><div class="t m0 x0 h4 y299f ff92 fs2 fc0 sc0 ls8 wseb">但是，不能彻底取消这个事件，因为那就相当于让用户无法离开当前页面了。为此，这个事件的意图是</div><div class="t m0 x0 h4 y29a0 ff92 fs2 fc0 sc0 ls6 wsf7">将控制权交给用户。显示的消息会告知用户页面行将被卸载（正因为如此才会显示这个消息），询问用</div><div class="t m0 x0 h5 y29a1 ff92 fs2 fc0 sc0 ls8 wseb">户是否真的要关闭页面，还是希望继续留下来（见图13-9）。 </div><div class="t m0 x2 h5 y29a2 ff8b fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 h3 y18c3 ff92 fs1 fc0 sc0 ls8 wsb">图 13-9 </div><div class="t m0 x0 h4 y29a3 ff92 fs2 fc0 sc0 ls8 wseb">为了显示这个弹出对话框，必须将event.returnValue的值设置为要显示给用户的字符串（对</div><div class="t m0 x0 h5 y29a4 ff8b fs2 fc0 sc0 lse ws9">IE及Fiefox而言），同时作为函数的值返回（对Safari和Chrome而言），如下面的例子所示。 </div></div></div>
<div id="pf198" class="pf w0 h0" data-page-no="198"><div class="pc pc198 w0 h0"><div class="t m0 x0 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">390  第13章 事件 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 ff96 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(window, &quot;beforeunload&quot;, function(event){ </div><div class="t m0 x0 hb y7a ff96 fs6 fc0 sc0 ls21 wsb">    event = EventUtil.getEvent(event); </div><div class="t m0 x0 hb y7b ff96 fs6 fc0 sc0 ls21 wsb">    var message = &quot;I&apos;m really going to miss you if you go.&quot;; </div><div class="t m0 x0 hb y7c ff96 fs6 fc0 sc0 ls21 wsb">    event.returnValue = message; </div><div class="t m0 x0 hb y7d ff96 fs6 fc0 sc0 ls21 wsb">    return message; </div><div class="t m0 x0 hb y7e ff96 fs6 fc0 sc0 ls21 wsb">});  </div><div class="t m0 x4 hf y9c0 ff97 fs2 fc0 sc0 ls25 wsb">BeforeUnloadEventExample01.htm </div><div class="t m0 x0 h5 y9c1 ff8b fs2 fc0 sc0 lse ws9">IE和Firefox、Safari和Chrome都支持beforeunload事件，也都会弹出这个对话框询问用户是否</div><div class="t m0 x0 hc y9c2 ff92 fs2 fc0 sc0 ls8 wseb">真想离开。Opera 11及之前的版本不支持beforeunload事件。 </div><div class="t m0 x0 h47 y29a6 ff90 fs2 fc0 sc0 ls2e wsb">3. DOMContentLoaded事件 </div><div class="t m0 x0 h4 y29a7 ff92 fs2 fc0 sc0 ls8 wseb">如前所述，window的load事件会在页面中的一切都加载完毕时触发，但这个过程可能会因为要</div><div class="t m0 x0 hc y29a8 ff92 fs2 fc0 sc0 ls8 wseb">加载的外部资源过多而颇费周折。而DOMContentLoaded事件则在形成完整的DOM树之后就会触发，</div><div class="t m0 x0 h5 y901 ff92 fs2 fc0 sc0 ls339">不理会图像、JavaScript文件、CSS文件或其他资源是否已经下载完毕。与 load事件不同，</div><div class="t m0 x0 h4 y29a9 ff96 fs1 fc0 sc0 ls9 ws2">DOMContentLoaded支持在页面下载的早期添加事件处理程序，这也就意味着用户能够尽早地与页面</div><div class="t m0 x0 h5 y29aa ff92 fs2 fc0 sc0 ls8 wseb">进行交互。 </div><div class="t m0 x0 h1c y29ab ff92 fs2 fc0 sc0 ls8 wseb">要处理DOMContentLoaded事件，可以为document或window 添加相应的事件处理程序（尽管</div><div class="t m0 x0 h5 y29ac ff92 fs2 fc0 sc0 ls8 wseb">这个事件会冒泡到window，但它的目标实际上是document）。来看下面的例子。 </div><div class="t m0 x0 h5 y29ad ff8b fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y29ae ff96 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(document, &quot;DOMContentLoaded&quot;, function(event){ </div><div class="t m0 x0 hb y29af ff96 fs6 fc0 sc0 ls21 wsb">    alert(&quot;Content loaded&quot;); </div><div class="t m0 x0 hb y29b0 ff96 fs6 fc0 sc0 ls21 wsb">});  </div><div class="t m0 x0 hb y29b1 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf y29b2 ff97 fs2 fc0 sc0 ls1b wsb">DOMContentLoadedEventExample01.htm </div><div class="t m0 x0 h5 y2519 ff96 fs1 fc0 sc0 ls9 ws2">DOMContentLoaded事件对象不会提供任何额外的信息（其target属性是document）。 </div><div class="t m0 x0 h5 y29b3 ff8b fs2 fc0 sc0 ls46 ws37">IE9+、Firefox、Chrome、Safari 3.1+和Opera 9+都支持DOMContentLoaded事件，通常这个事件</div><div class="t m0 x0 h5 y29b4 ff92 fs2 fc0 sc0 ls8 wseb">既可以添加事件处理程序，也可以执行其他DOM操作。这个事件始终都会在load事件之前触发。 </div><div class="t m0 x0 hc y1f22 ff92 fs2 fc0 sc0 ls8 wseb">对于不支持DOMContentLoaded的浏览器，我们建议在页面加载期间设置一个时间为0毫秒的超</div><div class="t m0 x0 h5 y29b5 ff92 fs2 fc0 sc0 ls8 wseb">时调用，如下面的例子所示。 </div><div class="t m0 x0 hb y2759 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y29b6 ff96 fs6 fc0 sc0 ls21 wsb">setTimeout(function(){ </div><div class="t m0 x0 h16 y29b7 ff96 fs6 fc0 sc0 ls21 wsb">    //在此添加事件处理程序 </div><div class="t m0 x0 hb y29b8 ff96 fs6 fc0 sc0 ls21 wsb">}, 0); </div><div class="t m0 x0 h5 y29b9 ff8b fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y29ba ff92 fs2 fc0 sc0 ls8 wseb">这段代码的实际意思就是：“在当前JavaScript处理完成后立即运行这个函数。”在页面下载和构建</div><div class="t m0 x0 h5 y29bb ff92 fs2 fc0 sc0 ls4 ws10d">期间，只有一个JavaScript处理过程，因此超时调用会在该过程结束时立即触发。至于这个时间与</div><div class="t m0 x0 h4 y22cb ff96 fs1 fc0 sc0 ls9 ws2">DOMContentLoaded被触发的时间能否同步，主要还是取决于用户使用的浏览器和页面中的其他代码。</div><div class="t m0 x0 h4 y29bc ff92 fs2 fc0 sc0 ls8 wseb">为了确保这个方法有效，必须将其作为页面中的第一个超时调用；即便如此，也还是无法保证在所有环</div><div class="t m0 x0 hc y29bd ff92 fs2 fc0 sc0 ls8 wseb">境中该超时调用一定会早于load事件被触发。 </div><div class="t m0 x0 h47 y29be ff90 fs2 fc0 sc0 ls2e wsb">4. readystatechange事件 </div><div class="t m0 x0 h5 y29bf ff8b fs2 fc0 sc0 lse ws9">IE为DOM文档中的某些部分提供了readystatechange事件。这个事件的目的是提供与文档或</div><div class="t m0 x0 h1e y29c0 ff92 fs2 fc0 sc0 ls8 wseb">元素的加载状态有关的信息，但这个事件的行为有时候也很难预料。支持readystatechange事件的</div><div class="t m0 x0 hc y1f73 ff92 fs2 fc0 sc0 ls8 wseb">每个对象都有一个readyState属性，可能包含下列5个值中的一个。 </div><div class="t m0 x0 h5 y1bfd ff91 fs1 fc0 sc0 ls2"> uninitialized（未初始化）：对象存在但尚未初始化。 </div></div></div>
<div id="pf199" class="pf w0 h0" data-page-no="199"><div class="pc pc199 w0 h0"><div class="t m0 x2 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">13.4 事件类型    391 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff8d fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff8d fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff8d fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff8d fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff8d fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff8d fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff8d fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff8d fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff8d fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff8d fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff8d fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff8d fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff8d fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff91 fs1 fc0 sc0 ls2"> loading（正在加载）：对象正在加载数据。 </div><div class="t m0 x0 h5 y4 ff91 fs1 fc0 sc0 ls2"> loaded（加载完毕）：对象加载数据完成。 </div><div class="t m0 x0 h5 y4e ff91 fs1 fc0 sc0 ls2"> interactive（交互）：可以操作对象了，但还没有完全加载。 </div><div class="t m0 x0 h5 yd9 ff91 fs1 fc0 sc0 ls2"> complete（完成）：对象已经加载完毕。 </div><div class="t m0 x0 h1e y15d ff92 fs2 fc0 sc0 ls8 wseb">这些状态看起来很直观，但并非所有对象都会经历readyState的这几个阶段。换句话说，如果某</div><div class="t m0 x0 h4 y21a ff92 fs2 fc0 sc0 ls8 wseb">个阶段不适用某个对象，则该对象完全可能跳过该阶段；并没有规定哪个阶段适用于哪个对象。显然，</div><div class="t m0 x0 he y5c8 ff92 fs2 fc0 sc0 ls8 wseb">这意味着readystatechange事件经常会少于4次，而readyState 属性的值也不总是连续的。 </div><div class="t m0 x0 h1e y15f ff92 fs2 fc0 sc0 ls8 wseb">对于document而言，值为&quot;interactive&quot;的readyState会在与 DOMContentLoaded大致相</div><div class="t m0 x0 h5 yb ff92 fs2 fc0 sc0 ls8 wseb">同的时刻触发readystatechange事件。此时，DOM树已经加载完毕，可以安全地操作它了，因此就</div><div class="t m0 x0 h5 y78a ff92 fs2 fc0 sc0 ls55 wsfc">会进入交互（interactive）阶段。但与此同时，图像及其他外部文件不一定可用。下面来看一段处理</div><div class="t m0 x0 h5 yd ff96 fs1 fc0 sc0 ls9 ws2">readystatechange事件的代码。 </div><div class="t m0 x0 hb y29c1 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y29c2 ff96 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(document, &quot;readystatechange&quot;, function(event){ </div><div class="t m0 x0 hb y29c3 ff96 fs6 fc0 sc0 ls21 wsb">    if (document.readyState == &quot;interactive&quot;){ </div><div class="t m0 x0 hb y29c4 ff96 fs6 fc0 sc0 ls21 wsb">        alert(&quot;Content loaded&quot;); </div><div class="t m0 x0 hb y29c5 ff96 fs6 fc0 sc0 ls21 wsb">    }  </div><div class="t m0 x0 hb y29c6 ff96 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 hb y29c7 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y29c8 ff92 fs2 fc0 sc0 ls8 wseb">这个事件的event对象不会提供任何信息，也没有目标对象。 </div><div class="t m0 x0 h1e y29c9 ff92 fs2 fc0 sc0 ls8 wseb">在与load事件一起使用时，无法预测两个事件触发的先后顺序。在包含较多或较大的外部资源的</div><div class="t m0 x0 h1e y29ca ff92 fs2 fc0 sc0 ls8 wseb">页面中，会在load事件触发之前先进入交互阶段；而在包含较少或较小的外部资源的页面中，则很难</div><div class="t m0 x0 hc y29cb ff92 fs2 fc0 sc0 ls2d3">说readystatechange 事件会发生在load事件前面。 </div><div class="t m0 x0 h4 y29cc ff92 fs2 fc0 sc0 ls8 wseb">让问题变得更复杂的是，交互阶段可能会早于也可能会晚于完成阶段出现，无法确保顺序。在包含</div><div class="t m0 x0 h4 y29cd ff92 fs2 fc0 sc0 ls8 wseb">较多外部资源的页面中，交互阶段更有可能早于完成阶段出现；而在页面中包含较少外部资源的情况下，</div><div class="t m0 x0 h4 y29ce ff92 fs2 fc0 sc0 ls8 wseb">完成阶段先于交互阶段出现的可能性更大。因此，为了尽可能抢到先机，有必要同时检测交互和完成阶</div><div class="t m0 x0 h5 y29cf ff92 fs2 fc0 sc0 ls8 wseb">段，如下面的例子所示。 </div><div class="t m0 x0 h5 y29d0 ff8b fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1a79 ff96 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(document, &quot;readystatechange&quot;, function(event){ </div><div class="t m0 x0 hb y29d1 ff96 fs6 fc0 sc0 ls21 wsb">    if (document.readyState == &quot;interactive&quot; || document.readyState == &quot;complete&quot;){ </div><div class="t m0 x0 hb y29d2 ff96 fs6 fc0 sc0 ls21 wsb">        EventUtil.removeHandler(document, &quot;readystatechange&quot;, arguments.callee); </div><div class="t m0 x0 hb y29d3 ff96 fs6 fc0 sc0 ls21 wsb">        alert(&quot;Content loaded&quot;); </div><div class="t m0 x0 hb y29d4 ff96 fs6 fc0 sc0 ls21 wsb">    }  </div><div class="t m0 x0 hb y29d5 ff96 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 hb y29d6 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y8b8 ff92 fs2 fc0 sc0 ls8 wseb">对于上面的代码来说，当readystatechange事件触发时，会检测document.readyState的值，</div><div class="t m0 x0 h4 y29d7 ff92 fs2 fc0 sc0 ls8 wseb">看当前是否已经进入交互阶段或完成阶段。如果是，则移除相应的事件处理程序以免在其他阶段再执行。</div><div class="t m0 x0 h1e y1ae2 ff92 fs2 fc0 sc0 ls8 wseb">注意，由于事件处理程序使用的是匿名函数，因此这里使用了arguments.callee来引用该函数。然</div><div class="t m0 x0 h4 y29d8 ff92 fs2 fc0 sc0 ls6 wsf7">后，会显示一个警告框，说明内容已经加载完毕。这样编写代码可以达到与使用DOMContentLoaded</div><div class="t m0 x0 h5 y39c ff92 fs2 fc0 sc0 ls8 wseb">十分相近的效果。 </div><div class="t m0 x0 hc y29d9 ff92 fs2 fc0 sc0 ls8 wseb">支持readystatechange事件的浏览器有IE、Firfox 4+和Opera。 </div><div class="t m0 x5 h40 y29da ff8c fs2 fc0 sc0 ls8 ws14">虽然使用readystatechange可以十分近似地模拟DOMContentLoaded事件，</div><div class="t m0 x5 ha y29db ff8c fs2 fc0 sc0 ls8 ws14">但它们本质上还是不同的。在不同页面中，load事件与readystatechange事件并</div><div class="t m0 x5 h5 y29dc ff8c fs2 fc0 sc0 ls8 ws14">不能保证以相同的顺序触发。 </div></div></div>
<div id="pf19a" class="pf w0 h0" data-page-no="19a"><div class="pc pc19a w0 h0"><div class="t m0 x0 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">392  第13章 事件 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff92 fs2 fc0 sc0 ls8 wseb">另外， &lt;script&gt;（在IE和Opera中）和&lt;link&gt;（仅IE中）元素也会触发 readystatechange</div><div class="t m0 x0 h5 y4 ff92 fs2 fc0 sc0 ls8 wseb">事件，可以用来确定外部的JavaScript和CSS文件是否已经加载完成。与在其他浏览器中一样，除非把</div><div class="t m0 x0 h4 y5 ff92 fs2 fc0 sc0 ls288 ws24b">动态创建的元素添加到页面中，否则浏览器不会开始下载外部资源。基于元素触发的</div><div class="t m0 x0 h4 yd9 ff96 fs1 fc0 sc0 ls9 ws2">readystatechange事件也存在同样的问题，即readyState 属性无论等于&quot;loaded&quot;还是</div><div class="t m0 x0 h4 y219 ff96 fs1 fc0 sc0 ls9 ws2">&quot;complete&quot;都可以表示资源已经可用。有时候，readyState会停在&quot;loaded&quot;阶段而永远不会“完成”；</div><div class="t m0 x0 h1e y21a ff92 fs2 fc0 sc0 ls8 wseb">有时候，又会跳过&quot;loaded&quot;阶段而直接“完成”。于是，还需要像对待document一样采取相同的编码</div><div class="t m0 x0 h5 y15e ff92 fs2 fc0 sc0 ls8 wseb">方式。例如，下面展示了一段加载外部JavaScript文件的代码。 </div><div class="t m0 x0 hb y970 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y29dd ff96 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(window, &quot;load&quot;, function(){  </div><div class="t m0 x0 hb y29de ff96 fs6 fc0 sc0 ls21 wsb">    var script = document.createElement(&quot;script&quot;); </div><div class="t m0 x0 h15 y29df ff99 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y29e0 ff96 fs6 fc0 sc0 ls21 wsb">    EventUtil.addHandler(script, &quot;readystatechange&quot;, function(event){ </div><div class="t m0 x0 hb y29e1 ff96 fs6 fc0 sc0 ls21 wsb">        event = EventUtil.getEvent(event); </div><div class="t m0 x0 hb y29e2 ff96 fs6 fc0 sc0 ls21 wsb">        var target = EventUtil.getTarget(event); </div><div class="t m0 x0 h15 y29e3 ff99 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y29e4 ff96 fs6 fc0 sc0 ls21 wsb">        if (target.readyState == &quot;loaded&quot; || target.readyState == &quot;complete&quot;){ </div><div class="t m0 x0 hb y29e5 ff96 fs6 fc0 sc0 ls21 wsb">            EventUtil.removeHandler(target, &quot;readystatechange&quot;, arguments. callee); </div><div class="t m0 x0 hb y29e6 ff96 fs6 fc0 sc0 ls21 wsb">            alert(&quot;Script Loaded&quot;); </div><div class="t m0 x0 hb y29e7 ff96 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y29e8 ff96 fs6 fc0 sc0 ls21 wsb">    }); </div><div class="t m0 x0 hb y29e9 ff96 fs6 fc0 sc0 ls21 wsb">    script.src = &quot;example.js&quot;; </div><div class="t m0 x0 hb y29ea ff96 fs6 fc0 sc0 ls21 wsb">    document.body.appendChild(script); </div><div class="t m0 x0 hb y29eb ff96 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 hb y29ec ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf y14f0 ff97 fs2 fc0 sc0 ls2b wsb">ReadyStateChangeEventExample01.htm </div><div class="t m0 x0 h4 y29ed ff92 fs2 fc0 sc0 ls6 wsf7">这个例子为新创建的&lt;script&gt;节点指定了一个事件处理程序。事件的目标是该节点本身，因此当</div><div class="t m0 x0 h1e y29ee ff92 fs2 fc0 sc0 ls2d9 ws2a4">触发readystatechange事件时，要检测目标的 readyState属性是不是等于&quot;loaded&quot;或</div><div class="t m0 x0 h4 y1461 ff96 fs1 fc0 sc0 ls9 ws2">&quot;complete&quot;。如果进入了其中任何一个阶段，则移除事件处理程序（以防止被执行两次），并显示一个</div><div class="t m0 x0 h5 y29ef ff92 fs2 fc0 sc0 ls8 wseb">警告框。与此同时，就可以执行已经加载完毕的外部文件中的函数了。 </div><div class="t m0 x0 hc y29f0 ff92 fs2 fc0 sc0 ls8 wseb">同样的编码方式也适用于通过&lt;link&gt;元素加载CSS文件的情况，如下面的例子所示。 </div><div class="t m0 x0 h5 y29f1 ff8b fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y15cd ff96 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(window, &quot;load&quot;, function(){  </div><div class="t m0 x0 hb y29f2 ff96 fs6 fc0 sc0 ls21 wsb">    var link = document.createElement(&quot;link&quot;); </div><div class="t m0 x0 hb y29f3 ff96 fs6 fc0 sc0 ls21 wsb">    link.type = &quot;text/css&quot;; </div><div class="t m0 x0 hb y29f4 ff96 fs6 fc0 sc0 ls21 wsb">    link.rel= &quot;stylesheet&quot;; </div><div class="t m0 x0 h15 y29f5 ff99 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y29f6 ff96 fs6 fc0 sc0 ls21 wsb">    EventUtil.addHandler(script, &quot;readystatechange&quot;, function(event){ </div><div class="t m0 x0 hb y29f7 ff96 fs6 fc0 sc0 ls21 wsb">        event = EventUtil.getEvent(event); </div><div class="t m0 x0 hb y26bd ff96 fs6 fc0 sc0 ls21 wsb">        var target = EventUtil.getTarget(event); </div><div class="t m0 x0 h15 y29f8 ff99 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y29f9 ff96 fs6 fc0 sc0 ls21 wsb">        if (target.readyState == &quot;loaded&quot; || target.readyState == &quot;complete&quot;){ </div><div class="t m0 x0 hb y29fa ff96 fs6 fc0 sc0 ls21 wsb">            EventUtil.removeHandler(target, &quot;readystatechange&quot;, arguments. callee); </div><div class="t m0 x0 hb y29fb ff96 fs6 fc0 sc0 ls21 wsb">            alert(&quot;CSS Loaded&quot;); </div><div class="t m0 x0 hb y29fc ff96 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y29fd ff96 fs6 fc0 sc0 ls21 wsb">    }); </div><div class="t m0 x0 hb y29fe ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y29ff ff96 fs6 fc0 sc0 ls21 wsb">    link.href = &quot;example.css&quot;; </div><div class="t m0 x0 hb y2a00 ff96 fs6 fc0 sc0 ls21 wsb">    document.getElementsByTagName(&quot;head&quot;)[0].appendChild(link); </div><div class="t m0 x0 hb y2a01 ff96 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 h28 y2a02 ff96 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf y2a03 ff97 fs2 fc0 sc0 ls2b ws5d">ReadyStateChangeEventExample02.htm  </div></div></div>
<div id="pf19b" class="pf w0 h0" data-page-no="19b"><div class="pc pc19b w0 h0"><div class="t m0 x2 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">13.4 事件类型    393 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff8d fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff8d fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff8d fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff8d fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff8d fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff8d fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff8d fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff8d fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff8d fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff8d fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff8d fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff8d fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff8d fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff92 fs2 fc0 sc0 ls1f ws108">同样，最重要的是要一并检测readyState的两个状态，并在调用了一次事件处理程序后就将其移除。 </div><div class="t m0 x0 h47 y2a04 ff90 fs2 fc0 sc0 ls2e wsb">5. pageshow和pagehide事件 </div><div class="t m0 x0 h5 y2a05 ff8b fs2 fc0 sc0 ls47 ws38">Firefox和Opera有一个特性，名叫“往返缓存”（back-forward cache，或bfcache），可以在用户使</div><div class="t m0 x0 h4 y2a06 ff92 fs2 fc0 sc0 ls8 wseb">用浏览器的“后退”和“前进”按钮时加快页面的转换速度。这个缓存中不仅保存着页面数据，还保存</div><div class="t m0 x0 h5 y2a07 ff92 fs2 fc0 sc0 ls3b">了DOM和JavaScript的状态；实际上是将整个页面都保存在了内存里。如果页面位于bfcache中，那么</div><div class="t m0 x0 h80 y2a08 ff92 fs2 fc0 sc0 ls8 wseb">再次打开该页面时就不会触发load事件。尽管由于内存中保存了整个页面的状态，不触发load事件</div><div class="t m0 x0 h5 y2088 ff92 fs2 fc0 sc0 ls8 wseb">也不应该会导致什么问题，但为了更形象地说明bfcache的行为，Firefox还是提供了一些新事件。 </div><div class="t m0 x0 he y2a09 ff92 fs2 fc0 sc0 ls8 wseb">第一个事件就是pageshow，这个事件在页面显示时触发，无论该页面是否来自bfcache。在重新加</div><div class="t m0 x0 hc y2042 ff92 fs2 fc0 sc0 ls8 wseb">载的页面中，pageshow会在load事件触发后触发；而对于bfcache中的页面，pageshow 会在页面状</div><div class="t m0 x0 h4 y2043 ff92 fs2 fc0 sc0 ls8 wseb">态完全恢复的那一刻触发。另外要注意的是，虽然这个事件的目标是document，但必须将其事件处理</div><div class="t m0 x0 hc ycbd ff92 fs2 fc0 sc0 ls8 wseb">程序添加到window。来看下面的例子。 </div><div class="t m0 x0 hb y2a0a ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2a0b ff96 fs6 fc0 sc0 ls21 wsb">(function(){ </div><div class="t m0 x0 hb y2a0c ff96 fs6 fc0 sc0 ls21 wsb">    var showCount = 0; </div><div class="t m0 x0 hb y2a0d ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2a0e ff96 fs6 fc0 sc0 ls21 wsb">    EventUtil.addHandler(window, &quot;load&quot;, function(){ </div><div class="t m0 x0 hb y2a0f ff96 fs6 fc0 sc0 ls21 wsb">        alert(&quot;Load fired&quot;); </div><div class="t m0 x0 hb y2a10 ff96 fs6 fc0 sc0 ls21 wsb">    });  </div><div class="t m0 x0 hb y2a11 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2a12 ff96 fs6 fc0 sc0 ls21 wsb">    EventUtil.addHandler(window, &quot;pageshow&quot;, function(){ </div><div class="t m0 x0 hb y2a13 ff96 fs6 fc0 sc0 ls21 wsb">        showCount++; </div><div class="t m0 x0 hb y2a14 ff96 fs6 fc0 sc0 ls21 wsb">        alert(&quot;Show has been fired &quot; + showCount + &quot; times.&quot;); </div><div class="t m0 x0 hb y1524 ff96 fs6 fc0 sc0 ls21 wsb">    }); </div><div class="t m0 x0 hb y2a15 ff96 fs6 fc0 sc0 ls21 wsb">})(); </div><div class="t m0 x0 hb y2a16 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y2a17 ff92 fs2 fc0 sc0 ls8 wseb">这个例子使用了私有作用域，以防止变量showCount进入全局作用域。当页面首次加载完成时，</div><div class="t m0 x0 h4 y2a18 ff96 fs1 fc0 sc0 ls9 ws2">showCount的值为0。此后，每当触发pageshow事件，showCount 的值就会递增并通过警告框显示</div><div class="t m0 x0 h4 y2a19 ff92 fs2 fc0 sc0 ls8 wseb">出来。如果你在离开包含以上代码的页面之后，又单击“后退”按钮返回该页面，就会看到showCount</div><div class="t m0 x0 h4 y2a1a ff92 fs2 fc0 sc0 ls8 wseb">每次递增的值。这是因为该变量的状态，乃至整个页面的状态，都被保存在了内存中，当你返回这个页</div><div class="t m0 x0 h1e y2a1b ff92 fs2 fc0 sc0 ls8 wseb">面时，它们的状态得到了恢复。如果你单击了浏览器的“刷新”按钮，那么showCount的值就会被重</div><div class="t m0 x0 h5 y2a1c ff92 fs2 fc0 sc0 ls8 wseb">置为0，因为页面已经完全重新加载了。 </div><div class="t m0 x0 h1e y2a1d ff92 fs2 fc0 sc0 ls8 wseb">除了通常的属性之外，pageshow事件的event对象还包含一个名为persisted 的布尔值属性。</div><div class="t m0 x0 h5 y2a1e ff92 fs2 fc0 sc0 ls8 wseb">如果页面被保存在了bfcache中，则这个属性的值为true；否则，这个属性的值为false。可以像下面</div><div class="t m0 x0 h5 y2a1f ff92 fs2 fc0 sc0 ls8 wseb">这样在事件处理程序中检测这个属性。 </div><div class="t m0 x0 hb y2a20 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2a21 ff96 fs6 fc0 sc0 ls21 wsb">(function(){ </div><div class="t m0 x0 hb y2a22 ff96 fs6 fc0 sc0 ls21 wsb">    var showCount = 0;  </div><div class="t m0 x0 hb y2a23 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2a24 ff96 fs6 fc0 sc0 ls21 wsb">    EventUtil.addHandler(window, &quot;load&quot;, function(){ </div><div class="t m0 x0 hb y2a25 ff96 fs6 fc0 sc0 ls21 wsb">        alert(&quot;Load fired&quot;); </div><div class="t m0 x0 hb y2a26 ff96 fs6 fc0 sc0 ls21 wsb">    }); </div><div class="t m0 x0 hb y2a27 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2a28 ff96 fs6 fc0 sc0 ls21 wsb">    EventUtil.addHandler(window, &quot;pageshow&quot;, function(){ </div><div class="t m0 x0 hb y2a29 ff96 fs6 fc0 sc0 ls21 wsb">        showCount++; </div><div class="t m0 x0 hb y2a2a ff96 fs6 fc0 sc0 ls21 wsb">        alert(&quot;Show has been fired &quot; + showCount + </div><div class="t m0 x0 hb y2a2b ff96 fs6 fc0 sc0 ls21 wsb">              &quot; times. Persisted? &quot; + event.persisted); </div><div class="t m0 x0 hb y2a2c ff96 fs6 fc0 sc0 ls21 wsb">    }); </div><div class="t m0 x0 hb y2a2d ff96 fs6 fc0 sc0 ls21 wsb">})(); </div><div class="t m0 x0 hb y2a2e ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y2a2f ff97 fs2 fc0 sc0 ls2b wsb">PageShowEventExample01.htm </div></div></div>
<div id="pf19c" class="pf w0 h0" data-page-no="19c"><div class="pc pc19c w0 h0"><div class="t m0 x0 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">394  第13章 事件 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff92 fs2 fc0 sc0 ls8 wseb">通过检测persisted属性，就可以根据页面在bfcache中的状态来确定是否需要采取其他操作。 </div><div class="t m0 x0 h1e y4d ff92 fs2 fc0 sc0 ls373">与pageshow事件对应的是pagehide事件，该事件会在浏览器 卸载页面的时候触发，而且是在</div><div class="t m0 x0 h4 y4e ff96 fs1 fc0 sc0 ls9 ws2">unload事件之前触发。与pageshow事件一样，pagehide在document 上面触发，但其事件处理程</div><div class="t m0 x0 h4 yd9 ff92 fs2 fc0 sc0 ls8 wseb">序必须要添加到window对象。这个事件的event对象也包含persisted属性，不过其用途稍有不同。</div><div class="t m0 x0 h5 y15d ff92 fs2 fc0 sc0 ls8 wseb">来看下面的例子。 </div><div class="t m0 x0 h5 y2a31 ff8b fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2177 ff96 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(window, &quot;pagehide&quot;, function(event){ </div><div class="t m0 x0 hb y2a32 ff96 fs6 fc0 sc0 ls21 wsb">    alert(&quot;Hiding. Persisted? &quot; + event.persisted); </div><div class="t m0 x0 hb y2a33 ff96 fs6 fc0 sc0 ls21 wsb">});  </div><div class="t m0 x0 hb y2a34 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1b7b ff97 fs2 fc0 sc0 ls2b wsb">PageShowEventExample01.htm </div><div class="t m0 x0 h4 y2a35 ff92 fs2 fc0 sc0 ls8 wseb">有时候，可能需要在pagehide事件触发时根据persisted的值采取不同的操作。对于pageshow</div><div class="t m0 x0 h5 y2a36 ff92 fs2 fc0 sc0 ls8 wseb">事件，如果页面是从bfcache中加载的，那么persisted的值就是true；对于 pagehide事件，如果</div><div class="t m0 x0 h5 y2a37 ff92 fs2 fc0 sc0 ls8 wseb">页面在卸载之后会被保存在bfcache中，那么persisted的值也会被设置为 true。因此，当第一次触</div><div class="t m0 x0 h1e y2a38 ff92 fs2 fc0 sc0 ls374">发pageshow时，persisted的值一定是false，而在第一次触发pagehide时，persisted 就会变</div><div class="t m0 x0 h5 yb52 ff92 fs2 fc0 sc0 ls2d8">成true（除非页面不会被保存在bfcache中）。 </div><div class="t m0 x0 hc y66e ff92 fs2 fc0 sc0 ls8 wseb">支持pageshow和pagehide事件的浏览器有Firefox、Safari 5+、Chrome和Opera。IE9 及之前版</div><div class="t m0 x0 h5 y2a39 ff92 fs2 fc0 sc0 ls8 wseb">本不支持这两个事件。 </div><div class="t m0 x5 h17 y2a3a ff8c fs2 fc0 sc0 ls8 ws14">指定了onunload事件处理程序的页面会被自动排除在 bfcache之外，即使事件</div><div class="t m0 x0 ha y2a3b ff8c fs2 fc0 sc0 ls8 ws14">处理程序是空的。原因在于，onunload最常用于撤销在onload中所执行的操作，</div><div class="t m0 x0 h18 y2a3c ff8c fs2 fc0 sc0 ls8 ws14">而跳过onload后再次显示页面很可能就会导致页面不正常。 </div><div class="t m0 x0 h50 y2a3d ff90 fs2 fc0 sc0 ls2e wsb">6. hashchange事件 </div><div class="t m0 x0 h5 y2a3e ff8b fs2 fc0 sc0 ls2f ws8a">HTML5新增了hashchange事件，以便在URL的参数列表（及URL中“ #”号后面的所有字符串）</div><div class="t m0 x0 h5 y26ff ff92 fs2 fc0 sc0 ls8 wseb">发生变化时通知开发人员。之所以新增这个事件，是因为在Ajax应用中，开发人员经常要利用URL参</div><div class="t m0 x0 h5 y2a3f ff92 fs2 fc0 sc0 ls8 wseb">数列表来保存状态或导航信息。 </div><div class="t m0 x0 he y2a40 ff92 fs2 fc0 sc0 ls8 wseb">必须要把hashchange事件处理程序添加给window对象，然后 URL参数列表只要变化就会调用</div><div class="t m0 x0 h1e y2a41 ff92 fs2 fc0 sc0 ls8 wseb">它。此时的event对象应该额外包含两个属性：oldURL和newURL。这两个属性分别保存着参数列表</div><div class="t m0 x0 h5 y1a38 ff92 fs2 fc0 sc0 ls8 wseb">变化前后的完整URL。例如： </div><div class="t m0 x0 hb y2a42 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2a43 ff96 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(window, &quot;hashchange&quot;, function(event){ </div><div class="t m0 x0 hb y2a44 ff96 fs6 fc0 sc0 ls21 wsb">    alert(&quot;Old URL: &quot; + event.oldURL + &quot;\nNew URL: &quot; + event.newURL); </div><div class="t m0 x0 hb y2a45 ff96 fs6 fc0 sc0 ls21 wsb">});  </div><div class="t m0 x0 hb y2a46 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y2a47 ff97 fs2 fc0 sc0 ls5e wsb">HashChangeEventExample01.htm </div><div class="t m0 x0 h5 y2a48 ff92 fs2 fc0 sc0 ls8 wseb">支持hashchange事件的浏览器有IE8+、Firefox 3.6+、Safari 5+、Chrome和Opera 10.6+。在这些</div><div class="t m0 x0 h5 y2a49 ff92 fs2 fc0 sc0 ls8 wseb">浏览器中，只有Firefox 6+、Chrome和Opera支持oldURL和newURL属性。为此，最好是使用location</div><div class="t m0 x0 h5 ya30 ff92 fs2 fc0 sc0 ls8 wseb">对象来确定当前的参数列表。 </div><div class="t m0 x0 hb y1a67 ff96 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(window, &quot;hashchange&quot;, function(event){ </div><div class="t m0 x0 hb y2a4a ff96 fs6 fc0 sc0 ls21 wsb">    alert(&quot;Current hash: &quot; + location.hash); </div><div class="t m0 x0 hb y2a4b ff96 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 hb y2a4c ff96 fs6 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf19d" class="pf w0 h0" data-page-no="19d"><div class="pc pc19d w0 h0"><div class="t m0 x2 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">13.4 事件类型    395 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff8d fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff8d fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff8d fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff8d fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff8d fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff8d fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff8d fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff8d fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff8d fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff8d fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff8d fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff8d fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff8d fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff92 fs2 fc0 sc0 ls8 wseb">使用以下代码可以检测浏览器是否支持hashchange事件： </div><div class="t m0 x0 hb y2a4d ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2a4e ff96 fs6 fc0 sc0 ls21 wsb">var isSupported = (&quot;onhashchange&quot; in window); //这里有bug </div><div class="t m0 x0 hb y2a4f ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y4c9 ff92 fs2 fc0 sc0 ls8 wseb">如果IE8是在IE7文档模式下运行，即使功能无效它也会返回 true。为解决这个问题，可以使用</div><div class="t m0 x0 h5 y2a50 ff92 fs2 fc0 sc0 ls8 wseb">以下这个更稳妥的检测方式： </div><div class="t m0 x0 hb y22a9 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2a51 ff96 fs6 fc0 sc0 ls21 wsb">var isSupported = (&quot;onhashchange&quot; in window) &amp;&amp; (document.documentMode === </div><div class="t m0 x0 hb y2a52 ff96 fs6 fc0 sc0 ls21 wsb">                   undefined || document.documentMode &gt; 7);  </div><div class="t m0 x0 h20 y2a53 ff90 fs3 fc0 sc0 ls248 ws214">13.4.8 设备事件 </div><div class="t m0 x0 h4 y2a54 ff92 fs2 fc0 sc0 ls8 wseb">智能手机和平板电脑的普及，为用户与浏览器交互引入了一种新的方式，而一类新事件也应运而生。</div><div class="t m0 x0 h5 y2a55 ff92 fs2 fc0 sc0 ls8 wseb">设备事件（device event）可以让开发人员确定用户在怎样使用设备。W3C从2011年开始着手制定一份</div><div class="t m0 x0 h5 y2a56 ff92 fs2 fc0 sc0 ls30 wsf6">关于设备事件的新草案（http://dev.w3.org/geo/api/spec-source-orientation.html），以涵盖不断增长的设备</div><div class="t m0 x0 h5 y2a57 ff92 fs2 fc0 sc0 ls8 wseb">类型并为它们定义相关的事件。本节会同时讨论这份草案中涉及的API和特定于浏览器开发商的事件。 </div><div class="t m0 x0 hb7 y2a58 ff90 fs2 fc0 sc0 ls2e wsb">1. orientationchange事件 </div><div class="t m0 x0 h5 y2a59 ff92 fs2 fc0 sc0 ls8 wseb">苹果公司为移动Safari中添加了orientationchange事件，以便开发人员能够确定用户何时将设</div><div class="t m0 x0 h5 y2a5a ff92 fs2 fc0 sc0 ls8 wseb">备由横向查看模式切换为纵向查看模式。移动Safari的window.orientation属性中可能包含3个值：</div><div class="t m0 x0 h4 y2a5b ff96 fs1 fc0 sc0 ls376">0表示肖像模式，90表示向左旋转的横向模式（“主屏幕”按钮在右侧），-90表示向右旋转的横向模</div><div class="t m0 x0 hc y2a5c ff92 fs2 fc0 sc0 ls8 wseb">式（“主屏幕”按钮在左侧）。相关文档中还提到一个值，即180表示iPhone头朝下；但这种模式至今</div><div class="t m0 x0 hc y2a5d ff92 fs2 fc0 sc0 ls8 wseb">尚未得到支持。图13-10展示了window.orientation的每个值的含义。 </div><div class="t m0 x2 h5 y2a5e ff8b fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 h3 y2a5f ff92 fs1 fc0 sc0 ls8 wsb">图 13-10 </div><div class="t m0 x0 h4 y96a ff92 fs2 fc0 sc0 ls8 wseb">只要用户改变了设备的查看模式，就会触发orientationchange事件。此时的event对象不包</div><div class="t m0 x0 h4 y2a60 ff92 fs2 fc0 sc0 ls8 wseb">含任何有价值的信息，因为唯一相关的信息可以通过window.orientation访问到。下面是使用这个</div><div class="t m0 x0 h5 y2a61 ff92 fs2 fc0 sc0 ls8 wseb">事件的典型示例。 </div><div class="t m0 x5 hb y10f5 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2a62 ff96 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(window, &quot;load&quot;, function(event){ </div><div class="t m0 x0 hb y2a63 ff96 fs6 fc0 sc0 ls21 wsb">    var div = document.getElementById(&quot;myDiv&quot;); </div><div class="t m0 x0 hb y2a64 ff96 fs6 fc0 sc0 ls21 wsb">    div.innerHTML = &quot;Current orientation is &quot; + window.orientation; </div></div></div>
<div id="pf19e" class="pf w0 h0" data-page-no="19e"><div class="pc pc19e w0 h0"><div class="t m0 x0 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">396  第13章 事件 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 ff96 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 hb y7a ff96 fs6 fc0 sc0 ls21 wsb">    EventUtil.addHandler(window, &quot;orientationchange&quot;, function(event){ </div><div class="t m0 x0 hb y7b ff96 fs6 fc0 sc0 ls21 wsb">        div.innerHTML = &quot;Current orientation is &quot; + window.orientation; </div><div class="t m0 x0 hb y7c ff96 fs6 fc0 sc0 ls21 wsb">    }); </div><div class="t m0 x0 hb y7d ff96 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 hb y7e ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf y9c0 ff97 fs2 fc0 sc0 ls1b wsb">OrientationChangeEventExample01.htm </div><div class="t m0 x0 h4 y9c1 ff92 fs2 fc0 sc0 ls1f ws108">在这个例子中，当触发load事件时会显示最初的方向信息。然后，添加了处理orientationchange</div><div class="t m0 x0 h5 y2a66 ff92 fs2 fc0 sc0 ls8 wseb">事件的处理程序。只要发生这个事件，就会有表示新方向的信息更新页面中的消息。 </div><div class="t m0 x0 hc y9c3 ff92 fs2 fc0 sc0 ls8 wseb">所有iOS设备都支持orientationchange事件和window.orientation 属性。 </div><div class="t m0 x5 h40 y2a67 ff8c fs2 fc0 sc0 lsa ws2f8">由于可以将orientationchange看成 window事件，所以也可以通过指定</div><div class="t m0 x0 h5 y2a68 ff96 fs1 fc0 sc0 ls9 ws2">&lt;body&gt;元素的onorientationchange特性来指定事件处理程序。 </div><div class="t m0 x0 h50 y2a69 ff90 fs2 fc0 sc0 ls2e wsb">2. MozOrientation事件 </div><div class="t m0 x0 h5 y2a6a ff8b fs2 fc0 sc0 ls47 wsaa">Firefox 3.6为检测设备的方向引入了一个名为MozOrientation的新事件。（前缀Moz表示这是特</div><div class="t m0 x0 h4 y2a6b ff92 fs2 fc0 sc0 ls6 wsf7">定于浏览器开发商的事件，不是标准事件。）当设备的加速计检测到设备方向改变时，就会触发这个事</div><div class="t m0 x0 h5 y2a6c ff92 fs2 fc0 sc0 ls8 wseb">件。但这个事件与iOS中的orientationchange事件不同，该事件只能提供一个平面的方向变化。由</div><div class="t m0 x0 hc y2a6d ff92 fs2 fc0 sc0 ls328">于MozOrientation事件是在window对象上触发的，所以可以使用以下代码来处理。 </div><div class="t m0 x0 hb y2a6e ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2a6f ff96 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(window, &quot;MozOrientation&quot;, function(event){ </div><div class="t m0 x0 h16 y2a70 ff96 fs6 fc0 sc0 ls21 wsb">    //响应事件 </div><div class="t m0 x0 hb y2a71 ff96 fs6 fc0 sc0 ls21 wsb">});  </div><div class="t m0 x0 hb y2a72 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y2a73 ff92 fs2 fc0 sc0 ls8 wseb">此时的event对象包含三个属性：x、y和z。这几个属性的值都介于1到-1之间，表示不同坐标</div><div class="t m0 x0 hc y2a74 ff92 fs2 fc0 sc0 ls8 wseb">轴上的方向。在静止状态下，x值为0，y值为0，z值为1（表示设备处于竖直状态）。如果设备向右倾</div><div class="t m0 x0 h4 y341 ff92 fs2 fc0 sc0 ls8 wseb">斜，x值会减小；反之，向左倾斜，x值会增大。类似地，如果设备向远离用户的方向倾斜，y值会减</div><div class="t m0 x0 hc y2a75 ff92 fs2 fc0 sc0 ls8 wseb">小，向接近用户的方向倾斜，y值会增大。z轴检测垂直加速度度，1表示静止不动，在设备移动时值</div><div class="t m0 x0 h5 y2a76 ff92 fs2 fc0 sc0 ls8 wseb">会减小。（失重状态下值为0。）以下是输出这三个值的一个简单的例子。 </div><div class="t m0 x0 hb y96 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2a77 ff96 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(window, &quot;MozOrientation&quot;, function(event){ </div><div class="t m0 x0 hb y2a78 ff96 fs6 fc0 sc0 ls21 wsb">    var output = document.getElementById(&quot;output&quot;); </div><div class="t m0 x0 hb y2a79 ff96 fs6 fc0 sc0 ls21 wsb">    output.innerHTML = &quot;X=&quot; + event.x + &quot;, Y=&quot; + event.y + &quot;, Z=&quot; + event.z +&quot;&lt;br&gt;&quot;; </div><div class="t m0 x0 hb y2a7a ff96 fs6 fc0 sc0 ls21 wsb">});  </div><div class="t m0 x0 hb y2a7b ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf y1613 ff97 fs2 fc0 sc0 ls1b wsb">MozOrientationEventExample01.htm </div><div class="t m0 x0 h5 y1180 ff92 fs2 fc0 sc0 ls8 wseb">只有带加速计的设备才支持MozOrientation事件，包括Macbook、Lenovo Thinkpad、Windows </div><div class="t m0 x0 h5 y2a7c ff8b fs2 fc0 sc0 lsb ws5">Mobile和Android设备。请大家注意，这是一个实验性API，将来可能会变（可能会被其他事件取代）。 </div><div class="t m0 x0 h47 y2a7d ff90 fs2 fc0 sc0 ls2e wsb">3. deviceorientation事件 </div><div class="t m0 x0 h5 y2a7e ff92 fs2 fc0 sc0 ls8 wseb">本质上，DeviceOrientation Event规范定义的deviceorientation事件与MozOrientation事件类</div><div class="t m0 x0 h1e y941 ff92 fs2 fc0 sc0 ls8 wseb">似。它也是在加速计检测到设备方向变化时在window对象上触发，而且具有与MozOrientation事件</div><div class="t m0 x0 h1e y2a7f ff92 fs2 fc0 sc0 ls8 wseb">相同的支持限制。不过，deviceorientation事件的意图是告诉开发人员设备在空间中朝向哪儿，而</div><div class="t m0 x0 h5 y2a80 ff92 fs2 fc0 sc0 ls8 wseb">不是如何移动。 </div></div></div>
<div id="pf19f" class="pf w0 h0" data-page-no="19f"><div class="pc pc19f w0 h0"><div class="t m0 x2 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">13.4 事件类型    397 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff8d fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff8d fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff8d fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff8d fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff8d fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff8d fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff8d fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff8d fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff8d fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff8d fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff8d fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff8d fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff8d fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff92 fs2 fc0 sc0 ls8 wseb">设备在三维空间中是靠x、y和z轴来定位的。当设备静止放在水平表面上时，这三个值都是0。x</div><div class="t m0 x0 h5 y4d ff92 fs2 fc0 sc0 ls8 wseb">轴方向是从左往右，y轴方向是从下往上，z轴方向是从后往前（参见图13-11）。 </div><div class="t m0 x2 h5 y2a81 ff8b fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 h3 y2a82 ff92 fs1 fc0 sc0 ls8 wsb">图 13-11 </div><div class="t m0 x0 h4 y2a83 ff92 fs2 fc0 sc0 ls8 wseb">触发deviceorientation事件时，事件对象中包含着每个轴相对于设备静止状态下发生变化的信</div><div class="t m0 x0 h5 yd26 ff92 fs2 fc0 sc0 ls8 wseb">息。事件对象包含以下5个属性。 </div><div class="t m0 x0 h5 y2a84 ff91 fs1 fc0 sc0 ls2"> alpha：在围绕z轴旋转时（即左右旋转时），y轴的度数差；是一个介于0到360之间的浮点数。 </div><div class="t m0 x0 h25 y16b ff91 fs1 fc0 sc0 ls8 ws134"> beta：在围绕x轴旋转时（即前后旋转时），z轴的度数差；是一个介于180到180之间的浮点数。 </div><div class="t m0 x0 h25 y2a85 ff91 fs1 fc0 sc0 ls8 ws134"> gamma：在围绕y轴旋转时（即扭转设备时），z轴的度数差；是一个介于90到90之间的浮点数。 </div><div class="t m0 x0 h5 y2a86 ff91 fs1 fc0 sc0 ls2"> absolute：布尔值，表示设备是否返回一个绝对值。 </div><div class="t m0 x0 h5 y2a87 ff91 fs1 fc0 sc0 ls2"> compassCalibrated：布尔值，表示设备的指南针是否校准过。 </div><div class="t m0 x0 hc y2a88 ff92 fs2 fc0 sc0 ls3b">图13-12是alpha、beta和gamma值含义的示意图。 </div><div class="t m0 x0 h5 yfcf ff92 fs2 fc0 sc0 ls8 wseb">下面是一个输出alpha、beta和gamma值的例子。 </div><div class="t m0 x0 hb y2a89 ff96 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(window, &quot;deviceorientation&quot;, function(event){ </div><div class="t m0 x0 hb y2a8a ff96 fs6 fc0 sc0 ls21 wsb">    var output = document.getElementById(&quot;output&quot;); </div><div class="t m0 x0 hb y2a8b ff96 fs6 fc0 sc0 ls21 wsb">    output.innerHTML = &quot;Alpha=&quot; + event.alpha + &quot;, Beta=&quot; + event.beta + </div><div class="t m0 x0 hb y2a8c ff96 fs6 fc0 sc0 ls21 wsb">                       &quot;, Gamma=&quot; + event.gamma + &quot;&lt;br&gt;&quot;; </div><div class="t m0 x0 hb y2a8d ff96 fs6 fc0 sc0 ls21 wsb">});  </div><div class="t m0 x2 hf y2218 ff97 fs2 fc0 sc0 ls8 wsb">DeviceOrientationEventExample01.htm </div><div class="t m0 x0 h4 y2a8e ff92 fs2 fc0 sc0 ls8 wseb">通过这些信息，可以响应设备的方向，重新排列或修改屏幕上的元素。要响应设备方向的改变而旋</div><div class="t m0 x0 h5 y2a8f ff92 fs2 fc0 sc0 ls8 wseb">转元素，可以参考如下代码。 </div><div class="t m0 x0 h5 y2a90 ff8b fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2a91 ff96 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(window, &quot;deviceorientation&quot;, function(event){ </div><div class="t m0 x0 hb y2a92 ff96 fs6 fc0 sc0 ls21 wsb">    var arrow = document.getElementById(&quot;arrow&quot;); </div><div class="t m0 x0 hb y2a93 ff96 fs6 fc0 sc0 ls21 wsb">    arrow.style.webkitTransform = &quot;rotate(&quot; + Math.round(event.alpha) + &quot;deg)&quot;; </div><div class="t m0 x0 hb y2a94 ff96 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 hb y2a95 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y10f6 ff97 fs2 fc0 sc0 ls8 wsb">DeviceOrientationEventExample01.htm </div><div class="c x2 y2a96 w1a he8"><div class="t m0 x0 he9 y2a97 ff97 fs6 fc0 sc0 ls8">x</div></div><div class="t m0 x2 he9 y1318 ff97 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x7 he9 y2a98 ff97 fs6 fc0 sc0 ls8">z</div><div class="t m0 x4 he9 y2a99 ff97 fs6 fc0 sc0 ls225 wsb">y </div></div></div>
<div id="pf1a0" class="pf w0 h0" data-page-no="1a0"><div class="pc pc1a0 w0 h0"><div class="t m0 x0 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">398  第13章 事件 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 h5 y1c3f ff8b fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x7 h3 y1809 ff92 fs1 fc0 sc0 ls8 wsb">图 13-12 </div><div class="t m0 x0 h5 y2a9b ff92 fs2 fc0 sc0 ls8 wseb">这个例子只能在移动WebKit浏览器中运行，因为它使用了专有的webkitTransform属性（即CSS</div><div class="t m0 x0 hc y2a9c ff92 fs2 fc0 sc0 ls8 wseb">标准属性transform的临时版）。元素“arrow”会随着event.alpha值的变化而旋转，给人一种指南</div><div class="t m0 x0 h5 y2a9d ff92 fs2 fc0 sc0 ls8 wseb">针的感觉。为了保证旋转平滑，这里的CSS3变换使用了舍入之后的值。 </div><div class="t m0 x0 he y2a9e ff92 fs2 fc0 sc0 ls3b">到2011年，支持deviceorientation事件的浏览器有iOS 4.2+中的Safari、Chrome和Android 版</div><div class="t m0 x0 h5 y2a9f ff8b fs2 fc0 sc0 lsfd wscc">WebKit。 </div><div class="t m0 x0 h47 y2aa0 ff90 fs2 fc0 sc0 ls2e wsb">4. devicemotion事件 </div><div class="t m0 x0 h5 y2aa1 ff8b fs2 fc0 sc0 ls25 ws61">DeviceOrientation Event规范还定义了一个devicemotion事件。这个事件是要告诉开发人员设备</div><div class="t m0 x0 h1e y2aa2 ff92 fs2 fc0 sc0 ls8 wseb">什么时候移动，而不仅仅是设备方向如何改变。例如，通过devicemotion能够检测到设备是不是正在</div><div class="t m0 x0 h5 y2aa3 ff92 fs2 fc0 sc0 ls8 wseb">往下掉，或者是不是被走着的人拿在手里。 </div><div class="t m0 x0 he y2aa4 ff92 fs2 fc0 sc0 ls8 wseb">触发devicemotion事件时，事件对象包含以下属性。 </div><div class="t m0 x0 h4 y2aa5 ff91 fs1 fc0 sc0 ls2"> acceleration：一个包含x、y和z属性的对象，在不考虑重力的情况下，告诉你在每个方向</div><div class="t m0 x0 h5 y2aa6 ff92 fs2 fc0 sc0 ls8 wseb">上的加速度。 </div><div class="t m0 x0 h4 y2aa7 ff91 fs1 fc0 sc0 ls2"> accelerationIncludingGravity：一个包含x、y和z属性的对象，在考虑z轴自然重力加</div><div class="t m0 x0 h5 y2aa8 ff92 fs2 fc0 sc0 ls8 wseb">速度的情况下，告诉你在每个方向上的加速度。 </div><div class="t m0 x0 h4 y2aa9 ff91 fs1 fc0 sc0 ls2"> interval：以毫秒表示的时间值，必须在另一个devicemotion事件触发前传入。这个值在每</div><div class="t m0 x0 h5 y2aaa ff92 fs2 fc0 sc0 ls8 wseb">个事件中应该是一个常量。 </div></div></div>
<div id="pf1a1" class="pf w0 h0" data-page-no="1a1"><div class="pc pc1a1 w0 h0"><div class="t m0 x2 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">13.4 事件类型    399 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff8d fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff8d fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff8d fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff8d fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff8d fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff8d fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff8d fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff8d fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff8d fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff8d fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff8d fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff8d fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff8d fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff91 fs1 fc0 sc0 ls2"> rotationRate：一个包含表示方向的alpha、beta和gamma属性的对象。 </div><div class="t m0 x0 h1e y4d ff92 fs2 fc0 sc0 ls8 wseb">如果读取不到acceleration、accelerationIncludingGravity和rotationRate值，则它们</div><div class="t m0 x0 hc y5 ff92 fs2 fc0 sc0 ls8 wseb">的值为null。因此，在使用这三个属性之前，应该先检测确定它们的值不是null。例如： </div><div class="t m0 x0 hb y2aab ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2aac ff96 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(window, &quot;devicemotion&quot;, function(event){ </div><div class="t m0 x0 hb y2aad ff96 fs6 fc0 sc0 ls21 wsb">    var output = document.getElementById(&quot;output&quot;); </div><div class="t m0 x0 hb y2aae ff96 fs6 fc0 sc0 ls21 wsb">    if (event.rotationRate !== null){ </div><div class="t m0 x0 hb y2aaf ff96 fs6 fc0 sc0 ls21 wsb">        output.innerHTML += &quot;Alpha=&quot; + event.rotationRate.alpha + &quot;, Beta=&quot; + </div><div class="t m0 x0 hb y2ab0 ff96 fs6 fc0 sc0 ls21 wsb">                             event.rotationRate.beta + &quot;, Gamma=&quot; + </div><div class="t m0 x0 hb y2ab1 ff96 fs6 fc0 sc0 ls21 wsb">                             event.rotationRate.gamma; </div><div class="t m0 x0 hb y2ab2 ff96 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y2ab3 ff96 fs6 fc0 sc0 ls21 wsb">});  </div><div class="t m0 x0 hb y2ab4 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y14e8 ff97 fs2 fc0 sc0 ls5e wsb">DeviceMotionEventExample01.htm </div><div class="t m0 x0 h5 y295 ff92 fs2 fc0 sc0 ls2c">与deviceorientation事件类似，只有iOS 4.2+中的Safari、Chrome和Android版WebKit 实现了</div><div class="t m0 x0 h5 y151e ff96 fs1 fc0 sc0 ls20 ws16">devicemotion事件。 </div><div class="t m0 x0 h20 y2ab5 ff90 fs3 fc0 sc0 ls248 ws214">13.4.9 触摸与手势事件 </div><div class="t m0 x0 h5 y2ab6 ff8b fs2 fc0 sc0 ls8 ws20">iOS版Safari为了向开发人员传达一些特殊信息，新增了一些专有事件。因为iOS设备既没有鼠标</div><div class="t m0 x0 h5 y2ab7 ff92 fs2 fc0 sc0 ls8 wseb">也没有键盘，所以在为移动Safari开发交互性网页时，常规的鼠标和键盘事件根本不够用。随着Android</div><div class="t m0 x0 h5 y2ab8 ff92 fs2 fc0 sc0 ls8 wseb">中的WebKit的加入，很多这样的专有事件变成了事实标准，导致W3C开始制定 Touch Events规范（参</div><div class="t m0 x0 h5 y2ab9 ff92 fs2 fc0 sc0 ls3b">见https://dvcs.w3.org/hg/webevents/raw-file/tip/touchevents.html）。以下介绍的事件只针对触摸设备。 </div><div class="t m0 x0 h3c y2aba ff90 fs2 fc0 sc0 ls2e wsb">1. 触摸事件 </div><div class="t m0 x0 h5 y2abb ff92 fs2 fc0 sc0 ls8 wseb">包含iOS 2.0软件的iPhone 3G发布时，也包含了一个新版本的Safari 浏览器。这款新的移动Safari</div><div class="t m0 x0 h5 y2abc ff92 fs2 fc0 sc0 ls8 wseb">提供了一些与触摸（touch）操作相关的新事件。后来，Android上的浏览器也实现了相同的事件。触摸</div><div class="t m0 x0 h4 y2abd ff92 fs2 fc0 sc0 ls8 wseb">事件会在用户手指放在屏幕上面时、在屏幕上滑动时或从屏幕上移开时触发。具体来说，有以下几个触</div><div class="t m0 x0 h5 y2abe ff92 fs2 fc0 sc0 ls8">摸事件。 </div><div class="t m0 x0 h5 y2abf ff91 fs1 fc0 sc0 ls2"> touchstart：当手指触摸屏幕时触发；即使已经有一个手指放在了屏幕上也会触发。 </div><div class="t m0 x0 h4 y2ac0 ff91 fs1 fc0 sc0 ls2"> touchmove：当手指在屏幕上滑动时连续地触发。在这个事件发生期间，调用 preventDefault()</div><div class="t m0 x5 h5 y2ac1 ff92 fs2 fc0 sc0 ls8 wseb">可以阻止滚动。 </div><div class="t m0 x0 h5 y3c4 ff91 fs1 fc0 sc0 ls2"> touchend：当手指从屏幕上移开时触发。 </div><div class="t m0 x0 h5 y1f27 ff91 fs1 fc0 sc0 ls8 ws134"> touchcancel：当系统停止跟踪触摸时触发。关于此事件的确切触发时间，文档中没有明确说明。 </div><div class="t m0 x0 h5 y2ac2 ff92 fs2 fc0 sc0 ls8 wseb">上面这几个事件都会冒泡，也都可以取消。虽然这些触摸事件没有在DOM规范中定义，但它们却</div><div class="t m0 x0 h5 y2ac3 ff92 fs2 fc0 sc0 ls8 wseb">是以兼容DOM的方式实现的。因此，每个触摸事件的event对象都提供了在鼠标事件中常见的属性：</div><div class="t m0 x0 h4 y20a1 ff96 fs1 fc0 sc0 ls9 ws2">bubbles、cancelable、view、clientX、clientY、screenX、screenY、detail、altKey、shiftKey、</div><div class="t m0 x0 h5 y75c ff96 fs1 fc0 sc0 ls9 ws2">ctrlKey和metaKey。 </div><div class="t m0 x0 h5 y2ac4 ff92 fs2 fc0 sc0 ls8 wseb">除了常见的DOM属性外，触摸事件还包含下列三个用于跟踪触摸的属性。 </div><div class="t m0 x0 h5 y2ac5 ff91 fs1 fc0 sc0 ls2"> touches：表示当前跟踪的触摸操作的Touch对象的数组。 </div><div class="t m0 x0 h5 y2ac6 ff91 fs1 fc0 sc0 ls2"> targetTouchs：特定于事件目标的Touch对象的数组。 </div><div class="t m0 x0 h5 y2ac7 ff91 fs1 fc0 sc0 ls2"> changeTouches：表示自上次触摸以来发生了什么改变的Touch对象的数组。 </div><div class="t m0 x0 hc y2ac8 ff92 fs2 fc0 sc0 ls8 wseb">每个Touch对象包含下列属性。 </div></div></div>
<div id="pf1a2" class="pf w0 h0" data-page-no="1a2"><div class="pc pc1a2 w0 h0"><div class="t m0 x0 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">400  第13章 事件 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff91 fs1 fc0 sc0 ls2"> clientX：触摸目标在视口中的x坐标。 </div><div class="t m0 x0 h5 y4 ff91 fs1 fc0 sc0 ls2"> clientY：触摸目标在视口中的y坐标。 </div><div class="t m0 x0 h5 y4e ff91 fs1 fc0 sc0 ls2"> identifier：标识触摸的唯一ID。 </div><div class="t m0 x0 h5 yd9 ff91 fs1 fc0 sc0 ls2"> pageX：触摸目标在页面中的x坐标。 </div><div class="t m0 x0 h5 y219 ff91 fs1 fc0 sc0 ls2"> pageY：触摸目标在页面中的y坐标。 </div><div class="t m0 x0 h5 y8 ff91 fs1 fc0 sc0 ls2"> screenX：触摸目标在屏幕中的x坐标。 </div><div class="t m0 x0 h5 y9 ff91 fs1 fc0 sc0 ls2"> screenY：触摸目标在屏幕中的y坐标。 </div><div class="t m0 x0 h5 ya ff91 fs1 fc0 sc0 ls2"> target：触摸的DOM节点目标。 </div><div class="t m0 x0 h5 yb ff92 fs2 fc0 sc0 ls8 wseb">使用这些属性可以跟踪用户对屏幕的触摸操作。来看下面的例子。 </div><div class="t m0 x0 hb y160 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y161 ff96 fs6 fc0 sc0 ls21 wsb">function handleTouchEvent(event){ </div><div class="t m0 x0 hb y162 ff96 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 h16 y163 ff96 fs6 fc0 sc0 ls21 wsb">    //只跟踪一次触摸 </div><div class="t m0 x0 hb y2aca ff96 fs6 fc0 sc0 ls21 wsb">    if (event.touches.length == 1){ </div><div class="t m0 x0 hb y2acb ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2acc ff96 fs6 fc0 sc0 ls21 wsb">        var output = document.getElementById(&quot;output&quot;); </div><div class="t m0 x0 hb y2acd ff96 fs6 fc0 sc0 ls21 wsb">        switch(event.type){ </div><div class="t m0 x0 hb y2ace ff96 fs6 fc0 sc0 ls21 wsb">            case &quot;touchstart&quot;: </div><div class="t m0 x0 hb y2acf ff96 fs6 fc0 sc0 ls21 wsb">                output.innerHTML = &quot;Touch started (&quot; + event.touches[0].clientX +  </div><div class="t m0 x0 hb y2ad0 ff96 fs6 fc0 sc0 ls21 wsb">                                   &quot;,&quot; + event.touches[0].clientY + &quot;)&quot;; </div><div class="t m0 x0 hb y2ad1 ff96 fs6 fc0 sc0 ls21 wsb">                break; </div><div class="t m0 x0 hb y2ad2 ff96 fs6 fc0 sc0 ls21 wsb">            case &quot;touchend&quot;: </div><div class="t m0 x0 hb y2ad3 ff96 fs6 fc0 sc0 ls21 wsb">                output.innerHTML += &quot;&lt;br&gt;Touch ended (&quot; +  </div><div class="t m0 x0 hb y2ad4 ff96 fs6 fc0 sc0 ls21 wsb">                                    event.changedTouches[0].clientX + &quot;,&quot; + </div><div class="t m0 x0 hb y2ad5 ff96 fs6 fc0 sc0 ls21 wsb">                                    event.changedTouches[0].clientY + &quot;)&quot;; </div><div class="t m0 x0 hb y2ad6 ff96 fs6 fc0 sc0 ls21 wsb">                break; </div><div class="t m0 x0 hb y2ad7 ff96 fs6 fc0 sc0 ls21 wsb">            case &quot;touchmove&quot;: </div><div class="t m0 x0 h16 y2ad8 ff96 fs6 fc0 sc0 ls21 wsb">                event.preventDefault();  //阻止滚动 </div><div class="t m0 x0 hb y2ad9 ff96 fs6 fc0 sc0 ls21 wsb">                output.innerHTML += &quot;&lt;br&gt;Touch moved (&quot; + </div><div class="t m0 x0 hb y2ada ff96 fs6 fc0 sc0 ls21 wsb">                                    event.changedTouches[0].clientX + &quot;,&quot; +  </div><div class="t m0 x0 hb y2adb ff96 fs6 fc0 sc0 ls21 wsb">                                    event.changedTouches[0].clientY + &quot;)&quot;; </div><div class="t m0 x0 hb y2adc ff96 fs6 fc0 sc0 ls21 wsb">                break; </div><div class="t m0 x0 hb y2add ff96 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y2ade ff96 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y2adf ff96 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y2ae0 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2ae1 ff96 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(document, &quot;touchstart&quot;, handleTouchEvent); </div><div class="t m0 x0 hb y2ae2 ff96 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(document, &quot;touchend&quot;, handleTouchEvent); </div><div class="t m0 x0 hb y2ae3 ff96 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(document, &quot;touchmove&quot;, handleTouchEvent); </div><div class="t m0 x0 hb y2ae4 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y2ae5 ff97 fs2 fc0 sc0 ls1b wsb">TouchEventsExample01.htm </div><div class="t m0 x0 h4 y2ae6 ff92 fs2 fc0 sc0 ls8 wseb">以上代码会跟踪屏幕上发生的一次触摸操作。为简单起见，只会在有一次活动触摸操作的情况下输</div><div class="t m0 x0 h1e y2ae7 ff92 fs2 fc0 sc0 ls8 wseb">出信息。当touchstart事件发生时，会将触摸的位置信息输出到&lt;div&gt;元素中。当touchmove事件</div><div class="t m0 x0 h4 y2ae8 ff92 fs2 fc0 sc0 ls6 wsf7">发生时，会取消其默认行为，阻止滚动（触摸移动的默认行为是滚动页面），然后输出触摸操作的变化</div><div class="t m0 x0 h1c y2ae9 ff92 fs2 fc0 sc0 ls8 wseb">信息。而touchend事件则会输出有关触摸操作的最终信息。注意，在touchend事件发生时，touches</div><div class="t m0 x0 h4 y2aea ff92 fs2 fc0 sc0 ls8 wseb">集合中就没有任何Touch对象了，因为不存在活动的触摸操作；此时，就必须转而使用changeTouchs</div><div class="t m0 x0 h5 y2353 ff92 fs2 fc0 sc0 ls8">集合。 </div><div class="t m0 x0 h4 y2aeb ff92 fs2 fc0 sc0 ls8 wseb">这些事件会在文档的所有元素上面触发，因而可以分别操作页面的不同部分。在触摸屏幕上的元素</div><div class="t m0 x0 h5 y2aec ff92 fs2 fc0 sc0 ls8 wseb">时，这些事件（包括鼠标事件）发生的顺序如下： </div></div></div>
<div id="pf1a3" class="pf w0 h0" data-page-no="1a3"><div class="pc pc1a3 w0 h0"><div class="t m0 x2 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">13.4 事件类型    401 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff8d fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff8d fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff8d fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff8d fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff8d fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff8d fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff8d fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff8d fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff8d fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff8d fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff8d fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff8d fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff8d fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y24d2 ff8b fs2 fc0 sc0 ls13 wsb">(1) touchstart </div><div class="t m0 x0 h5 y24d3 ff8b fs2 fc0 sc0 ls13 wsb">(2) mouseover </div><div class="t m0 x0 h5 y2aed ff8b fs2 fc0 sc0 ls13 wsb">(3) mousemove（一次） </div><div class="t m0 x0 h5 y1ed1 ff8b fs2 fc0 sc0 ls13 wsb">(4) mousedown </div><div class="t m0 x0 h5 y2aee ff8b fs2 fc0 sc0 ls13 wsb">(5) mouseup </div><div class="t m0 x0 h5 y2aef ff8b fs2 fc0 sc0 ls13 wsb">(6) click </div><div class="t m0 x0 h5 y2af0 ff8b fs2 fc0 sc0 ls13 wsb">(7) touchend </div><div class="t m0 x0 h5 y970 ff92 fs2 fc0 sc0 ls8 wseb">支持触摸事件的浏览器包括iOS版Safari、Android版WebKit、bada版Dolfin、OS6+中的BlackBerry </div><div class="t m0 x0 h5 y2af1 ff8b fs2 fc0 sc0 lsfd wscc">WebKit、Opera Mobile 10.1+和LG专有OS中的Phantom 浏览器。目前只有iOS版Safari支持多点触摸。</div><div class="t m0 x0 h5 y2af2 ff92 fs2 fc0 sc0 ls8 wseb">桌面版Firefox 6+和Chrome也支持触摸事件。 </div><div class="t m0 x0 h3c y2af3 ff90 fs2 fc0 sc0 ls2e wsb">2. 手势事件 </div><div class="t m0 x0 h5 y2af4 ff8b fs2 fc0 sc0 ls94 ws193">iOS 2.0中的Safari还引入了一组手势事件。当两个手指触摸屏幕时就会产生手势，手势通常会改变</div><div class="t m0 x0 h5 y2af5 ff92 fs2 fc0 sc0 ls8 wseb">显示项的大小，或者旋转显示项。有三个手势事件，分别介绍如下。 </div><div class="t m0 x0 h5 y2af6 ff91 fs1 fc0 sc0 ls2"> gesturestart：当一个手指已经按在屏幕上而另一个手指又触摸屏幕时触发。 </div><div class="t m0 x0 h5 y2af7 ff91 fs1 fc0 sc0 ls2"> gesturechange：当触摸屏幕的任何一个手指的位置发生变化时触发。 </div><div class="t m0 x0 h5 y2af8 ff91 fs1 fc0 sc0 ls2"> gestureend：当任何一个手指从屏幕上面移开时触发。 </div><div class="t m0 x0 h4 y2af9 ff92 fs2 fc0 sc0 ls8 wseb">只有两个手指都触摸到事件的接收容器时才会触发这些事件。在一个元素上设置事件处理程序，意</div><div class="t m0 x0 h4 y2afa ff92 fs2 fc0 sc0 ls6 wsf7">味着两个手指必须同时位于该元素的范围之内，才能触发手势事件（这个元素就是目标）。由于这些事</div><div class="t m0 x0 h4 y2afb ff92 fs2 fc0 sc0 ls8 wseb">件冒泡，所以将事件处理程序放在文档上也可以处理所有手势事件。此时，事件的目标就是两个手指都</div><div class="t m0 x0 h5 y2afc ff92 fs2 fc0 sc0 ls8 wseb">位于其范围内的那个元素。 </div><div class="t m0 x0 h2b y2afd ff92 fs2 fc0 sc0 ls8 wseb">触摸事件和手势事件之间存在某种关系。当一个手指放在屏幕上时，会触发touchstart事件。如</div><div class="t m0 x0 h1e y2afe ff92 fs2 fc0 sc0 ls8 wseb">果另一个手指又放在了屏幕上，则会先触发gesturestart事件，随后触发基于该手指的touchstart</div><div class="t m0 x0 h4 y2aff ff92 fs2 fc0 sc0 ls8 wseb">事件。如果一个或两个手指在屏幕上滑动，将会触发gesturechange事件。但只要有一个手指移开，</div><div class="t m0 x0 hc y2b00 ff92 fs2 fc0 sc0 ls8 wseb">就会触发gestureend事件，紧接着又会触发基于该手指的touchend事件。 </div><div class="t m0 x0 h4 y2b01 ff92 fs2 fc0 sc0 lsed ws221">与触摸事件一样，每个手势事件的event对象都包含着标准的鼠标事件属性：bubbles、</div><div class="t m0 x0 h4 y2758 ff96 fs1 fc0 sc0 ls9 ws2">cancelable、view、clientX、clientY、screenX、screenY、detail、altKey、shiftKey、</div><div class="t m0 x0 h4 y2b02 ff96 fs1 fc0 sc0 ls9 ws2">ctrlKey和metaKey。此外，还包含两个额外的属性：rotation和scale。其中，rotation属性表</div><div class="t m0 x0 h5 y2b03 ff92 fs2 fc0 sc0 ls8 wseb">示手指变化引起的旋转角度，负值表示逆时针旋转，正值表示顺时针旋转（该值从0开始）。而scale</div><div class="t m0 x0 h5 y5de ff92 fs2 fc0 sc0 ls8 wseb">属性表示两个手指间距离的变化情况（例如向内收缩会缩短距离）；这个值从1开始，并随距离拉大而</div><div class="t m0 x0 h5 y2b04 ff92 fs2 fc0 sc0 ls8 wseb">增长，随距离缩短而减小。 </div><div class="t m0 x0 h5 y2b05 ff92 fs2 fc0 sc0 ls8 wseb">下面是使用手势事件的一个示例。 </div><div class="t m0 x5 hb y1a19 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2b06 ff96 fs6 fc0 sc0 ls21 wsb">function handleGestureEvent(event){         </div><div class="t m0 x0 hb y2b07 ff96 fs6 fc0 sc0 ls21 wsb">    var output = document.getElementById(&quot;output&quot;); </div><div class="t m0 x0 hb y2b08 ff96 fs6 fc0 sc0 ls21 wsb">    switch(event.type){ </div><div class="t m0 x0 hb y2b09 ff96 fs6 fc0 sc0 ls21 wsb">        case &quot;gesturestart&quot;: </div><div class="t m0 x0 hb y2b0a ff96 fs6 fc0 sc0 ls21 wsb">            output.innerHTML = &quot;Gesture started (rotation=&quot; + event.rotation +  </div><div class="t m0 x0 hb y2b0b ff96 fs6 fc0 sc0 ls21 wsb">                               &quot;,scale=&quot; + event.scale + &quot;)&quot;; </div><div class="t m0 x0 hb y2b0c ff96 fs6 fc0 sc0 ls21 wsb">            break; </div><div class="t m0 x0 hb y2b0d ff96 fs6 fc0 sc0 ls21 wsb">        case &quot;gestureend&quot;: </div><div class="t m0 x0 hb y2b0e ff96 fs6 fc0 sc0 ls21 wsb">            output.innerHTML += &quot;&lt;br&gt;Gesture ended (rotation=&quot; + event.rotation +  </div><div class="t m0 x0 hb y2b0f ff96 fs6 fc0 sc0 ls21 wsb">                                &quot;,scale=&quot; + event.scale + &quot;)&quot;; </div><div class="t m0 x0 hb y2b10 ff96 fs6 fc0 sc0 ls21 wsb">            break; </div><div class="t m0 x0 hb y2b11 ff96 fs6 fc0 sc0 ls21 wsb">        case &quot;gesturechange&quot;: </div></div></div>
<div id="pf1a4" class="pf w0 h0" data-page-no="1a4"><div class="pc pc1a4 w0 h0"><div class="t m0 x0 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">402  第13章 事件 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 ff96 fs6 fc0 sc0 ls21 wsb">            output.innerHTML += &quot;&lt;br&gt;Gesture changed (rotation=&quot; + event.rotation +  </div><div class="t m0 x0 hb y7a ff96 fs6 fc0 sc0 ls21 wsb">                                &quot;,scale=&quot; + event.scale + &quot;)&quot;; </div><div class="t m0 x0 hb y7b ff96 fs6 fc0 sc0 ls21 wsb">            break; </div><div class="t m0 x0 hb y7c ff96 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y7d ff96 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y7e ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y7f ff96 fs6 fc0 sc0 ls21 wsb">document.addEventListener(&quot;gesturestart&quot;, handleGestureEvent, false); </div><div class="t m0 x0 hb y80 ff96 fs6 fc0 sc0 ls21 wsb">document.addEventListener(&quot;gestureend&quot;, handleGestureEvent, false); </div><div class="t m0 x0 hb y81 ff96 fs6 fc0 sc0 ls21 wsb">document.addEventListener(&quot;gesturechange&quot;, handleGestureEvent, false); </div><div class="t m0 x0 hb y1107 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1108 ff97 fs2 fc0 sc0 ls81 wsb">GestureEventsExample01.htm </div><div class="t m0 x0 h4 y1109 ff92 fs2 fc0 sc0 ls8 wseb">与前面演示触摸事件的例子一样，这里的代码只是将每个事件都关联到同一个函数中，然后通过该</div><div class="t m0 x0 h5 y2b13 ff92 fs2 fc0 sc0 ls8 wseb">函数输出每个事件的相关信息。 </div><div class="t m0 x5 ha y2b14 ff8c fs2 fc0 sc0 ls8 ws14">触摸事件也会返回rotation和scale属性，但这两个属性只会在两个手指与</div><div class="t m0 x0 ha y2b15 ff8c fs2 fc0 sc0 ls8 ws14">屏幕保持接触时才会发生变化。一般来说，使用基于两个手指的手势事件，要比管理</div><div class="t m0 x0 h5 y2b16 ff8c fs2 fc0 sc0 ls8 ws14">触摸事件中的所有交互要容易得多。 </div><div class="t m0 x0 hd y2b17 ff90 fs7 fc0 sc0 ls245">13.5 内存和性能 </div><div class="t m0 x0 h5 y2b18 ff92 fs2 fc0 sc0 ls8 wseb">由于事件处理程序可以为现代Web应用程序提供交互能力，因此许多开发人员会不分青红皂白地</div><div class="t m0 x0 h5 y2b19 ff92 fs2 fc0 sc0 ls8 wseb">向页面中添加大量的处理程序。在创建GUI的语言（如C#）中，为GUI中的每个按钮添加一个onclick</div><div class="t m0 x0 h5 y2b1a ff92 fs2 fc0 sc0 ls8 wseb">事件处理程序是司空见惯的事，而且这样做也不会导致什么问题。可是在JavaScript中，添加到页面上</div><div class="t m0 x0 h4 y2b1b ff92 fs2 fc0 sc0 ls8 wseb">的事件处理程序数量将直接关系到页面的整体运行性能。导致这一问题的原因是多方面的。首先，每个</div><div class="t m0 x0 h4 y2b1c ff92 fs2 fc0 sc0 ls8 wseb">函数都是对象，都会占用内存；内存中的对象越多，性能就越差。其次，必须事先指定所有事件处理程</div><div class="t m0 x0 h5 y2b1d ff92 fs2 fc0 sc0 ls8 wseb">序而导致的DOM访问次数，会延迟整个页面的交互就绪时间。事实上，从如何利用好事件处理程序的</div><div class="t m0 x0 h5 y2b1e ff92 fs2 fc0 sc0 ls8 wseb">角度出发，还是有一些方法能够提升性能的。 </div><div class="t m0 x0 h20 y2b1f ff90 fs3 fc0 sc0 ls248 ws214">13.5.1 事件委托 </div><div class="t m0 x0 h4 y345 ff92 fs2 fc0 sc0 ls8 wseb">对“事件处理程序过多”问题的解决方案就是事件委托。事件委托利用了事件冒泡，只指定一个事</div><div class="t m0 x0 h1e y2b20 ff92 fs2 fc0 sc0 ls8 wseb">件处理程序，就可以管理某一类型的所有事件。例如，click事件会一直冒泡到document层次。也就</div><div class="t m0 x0 h1e y2b21 ff92 fs2 fc0 sc0 ls8 wseb">是说，我们可以为整个页面指定一个onclick事件处理程序，而不必给每个可单击的元素分别添加事</div><div class="t m0 x0 h5 y2b22 ff92 fs2 fc0 sc0 ls8 wseb">件处理程序。以下面的HTML代码为例。 </div><div class="t m0 x0 hb y2b23 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2b24 ff96 fs6 fc0 sc0 ls21 wsb">&lt;ul id=&quot;myLinks&quot;&gt; </div><div class="t m0 x0 hb y2b25 ff96 fs6 fc0 sc0 ls21 wsb">    &lt;li id=&quot;goSomewhere&quot;&gt;Go somewhere&lt;/li&gt; </div><div class="t m0 x0 hb y2b26 ff96 fs6 fc0 sc0 ls21 wsb">    &lt;li id=&quot;doSomething&quot;&gt;Do something&lt;/li&gt; </div><div class="t m0 x0 hb y2b27 ff96 fs6 fc0 sc0 ls21 wsb">    &lt;li id=&quot;sayHi&quot;&gt;Say hi&lt;/li&gt; </div><div class="t m0 x0 hb y2b28 ff96 fs6 fc0 sc0 ls21 wsb">&lt;/ul&gt; </div><div class="t m0 x0 hb y2b29 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y2b2a ff97 fs2 fc0 sc0 ls1b wsb">EventDelegationExample01.htm </div><div class="t m0 x0 h5 y2b2b ff92 fs2 fc0 sc0 ls8 wseb">其中包含3个被单击后会执行操作的列表项。按照传统的做法，需要像下面这样为它们添加3个事</div><div class="t m0 x0 h5 y2b2c ff92 fs2 fc0 sc0 ls8 wseb">件处理程序。 </div></div></div>
<div id="pf1a5" class="pf w0 h0" data-page-no="1a5"><div class="pc pc1a5 w0 h0"><div class="t m0 x2 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">13.5 内存和性能    403 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff8d fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff8d fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff8d fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff8d fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff8d fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff8d fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff8d fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff8d fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff8d fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff8d fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff8d fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff8d fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff8d fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x5 hb y866 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y867 ff96 fs6 fc0 sc0 ls21 wsb">var item1 = document.getElementById(&quot;goSomewhere&quot;); </div><div class="t m0 x0 hb y2b2d ff96 fs6 fc0 sc0 ls21 wsb">var item2 = document.getElementById(&quot;doSomething&quot;); </div><div class="t m0 x0 hb y2b2e ff96 fs6 fc0 sc0 ls21 wsb">var item3 = document.getElementById(&quot;sayHi&quot;); </div><div class="t m0 x0 hb y2b2f ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2b30 ff96 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(item1, &quot;click&quot;, function(event){ </div><div class="t m0 x0 hb y2b31 ff96 fs6 fc0 sc0 ls21 wsb">    location.href = &quot;http://www.wrox.com&quot;; </div><div class="t m0 x0 hb y2b32 ff96 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 hb y2b33 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2b34 ff96 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(item2, &quot;click&quot;, function(event){ </div><div class="t m0 x0 hb y2b35 ff96 fs6 fc0 sc0 ls21 wsb">    document.title = &quot;I changed the document&apos;s title&quot;; </div><div class="t m0 x0 hb y2b36 ff96 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 hb y2b37 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2b38 ff96 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(item3, &quot;click&quot;, function(event){ </div><div class="t m0 x0 hb y2b39 ff96 fs6 fc0 sc0 ls21 wsb">    alert(&quot;hi&quot;); </div><div class="t m0 x0 hb y2b3a ff96 fs6 fc0 sc0 ls21 wsb">});  </div><div class="t m0 x0 h5 y18eb ff92 fs2 fc0 sc0 ls8 wseb">如果在一个复杂的Web应用程序中，对所有可单击的元素都采用这种方式，那么结果就会有数不</div><div class="t m0 x0 h4 y193a ff92 fs2 fc0 sc0 ls8 wseb">清的代码用于添加事件处理程序。此时，可以利用事件委托技术解决这个问题。使用事件委托，只需在</div><div class="t m0 x0 h5 y2b3b ff8b fs2 fc0 sc0 ls81 ws76">DOM树中尽量最高的层次上添加一个事件处理程序，如下面的例子所示。 </div><div class="t m0 x5 hb y2b3c ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2b3d ff96 fs6 fc0 sc0 ls21 wsb">var list = document.getElementById(&quot;myLinks&quot;); </div><div class="t m0 x0 hb y2b3e ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2b3f ff96 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(list, &quot;click&quot;, function(event){ </div><div class="t m0 x0 hb y2b40 ff96 fs6 fc0 sc0 ls21 wsb">    event = EventUtil.getEvent(event); </div><div class="t m0 x0 hb y2b41 ff96 fs6 fc0 sc0 ls21 wsb">    var target = EventUtil.getTarget(event); </div><div class="t m0 x0 hb y2b42 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2b43 ff96 fs6 fc0 sc0 ls21 wsb">    switch(target.id){ </div><div class="t m0 x0 hb y2b44 ff96 fs6 fc0 sc0 ls21 wsb">        case &quot;doSomething&quot;: </div><div class="t m0 x0 hb y2b45 ff96 fs6 fc0 sc0 ls21 wsb">            document.title = &quot;I changed the document&apos;s title&quot;; </div><div class="t m0 x0 hb y2b46 ff96 fs6 fc0 sc0 ls21 wsb">            break; </div><div class="t m0 x0 hb y2b47 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2b48 ff96 fs6 fc0 sc0 ls21 wsb">        case &quot;goSomewhere&quot;: </div><div class="t m0 x0 hb y2b49 ff96 fs6 fc0 sc0 ls21 wsb">            location.href = &quot;http://www.wrox.com&quot;; </div><div class="t m0 x0 hb y2b4a ff96 fs6 fc0 sc0 ls21 wsb">            break; </div><div class="t m0 x0 hb y2b4b ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2b4c ff96 fs6 fc0 sc0 ls21 wsb">        case &quot;sayHi&quot;: </div><div class="t m0 x0 hb y2b4d ff96 fs6 fc0 sc0 ls21 wsb">            alert(&quot;hi&quot;); </div><div class="t m0 x0 hb y2b4e ff96 fs6 fc0 sc0 ls21 wsb">            break; </div><div class="t m0 x0 hb y2b4f ff96 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y2b50 ff96 fs6 fc0 sc0 ls21 wsb">});  </div><div class="t m0 x2 hf y171c ff97 fs2 fc0 sc0 ls1b wsb">EventDelegationExample01.htm </div><div class="t m0 x0 h4 y2b51 ff92 fs2 fc0 sc0 ls8 wseb">在这段代码里，我们使用事件委托只为&lt;ul&gt;元素添加了一个onclick事件处理程序。由于所有列</div><div class="t m0 x0 h4 y14b6 ff92 fs2 fc0 sc0 ls8 wseb">表项都是这个元素的子节点，而且它们的事件会冒泡，所以单击事件最终会被这个函数处理。我们知道，</div><div class="t m0 x0 h1c y2b52 ff92 fs2 fc0 sc0 ls8 wseb">事件目标是被单击的列表项，故而可以通过检测id属性来决定采取适当的操作。与前面未使用事件委</div><div class="t m0 x0 h5 y2b53 ff92 fs2 fc0 sc0 ls8 wseb">托的代码比一比，会发现这段代码的事前消耗更低，因为只取得了一个DOM元素，只添加了一个事件</div><div class="t m0 x0 h4 y2b54 ff92 fs2 fc0 sc0 ls8 wseb">处理程序。虽然对用户来说最终的结果相同，但这种技术需要占用的内存更少。所有用到按钮的事件（多</div><div class="t m0 x0 h5 y2b55 ff92 fs2 fc0 sc0 ls8 wseb">数鼠标事件和键盘事件）都适合采用事件委托技术。 </div><div class="t m0 x0 h4b y2b56 ff92 fs2 fc0 sc0 ls8 wseb">如果可行的话，也可以考虑为document对象添加一个事件处理程序，用以处理页面上发生的某种</div><div class="t m0 x0 h5 y2b57 ff92 fs2 fc0 sc0 ls8 wseb">特定类型的事件。这样做与采取传统的做法相比具有如下优点。 </div></div></div>
<div id="pf1a6" class="pf w0 h0" data-page-no="1a6"><div class="pc pc1a6 w0 h0"><div class="t m0 x0 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">404  第13章 事件 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ff91 fs1 fc0 sc0 ls2"> document对象很快就可以访问，而且可以在页面生命周期的任何时点上为它添加事件处理程序</div><div class="t m0 x0 h1e y4d ff92 fs2 fc0 sc0 ls8 wseb">（无需等待DOMContentLoaded或load事件）。换句话说，只要可单击的元素呈现在页面上，</div><div class="t m0 x0 h5 y5 ff92 fs2 fc0 sc0 ls8 wseb">就可以立即具备适当的功能。 </div><div class="t m0 x0 h5 yd9 ff91 fs1 fc0 sc0 ls2"> 在页面中设置事件处理程序所需的时间更少。只添加一个事件处理程序所需的DOM引用更少，</div><div class="t m0 x0 h5 y15d ff92 fs2 fc0 sc0 ls8 wseb">所花的时间也更少。 </div><div class="t m0 x0 h5 y8 ff91 fs1 fc0 sc0 ls2"> 整个页面占用的内存空间更少，能够提升整体性能。 </div><div class="t m0 x0 h1e y15e ff92 fs2 fc0 sc0 ls5f ws10b">最适合采用事件委托技术的事件包括click、mousedown、mouseup、keydown、keyup和keypress。</div><div class="t m0 x0 h1e y15f ff92 fs2 fc0 sc0 ls5f ws10b">虽然mouseover和mouseout事件也冒泡，但要适当处理它们并不容易，而且经常需要计算元素的位置。</div><div class="t m0 x0 h5 yb ff92 fs2 fc0 sc0 ls5f ws10b">（因为当鼠标从一个元素移到其子节点时，或者当鼠标移出该元素时，都会触发mouseout事件。） </div><div class="t m0 x0 h20 y2b58 ff90 fs3 fc0 sc0 ls248 ws214">13.5.2 移除事件处理程序 </div><div class="t m0 x0 h5 y1255 ff92 fs2 fc0 sc0 ls8 wseb">每当将事件处理程序指定给元素时，运行中的浏览器代码与支持页面交互的JavaScript代码之间就</div><div class="t m0 x0 h4 y1256 ff92 fs2 fc0 sc0 ls8 wseb">会建立一个连接。这种连接越多，页面执行起来就越慢。如前所述，可以采用事件委托技术，限制建立</div><div class="t m0 x0 h4 y2b59 ff92 fs2 fc0 sc0 ls8 wseb">的连接数量。另外，在不需要的时候移除事件处理程序，也是解决这个问题的一种方案。内存中留有那</div><div class="t m0 x0 h5 y2b5a ff92 fs2 fc0 sc0 ls8 wseb">些过时不用的“空事件处理程序”（dangling event handler），也是造成Web应用程序内存与性能问题的</div><div class="t m0 x0 h5 y2b5b ff92 fs2 fc0 sc0 ls8 wseb">主要原因。 </div><div class="t m0 x0 h4 y2b5c ff92 fs2 fc0 sc0 ls8 wseb">在两种情况下，可能会造成上述问题。第一种情况就是从文档中移除带有事件处理程序的元素时。</div><div class="t m0 x0 h5 y2b5d ff92 fs2 fc0 sc0 ls8 wseb">这可能是通过纯粹的DOM操作，例如使用removeChild()和replaceChild()方法，但更多地是发</div><div class="t m0 x0 h4 y125c ff92 fs2 fc0 sc0 ls8 wseb">生在使用innerHTML替换页面中某一部分的时候。如果带有事件处理程序的元素被innerHTML 删除</div><div class="t m0 x0 h5 y2b5e ff92 fs2 fc0 sc0 ls8 wseb">了，那么原来添加到元素中的事件处理程序极有可能无法被当作垃圾回收。来看下面的例子。 </div><div class="t m0 x0 hb y2b5f ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2b60 ff96 fs6 fc0 sc0 ls21 wsb">&lt;div id=&quot;myDiv&quot;&gt; </div><div class="t m0 x0 hb y2b61 ff96 fs6 fc0 sc0 ls21 wsb">    &lt;input type=&quot;button&quot; value=&quot;Click Me&quot; id=&quot;myBtn&quot;&gt; </div><div class="t m0 x0 hb y2b62 ff96 fs6 fc0 sc0 ls21 wsb">&lt;/div&gt; </div><div class="t m0 x0 hb y2b63 ff96 fs6 fc0 sc0 ls21 wsb">&lt;script type=&quot;text/javascript&quot;&gt; </div><div class="t m0 x0 hb y2b64 ff96 fs6 fc0 sc0 ls21 wsb">    var btn = document.getElementById(&quot;myBtn&quot;); </div><div class="t m0 x0 hb y2b65 ff96 fs6 fc0 sc0 ls21 wsb">    btn.onclick = function(){ </div><div class="t m0 x0 hb y2b66 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2b67 ff96 fs6 fc0 sc0 ls21 wsb">        //先执行某些操作 </div><div class="t m0 x0 hb y2b68 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2b69 ff96 fs6 fc0 sc0 ls21 wsb">        document.getElementById(&quot;myDiv&quot;).innerHTML = &quot;Processing...&quot;; //麻烦了！ </div><div class="t m0 x0 hb y2b6a ff96 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 hb y2b6b ff96 fs6 fc0 sc0 ls21 wsb">&lt;/script&gt; </div><div class="t m0 x0 hb y2b6c ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y85f ff92 fs2 fc0 sc0 ls8 wseb">这里，有一个按钮被包含在&lt;div&gt;元素中。为避免双击，单击这个按钮时就将按钮移除并替换成一</div><div class="t m0 x0 h4 y2b6d ff92 fs2 fc0 sc0 ls8 wseb">条消息；这是网站设计中非常流行的一种做法。但问题在于，当按钮被从页面中移除时，它还带着一个</div><div class="t m0 x0 h1e y2b6e ff92 fs2 fc0 sc0 ls8 wseb">事件处理程序呢。在&lt;div&gt;元素上设置innerHTML可以把按钮移走，但事件处理程序仍然与按钮保持</div><div class="t m0 x0 h5 y2b6f ff92 fs2 fc0 sc0 ls8 wseb">着引用关系。有的浏览器（尤其是IE）在这种情况下不会作出恰当地处理，它们很有可能会将对元素和</div><div class="t m0 x0 h4 y2b70 ff92 fs2 fc0 sc0 ls8 wseb">对事件处理程序的引用都保存在内存中。如果你知道某个元素即将被移除，那么最好手工移除事件处理</div><div class="t m0 x0 h5 y2b71 ff92 fs2 fc0 sc0 ls8 wseb">程序，如下面的例子所示。 </div><div class="t m0 x0 hb y2b72 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2b73 ff96 fs6 fc0 sc0 ls21 wsb">&lt;div id=&quot;myDiv&quot;&gt; </div><div class="t m0 x0 hb y2b74 ff96 fs6 fc0 sc0 ls21 wsb">    &lt;input type=&quot;button&quot; value=&quot;Click Me&quot; id=&quot;myBtn&quot;&gt; </div><div class="t m0 x0 hb y2b75 ff96 fs6 fc0 sc0 ls21 wsb">&lt;/div&gt; </div><div class="t m0 x0 hb y2b76 ff96 fs6 fc0 sc0 ls21 wsb">&lt;script type=&quot;text/javascript&quot;&gt; </div><div class="t m0 x0 hb y2b77 ff96 fs6 fc0 sc0 ls21 wsb">    var btn = document.getElementById(&quot;myBtn&quot;); </div></div></div>
<div id="pf1a7" class="pf w0 h0" data-page-no="1a7"><div class="pc pc1a7 w0 h0"><div class="t m0 x2 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">13.6 模拟事件    405 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff8d fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff8d fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff8d fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff8d fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff8d fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff8d fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff8d fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff8d fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff8d fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff8d fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff8d fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff8d fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff8d fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y79 ff96 fs6 fc0 sc0 ls21 wsb">    btn.onclick = function(){ </div><div class="t m0 x0 hb y7a ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y7b ff96 fs6 fc0 sc0 ls21 wsb">        //先执行某些操作 </div><div class="t m0 x0 hb y7c ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y7d ff99 fs6 fc0 sc0 ls21 wsb">        btn.onclick = null;    //移除事件处理程序 </div><div class="t m0 x0 hb y2b78 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2b79 ff96 fs6 fc0 sc0 ls21 wsb">        document.getElementById(&quot;myDiv&quot;).innerHTML = &quot;Processing...&quot;;  </div><div class="t m0 x0 hb y2b7a ff96 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 hb y2b7b ff96 fs6 fc0 sc0 ls21 wsb">&lt;/script&gt; </div><div class="t m0 x5 hb y2b7c ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y2b7d ff92 fs2 fc0 sc0 ls8 wseb">在此，我们在设置&lt;div&gt;的innerHTML属性之前，先移除了按钮的事件处理程序。这样就确保了</div><div class="t m0 x0 h5 y2b7e ff92 fs2 fc0 sc0 ls8 wseb">内存可以被再次利用，而从DOM中移除按钮也做到了干净利索。 </div><div class="t m0 x0 h5 y2b7f ff92 fs2 fc0 sc0 ls8 wseb">注意，在事件处理程序中删除按钮也能阻止事件冒泡。目标元素在文档中是事件冒泡的前提。 </div><div class="t m0 x5 ha y2b80 ff8c fs2 fc0 sc0 ls8 ws14">采用事件委托也有助于解决这个问题。如果事先知道将来有可能使用innerHTML</div><div class="t m0 x5 ha y2b81 ff8c fs2 fc0 sc0 ls30 ws12c">替换掉页面中的某一部分，那么就可以不直接把事件处理程序添加到该部分的元素</div><div class="t m0 x5 h5 y2b82 ff8c fs2 fc0 sc0 ls8 ws14">中。而通过把事件处理程序指定给较高层次的元素，同样能够处理该区域中的事件。 </div><div class="t m0 x0 h5 y2b83 ff92 fs2 fc0 sc0 ls8 wseb">导致“空事件处理程序”的另一种情况，就是卸载页面的时候。毫不奇怪，IE8及更早版本在这种</div><div class="t m0 x0 h4 y2b84 ff92 fs2 fc0 sc0 ls8 wseb">情况下依然是问题最多的浏览器，尽管其他浏览器或多或少也有类似的问题。如果在页面被卸载之前没</div><div class="t m0 x0 h4 y2b85 ff92 fs2 fc0 sc0 ls8 wseb">有清理干净事件处理程序，那它们就会滞留在内存中。每次加载完页面再卸载页面时（可能是在两个页</div><div class="t m0 x0 h4 y2b86 ff92 fs2 fc0 sc0 ls6 wsf7">面间来回切换，也可以是单击了“刷新”按钮），内存中滞留的对象数目就会增加，因为事件处理程序</div><div class="t m0 x0 h5 y2b87 ff92 fs2 fc0 sc0 ls8 wseb">占用的内存并没有被释放。 </div><div class="t m0 x0 hed y2b88 ff92 fs2 fc0 sc0 ls8 wseb">一般来说，最好的做法是在页面卸载之前，先通过onunload事件处理程序移除所有事件处理程序。</div><div class="t m0 x0 h4 y2b89 ff92 fs2 fc0 sc0 ls8 wseb">在此，事件委托技术再次表现出它的优势——需要跟踪的事件处理程序越少，移除它们就越容易。对这</div><div class="t m0 x0 h1c y2b8a ff92 fs2 fc0 sc0 ls8 wseb">种类似撤销的操作，我们可以把它想象成：只要是通过onload事件处理程序添加的东西，最后都要通</div><div class="t m0 x0 h5 yc4 ff92 fs2 fc0 sc0 ls382">过onunload事件处理程序将它们移除。 </div><div class="t m0 x5 h1d y2b8b ff8c fs2 fc0 sc0 ls8 ws14">不要忘了，使用onunload事件处理程序意味着页面不会被缓存在bfcache中。</div><div class="t m0 x5 h5 y2b8c ff8c fs2 fc0 sc0 ls42 ws2fc">如果你在意这个问题，那么就只能在IE中通过onunload来移除事件处理程序了。 </div><div class="t m0 x0 hd y18f9 ff90 fs7 fc0 sc0 ls245">13.6 模拟事件 </div><div class="t m0 x0 h4 y2b8d ff92 fs2 fc0 sc0 ls8 wseb">事件，就是网页中某个特别值得关注的瞬间。事件经常由用户操作或通过其他浏览器功能来触发。</div><div class="t m0 x0 h5 y2b8e ff92 fs2 fc0 sc0 ls8 wseb">但很少有人知道，也可以使用JavaScript在任意时刻来触发特定的事件，而此时的事件就如同浏览器创</div><div class="t m0 x0 h4 y2b8f ff92 fs2 fc0 sc0 ls8 wseb">建的事件一样。也就是说，这些事件该冒泡还会冒泡，而且照样能够导致浏览器执行已经指定的处理它</div><div class="t m0 x0 h5 y2b90 ff92 fs2 fc0 sc0 ls8 wseb">们的事件处理程序。在测试Web应用程序，模拟触发事件是一种极其有用的技术。DOM2 级规范为此</div><div class="t m0 x0 h5 y2b91 ff92 fs2 fc0 sc0 ls8 wseb">规定了模拟特定事件的方式，IE9、Opera、Firefox、Chrome和Safari都支持这种方式。IE有它自己模拟</div><div class="t m0 x0 h5 y2b92 ff92 fs2 fc0 sc0 ls8 wseb">事件的方式。 </div><div class="t m0 x0 h20 y2b93 ff90 fs3 fc0 sc0 ls248 ws214">13.6.1 DOM中的事件模拟 </div><div class="t m0 x0 h4 y2b94 ff92 fs2 fc0 sc0 ls8 wseb">可以在document对象上使用createEvent()方法创建event 对象。这个方法接收一个参数，即</div><div class="t m0 x0 h5 y2b95 ff92 fs2 fc0 sc0 ls8 wseb">表示要创建的事件类型的字符串。在DOM2级中，所有这些字符串都使用英文复数形式，而在DOM3</div></div></div>
<div id="pf1a8" class="pf w0 h0" data-page-no="1a8"><div class="pc pc1a8 w0 h0"><div class="t m0 x0 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">406  第13章 事件 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff92 fs2 fc0 sc0 ls8 wseb">级中都变成了单数。这个字符串可以是下列几字符串之一。 </div><div class="t m0 x0 h5 y4 ff91 fs1 fc0 sc0 ls2"> UIEvents：一般化的UI事件。鼠标事件和键盘事件都继承自UI事件。DOM3级中是UIEvent。 </div><div class="t m0 x0 h5 y4e ff91 fs1 fc0 sc0 ls2"> MouseEvents：一般化的鼠标事件。DOM3级中是MouseEvent。 </div><div class="t m0 x0 h5 yd9 ff91 fs1 fc0 sc0 ls2"> MutationEvents：一般化的DOM变动事件。DOM3级中是MutationEvent。 </div><div class="t m0 x0 h5 y219 ff91 fs1 fc0 sc0 ls2"> HTMLEvents：一般化的HTML事件。没有对应的DOM3级事件（HTML事件被分散到其他类</div><div class="t m0 x0 h5 y21a ff92 fs2 fc0 sc0 ls8 wseb">别中）。 </div><div class="t m0 x0 h5 y5c8 ff92 fs2 fc0 sc0 ls8 wseb">要注意的是，“DOM2级事件”并没有专门规定键盘事件，后来的“DOM3级事件”中才正式将其</div><div class="t m0 x0 h5 y2b96 ff92 fs2 fc0 sc0 ls8 wseb">作为一种事件给出规定。IE9是目前唯一支持DOM3级键盘事件的浏览器。不过，在其他浏览器中，在</div><div class="t m0 x0 h5 y2b97 ff92 fs2 fc0 sc0 ls8 wseb">现有方法的基础上，可以通过几种方式来模拟键盘事件。 </div><div class="t m0 x0 h2b y2b98 ff92 fs2 fc0 sc0 ls8 wseb">在创建了event对象之后，还需要使用与事件有关的信息对其进行初始化。每种类型的event对</div><div class="t m0 x0 h1e y116b ff92 fs2 fc0 sc0 ls8 wseb">象都有一个特殊的方法，为它传入适当的数据就可以初始化该event对象。不同类型的这个方法的名</div><div class="t m0 x0 hc ye ff92 fs2 fc0 sc0 ls8 wseb">字也不相同，具体要取决于createEvent()中使用的参数。 </div><div class="t m0 x0 h4 y21c ff92 fs2 fc0 sc0 ls30 wsf6">模拟事件的最后一步就是触发事件。这一步需要使用dispatchEvent()方法，所有支持事件的</div><div class="t m0 x0 h5 y116c ff8b fs2 fc0 sc0 ls81 ws76">DOM节点都支持这个方法。调用dispatchEvent()方法时，需要传入一个参数，即表示要触发事件</div><div class="t m0 x0 h1e y1e96 ff92 fs2 fc0 sc0 ls383">的event对象。触发事件之后，该事件就跻身“官方事件”之列了，因而能够照样冒泡并引发相应事</div><div class="t m0 x0 h5 y12 ff92 fs2 fc0 sc0 ls8 wseb">件处理程序的执行。 </div><div class="t m0 x0 h3c y2b99 ff90 fs2 fc0 sc0 ls2e wsb">1. 模拟鼠标事件 </div><div class="t m0 x0 h4 y2b9a ff92 fs2 fc0 sc0 ls8 wseb">创建新的鼠标事件对象并为其指定必要的信息，就可以模拟鼠标事件。创建鼠标事件对象的方法是</div><div class="t m0 x0 h4 y2b9b ff92 fs2 fc0 sc0 ls384">为createEvent()传入字符串&quot;MouseEvents&quot;。返回的对象有一个名为initMouseEvent()方法，</div><div class="t m0 x0 h5 y20f4 ff92 fs2 fc0 sc0 ls8 wseb">用于指定与该鼠标事件有关的信息。这个方法接收15个参数，分别与鼠标事件中每个典型的属性一一</div><div class="t m0 x0 h5 y2b9c ff92 fs2 fc0 sc0 ls8 wseb">对应；这些参数的含义如下。 </div><div class="t m0 x0 h5 y1a5c ff91 fs1 fc0 sc0 ls2"> type（字符串）：表示要触发的事件类型，例如&quot;click&quot;。 </div><div class="t m0 x0 h4 y26b6 ff91 fs1 fc0 sc0 ls2"> bubbles（布尔值）：表示事件是否应该冒泡。为精确地模拟鼠标事件，应该把这个参数设置为</div><div class="t m0 x0 h5 y26b7 ff96 fs1 fc0 sc0 ls9 ws2">true。 </div><div class="t m0 x0 h4 y26b8 ff91 fs1 fc0 sc0 ls2"> cancelable（布尔值）：表示事件是否可以取消。为精确地模拟鼠标事件，应该把这个参数设</div><div class="t m0 x0 hc y2b9d ff92 fs2 fc0 sc0 ls8 wseb">置为true。 </div><div class="t m0 x0 h5 y26ba ff91 fs1 fc0 sc0 ls8 ws134"> view（AbstractView）：与事件关联的视图。这个参数几乎总是要设置为document.defaultView。 </div><div class="t m0 x0 h5 yd13 ff91 fs1 fc0 sc0 ls8 ws134"> detail（整数）：与事件有关的详细信息。这个值一般只有事件处理程序使用，但通常都设置为0。 </div><div class="t m0 x0 h5 y2b9e ff91 fs1 fc0 sc0 ls2"> screenX（整数）：事件相对于屏幕的X坐标。 </div><div class="t m0 x0 h5 y2b9f ff91 fs1 fc0 sc0 ls2"> screenY（整数）：事件相对于屏幕的Y坐标。 </div><div class="t m0 x0 h5 y2ba0 ff91 fs1 fc0 sc0 ls2"> clientX（整数）：事件相对于视口的X坐标。 </div><div class="t m0 x0 h5 y2ba1 ff91 fs1 fc0 sc0 ls2"> clientY（整数）：事件想对于视口的Y坐标。 </div><div class="t m0 x0 h5 y2ba2 ff91 fs1 fc0 sc0 ls2"> ctrlKey（布尔值）：表示是否按下了Ctrl键。默认值为false。 </div><div class="t m0 x0 h5 y144a ff91 fs1 fc0 sc0 ls2"> altKey（布尔值）：表示是否按下了Alt键。默认值为false。 </div><div class="t m0 x0 h5 y2ba3 ff91 fs1 fc0 sc0 ls2"> shiftKey（布尔值）：表示是否按下了Shift键。默认值为false。 </div><div class="t m0 x0 h5 y39f ff91 fs1 fc0 sc0 ls2"> metaKey（布尔值）：表示是否按下了Meta键。默认值为false。 </div><div class="t m0 x0 h5 y1f72 ff91 fs1 fc0 sc0 ls2"> button（整数）：表示按下了哪一个鼠标键。默认值为0。 </div><div class="t m0 x0 h4 y2ba4 ff91 fs1 fc0 sc0 ls8 ws134"> relatedTarget（对象）：表示与事件相关的对象。这个参数只在模拟mouseover或mouseout</div><div class="t m0 x0 h5 y1bfd ff92 fs2 fc0 sc0 ls1f">时使用。 </div></div></div>
<div id="pf1a9" class="pf w0 h0" data-page-no="1a9"><div class="pc pc1a9 w0 h0"><div class="t m0 x2 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">13.6 模拟事件    407 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff8d fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff8d fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff8d fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff8d fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff8d fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff8d fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff8d fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff8d fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff8d fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff8d fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff8d fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff8d fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff8d fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h4 y3 ff92 fs2 fc0 sc0 ls8 wseb">显而易见，initMouseEvent()方法的这些参数是与鼠标事件的event对象所包含的属性一一对</div><div class="t m0 x0 h5 y4d ff92 fs2 fc0 sc0 ls8 wseb">应的。其中，前4个参数对正确地激发事件至关重要，因为浏览器要用到这些参数；而剩下的所有参数</div><div class="t m0 x0 h1c yd8 ff92 fs2 fc0 sc0 ls8 wseb">只有在事件处理程序中才会用到。当把event对象传给dispatchEvent()方法时，这个对象的target</div><div class="t m0 x0 h5 yd9 ff92 fs2 fc0 sc0 ls8 wseb">属性会自动设置。下面，我们就通过一个例子来了解如何模拟对按钮的单击事件。 </div><div class="t m0 x5 hb ya81 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2ba5 ff96 fs6 fc0 sc0 ls21 wsb">var btn = document.getElementById(&quot;myBtn&quot;); </div><div class="t m0 x0 hb y2ba6 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2ba7 ff96 fs6 fc0 sc0 ls21">//创建事件对象 </div><div class="t m0 x0 hb y2ba8 ff96 fs6 fc0 sc0 ls21 wsb">var event = document.createEvent(&quot;MouseEvents&quot;); </div><div class="t m0 x0 hb y2ba9 ff96 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 h16 y2baa ff96 fs6 fc0 sc0 ls21">//初始化事件对象 </div><div class="t m0 x0 hb y2bab ff96 fs6 fc0 sc0 ls21 wsb">event.initMouseEvent(&quot;click&quot;, true, true, document.defaultView, 0, 0, 0, 0, 0,  </div><div class="t m0 x0 hb y2bac ff96 fs6 fc0 sc0 ls21 wsb">                     false, false, false, false, 0, null); </div><div class="t m0 x0 hb y2bad ff96 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 h16 y2bae ff96 fs6 fc0 sc0 ls21">//触发事件 </div><div class="t m0 x0 hb y2baf ff96 fs6 fc0 sc0 ls21 wsb">btn.dispatchEvent(event); </div><div class="t m0 x2 hf y2bb0 ff97 fs2 fc0 sc0 ls79 wsb">SimulateDOMClickExample01.htm </div><div class="t m0 x0 h5 y2bb1 ff92 fs2 fc0 sc0 ls8 wseb">在兼容DOM的浏览器中，也可以通过相同的方式来模拟其他鼠标事件（例如dblclick）。 </div><div class="t m0 x0 h3c y2bb2 ff90 fs2 fc0 sc0 ls2e wsb">2. 模拟键盘事件 </div><div class="t m0 x0 h5 y2bb3 ff92 fs2 fc0 sc0 ls8 wseb">前面曾经提到过，“DOM2级事件”中没有就键盘事件作出规定，因此模拟键盘事件并没有现成的</div><div class="t m0 x0 h5 y2bb4 ff92 fs2 fc0 sc0 ls8 wseb">思路可循。“DOM2级事件”的草案中本来包含了键盘事件，但在定稿之前又被删除了；Firefox根据其</div><div class="t m0 x0 h5 y2bb5 ff92 fs2 fc0 sc0 ls8 wseb">草案实现了键盘事件。需要提请大家注意的是，“DOM3级事件”中的键盘事件与曾包含在“DOM2级</div><div class="t m0 x0 h5 y2bb6 ff92 fs2 fc0 sc0 ls8 wseb">事件”草案中的键盘事件有很大区别。 </div><div class="t m0 x0 h5 y2bb7 ff8b fs2 fc0 sc0 ls24a ws215">DOM3级规定，调用createEvent()并传入&quot;KeyboardEvent&quot;就可以创建一个键盘事件。返回的</div><div class="t m0 x0 hc y2bb8 ff92 fs2 fc0 sc0 ls8 wseb">事件对象会包含一个initKeyEvent()方法，这个方法接收下列参数。 </div><div class="t m0 x0 h5 y2bb9 ff91 fs1 fc0 sc0 ls2"> type（字符串）：表示要触发的事件类型，如&quot;keydown&quot;。 </div><div class="t m0 x0 h5 y2346 ff91 fs1 fc0 sc0 ls2"> bubbles（布尔值）：表示事件是否应该冒泡。为精确模拟鼠标事件，应该设置为true。 </div><div class="t m0 x0 h5 y2bba ff91 fs1 fc0 sc0 ls2"> cancelable（布尔值）：表示事件是否可以取消。为精确模拟鼠标事件，应该设置为true。 </div><div class="t m0 x0 h4 y2bbb ff91 fs1 fc0 sc0 ls8 ws134"> view（AbstractView）：与事件关联的视图。这个参数几乎总是要设置为document. </div><div class="t m0 x5 h21 y2bbc ff96 fs1 fc0 sc0 ls9 ws2">defaultView。 </div><div class="t m0 x0 h5 y2bbd ff91 fs1 fc0 sc0 ls2"> key（布尔值）：表示按下的键的键码。 </div><div class="t m0 x0 h5 y19cf ff91 fs1 fc0 sc0 ls2"> location（整数）：表示按下了哪里的键。0表示默认的主键盘，1表示左，2表示右，3表示</div><div class="t m0 x5 h5 y2bbe ff92 fs2 fc0 sc0 ls8 wseb">数字键盘，4表示移动设备（即虚拟键盘），5表示手柄。 </div><div class="t m0 x0 h5 y23c8 ff91 fs1 fc0 sc0 ls8 ws134"> modifiers（字符串）：空格分隔的修改键列表，如&quot;Shift&quot;。 </div><div class="t m0 x0 h5 y2bbf ff91 fs1 fc0 sc0 ls2"> repeat（整数）：在一行中按了这个键多少次。 </div><div class="t m0 x0 h5 yc03 ff92 fs2 fc0 sc0 ls8 wseb">由于DOM3级不提倡使用keypress事件，因此只能利用这种技术来模拟keydown和keyup事件。 </div><div class="t m0 x0 hb y12d8 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2bc0 ff96 fs6 fc0 sc0 ls21 wsb">var textbox = document.getElementById(&quot;myTextbox&quot;), </div><div class="t m0 x0 hb y2bc1 ff96 fs6 fc0 sc0 ls21 wsb">    event;  </div><div class="t m0 x0 hb y2bc2 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h36 y2bc3 ff96 fs6 fc0 sc0 ls21">//以DOM3级方式创建事件对象 </div><div class="t m0 x0 hb y2bc4 ff96 fs6 fc0 sc0 ls21 wsb">if (document.implementation.hasFeature(&quot;KeyboardEvents&quot;, &quot;3.0&quot;)){ </div><div class="t m0 x0 hb y2bc5 ff96 fs6 fc0 sc0 ls21 wsb">    event = document.createEvent(&quot;KeyboardEvent&quot;); </div><div class="t m0 x0 hb y2bc6 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2bc7 ff96 fs6 fc0 sc0 ls21 wsb">    //初始化事件对象 </div><div class="t m0 x0 hb y2bc8 ff96 fs6 fc0 sc0 ls21 wsb">    event.initKeyboardEvent(&quot;keydown&quot;, true, true, document.defaultView, &quot;a&quot;, </div></div></div>
<div id="pf1aa" class="pf w0 h0" data-page-no="1aa"><div class="pc pc1aa w0 h0"><div class="t m0 x0 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">408  第13章 事件 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 ff96 fs6 fc0 sc0 ls21 wsb">                            0, &quot;Shift&quot;, 0); </div><div class="t m0 x0 hb y7a ff96 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y7b ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y7c ff96 fs6 fc0 sc0 ls21">//触发事件 </div><div class="t m0 x0 hb y7d ff96 fs6 fc0 sc0 ls21 wsb">textbox.dispatchEvent(event); </div><div class="t m0 x0 h5 y2bca ff8b fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf y2bcb ff97 fs2 fc0 sc0 ls79 wsb">SimulateDOMKeyEventExample01.htm </div><div class="t m0 x0 h5 y2bcc ff92 fs2 fc0 sc0 ls389 ws2fe">这个例子模拟的是按住Shift的同时又按下 A键。在使用document.createEvent </div><div class="t m0 x0 h21 y2bcd ff96 fs1 fc0 sc0 ls9 ws2">(&quot;KeyboardEvent&quot;)之前，应该先检测浏览器是否支持DOM3级事件；其他浏览器返回一个非标准的</div><div class="t m0 x0 h5 y2bce ff96 fs1 fc0 sc0 ls9 ws2">KeyboardEvent对象。 </div><div class="t m0 x0 h5 y2bcf ff92 fs2 fc0 sc0 lse5">在Firefox中，调用createEvent()并传入&quot;KeyEvents&quot;就可以创建一个键盘事件。返回的事件</div><div class="t m0 x0 hc y2bd0 ff92 fs2 fc0 sc0 ls8 wseb">对象会包含一个initKeyEvent()方法，这个方法接受下列10个参数。 </div><div class="t m0 x0 h5 y2bd1 ff91 fs1 fc0 sc0 ls2"> type（字符串）：表示要触发的事件类型，如&quot;keydown&quot;。 </div><div class="t m0 x0 h5 y2bd2 ff91 fs1 fc0 sc0 ls2"> bubbles（布尔值）：表示事件是否应该冒泡。为精确模拟鼠标事件，应该设置为true。 </div><div class="t m0 x0 h5 y151f ff91 fs1 fc0 sc0 ls2"> cancelable（布尔值）：表示事件是否可以取消。为精确模拟鼠标事件，应该设置为true。 </div><div class="t m0 x0 h4 y2bd3 ff91 fs1 fc0 sc0 ls2"> view（AbstractView）：与事件关联的视图。这个参数几乎总是要设置为document.default- </div><div class="t m0 x0 h5 y2bd4 ff96 fs1 fc0 sc0 ls43 ws31">View。 </div><div class="t m0 x0 h5 y2bd5 ff91 fs1 fc0 sc0 ls2"> ctrlKey（布尔值）：表示是否按下了Ctrl键。默认值为false。 </div><div class="t m0 x0 h5 y2bd6 ff91 fs1 fc0 sc0 ls2"> altKey（布尔值）：表示是否按下了Alt键。默认值为false。 </div><div class="t m0 x0 h5 y2bd7 ff91 fs1 fc0 sc0 ls2"> shiftKey（布尔值）：表示是否按下了Shift键。默认值为false。 </div><div class="t m0 x0 h5 y2bd8 ff91 fs1 fc0 sc0 ls2"> metaKey（布尔值）：表示是否按下了Meta键。默认值为false。 </div><div class="t m0 x0 h4 y24dd ff91 fs1 fc0 sc0 ls2"> keyCode（整数）：被按下或释放的键的键码。这个参数对keydown和keyup事件有用，默认</div><div class="t m0 x0 hc y2bd9 ff92 fs2 fc0 sc0 ls8 wseb">值为0。 </div><div class="t m0 x0 h5 y2bda ff91 fs1 fc0 sc0 ls2"> charCode（整数）：通过按键生成的字符的ASCII编码。这个参数对keypress事件有用，默</div><div class="t m0 x0 h5 y1a78 ff92 fs2 fc0 sc0 ls8 wseb">认值为0。 </div><div class="t m0 x0 hc y2bdb ff92 fs2 fc0 sc0 ls8 wseb">将创建的event对象传入到dispatchEvent()方法就可以触发键盘事件，如下面的例子所示。 </div><div class="t m0 x0 hb y2bdc ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2bdd ff96 fs6 fc0 sc0 ls21">//只适用于Firefox </div><div class="t m0 x0 hb y2bde ff96 fs6 fc0 sc0 ls21 wsb">var textbox = document.getElementById(&quot;myTextbox&quot;) </div><div class="t m0 x0 hb y2bdf ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2be0 ff99 fs6 fc0 sc0 ls21 ws34">//创建事件对象 </div><div class="t m0 x0 h15 y2be1 ff99 fs6 fc0 sc0 ls21 wsb">var event = document.createEvent(&quot;KeyEvents&quot;); </div><div class="t m0 x0 hb y2be2 ff96 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 h16 y2be3 ff99 fs6 fc0 sc0 ls21 ws34">//初始化事件对象 </div><div class="t m0 x0 h15 y2be4 ff99 fs6 fc0 sc0 ls21 wsb">event.initKeyEvent(&quot;keypress&quot;, true, true, document.defaultView, false, false,  </div><div class="t m0 x0 h15 y2be5 ff99 fs6 fc0 sc0 ls21 wsb">                   false, false, 65, 65); </div><div class="t m0 x0 h28 y2be6 ff96 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2be7 ff96 fs6 fc0 sc0 ls21">//触发事件 </div><div class="t m0 x0 hb y2be8 ff96 fs6 fc0 sc0 ls21 wsb">textbox.dispatchEvent(event); </div><div class="t m0 x0 hb y2be9 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf y2bea ff97 fs2 fc0 sc0 ls96 wsb">SimulateFFKeyEventExample01.htm </div><div class="t m0 x0 h5 y1583 ff92 fs2 fc0 sc0 ls86">在Firefox中运行上面的代码，会在指定的文本框中输入字母A。同样，也可以依此模拟keyup和</div><div class="t m0 x0 h5 y34d ff96 fs1 fc0 sc0 ls9 ws2">keydown事件。 </div><div class="t m0 x0 h5 y15db ff92 fs2 fc0 sc0 ls24 wsf5">在其他浏览器中，则需要创建一个通用的事件，然后再向事件对象中添加键盘事件特有的信息。 </div><div class="t m0 x0 h5 y2b57 ff92 fs2 fc0 sc0 ls8">例如： </div></div></div>
<div id="pf1ab" class="pf w0 h0" data-page-no="1ab"><div class="pc pc1ab w0 h0"><div class="t m0 x2 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">13.6 模拟事件    409 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff8d fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff8d fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff8d fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff8d fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff8d fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff8d fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff8d fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff8d fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff8d fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff8d fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff8d fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff8d fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff8d fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x5 hb y518 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2beb ff96 fs6 fc0 sc0 ls21 wsb">var textbox = document.getElementById(&quot;myTextbox&quot;); </div><div class="t m0 x0 hb y2bec ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2bed ff99 fs6 fc0 sc0 ls21 ws34">//创建事件对象 </div><div class="t m0 x0 h15 y2bee ff99 fs6 fc0 sc0 ls21 wsb">var event = document.createEvent(&quot;Events&quot;); </div><div class="t m0 x0 h15 y2bef ff99 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2bf0 ff99 fs6 fc0 sc0 ls21 ws34">//初始化事件对象 </div><div class="t m0 x0 h15 y2bf1 ff99 fs6 fc0 sc0 ls21 wsb">event.initEvent(type, bubbles, cancelable); </div><div class="t m0 x0 h15 y2bf2 ff99 fs6 fc0 sc0 ls21 wsb">event.view = document.defaultView; </div><div class="t m0 x0 h15 y2bf3 ff99 fs6 fc0 sc0 ls21 wsb">event.altKey = false; </div><div class="t m0 x0 h15 y2bf4 ff99 fs6 fc0 sc0 ls21 wsb">event.ctrlKey = false; </div><div class="t m0 x0 h15 y2bf5 ff99 fs6 fc0 sc0 ls21 wsb">event.shiftKey = false; </div><div class="t m0 x0 h15 y2bf6 ff99 fs6 fc0 sc0 ls21 wsb">event.metaKey = false; </div><div class="t m0 x0 h15 y2bf7 ff99 fs6 fc0 sc0 ls21 wsb">event.keyCode = 65; </div><div class="t m0 x0 h15 y2bf8 ff99 fs6 fc0 sc0 ls21 wsb">event.charCode = 65; </div><div class="t m0 x0 hb y2bf9 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2bfa ff96 fs6 fc0 sc0 ls21">//触发事件 </div><div class="t m0 x0 hb y2bfb ff96 fs6 fc0 sc0 ls21 wsb">textbox.dispatchEvent(event); </div><div class="t m0 x5 hb y2bfc ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y6ee ff92 fs2 fc0 sc0 ls8 wseb">以上代码首先创建了一个通用事件，然后调用initEvent()对其进行初始化，最后又为其添加了</div><div class="t m0 x0 h5 y7b8 ff92 fs2 fc0 sc0 ls8 wseb">键盘事件的具体信息。在此必须要使用通用事件，而不能使用UI事件，因为UI 事件不允许向event</div><div class="t m0 x0 h5 y7b9 ff92 fs2 fc0 sc0 ls8 wseb">对象中再添加新属性（Safari除外）。像这样模拟事件虽然会触发键盘事件，但却不会向文本框中写入文</div><div class="t m0 x0 h5 y2bfd ff92 fs2 fc0 sc0 ls8 wseb">本，这是由于无法精确模拟键盘事件所造成的。 </div><div class="t m0 x0 h3c y2bfe ff90 fs2 fc0 sc0 ls2e wsb">3. 模拟其他事件 </div><div class="t m0 x0 h4 y2bff ff92 fs2 fc0 sc0 ls4 ws10d">虽然鼠标事件和键盘事件是在浏览器中最经常模拟的事件，但有时候同样需要模拟变动事件和</div><div class="t m0 x0 h5 y2c00 ff8b fs2 fc0 sc0 lsfa wsc9">HTML事件。要模拟变动事件，可以使用createEvent(&quot;MutationEvents&quot;)创建一个包含</div><div class="t m0 x0 h4 y5b0 ff96 fs1 fc0 sc0 ls9 ws2">initMutationEvent()方法的变动事件对象。这个方法接受的参数包括：type、bubbles、</div><div class="t m0 x0 h4 y1d09 ff96 fs1 fc0 sc0 ls9 ws2">cancelable、relatedNode、preValue、newValue、attrName和attrChange。下面来看一个模</div><div class="t m0 x0 h5 y26cb ff92 fs2 fc0 sc0 ls5f ws10b">拟变动事件的例子。 </div><div class="t m0 x5 hb y2c01 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2c02 ff96 fs6 fc0 sc0 ls21 wsb">var event = document.createEvent(&quot;MutationEvents&quot;); </div><div class="t m0 x0 hb y2c03 ff96 fs6 fc0 sc0 ls21 wsb">event.initMutationEvent(&quot;DOMNodeInserted&quot;, true, false, someNode, &quot;&quot;,&quot;&quot;,&quot;&quot;,0); </div><div class="t m0 x0 hb y2c04 ff96 fs6 fc0 sc0 ls21 wsb">target.dispatchEvent(event); </div><div class="t m0 x5 hb y2c05 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y2c06 ff92 fs2 fc0 sc0 ls8 wseb">以上代码模拟了DOMNodeInserted事件。其他变动事件也都可以照这个样子来模拟，只要改一改</div><div class="t m0 x0 h5 y2c07 ff92 fs2 fc0 sc0 ls8 wseb">参数就可以了。 </div><div class="t m0 x0 h5 y2c08 ff92 fs2 fc0 sc0 ls8 wseb">要模拟HTML事件，同样需要先创建一个event对象——通过createEvent(&quot;HTMLEvents&quot;)，</div><div class="t m0 x0 hc y230 ff92 fs2 fc0 sc0 ls8 wseb">然后再使用这个对象的initEvent()方法来初始化它即可，如下面的例子所示。 </div><div class="t m0 x5 hb y1a61 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2c09 ff96 fs6 fc0 sc0 ls21 wsb">var event = document.createEvent(&quot;HTMLEvents&quot;); </div><div class="t m0 x0 hb y2c0a ff96 fs6 fc0 sc0 ls21 wsb">event.initEvent(&quot;focus&quot;, true, false); </div><div class="t m0 x0 hb y2c0b ff96 fs6 fc0 sc0 ls21 wsb">target.dispatchEvent(event); </div><div class="t m0 x5 hb y2c0c ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y2c0d ff92 fs2 fc0 sc0 ls8 wseb">这个例子展示了如何在给定目标上模拟focus事件。模拟其他HTML事件的方法也是这样。 </div><div class="t m0 x5 h5 y2c0e ff8c fs2 fc0 sc0 ls8 ws14">浏览器中很少使用变动事件和HTML事件，因为使用它们会受到一些限制。 </div><div class="t m0 x0 h3c y2c0f ff90 fs2 fc0 sc0 ls2e wsb">4. 自定义DOM事件 </div><div class="t m0 x0 h5 y2c10 ff8b fs2 fc0 sc0 ls2e wsf4">DOM3级还定义了“自定义事件”。自定义事件不是由DOM原生触发的，它的目的是让开发人员</div><div class="t m0 x0 h4 y2c11 ff92 fs2 fc0 sc0 ls8 wseb">创建自己的事件。要创建新的自定义事件，可以调用createEvent(&quot;CustomEvent&quot;)。返回的对象有</div><div class="t m0 x0 h5 y2c12 ff92 fs2 fc0 sc0 ls8 wseb">一个名为initCustomEvent()的方法，接收如下4个参数。 </div></div></div>
<div id="pf1ac" class="pf w0 h0" data-page-no="1ac"><div class="pc pc1ac w0 h0"><div class="t m0 x0 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">410  第13章 事件 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff91 fs1 fc0 sc0 ls2"> type（字符串）：触发的事件类型，例如&quot;keydown&quot;。 </div><div class="t m0 x0 h5 y4 ff91 fs1 fc0 sc0 ls2"> bubbles（布尔值）：表示事件是否应该冒泡。 </div><div class="t m0 x0 h5 y4e ff91 fs1 fc0 sc0 ls2"> cancelable（布尔值）：表示事件是否可以取消。 </div><div class="t m0 x0 h5 yd9 ff91 fs1 fc0 sc0 ls2"> detail（对象）：任意值，保存在event对象的detail属性中。 </div><div class="t m0 x0 h5 y15d ff92 fs2 fc0 sc0 ls8 wseb">可以像分派其他事件一样在DOM中分派创建的自定义事件对象。例如： </div><div class="t m0 x0 hb y263 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y264 ff96 fs6 fc0 sc0 ls21 wsb">var div = document.getElementById(&quot;myDiv&quot;), </div><div class="t m0 x0 hb y265 ff96 fs6 fc0 sc0 ls21 wsb">    event;  </div><div class="t m0 x0 hb y266 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y267 ff96 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(div, &quot;myevent&quot;, function(event){ </div><div class="t m0 x0 hb y268 ff96 fs6 fc0 sc0 ls21 wsb">    alert(&quot;DIV: &quot; + event.detail); </div><div class="t m0 x0 hb y269 ff96 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 hb y10db ff96 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(document, &quot;myevent&quot;, function(event){ </div><div class="t m0 x0 hb y10dc ff96 fs6 fc0 sc0 ls21 wsb">    alert(&quot;DOCUMENT: &quot; + event.detail); </div><div class="t m0 x0 hb y10dd ff96 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 hb y10de ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y10df ff96 fs6 fc0 sc0 ls21 wsb">if (document.implementation.hasFeature(&quot;CustomEvents&quot;, &quot;3.0&quot;)){ </div><div class="t m0 x0 hb y2c14 ff96 fs6 fc0 sc0 ls21 wsb">    event = document.createEvent(&quot;CustomEvent&quot;); </div><div class="t m0 x0 hb y2c15 ff96 fs6 fc0 sc0 ls21 wsb">    event.initCustomEvent(&quot;myevent&quot;, true, false, &quot;Hello world!&quot;); </div><div class="t m0 x0 hb y2c16 ff96 fs6 fc0 sc0 ls21 wsb">    div.dispatchEvent(event); </div><div class="t m0 x0 hb y2c17 ff96 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x4 hf y2699 ff97 fs2 fc0 sc0 ls79 wsb">SimulateDOMCustomEventExample01.htm </div><div class="t m0 x0 h4 y8ab ff92 fs2 fc0 sc0 ls8 wseb">这个例子创建了一个冒泡事件&quot;myevent&quot;。而event.detail的值被设置成了一个简单的字符串，</div><div class="t m0 x0 h4 y2c18 ff92 fs2 fc0 sc0 ls8 wseb">然后在&lt;div&gt;元素和document上侦听这个事件。因为initCustomEvent()方法已经指定这个事件应</div><div class="t m0 x0 hc y2c19 ff92 fs2 fc0 sc0 ls8 wseb">该冒泡，所以浏览器会负责将事件向上冒泡到document。 </div><div class="t m0 x0 h5 y2c1a ff92 fs2 fc0 sc0 ls8 wseb">支持自定义DOM事件的浏览器有IE9+和Firefox 6+。 </div><div class="t m0 x0 h20 y15a2 ff90 fs3 fc0 sc0 ls248 ws214">13.6.2 IE中的事件模拟 </div><div class="t m0 x0 h5 y2c1b ff92 fs2 fc0 sc0 ls3b">在IE8及之前版本中模拟事件与在DOM中模拟事件的思路相似：先创建event对象，然后为其指</div><div class="t m0 x0 h5 y2c1c ff92 fs2 fc0 sc0 ls8 wseb">定相应的信息，然后再使用该对象来触发事件。当然，IE在实现每个步骤时都采用了不一样的方式。 </div><div class="t m0 x0 he y2c1d ff92 fs2 fc0 sc0 ls8 wseb">调用document.createEventObject()方法可以在IE中创建event 对象。但与DOM方式不同</div><div class="t m0 x0 h4 y2c1e ff92 fs2 fc0 sc0 ls8 wseb">的是，这个方法不接受参数，结果会返回一个通用的event对象。然后，你必须手工为这个对象添加</div><div class="t m0 x0 h1e y2c1f ff92 fs2 fc0 sc0 ls8 wseb">所有必要的信息（没有方法来辅助完成这一步骤）。最后一步就是在目标上调用fireEvent()方法，这</div><div class="t m0 x0 h1e y2c20 ff92 fs2 fc0 sc0 ls6 wsf7">个方法接受两个参数：事件处理程序的名称和event对象。在调用 fireEvent()方法时，会自动为</div><div class="t m0 x0 h4 y2232 ff96 fs1 fc0 sc0 ls9 ws2">event对象添加srcElement和type属性；其他属性则都是必须通过手工添加的。换句话说，模拟任</div><div class="t m0 x0 h5 y2c21 ff92 fs2 fc0 sc0 ls137">何IE支持的事件都采用相同的模式。例如，下面的代码模拟了在一个按钮上触发click事件过程。 </div><div class="t m0 x0 hb y2a5e ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2c22 ff96 fs6 fc0 sc0 ls21 wsb">var btn = document.getElementById(&quot;myBtn&quot;); </div><div class="t m0 x0 hb y2c23 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2c24 ff96 fs6 fc0 sc0 ls21">//创建事件对象 </div><div class="t m0 x0 hb y2c25 ff96 fs6 fc0 sc0 ls21 wsb">var event = document.createEventObject(); </div><div class="t m0 x0 hb y2c26 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2c27 ff96 fs6 fc0 sc0 ls21">//初始化事件对象 </div><div class="t m0 x0 hb y2c28 ff96 fs6 fc0 sc0 ls21 wsb">event.screenX = 100; </div><div class="t m0 x0 hb y2c29 ff96 fs6 fc0 sc0 ls21 wsb">event.screenY = 0; </div><div class="t m0 x0 hb y2c2a ff96 fs6 fc0 sc0 ls21 wsb">event.clientX = 0; </div><div class="t m0 x0 hb y2c2b ff96 fs6 fc0 sc0 ls21 wsb">event.clientY = 0; </div><div class="t m0 x0 hb y2c2c ff96 fs6 fc0 sc0 ls21 wsb">event.ctrlKey = false; </div><div class="t m0 x0 hb y2c2d ff96 fs6 fc0 sc0 ls21 wsb">event.altKey = false; </div></div></div>
<div id="pf1ad" class="pf w0 h0" data-page-no="1ad"><div class="pc pc1ad w0 h0"><div class="t m0 x2 h2 y1 ff8b fs0 fc0 sc0 ls7 ws0">13.7 小结  411 </div><div class="t m0 x0 h3 y2 ff8b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff8d fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff8d fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff8d fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff8d fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff8d fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff8d fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff8d fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff8d fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff8d fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff8d fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff8d fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff8d fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff8d fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y2c2e ff96 fs6 fc0 sc0 ls21 wsb">event.shiftKey = false; </div><div class="t m0 x0 hb y2c2f ff96 fs6 fc0 sc0 ls21 wsb">event.button = 0; </div><div class="t m0 x0 hb y2c30 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2c31 ff96 fs6 fc0 sc0 ls21">//触发事件 </div><div class="t m0 x0 hb y2c32 ff96 fs6 fc0 sc0 ls21 wsb">btn.fireEvent(&quot;onclick&quot;, event); </div><div class="t m0 x5 hb y2c33 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y2731 ff97 fs2 fc0 sc0 ls2b wsb">SimulateIEClickExample01.htm </div><div class="t m0 x0 h4 y2c34 ff92 fs2 fc0 sc0 ls8 wseb">这个例子先创建了一个event对象，然后又用一些信息对其进行了初始化。注意，这里可以为对</div><div class="t m0 x0 h5 y2c35 ff92 fs2 fc0 sc0 ls8 wseb">象随意添加属性，不会有任何限制——即使添加的属性IE8及更早版本并不支持也无所谓。在此添加的</div><div class="t m0 x0 h5 y2c36 ff92 fs2 fc0 sc0 ls8 wseb">属性对事件没有什么影响，因为只有事件处理程序才会用到它们。 </div><div class="t m0 x0 he y2c37 ff92 fs2 fc0 sc0 ls8 wseb">采用相同的模式也可以模拟触发keypress事件，如下面的例子所示。 </div><div class="t m0 x5 hb y2c38 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2c39 ff96 fs6 fc0 sc0 ls21 wsb">var textbox = document.getElementById(&quot;myTextbox&quot;); </div><div class="t m0 x0 h28 y2c3a ff96 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2c3b ff96 fs6 fc0 sc0 ls21">//创建事件对象 </div><div class="t m0 x0 hb y2c3c ff96 fs6 fc0 sc0 ls21 wsb">var event = document.createEventObject(); </div><div class="t m0 x0 hb y2c3d ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2c3e ff96 fs6 fc0 sc0 ls21">//初始化事件对象 </div><div class="t m0 x0 hb y2c3f ff96 fs6 fc0 sc0 ls21 wsb">event.altKey = false; </div><div class="t m0 x0 hb y2c40 ff96 fs6 fc0 sc0 ls21 wsb">event.ctrlKey = false; </div><div class="t m0 x0 hb y2c41 ff96 fs6 fc0 sc0 ls21 wsb">event.shiftKey = false; </div><div class="t m0 x0 hb y2c42 ff96 fs6 fc0 sc0 ls21 wsb">event.keyCode = 65; </div><div class="t m0 x0 hb y2c43 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2c44 ff96 fs6 fc0 sc0 ls21">//触发事件 </div><div class="t m0 x0 hb y2c45 ff96 fs6 fc0 sc0 ls21 wsb">textbox.fireEvent(&quot;onkeypress&quot;, event); </div><div class="t m0 x5 hb y2c46 ff96 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y2c47 ff97 fs2 fc0 sc0 ls96 wsb">SimulateIEKeyEventExample01.htm </div><div class="t m0 x0 h4 y2c48 ff92 fs2 fc0 sc0 ls8 wseb">由于鼠标事件、键盘事件以及其他事件的event对象并没有什么不同，所以可以使用通用对象来</div><div class="t m0 x0 h5 y2c49 ff92 fs2 fc0 sc0 ls8 wseb">触发任何类型的事件。不过，正如在DOM中模拟键盘事件一样，运行这个例子也不会因模拟了keypress</div><div class="t m0 x0 h5 y2c4a ff92 fs2 fc0 sc0 ls8 wseb">而在文本框中看到任何字符，即使触发了事件处理程序也没有用。 </div><div class="t m0 x0 hd y2c4b ff90 fs7 fc0 sc0 ls245">13.7 小结 </div><div class="t m0 x0 h5 y2c4c ff92 fs2 fc0 sc0 ls8 wseb">事件是将JavaScript与网页联系在一起的主要方式。“DOM3级事件”规范和HTML5定义了常见的</div><div class="t m0 x0 h4 y85d ff92 fs2 fc0 sc0 ls8 wseb">大多数事件。即使有规范定义了基本事件，但很多浏览器仍然在规范之外实现了自己的专有事件，从而</div><div class="t m0 x0 h5 y1ee9 ff92 fs2 fc0 sc0 ls4c wsfa">为开发人员提供更多掌握用户交互的手段。有些专有事件与特定设备关联，例如移动Safari中的</div><div class="t m0 x0 h5 y227e ff96 fs1 fc0 sc0 ls9 ws2">orientationchange事件就是特定关联iOS设备的。 </div><div class="t m0 x0 h5 y227f ff92 fs2 fc0 sc0 ls8 wseb">在使用事件时，需要考虑如下一些内存与性能方面的问题。 </div><div class="t m0 x0 h4 y1eeb ff91 fs1 fc0 sc0 ls2"> 有必要限制一个页面中事件处理程序的数量，数量太多会导致占用大量内存，而且也会让用户</div><div class="t m0 x5 h5 y2c4d ff92 fs2 fc0 sc0 ls8 wseb">感觉页面反应不够灵敏。 </div><div class="t m0 x0 h5 y234 ff91 fs1 fc0 sc0 ls2"> 建立在事件冒泡机制之上的事件委托技术，可以有效地减少事件处理程序的数量。 </div><div class="t m0 x0 h5 y2c4e ff91 fs1 fc0 sc0 ls2"> 建议在浏览器卸载页面之前移除页面中的所有事件处理程序。 </div><div class="t m0 x0 h5 y2c4f ff92 fs2 fc0 sc0 ls8 wseb">可以使用JavaScript在浏览器中模拟事件。“DOM2级事件”和“DOM3级事件”规范规定了模拟事</div><div class="t m0 x0 h4 ya7e ff92 fs2 fc0 sc0 ls1f ws108">件的方法，为模拟各种有定义的事件提供了方便。此外，通过组合使用一些技术，还可以在某种程度上</div><div class="t m0 x0 h5 y2c50 ff92 fs2 fc0 sc0 ls1f">模拟键盘事件。IE8及之前版本同样支持事件模拟，只不过模拟的过程有些差异。 </div><div class="t m0 x0 h5 y2c51 ff92 fs2 fc0 sc0 ls1f ws108">事件是JavaScript中最重要的主题之一，深入理解事件的工作机制以及它们对性能的影响至关重要。 </div></div></div>
<div id="pf1ae" class="pf w0 h0" data-page-no="1ae"><div class="pc pc1ae w0 h0"><div class="t m0 x0 h2 y1 ff9d fs0 fc0 sc0 ls7 ws0">412  第14章 表单脚本 </div><div class="t m0 x0 h3 y2 ff9d fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h9 y2a ff9f fs5 fc0 sc0 ls12 wsb">表 单 脚 本 </div><div class="t m0 x0 h3c y2b ffa0 fs2 fc0 sc0 ls8">本章内容 </div><div class="t m0 x0 h5 y2c ffa2 fs1 fc0 sc0 ls2"> 理解表单 </div><div class="t m0 x0 h5 y2d ffa2 fs1 fc0 sc0 ls2"> 文本框验证与交互 </div><div class="t m0 x0 h5 y2e ffa2 fs1 fc0 sc0 ls2"> 使用其他表单控制 </div><div class="t m0 x0 h5 y8d9 ff9d fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y8da ff9d fs2 fc0 sc0 ls1b ws6e">avaScript最初的一个应用，就是分担服务器处理表单的责任，打破处处依赖服务器的局面。尽</div><div class="t m0 x0 h5 y8db ffa3 fs2 fc0 sc0 ls8 ws1">管目前的Web和JavaScript已经有了长足的发展，但Web表单的变化并不明显。由于 Web表单</div><div class="t m0 x0 h5 y8dc ffa3 fs2 fc0 sc0 ls6 ws6">没有为许多常见任务提供现成的解决手段，很多开发人员不仅会在验证表单时使用JavaScirpt，而且还</div><div class="t m0 x0 h5 y8dd ffa3 fs2 fc0 sc0 ls8 ws1">增强了一些标准表单控件的默认行为。 </div><div class="t m0 x0 hd y13e1 ffa1 fs7 fc0 sc0 ls245">14.1 表单的基础知识 </div><div class="t m0 x0 h5 y2c52 ffa3 fs2 fc0 sc0 ls38e">在HTML中，表单是由&lt;form&gt;元素来表示的，而在JavaScript中， 表单对应的则是HTMLForm- </div><div class="t m0 x0 h21 y2c53 ffa4 fs1 fc0 sc0 ls9 ws2">Element类型。HTMLFormElement继承了HTMLElement，因而与其他HTML元素具有相同的默认属</div><div class="t m0 x0 hc y2c54 ffa3 fs2 fc0 sc0 ls8 ws1">性。不过，HTMLFormElement也有它自己下列独有的属性和方法。 </div><div class="t m0 x0 h5 y10ca ffa2 fs1 fc0 sc0 ls2"> acceptCharset：服务器能够处理的字符集；等价于HTML中的accept-charset特性。 </div><div class="t m0 x0 h5 y10cb ffa2 fs1 fc0 sc0 ls2"> action：接受请求的URL；等价于HTML中的action特性。 </div><div class="t m0 x0 h5 y8e4 ffa2 fs1 fc0 sc0 ls2"> elements：表单中所有控件的集合（HTMLCollection）。 </div><div class="t m0 x0 h5 y10cd ffa2 fs1 fc0 sc0 ls2"> enctype：请求的编码类型；等价于HTML中的enctype特性。 </div><div class="t m0 x0 h5 y28e8 ffa2 fs1 fc0 sc0 ls2"> length：表单中控件的数量。 </div><div class="t m0 x0 h5 y2c55 ffa2 fs1 fc0 sc0 ls2"> method：要发送的HTTP请求类型，通常是&quot;get&quot;或&quot;post&quot;；等价于HTML的method特性。 </div><div class="t m0 x0 h5 y2c56 ffa2 fs1 fc0 sc0 ls2"> name：表单的名称；等价于HTML的name特性。 </div><div class="t m0 x0 h5 y2101 ffa2 fs1 fc0 sc0 ls2"> reset()：将所有表单域重置为默认值。 </div><div class="t m0 x0 h5 y1a7f ffa2 fs1 fc0 sc0 ls2"> submit()：提交表单。 </div><div class="t m0 x0 h5 y1d60 ffa2 fs1 fc0 sc0 ls2"> target：用于发送请求和接收响应的窗口名称；等价于HTML的target特性。 </div><div class="t m0 x0 h1e y1d61 ffa3 fs2 fc0 sc0 ls6 ws6">取得&lt;form&gt;元素引用的方式有好几种。其中最常见的方式就是将它看成与其他元素一样，并为其</div><div class="t m0 x0 hc y2c57 ffa3 fs2 fc0 sc0 ls8 ws1">添加id特性，然后再像下面这样使用getElementById()方法找到它。 </div><div class="t m0 x0 hb y2c58 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2c59 ffa4 fs6 fc0 sc0 ls21 wsb">var form = document.getElementById(&quot;form1&quot;); </div><div class="t m0 x0 hb y2c5a ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y2c5b ffa3 fs2 fc0 sc0 ls8 ws1">其次，通过document.forms可以取得页面中所有的表单。在这个集合中，可以通过数值索引或</div><div class="t m0 x0 h5 y2c5c ff9d fs2 fc0 sc0 ls8 ws20">name值来取得特定的表单，如下面的例子所示。 </div><div class="t m0 x0 hb yc52 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hf0 y103f ffa5 fs14 fc0 sc0 ls392 wsb">J </div><div class="t m0 x0 h11 y4b ffa6 fsa fc0 sc0 ls8">第</div><div class="t m1 x0 h12 y4b ffa7 fsb fc3 sc0 ls247">14</div><div class="t m0 x5 h11 y4b ffa6 fsa fc0 sc0 ls8 ws1d">章 </div></div></div>
<div id="pf1af" class="pf w0 h0" data-page-no="1af"><div class="pc pc1af w0 h0"><div class="t m0 x2 h2 y1 ff9d fs0 fc0 sc0 ls7 ws0">14.1 表单的基础知识    413 </div><div class="t m0 x0 h3 y2 ff9d fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffa8 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ffa8 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffa8 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffa8 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffa8 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffa8 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffa8 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffa8 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffa8 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffa8 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffa8 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffa8 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ffa8 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h16 y79 ffa4 fs6 fc0 sc0 ls21 wsb">var firstForm = document.forms[0];        //取得页面中的第一个表单 </div><div class="t m0 x0 h16 y7a ffa4 fs6 fc0 sc0 ls21 wsb">var myForm = document.forms[&quot;form2&quot;];     //取得页面中名称为&quot;form2&quot;的表单 </div><div class="t m0 x5 hb y1c6a ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1c6b ffa3 fs2 fc0 sc0 ls8 ws1">另外，在较早的浏览器或者那些支持向后兼容的浏览器中，也会把每个设置了name特性的表单作</div><div class="t m0 x0 h1e y1e20 ffa3 fs2 fc0 sc0 ls8 ws1">为属性保存在document对象中。例如，通过document.form2可以访问到名为 &quot;form2&quot;的表单。不</div><div class="t m0 x0 h5 y1c6c ffa3 fs2 fc0 sc0 ls8 ws1">过，我们不推荐使用这种方式：一是容易出错，二是将来的浏览器可能会不支持。 </div><div class="t m0 x0 he y2c5d ffa3 fs2 fc0 sc0 ls8 ws1">注意，可以同时为表单指定id和name属性，但它们的值不一定相同。 </div><div class="t m0 x0 h20 y2c5e ffa1 fs3 fc0 sc0 ls248 ws214">14.1.1 提交表单 </div><div class="t m0 x0 h4 y921 ffa3 fs2 fc0 sc0 ls8 ws1">用户单击提交按钮或图像按钮时，就会提交表单。使用&lt;input&gt;或&lt;button&gt;都可以定义提交按钮，</div><div class="t m0 x0 h4 y1a23 ffa3 fs2 fc0 sc0 ls8 ws1">只要将其type特性的值设置为&quot;submit&quot;即可，而图像按钮则是通过将&lt;input&gt;的type特性值设置为</div><div class="t m0 x0 h5 y2c5f ffa4 fs1 fc0 sc0 ls9 ws2">&quot;image&quot;来定义的。因此，只要我们单击以下代码生成的按钮，就可以提交表单。 </div><div class="t m0 x5 hb y2c60 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2c61 ffa4 fs6 fc0 sc0 ls21 wsb">&lt;!-- 通用提交按钮 --&gt; </div><div class="t m0 x0 hb y2c62 ffa4 fs6 fc0 sc0 ls21 wsb">&lt;input type=&quot;submit&quot; value=&quot;Submit Form&quot;&gt; </div><div class="t m0 x0 hb y2c63 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2c64 ffa4 fs6 fc0 sc0 ls21 wsb">&lt;!-- 自定义提交按钮 --&gt; </div><div class="t m0 x0 hb y2c65 ffa4 fs6 fc0 sc0 ls21 wsb">&lt;button type=&quot;submit&quot;&gt;Submit Form&lt;/button&gt; </div><div class="t m0 x0 hb y2c66 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2c67 ffa4 fs6 fc0 sc0 ls21 wsb">&lt;!-- 图像按钮 --&gt; </div><div class="t m0 x0 hb y2c68 ffa4 fs6 fc0 sc0 ls21 wsb">&lt;input type=&quot;image&quot; src=&quot;graphic.gif&quot;&gt; </div><div class="t m0 x5 hb y2c69 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y2c6a ffa3 fs2 fc0 sc0 ls8 ws1">只要表单中存在上面列出的任何一种按钮，那么在相应表单控件拥有焦点的情况下，按回车键就可</div><div class="t m0 x0 h1e y2c6b ffa3 fs2 fc0 sc0 ls8 ws1">以提交该表单。（textarea是一个例外，在文本区中回车会换行。）如果表单里没有提交按钮，按回车</div><div class="t m0 x0 h5 y2c6c ffa3 fs2 fc0 sc0 ls8 ws1">键不会提交表单。 </div><div class="t m0 x0 h1e y2c6d ffa3 fs2 fc0 sc0 ls8 ws1">以这种方式提交表单时，浏览器会在将请求发送给服务器之前触发submit事件。这样，我们就有</div><div class="t m0 x0 h4 y2c6e ffa3 fs2 fc0 sc0 ls8 ws1">机会验证表单数据，并据以决定是否允许表单提交。阻止这个事件的默认行为就可以取消表单提交。例</div><div class="t m0 x0 h5 y2c6f ffa3 fs2 fc0 sc0 ls8 ws1">如，下列代码会阻止表单提交。 </div><div class="t m0 x5 hb y2c70 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2c71 ffa4 fs6 fc0 sc0 ls21 wsb">var form = document.getElementById(&quot;myForm&quot;); </div><div class="t m0 x0 hb y2c72 ffa4 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(form, &quot;submit&quot;, function(event){ </div><div class="t m0 x0 hb y2c73 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2c74 ffa4 fs6 fc0 sc0 ls21 wsb">    //取得事件对象 </div><div class="t m0 x0 hb y2c75 ffa4 fs6 fc0 sc0 ls21 wsb">    event = EventUtil.getEvent(event); </div><div class="t m0 x0 hb y2c76 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2c77 ffa4 fs6 fc0 sc0 ls21 wsb">    //阻止默认事件 </div><div class="t m0 x0 hb y2c78 ffa4 fs6 fc0 sc0 ls21 wsb">    EventUtil.preventDefault(event); </div><div class="t m0 x0 hb y2c79 ffa4 fs6 fc0 sc0 ls21 wsb">});  </div><div class="t m0 x0 h5 y1cb0 ffa3 fs2 fc0 sc0 ls8 ws1">这里使用了第13章定义的EventUtil对象，以便跨浏览器处理事件。调用 prevetnDefault()</div><div class="t m0 x0 h5 y12d7 ffa3 fs2 fc0 sc0 ls8 ws1">方法阻止了表单提交。一般来说，在表单数据无效而不能发送给服务器时，可以使用这一技术。 </div><div class="t m0 x0 h5 y12d8 ffa3 fs2 fc0 sc0 ls21f">在JavaScript中，以编程方式调用submit()方法也可以提交表单。而且，这种方式无需表单包含</div><div class="t m0 x0 h5 y12d9 ffa3 fs2 fc0 sc0 ls8 ws1">提交按钮，任何时候都可以正常提交表单。来看一个例子。 </div><div class="t m0 x5 hb y12da ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y12db ffa4 fs6 fc0 sc0 ls21 wsb">var form = document.getElementById(&quot;myForm&quot;); </div><div class="t m0 x0 hb y2c7a ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2c7b ffaa fs6 fc0 sc0 ls21 ws34">//提交表单 </div><div class="t m0 x0 h15 y2c7c ffaa fs6 fc0 sc0 ls21 wsb">form.submit(); </div><div class="t m0 x5 hb y2c7d ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y2c7e ffa3 fs2 fc0 sc0 ls8 ws1">在以调用submit()方法的形式提交表单时，不会触发submit事件，因此要记得在调用此方法之</div><div class="t m0 x0 h5 y2c7f ffa3 fs2 fc0 sc0 ls8 ws1">前先验证表单数据。 </div></div></div>
<div id="pf1b0" class="pf w0 h0" data-page-no="1b0"><div class="pc pc1b0 w0 h0"><div class="t m0 x0 h2 y1 ff9d fs0 fc0 sc0 ls7 ws0">414  第14章 表单脚本 </div><div class="t m0 x0 h3 y2 ff9d fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ffa3 fs2 fc0 sc0 ls24 ws1e">提交表单时可能出现的最大问题，就是重复提交表单。在第一次提交表单后，如果长时间没有反</div><div class="t m0 x0 h4 y4d ffa3 fs2 fc0 sc0 ls24">应，用户可能会变得不耐烦。这时候，他们也许会反复单击提交按钮。结果往往很麻烦（因为服务器</div><div class="t m0 x0 h4 yd8 ffa3 fs2 fc0 sc0 ls24 ws1e">要处理重复的请求），或者会造成错误（如果用户是下订单，那么可能会多订好几份）。解决这一问题</div><div class="t m0 x0 h1c y28b ffa3 fs2 fc0 sc0 ls5 ws4">的办法有两个：在第一次提交表单后就禁用提交按钮，或者利用onsubmit事件处理程序取消后续的</div><div class="t m0 x0 h5 y15d ffa3 fs2 fc0 sc0 ls5">表单提交操作。 </div><div class="t m0 x0 h20 y2c81 ffa1 fs3 fc0 sc0 ls248 ws214">14.1.2 重置表单 </div><div class="t m0 x0 h4 y153e ffa3 fs2 fc0 sc0 ls8 ws1">在用户单击重置按钮时，表单会被重置。使用type特性值为&quot;reset&quot;的&lt;input&gt;或&lt;button&gt;都</div><div class="t m0 x0 h5 y2c82 ffa3 fs2 fc0 sc0 ls8 ws1">可以创建重置按钮，如下面的例子所示。 </div><div class="t m0 x0 hb y2713 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2c83 ffa4 fs6 fc0 sc0 ls21 wsb">&lt;!-- 通用重置按钮 --&gt; </div><div class="t m0 x0 hb y2c84 ffa4 fs6 fc0 sc0 ls21 wsb">&lt;input type=&quot;reset&quot; value=&quot;Reset Form&quot;&gt; </div><div class="t m0 x0 hb y2c85 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2c86 ffa4 fs6 fc0 sc0 ls21 wsb">&lt;!-- 自定义重置按钮 --&gt; </div><div class="t m0 x0 hb y2c87 ffa4 fs6 fc0 sc0 ls21 wsb">&lt;button type=&quot;reset&quot;&gt;Reset Form&lt;/button&gt; </div><div class="t m0 x0 hb y2c88 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1a27 ffa3 fs2 fc0 sc0 ls8 ws1">这两个按钮都可以用来重置表单。在重置表单时，所有表单字段都会恢复到页面刚加载完毕时的初</div><div class="t m0 x0 h5 y1a28 ffa3 fs2 fc0 sc0 ls8 ws1">始值。如果某个字段的初始值为空，就会恢复为空；而带有默认值的字段，也会恢复为默认值。 </div><div class="t m0 x0 h1e ya90 ffa3 fs2 fc0 sc0 ls8 ws1">用户单击重置按钮重置表单时，会触发reset事件。利用这个机会，我们可以在必要时取消重置</div><div class="t m0 x0 h5 y2c89 ffa3 fs2 fc0 sc0 ls8 ws1">操作。例如，下面展示了阻止重置表单的代码。 </div><div class="t m0 x0 hb y2c8a ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2c8b ffa4 fs6 fc0 sc0 ls21 wsb">var form = document.getElementById(&quot;myForm&quot;); </div><div class="t m0 x0 hb y2c8c ffa4 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(form, &quot;reset&quot;, function(event){ </div><div class="t m0 x0 hb y2c8d ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2c8e ffa4 fs6 fc0 sc0 ls21 wsb">    //取得事件对象 </div><div class="t m0 x0 hb y2c8f ffa4 fs6 fc0 sc0 ls21 wsb">    event = EventUtil.getEvent(event); </div><div class="t m0 x0 hb y2c90 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2c91 ffa4 fs6 fc0 sc0 ls21 wsb">    //阻止表单重置 </div><div class="t m0 x0 hb y2c92 ffa4 fs6 fc0 sc0 ls21 wsb">    EventUtil.preventDefault(event); </div><div class="t m0 x0 hb y2c93 ffa4 fs6 fc0 sc0 ls21 wsb">});  </div><div class="t m0 x0 h5 y2c94 ffa3 fs2 fc0 sc0 ls8 ws1">与提交表单一样，也可以通过JavaScript来重置表单，如下面的例子所示。 </div><div class="t m0 x0 hb y1f8e ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1f8f ffa4 fs6 fc0 sc0 ls21 wsb">var form = document.getElementById(&quot;myForm&quot;); </div><div class="t m0 x0 hb y2c95 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1f91 ffaa fs6 fc0 sc0 ls21 ws34">//重置表单 </div><div class="t m0 x0 h15 y1f92 ffaa fs6 fc0 sc0 ls21 wsb">form.reset(); </div><div class="t m0 x0 h15 y2c96 ffaa fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y28e9 ffa3 fs2 fc0 sc0 ls8 ws1">与调用submit()方法不同，调用reset()方法会像单击重置按钮一样触发reset事件。 </div><div class="t m0 x5 h5 y2c97 ff9e fs2 fc0 sc0 ls1d9">在Web表单设计中，重置表单通常意味着对已经填写的数据不满意。重置表单</div><div class="t m0 x0 ha y2c98 ff9e fs2 fc0 sc0 ls8 ws14">经常会导致用户摸不着头脑，如果意外地触发了表单重置事件，那么用户甚至会很恼</div><div class="t m0 x0 ha y2c99 ff9e fs2 fc0 sc0 ls8 ws14">火。事实上，重置表单的需求是很少见的。更常见的做法是提供一个取消按钮，让用</div><div class="t m0 x0 h5 y2c9a ff9e fs2 fc0 sc0 ls8 ws14">户能够回到前一个页面，而不是不分青红皂白地重置表单中的所有值。 </div><div class="t m0 x0 h20 y2c9b ffa1 fs3 fc0 sc0 ls248 ws214">14.1.3 表单字段 </div><div class="t m0 x0 h5 y2c9c ffa3 fs2 fc0 sc0 ls4 ws3">可以像访问页面中的其他元素一样，使用原生DOM方法访问表单元素。此外，每个表单都有</div></div></div>
<div id="pf1b1" class="pf w0 h0" data-page-no="1b1"><div class="pc pc1b1 w0 h0"><div class="t m0 x2 h2 y1 ff9d fs0 fc0 sc0 ls7 ws0">14.1 表单的基础知识    415 </div><div class="t m0 x0 h3 y2 ff9d fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffa8 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ffa8 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffa8 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffa8 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffa8 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffa8 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffa8 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffa8 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffa8 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffa8 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffa8 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffa8 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ffa8 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h4 y3 ffa4 fs1 fc0 sc0 ls9 ws2">elements属性，该属性是表单中所有表单元素（字段）的集合。这个elements集合是一个有序列表，</div><div class="t m0 x0 h1e y4d ffa3 fs2 fc0 sc0 ls8 ws1">其中包含着表单中的所有字段，例如&lt;input&gt;、&lt;textarea&gt;、&lt;button&gt;和&lt;fieldset&gt;。每个表单字</div><div class="t m0 x0 h1e y5 ffa3 fs2 fc0 sc0 ls8 ws1">段在elements集合中的顺序，与它们出现在标记中的顺序相同，可以按照位置和name特性来访问它</div><div class="t m0 x0 h5 yd9 ffa3 fs2 fc0 sc0 ls8 ws1">们。下面来看一个例子。 </div><div class="t m0 x5 hb ya81 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ya82 ffa4 fs6 fc0 sc0 ls21 wsb">var form = document.getElementById(&quot;form1&quot;); </div><div class="t m0 x0 hb y2c9d ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2c9e ffa4 fs6 fc0 sc0 ls21">//取得表单中的第一个字段 </div><div class="t m0 x0 hb y2c9f ffa4 fs6 fc0 sc0 ls21 wsb">var field1 = form.elements[0]; </div><div class="t m0 x0 hb y2ca0 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2ca1 ffa4 fs6 fc0 sc0 ls21">//取得名为&quot;textbox1&quot;的字段 </div><div class="t m0 x0 hb y2ca2 ffa4 fs6 fc0 sc0 ls21 wsb">var field2 = form.elements[&quot;textbox1&quot;]; </div><div class="t m0 x0 hb y2ca3 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2ca4 ffa4 fs6 fc0 sc0 ls21">//取得表单中包含的字段的数量 </div><div class="t m0 x0 hb y2ca5 ffa4 fs6 fc0 sc0 ls21 wsb">var fieldCount = form.elements.length; </div><div class="t m0 x0 h4 y139 ffa3 fs2 fc0 sc0 lsa ws53">如果有多个表单控件都在使用一个name（如单选按钮），那么就会返回以该name命名的一个</div><div class="t m0 x0 h5 y2ca6 ffa4 fs1 fc0 sc0 ls9 ws2">NodeList。例如，以下面的HTML代码片段为例。 </div><div class="t m0 x5 hb y2ca7 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2ca8 ffa4 fs6 fc0 sc0 ls21 wsb">&lt;form method=&quot;post&quot; id=&quot;myForm&quot;&gt; </div><div class="t m0 x0 hb y2ca9 ffa4 fs6 fc0 sc0 ls21 wsb">    &lt;ul&gt; </div><div class="t m0 x0 hb y2caa ffa4 fs6 fc0 sc0 ls21 wsb">        &lt;li&gt;&lt;input type=&quot;radio&quot; name=&quot;color&quot; value=&quot;red&quot;&gt;Red&lt;/li&gt; </div><div class="t m0 x0 hb y2cab ffa4 fs6 fc0 sc0 ls21 wsb">        &lt;li&gt;&lt;input type=&quot;radio&quot; name=&quot;color&quot; value=&quot;green&quot;&gt;Green&lt;/li&gt; </div><div class="t m0 x0 hb y2cac ffa4 fs6 fc0 sc0 ls21 wsb">        &lt;li&gt;&lt;input type=&quot;radio&quot; name=&quot;color&quot; value=&quot;blue&quot;&gt;Blue&lt;/li&gt; </div><div class="t m0 x0 hb y2cad ffa4 fs6 fc0 sc0 ls21 wsb">    &lt;/ul&gt; </div><div class="t m0 x0 hb y2cae ffa4 fs6 fc0 sc0 ls21 wsb">&lt;/form&gt; </div><div class="t m0 x5 hb y2caf ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y2cb0 ffab fs2 fc0 sc0 ls79 wsb">FormFieldsExample01.htm </div><div class="t m0 x0 h5 y20bc ffa3 fs2 fc0 sc0 ls8 ws1">在这个HTML表单中，有3个单选按钮，它们的name都是&quot;color&quot;，意味着 这3个字段是一起的。</div><div class="t m0 x0 hc y2cb1 ffa3 fs2 fc0 sc0 ls6 ws6">在访问elements[&quot;color&quot;]时，就会返回一个NodeList，其中包含这 3个元素；不过，如果访问</div><div class="t m0 x0 h5 y2cb2 ffa4 fs1 fc0 sc0 ls9 ws2">elements[0]，则只会返回第一个元素。来看下面的例子。 </div><div class="t m0 x5 hb y2cb3 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2cb4 ffa4 fs6 fc0 sc0 ls21 wsb">var form = document.getElementById(&quot;myForm&quot;); </div><div class="t m0 x0 hb y2cb5 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2cb6 ffa4 fs6 fc0 sc0 ls21 wsb">var colorFields = form.elements[&quot;color&quot;]; </div><div class="t m0 x0 hb y2cb7 ffa4 fs6 fc0 sc0 ls21 wsb">alert(colorFields.length);  //3 </div><div class="t m0 x0 hb y2cb8 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2cb9 ffa4 fs6 fc0 sc0 ls21 wsb">var firstColorField = colorFields[0]; </div><div class="t m0 x0 hb y2cba ffa4 fs6 fc0 sc0 ls21 wsb">var firstFormField = form.elements[0]; </div><div class="t m0 x0 hb y2cbb ffa4 fs6 fc0 sc0 ls21 wsb">alert(firstColorField === firstFormField);   //true </div><div class="t m0 x5 hb y2cbc ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y2cbd ffab fs2 fc0 sc0 ls79 wsb">FormFieldsExample01.htm </div><div class="t m0 x0 h4 y1d10 ffa3 fs2 fc0 sc0 ls57 wsa9">以上代码显示，通过form.elements[0]访问到的第一个表单字段，与包含在form.elements </div><div class="t m0 x0 h5 y2cbe ffa4 fs1 fc0 sc0 ls9 ws2">[&quot;color&quot;]中的第一个元素相同。 </div><div class="t m0 x5 ha y2cbf ff9e fs2 fc0 sc0 ls5 wsd7">也可以通过访问表单的属性来访问元素，例如form[0]可以取得第一个表单字</div><div class="t m0 x5 ha y2cc0 ff9e fs2 fc0 sc0 ls7b ws306">段，而form[&quot;color&quot;]则可以取得第一个命名字段。这些属性与通过elements集</div><div class="t m0 x5 ha y2cc1 ff9e fs2 fc0 sc0 ls8 ws14">合访问到的元素是相同的。但是，我们应该尽可能使用elements，通过表单属性访</div><div class="t m0 x5 h5 y2cc2 ff9e fs2 fc0 sc0 ls8 ws14">问元素只是为了与旧浏览器向后兼容而保留的一种过渡方式。 </div></div></div>
<div id="pf1b2" class="pf w0 h0" data-page-no="1b2"><div class="pc pc1b2 w0 h0"><div class="t m0 x0 h2 y1 ff9d fs0 fc0 sc0 ls7 ws0">416  第14章 表单脚本 </div><div class="t m0 x0 h3 y2 ff9d fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h3c y68b ffa1 fs2 fc0 sc0 ls2e wsb">1. 共有的表单字段属性 </div><div class="t m0 x0 h4 y68c ffa3 fs2 fc0 sc0 ls6 ws6">除了&lt;fieldset&gt;元素之外，所有表单字段都拥有相同的一组属性。由于&lt;input&gt;类型可以表示多</div><div class="t m0 x0 h4 y68d ffa3 fs2 fc0 sc0 ls8 ws1">种表单字段，因此有些属性只适用于某些字段，但还有一些属性是所有字段所共有的。表单字段共有的</div><div class="t m0 x0 h5 y2cc4 ffa3 fs2 fc0 sc0 ls8 ws1">属性如下。 </div><div class="t m0 x0 h5 y1bd7 ffa2 fs1 fc0 sc0 ls2"> disabled：布尔值，表示当前字段是否被禁用。 </div><div class="t m0 x0 h5 y1ed2 ffa2 fs1 fc0 sc0 ls2"> form：指向当前字段所属表单的指针；只读。 </div><div class="t m0 x0 h5 y1ed3 ffa2 fs1 fc0 sc0 ls2"> name：当前字段的名称。 </div><div class="t m0 x0 h5 y1aa7 ffa2 fs1 fc0 sc0 ls2"> readOnly：布尔值，表示当前字段是否只读。 </div><div class="t m0 x0 h5 yf6c ffa2 fs1 fc0 sc0 ls2"> tabIndex：表示当前字段的切换（tab）序号。 </div><div class="t m0 x0 h5 y2043 ffa2 fs1 fc0 sc0 ls2"> type：当前字段的类型，如&quot;checkbox&quot;、&quot;radio&quot;，等等。 </div><div class="t m0 x0 h4 y20ee ffa2 fs1 fc0 sc0 ls2"> value：当前字段将被提交给服务器的值。对文件字段来说，这个属性是只读的，包含着文件</div><div class="t m0 x0 h5 ycbe ffa3 fs2 fc0 sc0 ls8 ws1">在计算机中的路径。 </div><div class="t m0 x0 he y2cc5 ffa3 fs2 fc0 sc0 ls8 ws1">除了form属性之外，可以通过JavaScript动态修改其他任何属性。来看下面的例子： </div><div class="t m0 x0 hb y1290 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2cc6 ffa4 fs6 fc0 sc0 ls21 wsb">var form = document.getElementById(&quot;myForm&quot;); </div><div class="t m0 x0 hb y2cc7 ffa4 fs6 fc0 sc0 ls21 wsb">var field = form.elements[0]; </div><div class="t m0 x0 hb y2cc8 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2cc9 ffa4 fs6 fc0 sc0 ls21">//修改value属性 </div><div class="t m0 x0 hb y2cca ffa4 fs6 fc0 sc0 ls21 wsb">field.value = &quot;Another value&quot;; </div><div class="t m0 x0 hb y2ccb ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2ccc ffa4 fs6 fc0 sc0 ls21">//检查form属性的值 </div><div class="t m0 x0 hb y2ccd ffa4 fs6 fc0 sc0 ls21 wsb">alert(field.form === form);   //true </div><div class="t m0 x0 hb y2cce ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2ccf ffa4 fs6 fc0 sc0 ls21">//把焦点设置到当前字段 </div><div class="t m0 x0 hb y2cd0 ffa4 fs6 fc0 sc0 ls21 wsb">field.focus(); </div><div class="t m0 x0 hb y2cd1 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2cd2 ffa4 fs6 fc0 sc0 ls21">//禁用当前字段 </div><div class="t m0 x0 hb y2cd3 ffa4 fs6 fc0 sc0 ls21 wsb">field.disabled = true; </div><div class="t m0 x0 hb y2cd4 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2cd5 ffa4 fs6 fc0 sc0 ls21">//修改type属性（不推荐，但对&lt;input&gt;来说是可行的） </div><div class="t m0 x0 hb y2cd6 ffa4 fs6 fc0 sc0 ls21 wsb">field.type = &quot;checkbox&quot;; </div><div class="t m0 x0 hb y2cd7 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y605 ffa3 fs2 fc0 sc0 ls8 ws1">能够动态修改表单字段属性，意味着我们可以在任何时候，以任何方式来动态操作表单。例如，很</div><div class="t m0 x0 h4 y606 ffa3 fs2 fc0 sc0 ls8 ws1">多用户可能会重复单击表单的提交按钮。在涉及信用卡消费时，这就是个问题：因为会导致费用翻番。</div><div class="t m0 x0 h1e y2cd8 ffa3 fs2 fc0 sc0 ls8 ws1">为此，最常见的解决方案，就是在第一次单击后就禁用提交按钮。只要侦听submit事件，并在该事件</div><div class="t m0 x0 h5 y608 ffa3 fs2 fc0 sc0 ls8 ws1">发生时禁用提交按钮即可。以下就是这样一个例子。 </div><div class="t m0 x0 hb y2cd9 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2cda ffa4 fs6 fc0 sc0 ls21">//避免多次提交表单 </div><div class="t m0 x0 hb y2cdb ffa4 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(form, &quot;submit&quot;, function(event){ </div><div class="t m0 x0 hb y2cdc ffa4 fs6 fc0 sc0 ls21 wsb">    event = EventUtil.getEvent(event); </div><div class="t m0 x0 hb y2cdd ffa4 fs6 fc0 sc0 ls21 wsb">    var target = EventUtil.getTarget(event); </div><div class="t m0 x0 hb y2cde ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2cdf ffa4 fs6 fc0 sc0 ls21 wsb">    //取得提交按钮 </div><div class="t m0 x0 hb y2ce0 ffa4 fs6 fc0 sc0 ls21 wsb">    var btn = target.elements[&quot;submit-btn&quot;]; </div><div class="t m0 x0 hb y2ce1 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2ce2 ffa4 fs6 fc0 sc0 ls21 wsb">    //禁用它 </div><div class="t m0 x0 hb y2ce3 ffa4 fs6 fc0 sc0 ls21 wsb">    btn.disabled = true; </div><div class="t m0 x0 hb y2ce4 ffa4 fs6 fc0 sc0 ls21 wsb">});  </div><div class="t m0 x2 hf y2a2f ffab fs2 fc0 sc0 ls79 wsb">FormFieldsExample02.htm </div></div></div>
<div id="pf1b3" class="pf w0 h0" data-page-no="1b3"><div class="pc pc1b3 w0 h0"><div class="t m0 x2 h2 y1 ff9d fs0 fc0 sc0 ls7 ws0">14.1 表单的基础知识    417 </div><div class="t m0 x0 h3 y2 ff9d fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffa8 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ffa8 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffa8 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffa8 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffa8 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffa8 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffa8 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffa8 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffa8 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffa8 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffa8 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffa8 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ffa8 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h4 y3 ffa3 fs2 fc0 sc0 lsa ws53">以上代码为表单的submit事件添加了一个事件处理程序。事件触发后，代码取得了提交按钮</div><div class="t m0 x0 h1e y4d ffa3 fs2 fc0 sc0 lsa ws53">并将其disabled属性设置为true。注意，不能通过onclick 事件处理程序来实现这个功能，原</div><div class="t m0 x0 h1e y5 ffa3 fs2 fc0 sc0 ls55 ws49">因是不同浏览器之间存在“时差”：有的浏览器会在触发表单的submit事件之前触发click事件，</div><div class="t m0 x0 h4 yd9 ffa3 fs2 fc0 sc0 lsa ws53">而有的浏览器则相反。对于先触发click事件的浏览器，意味着会在提交发生之前禁用按钮，结果</div><div class="t m0 x0 h1e y15d ffa3 fs2 fc0 sc0 lsa ws53">永远都不会提交表单。因此，最好是通过submit事件来禁用提交按钮。不过，这种方式不适合表</div><div class="t m0 x0 h4 y21a ffa3 fs2 fc0 sc0 lsa ws53">单中不包含提交按钮的情况；如前所述，只有在包含提交按钮的情况下，才有可能触发表单的submit</div><div class="t m0 x0 h5 y9 ffa3 fs2 fc0 sc0 lsa">事件。 </div><div class="t m0 x0 hc y15f ffa3 fs2 fc0 sc0 ls8 ws1">除了&lt;fieldset&gt;之外，所有表单字段都有type属性。对于&lt;input&gt;元素，这个值等于HTML特</div><div class="t m0 x0 h4 yb ffa3 fs2 fc0 sc0 ls396">性type的值。对于其他元素，这个type属性的值如下表所列。 </div><div class="t m0 x5 h31 y2ce5 ffa0 fs6 fc0 sc0 lsa7 wsb">说  明 HTML示例 type属性的值 </div><div class="t m0 x0 h57 y2ce6 ffa3 fs6 fc0 sc0 ls8 ws33">单选列表 &lt;select&gt;...&lt;/select&gt;  &quot;select-one&quot; </div><div class="t m0 x0 h57 y2ce7 ffa3 fs6 fc0 sc0 ls8 ws33">多选列表 &lt;select multiple&gt;...&lt;/select&gt;  &quot;select-multiple&quot; </div><div class="t m0 x0 h57 y337 ffa3 fs6 fc0 sc0 ls8 ws33">自定义按钮 &lt;button&gt;...&lt;/button&gt;  &quot;submit&quot; </div><div class="t m0 x0 h57 y254d ffa3 fs6 fc0 sc0 ls8 ws33">自定义非提交按钮 &lt;button type=&quot;button&quot;&gt;...&lt;/button&gt; &quot;button&quot; </div><div class="t m0 x0 h57 y2ce8 ffa3 fs6 fc0 sc0 ls8 ws33">自定义重置按钮 &lt;button type=&quot;reset&quot;&gt;...&lt;/buton&gt; &quot;reset&quot; </div><div class="t m0 x0 h57 y2ce9 ffa3 fs6 fc0 sc0 ls8 ws33">自定义提交按钮 &lt;button type=&quot;submit&quot;&gt;...&lt;/buton&gt; &quot;submit&quot; </div><div class="t m0 x0 h4 y2297 ffa3 fs2 fc0 sc0 ls8 ws1">此外，&lt;input&gt;和&lt;button&gt;元素的type属性是可以动态修改的，而&lt;select&gt;元素的type属性</div><div class="t m0 x0 h5 y7dd ffa3 fs2 fc0 sc0 ls8 ws1">则是只读的。 </div><div class="t m0 x0 h3c y2cea ffa1 fs2 fc0 sc0 ls2e wsb">2. 共有的表单字段方法 </div><div class="t m0 x0 h4 y2ceb ffa3 fs2 fc0 sc0 ls8 ws1">每个表单字段都有两个方法：focus()和 blur()。其中，focus()方法用于将浏览器的焦点设置</div><div class="t m0 x0 h4 y2cec ffa3 fs2 fc0 sc0 ls8 ws1">到表单字段，即激活表单字段，使其可以响应键盘事件。例如，接收到焦点的文本框会显示插入符号，</div><div class="t m0 x0 h1e y2ced ffa3 fs2 fc0 sc0 ls8 ws1">随时可以接收输入。使用focus()方法，可以将用户的注意力吸引到页面中的某个部位。例如，在页面</div><div class="t m0 x0 h1e y2cee ffa3 fs2 fc0 sc0 ls8 ws1">加载完毕后，将焦点转移到表单中的第一个字段。为此，可以侦听页面的load事件，并在该事件发生</div><div class="t m0 x0 hc y2cef ffa3 fs2 fc0 sc0 ls8 ws1">时在表单的第一个字段上调用focus()方法，如下面的例子所示。 </div><div class="t m0 x5 hb y2cf0 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2cf1 ffa4 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(window, &quot;load&quot;, function(event){ </div><div class="t m0 x0 hb y2cf2 ffa4 fs6 fc0 sc0 ls21 wsb">    document.forms[0].elements[0].focus(); </div><div class="t m0 x0 hb y2cf3 ffa4 fs6 fc0 sc0 ls21 wsb">});  </div><div class="t m0 x0 h4 y1e8 ffa3 fs2 fc0 sc0 ls8 ws1">要注意的是，如果第一个表单字段是一个&lt;input&gt;元素，且其type特性的值为&quot;hidden&quot;，那么</div><div class="t m0 x0 h5 y2cf4 ffa3 fs2 fc0 sc0 ls8 ws1">以上代码会导致错误。另外，如果使用CSS的display和visibility属性隐藏了该字段，同样也会</div><div class="t m0 x0 h5 y2cf5 ffa3 fs2 fc0 sc0 ls8 ws1">导致错误。 </div><div class="t m0 x0 h5 y2cf6 ff9d fs2 fc0 sc0 ls2f ws8a">HTML5为表单字段新增了一个autofocus属性。在支持这个属性的浏览器中，只要设置这个属性，</div><div class="t m0 x0 h5 y2cf7 ffa3 fs2 fc0 sc0 ls8 ws1">不用JavaScript就能自动把焦点移动到相应字段。例如： </div><div class="t m0 x0 hb y2cf8 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2cf9 ffa4 fs6 fc0 sc0 ls21 wsb">&lt;input type=&quot;text&quot; autofocus&gt; </div><div class="t m0 x0 hb y2cfa ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y2cfb ffa3 fs2 fc0 sc0 ls8 ws1">为了保证前面的代码在设置autofocus的浏览器中正常运行，必须先检测是否设置了该属性，如</div><div class="t m0 x0 hc y2cfc ffa3 fs2 fc0 sc0 ls8 ws1">果设置了，就不用再调用focus()了。 </div><div class="t m0 x0 hb y1f72 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2cfd ffa4 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(window, &quot;load&quot;, function(event){  </div><div class="t m0 x0 hb y2cfe ffa4 fs6 fc0 sc0 ls21 wsb">    var element = document.forms[0].elements[0]; </div><div class="t m0 x0 hb y2cff ffa4 fs6 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf1b4" class="pf w0 h0" data-page-no="1b4"><div class="pc pc1b4 w0 h0"><div class="t m0 x0 h2 y1 ff9d fs0 fc0 sc0 ls7 ws0">418  第14章 表单脚本 </div><div class="t m0 x0 h3 y2 ff9d fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 ffa4 fs6 fc0 sc0 ls21 wsb">    if (element.autofocus !== true){ </div><div class="t m0 x0 hb y7a ffa4 fs6 fc0 sc0 ls21 wsb">        element.focus(); console.log(&quot;JS focus&quot;); </div><div class="t m0 x0 hb y7b ffa4 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y7c ffa4 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 hb y2d01 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y2d02 ffab fs2 fc0 sc0 ls2b wsb">FocusExample01.htm </div><div class="t m0 x0 h4 y2d03 ffa3 fs2 fc0 sc0 ls8 ws1">因为autofocus是一个布尔值属性，所以在支持的浏览器中它的值应该是true。（在不支持的浏</div><div class="t m0 x0 h1e y2d04 ffa3 fs2 fc0 sc0 ls8 ws1">览器中，它的值将是空字符串。）为此，上面的代码只有在autofocus不等于true的情况下才会调用</div><div class="t m0 x0 h5 y1f7b ffa4 fs1 fc0 sc0 ls9 ws2">focus()，从而保证向前兼容。支持autofocus属性的浏览器有Firefox 4+、Safari 5+、Chrome和Opera </div><div class="t m0 x0 h5 y1f7c ff9d fs2 fc0 sc0 lsd2 ws19b">9.6。 </div><div class="t m0 x5 ha y2d05 ff9e fs2 fc0 sc0 ls30">在默认情况下，只有表单字段可以获得焦点。对于其他元素而言，如果先将其</div><div class="t m0 x0 hf4 y2d06 ffa4 fs1 fc0 sc0 ls9 ws2">tabIndex属性设置为1，然后再调用focus()方法，也可以让这些元素获得焦点。</div><div class="t m0 x0 h5 y2d07 ff9e fs2 fc0 sc0 ls8 ws14">只有Opera不支持这种技术。 </div><div class="t m0 x0 hf5 y2d08 ffa3 fs2 fc0 sc0 ls39e">与focus()方法相对的是blur()方法，它的作用是从元素中移走焦点。在调用blur()方法时，</div><div class="t m0 x0 h4 y2d09 ffa3 fs2 fc0 sc0 ls24 ws1e">并不会把焦点转移到某个特定的元素上；仅仅是将焦点从调用这个方法的元素上面移走而已。在早期</div><div class="t m0 x0 h5 y2d0a ff9d fs2 fc0 sc0 lsfd wscc">Web开发中，那时候的表单字段还没有readonly特性，因此就可以使用blur()方法来创建只读字段。</div><div class="t m0 x0 hc y2d0b ffa3 fs2 fc0 sc0 ls8 ws1">现在，虽然需要使用blur()的场合不多了，但必要时还可以使用的。用法如下： </div><div class="t m0 x0 hb y2297 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2d0c ffa4 fs6 fc0 sc0 ls21 wsb">document.forms[0].elements[0].blur(); </div><div class="t m0 x0 hb y2d0d ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h3c y2d0e ffa1 fs2 fc0 sc0 ls2e wsb">3. 共有的表单字段事件 </div><div class="t m0 x0 h5 y2d0f ffa3 fs2 fc0 sc0 ls8 ws1">除了支持鼠标、键盘、更改和HTML事件之外，所有表单字段都支持下列3个事件。 </div><div class="t m0 x0 h5 y2d10 ffa2 fs1 fc0 sc0 ls2"> blur：当前字段失去焦点时触发。 </div><div class="t m0 x0 h4 y2d11 ffa2 fs1 fc0 sc0 ls2"> change：对于&lt;input&gt;和&lt;textarea&gt;元素，在它们失去焦点且value值改变时触发；对于</div><div class="t m0 x0 h5 y239d ffa4 fs1 fc0 sc0 ls9 ws2">&lt;select&gt;元素，在其选项改变时触发。 </div><div class="t m0 x0 h5 y2d12 ffa2 fs1 fc0 sc0 ls2"> focus：当前字段获得焦点时触发。 </div><div class="t m0 x0 h4 y2d13 ffa3 fs2 fc0 sc0 ls8 ws1">当用户改变了当前字段的焦点，或者我们调用了blur()或focus()方法时，都可以触发blur和</div><div class="t m0 x0 h4 y2d14 ffa4 fs1 fc0 sc0 ls9 ws2">focus事件。这两个事件在所有表单字段中都是相同的。但是，change事件在不同表单控件中触发的</div><div class="t m0 x0 h1e y2d15 ffa3 fs2 fc0 sc0 ls8 ws1">次数会有所不同。对于&lt;input&gt;和&lt;textarea&gt;元素，当它们从获得焦点到失去焦点且value值改变时，</div><div class="t m0 x0 h1e y2d16 ffa3 fs2 fc0 sc0 ls8 ws1">才会触发change事件。对于&lt;select&gt;元素，只要用户选择了不同的选项，就会触发change 事件；</div><div class="t m0 x0 h5 y7c9 ffa3 fs2 fc0 sc0 ls8 ws1">换句话说，不失去焦点也会触发change事件。 </div><div class="t m0 x0 h1e y2d17 ffa3 fs2 fc0 sc0 ls8 ws1">通常，可以使用focus和blur事件来以某种方式改变用户界面，要么是向用户给出视觉提示，要</div><div class="t m0 x0 h1e y2d18 ffa3 fs2 fc0 sc0 ls8 ws1">么是向界面中添加额外的功能（例如，为文本框显示一个下拉选项菜单）。而change事件则经常用于</div><div class="t m0 x0 h4 y2d19 ffa3 fs2 fc0 sc0 ls8 ws1">验证用户在字段中输入的数据。例如，假设有一个文本框，我们只允许用户输入数值。此时，可以利用</div><div class="t m0 x0 h4 y684 ffa4 fs1 fc0 sc0 ls9 ws2">focus事件修改文本框的背景颜色，以便更清楚地表明这个字段获得了焦点。可以利用blur事件恢复</div><div class="t m0 x0 h1e y2d1a ffa3 fs2 fc0 sc0 ls8 ws1">文本框的背景颜色，利用change事件在用户输入了非数值字符时再次修改背景颜色。下面就给出了实</div><div class="t m0 x0 h5 y2d1b ffa3 fs2 fc0 sc0 ls8 ws1">现上述功能的代码。 </div><div class="t m0 x0 hb y2d1c ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2d1d ffa4 fs6 fc0 sc0 ls21 wsb">var textbox = document.forms[0].elements[0]; </div><div class="t m0 x0 hb y2d1e ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2d1f ffa4 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(textbox, &quot;focus&quot;, function(event){ </div><div class="t m0 x0 hb y2d20 ffa4 fs6 fc0 sc0 ls21 wsb">    event = EventUtil.getEvent(event); </div></div></div>
<div id="pf1b5" class="pf w0 h0" data-page-no="1b5"><div class="pc pc1b5 w0 h0"><div class="t m0 x2 h2 y1 ff9d fs0 fc0 sc0 ls7 ws0">14.2 文本框脚本    419 </div><div class="t m0 x0 h3 y2 ff9d fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffa8 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ffa8 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffa8 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffa8 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffa8 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffa8 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffa8 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffa8 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffa8 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffa8 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffa8 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffa8 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ffa8 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y12e1 ffa4 fs6 fc0 sc0 ls21 wsb">    var target = EventUtil.getTarget(event); </div><div class="t m0 x0 hb y12e2 ffa4 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 hb y12e3 ffa4 fs6 fc0 sc0 ls21 wsb">    if (target.style.backgroundColor != &quot;red&quot;){ </div><div class="t m0 x0 hb y12e4 ffa4 fs6 fc0 sc0 ls21 wsb">        target.style.backgroundColor = &quot;yellow&quot;; </div><div class="t m0 x0 hb y12e5 ffa4 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y12e6 ffa4 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 hb y12e7 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y12e8 ffa4 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(textbox, &quot;blur&quot;, function(event){ </div><div class="t m0 x0 hb y12e9 ffa4 fs6 fc0 sc0 ls21 wsb">    event = EventUtil.getEvent(event); </div><div class="t m0 x0 hb y12ea ffa4 fs6 fc0 sc0 ls21 wsb">    var target = EventUtil.getTarget(event); </div><div class="t m0 x0 hb y12eb ffa4 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 hb y12ec ffa4 fs6 fc0 sc0 ls21 wsb">    if (/[^\d]/.test(target.value)){ </div><div class="t m0 x0 hb y12ed ffa4 fs6 fc0 sc0 ls21 wsb">        target.style.backgroundColor = &quot;red&quot;; </div><div class="t m0 x0 hb y12ee ffa4 fs6 fc0 sc0 ls21 wsb">    } else { </div><div class="t m0 x0 hb y12ef ffa4 fs6 fc0 sc0 ls21 wsb">        target.style.backgroundColor = &quot;&quot;; </div><div class="t m0 x0 hb y12f0 ffa4 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y17ff ffa4 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 hb y1800 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1801 ffa4 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(textbox, &quot;change&quot;, function(event){ </div><div class="t m0 x0 hb y2d21 ffa4 fs6 fc0 sc0 ls21 wsb">    event = EventUtil.getEvent(event); </div><div class="t m0 x0 hb y2d22 ffa4 fs6 fc0 sc0 ls21 wsb">    var target = EventUtil.getTarget(event); </div><div class="t m0 x0 hb y2d23 ffa4 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 hb y2d24 ffa4 fs6 fc0 sc0 ls21 wsb">    if (/[^\d]/.test(target.value)){ </div><div class="t m0 x0 hb y2d25 ffa4 fs6 fc0 sc0 ls21 wsb">        target.style.backgroundColor = &quot;red&quot;; </div><div class="t m0 x0 hb y2d26 ffa4 fs6 fc0 sc0 ls21 wsb">    } else { </div><div class="t m0 x0 hb y2d27 ffa4 fs6 fc0 sc0 ls21 wsb">        target.style.backgroundColor = &quot;&quot;; </div><div class="t m0 x0 hb y2d28 ffa4 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y2d29 ffa4 fs6 fc0 sc0 ls21 wsb">});                </div><div class="t m0 x5 hb y2d2a ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y2d2b ffab fs2 fc0 sc0 ls1b wsb">FormFieldEventsExample01.htm </div><div class="t m0 x0 h4 y1d09 ffa3 fs2 fc0 sc0 ls8 ws1">在此，onfocus事件处理程序将文本框的背景颜色修改为黄色，以清楚地表明当前字段已经激活。</div><div class="t m0 x0 h1e y2d2c ffa3 fs2 fc0 sc0 ls8 ws1">随后，onblur和onchange事件处理程序则会在发现非数值字符时，将文本框背景颜色修改为红色。</div><div class="t m0 x0 h4 y5b3 ffa3 fs2 fc0 sc0 ls8 ws1">为了测试用户输入的是不是非数值，这里针对文本框的value属性使用了简单的正则表达式。而且，</div><div class="t m0 x0 h1e y5b4 ffa3 fs2 fc0 sc0 ls8 ws1">为确保无论文本框的值如何变化，验证规则始终如一，onblur和onchange事件处理程序中使用了相</div><div class="t m0 x0 h5 y2d2d ffa3 fs2 fc0 sc0 ls8 ws1">同的正则表达式。 </div><div class="t m0 x5 ha y2d2e ff9e fs2 fc0 sc0 ls8 ws14">关于blur和change事件的关系，并没有严格的规定。在某些浏览器中，blur</div><div class="t m0 x5 ha y1e14 ff9e fs2 fc0 sc0 ls8 ws14">事件会先于change事件发生；而在其他浏览器中，则恰好相反。为此，不能假定这</div><div class="t m0 x5 h5 y2d2f ff9e fs2 fc0 sc0 ls8 ws14">两个事件总会以某种顺序依次触发，这一点要特别注意。 </div><div class="t m0 x0 hd y2816 ffa1 fs7 fc0 sc0 ls245">14.2 文本框脚本 </div><div class="t m0 x0 h5 y2d30 ffa3 fs2 fc0 sc0 lsd0">在HTML中，有两种方式来表现文本框：一种是使用&lt;input&gt;元素的单行文本框，另一种是使用</div><div class="t m0 x0 h4 y2d31 ffa4 fs1 fc0 sc0 ls9 ws2">&lt;textarea&gt;的多行文本框。这两个控件非常相似，而且多数时候的行为也差不多。不过，它们之间仍</div><div class="t m0 x0 h5 y2d32 ffa3 fs2 fc0 sc0 ls8 ws1">然存在一些重要的区别。 </div><div class="t m0 x0 h1c y2d33 ffa3 fs2 fc0 sc0 ls8 ws1">要表现文本框，必须将&lt;input&gt;元素的type特性设置为&quot;text&quot;。而通过设置size特性，可以指</div><div class="t m0 x0 h1e y2d34 ffa3 fs2 fc0 sc0 ls8 ws1">定文本框中能够显示的字符数。通过value特性，可以设置文本框的初始值，而maxlength特性则用</div><div class="t m0 x0 h5 y263c ffa3 fs2 fc0 sc0 ls8 ws1">于指定文本框可以接受的最大字符数。如果要创建一个文本框，让它能够显示25个字符，但输入不能</div><div class="t m0 x0 h5 y2d35 ffa3 fs2 fc0 sc0 ls8 ws1">超过50个字符，可以使用以下代码： </div></div></div>
<div id="pf1b6" class="pf w0 h0" data-page-no="1b6"><div class="pc pc1b6 w0 h0"><div class="t m0 x0 h2 y1 ff9d fs0 fc0 sc0 ls7 ws0">420  第14章 表单脚本 </div><div class="t m0 x0 h3 y2 ff9d fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 ffa4 fs6 fc0 sc0 ls21 wsb">&lt;input type=&quot;text&quot; size=&quot;25&quot; maxlength=&quot;50&quot; value=&quot;initial value&quot;&gt; </div><div class="t m0 x0 hf6 y7a ffad fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y2d36 ffa3 fs2 fc0 sc0 ls8 ws1">相对而言，&lt;textarea&gt;元素则始终会呈现为一个多行文本框。要指定文本框的大小，可以 使用rows</div><div class="t m0 x0 h4 y2d37 ffa3 fs2 fc0 sc0 ls2c">和cols特性。其中，rows特性指定的是文本框的字符行数，而cols特性指定的是文本框的字符列数</div><div class="t m0 x0 h1e y2d38 ffa3 fs2 fc0 sc0 ls339 ws30f">（类似于&lt;inpu&gt;元素的size 特性）。与&lt;input&gt;元素不同，&lt;textarea&gt;的初始值必须要放在</div><div class="t m0 x0 h5 y2d39 ffa4 fs1 fc0 sc0 ls9 ws2">&lt;textarea&gt;和&lt;/textarea&gt;之间，如下面的例子所示。 </div><div class="t m0 x0 hb y182 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2d3a ffa4 fs6 fc0 sc0 ls21 wsb">&lt;textarea rows=&quot;25&quot; cols=&quot;5&quot;&gt;initial value&lt;/textarea&gt; </div><div class="t m0 x0 hb y2d3b ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y2d3c ffa3 fs2 fc0 sc0 ls8 ws1">另一个与&lt;input&gt;的区别在于，不能在HTML中给&lt;textarea&gt;指定最大字符数。 </div><div class="t m0 x0 h1e y2734 ffa3 fs2 fc0 sc0 ls8 ws1">无论这两种文本框在标记中有什么区别，但它们都会将用户输入的内容保存在value属性中。可</div><div class="t m0 x0 h5 y2735 ffa3 fs2 fc0 sc0 ls8 ws1">以通过这个属性读取和设置文本框的值，如下面的例子所示： </div><div class="t m0 x0 hb y2ce5 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2d3d ffa4 fs6 fc0 sc0 ls21 wsb">var textbox = document.forms[0].elements[&quot;textbox1&quot;]; </div><div class="t m0 x0 hb y2d3e ffa4 fs6 fc0 sc0 ls21 wsb">alert(textbox.value); </div><div class="t m0 x0 hb y2d3f ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2d40 ffa4 fs6 fc0 sc0 ls21 wsb">textbox.value = &quot;Some new value&quot;; </div><div class="t m0 x0 hb y2d41 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y2d42 ffa3 fs2 fc0 sc0 ls8 ws1">我们建议读者像上面这样使用value属性读取或设置文本框的值，不建议使用标准的DOM方法。</div><div class="t m0 x0 h1e y2d43 ffa3 fs2 fc0 sc0 ls8 ws1">换句话说，不要使用setAttribute()设置&lt;input&gt;元素的value特性，也 不要去修改&lt;textarea&gt;</div><div class="t m0 x0 h5 y2d44 ffa3 fs2 fc0 sc0 ls8 ws1">元素的第一个子节点。原因很简单：对value属性所作的修改，不一定会反映在DOM中。因此，在处</div><div class="t m0 x0 h5 y2d45 ffa3 fs2 fc0 sc0 ls8 ws1">理文本框的值时，最好不要使用DOM方法。 </div><div class="t m0 x0 h20 y2d46 ffa1 fs3 fc0 sc0 ls248 ws214">14.2.1 选择文本 </div><div class="t m0 x0 h4 y2d47 ffa3 fs2 fc0 sc0 ls8 ws1">上述两种文本框都支持select()方法，这个方法用于选择文本框中的所有文本。在调用select()</div><div class="t m0 x0 h5 y1408 ffa3 fs2 fc0 sc0 ls8 ws1">方法时，大多数浏览器（Opera除外）都会将焦点设置到文本框中。这个方法不接受参数，可以在任何</div><div class="t m0 x0 h5 y858 ffa3 fs2 fc0 sc0 ls8 ws1">时候被调用。下面来看一个例子。 </div><div class="t m0 x0 hb y3be ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2d48 ffa4 fs6 fc0 sc0 ls21 wsb">var textbox = document.forms[0].elements[&quot;textbox1&quot;]; </div><div class="t m0 x0 hb y2d49 ffa4 fs6 fc0 sc0 ls21 wsb">textbox.select(); </div><div class="t m0 x0 hb y2d4a ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y2d4b ffa3 fs2 fc0 sc0 ls8 ws1">在文本框获得焦点时选择其所有文本，这是一种非常常见的做法，特别是在文本框包含默认值的时</div><div class="t m0 x0 h5 y6d9 ffa3 fs2 fc0 sc0 ls8 ws1">候。因为这样做可以让用户不必一个一个地删除文本。下面展示了实现这一操作的代码。 </div><div class="t m0 x0 hb y2d4c ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2d4d ffa4 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(textbox, &quot;focus&quot;, function(event){ </div><div class="t m0 x0 hb y2d4e ffa4 fs6 fc0 sc0 ls21 wsb">    event = EventUtil.getEvent(event); </div><div class="t m0 x0 hb y2d4f ffa4 fs6 fc0 sc0 ls21 wsb">    var target = EventUtil.getTarget(event); </div><div class="t m0 x0 hb y2d50 ffa4 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 hb y2d51 ffa4 fs6 fc0 sc0 ls21 wsb">    target.select(); </div><div class="t m0 x0 hb y2d52 ffa4 fs6 fc0 sc0 ls21 wsb">});  </div><div class="t m0 x2 hf y2d53 ffab fs2 fc0 sc0 ls1b wsb">TextboxSelectExample01.htm </div><div class="t m0 x0 h4 y2d54 ffa3 fs2 fc0 sc0 ls8 ws1">将上面的代码应用到文本框之后，只要文本框获得焦点，就会选择其中所有的文本。这种技术能够</div><div class="t m0 x0 h5 yc6f ffa3 fs2 fc0 sc0 ls8 ws1">较大幅度地提升表单的易用性。 </div><div class="t m0 x0 h4e y2d55 ffa1 fs2 fc0 sc0 ls2e wsb">1. 选择（select）事件 </div><div class="t m0 x0 h4 y2d56 ffa3 fs2 fc0 sc0 ls39f">与select()方法对应的，是一个select事件。在选择了文本框中的文本时，就会触发select</div><div class="t m0 x0 h5 y2d57 ffa3 fs2 fc0 sc0 ls8 ws1">事件。不过，到底什么时候触发select事件，还会因浏览器而异。在IE9+、Opera、Firefox、Chrome</div><div class="t m0 x0 hc y2d58 ffa3 fs2 fc0 sc0 ls3b">和Safari中，只有用户选择了文本（而且要释放鼠标），才会触发select事件。而在IE8及更早版本中，</div></div></div>
<div id="pf1b7" class="pf w0 h0" data-page-no="1b7"><div class="pc pc1b7 w0 h0"><div class="t m0 x2 h2 y1 ff9d fs0 fc0 sc0 ls7 ws0">14.2 文本框脚本    421 </div><div class="t m0 x0 h3 y2 ff9d fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffa8 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ffa8 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffa8 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffa8 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffa8 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffa8 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffa8 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffa8 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffa8 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffa8 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffa8 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffa8 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ffa8 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h4 y3 ffa3 fs2 fc0 sc0 ls8 ws1">只要用户选择了一个字母（不必释放鼠标），就会触发select事件。另外，在调用select()方法时也</div><div class="t m0 x0 hc y4d ffa3 fs2 fc0 sc0 ls8 ws1">会触发select事件。下面是一个简单的例子。 </div><div class="t m0 x5 hb y2d8 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2d59 ffa4 fs6 fc0 sc0 ls21 wsb">var textbox = document.forms[0].elements[&quot;textbox1&quot;]; </div><div class="t m0 x0 hb y2d5a ffa4 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(textbox, &quot;select&quot;, function(event){ </div><div class="t m0 x0 hb y2061 ffa4 fs6 fc0 sc0 ls21 wsb">    var alert(&quot;Text selected&quot; + textbox.value); </div><div class="t m0 x0 hb y2d5b ffa4 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 hb y2d5c ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y478 ffab fs2 fc0 sc0 ls1b wsb">SelectEventExample01.htm </div><div class="t m0 x0 h3c ye8a ffa1 fs2 fc0 sc0 ls2e wsb">2. 取得选择的文本 </div><div class="t m0 x0 h4 y2d5d ffa3 fs2 fc0 sc0 ls8 ws1">虽然通过select事件我们可以知道用户什么时候选择了文本，但仍然不知道用户选择了什么文本。</div><div class="t m0 x0 h5 y2d5e ff9d fs2 fc0 sc0 ls2f ws8a">HTML5通过一些扩展方案解决了这个问题，以便更顺利地取得选择的文本。该规范采取的办法是添加</div><div class="t m0 x0 he y2d5f ffa3 fs2 fc0 sc0 ls8 ws1">两个属性：selectionStart和selectionEnd。这两个属性中保存的是基于0的数值，表示所选择</div><div class="t m0 x0 h4 y20b2 ffa3 fs2 fc0 sc0 ls6 ws6">文本的范围（即文本选区开头和结尾的偏移量）。因此，要取得用户在文本框中选择的文本，可以使用</div><div class="t m0 x0 h5 y2d60 ffa3 fs2 fc0 sc0 ls8 ws1">如下代码。 </div><div class="t m0 x5 hb yb79 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2d61 ffa4 fs6 fc0 sc0 ls21 wsb">function getSelectedText(textbox){ </div><div class="t m0 x0 hb y2d62 ffa4 fs6 fc0 sc0 ls21 wsb">    return textbox.value.substring(textbox.selectionStart, textbox.selectionEnd); </div><div class="t m0 x0 hb y2d63 ffa4 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h4 y1c5b ffa3 fs2 fc0 sc0 ls288 ws311">因为substring()方法基于字符串的偏移量执行操作，所以将selectionStart 和</div><div class="t m0 x0 h5 y24c9 ffa4 fs1 fc0 sc0 ls9 ws2">selectionEnd直接传给它就可以取得选中的文本。 </div><div class="t m0 x0 h5 y1198 ff9d fs2 fc0 sc0 ls46 ws37">IE9+、Firefox、Safari、Chrome和Opera都支持这两个属性。IE8及之前版本不支持这两个属性，</div><div class="t m0 x0 h5 y2d64 ffa3 fs2 fc0 sc0 ls8 ws1">而是提供了另一种方案。 </div><div class="t m0 x0 h5 y2d65 ff9d fs2 fc0 sc0 ls2a ws21">IE8及更早的版本中有一个document.selection对象，其中保存着用户在整个文档范围内选择</div><div class="t m0 x0 h1e y2d66 ffa3 fs2 fc0 sc0 ls8 ws1">的文本信息；也就是说，无法确定用户选择的是页面中哪个部位的文本。不过，在与select事件一起</div><div class="t m0 x0 h4 y2d67 ffa3 fs2 fc0 sc0 ls8 ws1">使用的时候，可以假定是用户选择了文本框中的文本，因而触发了该事件。要取得选择的文本，首先必</div><div class="t m0 x0 h5 y2d68 ffa3 fs2 fc0 sc0 ls8 ws1">须创建一个范围（第12章讨论过），然后再将文本从其中提取出来，如下面的例子所示。 </div><div class="t m0 x0 hb y1ccf ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2d69 ffa4 fs6 fc0 sc0 ls21 wsb">function getSelectedText(textbox){  </div><div class="t m0 x0 hb y2d6a ffa4 fs6 fc0 sc0 ls21 wsb">    if (typeof textbox.selectionStart == &quot;number&quot;){ </div><div class="t m0 x0 hb y2d6b ffa4 fs6 fc0 sc0 ls21 wsb">        return textbox.value.substring(textbox.selectionStart, </div><div class="t m0 x0 hb y2d6c ffa4 fs6 fc0 sc0 ls21 wsb">                                       textbox.selectionEnd); </div><div class="t m0 x0 hb y2d6d ffa4 fs6 fc0 sc0 ls21 wsb">    } else if (document.selection){ </div><div class="t m0 x0 hb y2d6e ffa4 fs6 fc0 sc0 ls21 wsb">        return document.selection.createRange().text; </div><div class="t m0 x0 hb y2d6f ffa4 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y2d70 ffa4 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y2d71 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y2d72 ffab fs2 fc0 sc0 ls8 wsb">TextboxGetSelectedTextExample01.htm </div><div class="t m0 x0 h5 y969 ffa3 fs2 fc0 sc0 ls8 ws1">这里修改了前面的函数，包括了在IE中取得选择文本的代码。注意，调用document.selection</div><div class="t m0 x0 h5 y2d73 ffa3 fs2 fc0 sc0 ls8 ws1">时，不需要考虑textbox参数。 </div><div class="t m0 x0 h3c y2d74 ffa1 fs2 fc0 sc0 ls2e wsb">3. 选择部分文本 </div><div class="t m0 x0 h5 y2d75 ff9d fs2 fc0 sc0 ls2ae ws274">HTML5也为选择文本框中的部分文本提供了解决方案，即最早由Firefox 引入的</div><div class="t m0 x0 h4 y252a ffa4 fs1 fc0 sc0 ls43 ws31">setSelectionRange()方法。现在除select()方法之外，所有文本框都有一个setSelectionRange()</div><div class="t m0 x0 h4 y2d76 ffa3 fs2 fc0 sc0 ls42 ws30">方法。这个方法接收两个参数：要选择的第一个字符的索引和要选择的最后一个字符之后的字符的索引</div><div class="t m0 x0 hc5 y2d77 ffa3 fs2 fc0 sc0 ls44 ws32">（类似于substring()方法的两个参数）。来看一个例子。 </div></div></div>
<div id="pf1b8" class="pf w0 h0" data-page-no="1b8"><div class="pc pc1b8 w0 h0"><div class="t m0 x0 h2 y1 ff9d fs0 fc0 sc0 ls7 ws0">422  第14章 表单脚本 </div><div class="t m0 x0 h3 y2 ff9d fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y8f5 ffa4 fs6 fc0 sc0 ls21 wsb">textbox.value = &quot;Hello world!&quot; </div><div class="t m0 x0 hb y8f6 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y8f7 ffa4 fs6 fc0 sc0 ls21">//选择所有文本 </div><div class="t m0 x0 hb y8f8 ffa4 fs6 fc0 sc0 ls21 wsb">textbox.setSelectionRange(0, textbox.value.length);  //&quot;Hello world!&quot; </div><div class="t m0 x0 hb y8f9 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y8fa ffa4 fs6 fc0 sc0 ls21">//选择前3个字符 </div><div class="t m0 x0 hb y8fb ffa4 fs6 fc0 sc0 ls21 wsb">textbox.setSelectionRange(0, 3);  //&quot;Hel&quot; </div><div class="t m0 x0 hb y8fc ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2d78 ffa4 fs6 fc0 sc0 ls21">//选择第4到第6个字符 </div><div class="t m0 x0 hb y2d79 ffa4 fs6 fc0 sc0 ls21 wsb">textbox.setSelectionRange(4, 7);  //&quot;o w&quot; </div><div class="t m0 x0 hb y2d7a ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y640 ffa3 fs2 fc0 sc0 ls24 ws1e">要看到选择的文本，必须在调用setSelectionRange()之前或之后立即将焦点设置到文本框。</div><div class="t m0 x0 h5 y2d7b ff9d fs2 fc0 sc0 ls2a ws21">IE9、Firefox、Safari、Chrome和Opera支持这种方案。 </div><div class="t m0 x0 h5 y2d7c ff9d fs2 fc0 sc0 ls2a ws21">IE8及更早版本支持使用范围（第12章讨论过）选择部分文本。要选择文本框中的部分文本，必须</div><div class="t m0 x0 h5 y2d7d ffa3 fs2 fc0 sc0 ls8 ws1">首先使用IE在所有文本框上提供的createTextRange()方法创建一个范围，并将其放在恰当的位置</div><div class="t m0 x0 h1e y2d7e ffa3 fs2 fc0 sc0 ls8 ws1">上。然后，再使用moveStart()和moveEnd()这两个范围方法将范围移动到位。不过，在调用这两个</div><div class="t m0 x0 h1e y2d7f ffa3 fs2 fc0 sc0 ls8 ws1">方法以前，还必须使用collapse()将范围折叠到文本框的开始位置。此时，moveStart()将范围的起</div><div class="t m0 x0 h1e y1fc4 ffa3 fs2 fc0 sc0 ls6 ws6">点和终点移动到了相同的位置，只要再给moveEnd()传入要选择的字符总数即可。最后一步，就是使</div><div class="t m0 x0 hc y2d80 ffa3 fs2 fc0 sc0 ls8 ws1">用范围的select()方法选择文本，如下面的例子所示。 </div><div class="t m0 x0 hb y2d81 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2d82 ffa4 fs6 fc0 sc0 ls21 wsb">textbox.value = &quot;Hello world!&quot;; </div><div class="t m0 x0 hb y2d83 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2d84 ffa4 fs6 fc0 sc0 ls21 wsb">var range = textbox.createTextRange(); </div><div class="t m0 x0 hb y2d85 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2d86 ffa4 fs6 fc0 sc0 ls21">//选择所有文本 </div><div class="t m0 x0 hb y2d87 ffa4 fs6 fc0 sc0 ls21 wsb">range.collapse(true); </div><div class="t m0 x0 hb y2d88 ffa4 fs6 fc0 sc0 ls21 wsb">range.moveStart(&quot;character&quot;, 0); </div><div class="t m0 x0 hb y2d89 ffa4 fs6 fc0 sc0 ls21 wsb">range.moveEnd(&quot;character&quot;, textbox.value.length);  //&quot;Hello world!&quot; </div><div class="t m0 x0 hb y2d8a ffa4 fs6 fc0 sc0 ls21 wsb">range.select(); </div><div class="t m0 x0 hb y2d8b ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2d8c ffa4 fs6 fc0 sc0 ls21">//选择前3个字符 </div><div class="t m0 x0 hb y2d8d ffa4 fs6 fc0 sc0 ls21 wsb">range.collapse(true); </div><div class="t m0 x0 hb y2d8e ffa4 fs6 fc0 sc0 ls21 wsb">range.moveStart(&quot;character&quot;, 0); </div><div class="t m0 x0 hb y2d8f ffa4 fs6 fc0 sc0 ls21 wsb">range.moveEnd(&quot;character&quot;, 3); </div><div class="t m0 x0 hb y2d90 ffa4 fs6 fc0 sc0 ls21 wsb">range.select();                    //&quot;Hel&quot; </div><div class="t m0 x0 hb y2d91 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2d92 ffa4 fs6 fc0 sc0 ls21">//选择第4到第6个字符 </div><div class="t m0 x0 hb y2d93 ffa4 fs6 fc0 sc0 ls21 wsb">range.collapse(true); </div><div class="t m0 x0 hb y2d94 ffa4 fs6 fc0 sc0 ls21 wsb">range.moveStart(&quot;character&quot;, 4); </div><div class="t m0 x0 hb y2d95 ffa4 fs6 fc0 sc0 ls21 wsb">range.moveEnd(&quot;character&quot;, 3); </div><div class="t m0 x0 hb y2d96 ffa4 fs6 fc0 sc0 ls21 wsb">range.select();                    //&quot;o w&quot; </div><div class="t m0 x0 hb y2d97 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y2d98 ffa3 fs2 fc0 sc0 ls8 ws1">与在其他浏览器中一样，要想在文本框中看到文本被选择的效果，必须让文本框获得焦点。 </div><div class="t m0 x0 h5 y2d99 ffa3 fs2 fc0 sc0 ls8 ws1">为了实现跨浏览器编程，可以将上述两种方案组合起来，如下面的例子所示。 </div><div class="t m0 x0 hb y19f9 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2d9a ffa4 fs6 fc0 sc0 ls21 wsb">function selectText(textbox, startIndex, stopIndex){ </div><div class="t m0 x0 hb y2d9b ffa4 fs6 fc0 sc0 ls21 wsb">    if (textbox.setSelectionRange){ </div><div class="t m0 x0 hb y2d9c ffa4 fs6 fc0 sc0 ls21 wsb">        textbox.setSelectionRange(startIndex, stopIndex); </div><div class="t m0 x0 hb y2d9d ffa4 fs6 fc0 sc0 ls21 wsb">    } else if (textbox.createTextRange){ </div><div class="t m0 x0 hb y2d9e ffa4 fs6 fc0 sc0 ls21 wsb">        var range = textbox.createTextRange(); </div><div class="t m0 x0 hb y2d9f ffa4 fs6 fc0 sc0 ls21 wsb">        range.collapse(true); </div><div class="t m0 x0 hb y2da0 ffa4 fs6 fc0 sc0 ls21 wsb">        range.moveStart(&quot;character&quot;, startIndex); </div><div class="t m0 x0 hb y2da1 ffa4 fs6 fc0 sc0 ls21 wsb">        range.moveEnd(&quot;character&quot;, stopIndex - startIndex); </div><div class="t m0 x0 hb y2da2 ffa4 fs6 fc0 sc0 ls21 wsb">        range.select();                     </div><div class="t m0 x0 hb y2da3 ffa4 fs6 fc0 sc0 ls21 wsb">    } </div></div></div>
<div id="pf1b9" class="pf w0 h0" data-page-no="1b9"><div class="pc pc1b9 w0 h0"><div class="t m0 x2 h2 y1 ff9d fs0 fc0 sc0 ls7 ws0">14.2 文本框脚本    423 </div><div class="t m0 x0 h3 y2 ff9d fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffa8 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ffa8 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffa8 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffa8 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffa8 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffa8 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffa8 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffa8 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffa8 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffa8 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffa8 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffa8 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ffa8 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y79 ffa4 fs6 fc0 sc0 ls21 wsb">    textbox.focus(); </div><div class="t m0 x0 hb y2da4 ffa4 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x2 hf y2da5 ffab fs2 fc0 sc0 ls25 wsb">TextboxPartialSelectionExample01.htm </div><div class="t m0 x0 h4 y2da6 ffa3 fs2 fc0 sc0 ls8 ws1">这个selectText()函数接收三个参数：要操作的文本框、要选择文本中第一个字符的索引和要选</div><div class="t m0 x0 h1e y2da7 ffa3 fs2 fc0 sc0 ls8 ws1">择文本中最后一个字符之后的索引。首先，函数测试了文本框是否包含setSelectionRange()方法。</div><div class="t m0 x0 h4 y2da8 ffa3 fs2 fc0 sc0 ls8 ws1">如果有，则使用该方法。否则，检测文本框是否支持createTextRange()方法。如果支持，则通过创</div><div class="t m0 x0 h4 y2da9 ffa3 fs2 fc0 sc0 ls8 ws1">建范围来实现选择。最后一步，就是为文本框设置焦点，以便用户看到文本框中选择的文本。可以像下</div><div class="t m0 x0 he y2daa ffa3 fs2 fc0 sc0 ls8 ws1">面这样使用selectText()方法。 </div><div class="t m0 x5 hb y1228 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2dab ffa4 fs6 fc0 sc0 ls21 wsb">textbox.value = &quot;Hello world!&quot; </div><div class="t m0 x0 hb y2dac ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2dad ffa4 fs6 fc0 sc0 ls21">//选择所有文本 </div><div class="t m0 x0 hb y2dae ffa4 fs6 fc0 sc0 ls21 wsb">selectText(textbox, 0, textbox.value.length); //&quot;Hello world!&quot; </div><div class="t m0 x0 hb y2daf ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2db0 ffa4 fs6 fc0 sc0 ls21">//选择前3个字符 </div><div class="t m0 x0 hb y2db1 ffa4 fs6 fc0 sc0 ls21 wsb">selectText(textbox, 0, 3);     //&quot;Hel&quot; </div><div class="t m0 x0 hb y2db2 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2db3 ffa4 fs6 fc0 sc0 ls21">//选择第4到第6个字符 </div><div class="t m0 x0 hb y2db4 ffa4 fs6 fc0 sc0 ls21 wsb">selectText(textbox, 4, 7);     //&quot;o w&quot; </div><div class="t m0 x5 hb y2db5 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1b3 ffa3 fs2 fc0 sc0 ls8 ws1">选择部分文本的技术在实现高级文本输入框时很有用，例如提供自动完成建议的文本框就可以使用</div><div class="t m0 x0 h5 y2db6 ffa3 fs2 fc0 sc0 ls8 ws1">这种技术。 </div><div class="t m0 x0 h20 y2db7 ffa1 fs3 fc0 sc0 ls248 ws214">14.2.2 过滤输入 </div><div class="t m0 x0 h4 y2862 ffa3 fs2 fc0 sc0 ls8 ws1">我们经常会要求用户在文本框中输入特定的数据，或者输入特定格式的数据。例如，必须包含某些</div><div class="t m0 x0 h4 y2db8 ffa3 fs2 fc0 sc0 ls8 ws1">字符，或者必须匹配某种模式。由于文本框在默认情况下没有提供多少验证数据的手段，因此必须使用</div><div class="t m0 x0 h5 y2db9 ff9d fs2 fc0 sc0 lsb ws5">JavaScript来完成此类过滤输入的操作。而综合运用事件和DOM手段，就可以将普通的文本框转换成能</div><div class="t m0 x0 h5 y2dba ffa3 fs2 fc0 sc0 ls8 ws1">够理解用户输入数据的功能型控件。 </div><div class="t m0 x0 h3c y2dbb ffa1 fs2 fc0 sc0 ls2e wsb">1. 屏蔽字符 </div><div class="t m0 x0 h4 y2dbc ffa3 fs2 fc0 sc0 ls8 ws1">有时候，我们需要用户输入的文本中包含或不包含某些字符。例如，电话号码中不能包含非数值字</div><div class="t m0 x0 hf7 y2dbd ffa3 fs2 fc0 sc0 ls8 ws1">符。如前所述，响应向文本框中插入字符操作的是keypress事件。因此，可以通过阻止这个事件的默</div><div class="t m0 x0 h5 y85d ffa3 fs2 fc0 sc0 ls8 ws1">认行为来屏蔽此类字符。在极端的情况下，可以通过下列代码屏蔽所有按键操作。 </div><div class="t m0 x5 hb y2dbe ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2dbf ffa4 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(textbox, &quot;keypress&quot;, function(event){ </div><div class="t m0 x0 hb y2dc0 ffa4 fs6 fc0 sc0 ls21 wsb">    event = EventUtil.getEvent(event); </div><div class="t m0 x0 hb y2dc1 ffa4 fs6 fc0 sc0 ls21 wsb">    EventUtil.preventDefault(event); </div><div class="t m0 x0 hb y2dc2 ffa4 fs6 fc0 sc0 ls21 wsb">});  </div><div class="t m0 x0 h4 y2dc3 ffa3 fs2 fc0 sc0 ls8 ws1">运行以上代码后，由于所有按键操作都将被屏蔽，结果会导致文本框变成只读的。如果只想屏蔽特</div><div class="t m0 x0 h1e y2dc4 ffa3 fs2 fc0 sc0 ls8 ws1">定的字符，则需要检测keypress事件对应的字符编码，然后再决定如何响应。例如，下列代码只允许</div><div class="t m0 x0 h5 y2dc5 ffa3 fs2 fc0 sc0 ls8 ws1">用户输入数值。 </div><div class="t m0 x5 hb y2dc6 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2dc7 ffa4 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(textbox, &quot;keypress&quot;, function(event){ </div><div class="t m0 x0 hb y2dc8 ffa4 fs6 fc0 sc0 ls21 wsb">    event = EventUtil.getEvent(event); </div><div class="t m0 x0 h15 y2dc9 ffaa fs6 fc0 sc0 ls21 wsb">    var target = EventUtil.getTarget(event); </div><div class="t m0 x0 h15 y2dca ffaa fs6 fc0 sc0 ls21 wsb">    var charCode = EventUtil.getCharCode(event); </div><div class="t m0 x0 h15 y2dcb ffaa fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y2dcc ffaa fs6 fc0 sc0 ls21 wsb">    if (!/\d/.test(String.fromCharCode(charCode))){ </div></div></div>
<div id="pf1ba" class="pf w0 h0" data-page-no="1ba"><div class="pc pc1ba w0 h0"><div class="t m0 x0 h2 y1 ff9d fs0 fc0 sc0 ls7 ws0">424  第14章 表单脚本 </div><div class="t m0 x0 h3 y2 ff9d fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y79 ffaa fs6 fc0 sc0 ls21 wsb">        EventUtil.preventDefault(event); </div><div class="t m0 x0 h15 y7a ffaa fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y7b ffa4 fs6 fc0 sc0 ls21 wsb">});  </div><div class="t m0 x0 h4 y2dcd ffa3 fs2 fc0 sc0 ls6 ws6">在这个例子中，我们使用EventUtil.getCharCode()实现了跨浏览器取得字符编码。然后，使</div><div class="t m0 x0 hc y2dce ffa3 fs2 fc0 sc0 ls151">用String.fromCharCode()将字符编码转换成字符串，再使用正则表达式 /\d/ 来测试该字符串，从</div><div class="t m0 x0 h4 y2dcf ffa3 fs2 fc0 sc0 ls8 ws1">而确定用户输入的是不是数值。如果测试失败，那么就使用EventUtil.preventDefault()屏蔽按键</div><div class="t m0 x0 h5 y2dd0 ffa3 fs2 fc0 sc0 ls8 ws1">事件。结果，文本框就会忽略所有输入的非数值。 </div><div class="t m0 x0 h1c y2dd1 ffa3 fs2 fc0 sc0 ls8 ws1">虽然理论上只应该在用户按下字符键时才触发keypress事件，但有些浏览器也会对其他键触发此</div><div class="t m0 x0 h5 y1d3f ffa3 fs2 fc0 sc0 ls8">事件。Firefox和Safari（3.1版本以前）会对向上键、向下键、退格键和删除键触发keypress 事件；</div><div class="t m0 x0 h5 y459 ff9d fs2 fc0 sc0 ls96 ws1cb">Safari 3.1及更新版本则不会对这些键触发keypress事件。这意味着，仅考虑到屏蔽不是数值的字符还</div><div class="t m0 x0 h5 y45a ffa3 fs2 fc0 sc0 ls8 ws1">不够，还要避免屏蔽这些极为常用和必要的键。所幸的是，要检测这些键并不困难。在Firefox中，所</div><div class="t m0 x0 he y2dd2 ffa3 fs2 fc0 sc0 ls8 ws1">有由非字符键触发的keypress事件对应的字符编码为0，而在Safari 3 以前的版本中，对应的字符编</div><div class="t m0 x0 h5 y1d42 ffa3 fs2 fc0 sc0 ls8 ws1">码全部为8。为了让代码更通用，只要不屏蔽那些字符编码小于10的键即可。故而，可以将上面的函数</div><div class="t m0 x0 h5 y2dd3 ffa3 fs2 fc0 sc0 ls8 ws1">重写成如下所示。 </div><div class="t m0 x0 hb y2dd4 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2dd5 ffa4 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(textbox, &quot;keypress&quot;, function(event){ </div><div class="t m0 x0 hb y2dd6 ffa4 fs6 fc0 sc0 ls21 wsb">    event = EventUtil.getEvent(event); </div><div class="t m0 x0 hb y2dd7 ffa4 fs6 fc0 sc0 ls21 wsb">    var target = EventUtil.getTarget(event); </div><div class="t m0 x0 hb y2dd8 ffa4 fs6 fc0 sc0 ls21 wsb">    var charCode = EventUtil.getCharCode(event); </div><div class="t m0 x0 hb y2dd9 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y2dda ffaa fs6 fc0 sc0 ls21 wsb">    if (!/\d/.test(String.fromCharCode(charCode)) &amp;&amp; charCode &gt; 9){ </div><div class="t m0 x0 hb y2ddb ffa4 fs6 fc0 sc0 ls21 wsb">        EventUtil.preventDefault(event); </div><div class="t m0 x0 hb y2ddc ffa4 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y2ddd ffa4 fs6 fc0 sc0 ls21 wsb">});  </div><div class="t m0 x0 h4 y2dde ffa3 fs2 fc0 sc0 ls8 ws1">这样，我们的事件处理程序就可以适用所有浏览器了，即可以屏蔽非数值字符，但不屏蔽那些也会</div><div class="t m0 x0 h5 y23e6 ffa3 fs2 fc0 sc0 ls8 ws1">触发keypress事件的基本按键。 </div><div class="t m0 x0 h5 y2ddf ffa3 fs2 fc0 sc0 ls8 ws1">除此之外，还有一个问题需要处理：复制、粘贴及其他操作还要用到Ctrl键。在除IE 之外的所有</div><div class="t m0 x0 h5 y2de0 ffa3 fs2 fc0 sc0 ls8 ws1">浏览器中，前面的代码也会屏蔽Ctrl+C、Ctrl+V，以及其他使用Ctrl的组合键。因此，最后还要添加一</div><div class="t m0 x0 h5 y2de1 ffa3 fs2 fc0 sc0 ls8 ws1">个检测条件，以确保用户没有按下Ctrl键，如下面的例子所示。 </div><div class="t m0 x0 hb y2abf ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2de2 ffa4 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(textbox, &quot;keypress&quot;, function(event){ </div><div class="t m0 x0 hb y2de3 ffa4 fs6 fc0 sc0 ls21 wsb">    event = EventUtil.getEvent(event); </div><div class="t m0 x0 hb y2de4 ffa4 fs6 fc0 sc0 ls21 wsb">    var target = EventUtil.getTarget(event); </div><div class="t m0 x0 hb y2de5 ffa4 fs6 fc0 sc0 ls21 wsb">    var charCode = EventUtil.getCharCode(event); </div><div class="t m0 x0 hb y2de6 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y2de7 ffaa fs6 fc0 sc0 ls21 wsb">    if (!/\d/.test(String.fromCharCode(charCode)) &amp;&amp; charCode &gt; 9 &amp;&amp; </div><div class="t m0 x0 h15 y2de8 ffaa fs6 fc0 sc0 ls21 wsb">             !event.ctrlKey){ </div><div class="t m0 x0 hb y2de9 ffa4 fs6 fc0 sc0 ls21 wsb">        EventUtil.preventDefault(event); </div><div class="t m0 x0 hb y2dea ffa4 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y2deb ffa4 fs6 fc0 sc0 ls21 wsb">});  </div><div class="t m0 x4 hf y2dec ffab fs2 fc0 sc0 ls1b wsb">TextboxInputFilteringExample01.htm </div><div class="t m0 x0 h4 y272d ffa3 fs2 fc0 sc0 ls8 ws1">经过最后一点修改，就可以确保文本框的行为完全正常了。在这个例子的基础上加以修改和调整，</div><div class="t m0 x0 h5 y2ded ffa3 fs2 fc0 sc0 ls8 ws1">就可以将同样的技术运用于放过和屏蔽任何输入文本框的字符。 </div><div class="t m0 x0 h3c y2dee ffa1 fs2 fc0 sc0 ls2e wsb">2. 操作剪贴板 </div><div class="t m0 x0 h5 y2def ff9d fs2 fc0 sc0 lse ws9">IE是第一个支持与剪贴板相关事件，以及通过JavaScript访问剪贴板数据的浏览器。IE的实现成为</div><div class="t m0 x0 h5 y2df0 ffa3 fs2 fc0 sc0 ls8 ws1">了事实上的标准，不仅Safari 2、Chrome和Firefox 3也都支持类似的事件和剪贴板访问（Opera不支持</div></div></div>
<div id="pf1bb" class="pf w0 h0" data-page-no="1bb"><div class="pc pc1bb w0 h0"><div class="t m0 x2 h2 y1 ff9d fs0 fc0 sc0 ls7 ws0">14.2 文本框脚本    425 </div><div class="t m0 x0 h3 y2 ff9d fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffa8 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ffa8 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffa8 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffa8 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffa8 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffa8 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffa8 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffa8 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffa8 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffa8 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffa8 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffa8 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ffa8 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ffa3 fs2 fc0 sc0 ls8 ws1">通过JavaScript访问剪贴板），HTML 5后来也把剪贴板事件纳入了规范。下列就是6个剪贴板事件。 </div><div class="t m0 x0 h5 y4 ffa2 fs1 fc0 sc0 ls2"> beforecopy：在发生复制操作前触发。 </div><div class="t m0 x0 h5 y4e ffa2 fs1 fc0 sc0 ls2"> copy：在发生复制操作时触发。 </div><div class="t m0 x0 h5 yd9 ffa2 fs1 fc0 sc0 ls2"> beforecut：在发生剪切操作前触发。 </div><div class="t m0 x0 h5 y219 ffa2 fs1 fc0 sc0 ls2"> cut：在发生剪切操作时触发。 </div><div class="t m0 x0 h5 y8 ffa2 fs1 fc0 sc0 ls2"> beforepaste：在发生粘贴操作前触发。 </div><div class="t m0 x0 h5 y9 ffa2 fs1 fc0 sc0 ls2"> paste：在发生粘贴操作时触发。 </div><div class="t m0 x0 h5 y15f ffa3 fs2 fc0 sc0 ls8 ws1">由于没有针对剪贴板操作的标准，这些事件及相关对象会因浏览器而异。在Safari、Chrome和Firefox</div><div class="t m0 x0 h1e y2df1 ffa3 fs2 fc0 sc0 ls8 ws1">中，beforecopy、beforecut和beforepaste事件只会在显示针对文本框的上下文菜单（预期将发</div><div class="t m0 x0 h5 y78a ffa3 fs2 fc0 sc0 ls8 ws1">生剪贴板事件）的情况下触发。但是，IE则会在触发copy、cut和paste事件之前先行触发这些事件。</div><div class="t m0 x0 h1e y116b ffa3 fs2 fc0 sc0 ls8 ws1">至于copy、cut和paste事件，只要是在上下文菜单中选择了相应选项，或者使用了相应的键盘组合</div><div class="t m0 x0 h5 ye ffa3 fs2 fc0 sc0 ls8 ws1">键，所有浏览器都会触发它们。 </div><div class="t m0 x0 h1e yf ffa3 fs2 fc0 sc0 ls8 ws1">在实际的事件发生之前，通过beforecopy、beforecut和beforepaste事件可以在向剪贴板发</div><div class="t m0 x0 h4 y116c ffa3 fs2 fc0 sc0 ls8 ws1">送数据，或者从剪贴板取得数据之前修改数据。不过，取消这些事件并不会取消对剪贴板的操作——只</div><div class="t m0 x0 he y26c5 ffa3 fs2 fc0 sc0 ls8 ws1">有取消copy、cut和paste事件，才能阻止相应操作发生。 </div><div class="t m0 x0 hc y12 ffa3 fs2 fc0 sc0 ls8 ws1">要访问剪贴板中的数据，可以使用clipboardData对象：在IE中 ，这个对象是window对象的</div><div class="t m0 x0 h5 y13 ffa3 fs2 fc0 sc0 ls8 ws1">属性；而在Firefox 4+、Safari和Chrome中，这个对象是相应event 对象的属性。但是，在Firefox、</div><div class="t m0 x0 h5 y14 ff9d fs2 fc0 sc0 ls48 ws39">Safari和Chorme中，只有在处理剪贴板事件期间clipboardData对象才有效，这是为了防止对剪贴板</div><div class="t m0 x0 h5 y24ab ffa3 fs2 fc0 sc0 ls8 ws1">的未授权访问；在IE中，则可以随时访问clipboardData 对象。为了确保跨浏览器兼容性，最好只</div><div class="t m0 x0 h5 y2df2 ffa3 fs2 fc0 sc0 ls8 ws1">在发生剪贴板事件期间使用这个对象。 </div><div class="t m0 x0 h1e y2df3 ffa3 fs2 fc0 sc0 ls1f ws15">这个clipboardData对象有三个方法：getData()、setData()和clearData()。其中，getData()</div><div class="t m0 x0 h5 y2df4 ffa3 fs2 fc0 sc0 ls1f ws15">用于从剪贴板中取得数据，它接受一个参数，即要取得的数据的格式。在IE中，有两种数据格式：&quot;text&quot;</div><div class="t m0 x0 h5 yc4 ffa3 fs2 fc0 sc0 ls6c">和&quot;URL&quot;。在Firefox、Safari和Chrome 中，这个参数是一种MIME类型；不过，可以用&quot;text&quot;代表</div><div class="t m0 x0 h5 y2df5 ffa4 fs1 fc0 sc0 ls20 ws16">&quot;text/plain&quot;。 </div><div class="t m0 x0 h1e y2df6 ffa3 fs2 fc0 sc0 ls8 ws1">类似地，setData()方法的第一个参数也是数据类型，第二个参数是要放在剪贴板中的文本。对于</div><div class="t m0 x0 h5 y2df7 ffa3 fs2 fc0 sc0 ls6">第一个参数，IE照样支持&quot;text&quot;和&quot;URL&quot;，而Safari和Chro me仍然只支持MIME类型。但是，与</div><div class="t m0 x0 h5 y2df8 ffa4 fs1 fc0 sc0 ls9 ws2">getData()方法不同的是，Safari和Chrome的setData()方法不能识别&quot;text&quot;类型。这两个浏览器在</div><div class="t m0 x0 h1e y2df9 ffa3 fs2 fc0 sc0 ls24 ws1e">成功将文本放到剪贴板中后，都会返回true；否则，返回false。为了弥合这些差异，我们可以向</div><div class="t m0 x0 h5 y272a ffa4 fs1 fc0 sc0 ls9 ws2">EventUtil中再添加下列方法。 </div><div class="t m0 x5 hb y77f ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y780 ffa4 fs6 fc0 sc0 ls21 wsb">var EventUtil = { </div><div class="t m0 x0 hb y781 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2dfa ffa4 fs6 fc0 sc0 ls21 wsb">    //省略的代码 </div><div class="t m0 x0 hb y783 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y2dfb ffaa fs6 fc0 sc0 ls21 wsb">    getClipboardText: function(event){ </div><div class="t m0 x0 h15 y2dfc ffaa fs6 fc0 sc0 ls21 wsb">        var clipboardData = (event.clipboardData || window.clipboardData); </div><div class="t m0 x0 h15 y2dfd ffaa fs6 fc0 sc0 ls21 wsb">        return clipboardData.getData(&quot;text&quot;); </div><div class="t m0 x0 h15 y2dfe ffaa fs6 fc0 sc0 ls21 wsb">    }, </div><div class="t m0 x0 hb y2dff ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2e00 ffa4 fs6 fc0 sc0 ls21 wsb">    //省略的代码 </div><div class="t m0 x0 hb y2e01 ffa4 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 h15 y2e02 ffaa fs6 fc0 sc0 ls21 wsb">    setClipboardText: function(event, value){ </div><div class="t m0 x0 h15 y2e03 ffaa fs6 fc0 sc0 ls21 wsb">        if (event.clipboardData){ </div><div class="t m0 x0 h15 y2e04 ffaa fs6 fc0 sc0 ls21 wsb">            return event.clipboardData.setData(&quot;text/plain&quot;, value); </div></div></div>
<div id="pf1bc" class="pf w0 h0" data-page-no="1bc"><div class="pc pc1bc w0 h0"><div class="t m0 x0 h2 y1 ff9d fs0 fc0 sc0 ls7 ws0">426  第14章 表单脚本 </div><div class="t m0 x0 h3 y2 ff9d fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y79 ffaa fs6 fc0 sc0 ls21 wsb">        } else if (window.clipboardData){ </div><div class="t m0 x0 h15 y7a ffaa fs6 fc0 sc0 ls21 wsb">            return window.clipboardData.setData(&quot;text&quot;, value); </div><div class="t m0 x0 h15 y7b ffaa fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 h15 y7c ffaa fs6 fc0 sc0 ls21 wsb">    }, </div><div class="t m0 x0 hb ye14 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 yd6c ffa4 fs6 fc0 sc0 ls21 wsb">    //省略的代码 </div><div class="t m0 x0 hb y2e06 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2e07 ffa4 fs6 fc0 sc0 ls21 wsb">};  </div><div class="t m0 x2 hf y28cd ffab fs2 fc0 sc0 ls2b wsb">EventUtil.js </div><div class="t m0 x0 h4 y28ce ffa3 fs2 fc0 sc0 ls8 ws1">这里的getClipboardText()方法相对简单；它只要确定clipboardData对象的位置，然后再</div><div class="t m0 x0 h1e y28cf ffa3 fs2 fc0 sc0 ls8 ws1">以&quot;text&quot;类型调用getData()方法即可。相应地，setClipboardText()方法则要稍微复杂一些。在</div><div class="t m0 x0 hc y2e08 ffa3 fs2 fc0 sc0 ls8 ws1">取得clipboardData对象之后，需要根据不同的浏览器实现为setData()传入不同的类型（对于Safari</div><div class="t m0 x0 hc y2e09 ffa3 fs2 fc0 sc0 ls3b">和Chrome，是&quot;text/plain&quot;；对于IE，是&quot;text&quot;）。 </div><div class="t m0 x0 h4 y2e0a ffa3 fs2 fc0 sc0 ls1f ws15">在需要确保粘贴到文本框中的文本中包含某些字符，或者符合某种格式要求时，能够访问剪贴板是非</div><div class="t m0 x0 h4 y2e0b ffa3 fs2 fc0 sc0 ls44 ws32">常有用的。例如，如果一个文本框只接受数值，那么就必须检测粘贴过来的值，以确保有效。在paste</div><div class="t m0 x0 h5 y2e0c ffa3 fs2 fc0 sc0 ls1f">事件中，可以确定剪贴板中的值是否有效，如果无效，就可以像下面示例中那样，取消默认的行为。 </div><div class="t m0 x0 hb y2e0d ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2e0e ffa4 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(textbox, &quot;paste&quot;, function(event){ </div><div class="t m0 x0 hb y2e0f ffa4 fs6 fc0 sc0 ls21 wsb">    event = EventUtil.getEvent(event); </div><div class="t m0 x0 hb y2e10 ffa4 fs6 fc0 sc0 ls21 wsb">    var text = EventUtil.getClipboardText(event); </div><div class="t m0 x0 h28 y2e11 ffa4 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2325 ffa4 fs6 fc0 sc0 ls21 wsb">    if (!/^\d*$/.test(text)){ </div><div class="t m0 x0 hb y2e12 ffa4 fs6 fc0 sc0 ls21 wsb">        EventUtil.preventDefault(event); </div><div class="t m0 x0 hb y2e13 ffa4 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y2e14 ffa4 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 hb y2e15 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y2e16 ffab fs2 fc0 sc0 ls25 wsb">TextboxClipboardExample01.htm </div><div class="t m0 x0 h4 y2bda ffa3 fs2 fc0 sc0 ls6 ws6">在这里，onpaste事件处理程序可以确保只有数值才会被粘贴到文本框中。如果剪贴板的值与正</div><div class="t m0 x0 h5 y2e17 ffa3 fs2 fc0 sc0 ls8 ws1">则表达式不匹配，则会取消粘贴操作。Firefox、Safari和Chrome只允许在onpaste事件处理程序中访</div><div class="t m0 x0 hc y2e18 ffa3 fs2 fc0 sc0 ls3a3">问getData()方法。 </div><div class="t m0 x0 h4 y2e19 ffa3 fs2 fc0 sc0 ls24 ws1e">由于并非所有浏览器都支持访问剪贴板，所以更简单的做法是屏蔽一或多个剪贴板操作。在支持</div><div class="t m0 x0 h5 y2e1a ffa4 fs1 fc0 sc0 ls9 ws2">copy、cut和paste事件的浏览器中（IE、Safari、Chrome和Firefox 3及更高版本），很容易阻止这些</div><div class="t m0 x0 h5 y2e1b ffa3 fs2 fc0 sc0 ls8 ws1">事件的默认行为。在Opera中，则需要阻止那些会触发这些事件的按键操作，同时还要阻止在文本框中</div><div class="t m0 x0 h5 y2e1c ffa3 fs2 fc0 sc0 ls8 ws1">显示上下文菜单。 </div><div class="t m0 x0 h20 y282 ffa1 fs3 fc0 sc0 ls248 ws214">14.2.3 自动切换焦点 </div><div class="t m0 x0 h5 y2e1d ffa3 fs2 fc0 sc0 ls8 ws1">使用JavaScript可以从多个方面增强表单字段的易用性。其中，最常见的一种方式就是在用户填写</div><div class="t m0 x0 h4 y349 ffa3 fs2 fc0 sc0 ls8 ws1">完当前字段时，自动将焦点切换到下一个字段。通常，在自动切换焦点之前，必须知道用户已经输入了</div><div class="t m0 x0 h5 y2e1e ffa3 fs2 fc0 sc0 ls8 ws1">既定长度的数据（例如电话号码）。例如，美国的电话号码通常会分为三部分：区号、局号和另外4位</div><div class="t m0 x0 h5 y2e1f ffa3 fs2 fc0 sc0 ls8 ws1">数字。为取得完整的电话号码，很多网页中都会提供下列3个文本框： </div><div class="t m0 x0 hb y1a4 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2e20 ffa4 fs6 fc0 sc0 ls21 wsb">&lt;input type=&quot;text&quot; name=&quot;tel1&quot; id=&quot;txtTel1&quot; maxlength=&quot;3&quot;&gt; </div><div class="t m0 x0 hb y2e21 ffa4 fs6 fc0 sc0 ls21 wsb">&lt;input type=&quot;text&quot; name=&quot;tel2&quot; id=&quot;txtTel2&quot; maxlength=&quot;3&quot;&gt; </div><div class="t m0 x0 hb y2e22 ffa4 fs6 fc0 sc0 ls21 wsb">&lt;input type=&quot;text&quot; name=&quot;tel3&quot; id=&quot;txtTel3&quot; maxlength=&quot;4&quot;&gt; </div><div class="t m0 x4 hf y126c ffab fs2 fc0 sc0 ls8 wsb">TextboxTabForwardExample01.htm </div></div></div>
<div id="pf1bd" class="pf w0 h0" data-page-no="1bd"><div class="pc pc1bd w0 h0"><div class="t m0 x2 h2 y1 ff9d fs0 fc0 sc0 ls7 ws0">14.2 文本框脚本    427 </div><div class="t m0 x0 h3 y2 ff9d fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffa8 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ffa8 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffa8 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffa8 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffa8 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffa8 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffa8 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffa8 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffa8 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffa8 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffa8 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffa8 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ffa8 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h4 y3 ffa3 fs2 fc0 sc0 ls8 ws1">为增强易用性，同时加快数据输入，可以在前一个文本框中的字符达到最大数量后，自动将焦点切</div><div class="t m0 x0 h5 y4d ffa3 fs2 fc0 sc0 ls8 ws1">换到下一个文本框。换句话说，用户在第一个文本框中输入了3个数字之后，焦点就会切换到第二个文</div><div class="t m0 x0 h5 yd8 ffa3 fs2 fc0 sc0 ls8 ws1">本框，再输入3个数字，焦点又会切换到第三个文本框。这种“自动切换焦点”的功能，可以通过下列</div><div class="t m0 x0 h5 y28b ffa3 fs2 fc0 sc0 ls8 ws1">代码实现： </div><div class="t m0 x5 hb ya81 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2ba5 ffa4 fs6 fc0 sc0 ls21 wsb">(function(){ </div><div class="t m0 x0 hb y2e23 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2e24 ffa4 fs6 fc0 sc0 ls21 wsb">    function tabForward(event){ </div><div class="t m0 x0 hb y2e25 ffa4 fs6 fc0 sc0 ls21 wsb">        event = EventUtil.getEvent(event); </div><div class="t m0 x0 hb y2e26 ffa4 fs6 fc0 sc0 ls21 wsb">        var target = EventUtil.getTarget(event); </div><div class="t m0 x0 hb y2e27 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2e28 ffa4 fs6 fc0 sc0 ls21 wsb">        if (target.value.length == target.maxLength){ </div><div class="t m0 x0 hb y2e29 ffa4 fs6 fc0 sc0 ls21 wsb">            var form = target.form; </div><div class="t m0 x0 hb y2e2a ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2e2b ffa4 fs6 fc0 sc0 ls21 wsb">            for (var i=0, len=form.elements.length; i &lt; len; i++) { </div><div class="t m0 x0 hb y2e2c ffa4 fs6 fc0 sc0 ls21 wsb">                if (form.elements[i] == target) { </div><div class="t m0 x0 hb y2e2d ffa4 fs6 fc0 sc0 ls21 wsb">                    if (form.elements[i+1]){ </div><div class="t m0 x0 hb y2e2e ffa4 fs6 fc0 sc0 ls21 wsb">                        form.elements[i+1].focus(); </div><div class="t m0 x0 hb y2e2f ffa4 fs6 fc0 sc0 ls21 wsb">                    } </div><div class="t m0 x0 hb y2e30 ffa4 fs6 fc0 sc0 ls21 wsb">                    return; </div><div class="t m0 x0 hb y2e31 ffa4 fs6 fc0 sc0 ls21 wsb">                } </div><div class="t m0 x0 hb y2e32 ffa4 fs6 fc0 sc0 ls21 wsb">            } </div><div class="t m0 x0 hb y2e33 ffa4 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y2e34 ffa4 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y2e35 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2e36 ffa4 fs6 fc0 sc0 ls21 wsb">    var textbox1 = document.getElementById(&quot;txtTel1&quot;); </div><div class="t m0 x0 hb y2e37 ffa4 fs6 fc0 sc0 ls21 wsb">    var textbox2 = document.getElementById(&quot;txtTel2&quot;); </div><div class="t m0 x0 hb y2e38 ffa4 fs6 fc0 sc0 ls21 wsb">    var textbox3 = document.getElementById(&quot;txtTel3&quot;); </div><div class="t m0 x0 hb y2e39 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2e3a ffa4 fs6 fc0 sc0 ls21 wsb">    EventUtil.addHandler(textbox1, &quot;keyup&quot;, tabForward); </div><div class="t m0 x0 hb y2e3b ffa4 fs6 fc0 sc0 ls21 wsb">    EventUtil.addHandler(textbox2, &quot;keyup&quot;, tabForward); </div><div class="t m0 x0 hb y2e3c ffa4 fs6 fc0 sc0 ls21 wsb">    EventUtil.addHandler(textbox3, &quot;keyup&quot;, tabForward); </div><div class="t m0 x0 hb y2e3d ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2e3e ffa4 fs6 fc0 sc0 ls21 wsb">})(); </div><div class="t m0 x5 hb y2e3f ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y2e40 ffab fs2 fc0 sc0 ls8 wsb">TextboxTabForwardExample01.htm </div><div class="t m0 x0 h4 y2e41 ffa3 fs2 fc0 sc0 ls8 ws1">开始的tabForward()函数是实现“自动切换焦点”的关键所在。这个函数通过比较用户输入的值</div><div class="t m0 x0 h1e y2e42 ffa3 fs2 fc0 sc0 ls8 ws1">与文本框的maxlength特性，可以确定是否已经达到最大长度。如果这两个值相等（因为浏览器最终</div><div class="t m0 x0 h4 y2e43 ffa3 fs2 fc0 sc0 ls6 ws6">会强制它们相等，因此用户绝不会多输入字符），则需要查找表单字段集合，直至找到下一个文本框。</div><div class="t m0 x0 h4 y2e44 ffa3 fs2 fc0 sc0 ls8 ws1">找到下一个文本框之后，则将焦点切换到该文本框。然后，我们把这个函数指定为每个文本框的 onkeyup</div><div class="t m0 x0 h4 y2e45 ffa3 fs2 fc0 sc0 ls8 ws1">事件处理程序。由于keyup事件会在用户输入了新字符之后触发，所以此时是检测文本框中内容长度</div><div class="t m0 x0 h4 y26f1 ffa3 fs2 fc0 sc0 ls8 ws1">的最佳时机。这样一来，用户在填写这个简单的表单时，就不必再通过按制表键切换表单字段和提交表</div><div class="t m0 x0 h5 y2e46 ffa3 fs2 fc0 sc0 ls8">单了。 </div><div class="t m0 x0 h5 y2e47 ffa3 fs2 fc0 sc0 ls8 ws1">不过请记住，这些代码只适用于前面给出的标记，而且没有考虑隐藏字段。 </div><div class="t m0 x0 h20 y1181 ffa1 fs3 fc0 sc0 ls248 ws214">14.2.4 HTML5约束验证API </div><div class="t m0 x0 h5 y2e48 ffa3 fs2 fc0 sc0 ls8 ws1">为了在将表单提交到服务器之前验证数据，HTML5新增了一些功能。有了这些功能，即便JavaScript</div><div class="t m0 x0 h4 y25ab ffa3 fs2 fc0 sc0 ls8 ws1">被禁用或者由于种种原因未能加载，也可以确保基本的验证。换句话说，浏览器自己会根据标记中的规</div><div class="t m0 x0 h5 y2e49 ffa3 fs2 fc0 sc0 ls6 ws6">则执行验证，然后自己显示适当的错误消息（完全不用JavaScript插手）。当然，这个功能只有在支持</div><div class="t m0 x0 h5 y2e4a ff9d fs2 fc0 sc0 ls2f ws8a">HTML5这部分内容的浏览器中才有效，这些浏览器有Firefox 4+、Safari 5+、Chrome和Opera 10+。 </div></div></div>
<div id="pf1be" class="pf w0 h0" data-page-no="1be"><div class="pc pc1be w0 h0"><div class="t m0 x0 h2 y1 ff9d fs0 fc0 sc0 ls7 ws0">428  第14章 表单脚本 </div><div class="t m0 x0 h3 y2 ff9d fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ffa3 fs2 fc0 sc0 ls8 ws1">只有在某些情况下表单字段才能进行自动验证。具体来说，就是要在HTML标记中为特定的字段</div><div class="t m0 x0 h5 y4d ffa3 fs2 fc0 sc0 ls8 ws1">指定一些约束，然后浏览器才会自动执行表单验证。 </div><div class="t m0 x0 h3c y2e4b ffa1 fs2 fc0 sc0 ls2e wsb">1. 必填字段 </div><div class="t m0 x0 hf9 y2e4c ffa3 fs2 fc0 sc0 ls8 ws1">第一种情况是在表单字段中指定了required属性，如下面的例子所示： </div><div class="t m0 x0 hb y2e4d ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2e4e ffa4 fs6 fc0 sc0 ls21 wsb">&lt;input type=&quot;text&quot; name=&quot;username&quot; required&gt; </div><div class="t m0 x0 hb y2e4f ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y2e50 ffa3 fs2 fc0 sc0 ls8 ws1">任何标注有required的字段，在提交表单时都不能空着。这个属性适用于&lt;input&gt;、&lt;textarea&gt;</div><div class="t m0 x0 h5 y2e51 ffa3 fs2 fc0 sc0 ls8 ws1">和&lt;select&gt;字段（Opera 11及之前版本还不支持&lt;select&gt;的required属性）。在JavaScript中，通过</div><div class="t m0 x0 hc y2e52 ffa3 fs2 fc0 sc0 ls8 ws1">对应的required属性，可以检查某个表单字段是否为必填字段。 </div><div class="t m0 x0 hb y2e53 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2e54 ffa4 fs6 fc0 sc0 ls21 wsb">var isUsernameRequired = document.forms[0].elements[&quot;username&quot;].required; </div><div class="t m0 x0 hb y2e55 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y2e56 ffa3 fs2 fc0 sc0 ls8 ws1">另外，使用下面这行代码可以测试浏览器是否支持required属性。 </div><div class="t m0 x0 hfa y2e57 ffae fs15 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y94f ffa4 fs6 fc0 sc0 ls21 wsb">var isRequiredSupported = &quot;required&quot; in document.createElement(&quot;input&quot;); </div><div class="t m0 x0 h5 y2e58 ff9d fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb5 y2e59 ffa3 fs2 fc0 sc0 ls8 ws1">以上代码通过特性检测来确定新创建的&lt;input&gt;元素中是否存在required属性。 </div><div class="t m0 x0 h5 y2e5a ffa3 fs2 fc0 sc0 ls8 ws1">对于空着的必填字段，不同浏览器有不同的处理方式。Firefox 4和Opera 11会阻止表单提交并在相</div><div class="t m0 x0 h5 y2e5b ffa3 fs2 fc0 sc0 ls8 ws1">应字段下方弹出帮助框，而Safari（5之前）和Chrome（9之前）则什么也不做，而且也不阻止表单提</div><div class="t m0 x0 h5 y2e5c ffa3 fs2 fc0 sc0 ls8">交。 </div><div class="t m0 x0 h3c y2e5d ffa1 fs2 fc0 sc0 ls2e wsb">2. 其他输入类型 </div><div class="t m0 x0 h5 y2e5e ff9d fs2 fc0 sc0 ls2f ws8a">HTML5为&lt;input&gt;元素的type属性又增加了几个值。这些新的类型不仅能反映数据类型的信息，</div><div class="t m0 x0 h4 y2e5f ffa3 fs2 fc0 sc0 ls8 ws1">而且还能提供一些默认的验证功能。其中，&quot;email&quot;和&quot;url&quot;是两个得到支持最多的类型，各浏览器也</div><div class="t m0 x0 h5 y2e60 ffa3 fs2 fc0 sc0 ls8 ws1">都为它们增加了定制的验证机制。例如： </div><div class="t m0 x0 hb y22b ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2e61 ffa4 fs6 fc0 sc0 ls21 wsb">&lt;input type=&quot;email&quot; name =&quot;email&quot;&gt; </div><div class="t m0 x0 hb y2e62 ffa4 fs6 fc0 sc0 ls21 wsb">&lt;input type=&quot;url&quot; name=&quot;homepage&quot;&gt; </div><div class="t m0 x0 hb y2e63 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3c1 ffa3 fs2 fc0 sc0 ls8 ws1">顾名思义，&quot;email&quot;类型要求输入的文本必须符合电子邮件地址的模式，而&quot;url&quot;类型要求输入的</div><div class="t m0 x0 h5 y2e64 ffa3 fs2 fc0 sc0 ls8 ws1">文本必须符合URL的模式。不过，本节前面提到的浏览器在恰当地匹配模式方面都存在问题。最明显</div><div class="t m0 x0 hc y2e65 ffa3 fs2 fc0 sc0 ls8 ws1">的是&quot;-@-&quot;会被当成一个有效的电子邮件地址。浏览器开发商还在解决这些问题。 </div><div class="t m0 x0 h5 y2e66 ffa3 fs2 fc0 sc0 ls8 ws1">要检测浏览器是否支持这些新类型，可以在JavaScript创建一个&lt;input&gt;元素，然后将type 属性</div><div class="t m0 x0 h1e y2e67 ffa3 fs2 fc0 sc0 ls8 ws1">设置为&quot;email&quot;或&quot;url&quot;，最后再检测这个属性的值。不支持它们的旧版本浏览器会自动将未知的值设</div><div class="t m0 x0 h5 y21d0 ffa3 fs2 fc0 sc0 ls8 ws1">置为&quot;text&quot;，而支持的浏览器则会返回正确的值。例如： </div><div class="t m0 x0 hb y2e68 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2e69 ffa4 fs6 fc0 sc0 ls21 wsb">var input = document.createElement(&quot;input&quot;); </div><div class="t m0 x0 hb y2e6a ffa4 fs6 fc0 sc0 ls21 wsb">input.type = &quot;email&quot;; </div><div class="t m0 x0 hb y2e6b ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2e6c ffa4 fs6 fc0 sc0 ls21 wsb">var isEmailSupported = (input.type == &quot;email&quot;); </div><div class="t m0 x0 hb y2e6d ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y34c ffa3 fs2 fc0 sc0 ls8 ws1">要注意的是，如果不给&lt;input&gt;元素设置required属性，那么空文本框也会验证通过。另一方面，</div><div class="t m0 x0 h5 y2e6e ffa3 fs2 fc0 sc0 ls8 ws1">设置特定的输入类型并不能阻止用户输入无效的值，只是应用某些默认的验证而已。 </div><div class="t m0 x0 h3c y2e6f ffa1 fs2 fc0 sc0 ls2e wsb">3. 数值范围 </div><div class="t m0 x0 hfb y2e70 ffa3 fs2 fc0 sc0 ls6 ws6">除了&quot;email&quot;和&quot;url&quot;，HTML5还定义了另外几个输入元素。这几个元素都要求填写某种基于数</div></div></div>
<div id="pf1bf" class="pf w0 h0" data-page-no="1bf"><div class="pc pc1bf w0 h0"><div class="t m0 x2 h2 y1 ff9d fs0 fc0 sc0 ls7 ws0">14.2 文本框脚本    429 </div><div class="t m0 x0 h3 y2 ff9d fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffa8 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ffa8 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffa8 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffa8 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffa8 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffa8 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffa8 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffa8 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffa8 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffa8 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffa8 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffa8 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ffa8 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h4 y3 ffa3 fs2 fc0 sc0 ls8 ws1">字的值：&quot;number&quot;、&quot;range&quot;、&quot;datetime&quot;、&quot;datetime-local&quot;、&quot;date&quot;、&quot;month&quot;、&quot;week&quot;，</div><div class="t m0 x0 h1e y4d ffa3 fs2 fc0 sc0 ls6 ws6">还有&quot;time&quot;。浏览器对这几个类型的支持情况并不好，因此如果真想选用的话，要特别小心。目前，</div><div class="t m0 x0 h4 y5 ffa3 fs2 fc0 sc0 ls8 ws1">浏览器开发商主要关注更好的跨平台兼容性以及更多的逻辑功能。因此，本节介绍的内容某种程度上有</div><div class="t m0 x0 h5 y6 ffa3 fs2 fc0 sc0 ls8 ws1">些超前，不一定马上就能在实际开发中使用。 </div><div class="t m0 x0 h1c y7 ffa3 fs2 fc0 sc0 ls8 ws1">对所有这些数值类型的输入元素，可以指定min属性（最小的可能值）、max属性（最大的可能值）</div><div class="t m0 x0 hc y21a ffa3 fs2 fc0 sc0 ls3a6">和step属性（从min到max的两个刻度间的差值）。例如，想让用户只能输入0到100的值，而且这</div><div class="t m0 x0 h5 y15e ffa3 fs2 fc0 sc0 ls8 ws1">个值必须是5的倍数，可以这样写代码： </div><div class="t m0 x0 hb y970 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y971 ffa4 fs6 fc0 sc0 ls21 wsb">&lt;input type=&quot;number&quot; min=&quot;0&quot; max=&quot;100&quot; step=&quot;5&quot; name=&quot;count&quot;&gt; </div><div class="t m0 x0 hb y2e71 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1aef ffa3 fs2 fc0 sc0 ls24 ws1e">在不同的浏览器中，可能会也可能不会看到能够自动递增和递减的数值调节按钮（向上和向下按</div><div class="t m0 x0 h5 y2e72 ffa3 fs2 fc0 sc0 ls8 ws1">钮）。 </div><div class="t m0 x0 h5 y2e73 ffa3 fs2 fc0 sc0 ls8 ws1">以上这些属性在JavaScript中都能通过对应的元素访问（或修改）。此外，还有两个方法：stepUp()</div><div class="t m0 x0 h5 y42c ffa3 fs2 fc0 sc0 lsb4">和stepDown()，都接收一个可选的参数：要在当前值基础上加上或减去的数值。（默认是加或减1。）</div><div class="t m0 x0 h5 y2e74 ffa3 fs2 fc0 sc0 ls8 ws1">这两个方法还没有得到任何浏览器支持，但下面的例子演示了它们的用法。 </div><div class="t m0 x0 hb y2e75 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2e76 ffa4 fs6 fc0 sc0 ls21 wsb">input.stepUp();     //加1 </div><div class="t m0 x0 h16 y2e77 ffa4 fs6 fc0 sc0 ls21 wsb">input.stepUp(5);    //加5 </div><div class="t m0 x0 h16 y2e78 ffa4 fs6 fc0 sc0 ls21 wsb">input.stepDown();   //减1 </div><div class="t m0 x0 h16 y2e79 ffa4 fs6 fc0 sc0 ls21 wsb">input.stepDown(10); //减10 </div><div class="t m0 x0 hb y2e7a ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h3c y154a ffa1 fs2 fc0 sc0 ls2e wsb">4. 输入模式 </div><div class="t m0 x0 h5 y2e7b ff9d fs2 fc0 sc0 ls2f ws8a">HTML5为文本字段新增了pattern属性。这个属性的值是一个正则表达式，用于匹配文本框中的</div><div class="t m0 x0 h5 y2613 ffa3 fs2 fc0 sc0 ls8 ws1">值。例如，如果只想允许在文本字段中输入数值，可以像下面的代码一样应用约束： </div><div class="t m0 x0 hb ya77 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2e7c ffa4 fs6 fc0 sc0 ls21 wsb">&lt;input type=&quot;text&quot; pattern=&quot;\d+&quot; name=&quot;count&quot;&gt; </div><div class="t m0 x0 hb y2e7d ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y2e7e ffa3 fs2 fc0 sc0 ls6 ws6">注意，模式的开头和末尾不用加^和$符号（假定已经有了）。这两个符号表示输入的值必须从头到</div><div class="t m0 x0 h5 y2e7f ffa3 fs2 fc0 sc0 ls8 ws1">尾都与模式匹配。 </div><div class="t m0 x0 h1e y2e80 ffa3 fs2 fc0 sc0 ls8 ws1">与其他输入类型相似，指定pattern也不能阻止用户输入无效的文本。这个模式应用给值，浏览</div><div class="t m0 x0 hc y2e81 ffa3 fs2 fc0 sc0 ls8 ws1">器来判断值是有效，还是无效。在JavaScript中可以通过pattern属性访问模式。 </div><div class="t m0 x0 hfa y2e82 ffae fs15 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2217 ffa4 fs6 fc0 sc0 ls21 wsb">var pattern = document.forms[0].elements[&quot;count&quot;].pattern; </div><div class="t m0 x0 h5 y2e83 ff9d fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h2a y2e84 ffa3 fs2 fc0 sc0 ls8 ws1">使用以下代码可以检测浏览器是否支持pattern属性。 </div><div class="t m0 x0 hfa y2e85 ffae fs15 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2e86 ffa4 fs6 fc0 sc0 ls21 wsb">var isPatternSupported = &quot;pattern&quot; in document.createElement(&quot;input&quot;); </div><div class="t m0 x0 h5 y3f ff9d fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h3c y2e87 ffa1 fs2 fc0 sc0 ls2e wsb">5. 检测有效性 </div><div class="t m0 x0 h4 y2e88 ffa3 fs2 fc0 sc0 ls8 ws1">使用checkValidity()方法可以检测表单中的某个字段是否有效。所有表单字段都有个方法，如</div><div class="t m0 x0 h1e y2e89 ffa3 fs2 fc0 sc0 ls8 ws1">果字段的值有效，这个方法返回true，否则返回false。字段的值是否有效的判断依据是本节前面介</div><div class="t m0 x0 h1e y1b2f ffa3 fs2 fc0 sc0 ls8 ws1">绍过的那些约束。换句话说，必填字段中如果没有值就是无效的，而字段中的值与pattern属性不匹</div><div class="t m0 x0 h5 ycb5 ffa3 fs2 fc0 sc0 ls8 ws1">配也是无效的。例如： </div><div class="t m0 x0 hb y2e8a ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2e8b ffa4 fs6 fc0 sc0 ls21 wsb">if (document.forms[0].elements[0].checkValidity()){ </div><div class="t m0 x0 h16 y2e8c ffa4 fs6 fc0 sc0 ls21 wsb">    //字段有效，继续  </div><div class="t m0 x0 hb y2e8d ffa4 fs6 fc0 sc0 ls21 wsb">} else { </div><div class="t m0 x0 h16 y2e8e ffa4 fs6 fc0 sc0 ls21 wsb">    //字段无效 </div><div class="t m0 x0 hb y2e8f ffa4 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y2e90 ffa4 fs6 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf1c0" class="pf w0 h0" data-page-no="1c0"><div class="pc pc1c0 w0 h0"><div class="t m0 x0 h2 y1 ff9d fs0 fc0 sc0 ls7 ws0">430  第14章 表单脚本 </div><div class="t m0 x0 h3 y2 ff9d fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ffa3 fs2 fc0 sc0 ls8 ws1">要检测整个表单是否有效，可以在表单自身调用checkValidity()方法。如果所有表单字段都有</div><div class="t m0 x0 hc y4d ffa3 fs2 fc0 sc0 ls8 ws1">效，这个方法返回true；即使有一个字段无效，这个方法也会返回false。 </div><div class="t m0 x0 hb y1701 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2984 ffa4 fs6 fc0 sc0 ls21 wsb">if(document.forms[0].checkValidity()){ </div><div class="t m0 x0 h16 y2985 ffa4 fs6 fc0 sc0 ls21 wsb">    //表单有效，继续 </div><div class="t m0 x0 hb y2986 ffa4 fs6 fc0 sc0 ls21 wsb">} else { </div><div class="t m0 x0 h16 y2987 ffa4 fs6 fc0 sc0 ls21 wsb">    //表单无效 </div><div class="t m0 x0 hb y2988 ffa4 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y2e91 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y2e92 ffa3 fs2 fc0 sc0 ls13e">与checkValidity()方法简单地告诉你字段是否有效相比，validity属性则会告诉你为什么字</div><div class="t m0 x0 h5 y2e93 ffa3 fs2 fc0 sc0 ls8 ws1">段有效或无效。这个对象中包含一系列属性，每个属性会返回一个布尔值。 </div><div class="t m0 x0 h5 y2e94 ffa2 fs1 fc0 sc0 ls8 ws134"> customError ：如果设置了setCustomValidity()，则为true，否则返回false。 </div><div class="t m0 x0 h5 y2e95 ffa2 fs1 fc0 sc0 ls8 ws134"> patternMismatch：如果值与指定的pattern属性不匹配，返回true。 </div><div class="t m0 x0 h5 y2e96 ffa2 fs1 fc0 sc0 ls8 ws134"> rangeOverflow：如果值比max值大，返回true。 </div><div class="t m0 x0 h5 y2e97 ffa2 fs1 fc0 sc0 ls8 ws134"> rangeUnderflow：如果值比min值小，返回true。 </div><div class="t m0 x0 h5 y296 ffa2 fs1 fc0 sc0 ls8 ws134"> stepMisMatch：如果min和max之间的步长值不合理，返回true。 </div><div class="t m0 x0 h5 y1efb ffa2 fs1 fc0 sc0 ls8 ws134"> tooLong：如果值的长度超过了maxlength属性指定的长度，返回true。有的浏览器（如Firefox 4）</div><div class="t m0 x0 h5 y2e98 ffa3 fs2 fc0 sc0 lse2 wsb5">会自动约束字符数量，因此这个值可能永远都返回false。 </div><div class="t m0 x0 h5 y2e99 ffa2 fs1 fc0 sc0 ls8 ws134"> typeMismatch：如果值不是&quot;mail&quot;或&quot;url&quot;要求的格式，返回true。 </div><div class="t m0 x0 h5 y2e9a ffa2 fs1 fc0 sc0 ls8 ws134"> valid：如果这里的其他属性都是false，返回true。checkValidity()也要求相同的值。 </div><div class="t m0 x0 h5 y1757 ffa2 fs1 fc0 sc0 ls8 ws134"> valueMissing：如果标注为required的字段中没有值，返回true。 </div><div class="t m0 x0 hc y2e9b ffa3 fs2 fc0 sc0 ls8 ws1">因此，要想得到更具体的信息，就应该使用validity属性来检测表单的有效性。下面是一个例子。 </div><div class="t m0 x0 hb yfee ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2e9c ffa4 fs6 fc0 sc0 ls21 wsb">if (input.validity &amp;&amp; !input.validity.valid){ </div><div class="t m0 x0 hb y2e9d ffa4 fs6 fc0 sc0 ls21 wsb">    if (input.validity.valueMissing){  </div><div class="t m0 x0 hb y2e9e ffa4 fs6 fc0 sc0 ls21 wsb">        alert(&quot;Please specify a value.&quot;) </div><div class="t m0 x0 hb y2e9f ffa4 fs6 fc0 sc0 ls21 wsb">    } else if (input.validity.typeMismatch){ </div><div class="t m0 x0 hb y2ea0 ffa4 fs6 fc0 sc0 ls21 wsb">        alert(&quot;Please enter an email address.&quot;); </div><div class="t m0 x0 hb y2ea1 ffa4 fs6 fc0 sc0 ls21 wsb">    } else { </div><div class="t m0 x0 hb y2ea2 ffa4 fs6 fc0 sc0 ls21 wsb">        alert(&quot;Value is invalid.&quot;); </div><div class="t m0 x0 hb y2ea3 ffa4 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y2ea4 ffa4 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y2ea5 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h3c y2ea6 ffa1 fs2 fc0 sc0 ls2e wsb">6. 禁用验证 </div><div class="t m0 x0 hfc y2ea7 ffa3 fs2 fc0 sc0 ls8 ws1">通过设置novalidate属性，可以告诉表单不进行验证。 </div><div class="t m0 x0 hb y1e8 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2ea8 ffa4 fs6 fc0 sc0 ls21 wsb">&lt;form method=&quot;post&quot; action=&quot;signup.php&quot; novalidate&gt; </div><div class="t m0 x0 h16 y2ea9 ffa4 fs6 fc0 sc0 ls21 wsb">    &lt;!--这里插入表单元素--&gt;  </div><div class="t m0 x0 hb y2eaa ffa4 fs6 fc0 sc0 ls21 wsb">&lt;/form&gt; </div><div class="t m0 x0 hb y2eab ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y196c ffa3 fs2 fc0 sc0 lsc9">在JavaScript中使用noValidate属性可以取得或设置这个值，如果这个属性存在，值为 true，</div><div class="t m0 x0 h5 y196d ffa3 fs2 fc0 sc0 ls8 ws1">如果不存在，值为false。 </div><div class="t m0 x0 hb y9dd ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2eac ffa4 fs6 fc0 sc0 ls21 wsb">document.forms[0].noValidate = true; //禁用验证 </div><div class="t m0 x0 hb y2ead ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y2eae ffa3 fs2 fc0 sc0 ls8 ws1">如果一个表单中有多个提交按钮，为了指定点击某个提交按钮不必验证表单，可以在相应的按钮上</div><div class="t m0 x0 hc y1416 ffa3 fs2 fc0 sc0 ls8 ws1">添加formnovalidate属性。 </div><div class="t m0 x0 hb yfad ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2eaf ffa4 fs6 fc0 sc0 ls21 wsb">&lt;form method=&quot;post&quot; action=&quot;foo.php&quot;&gt; </div><div class="t m0 x0 h16 y2eb0 ffa4 fs6 fc0 sc0 ls21 wsb">    &lt;!--这里插入表单元素--&gt;  </div><div class="t m0 x0 hb y2eb1 ffa4 fs6 fc0 sc0 ls21 wsb">    &lt;input type=&quot;submit&quot; value=&quot;Regular Submit&quot;&gt; </div></div></div>
<div id="pf1c1" class="pf w0 h0" data-page-no="1c1"><div class="pc pc1c1 w0 h0"><div class="t m0 x2 h2 y1 ff9d fs0 fc0 sc0 ls7 ws0">14.3 选择框脚本    431 </div><div class="t m0 x0 h3 y2 ff9d fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffa8 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ffa8 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffa8 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffa8 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffa8 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffa8 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffa8 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffa8 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffa8 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffa8 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffa8 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffa8 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ffa8 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y79 ffa4 fs6 fc0 sc0 ls21 wsb">    &lt;input type=&quot;submit&quot; formnovalidate name=&quot;btnNoValidate&quot; </div><div class="t m0 x0 hb y7a ffa4 fs6 fc0 sc0 ls21 wsb">        value=&quot;Non-validating Submit&quot;&gt; </div><div class="t m0 x0 hb y7b ffa4 fs6 fc0 sc0 ls21 wsb">&lt;/form&gt; </div><div class="t m0 x0 hb y7c ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y2eb2 ffa3 fs2 fc0 sc0 ls8 ws1">在这个例子中，点击第一个提交按钮会像往常一样验证表单，而点击第二个按钮则会不经过验证而</div><div class="t m0 x0 h5 y2eb3 ffa3 fs2 fc0 sc0 ls8 ws1">提交表单。使用JavaScript也可以设置这个属性。 </div><div class="t m0 x0 hb y2eb4 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2eb5 ffa4 fs6 fc0 sc0 ls21">//禁用验证 </div><div class="t m0 x0 hb y2eb6 ffa4 fs6 fc0 sc0 ls21 wsb">document.forms[0].elements[&quot;btnNoValidate&quot;].formNoValidate = true; </div><div class="t m0 x0 hb y2eb7 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hd y233c ffa1 fs7 fc0 sc0 ls245">14.3 选择框脚本 </div><div class="t m0 x0 h4 y2eb8 ffa3 fs2 fc0 sc0 ls8 ws1">选择框是通过&lt;select&gt;和&lt;option&gt;元素创建的。为了方便与这个控件交互，除了所有表单字段共</div><div class="t m0 x0 hc y2eb9 ffa3 fs2 fc0 sc0 ls8 ws1">有的属性和方法外，HTMLSelectElement类型还提供了下列属性和方法。 </div><div class="t m0 x0 h5 y2eba ffa2 fs1 fc0 sc0 ls2"> add(newOption, relOption)：向控件中插入新&lt;option&gt;元素，其位置在相关项（relOption） </div><div class="t m0 x5 h5 y2ebb ffa3 fs2 fc0 sc0 ls8">之前。 </div><div class="t m0 x0 h5 y2ebc ffa2 fs1 fc0 sc0 ls2"> multiple：布尔值，表示是否允许多项选择；等价于HTML中的multiple特性。 </div><div class="t m0 x0 h5 y2ebd ffa2 fs1 fc0 sc0 ls2"> options：控件中所有&lt;option&gt;元素的HTMLCollection。 </div><div class="t m0 x0 h5 y2ebe ffa2 fs1 fc0 sc0 ls2"> remove(index)：移除给定位置的选项。 </div><div class="t m0 x0 h5 y23bb ffa2 fs1 fc0 sc0 ls2"> selectedIndex：基于0的选中项的索引，如果没有选中项，则值为-1。对于支持多选的控件，</div><div class="t m0 x5 h5 y627 ffa3 fs2 fc0 sc0 ls8 ws1">只保存选中项中第一项的索引。 </div><div class="t m0 x0 h5 y2ebf ffa2 fs1 fc0 sc0 ls2"> size：选择框中可见的行数；等价于HTML中的size特性。 </div><div class="t m0 x0 hc y2ec0 ffa3 fs2 fc0 sc0 ls8 ws1">选择框的type属性不是&quot;select-one&quot;，就是&quot;select-multiple&quot;，这取决于HTML代码中有</div><div class="t m0 x0 hc y2ec1 ffa3 fs2 fc0 sc0 ls8 ws1">没有multiple特性。选择框的value属性由当前选中项决定，相应规则如下。 </div><div class="t m0 x0 h5 y1d0a ffa2 fs1 fc0 sc0 ls2"> 如果没有选中的项，则选择框的value属性保存空字符串。 </div><div class="t m0 x0 h5 y5b3 ffa2 fs1 fc0 sc0 ls2"> 如果有一个选中项，而且该项的value特性已经在HTML中指定，则选择框的 value属性等</div><div class="t m0 x5 hc y5b4 ffa3 fs2 fc0 sc0 ls8 ws1">于选中项的value特性。即使value特性的值是空字符串，也同样遵循此条规则。 </div><div class="t m0 x0 h5 y4b9 ffa2 fs1 fc0 sc0 ls2"> 如果有一个选中项，但该项的value特性在HTML中未指定，则选择框的 value属性等于该</div><div class="t m0 x5 h5 y4ba ffa3 fs2 fc0 sc0 ls8 ws1">项的文本。 </div><div class="t m0 x0 h5 y2ec2 ffa2 fs1 fc0 sc0 ls2"> 如果有多个选中项，则选择框的value属性将依据前两条规则取得第一个选中项的值。 </div><div class="t m0 x0 h5 y2ec3 ffa3 fs2 fc0 sc0 ls8 ws1">以下面的选择框为例： </div><div class="t m0 x0 h5 y2ec4 ff9d fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2ec5 ffa4 fs6 fc0 sc0 ls21 wsb">&lt;select name=&quot;location&quot; id=&quot;selLocation&quot;&gt; </div><div class="t m0 x0 hb y2ec6 ffa4 fs6 fc0 sc0 ls21 wsb">    &lt;option value=&quot;Sunnyvale, CA&quot;&gt;Sunnyvale&lt;/option&gt; </div><div class="t m0 x0 hb y2ec7 ffa4 fs6 fc0 sc0 ls21 wsb">    &lt;option value=&quot;Los Angeles, CA&quot;&gt;Los Angeles&lt;/option&gt; </div><div class="t m0 x0 hb y2ec8 ffa4 fs6 fc0 sc0 ls21 wsb">    &lt;option value=&quot;Mountain View, CA&quot;&gt;Mountain View&lt;/option&gt; </div><div class="t m0 x0 hb y2ec9 ffa4 fs6 fc0 sc0 ls21 wsb">    &lt;option value=&quot;&quot;&gt;China&lt;/option&gt; </div><div class="t m0 x0 hb y2eca ffa4 fs6 fc0 sc0 ls21 wsb">    &lt;option&gt;Australia&lt;/option&gt; </div><div class="t m0 x0 hb y2ecb ffa4 fs6 fc0 sc0 ls21 wsb">&lt;/select&gt; </div><div class="t m0 x5 hb y2ecc ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y301 ffa3 fs2 fc0 sc0 ls6 ws6">如果用户选择了其中第一项，则选择框的值就是&quot;Sunnyvale, CA&quot;。如果文本为&quot;China&quot;的选项</div><div class="t m0 x0 h1e y302 ffa3 fs2 fc0 sc0 ls8 ws1">被选中，则选择框的值就是一个空字符串，因为其value特性是空的。如果选择了最后一项，那么由</div><div class="t m0 x0 h5 y1eac ffa3 fs2 fc0 sc0 ls8 ws1">于&lt;option&gt;中没有指定value特性，则选择框的值就是&quot;Australia&quot;。 </div><div class="t m0 x0 h5 y2ecd ffa3 fs2 fc0 sc0 ls2b9">在DOM中，每个&lt;option&gt;元素都有一个HTMLOptionElement 对象表示。为便于访问数据，</div><div class="t m0 x0 h5 y2021 ffa4 fs1 fc0 sc0 ls9 ws2">HTMLOptionElement对象添加了下列属性： </div></div></div>
<div id="pf1c2" class="pf w0 h0" data-page-no="1c2"><div class="pc pc1c2 w0 h0"><div class="t m0 x0 h2 y1 ff9d fs0 fc0 sc0 ls7 ws0">432  第14章 表单脚本 </div><div class="t m0 x0 h3 y2 ff9d fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ffa2 fs1 fc0 sc0 ls2"> index：当前选项在options集合中的索引。 </div><div class="t m0 x0 h5 y4 ffa2 fs1 fc0 sc0 ls2"> label：当前选项的标签；等价于HTML中的label特性。 </div><div class="t m0 x0 h5 y4e ffa2 fs1 fc0 sc0 ls2"> selected：布尔值，表示当前选项是否被选中。将这个属性设置为true可以选中当前选项。 </div><div class="t m0 x0 h5 yd9 ffa2 fs1 fc0 sc0 ls2"> text：选项的文本。 </div><div class="t m0 x0 h5 y219 ffa2 fs1 fc0 sc0 ls2"> value：选项的值（等价于HTML中的value特性）。 </div><div class="t m0 x0 h5 y21a ffa3 fs2 fc0 sc0 ls8 ws1">其中大部分属性的目的，都是为了方便对选项数据的访问。虽然也可以使用常规的DOM功能来访</div><div class="t m0 x0 h5 y5c8 ffa3 fs2 fc0 sc0 ls8 ws1">问这些信息，但效率是比较低的，如下面的例子所示： </div><div class="t m0 x0 hb y970 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y971 ffa4 fs6 fc0 sc0 ls21 wsb">var selectbox = document.forms[0].elements[&quot;location&quot;]; </div><div class="t m0 x0 hb y972 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y973 ffa4 fs6 fc0 sc0 ls21">//不推荐 </div><div class="t m0 x0 h16 y974 ffa4 fs6 fc0 sc0 ls21 wsb">var text = selectbox.options[0].firstChild.nodeValue;       //选项的文本 </div><div class="t m0 x0 h16 y975 ffa4 fs6 fc0 sc0 ls21 wsb">var value = selectbox.options[0].getAttribute(&quot;value&quot;);     //选项的值 </div><div class="t m0 x0 hb y2ece ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y2e97 ffa3 fs2 fc0 sc0 ls8 ws1">以上代码使用标准DOM方法，取得了选择框中第一项的文本和值。可以与下面使用选项属性的代</div><div class="t m0 x0 h5 y2ecf ffa3 fs2 fc0 sc0 ls8 ws1">码作一比较： </div><div class="t m0 x0 hb y21d ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2ed0 ffa4 fs6 fc0 sc0 ls21 wsb">var selectbox = document.forms[0]. elements[&quot;location&quot;]; </div><div class="t m0 x0 hb y2ed1 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2ed2 ffaa fs6 fc0 sc0 ls21 ws34">//推荐 </div><div class="t m0 x0 h16 y2ed3 ffaa fs6 fc0 sc0 ls21 wsb">var text = selectbox.options[0].text;         //选项的文本 </div><div class="t m0 x0 h16 y2ed4 ffaa fs6 fc0 sc0 ls21 wsb">var value = selectbox.options[0].value;       //选项的值 </div><div class="t m0 x0 hb y2ed5 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y2bd6 ffa3 fs2 fc0 sc0 ls8 ws1">在操作选项时，我们建议最好是使用特定于选项的属性，因为所有浏览器都支持这些属性。在将表</div><div class="t m0 x0 h5 y2ed6 ffa3 fs2 fc0 sc0 ls8 ws1">单控件作为DOM节点的情况下，实际的交互方式则会因浏览器而异。我们不推荐使用标准DOM技术</div><div class="t m0 x0 he y2ed7 ffa3 fs2 fc0 sc0 ls8 ws1">修改&lt;option&gt;元素的文本或者值。 </div><div class="t m0 x0 h1e y6a4 ffa3 fs2 fc0 sc0 ls8 ws1">最后，我们还想提醒读者注意一点：选择框的change事件与其他表单字段的change事件触发的</div><div class="t m0 x0 h4 y2ed8 ffa3 fs2 fc0 sc0 lsa ws53">条件不一样。其他表单字段的change事件是在值被修改且焦点离开当前字段时触发，而选择框的</div><div class="t m0 x0 h5 y2bda ffa4 fs1 fc0 sc0 ls9 ws2">change事件只要选中了选项就会触发。 </div><div class="t m0 x5 ha y2ed9 ff9e fs2 fc0 sc0 ls8 ws14">不同浏览器下，选项的value属性返回什么值也存在差别。但是，在所有浏览</div><div class="t m0 x0 h18 y2eda ff9e fs2 fc0 sc0 ls8 ws14">器中，value属性始终等于value特性。在未指定value 特性的情况下，IE8会返</div><div class="t m0 x0 h5 y2edb ff9e fs2 fc0 sc0 ls8 ws14">回空字符串，而IE9+、Safari、Firefox、Chrome和Opera则会返回与text特性相同</div><div class="t m0 x0 h5 y2edc ff9e fs2 fc0 sc0 ls8">的值。 </div><div class="t m0 x0 h20 y2585 ffa1 fs3 fc0 sc0 ls248 ws214">14.3.1 选择选项 </div><div class="t m0 x0 h4 y1b01 ffa3 fs2 fc0 sc0 ls8 ws1">对于只允许选择一项的选择框，访问选中项的最简单方式，就是使用选择框的selectedIndex属</div><div class="t m0 x0 h5 y2edd ffa3 fs2 fc0 sc0 ls8 ws1">性，如下面的例子所示： </div><div class="t m0 x0 hb y1bd2 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2ede ffa4 fs6 fc0 sc0 ls21 wsb">var selectedOption = selectbox.options[selectbox.selectedIndex]; </div><div class="t m0 x0 hb y2edf ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y2ee0 ffa3 fs2 fc0 sc0 ls8 ws1">取得选中项之后，可以像下面这样显示该选项的信息： </div><div class="t m0 x0 hb y2ee1 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2ee2 ffa4 fs6 fc0 sc0 ls21 wsb">var selectedIndex = selectbox.selectedIndex; </div><div class="t m0 x0 hb y2ee3 ffa4 fs6 fc0 sc0 ls21 wsb">var selectedOption = selectbox.options[selectedIndex]; </div><div class="t m0 x0 hb y2ee4 ffa4 fs6 fc0 sc0 ls21 wsb">alert(&quot;Selected index: &quot; + selectedIndex + &quot;\nSelected text: &quot; + </div><div class="t m0 x0 hb y2ee5 ffa4 fs6 fc0 sc0 ls21 wsb">      selectedOption.text + &quot;\nSelected value: &quot; + selectedOption.value); </div><div class="t m0 x0 hb y2ee6 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y2ee7 ffab fs2 fc0 sc0 ls25 wsb">SelectboxExample01.htm </div></div></div>
<div id="pf1c3" class="pf w0 h0" data-page-no="1c3"><div class="pc pc1c3 w0 h0"><div class="t m0 x2 h2 y1 ff9d fs0 fc0 sc0 ls7 ws0">14.3 选择框脚本    433 </div><div class="t m0 x0 h3 y2 ff9d fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffa8 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ffa8 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffa8 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffa8 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffa8 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffa8 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffa8 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffa8 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffa8 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffa8 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffa8 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffa8 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ffa8 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ffa3 fs2 fc0 sc0 ls8 ws1">这里，我们通过一个警告框显示了选中项的索引、文本和值。 </div><div class="t m0 x0 h1e y4d ffa3 fs2 fc0 sc0 ls107 wsd8">对于可以选择多项的选择框，selectedfIndex属性就好像只允许选择一项一样。设置</div><div class="t m0 x0 h4 y4e ffa4 fs1 fc0 sc0 ls9 ws2">selectedIndex会导致取消以前的所有选项并选择指定的那一项，而读取selectedIndex则只会返</div><div class="t m0 x0 h5 yd9 ffa3 fs2 fc0 sc0 ls8 ws1">回选中项中第一项的索引值。 </div><div class="t m0 x0 h1e y15d ffa3 fs2 fc0 sc0 ls8 ws1">另一种选择选项的方式，就是取得对某一项的引用，然后将其selected属性设置为true。例如，</div><div class="t m0 x0 h5 y21a ffa3 fs2 fc0 sc0 ls8 ws1">下面的代码会选中选择框中的第一项： </div><div class="t m0 x5 hb yb70 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y14e2 ffa4 fs6 fc0 sc0 ls21 wsb">selectbox.options[0].selected = true; </div><div class="t m0 x5 hb y2ee8 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 yaf2 ffa3 fs2 fc0 sc0 ls10a">与selectedIndex不同，在允许多选的选择框中设置选项的selected属性，不会取消对其他选中项</div><div class="t m0 x0 h1e y2ee9 ffa3 fs2 fc0 sc0 ls5c ws4a">的选择，因而可以动态选中任意多个项。但是，如果是在单选选择框中，修改某个选项的selected属性则</div><div class="t m0 x0 hc y2eea ffa3 fs2 fc0 sc0 ls5c ws4a">会取消对其他选项的选择。需要注意的是，将selected属性设置为false对单选选择框没有影响。 </div><div class="t m0 x0 h4 yb4 ffa3 fs2 fc0 sc0 ls8 ws1">实际上，selected属性的作用主要是确定用户选择了选择框中的哪一项。要取得所有选中的项，</div><div class="t m0 x0 hc y2eeb ffa3 fs2 fc0 sc0 ls8 ws1">可以循环遍历选项集合，然后测试每个选项的selected属性。来看下面的例子。 </div><div class="t m0 x5 hb y2eec ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2eed ffa4 fs6 fc0 sc0 ls21 wsb">function getSelectedOptions(selectbox){ </div><div class="t m0 x0 hb y2eee ffa4 fs6 fc0 sc0 ls21 wsb">    var result = new Array(); </div><div class="t m0 x0 hb y2eef ffa4 fs6 fc0 sc0 ls21 wsb">    var option = null; </div><div class="t m0 x0 hb y2ef0 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2ef1 ffa4 fs6 fc0 sc0 ls21 wsb">    for (var i=0, len=selectbox.options.length; i &lt; len; i++){ </div><div class="t m0 x0 hb y2ef2 ffa4 fs6 fc0 sc0 ls21 wsb">        option = selectbox.options[i]; </div><div class="t m0 x0 hb y2ef3 ffa4 fs6 fc0 sc0 ls21 wsb">        if (option.selected){ </div><div class="t m0 x0 hb y2ef4 ffa4 fs6 fc0 sc0 ls21 wsb">            result.push(option); </div><div class="t m0 x0 hb y2ef5 ffa4 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y2ef6 ffa4 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y2ef7 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2ef8 ffa4 fs6 fc0 sc0 ls21 wsb">    return result; </div><div class="t m0 x0 hb y2ef9 ffa4 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x2 hf y2efa ffab fs2 fc0 sc0 ls25 wsb">SelectboxExample03.htm </div><div class="t m0 x0 h4 y22c1 ffa3 fs2 fc0 sc0 ls8 ws1">这个函数可以返回给定选择框中选中项的一个数组。首先，创建一个将包含选中项的数组，然后使</div><div class="t m0 x0 h1e y2efb ffa3 fs2 fc0 sc0 ls3ae">用for循环迭代所有选项，同时检测每一项的selected 属性。如果有选项被选中，则将其添加到</div><div class="t m0 x0 h4 y2efc ffa4 fs1 fc0 sc0 ls9 ws2">result数组中。最后，返回包含选中项的数组。下面是一个使用getSelectedOptions()函数取得</div><div class="t m0 x0 h5 y2efd ffa3 fs2 fc0 sc0 ls8 ws1">选中项的示例。 </div><div class="t m0 x5 hb y2efe ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2eff ffa4 fs6 fc0 sc0 ls21 wsb">var selectbox = document.getElementById(&quot;selLocation&quot;); </div><div class="t m0 x0 hb y2f00 ffa4 fs6 fc0 sc0 ls21 wsb">var selectedOptions = getSelectedOptions(selectbox); </div><div class="t m0 x0 hb y2f01 ffa4 fs6 fc0 sc0 ls21 wsb">var message = &quot;&quot;; </div><div class="t m0 x0 hb y2f02 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2f03 ffa4 fs6 fc0 sc0 ls21 wsb">for (var i=0, len=selectedOptions.length; i &lt; len; i++){ </div><div class="t m0 x0 hb y2f04 ffa4 fs6 fc0 sc0 ls21 wsb">    message += &quot;Selected index: &quot; + selectedOptions[i].index + </div><div class="t m0 x0 hb y2f05 ffa4 fs6 fc0 sc0 ls21 wsb">    &quot;\nSelected text: &quot; + selectedOptions[i].text + </div><div class="t m0 x0 hb y2f06 ffa4 fs6 fc0 sc0 ls21 wsb">    &quot;\nSelected value: &quot; + selectedOptions[i].value + &quot;\n\n&quot;; </div><div class="t m0 x0 hb y2f07 ffa4 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y2f08 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2f09 ffa4 fs6 fc0 sc0 ls21 wsb">alert(message); </div><div class="t m0 x2 hf y2f0a ffab fs2 fc0 sc0 ls25 wsb">SelectboxExample03.htm </div><div class="t m0 x0 h4 y2354 ffa3 fs2 fc0 sc0 ls8 ws1">在这个例子中，我们首先从一个选择框中取得了选中项。然后，使用for循环构建了一条消息，包</div><div class="t m0 x0 h5 y2355 ffa3 fs2 fc0 sc0 ls8 ws1">含所有选中项的信息：每一项的索引、文本和值。这种技术适用于单选和多选选择框。 </div></div></div>
<div id="pf1c4" class="pf w0 h0" data-page-no="1c4"><div class="pc pc1c4 w0 h0"><div class="t m0 x0 h2 y1 ff9d fs0 fc0 sc0 ls7 ws0">434  第14章 表单脚本 </div><div class="t m0 x0 h3 y2 ff9d fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h20 y2f0b ffa1 fs3 fc0 sc0 ls248 ws214">14.3.2 添加选项 </div><div class="t m0 x0 h5 y2f0c ffa3 fs2 fc0 sc0 ls8 ws1">可以使用JavaScript动态创建选项，并将它们添加到选择框中。添加选项的方式有很多，第一种方</div><div class="t m0 x0 h5 y2f0d ffa3 fs2 fc0 sc0 ls8 ws1">式就是使用如下所示的DOM方法。 </div><div class="t m0 x0 hb y2f0e ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2f0f ffa4 fs6 fc0 sc0 ls21 wsb">var newOption = document.createElement(&quot;option&quot;); </div><div class="t m0 x0 hb y2f10 ffa4 fs6 fc0 sc0 ls21 wsb">newOption.appendChild(document.createTextNode(&quot;Option text&quot;)); </div><div class="t m0 x0 hb y2f11 ffa4 fs6 fc0 sc0 ls21 wsb">newOption.setAttribute(&quot;value&quot;, &quot;Option value&quot;); </div><div class="t m0 x0 hb y2f12 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2f13 ffa4 fs6 fc0 sc0 ls21 wsb">selectbox.appendChild(newOption); </div><div class="t m0 x0 hb y2f14 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y2f15 ffab fs2 fc0 sc0 ls25 wsb">SelectboxExample04.htm </div><div class="t m0 x0 h4 y1db4 ffa3 fs2 fc0 sc0 ls8 ws1">以上代码创建了一个新的&lt;option&gt;元素，然后为它添加了一个文本节点，并设置其value特性，</div><div class="t m0 x0 h5 y2f16 ffa3 fs2 fc0 sc0 ls8 ws1">最后将它添加到了选择框中。添加到选择框之后，用户立即就可以看到新选项。 </div><div class="t m0 x0 hc y1455 ffa3 fs2 fc0 sc0 lsa ws53">第二种方式是使用Option构造函数来创建新选项，这个构造函数是DOM出现之前就有的，一</div><div class="t m0 x0 h1e y2f17 ffa3 fs2 fc0 sc0 lsa ws53">直遗留到现在。Option构造函数接受两个参数：文本（text）和值（value）；第二个参数可选。</div><div class="t m0 x0 hc y2f18 ffa3 fs2 fc0 sc0 lsa ws53">虽然这个构造函数会创建一个Object的实例，但兼容DOM的浏览器会返回一个&lt;option&gt;元素。</div><div class="t m0 x0 h1e yb7b ffa3 fs2 fc0 sc0 lsa ws53">换句话说，在这种情况下，我们仍然可以使用appendChild()将新选项添加到选择框中。来看下面</div><div class="t m0 x0 h5 y1276 ffa3 fs2 fc0 sc0 lsa">的例子。 </div><div class="t m0 x0 hb y2f19 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2f1a ffa4 fs6 fc0 sc0 ls21 wsb">var newOption = new Option(&quot;Option text&quot;, &quot;Option value&quot;); </div><div class="t m0 x0 h36 y2f1b ffa4 fs6 fc0 sc0 ls21 wsb">selectbox.appendChild(newOption);     //在IE8及之前版本中有问题 </div><div class="t m0 x0 hb y2f1c ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y2f1d ffab fs2 fc0 sc0 ls25 wsb">SelectboxExample08.htm </div><div class="t m0 x0 h5 y2f1e ffa3 fs2 fc0 sc0 ls8 ws1">这种方式在除IE之外的浏览器中都可以使用。由于存在bug，IE 在这种方式下不能正确设置新选</div><div class="t m0 x0 h5 y2f1f ffa3 fs2 fc0 sc0 ls8 ws1">项的文本。 </div><div class="t m0 x0 hc y2f20 ffa3 fs2 fc0 sc0 ls8 ws1">第三种添加新选项的方式是使用选择框的add()方法。DOM规定这个方法接受两个参数：要添加</div><div class="t m0 x0 h4 y2f21 ffa3 fs2 fc0 sc0 ls24 ws1e">的新选项和将位于新选项之后的选项。如果想在列表的最后添加一个选项，应该将第二个参数设置为</div><div class="t m0 x0 h5 y2f22 ffa4 fs1 fc0 sc0 ls9 ws2">null。在IE对add()方法的实现中，第二个参数是可选的，而且如果指定，该参数必须是新选项之后</div><div class="t m0 x0 h5 y152e ffa3 fs2 fc0 sc0 ls8 ws1">选项的索引。兼容DOM的浏览器要求必须指定第二个参数，因此要想编写跨浏览器的代码，就不能只</div><div class="t m0 x0 h1e y1ba8 ffa3 fs2 fc0 sc0 ls6 ws6">传入一个参数。这时候，为第二个参数传入undefined，就可以在所有浏览器中都将新选项插入到列</div><div class="t m0 x0 h5 y2f23 ffa3 fs2 fc0 sc0 ls8 ws1">表最后了。来看一个例子。 </div><div class="t m0 x0 hb y2f24 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2f25 ffa4 fs6 fc0 sc0 ls21 wsb">var newOption = new Option(&quot;Option text&quot;, &quot;Option value&quot;); </div><div class="t m0 x0 h16 y2f26 ffa4 fs6 fc0 sc0 ls21 wsb">selectbox.add(newOption, undefined); //最佳方案 </div><div class="t m0 x0 hb y2f27 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y2f28 ffab fs2 fc0 sc0 ls25 wsb">SelectboxExample04.htm </div><div class="t m0 x0 h5 y1ecf ffa3 fs2 fc0 sc0 ls3b">在IE和兼容DOM的浏览器中，上面的代码都可以正常使用。如果你想将新选项添加到其他位置（不</div><div class="t m0 x0 hc y20c2 ffa3 fs2 fc0 sc0 ls8 ws1">是最后一个），就应该使用标准的DOM技术和insertBefore()方法。 </div><div class="t m0 x5 h5 y2f29 ff9e fs2 fc0 sc0 ls8 ws14">就和在HTML中一样，此时也不一定要为选项指定值。换句话说，只为Option</div><div class="t m0 x0 h5 y2f2a ff9e fs2 fc0 sc0 ls8 ws14">构造函数传入一个参数（选项的文本）也没有问题。 </div></div></div>
<div id="pf1c5" class="pf w0 h0" data-page-no="1c5"><div class="pc pc1c5 w0 h0"><div class="t m0 x2 h2 y1 ff9d fs0 fc0 sc0 ls7 ws0">14.3 选择框脚本    435 </div><div class="t m0 x0 h3 y2 ff9d fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffa8 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ffa8 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffa8 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffa8 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffa8 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffa8 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffa8 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffa8 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffa8 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffa8 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffa8 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffa8 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ffa8 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h20 y2f0b ffa1 fs3 fc0 sc0 ls248 ws214">14.3.3 移除选项 </div><div class="t m0 x0 h5 y2f0c ffa3 fs2 fc0 sc0 ls8 ws1">与添加选项类似，移除选项的方式也有很多种。首先，可以使用DOM的removeChild()方法，</div><div class="t m0 x0 h5 y2f0d ffa3 fs2 fc0 sc0 ls8 ws1">为其传入要移除的选项，如下面的例子所示： </div><div class="t m0 x5 hb y2f0e ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2f0f ffa4 fs6 fc0 sc0 ls21 wsb">selectbox.removeChild(selectbox.options[0]);     //移除第一个选项 </div><div class="t m0 x5 hb y2f2b ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y2f2c ffa3 fs2 fc0 sc0 ls8 ws1">其次，可以使用选择框的remove()方法。这个方法接受一个参数，即要移除选项的索引，如下面</div><div class="t m0 x0 h5 y2f2d ffa3 fs2 fc0 sc0 ls8 ws1">的例子所示： </div><div class="t m0 x5 hb y164a ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2f2e ffa4 fs6 fc0 sc0 ls21 wsb">selectbox.remove(0);     //移除第一个选项 </div><div class="t m0 x5 hb y2f2f ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y2f30 ffa3 fs2 fc0 sc0 ls8 ws1">最后一种方式，就是将相应选项设置为null。这种方式也是DOM出现之前浏览器的遗留机制。</div><div class="t m0 x0 h5 y2f31 ffa3 fs2 fc0 sc0 ls8">例如： </div><div class="t m0 x5 hb y2f32 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2f33 ffa4 fs6 fc0 sc0 ls21 wsb">selectbox.options[0] = null;    //移除第一个选项 </div><div class="t m0 x5 hb y2f34 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y2f35 ffa3 fs2 fc0 sc0 ls8 ws1">要清除选择框中所有的项，需要迭代所有选项并逐个移除它们，如下面的例子所示： </div><div class="t m0 x5 hb y2f36 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2f37 ffa4 fs6 fc0 sc0 ls21 wsb">function clearSelectbox(selectbox){ </div><div class="t m0 x0 hb y2f38 ffa4 fs6 fc0 sc0 ls21 wsb">    for(var i=0, len=selectbox.options.length; i &lt; len; i++){ </div><div class="t m0 x0 hb y2f39 ffa4 fs6 fc0 sc0 ls21 wsb">        selectbox.remove(i); </div><div class="t m0 x0 hb y2f3a ffa4 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y2f3b ffa4 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h4 y2f3c ffa3 fs2 fc0 sc0 ls8 ws1">这个函数每次只移除选择框中的第一个选项。由于移除第一个选项后，所有后续选项都会自动向上</div><div class="t m0 x0 h5 y2f3d ffa3 fs2 fc0 sc0 ls8 ws1">移动一个位置，因此重复移除第一个选项就可以移除所有选项了。 </div><div class="t m0 x0 h20 y31e ffa1 fs3 fc0 sc0 ls248 ws214">14.3.4 移动和重排选项 </div><div class="t m0 x0 h5 ydff ffa3 fs2 fc0 sc0 ls3b">在DOM标准出现之前，将一个选择框中的选项移动到另一个选择框中是非常麻烦的。整个过程要</div><div class="t m0 x0 h4 ye00 ffa3 fs2 fc0 sc0 ls8 ws1">涉及从第一个选择框中移除选项，然后以相同的文本和值创建新选项，最后再将新选项添加到第二个选</div><div class="t m0 x0 h5 y24f4 ffa3 fs2 fc0 sc0 ls8 ws1">择框中。而使用DOM的appendChild()方法，就可以将第一个选择框中的选项直接移动到第二个选</div><div class="t m0 x0 h4 y2f3e ffa3 fs2 fc0 sc0 ls8 ws1">择框中。我们知道，如果为appendChild()方法传入一个文档中已有的元素，那么就会先从该元素的</div><div class="t m0 x0 h4 y2f3f ffa3 fs2 fc0 sc0 ls8 ws1">父节点中移除它，再把它添加到指定的位置。下面的代码展示了将第一个选择框中的第一个选项移动到</div><div class="t m0 x0 h5 y2f40 ffa3 fs2 fc0 sc0 ls8 ws1">第二个选择框中的过程。 </div><div class="t m0 x5 hb y2f41 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2f42 ffa4 fs6 fc0 sc0 ls21 wsb">var selectbox1 = document.getElementById(&quot;selLocations1&quot;); </div><div class="t m0 x0 hb y2f43 ffa4 fs6 fc0 sc0 ls21 wsb">var selectbox2 = document.getElementById(&quot;selLocations2&quot;); </div><div class="t m0 x0 hb y2f44 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2f45 ffa4 fs6 fc0 sc0 ls21 wsb">selectbox2.appendChild(selectbox1.options[0]); </div><div class="t m0 x5 hb y2f46 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y2f47 ffab fs2 fc0 sc0 ls25 wsb">SelectboxExample05.htm </div><div class="t m0 x0 h5 y2f48 ffa3 fs2 fc0 sc0 ls8 ws1">移动选项与移除选项有一个共同之处，即会重置每一个选项的index属性。 </div><div class="t m0 x0 h5 y2f49 ffa3 fs2 fc0 sc0 ls8 ws1">重排选项次序的过程也十分类似，最好的方式仍然是使用DOM方法。要将选择框中的某一项移动</div><div class="t m0 x0 h5 y2f4a ffa3 fs2 fc0 sc0 ls8 ws1">到特定位置，最合适的DOM方法就是insertBefore()；appendChild()方法只适用于将选项添加</div><div class="t m0 x0 h5 y2f4b ffa3 fs2 fc0 sc0 ls8 ws1">到选择框的最后。要在选择框中向前移动一个选项的位置，可以使用以下代码： </div><div class="t m0 x5 hb y2f4c ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2f4d ffa4 fs6 fc0 sc0 ls21 wsb">var optionToMove = selectbox.options[1]; </div><div class="t m0 x0 hb y2f4e ffa4 fs6 fc0 sc0 ls21 wsb">selectbox.insertBefore(optionToMove, selectbox.options[optionToMove.index-1]); </div><div class="t m0 x5 hb y2f4f ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y2f50 ffab fs2 fc0 sc0 ls25 wsb">SelectboxExample06.htm </div></div></div>
<div id="pf1c6" class="pf w0 h0" data-page-no="1c6"><div class="pc pc1c6 w0 h0"><div class="t m0 x0 h2 y1 ff9d fs0 fc0 sc0 ls7 ws0">436  第14章 表单脚本 </div><div class="t m0 x0 h3 y2 ff9d fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ffa3 fs2 fc0 sc0 ls8 ws1">以上代码首先选择了要移动的选项，然后将其插入到了排在它前面的选项之前。实际上，第二行代</div><div class="t m0 x0 h4 y4d ffa3 fs2 fc0 sc0 ls8 ws1">码对除第一个选项之外的其他选项是通用的。类似地，可以使用下列代码将选择框中的选项向后移动一</div><div class="t m0 x0 h5 yd8 ffa3 fs2 fc0 sc0 ls8">个位置。  </div><div class="t m0 x0 hb y2f52 ffa4 fs6 fc0 sc0 ls21 wsb">var optionToMove = selectbox.options[1]; </div><div class="t m0 x0 hb y2f53 ffa4 fs6 fc0 sc0 ls21 wsb">selectbox.insertBefore(optionToMove, selectbox.options[optionToMove.index+2]); </div><div class="t m0 x0 hb y2f54 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y2f55 ffab fs2 fc0 sc0 ls25 wsb">SelectboxExample06.htm </div><div class="t m0 x0 h5 y2f56 ffa3 fs2 fc0 sc0 ls8 ws1">以上代码适用于选择框中的所有选项，包括最后一个选项。 </div><div class="t m0 x5 h5 y2f57 ff9d fs2 fc0 sc0 ls2a ws21">IE7存在一个页面重绘问题，有时候会导致使用DOM方法重排的选项不能马上</div><div class="t m0 x0 h5 y2f58 ff9e fs2 fc0 sc0 ls8 ws14">正确显示。 </div><div class="t m0 x0 hd y2f59 ffa1 fs7 fc0 sc0 ls245">14.4 表单序列化 </div><div class="t m0 x0 h5 y2f5a ffa3 fs2 fc0 sc0 ls8 ws1">随着Ajax的出现，表单序列化已经成为一种常见需求（第21章将讨论Ajax）。在JavaScript中，可</div><div class="t m0 x0 h1e y2f5b ffa3 fs2 fc0 sc0 ls8 ws1">以利用表单字段的type属性，连同name和value 属性一起实现对表单的序列化。在编写代码之前，</div><div class="t m0 x0 h5 y8d ffa3 fs2 fc0 sc0 ls8 ws1">有必须先搞清楚在表单提交期间，浏览器是怎样将数据发送给服务器的。 </div><div class="t m0 x0 h5 y1602 ffa2 fs1 fc0 sc0 ls2"> 对表单字段的名称和值进行URL编码，使用和号（&amp;）分隔。 </div><div class="t m0 x0 h5 y2f5c ffa2 fs1 fc0 sc0 ls2"> 不发送禁用的表单字段。 </div><div class="t m0 x0 h5 y2f5d ffa2 fs1 fc0 sc0 ls2"> 只发送勾选的复选框和单选按钮。 </div><div class="t m0 x0 h5 y2f5e ffa2 fs1 fc0 sc0 ls2"> 不发送type为&quot;reset&quot;和&quot;button&quot;的按钮。 </div><div class="t m0 x0 h5 y2f5f ffa2 fs1 fc0 sc0 ls2"> 多选选择框中的每个选中的值单独一个条目。 </div><div class="t m0 x0 h4 y2f60 ffa2 fs1 fc0 sc0 ls2"> 在单击提交按钮提交表单的情况下，也会发送提交按钮；否则，不发送提交按钮。也包括type</div><div class="t m0 x0 h5 y152b ffa3 fs2 fc0 sc0 ls8 ws1">为&quot;image&quot;的&lt;input&gt;元素。 </div><div class="t m0 x0 h4 y2f61 ffa2 fs1 fc0 sc0 ls2"> &lt;select&gt;元素的值，就是选中的&lt;option&gt;元素的value特性的值。如果&lt;option&gt;元素没有</div><div class="t m0 x0 h5 y2f62 ffa4 fs1 fc0 sc0 ls9 ws2">value特性，则是&lt;option&gt;元素的文本值。 </div><div class="t m0 x0 h4 y2f63 ffa3 fs2 fc0 sc0 ls8 ws1">在表单序列化过程中，一般不包含任何按钮字段，因为结果字符串很可能是通过其他方式提交的。</div><div class="t m0 x0 h5 y2f64 ffa3 fs2 fc0 sc0 ls8 ws1">除此之外的其他上述规则都应该遵循。以下就是实现表单序列化的代码。 </div><div class="t m0 x0 hb y50d ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2f65 ffa4 fs6 fc0 sc0 ls21 wsb">function serialize(form){         </div><div class="t m0 x0 hb y2f66 ffa4 fs6 fc0 sc0 ls21 wsb">    var parts = [], </div><div class="t m0 x0 hb y2f67 ffa4 fs6 fc0 sc0 ls21 wsb">    field = null, </div><div class="t m0 x0 hb y2f68 ffa4 fs6 fc0 sc0 ls21 ws31d"> i, </div><div class="t m0 x0 hb y2f69 ffa4 fs6 fc0 sc0 ls21 wsb">   len, </div><div class="t m0 x0 hb y2f6a ffa4 fs6 fc0 sc0 ls21 ws31d"> j, </div><div class="t m0 x0 hb y2f6b ffa4 fs6 fc0 sc0 ls21 ws31d"> optLen, </div><div class="t m0 x0 hb y2f6c ffa4 fs6 fc0 sc0 ls21 ws31d"> option, </div><div class="t m0 x0 hb y2f6d ffa4 fs6 fc0 sc0 ls21 ws31d"> optValue; </div><div class="t m0 x0 hb y2f6e ffa4 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 hb y2f6f ffa4 fs6 fc0 sc0 ls21 wsb">    for (i=0, len=form.elements.length; i &lt; len; i++){ </div><div class="t m0 x0 hb y2f70 ffa4 fs6 fc0 sc0 ls21 wsb">        field = form.elements[i]; </div><div class="t m0 x0 hb y2f71 ffa4 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 hb y2f72 ffa4 fs6 fc0 sc0 ls21 wsb">        switch(field.type){ </div><div class="t m0 x0 hb y2f73 ffa4 fs6 fc0 sc0 ls21 wsb">            case &quot;select-one&quot;: </div><div class="t m0 x0 hb y2f74 ffa4 fs6 fc0 sc0 ls21 wsb">            case &quot;select-multiple&quot;: </div><div class="t m0 x0 hb y2f75 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2f76 ffa4 fs6 fc0 sc0 ls21 wsb">            if (field.name.length){ </div><div class="t m0 x0 hb y2f77 ffa4 fs6 fc0 sc0 ls21 wsb">                for (j=0, optLen = field.options.length; j &lt; optLen; j++){ </div></div></div>
<div id="pf1c7" class="pf w0 h0" data-page-no="1c7"><div class="pc pc1c7 w0 h0"><div class="t m0 x2 h2 y1 ff9d fs0 fc0 sc0 ls7 ws0">14.4 表单序列化    437 </div><div class="t m0 x0 h3 y2 ff9d fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffa8 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ffa8 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffa8 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffa8 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffa8 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffa8 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffa8 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffa8 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffa8 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffa8 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffa8 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffa8 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ffa8 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y2f78 ffa4 fs6 fc0 sc0 ls21 wsb">                    option = field.options[j]; </div><div class="t m0 x0 hb y2f79 ffa4 fs6 fc0 sc0 ls21 wsb">                    if (option.selected){ </div><div class="t m0 x0 hb y2f7a ffa4 fs6 fc0 sc0 ls21 wsb">                        optValue = &quot;&quot;; </div><div class="t m0 x0 hb y2f7b ffa4 fs6 fc0 sc0 ls21 wsb">                        if (option.hasAttribute){ </div><div class="t m0 x0 hb y2f7c ffa4 fs6 fc0 sc0 ls21 wsb">                            optValue = (option.hasAttribute(&quot;value&quot;) ?  </div><div class="t m0 x0 hb y2f7d ffa4 fs6 fc0 sc0 ls21 wsb">                                        option.value : option.text); </div><div class="t m0 x0 hb y2f7e ffa4 fs6 fc0 sc0 ls21 wsb">                        } else { </div><div class="t m0 x0 hb y2f7f ffa4 fs6 fc0 sc0 ls21 wsb">                            optValue = (option.attributes[&quot;value&quot;].specified ?  </div><div class="t m0 x0 hb y2f80 ffa4 fs6 fc0 sc0 ls21 wsb">                                        option.value : option.text); </div><div class="t m0 x0 hb y2f81 ffa4 fs6 fc0 sc0 ls21 wsb">                        } </div><div class="t m0 x0 hb y2f82 ffa4 fs6 fc0 sc0 ls21 wsb">                        parts.push(encodeURIComponent(field.name) + &quot;=&quot; + </div><div class="t m0 x0 hb y2f83 ffa4 fs6 fc0 sc0 ls21 wsb">                                   encodeURIComponent(optValue)); </div><div class="t m0 x0 hb y2f84 ffa4 fs6 fc0 sc0 ls21 wsb">                       } </div><div class="t m0 x0 hb y2f85 ffa4 fs6 fc0 sc0 ls21 wsb">                    } </div><div class="t m0 x0 hb y2f86 ffa4 fs6 fc0 sc0 ls21 wsb">                } </div><div class="t m0 x0 hb y2f87 ffa4 fs6 fc0 sc0 ls21 wsb">                break; </div><div class="t m0 x0 hb y2f88 ffa4 fs6 fc0 sc0 ls21 wsb">                 </div><div class="t m0 x0 h16 y2f89 ffa4 fs6 fc0 sc0 ls21 wsb">            case undefined:      //字段集 </div><div class="t m0 x0 h16 y2f8a ffa4 fs6 fc0 sc0 ls21 wsb">            case &quot;file&quot;:          //文件输入 </div><div class="t m0 x0 h16 y2f8b ffa4 fs6 fc0 sc0 ls21 wsb">            case &quot;submit&quot;:       //提交按钮 </div><div class="t m0 x0 h16 y2f8c ffa4 fs6 fc0 sc0 ls21 wsb">            case &quot;reset&quot;:          //重置按钮 </div><div class="t m0 x0 h16 y2f8d ffa4 fs6 fc0 sc0 ls21 wsb">            case &quot;button&quot;:        //自定义按钮 </div><div class="t m0 x0 hb y2f8e ffa4 fs6 fc0 sc0 ls21 wsb">                break; </div><div class="t m0 x0 hb y2f8f ffa4 fs6 fc0 sc0 ls21 wsb">                 </div><div class="t m0 x0 h16 y2f90 ffa4 fs6 fc0 sc0 ls21 wsb">            case &quot;radio&quot;:         //单选按钮 </div><div class="t m0 x0 h16 y2f91 ffa4 fs6 fc0 sc0 ls21 wsb">            case &quot;checkbox&quot;:       //复选框 </div><div class="t m0 x0 hb y2f92 ffa4 fs6 fc0 sc0 ls21 wsb">                if (!field.checked){ </div><div class="t m0 x0 hb y2f93 ffa4 fs6 fc0 sc0 ls21 wsb">                    break; </div><div class="t m0 x0 hb y2f94 ffa4 fs6 fc0 sc0 ls21 wsb">                } </div><div class="t m0 x0 h16 y2f95 ffa4 fs6 fc0 sc0 ls21 wsb">                /* 执行默认操作 */ </div><div class="t m0 x0 hb y2f96 ffa4 fs6 fc0 sc0 ls21 wsb">                             </div><div class="t m0 x0 hb y2f97 ffa4 fs6 fc0 sc0 ls21 wsb">            default: </div><div class="t m0 x0 h16 y2f98 ffa4 fs6 fc0 sc0 ls21 wsb">                //不包含没有名字的表单字段 </div><div class="t m0 x0 hb y2f99 ffa4 fs6 fc0 sc0 ls21 wsb">                if (field.name.length){ </div><div class="t m0 x0 hb y2f9a ffa4 fs6 fc0 sc0 ls21 wsb">                    parts.push(encodeURIComponent(field.name) + &quot;=&quot; +  </div><div class="t m0 x0 hb y2f9b ffa4 fs6 fc0 sc0 ls21 wsb">                               encodeURIComponent(field.value)); </div><div class="t m0 x0 hb y2f9c ffa4 fs6 fc0 sc0 ls21 wsb">                } </div><div class="t m0 x0 hb y2f9d ffa4 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y2f9e ffa4 fs6 fc0 sc0 ls21 wsb">    }         </div><div class="t m0 x0 hb y2f9f ffa4 fs6 fc0 sc0 ls21 wsb">    return parts.join(&quot;&amp;&quot;); </div><div class="t m0 x0 hb y2fa0 ffa4 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x2 hf y2fa1 ffab fs2 fc0 sc0 ls25 wsb">FormSerializationExample01.htm </div><div class="t m0 x0 h4 y2fa2 ffa3 fs2 fc0 sc0 ls8 ws1">上面这个serialize()函数首先定义了一个名为parts的数组，用于保存将要创建的字符串的各</div><div class="t m0 x0 h1e y2fa3 ffa3 fs2 fc0 sc0 ls8 ws1">个部分。然后，通过for循环迭代每个表单字段，并将其保存在field变量中。在获得了一个字段的</div><div class="t m0 x0 h1e y2fa4 ffa3 fs2 fc0 sc0 ls8 ws1">引用之后，使用switch语句检测其type 属性。序列化过程中最麻烦的就是&lt;select&gt;元素，它可能</div><div class="t m0 x0 h4 y1664 ffa3 fs2 fc0 sc0 ls8 ws1">是单选框也可能是多选框。为此，需要遍历控件中的每一个选项，并在相应选项被选中的情况下向数组</div><div class="t m0 x0 h4 y2fa5 ffa3 fs2 fc0 sc0 ls8 ws1">中添加一个值。对于单选框，只可能有一个选中项，而多选框则可能有零或多个选中项。这里的代码适</div><div class="t m0 x0 h4 y2fa6 ffa3 fs2 fc0 sc0 ls8 ws1">用于这两种选择框，至于可选项的数量则是由浏览器控制的。在找到一个选中项之后，需要确定使用什</div><div class="t m0 x0 h4b y2fa7 ffa3 fs2 fc0 sc0 ls8 ws1">么值。如果不存在value特性，或者虽然存在该特性，但值为空字符串，都要使用选项的文本来代替。</div><div class="t m0 x0 h5 y2fa8 ffa3 fs2 fc0 sc0 ls8 ws1">为检查这个特性，在DOM兼容的浏览器中需要使用hasAttribute()方法，而在 IE中需要使用特性</div><div class="t m0 x0 hc y2fa9 ffa3 fs2 fc0 sc0 ls3b0">的specified属性。 </div><div class="t m0 x0 h1e y2faa ffa3 fs2 fc0 sc0 ls5c ws4a">如果表单中包含&lt;fieldset&gt;元素，则该元素会出现在元素集合中，但没有type属性。因此，如果type</div><div class="t m0 x0 h4 y2fab ffa3 fs2 fc0 sc0 ls5c ws4a">属性未定义，则不需要对其进行序列化。同样，对于各种按钮以及文件输入字段也是如此（文件输入字段在</div><div class="t m0 x0 h4 y2fac ffa3 fs2 fc0 sc0 ls5c ws4a">表单提交过程中包含文件的内容；但是，这个字段是无法模仿的，序列化时一般都要忽略）。对于单选按钮</div><div class="t m0 x0 h1e y2fad ffa3 fs2 fc0 sc0 ls5c ws4a">和复选框，要检查其checked属性是否被设置为false，如果是则退出switch 语句。如果checked属性</div></div></div>
<div id="pf1c8" class="pf w0 h0" data-page-no="1c8"><div class="pc pc1c8 w0 h0"><div class="t m0 x0 h2 y1 ff9d fs0 fc0 sc0 ls7 ws0">438  第14章 表单脚本 </div><div class="t m0 x0 h3 y2 ff9d fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ffa3 fs2 fc0 sc0 ls7e">为true，则继续执行default语句，即将当前字段的名称和值进行编码，然后添加到parts数组中。函数</div><div class="t m0 x0 hc y4d ffa3 fs2 fc0 sc0 ls5c ws4a">的最后一步，就是使用join()格式化整个字符串，也就是用和号来分隔每一个表单字段。 </div><div class="t m0 x0 h1e y5 ffa3 fs2 fc0 sc0 ls8 ws1">最后，serialize()函数会以查询字符串的格式输出序列化之后的字符串。当然，要序列化成其他</div><div class="t m0 x0 h5 yd9 ffa3 fs2 fc0 sc0 ls8 ws1">格式，也不是什么困难的事。 </div><div class="t m0 x0 hd y8 ffa1 fs7 fc0 sc0 ls245">14.5 富文本编辑 </div><div class="t m0 x0 h5 y1f ffa3 fs2 fc0 sc0 ls8 ws1">富文本编辑，又称为WYSIWYG（What You See Is What You Get，所见即所得）。在网页中编辑富</div><div class="t m0 x0 h5 y8c9 ffa3 fs2 fc0 sc0 ls8 ws1">文本内容，是人们对Web应用程序最大的期待之一。虽然也没有规范，但在IE最早引入的这一功能基</div><div class="t m0 x0 h5 y25d7 ffa3 fs2 fc0 sc0 ls8 ws1">础上，已经出现了事实标准。而且，Opera、Safari、Chrome和Firefox都已经支持这一功能。这一技术</div><div class="t m0 x0 h5 y25d8 ffa3 fs2 fc0 sc0 ls8 ws1">的本质，就是在页面中嵌入一个包含空HTML页面的iframe。通过设置 designMode属性，这个空白</div><div class="t m0 x0 hc y128e ffa3 fs2 fc0 sc0 ls3b">的HTML页面可以被编辑，而编辑对象则是该页面&lt;body&gt;元素的HTML代码。designMode属性有两</div><div class="t m0 x0 h4 y8cd ffa3 fs2 fc0 sc0 ls5 ws4">个可能的值：&quot;off&quot;（默认值）和&quot;on&quot;。在设置为&quot;on&quot;时，整个文档都会变得可以编辑（显示插入符</div><div class="t m0 x0 h5 y8ce ffa3 fs2 fc0 sc0 ls8 ws1">号），然后就可以像使用字处理软件一样，通过键盘将文本内容加粗、变成斜体，等等。 </div><div class="t m0 x0 he y2fae ffa3 fs2 fc0 sc0 ls8 ws1">可以给iframe指定一个非常简单的HTML页面作为其内容来源。例如： </div><div class="t m0 x0 hb y2faf ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2fb0 ffa4 fs6 fc0 sc0 ls21 wsb">&lt;!DOCTYPE html&gt; </div><div class="t m0 x0 hb y2fb1 ffa4 fs6 fc0 sc0 ls21 wsb">&lt;html&gt; </div><div class="t m0 x0 hb y2fb2 ffa4 fs6 fc0 sc0 ls21 wsb">    &lt;head&gt; </div><div class="t m0 x0 hb y2fb3 ffa4 fs6 fc0 sc0 ls21 wsb">        &lt;title&gt;Blank Page for Rich Text Editing&lt;/title&gt; </div><div class="t m0 x0 hb y2fb4 ffa4 fs6 fc0 sc0 ls21 wsb">    &lt;/head&gt; </div><div class="t m0 x0 hb y2fb5 ffa4 fs6 fc0 sc0 ls21 wsb">    &lt;body&gt; </div><div class="t m0 x0 hb y2fb6 ffa4 fs6 fc0 sc0 ls21 wsb">    &lt;/body&gt; </div><div class="t m0 x0 hb y2fb7 ffa4 fs6 fc0 sc0 ls21 wsb">&lt;/html&gt; </div><div class="t m0 x0 hb y2fb8 ffa4 fs6 fc0 sc0 ls8 wsb">  </div><div class="t m0 x0 h4 y2fb9 ffa3 fs2 fc0 sc0 ls8 ws1">这个页面在iframe中可以像其他页面一样被加载。要让它可以编辑，必须要将designMode设置</div><div class="t m0 x0 h1e y2fba ffa3 fs2 fc0 sc0 ls8 ws1">为&quot;on&quot;，但只有在页面完全加载之后才能设置这个属性。因此，在包含页面中，需要使用onload事件</div><div class="t m0 x0 hc y2fbb ffa3 fs2 fc0 sc0 ls8 ws1">处理程序来在恰当的时刻设置designMode，如下面的例子所示： </div><div class="t m0 x0 hb y209 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y20a ffa4 fs6 fc0 sc0 ls21 wsb">&lt;iframe name=&quot;richedit&quot; style=&quot;height:100px;width:100px;&quot; src=&quot;blank.htm&quot;&gt;&lt;/iframe&gt; </div><div class="t m0 x0 hb y2fbc ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2fbd ffa4 fs6 fc0 sc0 ls21 wsb">&lt;script type=&quot;text/javascript&quot;&gt; </div><div class="t m0 x0 hb y20d ffa4 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(window, &quot;load&quot;, function(){ </div><div class="t m0 x0 hb y2fbe ffa4 fs6 fc0 sc0 ls21 wsb">    frames[&quot;richedit&quot;].document.designMode = &quot;on&quot;; </div><div class="t m0 x0 hb y2fbf ffa4 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 hb y2fc0 ffa4 fs6 fc0 sc0 ls21 wsb">&lt;/script&gt; </div><div class="t m0 x0 hb y2fc1 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y9c ffa3 fs2 fc0 sc0 ls8 ws1">等到以上代码执行之后，你就会在页面中看到一个类似文本框的可编辑区字段。这个区字段具有与</div><div class="t m0 x0 h5 y2fc2 ffa3 fs2 fc0 sc0 ls8 ws1">其他网页相同的默认样式；不过，通过为空白页面应用CSS样式，可以修改可编辑区字段的外观。 </div><div class="t m0 x0 h20 y2282 ffa1 fs3 fc0 sc0 ls248 ws214">14.5.1 使用contenteditable属性 </div><div class="t m0 x0 h5 y2fc3 ffa3 fs2 fc0 sc0 ls8 ws1">另一种编辑富文本内容的方式是使用名为contenteditable的特殊属性，这个属性也是由IE 最</div><div class="t m0 x0 h4 y1583 ffa3 fs2 fc0 sc0 ls8 ws1">早实现的。可以把contenteditable属性应用给页面中的任何元素，然后用户立即就可以编辑该元素。</div><div class="t m0 x0 hc y2fc4 ffa3 fs2 fc0 sc0 ls221 ws1d9">这种方法之所以受到欢迎，是因为它不需要iframe、空白页和JavaScript ，只要为元素设置</div><div class="t m0 x0 h5 y2fc5 ffa4 fs1 fc0 sc0 ls9 ws2">contenteditable属性即可。 </div><div class="t m0 x0 hb y2fc6 ffa4 fs6 fc0 sc0 ls21 wsb">&lt;div class=&quot;editable&quot; id=&quot;richedit&quot; contenteditable&gt;&lt;/div&gt; </div></div></div>
<div id="pf1c9" class="pf w0 h0" data-page-no="1c9"><div class="pc pc1c9 w0 h0"><div class="t m0 x2 h2 y1 ff9d fs0 fc0 sc0 ls7 ws0">14.5 富文本编辑    439 </div><div class="t m0 x0 h3 y2 ff9d fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffa8 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ffa8 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffa8 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffa8 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffa8 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffa8 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffa8 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffa8 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffa8 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffa8 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffa8 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffa8 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ffa8 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h4 y3 ffa3 fs2 fc0 sc0 ls8 ws1">这样，元素中包含的任何文本内容就都可以编辑了，就好像这个元素变成了&lt;textarea&gt;元素一样。</div><div class="t m0 x0 hc y4d ffa3 fs2 fc0 sc0 ls8 ws1">通过在这个元素上设置contenteditable属性，也能打开或关闭编辑模式。 </div><div class="t m0 x0 h5 y2fc7 ff9d fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2fc8 ffa4 fs6 fc0 sc0 ls21 wsb">var div = document.getElementById(&quot;richedit&quot;); </div><div class="t m0 x0 hb y2fc9 ffa4 fs6 fc0 sc0 ls21 wsb">div.contentEditable = &quot;true&quot;; </div><div class="t m0 x0 hb y2fca ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y2fcb ffa4 fs1 fc0 sc0 ls9 ws2">contenteditable属性有三个可能的值：&quot;true&quot;表示打开、&quot;false&quot;表示关闭，&quot;inherit&quot;表示</div><div class="t m0 x0 h1e y2fcc ffa3 fs2 fc0 sc0 ls8 ws1">从父元素那里继承（因为可以在contenteditable元素中创建或删除元素）。支持contenteditable</div><div class="t m0 x0 h5 y2a66 ffa3 fs2 fc0 sc0 ls8 ws1">属性的元素有IE、Firefox、Chrome、Safari和Opera。在移动设备上，支持contenteditable属性的</div><div class="t m0 x0 h5 y9c3 ffa3 fs2 fc0 sc0 ls8 ws1">浏览器有iOS 5+中的Safari和Android 3+中的WebKit 。 </div><div class="t m0 x0 h20 y312 ffa1 fs3 fc0 sc0 ls248 ws214">14.5.2 操作富文本 </div><div class="t m0 x0 h4 y139 ffa3 fs2 fc0 sc0 ls8 ws1">与富文本编辑器交互的主要方式，就是使用document.execCommand()。这个方法可以对文档执</div><div class="t m0 x0 hc y13a ffa3 fs2 fc0 sc0 ls8 ws1">行预定义的命令，而且可以应用大多数格式。可以为document.execCommand()方法传递3个参数：</div><div class="t m0 x0 h4 y13b ffa3 fs2 fc0 sc0 ls8 ws1">要执行的命令名称、表示浏览器是否应该为当前命令提供用户界面的一个布尔值和执行命令必须的一个</div><div class="t m0 x0 h1e y13c ffa3 fs2 fc0 sc0 ls8 ws1">值（如果不需要值，则传递null）。为了确保跨浏览器的兼容性，第二个参数应该始终设置为false，</div><div class="t m0 x0 hc y13d ffa3 fs2 fc0 sc0 ls8 ws1">因为Firefox会在该参数为true时抛出错误。 </div><div class="t m0 x0 h4 y13e ffa3 fs2 fc0 sc0 ls8 ws1">不同浏览器支持的预定义命令也不一样。下表列出了那些被支持最多的命令。 </div><div class="t m0 x5 h31 y2fcd ffa0 fs6 fc0 sc0 lsa7 wsb">命  令 值（第三个参数） 说  明 </div><div class="t m0 x0 h32 y2fce ffa4 fsc fc0 sc0 lsa8 wsb">backcolor  颜色字符串 设置文档的背景颜色 </div><div class="t m0 x0 h32 ycd8 ffa4 fsc fc0 sc0 lsa8 ws322">bold null </div><div class="t m0 x4 h36 y2fcf ffa3 fs6 fc0 sc0 ls8 ws33">将选择的文本转换为粗体 </div><div class="t m0 x0 h32 y2a18 ffa4 fsc fc0 sc0 lsa8 ws322">copy null </div><div class="t m0 x4 h36 y1408 ffa3 fs6 fc0 sc0 ls8 ws33">将选择的文本复制到剪贴板 </div><div class="t m0 x0 h32 y204e ffa4 fsc fc0 sc0 lsa8 wsb">createlink  URL字符串 将选择的文本转换成一个链接，指向指定的URL </div><div class="t m0 x0 h32 y2fd0 ffa4 fsc fc0 sc0 lsa8 ws323">cut null </div><div class="t m0 x4 h36 yf5c ffa3 fs6 fc0 sc0 ls8 ws33">将选择的文本剪切到剪贴板 </div><div class="t m0 x0 h32 y2216 ffa4 fsc fc0 sc0 lsa8 ws324">delete null </div><div class="t m0 x4 h36 y1fb0 ffa3 fs6 fc0 sc0 ls8 ws33">删除选择的文本 </div><div class="t m0 x0 h32 y834 ffa4 fsc fc0 sc0 lsa8 wsb">fontname  字体名称 将选择的文本修改为指定字体 </div><div class="t m0 x0 h32 y605 ffa4 fsc fc0 sc0 lsa8 wsb">fontsize  1～7  将选择的文本修改为指定字体大小 </div><div class="t m0 x0 h32 y2fd1 ffa4 fsc fc0 sc0 lsa8 wsb">forecolor  颜色字符串 将选择的文本修改为指定的颜色 </div><div class="t m0 x0 h32 y72c ffa4 fsc fc0 sc0 lsa8 wsb">formatblock  要包围当前文本块的</div><div class="t m0 x1 h36 y2fd2 ff9d fs6 fc0 sc0 lsab ws84">HTML标签；如&lt;h1&gt; </div><div class="t m0 x4 h36 y2fd3 ffa3 fs6 fc0 sc0 ls8 ws33">使用指定的HTML标签来格式化选择的文本块 </div><div class="t m0 x0 h32 yedc ffa4 fsc fc0 sc0 lsa8 ws324">indent null </div><div class="t m0 x4 h36 y53c ffa3 fs6 fc0 sc0 ls8 ws33">缩进文本 </div><div class="t m0 x0 h32 y2fd4 ffa4 fsc fc0 sc0 lsa8 ws325">inserthorizontalrule null  在插入字符处插入一个&lt;hr&gt;元素 </div><div class="t m0 x0 h32 y21ad ffa4 fsc fc0 sc0 lsa8 wsb">insertimage  图像的URL  在插入字符处插入一个图像 </div><div class="t m0 x0 h32 y2fd5 ffa4 fsc fc0 sc0 lsa8 ws326">insertorderedlist null  在插入字符处插入一个&lt;ol&gt;元素 </div><div class="t m0 x0 h32 y2fd6 ffa4 fsc fc0 sc0 lsa8 ws327">insertunorderedlist null  在插入字符处插入一个&lt;ul&gt;元素 </div><div class="t m0 x0 h32 y2fd7 ffa4 fsc fc0 sc0 lsa8 ws328">insertparagraph null  在插入字符处插入一个&lt;p&gt;元素 </div><div class="t m0 x0 h32 yf89 ffa4 fsc fc0 sc0 lsa8 ws324">italic null </div><div class="t m0 x4 h36 y1ef0 ffa3 fs6 fc0 sc0 ls8 ws33">将选择的文本转换成斜体 </div><div class="t m0 x0 h32 y22f5 ffa4 fsc fc0 sc0 lsa8 ws329">justifycenter null  将插入光标所在文本块居中对齐 </div><div class="t m0 x0 h32 y13d3 ffa4 fsc fc0 sc0 lsa8 ws32a">justifyleft null  将插入光标所在文本块左对齐 </div><div class="t m0 x0 h32 y2fd8 ffa4 fsc fc0 sc0 lsa8 ws32b">outdent null 凸排文本（减少缩进） </div></div></div>
<div id="pf1ca" class="pf w0 h0" data-page-no="1ca"><div class="pc pc1ca w0 h0"><div class="t m0 x0 h2 y1 ff9d fs0 fc0 sc0 ls7 ws0">440  第14章 表单脚本 </div><div class="t m0 x0 h3 y2 ff9d fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x6 h3 y34f ffa3 fs1 fc0 sc0 ls8">（续） </div><div class="t m0 x0 h31 y2fda ffa0 fs6 fc0 sc0 lsa7 wsb">命  令 值（第三个参数） 说  明 </div><div class="t m0 x0 h32 y2fdb ffa4 fsc fc0 sc0 lsa8 ws32c">paste null </div><div class="t m0 x4 h36 y2fdc ffa3 fs6 fc0 sc0 ls8 ws33">将剪贴板中的文本粘贴到选择的文本 </div><div class="t m0 x0 h32 y2fdd ffa4 fsc fc0 sc0 lsa8 ws32d">removeformat null  移除插入光标所在文本块的块级格式。这是撤销formatblock</div><div class="t m0 x4 h36 y2fde ffa3 fs6 fc0 sc0 ls8 ws33">命令的操作 </div><div class="t m0 x0 h32 y8c7 ffa4 fsc fc0 sc0 lsa8 ws32e">selectall null 选择文档中的所有文本 </div><div class="t m0 x0 h32 y692 ffa4 fsc fc0 sc0 lsa8 ws32e">underline null 为选择的文本添加下划线 </div><div class="t m0 x0 h32 y2fdf ffa4 fsc fc0 sc0 lsa8 ws324">unlink null </div><div class="t m0 x4 h36 y2fe0 ffa3 fs6 fc0 sc0 ls8 ws33">移除文本的链接。这是撤销createlink命令的操作 </div><div class="t m0 x0 h5 y2fe1 ffa3 fs2 fc0 sc0 ls8 ws1">其中，与剪贴板有关的命令在不同浏览器中的差异极大。Opera根本没有实现任何剪贴板命令，而</div><div class="t m0 x0 h5 y2fe2 ff9d fs2 fc0 sc0 ls47 ws38">Firefox在默认情况下会禁用它们（必须修改用户的首选项来启用它们）。Safari和Chrome实现了cut和</div><div class="t m0 x0 h4 ye28 ffa4 fs1 fc0 sc0 ls9 ws2">copy，但没有实现paste。不过，即使不能通过document.execCommand()来执行这些命令，但却可</div><div class="t m0 x0 h5 ye29 ffa3 fs2 fc0 sc0 ls8 ws1">以通过相应的快捷键来实现同样的操作。 </div><div class="t m0 x0 h5 y2fe3 ffa3 fs2 fc0 sc0 ls8 ws1">可以在任何时候使用这些命令来修改富文本区域的外观，如下面的例子所示。 </div><div class="t m0 x0 hb y2fe4 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2fe5 ffa4 fs6 fc0 sc0 ls21">//转换粗体文本 </div><div class="t m0 x0 hb y2fe6 ffa4 fs6 fc0 sc0 ls21 wsb">frames[&quot;richedit&quot;].document.execCommand(&quot;bold&quot;, false, null); </div><div class="t m0 x0 hb y2fe7 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2fe8 ffa4 fs6 fc0 sc0 ls21">//转换斜体文本 </div><div class="t m0 x0 hb y2fe9 ffa4 fs6 fc0 sc0 ls21 wsb">frames[&quot;richedit&quot;].document.execCommand(&quot;italic&quot;, false, null); </div><div class="t m0 x0 hb y2fea ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2feb ffa4 fs6 fc0 sc0 ls21">//创建指向www.wrox.com的链接 </div><div class="t m0 x0 hb y2fec ffa4 fs6 fc0 sc0 ls21 wsb">frames[&quot;richedit&quot;].document.execCommand(&quot;createlink&quot;, false, </div><div class="t m0 x0 hb y2fed ffa4 fs6 fc0 sc0 ls21 wsb">                                        &quot;http://www.wrox.com&quot;); </div><div class="t m0 x0 hb y2fee ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2fef ffa4 fs6 fc0 sc0 ls21">//格式化为1级标题 </div><div class="t m0 x0 hb y2ff0 ffa4 fs6 fc0 sc0 ls21 wsb">frames[&quot;richedit&quot;].document.execCommand(&quot;formatblock&quot;, false, &quot;&lt;h1&gt;&quot;); </div><div class="t m0 x0 hb y2ff1 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y2ff2 ffab fs2 fc0 sc0 ls79 wsb">RichTextEditingExample01.htm </div><div class="t m0 x0 h4 y1fd1 ffa3 fs2 fc0 sc0 ls8 ws1">同样的方法也适用于页面中contenteditable属性为&quot;true&quot;的区块，只要把对框架的引用替换</div><div class="t m0 x0 h5 y1cd0 ffa3 fs2 fc0 sc0 ls8 ws1">成当前窗口的document对象即可。 </div><div class="t m0 x0 hb y23c3 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2ff3 ffa4 fs6 fc0 sc0 ls21">//转换粗体文本 </div><div class="t m0 x0 hb y2ff4 ffa4 fs6 fc0 sc0 ls21 wsb">document.execCommand(&quot;bold&quot;, false, null); </div><div class="t m0 x0 hb y2ff5 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2ff6 ffa4 fs6 fc0 sc0 ls21">//转换斜体文本 </div><div class="t m0 x0 hb y2ff7 ffa4 fs6 fc0 sc0 ls21 wsb">document.execCommand(&quot;italic&quot;, false, null); </div><div class="t m0 x0 hb y2ff8 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2ff9 ffa4 fs6 fc0 sc0 ls21">//创建指向www.wrox.com的链接 </div><div class="t m0 x0 hb y2ffa ffa4 fs6 fc0 sc0 ls21 wsb">document.execCommand(&quot;createlink&quot;, false, </div><div class="t m0 x0 hb y2ffb ffa4 fs6 fc0 sc0 ls21 wsb">                                        &quot;http://www.wrox.com&quot;);  </div><div class="t m0 x0 hb y2ffc ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2ffd ffa4 fs6 fc0 sc0 ls21">//格式化为1级标题 </div><div class="t m0 x0 hb y2ffe ffa4 fs6 fc0 sc0 ls21 wsb">document.execCommand(&quot;formatblock&quot;, false, &quot;&lt;h1&gt;&quot;); </div><div class="t m0 x0 hb y2fff ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y34c ffab fs2 fc0 sc0 ls79 wsb">RichTextEditingExample01.htm </div><div class="t m0 x0 h5 y3000 ffa3 fs2 fc0 sc0 ls8 ws1">需要注意的是，虽然所有浏览器都支持这些命令，但这些命令所产生的HTML仍然有很大不同。</div><div class="t m0 x0 hc y3001 ffa3 fs2 fc0 sc0 ls8 ws1">例如，执行bold命令时，IE和Opera会使用&lt;strong&gt;标签包围文本，Safari和Chrome使用&lt;b&gt;标签，</div></div></div>
<div id="pf1cb" class="pf w0 h0" data-page-no="1cb"><div class="pc pc1cb w0 h0"><div class="t m0 x2 h2 y1 ff9d fs0 fc0 sc0 ls7 ws0">14.5 富文本编辑    441 </div><div class="t m0 x0 h3 y2 ff9d fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffa8 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ffa8 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffa8 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffa8 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffa8 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffa8 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffa8 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffa8 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffa8 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffa8 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffa8 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffa8 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ffa8 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ffa3 fs2 fc0 sc0 ls21d">而Firefox则使用&lt;span&gt;标签。由于各个浏览器实现命令的方式不同，加上它们通过innerHTML实现</div><div class="t m0 x0 h5 y4d ffa3 fs2 fc0 sc0 ls8 ws1">转换的方式也不一样，因此不能指望富文本编辑器会产生一致的HTML。 </div><div class="t m0 x0 h1c yd8 ffa3 fs2 fc0 sc0 ls127 wse8">除了命令之外，还有一些与命令相关的方法。第一个方法就是queryCommandEnabled()，可以用它来检</div><div class="t m0 x0 h4 yd9 ffa3 fs2 fc0 sc0 ls75 ws56">测是否可以针对当前选择的文本，或者当前插入字符所在位置执行某个命令。这个方法接收一个参数，即要</div><div class="t m0 x0 hc y15d ffa3 fs2 fc0 sc0 ls127 wse8">检测的命令。如果当前编辑区域允许执行传入的命令，这个方法返回true，否则返回false。例如： </div><div class="t m0 x5 hb y4ef ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yfdc ffa4 fs6 fc0 sc0 ls21 wsb">var result = frames[&quot;richedit&quot;].document.queryCommandEnabled(&quot;bold&quot;); </div><div class="t m0 x5 hb y3002 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 yd44 ffa3 fs2 fc0 sc0 ls55 ws49">如果能够对当前选择的文本执行&quot;bold&quot;命令，以上代码会返回true。需要注意的是，query- </div><div class="t m0 x0 h4 y14e4 ffa4 fs1 fc0 sc0 ls9 ws2">CommandEnabled()方法返回true，并不意味着实际上就可以执行相应命令，而只能说明对当前选择</div><div class="t m0 x0 h5 y23d7 ffa3 fs2 fc0 sc0 ls8 ws1">的文本执行相应命令是否合适。例如，Firefox在默认情况下会禁用剪切操作，但执行queryCommand- </div><div class="t m0 x0 h21 y3003 ffa4 fs1 fc0 sc0 ls9 ws2">Enabled(&quot;cut&quot;)也可能会返回true。 </div><div class="t m0 x0 h1e y1d95 ffa3 fs2 fc0 sc0 ls8 ws1">另外，queryCommandState()方法用于确定是否已将指定命令应用到了选择的文本。例如，要确</div><div class="t m0 x0 h5 y1f15 ffa3 fs2 fc0 sc0 ls8 ws1">定当前选择的文本是否已经转换成了粗体，可以使用如下代码。 </div><div class="t m0 x5 hb y23da ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3004 ffa4 fs6 fc0 sc0 ls21 wsb">var isBold = frames[&quot;richedit&quot;].document.queryCommandState(&quot;bold&quot;); </div><div class="t m0 x5 hb y3005 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y3006 ffab fs2 fc0 sc0 ls79 wsb">RichTextEditingExample01.htm </div><div class="t m0 x0 h4 y1196 ffa3 fs2 fc0 sc0 ls8 ws1">如果此前已经对选择的文本执行了&quot;bold&quot;命令，那么上面的代码会返回true。一些功能全面的富</div><div class="t m0 x0 h5 y3007 ffa3 fs2 fc0 sc0 ls8 ws1">文本编辑器，正是利用这个方法来更新粗体、斜体等按钮的状态的。 </div><div class="t m0 x0 h1e y3008 ffa3 fs2 fc0 sc0 ls60 ws198">最后一个方法是queryCommandValue()，用于取得执行命令时传入的值（即前面例子中传给</div><div class="t m0 x0 h4 y3009 ffa4 fs1 fc0 sc0 ls9 ws2">document.execCommand()的第三个参数）。例如，在对一段文本应用&quot;fontsize&quot;命令时如果传入了</div><div class="t m0 x0 h5 y300a ffa4 fs1 fc0 sc0 ls8 ws23">7，那么下面的代码就会返回&quot;7&quot;： </div><div class="t m0 x5 hb y300b ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y300c ffa4 fs6 fc0 sc0 ls21 wsb">var fontSize = frames[&quot;richedit&quot;].document.queryCommandValue(&quot;fontsize&quot;); </div><div class="t m0 x5 hb y300d ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y300e ffab fs2 fc0 sc0 ls79 wsb">RichTextEditingExample01.htm </div><div class="t m0 x0 h4 y2864 ffa3 fs2 fc0 sc0 ls8 ws1">通过这个方法可以确定某个命令是怎样应用到选择的文本的，可以据以确定再对其应用后续命令是</div><div class="t m0 x0 h5 y2865 ffa3 fs2 fc0 sc0 ls8">否合适。 </div><div class="t m0 x0 h20 y300f ffa1 fs3 fc0 sc0 ls248 ws214">14.5.3 富文本选区 </div><div class="t m0 x0 h4 y13cc ffa3 fs2 fc0 sc0 ls8 ws1">在富文本编辑器中，使用框架（iframe）的getSelection()方法，可以确定实际选择的文本。</div><div class="t m0 x0 h1e y3010 ffa3 fs2 fc0 sc0 ls8 ws1">这个方法是window对象和document对象的属性，调用它会返回一个表示当前选择文本的Selection</div><div class="t m0 x0 h5 y3011 ffa3 fs2 fc0 sc0 ls8 ws1">对象。每个Selection对象都有下列属性。 </div><div class="t m0 x0 h5 y3012 ffa2 fs1 fc0 sc0 ls2"> anchorNode：选区起点所在的节点。 </div><div class="t m0 x0 h5 y632 ffa2 fs1 fc0 sc0 ls2"> anchorOffset：在到达选区起点位置之前跳过的anchorNode中的字符数量。 </div><div class="t m0 x0 h5 y3013 ffa2 fs1 fc0 sc0 ls2"> focusNode：选区终点所在的节点。 </div><div class="t m0 x0 h5 y29a2 ffa2 fs1 fc0 sc0 ls2"> focusOffset：focusNode中包含在选区之内的字符数量。 </div><div class="t m0 x0 h5 y3014 ffa2 fs1 fc0 sc0 ls2"> isCollapsed：布尔值，表示选区的起点和终点是否重合。 </div><div class="t m0 x0 h5 y7f0 ffa2 fs1 fc0 sc0 ls2"> rangeCount：选区中包含的DOM范围的数量。 </div><div class="t m0 x0 h4 y15b ffa4 fs1 fc0 sc0 ls9 ws2">Selection对象的这些属性并没有包含多少有用的信息。好在，该对象的下列方法提供了更多信</div><div class="t m0 x0 h5 y2762 ffa3 fs2 fc0 sc0 ls8 ws1">息，并且支持对选区的操作。 </div></div></div>
<div id="pf1cc" class="pf w0 h0" data-page-no="1cc"><div class="pc pc1cc w0 h0"><div class="t m0 x0 h2 y1 ff9d fs0 fc0 sc0 ls7 ws0">442  第14章 表单脚本 </div><div class="t m0 x0 h3 y2 ff9d fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ffa2 fs1 fc0 sc0 ls2"> addRange(range)：将指定的DOM范围添加到选区中。 </div><div class="t m0 x0 h5 y4 ffa2 fs1 fc0 sc0 ls2"> collapse(node, offset)：将选区折叠到指定节点中的相应的文本偏移位置。 </div><div class="t m0 x0 h5 y4e ffa2 fs1 fc0 sc0 ls2"> collapseToEnd()：将选区折叠到终点位置。 </div><div class="t m0 x0 h5 yd9 ffa2 fs1 fc0 sc0 ls2"> collapseToStart()：将选区折叠到起点位置。 </div><div class="t m0 x0 h5 y219 ffa2 fs1 fc0 sc0 ls2"> containsNode(node)：确定指定的节点是否包含在选区中。 </div><div class="t m0 x0 h4 y8 ffa2 fs1 fc0 sc0 ls8 ws134"> deleteFromDocument()：从文档中删除选区中的文本，与document.execCommand(&quot;delete&quot;, </div><div class="t m0 x0 h21 y3015 ffa4 fs1 fc0 sc0 ls43 ws32f">false, null)命令的结果相同。 </div><div class="t m0 x0 h5 ya ffa2 fs1 fc0 sc0 ls2"> extend(node, offset)：通过将focusNode和focusOffset移动到指定的值来扩展选区。 </div><div class="t m0 x0 h5 yb ffa2 fs1 fc0 sc0 ls2"> getRangeAt(index)：返回索引对应的选区中的DOM范围。 </div><div class="t m0 x0 h5 yc ffa2 fs1 fc0 sc0 ls2"> removeAllRanges()：从选区中移除所有DOM范围。实际上，这样会移除选区，因为选区中</div><div class="t m0 x0 h5 y116b ffa3 fs2 fc0 sc0 ls8 ws1">至少要有一个范围。 </div><div class="t m0 x0 h5 y21b ffa2 fs1 fc0 sc0 ls2"> reomveRange(range)：从选区中移除指定的DOM范围。 </div><div class="t m0 x0 h5 y21c ffa2 fs1 fc0 sc0 ls2"> selectAllChildren(node)：清除选区并选择指定节点的所有子节点。 </div><div class="t m0 x0 h5 y10 ffa2 fs1 fc0 sc0 ls2"> toString()：返回选区所包含的文本内容。 </div><div class="t m0 x0 h5 y11 ffa4 fs1 fc0 sc0 ls9 ws2">Selection对象的这些方法都极为实用，它们利用了（第12章讨论过的）DOM范围来管理选区。</div><div class="t m0 x0 h5 y12 ffa3 fs2 fc0 sc0 ls8 ws1">由于可以直接操作选择文本的DOM表现，因此访问DOM范围与使用execCommand()相比，能够对富</div><div class="t m0 x0 h5 y13 ffa3 fs2 fc0 sc0 ls8 ws1">文本编辑器进行更加细化的控制。下面来看一个例子。 </div><div class="t m0 x0 hb y26c6 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y26c7 ffa4 fs6 fc0 sc0 ls21 wsb">var selection = frames[&quot;richedit&quot;].getSelection(); </div><div class="t m0 x0 hb y3016 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y3017 ffa4 fs6 fc0 sc0 ls21">//取得选择的文本 </div><div class="t m0 x0 hb y3018 ffa4 fs6 fc0 sc0 ls21 wsb">var selectedText = selection.toString(); </div><div class="t m0 x0 hb y3019 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y301a ffa4 fs6 fc0 sc0 ls21">//取得代表选区的范围 </div><div class="t m0 x0 hb y301b ffa4 fs6 fc0 sc0 ls21 wsb">var range = selection.getRangeAt(0); </div><div class="t m0 x0 hb y301c ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y301d ffa4 fs6 fc0 sc0 ls21">//突出显示选择的文本 </div><div class="t m0 x0 hb y301e ffa4 fs6 fc0 sc0 ls21 wsb">var span = frames[&quot;richedit&quot;].document.createElement(&quot;span&quot;); </div><div class="t m0 x0 hb y301f ffa4 fs6 fc0 sc0 ls21 wsb">span.style.backgroundColor = &quot;yellow&quot;; </div><div class="t m0 x0 hb y3020 ffa4 fs6 fc0 sc0 ls21 wsb">range.surroundContents(span); </div><div class="t m0 x0 hb y3021 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y3022 ffab fs2 fc0 sc0 ls79 wsb">RichTextEditingExample01.htm </div><div class="t m0 x0 h5 y3023 ffa3 fs2 fc0 sc0 ls8 ws1">以上代码会为富文本编辑器中被选择的文本添加黄色的背景。这里使用了默认选区中的DOM范围，</div><div class="t m0 x0 hc y3024 ffa3 fs2 fc0 sc0 ls8 ws1">通过surroundContents()方法将选区添加到了带有黄色背景的&lt;span&gt;元素中。 </div><div class="t m0 x0 hc y3025 ff9d fs2 fc0 sc0 ls2f ws8a">HTML5将getSelection()方法纳入了标准，而且IE9、Firefox、Safari、Chrome和Opera 8都实</div><div class="t m0 x0 h5 y3026 ffa3 fs2 fc0 sc0 ls8 ws1">现了它。由于历史原因，在Firefox 3.6+中调用document.getSelection()会返回一个字符串。为此，</div><div class="t m0 x0 h5 y3027 ffa3 fs2 fc0 sc0 ls8 ws1">可以在Firefox 3.6+中改作调用window.getSelection()，从而返回selection对象。Firefox 8修复</div><div class="t m0 x0 hc y3028 ffa3 fs2 fc0 sc0 lsfb">了document.getSelection()的bug，能返回与window.getSelection()相同的值。 </div><div class="t m0 x0 h5 y3029 ff9d fs2 fc0 sc0 ls2a ws21">IE8及更早的版本不支持DOM范围，但我们可以通过它支持的selection对象操作选择的文本。</div><div class="t m0 x0 h5 y302a ff9d fs2 fc0 sc0 lse ws9">IE中的selection对象是document的属性，本章前面曾经讨论过。要取得富文本编辑器中选择的文</div><div class="t m0 x0 hc y302b ffa3 fs2 fc0 sc0 ls8 ws1">本，首先必须创建一个文本范围（请参考第12章中的相关内容），然后再像下面这样访问其text属性。 </div><div class="t m0 x0 hb y192f ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y302c ffa4 fs6 fc0 sc0 ls21 wsb">var range = frames[&quot;richedit&quot;].document.selection.createRange(); </div><div class="t m0 x0 hb y302d ffa4 fs6 fc0 sc0 ls21 wsb">var selectedText = range.text; </div><div class="t m0 x0 hb y302e ffa4 fs6 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf1cd" class="pf w0 h0" data-page-no="1cd"><div class="pc pc1cd w0 h0"><div class="t m0 x2 h2 y1 ff9d fs0 fc0 sc0 ls7 ws0">14.6 小结  443 </div><div class="t m0 x0 h3 y2 ff9d fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffa8 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ffa8 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffa8 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffa8 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffa8 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffa8 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffa8 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffa8 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffa8 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffa8 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffa8 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffa8 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ffa8 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ffa3 fs2 fc0 sc0 ls8 ws1">虽然使用IE的文本范围来执行HTML操作并不像使用 DOM范围那么可靠，但也不失为一种有效</div><div class="t m0 x0 h5 y4d ffa3 fs2 fc0 sc0 ls30 ws2a">的途径。要像前面使用DOM范围那样实现相同的文本高亮效果，可以组合使用 htmlText属性和</div><div class="t m0 x0 h5 y4e ffa4 fs1 fc0 sc0 ls9 ws2">pasteHTML()方法。 </div><div class="t m0 x5 hb y6bd ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y6be ffa4 fs6 fc0 sc0 ls21 wsb">var range = frames[&quot;richedit&quot;].document.selection.createRange(); </div><div class="t m0 x0 hb y6bf ffa4 fs6 fc0 sc0 ls21 wsb">range.pasteHTML(&quot;&lt;span style=\&quot;background-color:yellow\&quot;&gt; &quot; + range.htmlText + </div><div class="t m0 x0 hb y6c0 ffa4 fs6 fc0 sc0 ls21 wsb">                &quot;&lt;/span&gt;&quot;);  </div><div class="t m0 x5 hb y302f ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y2321 ffa3 fs2 fc0 sc0 ls8 ws1">以上代码通过htmlText取得了当前选区中的HTML，然后将其放在了一对&lt;span&gt;标签中，最后</div><div class="t m0 x0 hc y2733 ffa3 fs2 fc0 sc0 ls8 ws1">又使用pasteHTML()将结果重新插入到了选区中。 </div><div class="t m0 x0 h20 y10b5 ffa1 fs3 fc0 sc0 ls248 ws214">14.5.4 表单与富文本 </div><div class="t m0 x0 h4 y1346 ffa3 fs2 fc0 sc0 ls8 ws1">由于富文本编辑是使用iframe而非表单控件实现的，因此从技术上说，富文本编辑器并不属于表</div><div class="t m0 x0 h5 y3030 ffa3 fs2 fc0 sc0 ls30 ws2a">单。换句话说，富文本编辑器中的HTML不会被自动提交给服务器，而需要我们手工来提取并提交</div><div class="t m0 x0 he y3031 ff9d fs2 fc0 sc0 lsfa wsc9">HTML。为此，通常可以添加一个隐藏的表单字段，让它的值等于从iframe中提取出的HTML。具体</div><div class="t m0 x0 hc y3032 ffa3 fs2 fc0 sc0 ls8 ws1">来说，就是在提交表单之前，从iframe中提取出HTML，并将其插入到隐藏的字段中。下面就是通过</div><div class="t m0 x0 h5 y3033 ffa3 fs2 fc0 sc0 ls8 ws1">表单的onsubmit事件处理程序实现上述操作的代码。 </div><div class="t m0 x5 hb y2381 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3034 ffa4 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(form, &quot;submit&quot;, function(event){ </div><div class="t m0 x0 hb y3035 ffa4 fs6 fc0 sc0 ls21 wsb">    event = EventUtil.getEvent(event); </div><div class="t m0 x0 hb y3036 ffa4 fs6 fc0 sc0 ls21 wsb">    var target = EventUtil.getTarget(event); </div><div class="t m0 x0 hb y3037 ffa4 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3038 ffa4 fs6 fc0 sc0 ls21 wsb">    target.elements[&quot;comments&quot;].value = frames[&quot;richedit&quot;].document.body.innerHTML; </div><div class="t m0 x0 hb y3039 ffa4 fs6 fc0 sc0 ls21 wsb">});  </div><div class="t m0 x2 hf y831 ffab fs2 fc0 sc0 ls79 wsb">RichTextEditingExample01.htm </div><div class="t m0 x0 h5 y303a ffa3 fs2 fc0 sc0 ls8 ws1">在此，我们通过文档主体的innerHTML属性取得了iframe中的 HTML，然后将其插入到了名为</div><div class="t m0 x0 h4 y279 ffa4 fs1 fc0 sc0 ls9 ws2">&quot;comments&quot;的表单字段中。这样可以确保恰好在提交表单之前填充&quot;comments&quot;字段。如果你想在代</div><div class="t m0 x0 h1e y303b ffa3 fs2 fc0 sc0 ls8 ws1">码中通过submit()来手工提交表单，那么一定不要忘记事先执行上面的操作。对于contenteditable</div><div class="t m0 x0 h5 y303c ffa3 fs2 fc0 sc0 ls8 ws1">元素，也可以执行类似操作。 </div><div class="t m0 x0 h5 y303d ff9d fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1795 ffa4 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(form, &quot;submit&quot;, function(event){ </div><div class="t m0 x0 hb y303e ffa4 fs6 fc0 sc0 ls21 wsb">    event = EventUtil.getEvent(event); </div><div class="t m0 x0 hb y303f ffa4 fs6 fc0 sc0 ls21 wsb">    var target = EventUtil.getTarget(event); </div><div class="t m0 x0 hb y3040 ffa4 fs6 fc0 sc0 ls21 wsb">   </div><div class="t m0 x0 hb y3041 ffa4 fs6 fc0 sc0 ls21 wsb">    target.elements[&quot;comments&quot;].value = </div><div class="t m0 x0 hb y3042 ffa4 fs6 fc0 sc0 ls21 wsb">        document.getElementById(&quot;richedit&quot;).innerHTML; </div><div class="t m0 x0 hb y3043 ffa4 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 h15 y3044 ffaa fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hd y3045 ffa1 fs7 fc0 sc0 ls245">14.6 小结 </div><div class="t m0 x0 h5 y3046 ffa3 fs2 fc0 sc0 ls30 ws2a">虽然HTML和Web应用自诞生以来已经发生了天翻地覆的变化，但Web 表单相对却没有什么改</div><div class="t m0 x0 h5 y3047 ffa3 fs2 fc0 sc0 ls24 ws1e">变。使用JavaScript可以增强已有的表单字段，从而创造出新的功能，或者提升表单的易用性。为此，</div><div class="t m0 x0 h5 y49c ffa3 fs2 fc0 sc0 ls30 ws2a">表单、表单字段都引入了相应的属性和方法，以便JavaScript使用。下面是本章介绍的几个概念。 </div><div class="t m0 x0 h5 y126b ffa2 fs1 fc0 sc0 ls2"> 可以使用一些标准或非标准的方法选择文本框中的全部或部分文本。 </div><div class="t m0 x0 h5 y126c ffa2 fs1 fc0 sc0 ls2"> 大多数浏览器都采用了Firefox操作选择文本的方式，但IE仍然坚持自己的实现。 </div></div></div>
<div id="pf1ce" class="pf w0 h0" data-page-no="1ce"><div class="pc pc1ce w0 h0"><div class="t m0 x0 h2 y1 ff9d fs0 fc0 sc0 ls7 ws0">444  第14章 表单脚本 </div><div class="t m0 x0 h3 y2 ff9d fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ffa2 fs1 fc0 sc0 ls2"> 在文本框的内容变化时，可以通过侦听键盘事件以及检测插入的字符，来允许或禁止用户输入</div><div class="t m0 x0 h5 y4d ffa3 fs2 fc0 sc0 ls8 ws1">某些字符。 </div><div class="t m0 x0 h5 yd8 ffa3 fs2 fc0 sc0 ls98">除Opera之外的所有浏览器都支持剪贴板事件，包括copy、cut和paste。其他浏览器在实现剪</div><div class="t m0 x0 h5 yd9 ffa3 fs2 fc0 sc0 ls8 ws1">贴板事件时也可以分为几种不同的情况。 </div><div class="t m0 x0 h5 y219 ffa2 fs1 fc0 sc0 ls2"> IE、Firefox、Chrome和Safari允许通过JavaScript访问剪贴板中的数据，而Opera不允许这种访</div><div class="t m0 x0 h5 y21a ffa3 fs2 fc0 sc0 ls8">问方式。 </div><div class="t m0 x0 h5 y9 ffa2 fs1 fc0 sc0 ls2"> 即使是IE、Chrome和Safari，它们各自的实现方式也不相同。 </div><div class="t m0 x0 h5 ya ffa2 fs1 fc0 sc0 ls2"> Firefox、Safari和Chrome只允许在paste事件发生时读取剪贴板数据，而IE 没有这个限制。 </div><div class="t m0 x0 h5 yb ffa2 fs1 fc0 sc0 ls2"> Firefox、Safari和Chrome只允许在发生剪贴板事件时访问与剪贴板相关的信息，而IE允许在任</div><div class="t m0 x0 h5 y78a ffa3 fs2 fc0 sc0 ls8 ws1">何时候访问相关信息。 </div><div class="t m0 x0 h4 y3048 ffa3 fs2 fc0 sc0 ls8 ws1">在文本框内容必须限制为某些特定字符的情况下，就可以利用剪贴板事件来屏蔽通过粘贴向文本框</div><div class="t m0 x0 h5 y3049 ffa3 fs2 fc0 sc0 ls8 ws1">中插入内容的操作。 </div><div class="t m0 x0 h5 y304a ffa3 fs2 fc0 sc0 ls8 ws1">选择框也是经常要通过JavaScript来控制的一个表单字段。由于有了DOM，对选择框的操作比以前</div><div class="t m0 x0 h4 y304b ffa3 fs2 fc0 sc0 ls8 ws1">要方便多了。添加选项、移除选项、将选项从一个选择框移动到另一个选择框，甚至对选项进行排序等</div><div class="t m0 x0 h5 y304c ffa3 fs2 fc0 sc0 ls8 ws1">操作，都可以使用标准的DOM技术来实现。 </div><div class="t m0 x0 h5 y304d ffa3 fs2 fc0 sc0 ls3ba ws330">富文本编辑功能是通过一个包含空HTML文档的 iframe元素来实现的。通过将空文档的</div><div class="t m0 x0 h4 y13 ffa4 fs1 fc0 sc0 ls9 ws2">designMode属性设置为&quot;on&quot;，就可以将该页面转换为可编辑状态，此时其表现如同字处理软件。另外，</div><div class="t m0 x0 h1e y14 ffa3 fs2 fc0 sc0 ls8 ws1">也可以将某个元素设置为contenteditable。在默认情况下，可以将字体加粗或者将文本转换为斜体，</div><div class="t m0 x0 h5 y24ab ffa3 fs2 fc0 sc0 ls8 ws1">还可以使用剪贴板。JavaScript通过使用execCommand()方法也可以实现相同的一些功能。另外，使用</div><div class="t m0 x0 h4 y16 ffa4 fs1 fc0 sc0 ls9 ws2">queryCommandEnabled()、queryCommandState()和queryCommandValue()方法则可以取得有关</div><div class="t m0 x0 h4 y17 ffa3 fs2 fc0 sc0 ls24">文本选区的信息。由于以这种方式构建的富文本编辑器并不是一个表单字段，因此在将其内容提交给</div><div class="t m0 x0 hc y18 ffa3 fs2 fc0 sc0 ls5 ws4">服务器之前，必须将iframe或contenteditable元素中的HTML复制到一个表单字段中。 </div><div class="t m0 x0 h5 y304e ff9d fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y304f ff9d fs2 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf1cf" class="pf w0 h0" data-page-no="1cf"><div class="pc pc1cf w0 h0"><div class="t m0 x2 h2 y1 ffb0 fs0 fc0 sc0 ls7 ws0">15.1 基本用法    445 </div><div class="t m0 x0 h3 y2 ffb0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffb2 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ffb2 fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ffb2 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffb2 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffb2 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffb2 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffb2 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffb2 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffb2 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffb2 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffb2 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ffb2 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ffb2 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h9 y2a ffb3 fs5 fc0 sc0 ls12 wsb">使用Canvas绘图 </div><div class="t m0 x0 h3c y2b ffb4 fs2 fc0 sc0 ls8">本章内容 </div><div class="t m0 x0 h5 y2c ffb6 fs1 fc0 sc0 ls2"> 理解&lt;canvas&gt;元素 </div><div class="t m0 x0 h5 y2d ffb6 fs1 fc0 sc0 ls2"> 绘制简单的2D图形 </div><div class="t m0 x0 h5 y2e ffb6 fs1 fc0 sc0 ls2"> 使用WebGL绘制3D图形 </div><div class="t m0 x0 h5 y8d9 ffb0 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x5 h5 y8da ffb7 fs2 fc0 sc0 ls8 wseb">用说，HTML5添加的最受欢迎的功能就是&lt;canvas&gt;元素。这个元素负责在页面中设定一个</div><div class="t m0 x5 h5 y3050 ffb7 fs2 fc0 sc0 ls8 wseb">区域，然后就可以通过JavaScript动态地在这个区域中绘制图形。&lt;canvas&gt;元素最早是由苹</div><div class="t m0 x0 h5 y3051 ffb7 fs2 fc0 sc0 ls8 wseb">果公司推出的，当时主要用在其Dashboard微件中。很快，HTML5加入了这个元素，主流浏览器也迅</div><div class="t m0 x0 h5 y3052 ffb7 fs2 fc0 sc0 ls8 wseb">速开始支持它。IE9+、Firefox 1.5+、Safari 2+、Opera 9+、Chrome、iOS版Safari以及Android版WebKit</div><div class="t m0 x0 he y3053 ffb7 fs2 fc0 sc0 ls8 wseb">都在某种程度上支持&lt;canvas&gt;。 </div><div class="t m0 x0 hc y3054 ffb7 fs2 fc0 sc0 ls8 wseb">与浏览器环境中的其他组件类似，&lt;canvas&gt;由几组API构成，但并非所有浏览器都支持所有这些</div><div class="t m0 x0 h5 y1fcf ffb0 fs2 fc0 sc0 ls25 wsb3">API。除了具备基本绘图能力的2D上下文，&lt;canvas&gt;还建议了一个名为WebGL的3D上下文。目前，</div><div class="t m0 x0 h5 y3055 ffb7 fs2 fc0 sc0 ls8 wseb">支持该元素的浏览器都支持2D上下文及文本API，但对WebGL的支持还不够好。由于 WebGL还是实</div><div class="t m0 x0 h5 y3056 ffb7 fs2 fc0 sc0 ls8 wseb">验性的，因此要得到所有浏览器支持还需要很长一段时间。Firefox 4+和Chrome支持WebGL规范的早</div><div class="t m0 x0 h5 y3057 ffb7 fs2 fc0 sc0 ls8 wseb">期版本，但一些老版本的操作系统，比如Windows XP，由于缺少必要的绘图驱动程序，即便安装了这</div><div class="t m0 x0 h5 y3058 ffb7 fs2 fc0 sc0 ls8 wseb">两款浏览器也无济于事。 </div><div class="t m0 x0 hd y3059 ffb5 fs7 fc0 sc0 ls245">15.1 基本用法 </div><div class="t m0 x0 h4 y28e8 ffb7 fs2 fc0 sc0 ls8 wseb">要使用&lt;canvas&gt;元素，必须先设置其width和height属性，指定可以绘图的区域大小。出现在</div><div class="t m0 x0 h4 y2c55 ffb7 fs2 fc0 sc0 ls6 wsf7">开始和结束标签中的内容是后备信息，如果浏览器不支持&lt;canvas&gt;元素，就会显示这些信息。下面就</div><div class="t m0 x0 hc y305a ffb7 fs2 fc0 sc0 ls3bb">是&lt;canvas&gt;元素的例子。 </div><div class="t m0 x0 hb y28e2 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y305b ffb8 fs6 fc0 sc0 ls21 wsb">&lt;canvas id=&quot;drawing&quot; width=&quot; 200&quot; height=&quot;200&quot;&gt;A drawing of something.&lt;/canvas&gt; </div><div class="t m0 x0 hb y305c ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y305d ffb7 fs2 fc0 sc0 ls8 wseb">与其他元素一样，&lt;canvas&gt;元素对应的DOM元素对象也有width和height 属性，可以随意修</div><div class="t m0 x0 h5 y305e ffb7 fs2 fc0 sc0 ls8 wseb">改。而且，也能通过CSS为该元素添加样式，如果不添加任何样式或者不绘制任何图形，在页面中是看</div><div class="t m0 x0 h5 y305f ffb7 fs2 fc0 sc0 ls8 wseb">不到该元素的。 </div><div class="t m0 x0 h5 y3060 ffb7 fs2 fc0 sc0 ls8 wseb">要在这块画布（canvas）上绘图，需要取得绘图上下文。而取得绘图上下文对象的引用，需要调用</div><div class="t m0 x0 h5 y144b ffb8 fs1 fc0 sc0 ls9 ws2">getContext()方法并传入上下文的名字。传入&quot;2d&quot;，就可以取得2D上下文对象。 </div><div class="t m0 x0 hb yc07 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3061 ffb8 fs6 fc0 sc0 ls21 wsb">var drawing = document.getElementById(&quot;drawing&quot;); </div><div class="t m0 x0 hb y3062 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y3063 ffb8 fs6 fc0 sc0 ls21">//确定浏览器支持&lt;canvas&gt;元素 </div><div class="t m0 x0 hb y3064 ffb8 fs6 fc0 sc0 ls21 wsb">if (drawing.getContext){ </div><div class="t m0 x0 hff y338 ffb4 fs16 fc0 sc0 ls8 wsb">不 </div><div class="t m0 x0 h11 y4b ffb9 fsa fc0 sc0 ls8">第</div><div class="t m1 x0 h12 y4b ffba fsb fc3 sc0 ls247">15</div><div class="t m0 x5 h9 y4b ffb9 fsa fc0 sc0 ls8 ws1d">章 </div></div></div>
<div id="pf1d0" class="pf w0 h0" data-page-no="1d0"><div class="pc pc1d0 w0 h0"><div class="t m0 x0 h2 y1 ffb0 fs0 fc0 sc0 ls7 ws0">446  第15章 使用Canvas绘图 </div><div class="t m0 x0 h3 y2 ffb0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 ffb8 fs6 fc0 sc0 ls21 wsb">var context = drawing.getContext(&quot;2d&quot;); </div><div class="t m0 x0 h34 y7a ffb8 fs6 fc0 sc0 ls21">//更多代码 </div><div class="t m0 x0 hb y7b ffb8 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y105 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3066 ffb7 fs2 fc0 sc0 ls8 wseb">在使用&lt;canvas&gt;元素之前，首先要检测getContext()方法是否存在，这一步非常重要。有些浏</div><div class="t m0 x0 h69 y3067 ffb7 fs2 fc0 sc0 ls8 wseb">览器会为HTML规范之外的元素创建默认的HTML元素对象①。在这种情况下，即使 drawing变量中</div><div class="t m0 x0 hc y3068 ffb7 fs2 fc0 sc0 ls8 wseb">保存着一个有效的元素引用，也检测不到getContext()方法。 </div><div class="t m0 x0 h4 y3069 ffb7 fs2 fc0 sc0 ls8 wseb">使用toDataURL()方法，可以导出在&lt;canvas&gt;元素上绘制的图像。这个方法接受一个参数，即图</div><div class="t m0 x0 h5 y306a ffb7 fs2 fc0 sc0 ls8 wseb">像的MIME类型格式，而且适合用于创建图像的任何上下文。比如，要取得画布中的一幅PNG格式的</div><div class="t m0 x0 h5 y306b ffb7 fs2 fc0 sc0 ls8 wseb">图像，可以使用以下代码。 </div><div class="t m0 x0 hb y306c ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y306d ffb8 fs6 fc0 sc0 ls21 wsb">var drawing = document.getElementById(&quot;drawing&quot;);  </div><div class="t m0 x0 hb y1c55 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y306e ffb8 fs6 fc0 sc0 ls21">//确定浏览器支持&lt;canvas&gt;元素 </div><div class="t m0 x0 hb y306f ffb8 fs6 fc0 sc0 ls21 wsb">if (drawing.getContext){ </div><div class="t m0 x0 hb y3070 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y3071 ffbb fs6 fc0 sc0 ls21 wsb">    //取得图像的数据URI </div><div class="t m0 x0 h15 y3072 ffbb fs6 fc0 sc0 ls21 wsb">    var imgURI = drawing.toDataURL(&quot;image/png&quot;); </div><div class="t m0 x0 h15 y3073 ffbb fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y3074 ffbb fs6 fc0 sc0 ls21 wsb">    //显示图像 </div><div class="t m0 x0 h15 y3075 ffbb fs6 fc0 sc0 ls21 wsb">    var image = document.createElement(&quot;img&quot;); </div><div class="t m0 x0 h15 y3076 ffbb fs6 fc0 sc0 ls21 wsb">    image.src = imgURI; </div><div class="t m0 x0 h15 y3077 ffbb fs6 fc0 sc0 ls21 wsb">    document.body.appendChild(image); </div><div class="t m0 x0 hb y3078 ffb8 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 h28 y5e ffb8 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y5d6 ffbc fs2 fc0 sc0 ls1b wsb">2DDataUrlExample01.htm </div><div class="t m0 x0 h5 y3079 ffb7 fs2 fc0 sc0 ls24 wsf5">默认情况下，浏览器会将图像编码为PNG格式（除非另行指定）。Firefox和Opera 也支持基于</div><div class="t m0 x0 h5 y307a ffb8 fs1 fc0 sc0 ls9 ws2">&quot;image/jpeg&quot;参数的JPEG编码格式。由于这个方法是后来才追加的，所以支持&lt;canvas&gt;的浏览器也</div><div class="t m0 x0 h5 y307b ffb7 fs2 fc0 sc0 ls8 wseb">是在较新的版本中才加入了对它的支持，比如IE9、Firefox 3.5和Opera 10。 </div><div class="t m0 x5 h60 y307c ffb1 fs2 fc0 sc0 ls8 ws14">如果绘制到画布上的图像源自不同的域，toDataURL()方法会抛出错误。本章后</div><div class="t m0 x0 h5 y307d ffb1 fs2 fc0 sc0 ls8 ws14">面还将介绍更多相关内容。 </div><div class="t m0 x0 hd y307e ffb5 fs7 fc0 sc0 ls245">15.2 2D上下文 </div><div class="t m0 x0 h5 y307f ffb7 fs2 fc0 sc0 ls8 wseb">使用2D绘图上下文提供的方法，可以绘制简单的2D图形，比如矩形、弧线和路径。2D上下文的</div><div class="t m0 x0 hc y3080 ffb7 fs2 fc0 sc0 ls8 wseb">坐标开始于&lt;canvas&gt;元素的左上角，原点坐标是(0,0)。所有坐标值都基于这个原点计算，x值越大表示</div><div class="t m0 x0 h4 y3081 ffb7 fs2 fc0 sc0 ls8">越靠右，y值越大表示越靠下。默认情况下，width和height表示水平和垂直两个方向上可用的像素</div><div class="t m0 x0 h5 y3082 ffb7 fs2 fc0 sc0 ls8">数目。 </div><div class="t m0 x0 h20 y1d54 ffb5 fs3 fc0 sc0 ls248 ws214">15.2.1 填充和描边 </div><div class="t m0 x0 h5 y3083 ffb0 fs2 fc0 sc0 ls8 ws20">2D上下文的两种基本绘图操作是填充和描边。填充，就是用指定的样式（颜色、渐变或图像）填</div><div class="t m0 x0 h5 y3084 ffb7 fs2 fc0 sc0 ls8 wseb">充图形；描边，就是只在图形的边缘画线。大多数2D上下文操作都会细分为填充和描边两个操作，而</div><div class="t m0 x0 h3c y3085 ffb4 fs2 fc0 sc0 ls7b wsb">—————————— </div><div class="t m0 x0 h36 ycc5 ffb7 fs6 fc0 sc0 ls95">① 假设你想在Firefox 3中使用&lt;canvas&gt;元素。虽然浏览器会为该标签创建一个DOM对象，而且也可以引用它，但</div><div class="t m0 x0 h36 y3086 ffb7 fs6 fc0 sc0 ls8 ws124">这个对象中并没有getContext()方法。（据作者回复） </div></div></div>
<div id="pf1d1" class="pf w0 h0" data-page-no="1d1"><div class="pc pc1d1 w0 h0"><div class="t m0 x2 h2 y1 ffb0 fs0 fc0 sc0 ls7 ws0">15.2 2D上下文   447 </div><div class="t m0 x0 h3 y2 ffb0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffb2 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ffb2 fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ffb2 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffb2 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffb2 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffb2 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffb2 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffb2 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffb2 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffb2 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffb2 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ffb2 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ffb2 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ffb7 fs2 fc0 sc0 ls8 wseb">操作的结果取决于两个属性：fillStyle和strokeStyle。 </div><div class="t m0 x0 h1e y4d ffb7 fs2 fc0 sc0 ls8 wseb">这两个属性的值可以是字符串、渐变对象或模式对象，而且它们的默认值都是&quot;#000000&quot;。如果为</div><div class="t m0 x0 h5 y5 ffb7 fs2 fc0 sc0 ls6 wsf7">它们指定表示颜色的字符串值，可以使用CSS中指定颜色值的任何格式，包括颜色名、十六进制码、</div><div class="t m0 x0 h5 yd9 ffb8 fs1 fc0 sc0 ls9 ws2">rgb、rgba、hsl或hsla。举个例子： </div><div class="t m0 x0 hb ya81 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ya82 ffb8 fs6 fc0 sc0 ls21 wsb">var drawing = document.getElementById(&quot;drawing&quot;);  </div><div class="t m0 x0 hb ya83 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y1908 ffb8 fs6 fc0 sc0 ls21">//确定浏览器支持&lt;canvas&gt;元素 </div><div class="t m0 x0 hb y1909 ffb8 fs6 fc0 sc0 ls21 wsb">if (drawing.getContext){ </div><div class="t m0 x0 hb y190a ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y190b ffb8 fs6 fc0 sc0 ls21 wsb">    var context = drawing.getContext(&quot;2d&quot;); </div><div class="t m0 x0 hb y190c ffb8 fs6 fc0 sc0 ls21 wsb">    context.strokeStyle = &quot;red&quot;; </div><div class="t m0 x0 hb y190d ffb8 fs6 fc0 sc0 ls21 wsb">    context.fillStyle = &quot;#0000ff&quot;; </div><div class="t m0 x0 hb y190e ffb8 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y3087 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y20b2 ffb7 fs2 fc0 sc0 ls8 wseb">以上代码将strokeStyle设置为red（CSS中的颜色名），将fillStyle设置为#0000ff（蓝色）。</div><div class="t m0 x0 h4 y2d60 ffb7 fs2 fc0 sc0 ls8 wseb">然后，所有涉及描边和填充的操作都将使用这两个样式，直至重新设置这两个值。如前所述，这两个属</div><div class="t m0 x0 h5 y3088 ffb7 fs2 fc0 sc0 ls8 wseb">性的值也可以是渐变对象或模式对象。本章后面会讨论这两种对象。 </div><div class="t m0 x0 h20 y3051 ffb5 fs3 fc0 sc0 ls248 ws214">15.2.2 绘制矩形 </div><div class="t m0 x0 h5 y3089 ffb7 fs2 fc0 sc0 ls4 ws10d">矩形是唯一一种可以直接在2D上下文中绘制的形状。与矩形有关的方法包括 fillRect()、</div><div class="t m0 x0 h5 y254f ffb8 fs1 fc0 sc0 ls9 ws2">strokeRect()和clearRect()。这三个方法都能接收4个参数：矩形的x坐标、矩形的y坐标、矩形</div><div class="t m0 x0 h5 y308a ffb7 fs2 fc0 sc0 ls8 wseb">宽度和矩形高度。这些参数的单位都是像素。 </div><div class="t m0 x0 h1c y308b ffb7 fs2 fc0 sc0 ls8 wseb">首先，fillRect()方法在画布上绘制的矩形会填充指定的颜色。填充的颜色通过fillStyle属</div><div class="t m0 x0 h5 y2947 ffb7 fs2 fc0 sc0 ls8 wseb">性指定，比如： </div><div class="t m0 x0 hb y308c ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y308d ffb8 fs6 fc0 sc0 ls21 wsb">var drawing = document.getElementById(&quot;drawing&quot;);  </div><div class="t m0 x0 hb y308e ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y308f ffb8 fs6 fc0 sc0 ls21">//确定浏览器支持&lt;canvas&gt;元素 </div><div class="t m0 x0 hb y3090 ffb8 fs6 fc0 sc0 ls21 wsb">if (drawing.getContext){ </div><div class="t m0 x0 hb y3091 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3092 ffb8 fs6 fc0 sc0 ls21 wsb">    var context = drawing.getContext(&quot;2d&quot;); </div><div class="t m0 x0 hb y3093 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3094 ffb8 fs6 fc0 sc0 ls21 wsb">    /* </div><div class="t m0 x0 h34 y3095 ffb8 fs6 fc0 sc0 ls21 wsb">     * 根据Mozilla的文档 </div><div class="t m0 x0 hb y3096 ffb8 fs6 fc0 sc0 ls21 wsb">     * http://developer.mozilla.org/en/docs/Canvas_tutorial:Basic_usage </div><div class="t m0 x0 hb y3097 ffb8 fs6 fc0 sc0 ls21 wsb">     */ </div><div class="t m0 x0 hb y3098 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y3099 ffbb fs6 fc0 sc0 ls21 wsb">    //绘制红色矩形 </div><div class="t m0 x0 h15 y309a ffbb fs6 fc0 sc0 ls21 wsb">    context.fillStyle = &quot;#ff0000&quot;; </div><div class="t m0 x0 h15 y309b ffbb fs6 fc0 sc0 ls21 wsb">    context.fillRect(10, 10, 50, 50); </div><div class="t m0 x0 h15 y309c ffbb fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y309d ffbb fs6 fc0 sc0 ls21 wsb">    //绘制半透明的蓝色矩形 </div><div class="t m0 x0 h15 y309e ffbb fs6 fc0 sc0 ls21 wsb">    context.fillStyle = &quot;rgba(0,0,255,0.5)&quot;; </div><div class="t m0 x0 h15 y309f ffbb fs6 fc0 sc0 ls21 wsb">    context.fillRect(30, 30, 50, 50); </div><div class="t m0 x0 hb y30a0 ffb8 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y30a1 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y30a2 ffbc fs2 fc0 sc0 ls7a wsb">2DFillRectExample01.htm </div><div class="t m0 x0 h5 y15b ffb7 fs2 fc0 sc0 ls8 wseb">以上代码首先将fillStyle设置为红色，然后从(10,10)处开始绘制矩形，矩形的宽和高均为50像</div><div class="t m0 x0 h4 y17cc ffb7 fs2 fc0 sc0 ls8 wseb">素。然后，通过rgba()格式再将fillStyle设置为半透明的蓝色，在第一个矩形上面绘制第二个矩</div></div></div>
<div id="pf1d2" class="pf w0 h0" data-page-no="1d2"><div class="pc pc1d2 w0 h0"><div class="t m0 x0 h2 y1 ffb0 fs0 fc0 sc0 ls7 ws0">448  第15章 使用Canvas绘图 </div><div class="t m0 x0 h3 y2 ffb0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ffb7 fs2 fc0 sc0 ls8 wseb">形。结果就是可以透过蓝色的矩形看到红色的矩形（见图15-1）。 </div><div class="t m0 x0 h4 y4 ffb8 fs1 fc0 sc0 ls9 ws2">strokeRect()方法在画布上绘制的矩形会使用指定的颜色描边。描边颜色通</div><div class="t m0 x0 hc y5 ffb7 fs2 fc0 sc0 lsd9">过strokeStyle属性指定。比如： </div><div class="t m0 x0 hb y6bd ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y6be ffb8 fs6 fc0 sc0 ls21 wsb">var drawing = document.getElementById(&quot;drawing&quot;); </div><div class="t m0 x0 hb y30a3 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y30a4 ffb8 fs6 fc0 sc0 ls21">//确定浏览器支持&lt;canvas&gt;元素 </div><div class="t m0 x0 hb y30a5 ffb8 fs6 fc0 sc0 ls21 wsb">if (drawing.getContext){ </div><div class="t m0 x0 hb y30a6 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y30a7 ffb8 fs6 fc0 sc0 ls21 wsb">    var context = drawing.getContext(&quot;2d&quot;); </div><div class="t m0 x0 hb y30a8 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y30a9 ffb8 fs6 fc0 sc0 ls21 wsb">    /* </div><div class="t m0 x0 h34 y30aa ffb8 fs6 fc0 sc0 ls21 wsb">     * 根据Mozilla的文档 </div><div class="t m0 x0 hb y30ab ffb8 fs6 fc0 sc0 ls21 wsb">     * http://developer.mozilla.org/en/docs/Canvas_tutorial:Basic_usage </div><div class="t m0 x0 hb y30ac ffb8 fs6 fc0 sc0 ls21 wsb">     */ </div><div class="t m0 x0 hb y30ad ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y30ae ffbb fs6 fc0 sc0 ls21 wsb">    //绘制红色描边矩形 </div><div class="t m0 x0 h15 y30af ffbb fs6 fc0 sc0 ls21 wsb">    context.strokeStyle = &quot;#ff0000&quot;; </div><div class="t m0 x0 h15 y30b0 ffbb fs6 fc0 sc0 ls21 wsb">    context.strokeRect(10, 10, 50, 50); </div><div class="t m0 x0 h15 y30b1 ffbb fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y30b2 ffbb fs6 fc0 sc0 ls21 wsb">    //绘制半透明的蓝色描边矩形 </div><div class="t m0 x0 h15 y30b3 ffbb fs6 fc0 sc0 ls21 wsb">    context.strokeStyle = &quot;rgba(0,0,255,0.5)&quot;; </div><div class="t m0 x0 h15 y30b4 ffbb fs6 fc0 sc0 ls21 wsb">    context.strokeRect(30, 30, 50, 50); </div><div class="t m0 x0 hb y30b5 ffb8 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y30b6 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y30b7 ffbc fs2 fc0 sc0 ls1b wsb">2DStrokeRectExample01.htm </div><div class="t m0 x0 h5 y30b8 ffb7 fs2 fc0 sc0 ls8 wseb">以上代码绘制了两个重叠的矩形。不过，这两个矩形都只有框线，内部并没有填充颜色（见图15-2）。 </div><div class="t m0 x4 h5 y30b9 ffb0 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x7 h3 y80b ffb7 fs1 fc0 sc0 ls8 wsb">图 15-2 </div><div class="t m0 x5 ha y2ac1 ffb1 fs2 fc0 sc0 ls8 ws14">描边线条的宽度由lineWidth属性控制，该属性的值可以是任意整数。另外，</div><div class="t m0 x0 h101 y30ba ffb1 fs2 fc0 sc0 ls4 ws337">通过lineCap属性可以控制线条末端的形状是平头、圆头还是方头（&quot;butt&quot;、</div><div class="t m0 x0 ha y11cb ffb8 fs1 fc0 sc0 ls9 ws2">&quot;round&quot;或&quot;square&quot;），通过lineJoin属性可以控制线条相交的方式是圆交、斜</div><div class="t m0 x0 h18 y30bb ffb1 fs2 fc0 sc0 ls8 ws14">交还是斜接（&quot;round&quot;、&quot;bevel&quot;或&quot;miter&quot;）。 </div><div class="t m0 x0 h4 y30bc ffb7 fs2 fc0 sc0 ls8 wseb">最后，clearRect()方法用于清除画布上的矩形区域。本质上，这个方法可以把绘制上下文中的某</div><div class="t m0 x0 h4 y30bd ffb7 fs2 fc0 sc0 ls8 wseb">一矩形区域变透明。通过绘制形状然后再清除指定区域，就可以生成有意思的效果，例如把某个形状切</div><div class="t m0 x0 h5 y30be ffb7 fs2 fc0 sc0 ls8 wseb">掉一块。下面看一个例子。 </div><div class="t m0 x0 hb y30bf ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y30c0 ffb8 fs6 fc0 sc0 ls21 wsb">var drawing = document.getElementById(&quot;drawing&quot;); </div><div class="t m0 x0 hb y30c1 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y30c2 ffb8 fs6 fc0 sc0 ls21">//确定浏览器支持&lt;canvas&gt;元素 </div><div class="t m0 x0 hb y30c3 ffb8 fs6 fc0 sc0 ls21 wsb">if (drawing.getContext){ </div><div class="t m0 x0 hb y30c4 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y30c5 ffb8 fs6 fc0 sc0 ls21 wsb">    var context = drawing.getContext(&quot;2d&quot;); </div><div class="t m0 x6 h5 y30c6 ffb0 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 h5 y30c7 ffb7 fs1 fc0 sc0 ls8 wsb">图 15-1 </div></div></div>
<div id="pf1d3" class="pf w0 h0" data-page-no="1d3"><div class="pc pc1d3 w0 h0"><div class="t m0 x2 h2 y1 ffb0 fs0 fc0 sc0 ls7 ws0">15.2 2D上下文   449 </div><div class="t m0 x0 h3 y2 ffb0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffb2 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ffb2 fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ffb2 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffb2 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffb2 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffb2 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffb2 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffb2 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffb2 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffb2 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffb2 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ffb2 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ffb2 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y79 ffb8 fs6 fc0 sc0 ls21 wsb">    /* </div><div class="t m0 x0 h34 y7a ffb8 fs6 fc0 sc0 ls21 wsb">     * 根据Mozilla的文档 </div><div class="t m0 x0 hb y7b ffb8 fs6 fc0 sc0 ls21 wsb">     * http://developer.mozilla.org/en/docs/Canvas_tutorial:Basic_usage </div><div class="t m0 x0 hb y7c ffb8 fs6 fc0 sc0 ls21 wsb">     */ </div><div class="t m0 x0 hb y7d ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y7e ffb8 fs6 fc0 sc0 ls21 wsb">    //绘制红色矩形 </div><div class="t m0 x0 hb y7f ffb8 fs6 fc0 sc0 ls21 wsb">    context.fillStyle = &quot;#ff0000&quot;; </div><div class="t m0 x0 hb y80 ffb8 fs6 fc0 sc0 ls21 wsb">    context.fillRect(10, 10, 50, 50); </div><div class="t m0 x0 hb y81 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y82 ffb8 fs6 fc0 sc0 ls21 wsb">    //绘制半透明的蓝色矩形 </div><div class="t m0 x0 hb y83 ffb8 fs6 fc0 sc0 ls21 wsb">    context.fillStyle = &quot;rgba(0,0,255,0.5)&quot;; </div><div class="t m0 x0 hb y84 ffb8 fs6 fc0 sc0 ls21 wsb">    context.fillRect(30, 30, 50, 50); </div><div class="t m0 x0 hb y85 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y86 ffbb fs6 fc0 sc0 ls21 wsb">    //在两个矩形重叠的地方清除一个小矩形 </div><div class="t m0 x0 h15 y87 ffbb fs6 fc0 sc0 ls21 wsb">    context.clearRect(40, 40, 10, 10); </div><div class="t m0 x0 hb y88 ffb8 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y383 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1b34 ffbc fs2 fc0 sc0 ls1b wsb">2DClearRectExample01.htm </div><div class="t m0 x0 h5 y1b35 ffb7 fs2 fc0 sc0 ls8 wseb">如图15-3所示，两个填充矩形重叠在一起，而重叠的地方又被清除了一个小</div><div class="t m0 x0 h5 y30c8 ffb7 fs2 fc0 sc0 ls8 wseb">矩形区域。 </div><div class="t m0 x0 h20 y30c9 ffb5 fs3 fc0 sc0 ls248 ws214">15.2.3 绘制路径 </div><div class="t m0 x0 h5 y30ca ffb0 fs2 fc0 sc0 ls8 ws20">2D绘制上下文支持很多在画布上绘制路径的方法。通过路径可以创造出复</div><div class="t m0 x0 h4 y1f1c ffb7 fs2 fc0 sc0 ls6 wsf7">杂的形状和线条。要绘制路径，首先必须调用beginPath()方法，表示要开始</div><div class="t m0 x0 h5 y30cb ffb7 fs2 fc0 sc0 ls8 wseb">绘制新路径。然后，再通过调用下列方法来实际地绘制路径。 </div><div class="t m0 x0 h4 y30cc ffb6 fs1 fc0 sc0 ls2"> arc(x, y, radius, startAngle, endAngle, counterclockwise)：以(x,y)为圆心绘</div><div class="t m0 x5 h1e y30cd ffb7 fs2 fc0 sc0 ls30 wsf6">制一条弧线，弧线半径为radius，起始和结束角度（用弧度表示）分别为startAngle 和</div><div class="t m0 x5 h4 y30ce ffb8 fs1 fc0 sc0 ls9 ws2">endAngle。最后一个参数表示startAngle和endAngle是否按逆时针方向计算，值为false</div><div class="t m0 x5 h5 y2cb3 ffb7 fs2 fc0 sc0 ls8 wseb">表示按顺时针方向计算。 </div><div class="t m0 x0 h4 y30cf ffb6 fs1 fc0 sc0 ls2"> arcTo(x1, y1, x2, y2, radius)：从上一点开始绘制一条弧线，到(x2,y2)为止，并且以</div><div class="t m0 x5 hc y30d0 ffb7 fs2 fc0 sc0 ls8 wseb">给定的半径radius穿过(x1,y1)。 </div><div class="t m0 x0 h4 y30d1 ffb6 fs1 fc0 sc0 ls2"> bezierCurveTo(c1x, c1y, c2x, c2y, x, y)：从上一点开始绘制一条曲线，到(x,y)为</div><div class="t m0 x5 hc y30d2 ffb7 fs2 fc0 sc0 ls8 wseb">止，并且以(c1x,c1y)和(c2x,c2y)为控制点。 </div><div class="t m0 x0 h5 y188a ffb6 fs1 fc0 sc0 ls2"> lineTo(x, y)：从上一点开始绘制一条直线，到(x,y)为止。 </div><div class="t m0 x0 h5 y30d3 ffb6 fs1 fc0 sc0 ls2"> moveTo(x, y)：将绘图游标移动到(x,y)，不画线。 </div><div class="t m0 x0 h4 y2cf ffb6 fs1 fc0 sc0 ls2"> quadraticCurveTo(cx, cy, x, y)：从上一点开始绘制一条二次曲线，到(x,y)为止，并</div><div class="t m0 x5 h5 y30d4 ffb7 fs2 fc0 sc0 ls8 wseb">且以(cx,cy)作为控制点。 </div><div class="t m0 x0 h4 y196d ffb6 fs1 fc0 sc0 ls2"> rect(x, y, width, height)：从点(x,y)开始绘制一个矩形，宽度和高度分别由width和</div><div class="t m0 x5 h4 y196e ffb8 fs1 fc0 sc0 ls9 ws2">height指定。这个方法绘制的是矩形路径，而不是strokeRect()和fillRect()所绘制的独</div><div class="t m0 x5 h5 y30d5 ffb7 fs2 fc0 sc0 ls8 wseb">立的形状。 </div><div class="t m0 x0 h4 y30d6 ffb7 fs2 fc0 sc0 ls4 ws10d">创建了路径后，接下来有几种可能的选择。如果想绘制一条连接到路径起点的线条，可以调用</div><div class="t m0 x0 h4 y1971 ffb8 fs1 fc0 sc0 ls9 ws2">closePath()。如果路径已经完成，你想用fillStyle填充它，可以调用fill()方法。另外，还可</div><div class="t m0 x0 h1e y30d7 ffb7 fs2 fc0 sc0 ls8 wseb">以调用stroke()方法对路径描边，描边使用的是strokeStyle。最后还可以调用clip()，这个方法</div><div class="t m0 x0 h5 y30d8 ffb7 fs2 fc0 sc0 ls8 wseb">可以在路径上创建一个剪切区域。 </div><div class="t m0 x6 h5 y2048 ffb0 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x6 h3 y30d9 ffb7 fs1 fc0 sc0 ls8 wsb">图 15-3 </div></div></div>
<div id="pf1d4" class="pf w0 h0" data-page-no="1d4"><div class="pc pc1d4 w0 h0"><div class="t m0 x0 h2 y1 ffb0 fs0 fc0 sc0 ls7 ws0">450  第15章 使用Canvas绘图 </div><div class="t m0 x0 h3 y2 ffb0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ffb7 fs2 fc0 sc0 ls8 wseb">下面看一个例子，即绘制一个不带数字的时钟表盘。 </div><div class="t m0 x0 hb yfb2 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yfb3 ffb8 fs6 fc0 sc0 ls21 wsb">var drawing = document.getElementById(&quot;drawing&quot;);  </div><div class="t m0 x0 hb yfb4 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 yfb5 ffb8 fs6 fc0 sc0 ls21">//确定浏览器支持&lt;canvas&gt;元素 </div><div class="t m0 x0 hb yfb6 ffb8 fs6 fc0 sc0 ls21 wsb">if (drawing.getContext){ </div><div class="t m0 x0 hb yfb7 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yfb8 ffb8 fs6 fc0 sc0 ls21 wsb">    var context = drawing.getContext(&quot;2d&quot;); </div><div class="t m0 x0 hb yfb9 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 yfba ffbb fs6 fc0 sc0 ls21 wsb">    //开始路径 </div><div class="t m0 x0 h15 yfbb ffbb fs6 fc0 sc0 ls21 wsb">    context.beginPath(); </div><div class="t m0 x0 h15 y2005 ffbb fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y2006 ffbb fs6 fc0 sc0 ls21 wsb">    //绘制外圆 </div><div class="t m0 x0 h103 y30db ffbb fs6 fc0 sc0 ls21 wsb">    context.arc(100, 100, 99, 0, 2 * Math.PI, false); </div><div class="t m0 x0 h104 y30dc ffbb fs15 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y30dd ffbb fs6 fc0 sc0 ls21 wsb">    //绘制内圆 </div><div class="t m0 x0 h104 y103c ffbb fs6 fc0 sc0 ls21 wsb">    context.moveTo(194, 100); </div><div class="t m0 x0 h104 y30de ffbb fs6 fc0 sc0 ls21 wsb">    context.arc(100, 100, 94, 0, 2 * Math.PI, false); </div><div class="t m0 x0 h104 y30df ffbb fs15 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y297 ffbb fs6 fc0 sc0 ls21 wsb">    //绘制分针 </div><div class="t m0 x0 h104 y30e0 ffbb fs6 fc0 sc0 ls21 wsb">    context.moveTo(100, 100); </div><div class="t m0 x0 h104 y11 ffbb fs6 fc0 sc0 ls21 wsb">    context.lineTo(100, 15); </div><div class="t m0 x0 h104 y30e1 ffbb fs15 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y30e2 ffbb fs6 fc0 sc0 ls21 wsb">    //绘制时针 </div><div class="t m0 x0 h104 y30e3 ffbb fs6 fc0 sc0 ls21 wsb">    context.moveTo(100, 100); </div><div class="t m0 x0 h104 y30e4 ffbb fs6 fc0 sc0 ls21 wsb">    context.lineTo(35, 100); </div><div class="t m0 x0 h15 ye2f ffbb fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y30e5 ffbb fs6 fc0 sc0 ls21 wsb">    //描边路径 </div><div class="t m0 x0 h15 y30e6 ffbb fs6 fc0 sc0 ls21 wsb">    context.stroke(); </div><div class="t m0 x0 hb y30e7 ffb8 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y30e8 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y930 ffbc fs2 fc0 sc0 ls2b wsb">2DPathExample01.htm </div><div class="t m0 x0 h4 y15cc ffb7 fs2 fc0 sc0 ls8 wseb">这个例子使用arc()方法绘制了两个圆形：一个外圆和一个内圆，构成了表盘的边框。外圆的半径</div><div class="t m0 x0 h5 y30e9 ffb7 fs2 fc0 sc0 ls3b">是99像素，圆心位于点(100,100)，也是画布的中心点。为了绘制一个完整的圆形，我们从0弧度开始，</div><div class="t m0 x0 h5 y30ea ffb7 fs2 fc0 sc0 ls8 wseb">绘制2π弧度（通过Math.PI来计算）。在绘制内圆之前，必须把路径移动到内圆上的某一点，以避免</div><div class="t m0 x0 h1e y1ea2 ffb7 fs2 fc0 sc0 ls5 wsec">绘制出多余的线条。第二次调用arc()使用了小一点的半径，以便创造边框的效果。然后，组合使用</div><div class="t m0 x0 h4 y30eb ffb8 fs1 fc0 sc0 ls9 ws2">moveTo()和lineTo()方法来绘制时针和分针。最后一步是调用stroke()方法，这样才能把图形绘制</div><div class="t m0 x0 h5 y30ec ffb7 fs2 fc0 sc0 ls8 wseb">到画布上，如图15-4所示。 </div><div class="t m0 x4 h5 ycb8 ffb0 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x7 h3 y30ed ffb7 fs1 fc0 sc0 ls8 wsb">图 15-4 </div></div></div>
<div id="pf1d5" class="pf w0 h0" data-page-no="1d5"><div class="pc pc1d5 w0 h0"><div class="t m0 x2 h2 y1 ffb0 fs0 fc0 sc0 ls7 ws0">15.2 2D上下文   451 </div><div class="t m0 x0 h3 y2 ffb0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffb2 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ffb2 fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ffb2 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffb2 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffb2 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffb2 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffb2 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffb2 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffb2 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffb2 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffb2 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ffb2 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ffb2 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ffb7 fs2 fc0 sc0 ls71">在2D绘图上下文中，路径是一种主要的绘图方式，因为路径能为要绘制的图形提供更多控制。由</div><div class="t m0 x0 h1e y4d ffb7 fs2 fc0 sc0 ls8 wseb">于路径的使用很频繁，所以就有了一个名为isPointInPath()的方法。这个方法接收x和y坐标作为</div><div class="t m0 x0 h5 y5 ffb7 fs2 fc0 sc0 ls8 wseb">参数，用于在路径被关闭之前确定画布上的某一点是否位于路径上，例如： </div><div class="t m0 x0 hb y6bd ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y6be ffb8 fs6 fc0 sc0 ls21 wsb">if (context.isPointInPath(100, 100)){ </div><div class="t m0 x0 hb y6bf ffb8 fs6 fc0 sc0 ls21 wsb">    alert(&quot;Point (100, 100) is in the path.&quot;); </div><div class="t m0 x0 hb y6c0 ffb8 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y302f ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y2321 ffb0 fs2 fc0 sc0 ls8 ws20">2D上下文中的路径API已经非常稳定，可以利用它们结合不同的填充和描边样式，绘制出非常复</div><div class="t m0 x0 h5 y2733 ffb7 fs2 fc0 sc0 ls8 wseb">杂的图形来。 </div><div class="t m0 x0 h20 y30ee ffb5 fs3 fc0 sc0 ls248 ws214">15.2.4 绘制文本 </div><div class="t m0 x0 h5 y1346 ffb7 fs2 fc0 sc0 ls6 wsf7">文本与图形总是如影随形。为此，2D绘图上下文也提供了绘制文本的方法。绘制文本主要有两个</div><div class="t m0 x0 hc y3030 ffb7 fs2 fc0 sc0 ls8 wseb">方法：fillText()和strokeText()。这两个方法都可以接收4个参数：要绘制的文本字符串、x坐</div><div class="t m0 x0 h5 y30ef ffb7 fs2 fc0 sc0 ls8">标、y坐标和可选的最大像素宽度。而且，这两个方法都以下列3个属性为基础。 </div><div class="t m0 x0 h5 y82a ffb6 fs1 fc0 sc0 ls2"> font：表示文本样式、大小及字体，用CSS中指定字体的格式来指定，例如&quot;10px Arial&quot;。 </div><div class="t m0 x0 h4 y3033 ffb6 fs1 fc0 sc0 ls2"> textAlign：表示文本对齐方式。可能的值有&quot;start&quot;、&quot;end&quot;、&quot;left&quot;、&quot;right&quot;和&quot;center&quot;。</div><div class="t m0 x5 h1e y30f0 ffb7 fs2 fc0 sc0 ls6 wsf7">建议使用&quot;start&quot;和&quot;end&quot;，不要使用&quot;left&quot;和&quot;right&quot;，因为前两者的意思更稳妥，能同时</div><div class="t m0 x5 h5 y30f1 ffb7 fs2 fc0 sc0 ls8 wseb">适合从左到右和从右到左显示（阅读）的语言。 </div><div class="t m0 x0 h4 y30f2 ffb6 fs1 fc0 sc0 ls2"> textBaseline：表示文本的基线。可能的值有&quot;top&quot;、&quot; hanging&quot;、&quot;middle&quot;、&quot;alphabetic&quot;、</div><div class="t m0 x5 h5 y1ca5 ffb8 fs1 fc0 sc0 ls9 ws2">&quot;ideographic&quot;和&quot;bottom&quot;。 </div><div class="t m0 x0 h1e y30f3 ffb7 fs2 fc0 sc0 lsa ws10a">这几个属性都有默认值，因此没有必要每次使用它们都重新设置一遍值。fillText()方法使用</div><div class="t m0 x0 h4 y228a ffb8 fs1 fc0 sc0 ls9 ws2">fillStyle属性绘制文本，而strokeText()方法使用strokeStyle属性为文本描边。相对来说，还</div><div class="t m0 x0 h1e y30f4 ffb7 fs2 fc0 sc0 ls8 wseb">是使用fillText()的时候更多，因为该方法模仿了在网页中正常显示文本。例如，下面的代码在前一</div><div class="t m0 x0 h5 y30f5 ffb7 fs2 fc0 sc0 ls8 wseb">节创建的表盘上方绘制了数字12： </div><div class="t m0 x0 hb y30f6 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y30f7 ffb8 fs6 fc0 sc0 ls21 wsb">context.font = &quot;bold 14px Arial&quot;; </div><div class="t m0 x0 hb y30f8 ffb8 fs6 fc0 sc0 ls21 wsb">context.textAlign = &quot;center&quot;; </div><div class="t m0 x0 hb y30f9 ffb8 fs6 fc0 sc0 ls21 wsb">context.textBaseline = &quot;middle&quot;; </div><div class="t m0 x0 hb y30fa ffb8 fs6 fc0 sc0 ls21 wsb">context.fillText(&quot;12&quot;, 100, 20); </div><div class="t m0 x0 hb y30fb ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y30fc ffbc fs2 fc0 sc0 ls25 ws26a">2D TextExample01.htm </div><div class="t m0 x0 h5 y15d1 ffb7 fs2 fc0 sc0 ls8 wseb">结果如图15-5所示。 </div><div class="t m0 x2 h5 y30fd ffb0 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 h3 y2021 ffb7 fs1 fc0 sc0 ls8 wsb">图 15-5 </div></div></div>
<div id="pf1d6" class="pf w0 h0" data-page-no="1d6"><div class="pc pc1d6 w0 h0"><div class="t m0 x0 h2 y1 ffb0 fs0 fc0 sc0 ls7 ws0">452  第15章 使用Canvas绘图 </div><div class="t m0 x0 h3 y2 ffb0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ffb7 fs2 fc0 sc0 ls8 wseb">因为这里把textAlign设置为&quot;center&quot;，把textBaseline设置为&quot;middle&quot;，所以坐标(100,20)</div><div class="t m0 x0 h1e y4d ffb7 fs2 fc0 sc0 ls8 wseb">表示的是文本水平和垂直中点的坐标。如果将textAlign设置为&quot;start&quot;，则x坐标表示的是文本左</div><div class="t m0 x0 h1e y5 ffb7 fs2 fc0 sc0 ls8 wseb">端的位置（从左到右阅读的语言）；设置为&quot;end&quot;，则x坐标表示的是文本右端的位置（从左到右阅读的</div><div class="t m0 x0 h5 yd9 ffb7 fs2 fc0 sc0 ls8 wseb">语言）。例如： </div><div class="t m0 x0 hb ya81 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 ya82 ffb8 fs6 fc0 sc0 ls21">//正常 </div><div class="t m0 x0 hb ya83 ffb8 fs6 fc0 sc0 ls21 wsb">context.font = &quot;bold 14px Arial&quot;; </div><div class="t m0 x0 hb y1908 ffb8 fs6 fc0 sc0 ls21 wsb">context.textAlign = &quot;center&quot;; </div><div class="t m0 x0 hb y1909 ffb8 fs6 fc0 sc0 ls21 wsb">context.textBaseline = &quot;middle&quot;; </div><div class="t m0 x0 hb y190a ffb8 fs6 fc0 sc0 ls21 wsb">context.fillText(&quot;12&quot;, 100, 20); </div><div class="t m0 x0 hb y190b ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y190c ffbb fs6 fc0 sc0 ls21 ws34">//起点对齐 </div><div class="t m0 x0 h15 y190d ffbb fs6 fc0 sc0 ls21 wsb">context.textAlign = &quot;start&quot;; </div><div class="t m0 x0 h15 y190e ffbb fs6 fc0 sc0 ls21 wsb">context.fi llText(&quot;12&quot;, 100, 40); </div><div class="t m0 x0 h15 y190f ffbb fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y1910 ffbb fs6 fc0 sc0 ls21 ws34">//终点对齐 </div><div class="t m0 x0 h15 y1911 ffbb fs6 fc0 sc0 ls21 wsb">context.textAlign = &quot;end&quot;; </div><div class="t m0 x0 h15 y223e ffbb fs6 fc0 sc0 ls21 wsb">context.fi llText(&quot;12&quot;, 100, 60); </div><div class="t m0 x0 hb y1b5d ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y30ff ffbc fs2 fc0 sc0 ls1b wsb">2DTextExample02.htm </div><div class="t m0 x0 h4 y3100 ffb7 fs2 fc0 sc0 ls8 wseb">这一回绘制了三个字符串&quot;12&quot;，每个字符串的x坐标值相同，但textAlign值不同。另外，后两</div><div class="t m0 x0 h5 y3101 ffb7 fs2 fc0 sc0 ls8 wseb">个字符串的y坐标依次增大，以避免相互重叠。结果如图15-6所示。 </div><div class="t m0 x4 h5 y1716 ffb0 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x7 h3 y3102 ffb7 fs1 fc0 sc0 ls8 wsb">图 15-6 </div><div class="t m0 x0 h4 y3103 ffb7 fs2 fc0 sc0 ls8 wseb">表盘中的分针恰好位于正中间，因此文本的水平对齐方式如何变化也能够一目了然。类似地，修改</div><div class="t m0 x0 h4 y3104 ffb8 fs1 fc0 sc0 ls9 ws2">textBaseline属性的值可以调整文本的垂直对齐方式：值为&quot;top&quot;，y坐标表示文本顶端；值为</div><div class="t m0 x0 h4 y3105 ffb8 fs1 fc0 sc0 ls9 ws2">&quot;bottom&quot;，y坐标表示文本底端；值为&quot;hanging&quot;、&quot;alphabetic&quot;和&quot;ideographic&quot;，则y坐标分</div><div class="t m0 x0 h5 y3106 ffb7 fs2 fc0 sc0 ls8 wseb">别指向字体的特定基线坐标。 </div><div class="t m0 x0 h5 y3107 ffb7 fs2 fc0 sc0 ls6 wsf7">由于绘制文本比较复杂，特别是需要把文本控制在某一区域中的时候，2D上下文提供了辅助确定</div><div class="t m0 x0 h1c y3108 ffb7 fs2 fc0 sc0 ls8 wseb">文本大小的方法measureText()。这个方法接收一个参数，即要绘制的文本；返回一个TextMetrics</div><div class="t m0 x0 h5 y2dc6 ffb7 fs2 fc0 sc0 ls8 wseb">对象。返回的对象目前只有一个width属性，但将来还会增加更多度量属性。 </div><div class="t m0 x0 h4 y3109 ffb8 fs1 fc0 sc0 ls9 ws2">measureText()方法利用font、textAlign和textBaseline的当前值计算指定文本的大小。</div><div class="t m0 x0 h5 y310a ffb7 fs2 fc0 sc0 ls8 wseb">比如，假设你想在一个140像素宽的矩形区域中绘制文本Hello world!，下面的代码从100 像素的字体</div><div class="t m0 x0 h5 y310b ffb7 fs2 fc0 sc0 ls8 wseb">大小开始递减，最终会找到合适的字体大小。 </div><div class="t m0 x0 hb y1aa1 ffb8 fs6 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf1d7" class="pf w0 h0" data-page-no="1d7"><div class="pc pc1d7 w0 h0"><div class="t m0 x2 h2 y1 ffb0 fs0 fc0 sc0 ls7 ws0">15.2 2D上下文   453 </div><div class="t m0 x0 h3 y2 ffb0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffb2 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ffb2 fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ffb2 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffb2 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffb2 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffb2 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffb2 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffb2 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffb2 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffb2 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffb2 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ffb2 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ffb2 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y79 ffb8 fs6 fc0 sc0 ls21 wsb">var fontSize = 100; </div><div class="t m0 x0 hb y7a ffb8 fs6 fc0 sc0 ls21 wsb">context.font = fontSize + &quot;px Arial&quot;;  </div><div class="t m0 x0 hb y7b ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y7c ffb8 fs6 fc0 sc0 ls21 wsb">while(context.measureText(&quot;Hello world!&quot;).width &gt; 140){ </div><div class="t m0 x0 hb y7d ffb8 fs6 fc0 sc0 ls21 wsb">    fontSize--; </div><div class="t m0 x0 hb y7e ffb8 fs6 fc0 sc0 ls21 wsb">    context.font = fontSize + &quot;px Arial&quot;; </div><div class="t m0 x0 hb y7f ffb8 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y80 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y81 ffb8 fs6 fc0 sc0 ls21 wsb">context.fillText(&quot;Hello world!&quot;, 10, 10); </div><div class="t m0 x0 hb y82 ffb8 fs6 fc0 sc0 ls21 wsb">context.fillText(&quot;Font size is &quot; + fontSize + &quot;px&quot;, 10, 50); </div><div class="t m0 x0 hb y310c ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y310d ffbc fs2 fc0 sc0 ls1b wsb">2DTextExample03.htm </div><div class="t m0 x0 h4 y310e ffb7 fs2 fc0 sc0 ls8 wseb">前面提到过，fillText和strokeText()方法都可以接收第四个参数，</div><div class="t m0 x0 h4 y310f ffb7 fs2 fc0 sc0 ls8 wseb">也就是文本的最大像素宽度。不过，这个可选的参数尚未得到所有浏览器支持</div><div class="t m0 x0 h5 y3110 ffb7 fs2 fc0 sc0 ls169 ws131">（最早支持它的是Firefox 4）。提供这个参数后，调用fillText()或</div><div class="t m0 x0 h4 ycab ffb8 fs1 fc0 sc0 ls9 ws2">strokeText()时如果传入的字符串大于最大宽度，则绘制的文本字符的高度</div><div class="t m0 x0 h5 y3111 ffb7 fs2 fc0 sc0 ls8 wseb">正确，但宽度会收缩以适应最大宽度。图15-7展示了这个效果。 </div><div class="t m0 x0 h1c y3112 ffb7 fs2 fc0 sc0 ls6 wsf7">绘制文本还是相对比较复杂的操作，因此支持&lt;canvas&gt;元素的浏览器也并未完全实现所有与绘制</div><div class="t m0 x0 h5 y3113 ffb7 fs2 fc0 sc0 ls8 wseb">文本相关的API。 </div><div class="t m0 x0 h20 y52d ffb5 fs3 fc0 sc0 ls248 ws214">15.2.5 变换 </div><div class="t m0 x0 h5 y172f ffb7 fs2 fc0 sc0 ls8 wseb">通过上下文的变换，可以把处理后的图像绘制到画布上。2D绘制上下文支持各种基本的绘制变换。</div><div class="t m0 x0 h4 y3114 ffb7 fs2 fc0 sc0 ls8 wseb">创建绘制上下文时，会以默认值初始化变换矩阵，在默认的变换矩阵下，所有处理都按描述直接绘制。</div><div class="t m0 x0 h5 y3115 ffb7 fs2 fc0 sc0 ls8 wseb">为绘制上下文应用变换，会导致使用不同的变换矩阵应用处理，从而产生不同的结果。 </div><div class="t m0 x0 h5 y3116 ffb7 fs2 fc0 sc0 ls8 wseb">可以通过如下方法来修改变换矩阵。 </div><div class="t m0 x0 h5 y3117 ffb6 fs1 fc0 sc0 ls2"> rotate(angle)：围绕原点旋转图像angle弧度。 </div><div class="t m0 x0 h4 y3118 ffb6 fs1 fc0 sc0 ls2"> scale(scaleX, scaleY)：缩放图像，在x方向乘以scaleX，在y方向乘以scaleY。scaleX</div><div class="t m0 x5 h5 y3119 ffb7 fs2 fc0 sc0 ls2c">和scaleY的默认值都是1.0。 </div><div class="t m0 x0 h5 y311a ffb6 fs1 fc0 sc0 ls2"> translate(x, y)：将坐标原点移动到(x,y)。执行这个变换之后，坐标(0,0)会变成之前由(x,y)</div><div class="t m0 x5 h5 y311b ffb7 fs2 fc0 sc0 ls8 wseb">表示的点。 </div><div class="t m0 x0 h5 y311c ffb6 fs1 fc0 sc0 ls2"> transform(m1_1, m1_2, m2_1, m2_2, dx, dy)：直接修改变换矩阵，方式是乘以如下 </div><div class="t m0 x5 h5 y311d ffb7 fs2 fc0 sc0 ls8">矩阵。 </div><div class="t m0 x5 h28 y30d3 ffb8 fs1 fc0 sc0 ls9">m1_1  m1_2  dx </div><div class="t m0 x5 h28 y311e ffb8 fs1 fc0 sc0 ls9">m2_1  m2_2  dy </div><div class="t m0 x5 h28 y2410 ffb8 fs1 fc0 sc0 ls8">0     0      1 </div><div class="t m0 x0 h42 y311f ffb6 fs1 fc0 sc0 ls2"> setTransform(m1_1, m1_2, m2_1, m2_2, dx, dy)：将变换矩阵重置为默认状态，然后</div><div class="t m0 x5 h5 y815 ffb7 fs2 fc0 sc0 ls8 wseb">再调用transform()。 </div><div class="t m0 x0 h4 y3120 ffb7 fs2 fc0 sc0 ls8 wseb">变换有可能很简单，但也可能很复杂，这都要视情况而定。比如，就拿前面例子中绘制表针来说，</div><div class="t m0 x0 h5 y3121 ffb7 fs2 fc0 sc0 ls8 wseb">如果把原点变换到表盘的中心，然后再绘制表针就容易多了。请看下面的例子。 </div><div class="t m0 x0 hb y3122 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3123 ffb8 fs6 fc0 sc0 ls21 wsb">var drawing = document.getElementById(&quot;drawing&quot;); </div><div class="t m0 x0 hb y3124 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y3125 ffb8 fs6 fc0 sc0 ls21">//确定浏览器支持&lt;canvas&gt;元素 </div><div class="t m0 x0 hb y3126 ffb8 fs6 fc0 sc0 ls21 wsb">if (drawing.getContext){ </div><div class="t m0 x0 hb y3127 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x6 h5 y3128 ffb0 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 h3 yf2a ffb7 fs1 fc0 sc0 ls8 wsb">图 15-7 </div></div></div>
<div id="pf1d8" class="pf w0 h0" data-page-no="1d8"><div class="pc pc1d8 w0 h0"><div class="t m0 x0 h2 y1 ffb0 fs0 fc0 sc0 ls7 ws0">454  第15章 使用Canvas绘图 </div><div class="t m0 x0 h3 y2 ffb0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 ffb8 fs6 fc0 sc0 ls21 wsb">    var context = drawing.getContext(&quot;2d&quot;); </div><div class="t m0 x0 hb y7a ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y7b ffb8 fs6 fc0 sc0 ls21 wsb">    //开始路径 </div><div class="t m0 x0 hb y7c ffb8 fs6 fc0 sc0 ls21 wsb">    context.beginPath(); </div><div class="t m0 x0 hb y7d ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y7e ffb8 fs6 fc0 sc0 ls21 wsb">    //绘制外圆 </div><div class="t m0 x0 hb y7f ffb8 fs6 fc0 sc0 ls21 wsb">    context.arc(100, 100, 99, 0, 2 * Math.PI, false); </div><div class="t m0 x0 hb y80 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y81 ffb8 fs6 fc0 sc0 ls21 wsb">    //绘制内圆 </div><div class="t m0 x0 hb y82 ffb8 fs6 fc0 sc0 ls21 wsb">    context.moveTo(194, 100); </div><div class="t m0 x0 hb y83 ffb8 fs6 fc0 sc0 ls21 wsb">    context.arc(100, 100, 94, 0, 2 * Math.PI, false); </div><div class="t m0 x0 hb y84 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y85 ffbb fs6 fc0 sc0 ls21 wsb">    //变换原点 </div><div class="t m0 x0 h15 y86 ffbb fs6 fc0 sc0 ls21 wsb">    context.translate(100, 100); </div><div class="t m0 x0 h15 y87 ffbb fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y88 ffbb fs6 fc0 sc0 ls21 wsb">    //绘制分针 </div><div class="t m0 x0 h15 y89 ffbb fs6 fc0 sc0 ls21 wsb">    context.moveTo(0,0); </div><div class="t m0 x0 h15 y8a ffbb fs6 fc0 sc0 ls21 wsb">    context.lineTo(0, -85); </div><div class="t m0 x0 h15 y1823 ffbb fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y1824 ffbb fs6 fc0 sc0 ls21 wsb">    //绘制时针 </div><div class="t m0 x0 h15 y1825 ffbb fs6 fc0 sc0 ls21 wsb">    context.moveTo(0, 0); </div><div class="t m0 x0 h15 y1826 ffbb fs6 fc0 sc0 ls21 wsb">    context.lineTo(-65, 0); </div><div class="t m0 x0 hb y1827 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y1828 ffb8 fs6 fc0 sc0 ls21 wsb">    //描边路径 </div><div class="t m0 x0 hb y1829 ffb8 fs6 fc0 sc0 ls21 wsb">    context.stroke(); </div><div class="t m0 x0 hb y182a ffb8 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y312a ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y2298 ffbc fs2 fc0 sc0 ls25 wsb">2DTransformExample01.htm </div><div class="t m0 x0 h5 y1af9 ffb7 fs2 fc0 sc0 ls8 wseb">把原点变换到时钟表盘的中心点(100,100)后，在同一方向上绘制线条就变成了简单的数学问题了。</div><div class="t m0 x0 h5 y312b ffb7 fs2 fc0 sc0 ls8 wseb">所有数学计算都基于(0,0)，而不是(100,100)。还可以更进一步，像下面这样使用rotate()方法旋转时</div><div class="t m0 x0 h5 y312c ffb7 fs2 fc0 sc0 ls8 wseb">钟的表针。 </div><div class="t m0 x0 hb y312d ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y312e ffb8 fs6 fc0 sc0 ls21 wsb">var drawing = document.getElementById(&quot;drawing&quot;); </div><div class="t m0 x0 hb y312f ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y3130 ffb8 fs6 fc0 sc0 ls21">//确定浏览器支持&lt;canvas&gt;元素 </div><div class="t m0 x0 hb y3131 ffb8 fs6 fc0 sc0 ls21 wsb">if (drawing.getContext){ </div><div class="t m0 x0 hb y3132 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3133 ffb8 fs6 fc0 sc0 ls21 wsb">    var context = drawing.getContext(&quot;2d&quot;); </div><div class="t m0 x0 hb y3134 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y3135 ffb8 fs6 fc0 sc0 ls21 wsb">    //开始路径 </div><div class="t m0 x0 hb y3136 ffb8 fs6 fc0 sc0 ls21 wsb">    context.beginPath(); </div><div class="t m0 x0 hb y3137 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y3138 ffb8 fs6 fc0 sc0 ls21 wsb">    //绘制外圆 </div><div class="t m0 x0 hb y3139 ffb8 fs6 fc0 sc0 ls21 wsb">    context.arc(100, 100, 99, 0, 2 * Math.PI, false); </div><div class="t m0 x0 hb y313a ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y313b ffb8 fs6 fc0 sc0 ls21 wsb">    //绘制内圆 </div><div class="t m0 x0 hb y313c ffb8 fs6 fc0 sc0 ls21 wsb">    context.moveTo(194, 100); </div><div class="t m0 x0 hb y313d ffb8 fs6 fc0 sc0 ls21 wsb">    context.arc(100, 100, 94, 0, 2 * Math.PI, false); </div><div class="t m0 x0 hb y313e ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y313f ffb8 fs6 fc0 sc0 ls21 wsb">    //变换原点 </div><div class="t m0 x0 hb y3140 ffb8 fs6 fc0 sc0 ls21 wsb">    context.translate(100, 100); </div><div class="t m0 x0 hb y3141 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y3142 ffbb fs6 fc0 sc0 ls21 wsb">    //旋转表针 </div><div class="t m0 x0 h15 y3143 ffbb fs6 fc0 sc0 ls21 wsb">    context.rotate(1); </div><div class="t m0 x0 hb y3144 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y3145 ffb8 fs6 fc0 sc0 ls21 wsb">    //绘制分针 </div></div></div>
<div id="pf1d9" class="pf w0 h0" data-page-no="1d9"><div class="pc pc1d9 w0 h0"><div class="t m0 x2 h2 y1 ffb0 fs0 fc0 sc0 ls7 ws0">15.2 2D上下文   455 </div><div class="t m0 x0 h3 y2 ffb0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffb2 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ffb2 fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ffb2 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffb2 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffb2 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffb2 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffb2 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffb2 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffb2 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffb2 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffb2 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ffb2 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ffb2 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y79 ffb8 fs6 fc0 sc0 ls21 wsb">    context.moveTo(0,0); </div><div class="t m0 x0 hb y7a ffb8 fs6 fc0 sc0 ls21 wsb">    context.lineTo(0, -85); </div><div class="t m0 x0 hb y7b ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y7c ffb8 fs6 fc0 sc0 ls21 wsb">    //绘制时针 </div><div class="t m0 x0 hb y7d ffb8 fs6 fc0 sc0 ls21 wsb">    context.moveTo(0, 0); </div><div class="t m0 x0 hb y7e ffb8 fs6 fc0 sc0 ls21 wsb">    context.lineTo(-65, 0); </div><div class="t m0 x0 hb y7f ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y80 ffb8 fs6 fc0 sc0 ls21 wsb">    //描边路径 </div><div class="t m0 x0 hb y81 ffb8 fs6 fc0 sc0 ls21 wsb">    context.stroke(); </div><div class="t m0 x0 hb y82 ffb8 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y83 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y998 ffbc fs2 fc0 sc0 lsb wsb">2DTransformExample01.htm </div><div class="t m0 x0 h4 y999 ffb7 fs2 fc0 sc0 ls8 wseb">因为原点已经变换到了时钟表盘的中心点，所以旋转也是以该点为圆心的。结果就像是表针真地被</div><div class="t m0 x0 h5 y99a ffb7 fs2 fc0 sc0 ls8 wseb">固定在表盘中心一样，然后向右旋转了一定角度。结果如图15-8所示。 </div><div class="t m0 x2 h5 y3146 ffb0 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 h3 y3147 ffb7 fs1 fc0 sc0 ls8 wsb">图 15-8 </div><div class="t m0 x0 h4 y19a2 ffb7 fs2 fc0 sc0 ls8 wseb">无论是刚才执行的变换，还是fillStyle、strokeStyle等属性，都会在当前上下文中一直有效，</div><div class="t m0 x0 h4 y3148 ffb7 fs2 fc0 sc0 ls8 wseb">除非再对上下文进行什么修改。虽然没有什么办法把上下文中的一切都重置回默认值，但有两个方法可</div><div class="t m0 x0 h1c y3149 ffb7 fs2 fc0 sc0 ls8 wseb">以跟踪上下文的状态变化。如果你知道将来还要返回某组属性与变换的组合，可以调用save()方法。</div><div class="t m0 x0 h4 ya50 ffb7 fs2 fc0 sc0 ls8 wseb">调用这个方法后，当时的所有设置都会进入一个栈结构，得以妥善保管。然后可以对上下文进行其他修</div><div class="t m0 x0 h1e y314a ffb7 fs2 fc0 sc0 ls8 wseb">改。等想要回到之前保存的设置时，可以调用restore()方法，在保存设置的栈结构中向前返回一级，</div><div class="t m0 x0 h1e y314b ffb7 fs2 fc0 sc0 ls8 wseb">恢复之前的状态。连续调用save()可以把更多设置保存到栈结构中，之后再连续调用restore()则可</div><div class="t m0 x0 h5 y314c ffb7 fs2 fc0 sc0 ls8 wseb">以一级一级返回。下面来看一个例子。 </div><div class="t m0 x0 hb y314d ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y314e ffb8 fs6 fc0 sc0 ls21 wsb">context.fillStyle = &quot;#ff0000&quot;; </div><div class="t m0 x0 hb y314f ffb8 fs6 fc0 sc0 ls21 wsb">context.save(); </div><div class="t m0 x0 hb y3150 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3151 ffb8 fs6 fc0 sc0 ls21 wsb">context.fillStyle = &quot;#00ff00&quot;; </div><div class="t m0 x0 hb y3152 ffb8 fs6 fc0 sc0 ls21 wsb">context.translate(100, 100); </div><div class="t m0 x0 hb y3153 ffb8 fs6 fc0 sc0 ls21 wsb">context.save(); </div><div class="t m0 x0 hb y3154 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3155 ffb8 fs6 fc0 sc0 ls21 wsb">context.fillStyle = &quot;#0000ff&quot;; </div><div class="t m0 x0 h34 y3156 ffb8 fs6 fc0 sc0 ls21 wsb">context.fillRect(0, 0, 100, 200); //从点(100,100)开始绘制蓝色矩形 </div><div class="t m0 x0 hb y3157 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3158 ffb8 fs6 fc0 sc0 ls21 wsb">context.restore(); </div><div class="t m0 x0 h34 y3159 ffb8 fs6 fc0 sc0 ls21 wsb">context.fillRect(10, 10, 100, 200); //从点(110,110)开始绘制绿色矩形 </div><div class="t m0 x0 hb y315a ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y315b ffb8 fs6 fc0 sc0 ls21 wsb">context.restore(); </div></div></div>
<div id="pf1da" class="pf w0 h0" data-page-no="1da"><div class="pc pc1da w0 h0"><div class="t m0 x0 h2 y1 ffb0 fs0 fc0 sc0 ls7 ws0">456  第15章 使用Canvas绘图 </div><div class="t m0 x0 h3 y2 ffb0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y79 ffb8 fs6 fc0 sc0 ls21 wsb">context.fillRect(0, 0, 100, 200); //从点(0,0)开始绘制红色矩形 </div><div class="t m0 x2 hf y4 ffbc fs2 fc0 sc0 ls8 wsb">2DSaveRestoreExample01.htm </div><div class="t m0 x0 h4 y315d ffb7 fs2 fc0 sc0 ls8 wseb">首先，将fillStyle设置为红色，并调用save()保存上下文状态。接下来，把fillStyle修改</div><div class="t m0 x0 h5 y315e ffb7 fs2 fc0 sc0 ls8 wseb">为绿色，把坐标原点变换到(100,100)，再调用save()保存上下文状态。然后，把fillStyle修改为蓝</div><div class="t m0 x0 h5 y315f ffb7 fs2 fc0 sc0 ls8 wseb">色并绘制蓝色的矩形。因为此时的坐标原点已经变了，所以矩形的左上角坐标实际上是(100,100)。然后</div><div class="t m0 x0 h1e y3160 ffb7 fs2 fc0 sc0 ls8 wseb">调用restore()，之后fillStyle变回了绿色，因而第二个矩形就是绿色。之所以第二个矩形的起点</div><div class="t m0 x0 h5 y3161 ffb7 fs2 fc0 sc0 ls6 wsf7">坐标是(110,110)，是因为坐标位置的变换仍然起作用。再调用一次restore()，变换就被取消了，而</div><div class="t m0 x0 h5 y3162 ffb8 fs1 fc0 sc0 ls9 ws2">fillStyle也返回了红色。所以最后一个矩形是红色的，而且绘制的起点是(0,0)。 </div><div class="t m0 x0 h4 y2691 ffb7 fs2 fc0 sc0 ls57 ws151">需要注意的是，save()方法保存的只是对绘图上下文的设置和变换，不会保存绘图上下文的</div><div class="t m0 x0 h5 y2692 ffb7 fs2 fc0 sc0 ls4">内容。 </div><div class="t m0 x0 h20 y3163 ffb5 fs3 fc0 sc0 ls248 ws214">15.2.6 绘制图像 </div><div class="t m0 x0 h5 y3164 ffb0 fs2 fc0 sc0 ls8 ws20">2D绘图上下文内置了对图像的支持。如果你想把一幅图像绘制到画布上，可以使用drawImage()</div><div class="t m0 x0 h4 y18d ffb7 fs2 fc0 sc0 ls8 wseb">方法。根据期望的最终结果不同，调用这个方法时，可以使用三种不同的参数组合。最简单的调用方式</div><div class="t m0 x0 h5 y3165 ffb7 fs2 fc0 sc0 ls8 wseb">是传入一个HTML &lt;img&gt;元素，以及绘制该图像的起点的x和y坐标。例如： </div><div class="t m0 x0 hb y3166 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3167 ffb8 fs6 fc0 sc0 ls21 wsb">var image = document.images[0]; </div><div class="t m0 x0 hb y3168 ffb8 fs6 fc0 sc0 ls21 wsb">context.drawImage(image, 10, 10); </div><div class="t m0 x0 hb y3169 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y316a ffbc fs2 fc0 sc0 ls1b wsb">2DDrawImageExample01.htm </div><div class="t m0 x0 h5 y2919 ffb7 fs2 fc0 sc0 ls8 wseb">这两行代码取得了文档中的第一幅图像，然后将它绘制到上下文中，起点为(10,10)。绘制到画布上</div><div class="t m0 x0 h4 y316b ffb7 fs2 fc0 sc0 ls8 wseb">的图像大小与原始大小一样。如果你想改变绘制后图像的大小，可以再多传入两个参数，分别表示目标</div><div class="t m0 x0 h5 y316c ffb7 fs2 fc0 sc0 ls8 wseb">宽度和目标高度。通过这种方式来缩放图像并不影响上下文的变换矩阵。例如： </div><div class="t m0 x0 hb y316d ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y316e ffb8 fs6 fc0 sc0 ls21 wsb">context.drawImage(image, 50, 10, 20, 30); </div><div class="t m0 x0 hb y316f ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y127a ffbc fs2 fc0 sc0 ls1b wsb">2DDrawImageExample01.htm </div><div class="t m0 x0 h5 y440 ffb7 fs2 fc0 sc0 ls8 wseb">执行代码后，绘制出来的图像大小会变成20×30像素。 </div><div class="t m0 x0 h1e y3170 ffb7 fs2 fc0 sc0 ls8 wseb">除了上述两种方式，还可以选择把图像中的某个区域绘制到上下文中。drawImage()方法的这种调</div><div class="t m0 x0 h5 y3171 ffb7 fs2 fc0 sc0 ls8 wseb">用方式总共需要传入9个参数：要绘制的图像、源图像的x坐标、源图像的y坐标、源图像的宽度、源</div><div class="t m0 x0 h4 y3172 ffb7 fs2 fc0 sc0 ls8 wseb">图像的高度、目标图像的x坐标、目标图像的y坐标、目标图像的宽度、目标图像的高度。这样调用</div><div class="t m0 x0 h5 y443 ffb8 fs1 fc0 sc0 ls9 ws2">drawImage()方法可以获得最多的控制。例如： </div><div class="t m0 x0 hb y2a8e ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3173 ffb8 fs6 fc0 sc0 ls21 wsb">context.drawImage(image, 0, 10, 50, 50, 0, 100, 40, 60); </div><div class="t m0 x0 hb y3174 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y2855 ffbc fs2 fc0 sc0 ls1b wsb">2DDrawImageExample01.htm </div><div class="t m0 x0 h5 y3175 ffb7 fs2 fc0 sc0 ls5 wsec">这行代码只会把原始图像的一部分绘制到画布上。原始图像的这一部分的起点为(0,10)，宽和高都</div><div class="t m0 x0 h5 y3176 ffb7 fs2 fc0 sc0 ls3b">是50像素。最终绘制到上下文中的图像的起点是(0,100)，而大小变成了40×60像素。 </div><div class="t m0 x0 h5 y3177 ffb7 fs2 fc0 sc0 ls8 wseb">这种调用方式可以创造出很有意思的效果，如图15-9所示。 </div></div></div>
<div id="pf1db" class="pf w0 h0" data-page-no="1db"><div class="pc pc1db w0 h0"><div class="t m0 x2 h2 y1 ffb0 fs0 fc0 sc0 ls7 ws0">15.2 2D上下文   457 </div><div class="t m0 x0 h3 y2 ffb0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffb2 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ffb2 fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ffb2 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffb2 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffb2 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffb2 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffb2 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffb2 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffb2 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffb2 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffb2 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ffb2 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ffb2 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x4 h5 y1a23 ffb0 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 h3 y3178 ffb7 fs1 fc0 sc0 ls8 wsb">图 15-9 </div><div class="t m0 x0 h5 y42c ffb7 fs2 fc0 sc0 ls8 wseb">除了给drawImage()方法传入HTML &lt;img&gt;元素外，还可以传入另一个&lt;canvas&gt;元素作为其第一</div><div class="t m0 x0 h5 y2e74 ffb7 fs2 fc0 sc0 ls8 wseb">个参数。这样，就可以把另一个画布内容绘制到当前画布上。 </div><div class="t m0 x0 h1c y3179 ffb7 fs2 fc0 sc0 ls57 ws151">结合使用drawImage()和其他方法，可以对图像进行各种基本操作。而操作的结果可以通过</div><div class="t m0 x0 h3b y317a ffb8 fs1 fc0 sc0 ls9 ws2">toDataURL()方法获得①。不过，有一个例外，即图像不能来自其他域。如果图像来自其他域，调用</div><div class="t m0 x0 h5 y134a ffb8 fs1 fc0 sc0 ls9 ws2">toDataURL()会抛出一个错误。打个比方，假如位于www.example.com上的页面绘制的图像来自于</div><div class="t m0 x0 h5 y317b ffb0 fs2 fc0 sc0 ls79 ws6c">www.wrox.com，那当前上下文就会被认为“不干净”，因而会抛出错误。 </div><div class="t m0 x0 h20 y317c ffb5 fs3 fc0 sc0 ls248 ws214">15.2.7 阴影 </div><div class="t m0 x0 h5 y1fd0 ffb0 fs2 fc0 sc0 ls8 ws20">2D上下文会根据以下几个属性的值，自动为形状或路径绘制出阴影。 </div><div class="t m0 x0 h5 yef7 ffb6 fs1 fc0 sc0 ls2"> shadowColor：用CSS颜色格式表示的阴影颜色，默认为黑色。 </div><div class="t m0 x0 h5 y13e5 ffb6 fs1 fc0 sc0 ls2"> shadowOffsetX：形状或路径x轴方向的阴影偏移量，默认为0。 </div><div class="t m0 x0 h5 y1cce ffb6 fs1 fc0 sc0 ls2"> shadowOffsetY：形状或路径y轴方向的阴影偏移量，默认为0。 </div><div class="t m0 x0 h5 y1fd1 ffb6 fs1 fc0 sc0 ls2"> shadowBlur：模糊的像素数，默认0，即不模糊。 </div><div class="t m0 x0 h1e y1fd2 ffb7 fs2 fc0 sc0 ls8 wseb">这些属性都可以通过context对象来修改。只要在绘制前为它们设置适当的值，就能自动产生阴</div><div class="t m0 x0 h5 y317d ffb7 fs2 fc0 sc0 ls8 wseb">影。例如： </div><div class="t m0 x0 hb y227c ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y317e ffb8 fs6 fc0 sc0 ls21 wsb">var context = drawing.getContext(&quot;2d&quot;); </div><div class="t m0 x0 hb y317f ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y3180 ffbb fs6 fc0 sc0 ls21 ws34">//设置阴影 </div><div class="t m0 x0 h15 y3181 ffbb fs6 fc0 sc0 ls21 wsb">context.shadowOffsetX = 5; </div><div class="t m0 x0 h15 y3182 ffbb fs6 fc0 sc0 ls21 wsb">context.shadowOffsetY = 5; </div><div class="t m0 x0 h15 y3183 ffbb fs6 fc0 sc0 ls21 wsb">context.shadowBlur    = 4; </div><div class="t m0 x0 h15 y3184 ffbb fs6 fc0 sc0 ls21 wsb">context.shadowColor   = &quot;rgba(0, 0, 0, 0.5)&quot;; </div><div class="t m0 x0 hb y3185 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y3186 ffb8 fs6 fc0 sc0 ls21">//绘制红色矩形 </div><div class="t m0 x0 hb y3187 ffb8 fs6 fc0 sc0 ls21 wsb">context.fillStyle = &quot;#ff0000&quot;; </div><div class="t m0 x0 hb y3188 ffb8 fs6 fc0 sc0 ls21 wsb">context.fillRect(10, 10, 50, 50); </div><div class="t m0 x0 hb y3189 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y318a ffb8 fs6 fc0 sc0 ls21">//绘制蓝色矩形 </div><div class="t m0 x0 hb y318b ffb8 fs6 fc0 sc0 ls21 wsb">context.fillStyle = &quot;rgba(0,0,255,1)&quot;; </div><div class="t m0 x0 h3c y13d3 ffb4 fs2 fc0 sc0 ls7b wsb">—————————— </div><div class="t m0 x0 h36 ycc5 ffb7 fs6 fc0 sc0 ls95">① 请读者注意，虽然本章至今一直在讨论2D绘图上下文，但toDataURL()是Canvas对象的方法，不是上下文对</div><div class="t m0 x0 h36 y3086 ffb7 fs6 fc0 sc0 ls8 ws124">象的方法。 </div></div></div>
<div id="pf1dc" class="pf w0 h0" data-page-no="1dc"><div class="pc pc1dc w0 h0"><div class="t m0 x0 h2 y1 ffb0 fs0 fc0 sc0 ls7 ws0">458  第15章 使用Canvas绘图 </div><div class="t m0 x0 h3 y2 ffb0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 ffb8 fs6 fc0 sc0 ls21 wsb">context.fillRect(30, 30, 50, 50); </div><div class="t m0 x0 hb y1b0b ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y318d ffbc fs2 fc0 sc0 ls2b wsb">2DFillRectShadowExample01.htm </div><div class="t m0 x0 h5 y318e ffb7 fs2 fc0 sc0 ls8 wseb">两个矩形的阴影样式相同，结果如图15-10所示。 </div><div class="t m0 x0 h5 y318f ffb7 fs2 fc0 sc0 ls8 wseb">不同浏览器对阴影的支持有一些差异。IE9、Firefox 4和Opera 11的行为</div><div class="t m0 x0 h4 y2732 ffb7 fs2 fc0 sc0 ls8 wseb">最为规范，其他浏览器多多少少会有一些奇怪的现象，甚至根本不支持阴影。</div><div class="t m0 x0 h5 y3190 ffb0 fs2 fc0 sc0 ls50 ws41">Chrome（直至第10版）不能正确地为描边的形状应用实心阴影。Chrome和</div><div class="t m0 x0 h5 y3191 ffb0 fs2 fc0 sc0 ls48 ws39">Safari（直至第5版）在为带透明像素的图像应用阴影时也会有问题：不透明</div><div class="t m0 x0 h5 y3192 ffb7 fs2 fc0 sc0 ls8 wseb">部分的下方本来是该有阴影的，但此时则一概不见了。Safari也不能给渐变图</div><div class="t m0 x0 h5 y3193 ffb7 fs2 fc0 sc0 ls8 wseb">形应用阴影，其他浏览器都可以。 </div><div class="t m0 x0 h20 y2a68 ffb5 fs3 fc0 sc0 ls248 ws214">15.2.8 渐变 </div><div class="t m0 x0 h5 y23da ffb7 fs2 fc0 sc0 ls8 wseb">渐变由CanvasGradient实例表示，很容易通过2D上下文来创建和修改。要创建一个新的线性渐</div><div class="t m0 x0 hc y3194 ffb7 fs2 fc0 sc0 ls8 wseb">变，可以调用createLinearGradient()方法。这个方法接收4个参数：起点的x坐标、起点的y坐</div><div class="t m0 x0 h4 y3195 ffb7 fs2 fc0 sc0 ls60 ws140">标、终点的x坐标、终点的y坐标。调用这个方法后，它就会创建一个指定大小的渐变，并返回</div><div class="t m0 x0 h5 y3196 ffb8 fs1 fc0 sc0 ls9 ws2">CanvasGradient对象的实例。 </div><div class="t m0 x0 h1e y3197 ffb7 fs2 fc0 sc0 ls8 wseb">创建了渐变对象后，下一步就是使用addColorStop()方法来指定色标。这个方法接收两个参数：</div><div class="t m0 x0 h5 y3198 ffb7 fs2 fc0 sc0 ls8 wseb">色标位置和CSS颜色值。色标位置是一个0（开始的颜色）到1（结束的颜色）之间的数字。例如： </div><div class="t m0 x0 hb y3199 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y319a ffb8 fs6 fc0 sc0 ls21 wsb">var gradient = context.createLinearGradient(30, 30, 70, 70); </div><div class="t m0 x0 hb y319b ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y319c ffb8 fs6 fc0 sc0 ls21 wsb">gradient.addColorStop(0, &quot;white&quot;); </div><div class="t m0 x0 hb y319d ffb8 fs6 fc0 sc0 ls21 wsb">gradient.addColorStop(1, &quot;black&quot;); </div><div class="t m0 x0 hb y319e ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf y129c ffbc fs2 fc0 sc0 ls79 wsb">2DFillRectGradientExample01.htm </div><div class="t m0 x0 h5 y319f ffb7 fs2 fc0 sc0 ls8 wseb">此时，gradient对象表示的是一个从画布上点(30,30)到点(70,70)的渐变。起点的色标是白色，终</div><div class="t m0 x0 h1e y31a0 ffb7 fs2 fc0 sc0 ls8 wseb">点的色标是黑色。然后就可以把fillStyle或strokeStyle设置为这个对象，从而使用渐变来绘制</div><div class="t m0 x0 h5 y31a1 ffb7 fs2 fc0 sc0 ls8 wseb">形状或描边： </div><div class="t m0 x0 hb y31a2 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y31a3 ffb8 fs6 fc0 sc0 ls21">//绘制红色矩形 </div><div class="t m0 x0 hb y31a4 ffb8 fs6 fc0 sc0 ls21 wsb">context.fillStyle = &quot;#ff0000&quot;; </div><div class="t m0 x0 hb y31a5 ffb8 fs6 fc0 sc0 ls21 wsb">context.fillRect(10, 10, 50, 50); </div><div class="t m0 x0 hb y31a6 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y31a7 ffb8 fs6 fc0 sc0 ls21">//绘制渐变矩形 </div><div class="t m0 x0 h15 y31a8 ffbb fs6 fc0 sc0 ls21 wsb">context.fillStyle = gradient; </div><div class="t m0 x0 hb y31a9 ffb8 fs6 fc0 sc0 ls21 wsb">context.fillRect(30, 30, 50, 50); </div><div class="t m0 x0 hb y31aa ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf ya00 ffbc fs2 fc0 sc0 ls79 wsb">2DFillRectGradientExample01.htm </div><div class="t m0 x0 h4 y31ab ffb7 fs2 fc0 sc0 ls6 wsf7">为了让渐变覆盖整个矩形，而不是仅应用到矩形的一部分，矩形和渐变对</div><div class="t m0 x0 h5 y31ac ffb7 fs2 fc0 sc0 ls8 wseb">象的坐标必须匹配才行。以上代码会得到如图15-11所示的结果。 </div><div class="t m0 x0 h4 y31ad ffb7 fs2 fc0 sc0 ls55 wsfc">如果没有把矩形绘制到恰当的位置，那可能就只会显示部分渐变效果。</div><div class="t m0 x0 h5 y31ae ffb7 fs2 fc0 sc0 lsa">例如： </div><div class="t m0 x0 hb y31af ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y31b0 ffb8 fs6 fc0 sc0 ls21 wsb">context.fillStyle = gradient; </div><div class="t m0 x6 h5 y31b1 ffb0 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 h3 y31b2 ffb7 fs1 fc0 sc0 ls8 wsb">图 15-10 </div><div class="t m0 x6 h5 y31af ffb0 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 h3 y31b3 ffb7 fs1 fc0 sc0 ls8 wsb">图 15-11 </div></div></div>
<div id="pf1dd" class="pf w0 h0" data-page-no="1dd"><div class="pc pc1dd w0 h0"><div class="t m0 x2 h2 y1 ffb0 fs0 fc0 sc0 ls7 ws0">15.2 2D上下文   459 </div><div class="t m0 x0 h3 y2 ffb0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffb2 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ffb2 fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ffb2 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffb2 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffb2 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffb2 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffb2 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffb2 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffb2 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffb2 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffb2 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ffb2 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ffb2 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h15 y79 ffbb fs6 fc0 sc0 ls21 wsb">context.fillRect(50, 50, 50, 50); </div><div class="t m0 x0 hb y31b4 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y31b5 ffbc fs2 fc0 sc0 ls79 wsb">2DFillRectGradientExample02.htm </div><div class="t m0 x0 h4 y31b6 ffb7 fs2 fc0 sc0 ls8 wseb">这两行代码执行后得到的矩形只有左上角稍微有一点白色。这主要是因为矩形的起点位于渐变的中</div><div class="t m0 x0 h4 y31b7 ffb7 fs2 fc0 sc0 ls8 wseb">间位置，而此时渐变差不多已经结束了。由于渐变不重复，所以矩形的大部分区域都是黑色。确保渐变</div><div class="t m0 x0 h5 y31b8 ffb7 fs2 fc0 sc0 ls8 wseb">与形状对齐非常重要，有时候可以考虑使用函数来确保坐标合适。例如： </div><div class="t m0 x0 hb y31b9 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y31ba ffb8 fs6 fc0 sc0 ls21 wsb">function createRectLinearGradient(context, x, y, width, height){  </div><div class="t m0 x0 hb y31bb ffb8 fs6 fc0 sc0 ls21 wsb">    return context.createLinearGradient(x, y, x+width, y+height); </div><div class="t m0 x0 hb y31bc ffb8 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y31bd ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y2642 ffbc fs2 fc0 sc0 ls79 wsb">2DFillRectGradientExample03.htm </div><div class="t m0 x0 h4 y2f32 ffb7 fs2 fc0 sc0 ls8 wseb">这个函数基于起点的x和y坐标以及宽度和高度值来创建渐变对象，从而让我们可以在fillRect()</div><div class="t m0 x0 h5 y14a0 ffb7 fs2 fc0 sc0 ls8 wseb">中使用相同的值。 </div><div class="t m0 x0 hb y31be ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y31bf ffb8 fs6 fc0 sc0 ls21 wsb">var gradient = createRectLinearGradient(context, 30, 30, 50, 50);  </div><div class="t m0 x0 hb y31c0 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y31c1 ffb8 fs6 fc0 sc0 ls21 wsb">gradient.addColorStop(0, &quot;white&quot;); </div><div class="t m0 x0 hb y31c2 ffb8 fs6 fc0 sc0 ls21 wsb">gradient.addColorStop(1, &quot;black&quot;); </div><div class="t m0 x0 hb y31c3 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y31c4 ffb8 fs6 fc0 sc0 ls21">//绘制渐变矩形 </div><div class="t m0 x0 h15 y31c5 ffbb fs6 fc0 sc0 ls21 wsb">context.fi llStyle = gradient; </div><div class="t m0 x0 hb y31c6 ffb8 fs6 fc0 sc0 ls21 ws34">context.fillRect(30, 30, 50, 50); </div><div class="t m0 x0 hb y31c7 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y125c ffbc fs2 fc0 sc0 ls79 wsb">2DFillRectGradientExample03.htm </div><div class="t m0 x0 h4 y31c8 ffb7 fs2 fc0 sc0 ls8 wseb">使用画布的时候，确保坐标匹配很重要，也需要一些技巧。类似createRectLinearGradient()</div><div class="t m0 x0 h5 y119b ffb7 fs2 fc0 sc0 ls8 wseb">这样的辅助方法可以让控制坐标更容易一些。 </div><div class="t m0 x0 hc y31c9 ffb7 fs2 fc0 sc0 ls8 wseb">要创建径向渐变（或放射渐变），可以使用createRadialGradient()方法。这个方法接收6个参</div><div class="t m0 x0 h4 y31ca ffb7 fs2 fc0 sc0 ls8 wseb">数，对应着两个圆的圆心和半径。前三个参数指定的是起点圆的原心（x和y）及半径，后三个参数指</div><div class="t m0 x0 h5 y31cb ffb7 fs2 fc0 sc0 ls8 wseb">定的是终点圆的原心（x和y）及半径。可以把径向渐变想象成一个长圆桶，而这6个参数定义的正是</div><div class="t m0 x0 h4 y31cc ffb7 fs2 fc0 sc0 ls8 wseb">这个桶的两个圆形开口的位置。如果把一个圆形开口定义得比另一个小一些，那这个圆桶就变成了圆锥</div><div class="t m0 x0 h5 y31cd ffb7 fs2 fc0 sc0 ls8 wseb">体，而通过移动每个圆形开口的位置，就可达到像旋转这个圆锥体一样的效果。 </div><div class="t m0 x0 h4 y31ce ffb7 fs2 fc0 sc0 ls8 wseb">如果想从某个形状的中心点开始创建一个向外扩散的径向渐变效果，就要将两个圆定义为同心圆。</div><div class="t m0 x0 h5 y31cf ffb7 fs2 fc0 sc0 ls8 wseb">比如，就拿前面创建的矩形来说，径向渐变的两个圆的圆心都应该在(55,55)，因为矩形的区域是从(30,30)</div><div class="t m0 x0 h5 y31d0 ffb7 fs2 fc0 sc0 ls8">到(80,80)。请看代码： </div><div class="t m0 x0 hb y31d1 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y31d2 ffbb fs6 fc0 sc0 ls21 wsb">var gradient = context.createRadialGradient(55, 55, 10, 55, 55, 30); </div><div class="t m0 x0 hb y31d3 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y31d4 ffb8 fs6 fc0 sc0 ls21 wsb">gradient.addColorStop(0, &quot;white&quot;); </div><div class="t m0 x0 hb y31d5 ffb8 fs6 fc0 sc0 ls21 wsb">gradient.addColorStop(1, &quot;black&quot;); </div><div class="t m0 x0 hb y31d6 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y31d7 ffb8 fs6 fc0 sc0 ls21">//绘制红色矩形 </div><div class="t m0 x0 hb y31d8 ffb8 fs6 fc0 sc0 ls21 wsb">context.fillStyle = &quot;#ff0000&quot;; </div><div class="t m0 x0 hb y31d9 ffb8 fs6 fc0 sc0 ls21 wsb">context.fillRect(10, 10, 50, 50); </div><div class="t m0 x0 hb y31da ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y31db ffb8 fs6 fc0 sc0 ls21">//绘制渐变矩形 </div><div class="t m0 x0 hb y31dc ffb8 fs6 fc0 sc0 ls21 wsb">context.fillStyle = gradient; </div><div class="t m0 x0 hb y31dd ffb8 fs6 fc0 sc0 ls21 wsb">context.fillRect(30, 30, 50, 50); </div><div class="t m0 x0 hb y31de ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y846 ffbc fs2 fc0 sc0 ls79 wsb">2DFillRectGradientExample04.htm </div></div></div>
<div id="pf1de" class="pf w0 h0" data-page-no="1de"><div class="pc pc1de w0 h0"><div class="t m0 x0 h2 y1 ffb0 fs0 fc0 sc0 ls7 ws0">460  第15章 使用Canvas绘图 </div><div class="t m0 x0 h3 y2 ffb0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ffb7 fs2 fc0 sc0 ls8 wseb">运行代码，会得到如图15-12所示的结果。 </div><div class="t m0 x0 h4 y4d ffb7 fs2 fc0 sc0 ls8 wseb">因为创建比较麻烦，所以径向渐变并不那么容易控制。不过，一般来说，</div><div class="t m0 x0 h4 yd8 ffb7 fs2 fc0 sc0 ls8 wseb">让起点圆和终点圆保持为同心圆的情况比较多，这时候只要考虑给两个圆设置</div><div class="t m0 x0 h5 y28b ffb7 fs2 fc0 sc0 ls8 wseb">不同的半径就好了。 </div><div class="t m0 x0 h20 y1250 ffb5 fs3 fc0 sc0 ls248 ws214">15.2.9 模式 </div><div class="t m0 x0 h4 y1251 ffb7 fs2 fc0 sc0 ls97 ws24d">模式其实就是重复的图像，可以用来填充或描边图形。要创建一个新模式，可以调用</div><div class="t m0 x0 h5 y288a ffb8 fs1 fc0 sc0 ls9 ws2">createPattern()方法并传入两个参数：一个HTML &lt;img&gt;元素和一个表示如何重复图像的字符串。</div><div class="t m0 x0 h5 y1f7 ffb7 fs2 fc0 sc0 ls8 wseb">其中，第二个参数的值与CSS的background-repeat属性值相同，包括&quot;repeat&quot;、&quot;repeat-x&quot;、</div><div class="t m0 x0 h5 y7d4 ffb8 fs1 fc0 sc0 ls9 ws2">&quot;repeat-y&quot;和&quot;no-repeat&quot;。看一个例子。 </div><div class="t m0 x0 hb y1f9 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1fa ffb8 fs6 fc0 sc0 ls21 wsb">var image = document.images[0],  </div><div class="t m0 x0 h15 y1fb ffbb fs6 fc0 sc0 ls21 wsb">    pattern = context.createPattern(image, &quot;repeat&quot;); </div><div class="t m0 x0 hb y1fc ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y1fd ffb8 fs6 fc0 sc0 ls21">//绘制矩形 </div><div class="t m0 x0 hb y1fe ffb8 fs6 fc0 sc0 ls21 wsb">context.fillStyle = pattern; </div><div class="t m0 x0 hb y31e0 ffb8 fs6 fc0 sc0 ls21 wsb">context.fillRect(10, 10, 150, 150); </div><div class="t m0 x0 hb y31e1 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1be7 ffbc fs2 fc0 sc0 ls1b wsb">2DFillRectPatternExample01.htm </div><div class="t m0 x0 h5 ye8 ffb7 fs2 fc0 sc0 ls8 wseb">需要注意的是，模式与渐变一样，都是从画布的原点(0,0)开始的。将填充样式（fillStyle）设置</div><div class="t m0 x0 h4 y19c5 ffb7 fs2 fc0 sc0 ls8 wseb">为模式对象，只表示在某个特定的区域内显示重复的图像，而不是要从某个位置开始绘制重复的图像。</div><div class="t m0 x0 h5 y31e2 ffb7 fs2 fc0 sc0 ls8 wseb">上面的代码会得到如图15-13所示的结果。 </div><div class="t m0 x4 h5 y2a9f ffb0 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x7 h3 yac9 ffb7 fs1 fc0 sc0 ls8 wsb">图 15-13 </div><div class="t m0 x0 h21 y31e3 ffb8 fs1 fc0 sc0 ls9 ws2">createPattern()方法的第一个参数也可以是一个&lt;video&gt;元素，或者另一个&lt;canvas&gt;元素。 </div><div class="t m0 x0 h20 y1079 ffb5 fs3 fc0 sc0 ls3dc">15.2.10 使用图像数据 </div><div class="t m0 x0 h5 y31e4 ffb0 fs2 fc0 sc0 ls8 ws20">2D上下文的一个明显的长处就是，可以通过getImageData()取得原始图像数据。这个方法接收</div><div class="t m0 x0 h5 y31e5 ffb0 fs2 fc0 sc0 lsee">4个参数：要取得其数据的画面区域的x和y坐标以及该区域的像素宽度和高度。例如，要取得左上角</div><div class="t m0 x0 h5 y31e6 ffb7 fs2 fc0 sc0 ls8">坐标为(10,5)、大小为50×50像素的区域的图像数据，可以使用以下代码： </div><div class="t m0 x0 hb y31e7 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y31e8 ffb8 fs6 fc0 sc0 ls21 wsb">var imageData = context.getImageData(10, 5, 50, 50); </div><div class="t m0 x0 hb y31e9 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y2fac ffb7 fs2 fc0 sc0 ls8 wseb">这里返回的对象是ImageData的实例。每个ImageData对象都有三个属性：width、height 和</div><div class="t m0 x0 h4 y31ea ffb8 fs1 fc0 sc0 ls9 ws2">data。其中data属性是一个数组，保存着图像中每一个像素的数据。在data数组中，每一个像素用</div><div class="t m0 x6 h5 y31eb ffb0 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 h3 y31ec ffb7 fs1 fc0 sc0 ls8 wsb">图 15-12 </div></div></div>
<div id="pf1df" class="pf w0 h0" data-page-no="1df"><div class="pc pc1df w0 h0"><div class="t m0 x2 h2 y1 ffb0 fs0 fc0 sc0 ls7 ws0">15.2 2D上下文   461 </div><div class="t m0 x0 h3 y2 ffb0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffb2 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ffb2 fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ffb2 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffb2 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffb2 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffb2 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffb2 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffb2 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffb2 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffb2 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffb2 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ffb2 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ffb2 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ffb0 fs2 fc0 sc0 ls18d">4个元素来保存，分别表示红、绿、蓝和透明度值。因此，第一个像素的数据就保存在数组的第0到第</div><div class="t m0 x0 h5 y4d ffb0 fs2 fc0 sc0 ls38">3个元素中，例如： </div><div class="t m0 x0 hb y2d8 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2d9 ffb8 fs6 fc0 sc0 ls21 wsb">var data = imageData.data, </div><div class="t m0 x0 hb y2da ffb8 fs6 fc0 sc0 ls21 wsb">    red = data[0], </div><div class="t m0 x0 hb y2db ffb8 fs6 fc0 sc0 ls21 wsb">    green = data[1], </div><div class="t m0 x0 hb y2dc ffb8 fs6 fc0 sc0 ls21 wsb">    blue = data[2], </div><div class="t m0 x0 hb y2dd ffb8 fs6 fc0 sc0 ls21 wsb">    alpha = data[3]; </div><div class="t m0 x0 hb y2de ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y13fd ffb7 fs2 fc0 sc0 ls8 wseb">数组中每个元素的值都介于0到255之间（包括0和255）。能够直接访问到原始图像数据，就能够</div><div class="t m0 x0 h5 y13fe ffb7 fs2 fc0 sc0 ls8 wseb">以各种方式来操作这些数据。例如，通过修改图像数据，可以像下面这样创建一个简单的灰阶过滤器。 </div><div class="t m0 x0 hb y13ff ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1400 ffb8 fs6 fc0 sc0 ls21 wsb">var drawing = document.getElementById(&quot;drawing&quot;); </div><div class="t m0 x0 hb y1401 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y1402 ffb8 fs6 fc0 sc0 ls21">//确定浏览器支持&lt;canvas&gt;元素 </div><div class="t m0 x0 hb y31ed ffb8 fs6 fc0 sc0 ls21 wsb">if (drawing.getContext){ </div><div class="t m0 x0 hb y31ee ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y31ef ffb8 fs6 fc0 sc0 ls21 wsb">    var context = drawing.getContext(&quot;2d&quot;), </div><div class="t m0 x0 hb y31f0 ffb8 fs6 fc0 sc0 ls21 wsb">        image = document.images[0], </div><div class="t m0 x0 hb y31f1 ffb8 fs6 fc0 sc0 ls21 wsb">        imageData, data, </div><div class="t m0 x0 hb y31f2 ffb8 fs6 fc0 sc0 ls21 wsb">        i, len, average, </div><div class="t m0 x0 hb y31f3 ffb8 fs6 fc0 sc0 ls21 wsb">        red, green, blue, alpha; </div><div class="t m0 x0 hb y31f4 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y31f5 ffb8 fs6 fc0 sc0 ls21 wsb">    //绘制原始图像 </div><div class="t m0 x0 hb y31f6 ffb8 fs6 fc0 sc0 ls21 wsb">    context.drawImage(image, 0, 0); </div><div class="t m0 x0 hb y31f7 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y31f8 ffb8 fs6 fc0 sc0 ls21 wsb">    //取得图像数据 </div><div class="t m0 x0 hb y31f9 ffb8 fs6 fc0 sc0 ls21 wsb">    imageData = context.getImageData(0, 0, image.width, image.height); </div><div class="t m0 x0 hb y31fa ffb8 fs6 fc0 sc0 ls21 wsb">    data = imageData.data; </div><div class="t m0 x0 hb y31fb ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y31fc ffb8 fs6 fc0 sc0 ls21 wsb">    for (i=0, len=data.length; i &lt; len; i+=4){ </div><div class="t m0 x0 hb y31fd ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y31fe ffb8 fs6 fc0 sc0 ls21 wsb">        red = data[i]; </div><div class="t m0 x0 hb y31ff ffb8 fs6 fc0 sc0 ls21 wsb">        green = data[i+1]; </div><div class="t m0 x0 hb y3200 ffb8 fs6 fc0 sc0 ls21 wsb">        blue = data[i+2]; </div><div class="t m0 x0 hb y3201 ffb8 fs6 fc0 sc0 ls21 wsb">        alpha = data[i+3]; </div><div class="t m0 x0 hb y3202 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y3203 ffb8 fs6 fc0 sc0 ls21 wsb">        //求得rgb平均值 </div><div class="t m0 x0 hb y3204 ffb8 fs6 fc0 sc0 ls21 wsb">        average = Math.floor((red + green + blue) / 3); </div><div class="t m0 x0 hb y3205 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y3206 ffb8 fs6 fc0 sc0 ls21 wsb">        //设置颜色值，透明度不变 </div><div class="t m0 x0 hb y3207 ffb8 fs6 fc0 sc0 ls21 wsb">        data[i] = average; </div><div class="t m0 x0 hb y3208 ffb8 fs6 fc0 sc0 ls21 wsb">        data[i+1] = average; </div><div class="t m0 x0 hb y3209 ffb8 fs6 fc0 sc0 ls21 wsb">        data[i+2] = average; </div><div class="t m0 x0 hb y320a ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y320b ffb8 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y320c ffb8 fs6 fc0 sc0 ls21 wsb">   </div><div class="t m0 x0 h34 y320d ffb8 fs6 fc0 sc0 ls21 wsb">    //回写图像数据并显示结果 </div><div class="t m0 x0 hb y320e ffb8 fs6 fc0 sc0 ls21 wsb">    imageData.data = data; </div><div class="t m0 x0 hb y320f ffb8 fs6 fc0 sc0 ls21 wsb">    context.putImageData(imageData, 0, 0); </div><div class="t m0 x0 hb y3210 ffb8 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y3211 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y25ab ffbc fs2 fc0 sc0 ls1b wsb">2DImageDataExample01.htm </div><div class="t m0 x0 h4 y3212 ffb7 fs2 fc0 sc0 ls8 wseb">这个例子首先在画面上绘制了一幅图像，然后取得了原始图像数据。其中的for循环遍历了图像数</div><div class="t m0 x0 hc y13b5 ffb7 fs2 fc0 sc0 ls8 wseb">据中的每一个像素。这里要注意的是，每次循环控制变量i都递增4。在取得每个像素的红、绿、蓝颜</div></div></div>
<div id="pf1e0" class="pf w0 h0" data-page-no="1e0"><div class="pc pc1e0 w0 h0"><div class="t m0 x0 h2 y1 ffb0 fs0 fc0 sc0 ls7 ws0">462  第15章 使用Canvas绘图 </div><div class="t m0 x0 h3 y2 ffb0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ffb7 fs2 fc0 sc0 ls8 wseb">色值后，计算出它们的平均值。再把这个平均值设置为每个颜色的值，结果就是去掉了每个像素的颜色，</div><div class="t m0 x0 h1e y4d ffb7 fs2 fc0 sc0 ls60 ws140">只保留了亮度接近的灰度值（即彩色变黑白）。在把data数组回写到imageData 对象后，调用</div><div class="t m0 x0 h5 y4e ffb8 fs1 fc0 sc0 ls9 ws2">putImageData()方法把图像数据绘制到画布上。最终得到了图像的黑白版。 </div><div class="t m0 x0 h4 yd9 ffb7 fs2 fc0 sc0 ls8 wseb">当然，通过操作原始像素值不仅能实现灰阶过滤，还能实现其他功能。要了解通过操作原始图像数</div><div class="t m0 x0 h5 y15d ffb7 fs2 fc0 sc0 ls8 wseb">据实现过滤器的更多信息，请参考Ilmari Heikkinen 的文章“Making Image Filters with Canvas”（基于</div><div class="t m0 x0 h5 y2b3 ffb0 fs2 fc0 sc0 ls14d ws11a">Canvas的图像过滤器）：http://www.html5rocks.com/en/tutorials/canvas/imagefilters/。 </div><div class="t m0 x5 ha y3214 ffb1 fs2 fc0 sc0 ls8 ws14">只有在画布“干净”的情况下（即图像并非来自其他域），才可以取得图像数据。</div><div class="t m0 x0 h5 y3215 ffb1 fs2 fc0 sc0 ls8 ws14">如果画布“不干净”，那么访问图像数据时会导致JavaScript错误。 </div><div class="t m0 x0 h20 y3216 ffb5 fs3 fc0 sc0 ls3dc">15.2.11 合成 </div><div class="t m0 x0 h5 y1f81 ffb7 fs2 fc0 sc0 ls6 wsf7">还有两个会应用到2D上下文中所有绘制操作的属性：globalAlpha 和globalComposition- </div><div class="t m0 x0 h21 y3217 ffb8 fs1 fc0 sc0 ls9 ws2">Operation。其中，globalAlpha是一个介于0和1之间的值（包括0和1），用于指定所有绘制的透</div><div class="t m0 x0 h5 y1be6 ffb7 fs2 fc0 sc0 ls8 wseb">明度。默认值为0。如果所有后续操作都要基于相同的透明度，就可以先把globalAlpha设置为适当</div><div class="t m0 x0 h5 y3218 ffb7 fs2 fc0 sc0 ls8 wseb">值，然后绘制，最后再把它设置回默认值0。下面来看一个例子。 </div><div class="t m0 x0 hb y3219 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y321a ffb8 fs6 fc0 sc0 ls21">//绘制红色矩形 </div><div class="t m0 x0 hb y321b ffb8 fs6 fc0 sc0 ls21 wsb">context.fillStyle = &quot;#ff0000&quot;; </div><div class="t m0 x0 hb y321c ffb8 fs6 fc0 sc0 ls21 wsb">context.fillRect(10, 10, 50, 50); </div><div class="t m0 x0 hb y321d ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y321e ffb8 fs6 fc0 sc0 ls21">//修改全局透明度 </div><div class="t m0 x0 h15 y321f ffbb fs6 fc0 sc0 ls21 wsb">context.globalAlpha = 0.5; </div><div class="t m0 x0 hb y3220 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y3221 ffb8 fs6 fc0 sc0 ls21">//绘制蓝色矩形 </div><div class="t m0 x0 hb y3222 ffb8 fs6 fc0 sc0 ls21 wsb">context.fillStyle = &quot;rgba(0,0,255,1)&quot;; </div><div class="t m0 x0 hb y3223 ffb8 fs6 fc0 sc0 ls21 wsb">context.fillRect(30, 30, 50, 50); </div><div class="t m0 x0 hb y3224 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y3225 ffb8 fs6 fc0 sc0 ls21">//重置全局透明度 </div><div class="t m0 x0 hb y3226 ffb8 fs6 fc0 sc0 ls21 wsb">context.globalAlpha = 0; </div><div class="t m0 x0 hb y3227 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y15ce ffbc fs2 fc0 sc0 ls2b wsb">2DGlobalAlphaExample01.htm </div><div class="t m0 x0 h4 y607 ffb7 fs2 fc0 sc0 ls5 wsec">在这个例子中，我们把蓝色矩形绘制到了红色矩形上面。因为在绘制蓝色矩形前，globalAlpha</div><div class="t m0 x0 h5 yf7 ffb7 fs2 fc0 sc0 ls8 wseb">已经被设置为0.5，所以蓝色矩形会呈现半透明效果，透过它可以看到下面的红色矩形。 </div><div class="t m0 x0 h1e yf8 ffb7 fs2 fc0 sc0 ls8 wseb">第二个属性globalCompositionOperation表示后绘制的图形怎样与先绘制的图形结合。这个</div><div class="t m0 x0 h5 ya29 ffb7 fs2 fc0 sc0 ls8 wseb">属性的值是字符串，可能的值如下。 </div><div class="t m0 x0 h5 y2b51 ffb6 fs1 fc0 sc0 ls2"> source-over（默认值）：后绘制的图形位于先绘制的图形上方。 </div><div class="t m0 x0 h5 y3228 ffb6 fs1 fc0 sc0 ls2"> source-in：后绘制的图形与先绘制的图形重叠的部分可见，两者其他部分完全透明。 </div><div class="t m0 x0 h5 y3229 ffb6 fs1 fc0 sc0 ls2"> source-out：后绘制的图形与先绘制的图形不重叠的部分可见，先绘制的图形完全透明。 </div><div class="t m0 x0 h5 y1d62 ffb6 fs1 fc0 sc0 ls2"> source-atop：后绘制的图形与先绘制的图形重叠的部分可见，先绘制图形不受影响。 </div><div class="t m0 x0 h5 y322a ffb6 fs1 fc0 sc0 ls8 ws134"> destination-over：后绘制的图形位于先绘制的图形下方，只有之前透明像素下的部分才可见。 </div><div class="t m0 x0 h5 y1aa0 ffb6 fs1 fc0 sc0 ls2"> destination-in：后绘制的图形位于先绘制的图形下方，两者不重叠的部分完全透明。 </div><div class="t m0 x0 h5 y15db ffb6 fs1 fc0 sc0 ls2"> destination-out：后绘制的图形擦除与先绘制的图形重叠的部分。 </div><div class="t m0 x0 h4 y2ee7 ffb6 fs1 fc0 sc0 ls2"> destination-atop：后绘制的图形位于先绘制的图形下方，在两者不重叠的地方，先绘制的</div></div></div>
<div id="pf1e1" class="pf w0 h0" data-page-no="1e1"><div class="pc pc1e1 w0 h0"><div class="t m0 x2 h2 y1db2 ffb0 fs0 fc0 sc0 ls7 ws0">15.3 WebGL  463 </div><div class="t m0 x0 h3 y2 ffb0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffb2 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ffb2 fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ffb2 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffb2 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffb2 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffb2 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffb2 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffb2 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffb2 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffb2 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffb2 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ffb2 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ffb2 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x5 h5 y3 ffb7 fs2 fc0 sc0 ls8 wseb">图形会变透明。 </div><div class="t m0 x0 h5 y4 ffb6 fs1 fc0 sc0 ls2"> lighter：后绘制的图形与先绘制的图形重叠部分的值相加，使该部分变亮。 </div><div class="t m0 x0 h5 y4e ffb6 fs1 fc0 sc0 ls2"> copy：后绘制的图形完全替代与之重叠的先绘制图形。 </div><div class="t m0 x0 h5 yd9 ffb6 fs1 fc0 sc0 ls2"> xor：后绘制的图形与先绘制的图形重叠的部分执行“异或”操作。 </div><div class="t m0 x0 h4 y15d ffb7 fs2 fc0 sc0 ls24 wsf5">这个合成操作实际上用语言或者黑白图像是很难说清楚的。要了解每个操作的具体效果，请参见</div><div class="t m0 x0 h5 y2b3 ffb0 fs2 fc0 sc0 ls138 ws133">https://developer.mozilla.org/samples/canvas-tutorial/6_1_canvas_composite.html。推荐使用IE9+或Firefox </div><div class="t m0 x0 h5 y765 ffb0 fs2 fc0 sc0 ls8 ws20">4+访问前面的网页，因为这两款浏览器对Canvas的实现最完善。下面来看一个例子。 </div><div class="t m0 x0 hb ycf5 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 ycf6 ffb8 fs6 fc0 sc0 ls21">//绘制红色矩形 </div><div class="t m0 x0 hb ycf7 ffb8 fs6 fc0 sc0 ls21 wsb">context.fillStyle = &quot;#ff0000&quot;; </div><div class="t m0 x0 hb ycf8 ffb8 fs6 fc0 sc0 ls21 wsb">context.fillRect(10, 10, 50, 50); </div><div class="t m0 x0 hb ycf9 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 ycfa ffb8 fs6 fc0 sc0 ls21">//设置合成操作 </div><div class="t m0 x0 hb ycfb ffbb fs6 fc0 sc0 ls21 wsb">context.globalCompositeOperation = &quot;destination-over&quot;; </div><div class="t m0 x0 hb ycfc ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 ycfd ffb8 fs6 fc0 sc0 ls21">//绘制蓝色矩形 </div><div class="t m0 x0 hb ycfe ffb8 fs6 fc0 sc0 ls21 wsb">context.fillStyle = &quot;rgba(0,0,255,1)&quot;; </div><div class="t m0 x0 hb ycff ffb8 fs6 fc0 sc0 ls21 wsb">context.fillRect(30, 30, 50, 50); </div><div class="t m0 x0 hb y322b ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf y322c ffbc fs2 fc0 sc0 ls8 wsb">2DGlobalCompositeOperationExample01.htm </div><div class="t m0 x0 h4 y322d ffb7 fs2 fc0 sc0 ls147 ws115">如果不修改globalCompositionOperation，那么蓝色矩形应该位于红色矩形之上。但把</div><div class="t m0 x0 h5 y322e ffb8 fs1 fc0 sc0 ls9 ws2">globalCompositionOperation设置为&quot;destination-over&quot;之后，红色矩形跑到了蓝色矩形上面。 </div><div class="t m0 x0 h1e y322f ffb7 fs2 fc0 sc0 ls8 wseb">在使用globalCompositionOperation的情况下，一定要多测试一些浏览器。因为不同浏览器</div><div class="t m0 x0 h5 y2c52 ffb7 fs2 fc0 sc0 ls8 wseb">对这个属性的实现仍然存在较大的差别。Safari和Chrome在这方面还有问题，至于有什么问题，大家</div><div class="t m0 x0 h5 y3230 ffb7 fs2 fc0 sc0 ls8 wseb">可以比较在打开上述页面的情况下，IE9+和Firefox 4+与它们有什么差异。 </div><div class="t m0 x0 hd y3231 ffb5 fs7 fc0 sc0 ls245">15.3 WebGL </div><div class="t m0 x0 h5 y1d7d ffb0 fs2 fc0 sc0 ls138 ws133">WebGL是针对Canvas的3D上下文。与其他Web 技术不同，WebGL并不是W3C制定的标准，而</div><div class="t m0 x0 h5 y25ff ffb7 fs2 fc0 sc0 ls8 wseb">是由Khronos Group制定的。其官方网站是这样介绍的：“Khronos Group是一个非盈利的由会员资助的</div><div class="t m0 x0 h5 y3232 ffb7 fs2 fc0 sc0 ls5 wsec">协会，专注于为并行计算以及各种平台和设备上的图形及动态媒体制定无版税的开放标准。” Khronos </div><div class="t m0 x0 h5 y3233 ffb0 fs2 fc0 sc0 ls79 ws6c">Group也设计了其他图形处理API，比如OpenGL ES 2.0。浏览器中使用的WebGL就是基于 OpenGL ES </div><div class="t m0 x0 h5 y3234 ffb0 fs2 fc0 sc0 lsd2 ws19b">2.0制定的。 </div><div class="t m0 x0 h5 y3235 ffb0 fs2 fc0 sc0 lsd ws8">OpenGL等3D图形语言是非常复杂的，本书不可能介绍其中每一个概念。熟悉OpenGL ES 2.0的读</div><div class="t m0 x0 h5 y3236 ffb7 fs2 fc0 sc0 ls8 wseb">者可能会觉得WebGL更好理解一些，因为好多概念是相通的。 </div><div class="t m0 x0 h5 y3237 ffb7 fs2 fc0 sc0 ls8 wseb">本节将适当地介绍OpenGL ES 2.0的一些概念，尽力解释其中的某些部分在WebGL中的实现。要</div><div class="t m0 x0 h5 y3238 ffb7 fs2 fc0 sc0 ls8 wseb">全面了解OpenGL，请访问www.opengl.org。要全面学习WebGL，请参考www.learningwebgl.com，其</div><div class="t m0 x0 h10b y3239 ffb7 fs2 fc0 sc0 ls8 wseb">中包含非常棒的系列教程①。 </div><div class="t m0 x0 h20 y3083 ffb5 fs3 fc0 sc0 ls248 ws214">15.3.1 类型化数组 </div><div class="t m0 x0 h5 y2fab ffb0 fs2 fc0 sc0 ls138 ws133">WebGL涉及的复杂计算需要提前知道数值的精度，而标准的JavaScript数值无法满足需要。为此，</div><div class="t m0 x0 h3c y323a ffb4 fs2 fc0 sc0 ls7b wsb">—————————— </div><div class="t m0 x0 h36 ycc6 ffb7 fs6 fc0 sc0 ls95">① 中文翻译版请参考http://www.hiwebgl.com/?p=42。 </div></div></div>
<div id="pf1e2" class="pf w0 h0" data-page-no="1e2"><div class="pc pc1e2 w0 h0"><div class="t m0 x0 h2 y1 ffb0 fs0 fc0 sc0 ls7 ws0">464  第15章 使用Canvas绘图 </div><div class="t m0 x0 h3 y2 ffb0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ffb0 fs2 fc0 sc0 ls138 ws133">WebGL引入了一个概念，叫类型化数组（typed arrays）。类型化数组也是数组，只不过其元素被设置为</div><div class="t m0 x0 h5 y4d ffb7 fs2 fc0 sc0 ls8 wseb">特定类型的值。 </div><div class="t m0 x0 h1c yd8 ffb7 fs2 fc0 sc0 ls8 wseb">类型化数组的核心就是一个名为ArrayBuffer的类型。每个ArrayBuffer对象表示的只是内存</div><div class="t m0 x0 h4 yd9 ffb7 fs2 fc0 sc0 ls8 wseb">中指定的字节数，但不会指定这些字节用于保存什么类型的数据。通过ArrayBuffer所能做的，就是</div><div class="t m0 x0 h5 y15d ffb7 fs2 fc0 sc0 ls8 wseb">为了将来使用而分配一定数量的字节。例如，下面这行代码会在内存中分配20B。 </div><div class="t m0 x0 hb y4ef ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yfdc ffb8 fs6 fc0 sc0 ls21 wsb">var buffer = new ArrayBuffer(20); </div><div class="t m0 x0 hb y3002 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 yd44 ffb7 fs2 fc0 sc0 ls5 wsec">创建了ArrayBuffer对象后，能够通过该对象获得的信息只有它包含的字节数，方法是访问其</div><div class="t m0 x0 h5 y14e4 ffb8 fs1 fc0 sc0 ls9 ws2">byteLength属性： </div><div class="t m0 x0 hb y14e5 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y14e6 ffb8 fs6 fc0 sc0 ls21 wsb">var bytes = buffer.byteLength; </div><div class="t m0 x0 hb y14e7 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y14e8 ffb7 fs2 fc0 sc0 ls8 wseb">虽然ArrayBuffer对象本身没有多少可说的，但对WebGL 而言，使用它是极其重要的。而且，</div><div class="t m0 x0 h5 y14e9 ffb7 fs2 fc0 sc0 ls8 wseb">在涉及视图的时候，你才会发现它原来还是很有意思的。 </div><div class="t m0 x0 h3c y323b ffb5 fs2 fc0 sc0 ls2e wsb">1. 视图 </div><div class="t m0 x0 h4 y323c ffb7 fs2 fc0 sc0 ls8 wseb">使用ArrayBuffer（数组缓冲器类型）的一种特别的方式就是用它来创建数组缓冲器视图。其中，</div><div class="t m0 x0 h4 y323d ffb7 fs2 fc0 sc0 ls8 wseb">最常见的视图是DataView，通过它可以选择ArrayBuffer中一小段字节。为此，可以在创建DataView</div><div class="t m0 x0 h4 y323e ffb7 fs2 fc0 sc0 ls8 wseb">实例的时候传入一个ArrayBuffer、一个可选的字节偏移量（从该字节开始选择）和一个可选的要选</div><div class="t m0 x0 h5 y323f ffb7 fs2 fc0 sc0 ls8 wseb">择的字节数。例如： </div><div class="t m0 x0 hb y3240 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y3241 ffb8 fs6 fc0 sc0 ls21">//基于整个缓冲器创建一个新视图 </div><div class="t m0 x0 hb y3242 ffb8 fs6 fc0 sc0 ls21 wsb">var view = new DataView(buffer); </div><div class="t m0 x0 hb y3243 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y3244 ffb8 fs6 fc0 sc0 ls21">//创建一个开始于字节9的新视图 </div><div class="t m0 x0 hb y3245 ffb8 fs6 fc0 sc0 ls21 wsb">var view = new DataView(buffer, 9); </div><div class="t m0 x0 hb y3246 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y3247 ffb8 fs6 fc0 sc0 ls21">//创建一个从字节9开始到字节18的新视图 </div><div class="t m0 x0 hb y3248 ffb8 fs6 fc0 sc0 ls21 wsb">var view = new DataView(buffer, 9, 10); </div><div class="t m0 x0 hb y3249 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y324a ffb7 fs2 fc0 sc0 ls4c wsfa">实例化之后，DataView对象会把字节偏移量以及字节长度信息分别保存在byteOffset 和</div><div class="t m0 x0 h5 y324b ffb8 fs1 fc0 sc0 ls9 ws2">byteLength属性中。 </div><div class="t m0 x0 hb ye4b ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y324c ffb8 fs6 fc0 sc0 ls21 wsb">alert(view.byteOffset); </div><div class="t m0 x0 hb y324d ffb8 fs6 fc0 sc0 ls21 wsb">alert(view.byteLength); </div><div class="t m0 x0 hb y324e ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y324f ffb7 fs2 fc0 sc0 ls8 wseb">通过这两个属性可以在以后方便地了解视图的状态。另外，通过其buffer属性也可以取得数组缓</div><div class="t m0 x0 h5 y3250 ffb7 fs2 fc0 sc0 ls8">冲器。 </div><div class="t m0 x0 hc yd15 ffb7 fs2 fc0 sc0 ls8 wseb">读取和写入DataView的时候，要根据实际操作的数据类型，选择相应的getter和setter 方法。下</div><div class="t m0 x0 hc y3251 ffb7 fs2 fc0 sc0 ls8 wseb">表列出了DataView支持的数据类型以及相应的读写方法。 </div><div class="t m0 x0 hb4 y631 ffb5 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h31 y3252 ffb4 fs6 fc0 sc0 ls8">数据类型 getter setter </div><div class="t m0 x0 h10c y196e ffb7 fs6 fc0 sc0 ls31 ws125">有符号8位整数 getInt8(byteOffset) setInt8(byteOffset, value) </div><div class="t m0 x0 h10c y1182 ffb7 fs6 fc0 sc0 ls31 ws125">无符号8位整数 getUint8(byteOffset) setUint8(byteOffset, value) </div><div class="t m0 x0 h10c y3253 ffb7 fs6 fc0 sc0 ls31 ws125">有符号16位整数 getInt16(byteOffset,littleEndian)  setInt16(byteOffset, </div><div class="t m0 x4 hb y3254 ffb8 fs6 fc0 sc0 ls21 wsb">value,littleEndian) </div><div class="t m0 x0 h10c y3255 ffb7 fs6 fc0 sc0 ls31 ws125">无符号16位整数 getUint16(byteOffset,littleEndian)  setUint16(byteOffset,value, </div><div class="t m0 x4 hb y3256 ffb8 fs6 fc0 sc0 ls21 wsb">littleEndian) </div><div class="t m0 x0 h10c y20eb ffb7 fs6 fc0 sc0 ls31 ws125">有符号32位整数 getInt32(byteOffset,littleEndian)  setInt32(byteOffset, </div><div class="t m0 x4 hb y3257 ffb8 fs6 fc0 sc0 ls21 ws347">value,littleEndian)  </div></div></div>
<div id="pf1e3" class="pf w0 h0" data-page-no="1e3"><div class="pc pc1e3 w0 h0"><div class="t m0 x2 h2 y1db2 ffb0 fs0 fc0 sc0 ls7 ws0">15.3 WebGL  465 </div><div class="t m0 x0 h3 y2 ffb0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffb2 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ffb2 fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ffb2 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffb2 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffb2 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffb2 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffb2 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffb2 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffb2 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffb2 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffb2 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ffb2 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ffb2 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x6 h3 y34f ffb7 fs1 fc0 sc0 ls8">（续） </div><div class="t m0 x0 h31 y350 ffb4 fs6 fc0 sc0 ls8">数据类型 getter setter </div><div class="t m0 x0 h10c y354 ffb7 fs6 fc0 sc0 ls31 ws125">无符号32位整数 getUint32(byteOffset,littleEndian)  setUint32(byteOffset,value, </div><div class="t m0 x4 hb y3258 ffb8 fs6 fc0 sc0 ls21 wsb">littleEndian) </div><div class="t m0 x0 h10c y3259 ffb0 fs6 fc0 sc0 lsa1">32位浮点数 getFloat32(byteOffset,littleEndian) setFloat32(byteOffset,value, </div><div class="t m0 x4 hb y325a ffb8 fs6 fc0 sc0 ls21 wsb">littleEndian) </div><div class="t m0 x0 h10c y325b ffb0 fs6 fc0 sc0 lsa1">64位浮点数 getFloat64(byteOffset,littleEndian) setFloat64(byteOffset,value, </div><div class="t m0 x4 hb y325c ffb8 fs6 fc0 sc0 ls21 wsb">littleEndian) </div><div class="t m0 x0 h5 y2e50 ffb0 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y325d ffb7 fs2 fc0 sc0 ls8 wseb">所有这些方法的第一个参数都是一个字节偏移量，表示要从哪个字节开始读取或写入。不要忘了，</div><div class="t m0 x0 h5 y325e ffb7 fs2 fc0 sc0 ls8 wseb">要保存有些数据类型的数据，可能需要不止1B。比如，无符号8位整数要用1B，而32位浮点数则要用</div><div class="t m0 x0 h5 y325f ffb0 fs2 fc0 sc0 ls8 ws20">4B。使用DataView，就需要你自己来管理这些细节，即要明确知道自己的数据需要多少字节，并选择</div><div class="t m0 x0 h5 y3b3 ffb7 fs2 fc0 sc0 ls8 wseb">正确的读写方法。例如： </div><div class="t m0 x0 hb y3260 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3261 ffb8 fs6 fc0 sc0 ls21 wsb">var buffer = new ArrayBuffer(20),  </div><div class="t m0 x0 hb y3262 ffb8 fs6 fc0 sc0 ls21 wsb">    view = new DataView(buffer), </div><div class="t m0 x0 hb y3263 ffb8 fs6 fc0 sc0 ls21 wsb">    value; </div><div class="t m0 x0 hb y3264 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3265 ffb8 fs6 fc0 sc0 ls21 wsb">view.setUint16(0, 25); </div><div class="t m0 x0 h34 y3266 ffb8 fs6 fc0 sc0 ls21 wsb">view.setUint16(2, 50); //不能从字节1开始，因为16位整数要用2B </div><div class="t m0 x0 hb y3267 ffb8 fs6 fc0 sc0 ls21 wsb">value = view.getUint16(0); </div><div class="t m0 x0 hb y3268 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y3269 ffbc fs2 fc0 sc0 ls2b wsb">DataViewExample01.htm </div><div class="t m0 x0 h5 y326a ffb7 fs2 fc0 sc0 ls8 wseb">以上代码把两个无符号16位整数保存到了数组缓冲器中。因为每个16位整数要用 2B，所以保存</div><div class="t m0 x0 h5 y326b ffb7 fs2 fc0 sc0 ls8 wseb">第一个数的字节偏移量为0，而保存第二个数的字节偏移量为2。 </div><div class="t m0 x0 h5 y326c ffb7 fs2 fc0 sc0 ls8 wseb">用于读写16位或更大数值的方法都有一个可选的参数littleEndian。这个参数是一个布尔值，</div><div class="t m0 x0 h4 y2cec ffb7 fs2 fc0 sc0 ls6 wsf7">表示读写数值时是否采用小端字节序（即将数据的最低有效位保存在低内存地址中），而不是大端字节</div><div class="t m0 x0 h4 y326d ffb7 fs2 fc0 sc0 ls8 wseb">序（即将数据的最低有效位保存在高内存地址中）。如果你也不确定应该使用哪种字节序，那不用管它，</div><div class="t m0 x0 h5 y326e ffb7 fs2 fc0 sc0 ls8 wseb">就采用默认的大端字节序方式保存即可。 </div><div class="t m0 x0 h4 y326f ffb7 fs2 fc0 sc0 ls8 wseb">因为在这里使用的是字节偏移量，而非数组元素数，所以可以通过几种不同的方式来访问同一字节。</div><div class="t m0 x0 h5 y3270 ffb7 fs2 fc0 sc0 ls8">例如： </div><div class="t m0 x0 hb y3271 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3272 ffb8 fs6 fc0 sc0 ls21 wsb">var buffer = new ArrayBuffer(20),  </div><div class="t m0 x0 hb y3273 ffb8 fs6 fc0 sc0 ls21 wsb">    view = new DataView(buffer), </div><div class="t m0 x0 hb y3274 ffb8 fs6 fc0 sc0 ls21 wsb">    value; </div><div class="t m0 x0 hb y3275 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3276 ffb8 fs6 fc0 sc0 ls21 wsb">view.setUint16(0, 25); </div><div class="t m0 x0 hb y3277 ffb8 fs6 fc0 sc0 ls21 wsb">value = view.getInt8(0); </div><div class="t m0 x0 hb y3278 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3279 ffb8 fs6 fc0 sc0 ls21 wsb">alert(value); //0 </div><div class="t m0 x0 hb y327a ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y31e4 ffbc fs2 fc0 sc0 ls2b wsb">DataViewExample02.htm </div><div class="t m0 x0 h5 yff ffb7 fs2 fc0 sc0 ls8 wseb">在这个例子中，数值25以16位无符号整数的形式被写入，字节偏移量为0。然后，再以 8位有符</div><div class="t m0 x0 h5 y327b ffb7 fs2 fc0 sc0 ls8 wseb">号整数的方式读取该数据，得到的结果是0。这是因为25的二进制形式的前8位（第一个字节）全部是</div><div class="t m0 x0 h5 y327c ffb0 fs2 fc0 sc0 ls8">0，如图15-14所示。 </div></div></div>
<div id="pf1e4" class="pf w0 h0" data-page-no="1e4"><div class="pc pc1e4 w0 h0"><div class="t m0 x0 h2 y1 ffb0 fs0 fc0 sc0 ls7 ws0">466  第15章 使用Canvas绘图 </div><div class="t m0 x0 h3 y2 ffb0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 h5 y327e ffb0 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x7 h3 y824 ffb7 fs1 fc0 sc0 ls8 wsb">图 15-14 </div><div class="t m0 x0 h4 y327f ffb7 fs2 fc0 sc0 ls8 wseb">可见，虽然DataView能让我们在字节级别上读写数组缓冲器中的数据，但我们必须自己记住要将</div><div class="t m0 x0 h5 y3280 ffb7 fs2 fc0 sc0 ls8 wseb">数据保存到哪里，需要占用多少字节。这样一来，就会带来很多工作量，因此类型化视图也就应运而生。 </div><div class="t m0 x0 h3c y3281 ffb5 fs2 fc0 sc0 ls2e wsb">2. 类型化视图 </div><div class="t m0 x0 h4 y3282 ffb7 fs2 fc0 sc0 ls8 wseb">类型化视图一般也被称为类型化数组，因为它们除了元素必须是某种特定的数据类型外，与常规的</div><div class="t m0 x0 hdf y3283 ffb7 fs2 fc0 sc0 ls8 wseb">数组无异。类型化视图也分几种，而且它们都继承了DataView。 </div><div class="t m0 x0 h5 y3284 ffb6 fs1 fc0 sc0 ls2"> Int8Array：表示8位二补整数。 </div><div class="t m0 x0 h5 y3285 ffb6 fs1 fc0 sc0 ls2"> Uint8Array：表示8位无符号整数。 </div><div class="t m0 x0 h5 y2344 ffb6 fs1 fc0 sc0 ls2"> Int16Array：表示16位二补整数。 </div><div class="t m0 x0 h5 y3286 ffb6 fs1 fc0 sc0 ls2"> Uint16Array：表示16位无符号整数。 </div><div class="t m0 x0 h5 y3287 ffb6 fs1 fc0 sc0 ls2"> Int32Array：表示32位二补整数。 </div><div class="t m0 x0 h5 y3288 ffb6 fs1 fc0 sc0 ls2"> Uint32Array：表示32位无符号整数。 </div><div class="t m0 x0 h5 y3289 ffb6 fs1 fc0 sc0 ls2"> Float32Array：表示32位IEEE浮点值。 </div><div class="t m0 x0 h5 y328a ffb6 fs1 fc0 sc0 ls2"> Float64Array：表示64位IEEE浮点值。 </div><div class="t m0 x0 h4 y328b ffb7 fs2 fc0 sc0 ls8 wseb">每种视图类型都以不同的方式表示数据，而同一数据视选择的类型不同有可能占用一或多字节。例</div><div class="t m0 x0 he y328c ffb7 fs2 fc0 sc0 ls8">如，20B的ArrayBuffer可以保存20 个Int8Array或Uint8Array，或者10个Int16Array或</div><div class="t m0 x0 h5 y25 ffb8 fs1 fc0 sc0 ls9 ws2">Uint16Array，或者5个Int32Array、Uint32Array或Float32Array，或者2个Float64Array。 </div><div class="t m0 x0 h1e y328d ffb7 fs2 fc0 sc0 ls8 wseb">由于这些视图都继承自DataView，因而可以使用相同的构造函数参数来实例化。第一个参数是要</div><div class="t m0 x0 hc y328e ffb7 fs2 fc0 sc0 ls8 wseb">使用ArrayBuffer对象，第二个参数是作为起点的字节偏移量（默认为0），第三个参数是要包含的字</div><div class="t m0 x0 h5 y328f ffb7 fs2 fc0 sc0 ls8 wseb">节数。三个参数中只有第一个是必需的。下面来看几个例子。 </div><div class="t m0 x0 hb y3290 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y3291 ffb8 fs6 fc0 sc0 ls21">//创建一个新数组，使用整个缓冲器 </div><div class="t m0 x0 hb y3292 ffb8 fs6 fc0 sc0 ls21 wsb">var int8s = new Int8Array(buffer); </div><div class="t m0 x0 hb y3293 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y3294 ffb8 fs6 fc0 sc0 ls21">//只使用从字节9开始的缓冲器 </div><div class="t m0 x0 hb y3295 ffb8 fs6 fc0 sc0 ls21 wsb">var int16s = new Int16Array(buffer, 9); </div><div class="t m0 x0 hb y3296 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y3297 ffb8 fs6 fc0 sc0 ls21">//只使用从字节9到字节18的缓冲器 </div><div class="t m0 x0 hb y3298 ffb8 fs6 fc0 sc0 ls21 wsb">var uint16s = new Uint16Array(buffer, 9, 10); </div><div class="t m0 x0 hb y3299 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y683 ffb7 fs2 fc0 sc0 ls8 wseb">能够指定缓冲器中可用的字节段，意味着能在同一个缓冲器中保存不同类型的数值。比如，下面的</div><div class="t m0 x0 h5 y329a ffb7 fs2 fc0 sc0 ls8 wseb">代码就是在缓冲器的开头保存8位整数，而在其他字节中保存16位整数。 </div><div class="t m0 x0 hb y2ba3 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y329b ffb8 fs6 fc0 sc0 ls21">//使用缓冲器的一部分保存8位整数，另一部分保存16位整数 </div><div class="t m0 x0 hb y329c ffb8 fs6 fc0 sc0 ls21 wsb">var int8s = new Int8Array(buffer, 0, 10); </div><div class="t m0 x0 hb y329d ffb8 fs6 fc0 sc0 ls21 wsb">var uint16s = new Uint16Array(buffer, 11, 10); </div><div class="t m0 x0 hb y329e ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y329f ffb7 fs2 fc0 sc0 ls8 wseb">每个视图构造函数都有一个名为BYTES_PER_ELEMENT的属性，表示类型化数组的每个元素需要多</div><div class="t m0 x0 hc y32a0 ffb7 fs2 fc0 sc0 ls8 wseb">少字节。因此，Uint8Array.BYTES_PER_ELEMENT就是1，而Float32Array.BYTES_PER_ELEMENT</div></div></div>
<div id="pf1e5" class="pf w0 h0" data-page-no="1e5"><div class="pc pc1e5 w0 h0"><div class="t m0 x2 h2 y1db2 ffb0 fs0 fc0 sc0 ls7 ws0">15.3 WebGL  467 </div><div class="t m0 x0 h3 y2 ffb0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffb2 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ffb2 fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ffb2 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffb2 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffb2 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffb2 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffb2 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffb2 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffb2 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffb2 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffb2 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ffb2 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ffb2 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ffb7 fs2 fc0 sc0 ls8 wseb">则为4。可以利用这个属性来辅助初始化。 </div><div class="t m0 x0 hb yfb2 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 yfb3 ffb8 fs6 fc0 sc0 ls21">//需要10个元素空间 </div><div class="t m0 x0 hb yfb4 ffb8 fs6 fc0 sc0 ls21 wsb">var int8s = new Int8Array(buffer, 0, 10 * Int8Array.BYTES_PER_ELEMENT); </div><div class="t m0 x0 hb yfb5 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 yfb6 ffb8 fs6 fc0 sc0 ls21">//需要5个元素空间 </div><div class="t m0 x0 hb yfb7 ffb8 fs6 fc0 sc0 ls21 wsb">var uint16s = new Uint16Array(buffer, int8s.byteOffset + int8s.byteLength,  </div><div class="t m0 x0 hb yfb8 ffb8 fs6 fc0 sc0 ls21 wsb">                              5 * Uint16Array.BYTES_PER_ELEMENT); </div><div class="t m0 x0 hb y32a1 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y32a2 ffb7 fs2 fc0 sc0 ls8 wseb">以上代码基于同一个数组缓冲器创建了两个视图。缓冲器的前10B用于保存8位整数，而其他字节</div><div class="t m0 x0 h5 y32a3 ffb7 fs2 fc0 sc0 ls8 wseb">用于保存无符号16位整数。在初始化Uint16Array的时候，使用了 Int8Array的byteOffset和</div><div class="t m0 x0 h5 yf6c ffb8 fs1 fc0 sc0 ls9 ws2">byteLength属性，以确保uint16s开始于8位数据之后。 </div><div class="t m0 x0 h4 yf6d ffb7 fs2 fc0 sc0 ls8 wseb">如前所述，类型化视图的目的在于简化对二进制数据的操作。除了前面看到的优点之外，创建类型</div><div class="t m0 x0 h1c y32a4 ffb7 fs2 fc0 sc0 ls8 wseb">化视图还可以不用首先创建ArrayBuffer对象。只要传入希望数组保存的元素数，相应的构造函数就</div><div class="t m0 x0 hc y32a5 ffb7 fs2 fc0 sc0 ls8 wseb">可以自动创建一个包含足够字节数的ArrayBuffer对象，例如： </div><div class="t m0 x0 hb y32a6 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y32a7 ffb8 fs6 fc0 sc0 ls21">//创建一个数组保存10个8位整数（10字节） </div><div class="t m0 x0 hb y32a8 ffb8 fs6 fc0 sc0 ls21 wsb">var int8s = new Int8Array(10); </div><div class="t m0 x0 hb y32a9 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y32aa ffb8 fs6 fc0 sc0 ls21">//创建一个数组保存10个16位整数（20字节） </div><div class="t m0 x0 hb y32ab ffb8 fs6 fc0 sc0 ls21 wsb">var int16s = new Int16Array(10); </div><div class="t m0 x0 hb y32ac ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y32ad ffb7 fs2 fc0 sc0 ls8 wseb">另外，也可以把常规数组转换为类型化视图，只要把常规数组传入类型化视图的构造函数即可： </div><div class="t m0 x0 hb y32ae ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y32af ffb8 fs6 fc0 sc0 ls21">//创建一个数组保存5个8位整数（10字节） </div><div class="t m0 x0 hb y32b0 ffb8 fs6 fc0 sc0 ls21 wsb">var int8s = new Int8Array([10, 20, 30, 40, 50]); </div><div class="t m0 x0 hb y32b1 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y2247 ffb7 fs2 fc0 sc0 ls8 wseb">这是用默认值来初始化类型化视图的最佳方式，也是WebGL项目中最常用的方式。 </div><div class="t m0 x0 h1e y32b2 ffb7 fs2 fc0 sc0 ls8 wseb">以这种方式来使用类型化视图，可以让它们看起来更像Array对象，同时也能确保在读写信息的</div><div class="t m0 x0 h5 y32b3 ffb7 fs2 fc0 sc0 ls8 wseb">时候使用正确的数据类型。 </div><div class="t m0 x0 h1e y32b4 ffb7 fs2 fc0 sc0 ls8 wseb">使用类型化视图时，可以通过方括号语法访问每一个数据成员，可以通过length属性确定数组中</div><div class="t m0 x0 hc y32b5 ffb7 fs2 fc0 sc0 ls8 wseb">有多少元素。这样，对类型化视图的迭代与对Array对象的迭代就是一样的了。 </div><div class="t m0 x0 hb y32b6 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y32b7 ffb8 fs6 fc0 sc0 ls21 wsb">for (var i=0, len=int8s.length; i &lt; len; i++){  </div><div class="t m0 x0 hb y32b8 ffb8 fs6 fc0 sc0 ls21 wsb">    console.log(&quot;Value at position &quot; + i + &quot; is &quot; + int8s[i]); </div><div class="t m0 x0 hb y32b9 ffb8 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y32ba ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y32bb ffb7 fs2 fc0 sc0 ls8 wseb">当然，也可以使用方括号语法为类型化视图的元素赋值。如果为相应元素指定的字节数放不下相应</div><div class="t m0 x0 h5 y32bc ffb7 fs2 fc0 sc0 ls8 wseb">的值，则实际保存的值是最大可能值的模。例如，无符号16位整数所能表示的最大数值是65535，如果</div><div class="t m0 x0 h5 yf8 ffb7 fs2 fc0 sc0 ls8 wseb">你想保存65536，那实际保存的值是0；如果你想保存65537，那实际保存的值是1，依此类推。 </div><div class="t m0 x0 hb y32bd ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y32be ffb8 fs6 fc0 sc0 ls21 wsb">var uint16s = new Uint16Array(10); </div><div class="t m0 x0 hb y32bf ffb8 fs6 fc0 sc0 ls21 wsb">uint16s[0] = 65537; </div><div class="t m0 x0 hb y32c0 ffb8 fs6 fc0 sc0 ls21 wsb">alert(uint16s[0]); //1 </div><div class="t m0 x0 hb y32c1 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y32c2 ffb7 fs2 fc0 sc0 ls8 wseb">数据类型不匹配时不会抛出错误，所以你必须自己保证所赋的值不会超过相应元素的字节限制。 </div><div class="t m0 x0 h1e y32c3 ffb7 fs2 fc0 sc0 ls8 wseb">类型化视图还有一个方法，即subarray()，使用这个方法可以基于底层数组缓冲器的子集创建一</div><div class="t m0 x0 h4 y32c4 ffb7 fs2 fc0 sc0 ls8 wseb">个新视图。这个方法接收两个参数：开始元素的索引和可选的结束元素的索引。返回的类型与调用该方</div><div class="t m0 x0 h5 y32c5 ffb7 fs2 fc0 sc0 ls8 wseb">法的视图类型相同。例如： </div><div class="t m0 x0 hb ycb8 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y32c6 ffb8 fs6 fc0 sc0 ls21 wsb">var uint16s = new Uint16Array(10),  </div><div class="t m0 x0 h15 y32c7 ffbb fs6 fc0 sc0 ls21 wsb">    sub = uint16s.subarray(2, 5); </div><div class="t m0 x0 hb y32c8 ffb8 fs6 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf1e6" class="pf w0 h0" data-page-no="1e6"><div class="pc pc1e6 w0 h0"><div class="t m0 x0 h2 y1 ffb0 fs0 fc0 sc0 ls7 ws0">468  第15章 使用Canvas绘图 </div><div class="t m0 x0 h3 y2 ffb0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ffb7 fs2 fc0 sc0 ls3ba ws34a">在以上代码中，sub也是Uint16Array 的一个实例，而且底层与uint16s都基于同一个</div><div class="t m0 x0 h4 y4 ffb8 fs1 fc0 sc0 ls9 ws2">ArrayBuffer。通过大视图创建小视图的主要好处就是，在操作大数组中的一部分元素时，无需担心意</div><div class="t m0 x0 h5 y5 ffb7 fs2 fc0 sc0 ls8 wseb">外修改了其他元素。 </div><div class="t m0 x0 h5 y6 ffb7 fs2 fc0 sc0 ls8 wseb">类型化数组是WebGL项目中执行各种操作的重要基础。 </div><div class="t m0 x0 h20 y32ca ffb5 fs3 fc0 sc0 ls248 ws214">15.3.2 WebGL上下文 </div><div class="t m0 x0 h5 y32cb ffb7 fs2 fc0 sc0 ls8 wseb">目前，在支持的浏览器中，WebGL的名字叫&quot;experimental-webgl&quot;，这是因为WebGL规范仍</div><div class="t m0 x0 hc y32cc ffb7 fs2 fc0 sc0 ls8 wseb">然未制定完成。制定完成后，这个上下文的名字就会变成简单的&quot;webgl&quot;。如果浏览器不支持WebGL，</div><div class="t m0 x0 h5 y32cd ffb7 fs2 fc0 sc0 ls8 wseb">那么取得该上下文时会返回null。在使用WebGL上下文时，务必先检测一下返回值。 </div><div class="t m0 x0 hb y1318 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y32ce ffb8 fs6 fc0 sc0 ls21 wsb">var drawing = document.getElementById(&quot;drawing&quot;); </div><div class="t m0 x0 hb y32cf ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y32d0 ffb8 fs6 fc0 sc0 ls21">//确定浏览器支持&lt;canvas&gt;元素 </div><div class="t m0 x0 hb y32d1 ffb8 fs6 fc0 sc0 ls21 wsb">if (drawing.getContext){ </div><div class="t m0 x0 hb y32d2 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y32d3 ffb8 fs6 fc0 sc0 ls21 wsb">    var gl = drawing.getContext(&quot;experimental-webgl&quot;); </div><div class="t m0 x0 h15 y32d4 ffbb fs6 fc0 sc0 ls21 wsb">    if (gl){ </div><div class="t m0 x0 h34 y32d5 ffbb fs6 fc0 sc0 ls21 wsb">        //使用WebGL </div><div class="t m0 x0 h15 y32d6 ffbb fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y32d7 ffb8 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y32d8 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y206d ffbc fs2 fc0 sc0 ls79 wsb">WebGLExample01.htm </div><div class="t m0 x0 h5 y264c ffb7 fs2 fc0 sc0 ls30 wsf6">一般都把WebGL上下文对象命名为gl。大多数WebGL应用和示例都遵守这一约定，因为OpenGL </div><div class="t m0 x0 hc y32d9 ffb0 fs2 fc0 sc0 ls3e7 ws34e">ES 2.0规定的方法和值通常都以&quot;gl&quot;开头。这样做也可以保证JavaScript代码与OpenGL程序更相近。 </div><div class="t m0 x0 h5 y32da ffb7 fs2 fc0 sc0 ls8 wseb">取得了WebGL上下文之后，就可以开始3D绘图了。如前所述，WebGL 是OpenGL ES 2.0的Web</div><div class="t m0 x0 h5 y32db ffb7 fs2 fc0 sc0 ls8 wseb">版，因此本节讨论的概念实际上就是OpenGL概念在JavaScript中的实现。 </div><div class="t m0 x0 he y32dc ffb7 fs2 fc0 sc0 ls8 wseb">通过给getContext()传递第二个参数，可以为WebGL上下文设置一些选项。这个参数本身是一</div><div class="t m0 x0 h5 y32dd ffb7 fs2 fc0 sc0 ls8 wseb">个对象，可以包含下列属性。 </div><div class="t m0 x0 h5 y32de ffb6 fs1 fc0 sc0 ls2"> alpha：值为true，表示为上下文创建一个Alpha通道缓冲区；默认值为true。 </div><div class="t m0 x0 h5 y127b ffb6 fs1 fc0 sc0 ls2"> depth：值为true，表示可以使用16位深缓冲区；默认值为true。 </div><div class="t m0 x0 h5 y32df ffb6 fs1 fc0 sc0 ls2"> stencil：值为true，表示可以使用8位模板缓冲区；默认值为false。 </div><div class="t m0 x0 h5 y32e0 ffb6 fs1 fc0 sc0 ls2"> antialias：值为true，表示将使用默认机制执行抗锯齿操作；默认值为true。 </div><div class="t m0 x0 h5 y32e1 ffb6 fs1 fc0 sc0 ls2"> premultipliedAlpha：值为true，表示绘图缓冲区有预乘Alpha值；默认值为true。 </div><div class="t m0 x0 h4 y32e2 ffb6 fs1 fc0 sc0 ls2"> preserveDrawingBuffer：值为true，表示在绘图完成后保留绘图缓冲区；默认值为false。</div><div class="t m0 x0 h5 y32e3 ffb7 fs2 fc0 sc0 ls8 wseb">建议确实有必要的情况下再开启这个值，因为可能影响性能。 </div><div class="t m0 x0 h5 y32e4 ffb7 fs2 fc0 sc0 ls8 wseb">传递这个选项对象的方式如下： </div><div class="t m0 x0 hb y32e5 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y32e6 ffb8 fs6 fc0 sc0 ls21 wsb">var drawing = document.getElementById(&quot;drawing&quot;); </div><div class="t m0 x0 hb y32e7 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y32e8 ffb8 fs6 fc0 sc0 ls21">//确定浏览器支持&lt;canvas&gt;元素 </div><div class="t m0 x0 hb y32e9 ffb8 fs6 fc0 sc0 ls21 wsb">if (drawing.getContext){  </div><div class="t m0 x0 hb y32ea ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y32eb ffbb fs6 fc0 sc0 ls21 wsb">    var gl = drawing.getContext(&quot;experimental-webgl&quot;, { alpha: false}); </div><div class="t m0 x0 h15 y32ec ffbb fs6 fc0 sc0 ls21 wsb">    if (gl){ </div><div class="t m0 x0 h34 y32ed ffbb fs6 fc0 sc0 ls21 wsb">        //使用WebGL </div></div></div>
<div id="pf1e7" class="pf w0 h0" data-page-no="1e7"><div class="pc pc1e7 w0 h0"><div class="t m0 x2 h2 y1db2 ffb0 fs0 fc0 sc0 ls7 ws0">15.3 WebGL  469 </div><div class="t m0 x0 h3 y2 ffb0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffb2 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ffb2 fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ffb2 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffb2 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffb2 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffb2 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffb2 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffb2 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffb2 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffb2 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffb2 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ffb2 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ffb2 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h15 y79 ffbb fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y7a ffb8 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y32ee ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y32ef ffbc fs2 fc0 sc0 ls79 wsb">WebGLExample01.htm </div><div class="t m0 x0 h5 y32f0 ffb7 fs2 fc0 sc0 ls8 wseb">大多数上下文选项只在高级技巧中使用。很多时候，各个选项的默认值就能满足我们的要求。 </div><div class="t m0 x0 hc y32f1 ffb7 fs2 fc0 sc0 ls8 wseb">如果getContext()无法创建WebGL上下文，有的浏览器会抛出错误。为此，最好把调用封装到</div><div class="t m0 x0 h5 y32f2 ffb7 fs2 fc0 sc0 ls8 wseb">一个try-catch块中。 </div><div class="t m0 x0 hb y32f3 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y32f4 ffb8 fs6 fc0 sc0 ls21 wsb">Insert IconMargin       [download]var drawing = document.getElementById(&quot;drawing&quot;),  </div><div class="t m0 x0 hb y32f5 ffb8 fs6 fc0 sc0 ls21 wsb">    gl; </div><div class="t m0 x0 hb y32f6 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y32f7 ffb8 fs6 fc0 sc0 ls21">//确定浏览器支持&lt;canvas&gt;元素 </div><div class="t m0 x0 hb y32f8 ffb8 fs6 fc0 sc0 ls21 wsb">if (drawing.getContext){ </div><div class="t m0 x0 h15 y32f9 ffbb fs6 fc0 sc0 ls21 wsb">    try { </div><div class="t m0 x0 hb y32fa ffb8 fs6 fc0 sc0 ls21 wsb">        gl = drawing.getContext(&quot;experimental-webgl&quot;); </div><div class="t m0 x0 h15 y32fb ffbb fs6 fc0 sc0 ls21 wsb">    } catch (ex) { </div><div class="t m0 x0 h34 y32fc ffbb fs6 fc0 sc0 ls21 wsb">        //什么也不做 </div><div class="t m0 x0 h15 y32fd ffbb fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y32fe ffb8 fs6 fc0 sc0 ls21 wsb">    if (gl){ </div><div class="t m0 x0 h34 y32ff ffb8 fs6 fc0 sc0 ls21 wsb">        //使用WebGL </div><div class="t m0 x0 hb y3300 ffb8 fs6 fc0 sc0 ls21 wsb">    } else { </div><div class="t m0 x0 hb y3301 ffb8 fs6 fc0 sc0 ls21 wsb">        alert(&quot;WebGL context could not be created.&quot;); </div><div class="t m0 x0 hb y3302 ffb8 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y3303 ffb8 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y3304 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y3305 ffbc fs2 fc0 sc0 ls79 wsb">WebGLExample01.htm </div><div class="t m0 x0 h3c y3306 ffb5 fs2 fc0 sc0 ls2e wsb">1. 常量 </div><div class="t m0 x0 h5 y3307 ffb7 fs2 fc0 sc0 ls8 wseb">如果你熟悉OpenGL，那肯定会对各种操作中使用非常多的常量印象深刻。这些常量在OpenGL中</div><div class="t m0 x0 h54 y3308 ffb7 fs2 fc0 sc0 ls221 ws21e">都带前缀GL_。在WebGL 中，保存在上下文对象中的这些常量都没有GL_前缀。比如说，</div><div class="t m0 x0 h5 y3309 ffb8 fs1 fc0 sc0 ls9 ws2">GL_COLOR_BUFFER_BIT常量在WebGL上下文中就是gl.COLOR_BUFFER_BIT。WebGL以这种方式支</div><div class="t m0 x0 h5 y330a ffb7 fs2 fc0 sc0 ls8 wseb">持大多数OpenGL常量（有一部分常量是不支持的）。 </div><div class="t m0 x0 h3c y330b ffb5 fs2 fc0 sc0 ls2e wsb">2. 方法命名 </div><div class="t m0 x0 h5 y330c ffb0 fs2 fc0 sc0 lsd ws8">OpenGL（以及WebGL）中的很多方法都试图通过名字传达有关数据类型的信息。如果某方法可以</div><div class="t m0 x0 h5 y330d ffb7 fs2 fc0 sc0 ls8 wseb">接收不同类型及不同数量的参数，看方法名的后缀就可以知道。方法名的后缀会包含参数个数（1到4）</div><div class="t m0 x0 h67 y330e ffb7 fs2 fc0 sc0 ls8 wseb">和接收的数据类型（f表示浮点数，i表示整数）。例如，gl.uniform4f()意味着要接收4个浮点数，</div><div class="t m0 x0 h5 y330f ffb7 fs2 fc0 sc0 ls3e9">而gl.uniform3i()则表示要接收3个整数。 </div><div class="t m0 x0 h5 y3310 ffb7 fs2 fc0 sc0 ls8 wseb">也有很多方法接收数组参数而非一个个单独的参数。这样的方法其名字中会包含字母v（即vector，</div><div class="t m0 x0 he y3311 ffb7 fs2 fc0 sc0 ls8 wseb">矢量）。因此，gl.uniform3iv()可以接收一个包含3个值的整数数组。请大家记住以上命名约定，这</div><div class="t m0 x0 h5 ybd6 ffb7 fs2 fc0 sc0 ls8 wseb">样对理解后面关于WebGL的讨论很有帮助。 </div><div class="t m0 x0 h3c y3312 ffb5 fs2 fc0 sc0 ls2e wsb">3. 准备绘图 </div><div class="t m0 x0 h5 y3313 ffb7 fs2 fc0 sc0 ls8 wseb">在实际操作WebGL上下文之前，一般都要使用某种实色清除&lt;canvas&gt;，为绘图做好准备。为此，</div><div class="t m0 x0 h5 y3314 ffb7 fs2 fc0 sc0 ls8 wseb">首先必须使用clearColor()方法来指定要使用的颜色值，该方法接收4个参数：红、绿、蓝和透明度。</div><div class="t m0 x0 h5 y21b1 ffb7 fs2 fc0 sc0 ls8 wseb">每个参数必须是一个0到1之间的数值，表示每种分量在最终颜色中的强度。来看下面的例子。 </div><div class="t m0 x0 hb y56c ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3315 ffb8 fs6 fc0 sc0 ls21 wsb">gl.clearColor(0,0,0,1);   //black </div><div class="t m0 x0 hb y3316 ffb8 fs6 fc0 sc0 ls21 wsb">gl.clear(gl.COLOR_BUFFER_BIT); </div><div class="t m0 x0 hb y3317 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y3318 ffbc fs2 fc0 sc0 ls79 wsb">WebGLExample01.htm </div></div></div>
<div id="pf1e8" class="pf w0 h0" data-page-no="1e8"><div class="pc pc1e8 w0 h0"><div class="t m0 x0 h2 y1 ffb0 fs0 fc0 sc0 ls7 ws0">470  第15章 使用Canvas绘图 </div><div class="t m0 x0 h3 y2 ffb0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ffb7 fs2 fc0 sc0 ls8 wseb">以上代码把清理颜色缓冲区的值设置为黑色，然后调用了clear()方法，这个方法与OpenGL中的</div><div class="t m0 x0 h5 y4 ffb8 fs1 fc0 sc0 ls9 ws2">glClear()等价。传入的参数gl.COLOR_BUFFER_BIT告诉WebGL使用之前定义的颜色来填充相应区</div><div class="t m0 x0 h5 y5 ffb7 fs2 fc0 sc0 ls8 wseb">域。一般来说，都要先清理缓冲区，然后再执行其他绘图操作。 </div><div class="t m0 x0 h3c y331a ffb5 fs2 fc0 sc0 ls2e wsb">4. 视口与坐标 </div><div class="t m0 x0 h5 y17cf ffb7 fs2 fc0 sc0 ls8 wseb">开始绘图之前，通常要先定义WebGL的视口（viewport）。默认情况下，视口可以使用整个&lt;canvas&gt;</div><div class="t m0 x0 h5 y1ed2 ffb7 fs2 fc0 sc0 ls8 wseb">区域。要改变视口大小，可以调用viewport()方法并传入4个参数：（视口相对于&lt;canvas&gt;元素的）</div><div class="t m0 x0 hc y2088 ffbc fs2 fc0 sc0 lsdd">x坐标、y坐标、宽度和高度。例如，下面的调用就使用了&lt;canvas&gt;元素： </div><div class="t m0 x0 hb yd44 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yd45 ffb8 fs6 fc0 sc0 ls21 wsb">gl.viewport(0, 0, drawing.width, drawing.height); </div><div class="t m0 x0 hb y331b ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y331c ffb7 fs2 fc0 sc0 ls30">视口坐标与我们通常熟悉的网页坐标不一样。视口坐标的原点(0,0)在&lt;canvas&gt;元素的左下角，x</div><div class="t m0 x0 h25 y331d ffb7 fs2 fc0 sc0 ls8 wseb">轴和y轴的正方向分别是向右和向上，可以定义为(width1, height1)，如图15-15所示。 </div><div class="t m0 x4 h5 y331e ffb0 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x7 h3 y18f ffb7 fs1 fc0 sc0 ls8 wsb">图 15-15 </div><div class="t m0 x0 h5 y2a84 ffb7 fs2 fc0 sc0 ls8 wseb">知道怎么定义视口大小，就可以只在&lt;canvas&gt;元素的部分区域中绘图。来看下面的例子。 </div><div class="t m0 x0 hb y331f ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y3320 ffb8 fs6 fc0 sc0 ls21">//视口是&lt;canvas&gt;左下角的四分之一区域 </div><div class="t m0 x0 hb y3321 ffb8 fs6 fc0 sc0 ls21 wsb">gl.viewport(0, 0, drawing.width/2, drawing.height/2); </div><div class="t m0 x0 hb y3322 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y3323 ffb8 fs6 fc0 sc0 ls21">//视口是&lt;canvas&gt;左上角的四分之一区域 </div><div class="t m0 x0 hb y3324 ffb8 fs6 fc0 sc0 ls21 wsb">gl.viewport(0, drawing.height/2, drawing.width/2, drawing.height/2); </div><div class="t m0 x0 hb y3325 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y3326 ffb8 fs6 fc0 sc0 ls21">//视口是&lt;canvas&gt;右下角的四分之一区域 </div><div class="t m0 x0 hb y3327 ffb8 fs6 fc0 sc0 ls21 wsb">gl.viewport(drawing.width/2, 0, drawing.width/2, drawing.height/2); </div><div class="t m0 x0 hb y3328 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3329 ffb7 fs2 fc0 sc0 ls8 wseb">另外，视口内部的坐标系与定义视口的坐标系也不一样。在视口内部，坐标原点(0,0)是视口的中心</div><div class="t m0 x0 h25 y332a ffb7 fs2 fc0 sc0 ls8 wseb">点，因此视口左下角坐标为(1,1)，而右上角坐标为(1,1)，如图15-16所示。 </div><div class="t m0 x4 h5 y332b ffb0 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x7 h3 y332c ffb7 fs1 fc0 sc0 ls8 wsb">图 15-16 </div><div class="t m0 x0 h4 y332d ffb7 fs2 fc0 sc0 ls8 wseb">如果在视口内部绘图时使用视口外部的坐标，结果可能会被视口剪切。比如，要绘制的形状有一个</div><div class="t m0 x0 h5 y332e ffb7 fs2 fc0 sc0 ls8">顶点在(1,2)，那么该形状在视口右侧的部分会被剪切掉。 </div><div class="t m0 x0 h3c y65d ffb5 fs2 fc0 sc0 ls2e wsb">5. 缓冲区 </div><div class="t m0 x0 h5 y332f ffb7 fs2 fc0 sc0 ls8 wseb">顶点信息保存在JavaScript的类型化数组中，使用之前必须转换到WebGL的缓冲区。要创建缓冲区，</div></div></div>
<div id="pf1e9" class="pf w0 h0" data-page-no="1e9"><div class="pc pc1e9 w0 h0"><div class="t m0 x2 h2 y1db2 ffb0 fs0 fc0 sc0 ls7 ws0">15.3 WebGL  471 </div><div class="t m0 x0 h3 y2 ffb0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffb2 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ffb2 fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ffb2 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffb2 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffb2 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffb2 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffb2 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffb2 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffb2 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffb2 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffb2 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ffb2 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ffb2 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ffb7 fs2 fc0 sc0 ls8 wseb">可以调用gl.createBuffer()，然后使用gl.bindBuffer()绑定到WebGL 上下文。这两步做完之</div><div class="t m0 x0 h5 y4d ffb7 fs2 fc0 sc0 ls8 wseb">后，就可以用数据来填充缓冲区了。例如： </div><div class="t m0 x0 hb y2d8 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2d9 ffb8 fs6 fc0 sc0 ls21 wsb">var buffer = gl.createBuffer(); </div><div class="t m0 x0 hb y2da ffb8 fs6 fc0 sc0 ls21 wsb">gl.bindBuffer(gl.ARRAY_BUFFER, buffer); </div><div class="t m0 x0 hb y2db ffb8 fs6 fc0 sc0 ls21 wsb">gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0.5, 1]), gl.STATIC_DRAW); </div><div class="t m0 x0 hb y2320 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y22a9 ffb7 fs2 fc0 sc0 ls5 wsec">调用gl.bindBuffer()可以将buffer设置为上下文的当前缓冲区。此后，所有缓冲区操作都</div><div class="t m0 x0 h4 y2321 ffb7 fs2 fc0 sc0 ls5 wsec">直接在buffer中执行。因此，调用gl.bufferData()时不需要明确传入buffer也没有问题。最后</div><div class="t m0 x0 h1e y2733 ffb7 fs2 fc0 sc0 ls5 wsec">一行代码使用Float32Array中的数据初始化了buffer（一般都是用Float32Array来保存顶点信</div><div class="t m0 x0 hc y2734 ffb7 fs2 fc0 sc0 ls5 wsec">息）。如果想使用drawElements()输出缓冲区的内容，也可以传入gl.ELEMENT_ARRAY_BUFFER。 </div><div class="t m0 x0 h5 y147d ffb8 fs1 fc0 sc0 ls9 ws2">gl.bufferData()的最后一个参数用于指定使用缓冲区的方式，取值范围是如下几个常量。 </div><div class="t m0 x0 h5 y3330 ffb6 fs1 fc0 sc0 ls2"> gl.STATIC_DRAW：数据只加载一次，在多次绘图中使用。 </div><div class="t m0 x0 h5 y3331 ffb6 fs1 fc0 sc0 ls2"> gl.STREAM_DRAW：数据只加载一次，在几次绘图中使用。 </div><div class="t m0 x0 h5 y1480 ffb6 fs1 fc0 sc0 ls2"> gl.DYNAMIC_DRAW：数据动态改变，在多次绘图中使用。 </div><div class="t m0 x0 h5 y1481 ffb7 fs2 fc0 sc0 ls8 wseb">如果不是非常有经验的OpenGL程序员，多数情况下将缓冲区使用方式设置为 gl.STATIC_DRAW</div><div class="t m0 x0 h5 y3332 ffb7 fs2 fc0 sc0 ls8">即可。 </div><div class="t m0 x0 h4 y647 ffb7 fs2 fc0 sc0 ls8 wseb">在包含缓冲区的页面重载之前，缓冲区始终保留在内存中。如果你不想要某个缓冲区了，可以直接</div><div class="t m0 x0 hc y2890 ffb7 fs2 fc0 sc0 ls8 wseb">调用gl.deleteBuffer()释放内存： </div><div class="t m0 x0 hb y3333 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3334 ffb8 fs6 fc0 sc0 ls21 wsb">gl.deleteBuffer(buffer); </div><div class="t m0 x0 hb y3335 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h3c y3336 ffb5 fs2 fc0 sc0 ls2e wsb">6. 错误 </div><div class="t m0 x0 h5 y3337 ffb0 fs2 fc0 sc0 lsb ws5">JavaScript与WebGL之间的一个最大的区别在于，WebGL操作一般不会抛出错误。为了知道是否</div><div class="t m0 x0 h4 y3338 ffb7 fs2 fc0 sc0 ls8 wseb">有错误发生，必须在调用某个可能出错的方法后，手工调用gl.getError()方法。这个方法返回一个</div><div class="t m0 x0 h5 y3339 ffb7 fs2 fc0 sc0 ls8 wseb">表示错误类型的常量。可能的错误常量如下。 </div><div class="t m0 x0 h5 y333a ffb6 fs1 fc0 sc0 ls2"> gl.NO_ERROR：上一次操作没有发生错误（值为0）。 </div><div class="t m0 x0 h5 y333b ffb6 fs1 fc0 sc0 ls2"> gl.INVALID_ENUM：应该给方法传入WebGL常量，但却传错了参数。 </div><div class="t m0 x0 h5 y120d ffb6 fs1 fc0 sc0 ls2"> gl.INVALID_VALUE：在需要无符号数的地方传入了负值。 </div><div class="t m0 x0 h5 ye9d ffb6 fs1 fc0 sc0 ls2"> gl.INVALID_OPERATION：在当前状态下不能完成操作。 </div><div class="t m0 x0 h5 y333c ffb6 fs1 fc0 sc0 ls2"> gl.OUT_OF_MEMORY：没有足够的内存完成操作。 </div><div class="t m0 x0 h5 y1662 ffb6 fs1 fc0 sc0 ls2"> gl.CONTEXT_LOST_WEBGL：由于外部事件（如设备断电）干扰丢失了当前WebGL上下文。 </div><div class="t m0 x0 h1e y1663 ffb7 fs2 fc0 sc0 ls8 wseb">每次调用gl.getError()方法返回一个错误值。第一次调用后，后续对gl.getError()的调用</div><div class="t m0 x0 h1e y333d ffb7 fs2 fc0 sc0 ls386 ws2fd">可能会返回另一个错误值。如果发生了多个错误，需要反复调用gl.getError()直至它返回</div><div class="t m0 x0 h5 y333e ffb8 fs1 fc0 sc0 ls9 ws2">gl.NO_ERROR。在执行了很多操作的情况下，最好通过一个循环来调用getError()，如下所示： </div><div class="t m0 x0 hb y22a0 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y333f ffb8 fs6 fc0 sc0 ls21 wsb">var errorCode = gl.getError();  </div><div class="t m0 x0 hb y3340 ffb8 fs6 fc0 sc0 ls21 wsb">while(errorCode){ </div><div class="t m0 x0 hb y3341 ffb8 fs6 fc0 sc0 ls21 wsb">    console.log(&quot;Error occurred: &quot; + errorCode); </div><div class="t m0 x0 hb y3342 ffb8 fs6 fc0 sc0 ls21 wsb">    errorCode = gl.getError(); </div><div class="t m0 x0 hb y3343 ffb8 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y3344 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y26ab ffb7 fs2 fc0 sc0 ls8 wseb">如果WebGL脚本输出不正确，那在脚本中放几行gl.getError()有助于找出问题所在。 </div><div class="t m0 x0 h3c y3345 ffb5 fs2 fc0 sc0 ls2e wsb">7. 着色器 </div><div class="t m0 x0 h5 y3346 ffb7 fs2 fc0 sc0 ls8 wseb">着色器（shader）是OpenGL中的另一个概念。WebGL中有两种着色器：顶点着色器和片段（或像</div><div class="t m0 x0 h5 y3347 ffb7 fs2 fc0 sc0 ls8 wseb">素）着色器。顶点着色器用于将3D顶点转换为需要渲染的2D 点。片段着色器用于准确计算要绘制的</div></div></div>
<div id="pf1ea" class="pf w0 h0" data-page-no="1ea"><div class="pc pc1ea w0 h0"><div class="t m0 x0 h2 y1 ffb0 fs0 fc0 sc0 ls7 ws0">472  第15章 使用Canvas绘图 </div><div class="t m0 x0 h3 y2 ffb0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ffb7 fs2 fc0 sc0 ls8 wseb">每个像素的颜色。WebGL着色器的独特之处也是其难点在于，它们并不是用JavaScript写的。这些着色</div><div class="t m0 x0 h5 y4d ffb7 fs2 fc0 sc0 ls8 wseb">器是使用GLSL（OpenGL Shading Language，OpenGL着色语言）写的，GLSL是一种与C和JavaScript</div><div class="t m0 x0 h5 yd8 ffb7 fs2 fc0 sc0 ls8 wseb">完全不同的语言。 </div><div class="t m0 x0 h3c y3349 ffb5 fs2 fc0 sc0 ls2e wsb">8. 编写着色器 </div><div class="t m0 x0 h5 y334a ffb0 fs2 fc0 sc0 ls96 wsb2">GLSL是一种类C语言，专门用于编写OpenGL着色器。因为WebGL是OpenGL ES 2.0的实现，所</div><div class="t m0 x0 h5 y334b ffb7 fs2 fc0 sc0 ls3b">以OpenGL中使用的着色器可以直接在WebGL中使用。这样就方便了将桌面图形应用移植到浏览器中。 </div><div class="t m0 x0 hb2 y334c ffb7 fs2 fc0 sc0 ls8 wseb">每个着色器都有一个main()方法，该方法在绘图期间会重复执行。为着色器传递数据的方式有两</div><div class="t m0 x0 h5 y1ed4 ffb7 fs2 fc0 sc0 ls8">种：Attribute和Uniform。通过Attribute可以向顶点着色器中传入顶点信息，通过Uniform 可以向任何</div><div class="t m0 x0 h5 y334d ffb7 fs2 fc0 sc0 ls5">着色器传入常量值。Attribute和Uniform在main()方法外部定义，分别使用关键字 attribute和</div><div class="t m0 x0 h5 y2043 ffb8 fs1 fc0 sc0 ls9 ws2">uniform。在这两个值类型关键字之后，是数据类型和变量名。下面是一个简单的顶点着色器的例子。 </div><div class="t m0 x0 hb y1d94 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y334e ffb8 fs6 fc0 sc0 ls21 ws34">//OpenGL着色语言 </div><div class="t m0 x0 h34 y334f ffb8 fs6 fc0 sc0 ls21">//着色器，作者Bartek Drozdz，摘自他的文章 </div><div class="t m0 x0 hb y3350 ffb8 fs6 fc0 sc0 ls21 wsb">//http://www.netmagazine.com/tutorials/get-started-webgl-draw-square </div><div class="t m0 x0 hb y3351 ffb8 fs6 fc0 sc0 ls21 wsb">attribute vec2 aVertexPosition; </div><div class="t m0 x0 hb y3352 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3353 ffb8 fs6 fc0 sc0 ls21 wsb">void main() {  </div><div class="t m0 x0 hb y3354 ffb8 fs6 fc0 sc0 ls21 wsb">        gl_Position = vec4(aVertexPosition, 0.0, 1.0); </div><div class="t m0 x0 hb y3355 ffb8 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y3356 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y3357 ffbc fs2 fc0 sc0 ls79 wsb">WebGLExample02.htm </div><div class="t m0 x0 h5 y1198 ffb7 fs2 fc0 sc0 ls8 wseb">这个顶点着色器定义了一个名为aVertexPosition的Attribute，这个Attribute是一个数组，包含</div><div class="t m0 x0 h1e y2d64 ffb7 fs2 fc0 sc0 ls8 wseb">两个元素（数据类型为vec2），表示x和y坐标。即使只接收到两个坐标，顶点着色器也必须把一个包</div><div class="t m0 x0 h1e y3358 ffb7 fs2 fc0 sc0 ls8 wseb">含四方面信息的顶点赋值给特殊变量gl_Position。这里的着色器创建了一个新的包含四个元素的数</div><div class="t m0 x0 hc y2d66 ffb7 fs2 fc0 sc0 ls8 wseb">组（vec4），填补缺失的坐标，结果是把2D坐标转换成了3D坐标。 </div><div class="t m0 x0 h5 y2d67 ffb7 fs2 fc0 sc0 ls8 wseb">除了只能通过Uniform传入数据外，片段着色器与顶点着色器类似。以下是片段着色器的例子。 </div><div class="t m0 x0 hb y148c ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y3359 ffb8 fs6 fc0 sc0 ls21 ws34">//OpenGL着色语言 </div><div class="t m0 x0 h34 y335a ffb8 fs6 fc0 sc0 ls21">//着色器，作者Bartek Drozdz，摘自他的文章 </div><div class="t m0 x0 hb y335b ffb8 fs6 fc0 sc0 ls21 wsb">//http://www.netmagazine.com/tutorials/get-started-webgl-draw-square </div><div class="t m0 x0 hb y335c ffb8 fs6 fc0 sc0 ls21 wsb">uniform vec4 uColor; </div><div class="t m0 x0 hb y335d ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y335e ffb8 fs6 fc0 sc0 ls21 wsb">void main() {  </div><div class="t m0 x0 hb y335f ffb8 fs6 fc0 sc0 ls21 wsb">        gl_FragColor = uColor; </div><div class="t m0 x0 hb y3360 ffb8 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y3361 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y3362 ffbc fs2 fc0 sc0 ls79 wsb">WebGLExample02.htm </div><div class="t m0 x0 h4 y3363 ffb7 fs2 fc0 sc0 ls8 wseb">片段着色器必须返回一个值，赋给变量gl_FragColor，表示绘图时使用的颜色。这个着色器定义</div><div class="t m0 x0 h4 y3364 ffb7 fs2 fc0 sc0 ls8 wseb">了一个包含四方面信息（vec4）的统一的颜色uColor。从以上代码看，这个着色器除了把传入的值赋</div><div class="t m0 x0 hc y3365 ffb7 fs2 fc0 sc0 ls2ca">给gl_FragColor什么也没做。uColor的值在这个着色器内部不能改变。 </div><div class="t m0 x5 h5 y3366 ffb0 fs2 fc0 sc0 lsd ws8">OpenGL着色语言比这里看到的还要复杂。专门讲解这门语言的书有很多，本节</div><div class="t m0 x0 h5 y3367 ffb1 fs2 fc0 sc0 ls8 ws14">只是从辅助使用WebGL的角度简要介绍一下该语言。要了解更多信息，请参考Randi </div><div class="t m0 x0 h5 y3368 ffb0 fs2 fc0 sc0 ls201 ws351">J. Rost编著的OpenGL Shading Language（Addison-Wesley,2006）。 </div></div></div>
<div id="pf1eb" class="pf w0 h0" data-page-no="1eb"><div class="pc pc1eb w0 h0"><div class="t m0 x2 h2 y1db2 ffb0 fs0 fc0 sc0 ls7 ws0">15.3 WebGL  473 </div><div class="t m0 x0 h3 y2 ffb0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffb2 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ffb2 fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ffb2 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffb2 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffb2 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffb2 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffb2 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffb2 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffb2 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffb2 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffb2 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ffb2 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ffb2 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h3c y68b ffb5 fs2 fc0 sc0 ls2e wsb">9. 编写着色器程序 </div><div class="t m0 x0 h5 y68c ffb7 fs2 fc0 sc0 ls8 wseb">浏览器不能理解GLSL程序，因此必须准备好字符串形式的GLSL程序，以便编译并链接到着色器</div><div class="t m0 x0 h4 y15dc ffb7 fs2 fc0 sc0 ls8 wseb">程序。为便于使用，通常是把着色器包含在页面的&lt;script&gt;标签内，并为该标签指定一个自定义的type</div><div class="t m0 x0 h4 y1ed1 ffb7 fs2 fc0 sc0 ls8 wseb">属性。由于无法识别type属性值，浏览器不会解析&lt;script&gt;标签中的内容，但这不影响你读写其中</div><div class="t m0 x0 h5 y6e4 ffb7 fs2 fc0 sc0 ls8 wseb">的代码。例如： </div><div class="t m0 x0 hb y6e5 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y6e6 ffb8 fs6 fc0 sc0 ls21 wsb">&lt;script type=&quot;x-webgl/x-vertex-shader&quot; id=&quot;vertexShader&quot;&gt; </div><div class="t m0 x0 hb y6e7 ffb8 fs6 fc0 sc0 ls21 wsb">attribute vec2 aVertexPosition; </div><div class="t m0 x0 hb y6e8 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y286f ffb8 fs6 fc0 sc0 ls21 wsb">void main() {  </div><div class="t m0 x0 hb y2870 ffb8 fs6 fc0 sc0 ls21 wsb">        gl_Position = vec4(aVertexPosition, 0.0, 1.0); </div><div class="t m0 x0 hb y3369 ffb8 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y336a ffb8 fs6 fc0 sc0 ls21 wsb">&lt;/script&gt; </div><div class="t m0 x0 hb y336b ffb8 fs6 fc0 sc0 ls21 wsb">&lt;script type=&quot;x-webgl/x-fragment-shader&quot; id=&quot;fragmentShader&quot;&gt; </div><div class="t m0 x0 hb y336c ffb8 fs6 fc0 sc0 ls21 wsb">uniform vec4 uColor; </div><div class="t m0 x0 hb y336d ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y336e ffb8 fs6 fc0 sc0 ls21 wsb">void main() { </div><div class="t m0 x0 hb y336f ffb8 fs6 fc0 sc0 ls21 wsb">        gl_FragColor = uColor; </div><div class="t m0 x0 hb y3370 ffb8 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y3371 ffb8 fs6 fc0 sc0 ls21 wsb">&lt;/script&gt; </div><div class="t m0 x0 hb y3372 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y3373 ffbc fs2 fc0 sc0 ls79 wsb">WebGLExample02.htm </div><div class="t m0 x0 h5 y3374 ffb7 fs2 fc0 sc0 ls8 wseb">然后，可以通过text属性提取出&lt;script&gt;元素的内容： </div><div class="t m0 x0 hb y3375 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3376 ffb8 fs6 fc0 sc0 ls21 wsb">var vertexGlsl = document.getElementById(&quot;vertexShader&quot;).text,  </div><div class="t m0 x0 hb y3377 ffb8 fs6 fc0 sc0 ls21 wsb">    fragmentGlsl = document.getElementById(&quot;fragmentShader&quot;).text; </div><div class="t m0 x0 hb y3378 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y4b6 ffb7 fs2 fc0 sc0 ls8 wseb">复杂一些的WebGL应用可能会通过Ajax（详见第21章）动态加载着色器。而使用着色器的关键是</div><div class="t m0 x0 h5 y2cec ffb7 fs2 fc0 sc0 ls8 wseb">要有字符串形式的GLSL程序。 </div><div class="t m0 x0 h5 y2ced ffb7 fs2 fc0 sc0 ls8 wseb">取得了GLSL字符串之后，接下来就是创建着色器对象。要创建着色器对象，可以调用gl.create- </div><div class="t m0 x0 h42 y3379 ffb8 fs1 fc0 sc0 ls20 ws16">Shader()方法并传入要创建的着色器类型（gl.VERTEX_SHADER或gl.FRAGMENT_SHADER）。编译着色</div><div class="t m0 x0 hc y2cef ffb7 fs2 fc0 sc0 ls8 wseb">器使用的是gl.compileShader()。请看下面的例子。 </div><div class="t m0 x0 hb y2cf0 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2cf1 ffb8 fs6 fc0 sc0 ls21 wsb">var vertexShader = gl.createShader(gl.VERTEX_SHADER); </div><div class="t m0 x0 hb y2cf2 ffb8 fs6 fc0 sc0 ls21 wsb">gl.shaderSource(vertexShader, vertexGlsl); </div><div class="t m0 x0 hb y2cf3 ffb8 fs6 fc0 sc0 ls21 wsb">gl.compileShader(vertexShader); </div><div class="t m0 x0 hb y337a ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y337b ffb8 fs6 fc0 sc0 ls21 wsb">var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER); </div><div class="t m0 x0 hb y337c ffb8 fs6 fc0 sc0 ls21 wsb">gl.shaderSource(fragmentShader, fragmentGlsl); </div><div class="t m0 x0 hb y337d ffb8 fs6 fc0 sc0 ls21 wsb">gl.compileShader(fragmentShader); </div><div class="t m0 x0 hb y337e ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y2be6 ffbc fs2 fc0 sc0 ls79 wsb">WebGLExample02.htm </div><div class="t m0 x0 h4 y919 ffb7 fs2 fc0 sc0 ls8 wseb">以上代码创建了两个着色器，并将它们分别保存在vertexShader和fragmentShader中。而使</div><div class="t m0 x0 h5 y91a ffb7 fs2 fc0 sc0 ls8 wseb">用下列代码，可以把这两个对象链接到着色器程序中。 </div><div class="t m0 x0 hb y337f ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3380 ffb8 fs6 fc0 sc0 ls21 wsb">var program = gl.createProgram(); </div><div class="t m0 x0 hb y3381 ffb8 fs6 fc0 sc0 ls21 wsb">gl.attachShader(program, vertexShader); </div><div class="t m0 x0 hb y3382 ffb8 fs6 fc0 sc0 ls21 wsb">gl.attachShader(program, fragmentShader); </div><div class="t m0 x0 hb y3383 ffb8 fs6 fc0 sc0 ls21 wsb">gl.linkProgram(program); </div><div class="t m0 x0 hb y3384 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y3385 ffbc fs2 fc0 sc0 ls79 wsb">WebGLExample02.htm </div></div></div>
<div id="pf1ec" class="pf w0 h0" data-page-no="1ec"><div class="pc pc1ec w0 h0"><div class="t m0 x0 h2 y1 ffb0 fs0 fc0 sc0 ls7 ws0">474  第15章 使用Canvas绘图 </div><div class="t m0 x0 h3 y2 ffb0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ffb7 fs2 fc0 sc0 ls8 wseb">第一行代码创建了程序，然后调用attachShader()方法又包含了两个着色器。最后调用gl.link- </div><div class="t m0 x0 h42 ye26 ffb8 fs1 fc0 sc0 ls9 ws2">Program()则把两个着色器封装到了变量program中。链接完程序之后，就可以通过gl.useProgram()</div><div class="t m0 x0 h5 y4e ffb7 fs2 fc0 sc0 ls8 wseb">方法通知WebGL使用这个程序了。 </div><div class="t m0 x0 hb y6bd ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y6be ffb8 fs6 fc0 sc0 ls21 wsb">gl.useProgram(program); </div><div class="t m0 x0 hb y153b ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y6e5 ffb7 fs2 fc0 sc0 ls8 wseb">调用gl.useProgram()方法后，所有后续的绘图操作都将使用这个程序。 </div><div class="t m0 x0 h3c y3387 ffb5 fs2 fc0 sc0 ls2e wsb">10. 为着色器传入值 </div><div class="t m0 x0 h4 y3388 ffb7 fs2 fc0 sc0 ls8 wseb">前面定义的着色器都必须接收一个值才能工作。为了给着色器传入这个值，必须先找到要接收这个</div><div class="t m0 x0 h5 y3389 ffb7 fs2 fc0 sc0 ls8 wseb">值的变量。对于Uniform变量，可以使用gl.getUniformLocation()，这个方法返回一个对象，表示</div><div class="t m0 x0 h5 y338a ffb0 fs2 fc0 sc0 ls79 ws6c">Uniform变量在内存中的位置。然后可以基于变量的位置来赋值。例如： </div><div class="t m0 x0 hb y338b ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y338c ffb8 fs6 fc0 sc0 ls21 wsb">var uColor = gl.getUniformLocation(program, &quot;uColor&quot;); </div><div class="t m0 x0 hb y338d ffb8 fs6 fc0 sc0 ls21 wsb">gl.uniform4fv(uColor, [0, 0, 0, 1]); </div><div class="t m0 x2 hf y208a ffbc fs2 fc0 sc0 ls79 wsb">WebGLExample02.htm </div><div class="t m0 x0 h5 y338e ffb7 fs2 fc0 sc0 ls8 wseb">第一行代码从program中找到Uniform变量uColor，返回了它在内存中的位置。第二行代码使用</div><div class="t m0 x0 h5 y27fd ffb8 fs1 fc0 sc0 ls9 ws2">gl.uniform4fv()给uColor赋值。 </div><div class="t m0 x0 h5 y338f ffb7 fs2 fc0 sc0 ls8 wseb">对于顶点着色器中的Attribute变量，也是差不多的赋值过程。要找到Attribute变量在内存中的位置，</div><div class="t m0 x0 he y3390 ffb7 fs2 fc0 sc0 ls8 wseb">可以调用gl.getAttribLocation()。取得了位置之后，就可以像下面这样赋值了： </div><div class="t m0 x0 hb y3391 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3392 ffb8 fs6 fc0 sc0 ls21 wsb">var aVertexPosition = gl.getAttribLocation(program, &quot;aVertexPosition&quot;); </div><div class="t m0 x0 hb y3393 ffb8 fs6 fc0 sc0 ls21 wsb">gl.enableVertexAttribArray(aVertexPosition); </div><div class="t m0 x0 hb y3394 ffb8 fs6 fc0 sc0 ls21 wsb">gl.vertexAttribPointer(aVertexPosition, itemSize, gl.FLOAT, false, 0, 0); </div><div class="t m0 x0 hb y3395 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y6f8 ffbc fs2 fc0 sc0 ls79 wsb">WebGLExample02.htm </div><div class="t m0 x0 h4 y2c01 ffb7 fs2 fc0 sc0 ls8 wseb">在此，我们取得了aVertexPosition的位置，然后又通过 gl.enableVertexAttribArray()</div><div class="t m0 x0 h4 y3396 ffb7 fs2 fc0 sc0 ls3ec ws352">启用它。最后一行创建了指针，指向由gl.bindBuffer()指定的缓冲区，并将其保存在</div><div class="t m0 x0 h5 y20fa ffb8 fs1 fc0 sc0 ls9 ws2">aVertexPosition中，以便顶点着色器使用。 </div><div class="t m0 x0 h3c y3397 ffb5 fs2 fc0 sc0 ls2e wsb">11. 调试着色器和程序 </div><div class="t m0 x0 h5 y3398 ffb7 fs2 fc0 sc0 lsdc">与WebGL中的其他操作一样，着色器操作也可能会失败，而且也是静默失败。如果你想知道着色</div><div class="t m0 x0 h5 y3399 ffb7 fs2 fc0 sc0 ls8 wseb">器或程序执行中是否发生了错误，必须亲自询问WebGL上下文。 </div><div class="t m0 x0 hdf y339a ffb7 fs2 fc0 sc0 ls8 wseb">对于着色器，可以在操作之后调用gl.getShaderParameter()，取得着色器的编译状态： </div><div class="t m0 x0 hb y339b ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y339c ffb8 fs6 fc0 sc0 ls21 wsb">if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)){ </div><div class="t m0 x0 hb y339d ffb8 fs6 fc0 sc0 ls21 wsb">    alert(gl.getShaderInfoLog(vertexShader)); </div><div class="t m0 x0 hb y339e ffb8 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y339f ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1ac2 ffbc fs2 fc0 sc0 ls79 wsb">WebGLExample02.htm </div><div class="t m0 x0 h4 y33a0 ffb7 fs2 fc0 sc0 ls3ba ws34a">这个例子检测了vertexShader的编译状态。如果着色器编译成功，调用 gl.getShader- </div><div class="t m0 x0 h42 y33a1 ffb8 fs1 fc0 sc0 ls9 ws2">Parameter()会返回true。如果返回的是false，说明编译期间发生了错误，此时调用gl.getShader- </div><div class="t m0 x0 h4 y33a2 ffb8 fs1 fc0 sc0 ls9 ws2">InfoLog()并传入相应的着色器就可以取得错误消息。错误消息就是一个表示问题所在的字符串。无论</div><div class="t m0 x0 h1e y33a3 ffb7 fs2 fc0 sc0 ls8 wseb">是顶点着色器，还是片段着色器，都可以使用gl.getShaderParameter()和gl.getShaderInfoLog()</div><div class="t m0 x0 h5 y33a4 ffb7 fs2 fc0 sc0 ls8">方法。 </div></div></div>
<div id="pf1ed" class="pf w0 h0" data-page-no="1ed"><div class="pc pc1ed w0 h0"><div class="t m0 x2 h2 y1db2 ffb0 fs0 fc0 sc0 ls7 ws0">15.3 WebGL  475 </div><div class="t m0 x0 h3 y2 ffb0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffb2 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ffb2 fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ffb2 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffb2 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffb2 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffb2 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffb2 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffb2 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffb2 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffb2 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffb2 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ffb2 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ffb2 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ffb7 fs2 fc0 sc0 ls6 wsf7">程序也可能会执行失败，因此也有类似的方法——gl.getProgramParameter()，可以用来检测</div><div class="t m0 x0 h5 y4d ffb7 fs2 fc0 sc0 ls8 wseb">执行状态。最常见的程序失败发生在链接过程中，要检测链接错误，可以使用下列代码。 </div><div class="t m0 x0 hb y2d8 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2d9 ffb8 fs6 fc0 sc0 ls21 wsb">if (!gl.getProgramParameter(program, gl.LINK_STATUS)){  </div><div class="t m0 x0 hb y2da ffb8 fs6 fc0 sc0 ls21 wsb">    alert(gl.getProgramInfoLog(program)); </div><div class="t m0 x0 hb y2db ffb8 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y2320 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y7b1 ffbc fs2 fc0 sc0 ls79 wsb">WebGLExample02.htm </div><div class="t m0 x0 h4 y426 ffb7 fs2 fc0 sc0 ls2c">与gl.getShaderParameter()类似，gl.getProgramParameter()返回true表示链接成功，</div><div class="t m0 x0 h4 y33a5 ffb7 fs2 fc0 sc0 ls5 wsec">返回false表示链接失败。同样，也有一个gl.getProgramInfoLog()方法，用于捕获程序失败的</div><div class="t m0 x0 h5 y33a6 ffb7 fs2 fc0 sc0 ls5">消息。 </div><div class="t m0 x0 h4 y33a7 ffb7 fs2 fc0 sc0 ls8 wseb">以上介绍的这些方法主要在开发过程中用于调试。只要没有依赖外部代码，就可以放心地把它们从</div><div class="t m0 x0 h5 y33a8 ffb7 fs2 fc0 sc0 ls8 wseb">产品代码中删除。 </div><div class="t m0 x0 h3c y33a9 ffb5 fs2 fc0 sc0 ls2e wsb">12. 绘图 </div><div class="t m0 x0 h5 y33aa ffb0 fs2 fc0 sc0 ls138 ws133">WebGL只能绘制三种形状：点、线和三角。其他所有形状都是由这三种基本形状合成之后，再绘</div><div class="t m0 x0 hb2 y33ab ffb7 fs2 fc0 sc0 ls8 wseb">制到三维空间中的。执行绘图操作要调用gl.drawArrays()或gl.drawElements()方法，前者用于</div><div class="t m0 x0 h5 y33ac ffb7 fs2 fc0 sc0 ls8 wseb">数组缓冲区，后者用于元素数组缓冲区。 </div><div class="t m0 x0 h4 y2bfd ffb8 fs1 fc0 sc0 ls9 ws2">gl.drawArrays()或gl.drawElements()的第一个参数都是一个常量，表示要绘制的形状。可</div><div class="t m0 x0 h5 y33ad ffb7 fs2 fc0 sc0 ls8 wseb">取值的常量范围包括以下这些。 </div><div class="t m0 x0 h5 y2876 ffb6 fs1 fc0 sc0 ls2"> gl.POINTS：将每个顶点当成一个点来绘制。 </div><div class="t m0 x0 h4 y33ae ffb6 fs1 fc0 sc0 ls2"> gl.LINES：将数组当成一系列顶点，在这些顶点间画线。每个顶点既是起点也是终点，因此数</div><div class="t m0 x5 h5 y33af ffb7 fs2 fc0 sc0 ls8 wseb">组中必须包含偶数个顶点才能完成绘制。 </div><div class="t m0 x0 h4 y3147 ffb6 fs1 fc0 sc0 ls2"> gl.LINE_LOOP：将数组当成一系列顶点，在这些顶点间画线。线条从第一个顶点到第二个顶点，</div><div class="t m0 x5 h4 yef ffb7 fs2 fc0 sc0 ls5 wsec">再从第二个顶点到第三个顶点，依此类推，直至最后一个顶点。然后再从最后一个顶点到第一</div><div class="t m0 x5 h5 yf0 ffb7 fs2 fc0 sc0 ls8 wseb">个顶点画一条线。结果就是一个形状的轮廓。 </div><div class="t m0 x0 h4 y33b0 ffb6 fs1 fc0 sc0 ls2"> gl.LINE_STRIP：除了不画最后一个顶点与第一个顶点之间的线之外，其他与gl.LINE_LOOP</div><div class="t m0 x5 h5 y33b1 ffb7 fs2 fc0 sc0 ls8">相同。 </div><div class="t m0 x0 h4 y33b2 ffb6 fs1 fc0 sc0 ls2"> gl.TRIANGLES：将数组当成一系列顶点，在这些顶点间绘制三角形。除非明确指定，每个三角</div><div class="t m0 x5 h5 y33b3 ffb7 fs2 fc0 sc0 ls8 wseb">形都单独绘制，不与其他三角形共享顶点。 </div><div class="t m0 x0 h4 y33b4 ffb6 fs1 fc0 sc0 ls2"> gl.TRIANGLES_STRIP：除了将前三个顶点之后的顶点当作第三个顶点与前两个顶点共同构成</div><div class="t m0 x5 hc y33b5 ffb7 fs2 fc0 sc0 ls8 wseb">一个新三角形外，其他都与gl.TRIANGLES相同。例如，如果数组中包含A、B、C、D四个顶</div><div class="t m0 x5 h5 yd8a ffb7 fs2 fc0 sc0 ls8 wseb">点，则第一个三角形连接ABC，而第二个三角形连接BCD。 </div><div class="t m0 x0 h4 y33b6 ffb6 fs1 fc0 sc0 ls2"> gl. TRIANGLES_FAN：除了将前三个顶点之后的顶点当作第三个顶点与前一个顶点及第一个顶</div><div class="t m0 x5 hc y1504 ffb7 fs2 fc0 sc0 ls8 wseb">点共同构成一个新三角形外，其他都与gl.TRIANGLES相同。例如，如果数组中包含A、B、C、</div><div class="t m0 x5 h5 y33b7 ffb0 fs2 fc0 sc0 lsdd">D四个顶点，则第一个三角形连接ABC，而第二个三角形连接ACD。 </div><div class="t m0 x0 h4 y2dc5 ffb8 fs1 fc0 sc0 ls9 ws2">gl.drawArrays()方法接收上面列出的常量中的一个作为第一个参数，接收数组缓冲区中的起始</div><div class="t m0 x0 h4 y1a64 ffb7 fs2 fc0 sc0 ls8 wseb">索引作为第二个参数，接收数组缓冲区中包含的顶点数（点的集合数）作为第三个参数。下面的代码使</div><div class="t m0 x0 hc y33b8 ffb7 fs2 fc0 sc0 ls3ed">用gl.drawArrays()在画布上绘制了一个三角形。 </div><div class="t m0 x0 hb y33b9 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y33ba ffb8 fs6 fc0 sc0 ls21">//假设已经使用本节前面定义的着色器清除了视口 </div><div class="t m0 x0 hb y33bb ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y33bc ffb8 fs6 fc0 sc0 ls21">//定义三个顶点以及每个顶点的x和y坐标 </div></div></div>
<div id="pf1ee" class="pf w0 h0" data-page-no="1ee"><div class="pc pc1ee w0 h0"><div class="t m0 x0 h2 y1 ffb0 fs0 fc0 sc0 ls7 ws0">476  第15章 使用Canvas绘图 </div><div class="t m0 x0 h3 y2 ffb0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 ffb8 fs6 fc0 sc0 ls21 wsb">var vertices = new Float32Array([ 0, 1, 1, -1, -1, -1 ]), </div><div class="t m0 x0 hb y7a ffb8 fs6 fc0 sc0 ls21 wsb">    buffer = gl.createBuffer(), </div><div class="t m0 x0 hb y7b ffb8 fs6 fc0 sc0 ls21 wsb">    vertexSetSize = 2, </div><div class="t m0 x0 hb y7c ffb8 fs6 fc0 sc0 ls21 wsb">    vertexSetCount = vertices.length/vertexSetSize, </div><div class="t m0 x0 hb y7d ffb8 fs6 fc0 sc0 ls21 wsb">    uColor, aVertexPosition; </div><div class="t m0 x0 hb y7e ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y7f ffb8 fs6 fc0 sc0 ls21">//把数据放到缓冲区 </div><div class="t m0 x0 hb y80 ffb8 fs6 fc0 sc0 ls21 wsb">gl.bindBuffer(gl.ARRAY_BUFFER, buffer); </div><div class="t m0 x0 hb y81 ffb8 fs6 fc0 sc0 ls21 wsb">gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW); </div><div class="t m0 x0 hb y82 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y83 ffb8 fs6 fc0 sc0 ls21">//为片段着色器传入颜色值 </div><div class="t m0 x0 hb y84 ffb8 fs6 fc0 sc0 ls21 wsb">uColor = gl.getUniformLocation(program, &quot;uColor&quot;); </div><div class="t m0 x0 hb y85 ffb8 fs6 fc0 sc0 ls21 wsb">gl.uniform4fv(uColor, [ 0, 0, 0, 1 ]); </div><div class="t m0 x0 hb y86 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y87 ffb8 fs6 fc0 sc0 ls21">//为着色器传入顶点信息 </div><div class="t m0 x0 hb y88 ffb8 fs6 fc0 sc0 ls21 wsb">aVertexPosition = gl.getAttribLocation(program, &quot;aVertexPosition&quot;); </div><div class="t m0 x0 hb y89 ffb8 fs6 fc0 sc0 ls21 wsb">gl.enableVertexAttribArray(aVertexPosition); </div><div class="t m0 x0 hb y8a ffb8 fs6 fc0 sc0 ls21 wsb">gl.vertexAttribPointer(aVertexPosition, vertexSetSize, gl.FLOAT, false, 0, 0); </div><div class="t m0 x0 hb y1823 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y1824 ffb8 fs6 fc0 sc0 ls21">//绘制三角形 </div><div class="t m0 x0 hb y1825 ffb8 fs6 fc0 sc0 ls21 wsb">gl.drawArrays(gl.TRIANGLES, 0, vertexSetCount); </div><div class="t m0 x0 hb y33be ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y2495 ffbc fs2 fc0 sc0 ls79 wsb">WebGLExample02.htm </div><div class="t m0 x0 h4 y33bf ffb7 fs2 fc0 sc0 ls8 wseb">这个例子定义了一个Float32Array，包含三组顶点（每个顶点由两点表示）。这里关键是要知道</div><div class="t m0 x0 hc y33c0 ffb7 fs2 fc0 sc0 lsed ws221">顶点的大小及数量，以便将来计算时使用。把vertexSetSize设置为 2之后，就可以计算出</div><div class="t m0 x0 h5 y316a ffb8 fs1 fc0 sc0 ls9 ws2">vertexSetCount的值。把顶点的信息保存在缓冲区中后，又把颜色信息传给了片段着色器。 </div><div class="t m0 x0 h4 y3079 ffb7 fs2 fc0 sc0 ls8 wseb">接下来，给顶点着色器传入顶点大小以及gl.FLOAT，后者表示顶点坐标是浮点数。传入的第四个</div><div class="t m0 x0 hc y33c1 ffb7 fs2 fc0 sc0 ls8 wseb">参数是一个布尔值，false在此表示坐标不是标准化的。第五个参数是步长值（stride value），表示取</div><div class="t m0 x0 h5 y307b ffb7 fs2 fc0 sc0 ls8 wseb">得下一个值的时候，要跳过多少个数组元素。除非你真需要跳过数组元素，否则传入0即可。最后一个</div><div class="t m0 x0 h5 y33c2 ffb7 fs2 fc0 sc0 ls8 wseb">参数是起点偏移量，值为0表示从第一个元素开始。 </div><div class="t m0 x0 h1c y33c3 ffb7 fs2 fc0 sc0 ls8 wseb">最后一步就是使用gl.drawArrays()绘制三角形。传入gl.TRIANGLES作为第一个参数，表示在</div><div class="t m0 x0 h25 y33c4 ffb0 fs2 fc0 sc0 ls46 ws37">(0,1)、(1,1)和(1,1)点之间绘制三角形，并使用传给片段着色器的颜色来填充它。第二个参数是缓冲</div><div class="t m0 x0 h5 y33c5 ffb7 fs2 fc0 sc0 ls8 wseb">区中的起点偏移量，最后一个参数是要读取的顶点总数。这次绘图操作的结果如图15-17所示。 </div><div class="t m0 x2 h5 y33c6 ffb0 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x7 h3 y33c7 ffb7 fs1 fc0 sc0 ls8 wsb">图 15-17 </div></div></div>
<div id="pf1ef" class="pf w0 h0" data-page-no="1ef"><div class="pc pc1ef w0 h0"><div class="t m0 x2 h2 y1db2 ffb0 fs0 fc0 sc0 ls7 ws0">15.3 WebGL  477 </div><div class="t m0 x0 h3 y2 ffb0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffb2 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ffb2 fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ffb2 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffb2 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffb2 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffb2 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffb2 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffb2 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffb2 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffb2 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffb2 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ffb2 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ffb2 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ffb7 fs2 fc0 sc0 ls8 wseb">通过修改gl.drawArrays()的第一个参数，可以修改绘制三角形的方式。图15-18展示了传入不</div><div class="t m0 x0 h5 y4d ffb7 fs2 fc0 sc0 ls8 wseb">同的参数后可能得到的结果。 </div><div class="t m0 x2 h5 y33c8 ffb0 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 h3 y33c9 ffb7 fs1 fc0 sc0 ls8 wsb">图 15-18 </div><div class="t m0 x0 h3c y33ca ffb5 fs2 fc0 sc0 ls2e wsb">13. 纹理 </div><div class="t m0 x0 h5 y33cb ffb0 fs2 fc0 sc0 ls138 ws133">WebGL的纹理可以使用DOM中的图像。要创建一个新纹理，可以调用gl.createTexture()，</div><div class="t m0 x0 h1e y33cc ffb7 fs2 fc0 sc0 ls8 wseb">然后再将一幅图像绑定到该纹理。如果图像尚未加载到内存中，可能需要创建一个Image对象的实例，</div><div class="t m0 x0 h4 y33cd ffb7 fs2 fc0 sc0 ls8 wseb">以便动态加载图像。图像加载完成之前，纹理不会初始化，因此，必须在load事件触发后才能设置纹</div><div class="t m0 x0 h5 y33ce ffb7 fs2 fc0 sc0 ls8 wseb">理。例如： </div><div class="t m0 x0 hb y8d ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y33cf ffb8 fs6 fc0 sc0 ls21 wsb">var image = new Image(), </div><div class="t m0 x0 hb y33d0 ffb8 fs6 fc0 sc0 ls21 wsb">    texture; </div><div class="t m0 x0 hb y33d1 ffb8 fs6 fc0 sc0 ls21 wsb">image.src = &quot;smile.gif&quot;; </div><div class="t m0 x0 hb y33d2 ffb8 fs6 fc0 sc0 ls21 wsb">image.onload = function(){ </div><div class="t m0 x0 hb y33d3 ffb8 fs6 fc0 sc0 ls21 wsb">    texture = gl.createTexture(); </div><div class="t m0 x0 hb y33d4 ffb8 fs6 fc0 sc0 ls21 wsb">    gl.bindTexture(gl.TEXTURE_2D, texture); </div><div class="t m0 x0 hb y33d5 ffb8 fs6 fc0 sc0 ls21 wsb">    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true); </div><div class="t m0 x0 hb y33d6 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y33d7 ffb8 fs6 fc0 sc0 ls21 wsb">    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image); </div><div class="t m0 x0 hb y33d8 ffb8 fs6 fc0 sc0 ls21 wsb">    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST); </div><div class="t m0 x0 hb y33d9 ffb8 fs6 fc0 sc0 ls21 wsb">    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST); </div><div class="t m0 x0 hb y33da ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y33db ffb8 fs6 fc0 sc0 ls21 wsb">    //清除当前纹理 </div><div class="t m0 x0 hb y33dc ffb8 fs6 fc0 sc0 ls21 wsb">    gl.bindTexture(gl.TEXTURE_2D, null); </div><div class="t m0 x0 hb y33dd ffb8 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y33de ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1b6a ffb7 fs2 fc0 sc0 ls8 wseb">除了使用DOM中的图像之外，以上步骤与在OpenGL中创建纹理的步骤相同。最大的差异是使用</div><div class="t m0 x0 h5 y33df ffb8 fs1 fc0 sc0 ls9 ws2">gl.pixelStore1()设置像素存储格式。gl.UNPACK_FLIP_Y_WEBGL是WebGL独有的常量，在加载</div><div class="t m0 x0 h5 y23c7 ffb0 fs2 fc0 sc0 lsfd wscc">Web中的图像时，多数情况下都必须使用这个常量。这主要是因为GIF、JPEG和PNG 图像与WebGL</div><div class="t m0 x0 h5 y33e0 ffb7 fs2 fc0 sc0 ls8 wseb">使用的坐标系不一样，如果没有这个标志，解析图像时就会发生混乱。 </div><div class="t m0 x0 h5 y33e1 ffb7 fs2 fc0 sc0 ls8 wseb">用作纹理的图像必须与包含页面来自同一个域，或者是保存在启用了CORS（Cross-Origin Resource </div><div class="t m0 x0 h5 y33e2 ffb0 fs2 fc0 sc0 ls7a ws89">Sharing，跨域资源共享）的服务器上。第21章将讨论CORS。 </div><div class="t m0 x5 h113 y33e3 ffb1 fs2 fc0 sc0 ls8 ws14">图像、加载到&lt;video&gt;元素中的视频，甚至其他&lt;canvas&gt;元素都可以用作纹理。</div><div class="t m0 x5 h5 y33e4 ffb1 fs2 fc0 sc0 ls8 ws14">跨域资源限制同样适用于视频。 </div><div class="t m0 x0 h3c y33e5 ffb5 fs2 fc0 sc0 ls2e wsb">14. 读取像素 </div><div class="t m0 x0 h5 y33e6 ffb7 fs2 fc0 sc0 ls3ee">与2D上下文 类似，通过WebGL上下文也能读取像素值。读取像素值的方法 readPixels()与</div><div class="t m0 x0 h5 yb1a ffb0 fs2 fc0 sc0 lsd ws8">OpenGL中的同名方法只有一点不同，即最后一个参数必须是类型化数组。像素信息是从帧缓冲区读取</div><div class="t m0 x1 hb y33e7 ffb8 fs6 fc0 sc0 ls21">gl.LINE_LOOP</div><div class="c x7 y33e8 w1c h114"><div class="t m0 x0 h28 y33e9 ffb8 fs1 fc0 sc0 ls8 wsb"> </div></div><div class="t m0 x4 hb y2bce ffb8 fs6 fc0 sc0 ls21">gl.LINE_SET</div><div class="c x2 y33ea w1c h114"><div class="t m0 x0 h28 y33e9 ffb8 fs1 fc0 sc0 ls8 wsb"> </div></div></div></div>
<div id="pf1f0" class="pf w0 h0" data-page-no="1f0"><div class="pc pc1f0 w0 h0"><div class="t m0 x0 h2 y1 ffb0 fs0 fc0 sc0 ls7 ws0">478  第15章 使用Canvas绘图 </div><div class="t m0 x0 h3 y2 ffb0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ffb7 fs2 fc0 sc0 ls8 wseb">的，然后保存在类型化数组中。readPixels()方法的参数有：x、y、宽度、高度、图像格式、数据类</div><div class="t m0 x0 h5 y4d ffb7 fs2 fc0 sc0 ls8 wseb">型和类型化数组。前4个参数指定读取哪个区域中的像素。图像格式参数几乎总是gl.RGBA。数据类型</div><div class="t m0 x0 h5 y5 ffb7 fs2 fc0 sc0 ls8 wseb">参数用于指定保存在类型化数组中的数据的类型，但有以下限制。 </div><div class="t m0 x0 h5 yd9 ffb6 fs1 fc0 sc0 ls2"> 如果类型是gl.UNSIGNED_BYTE，则类型化数组必须是Uint8Array。 </div><div class="t m0 x0 h4 y219 ffb6 fs1 fc0 sc0 ls2"> 如果类型是gl.UNSIGNED_SHORT_5_6_5、gl.UNSIGNED_SHORT_4_4_4_4或gl.UNSIGNED_ </div><div class="t m0 x0 h21 y262b ffb8 fs1 fc0 sc0 ls9 ws2">SHORT_5_5_5_1，则类型化数组必须是Uint16Array。 </div><div class="t m0 x0 h5 y15e ffb7 fs2 fc0 sc0 ls8 wseb">下面是一个简单的例子。 </div><div class="t m0 x0 hb ycf5 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ycf6 ffb8 fs6 fc0 sc0 ls21 wsb">var pixels = new Uint8Array(25*25); </div><div class="t m0 x0 hb ycf7 ffb8 fs6 fc0 sc0 ls21 wsb">gl.readPixels(0, 0, 25, 25, gl.RGBA, gl.UNSIGNED_BYTE, pixels); </div><div class="t m0 x0 hb y33eb ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 yee8 ffb7 fs2 fc0 sc0 ls8 wseb">以上代码从帧缓冲区中读取了25×25像素的区域，将读取到的像素信息保存到了pixels数组中。</div><div class="t m0 x0 h5 yee9 ffb7 fs2 fc0 sc0 ls8 wseb">其中，每个像素的颜色由4个数组元素表示，分别代表红、绿、蓝和透明度。每个数组元素的值介于0</div><div class="t m0 x0 h5 y33ec ffb7 fs2 fc0 sc0 ls3b">到255之间（包含0和255）。不要忘了根据返回的数据大小初始化类型化数组。 </div><div class="t m0 x0 h5 y33ed ffb7 fs2 fc0 sc0 ls8 wseb">在浏览器绘制更新的WebGL图像之前调用readPixels()不会有什么意外。绘制发生后，帧缓冲</div><div class="t m0 x0 h1e y1567 ffb7 fs2 fc0 sc0 ls8 wseb">区会恢复其原始的干净状态，而调用readPixels()返回的像素数据反映的就是清除缓冲区后的状态。</div><div class="t m0 x0 h5 y33ee ffb7 fs2 fc0 sc0 ls38b ws2ff">如果你想在绘制发生后读取像素数据，那在初始化WebGL上下文时必须传入适当的</div><div class="t m0 x0 h5 ybec ffb8 fs1 fc0 sc0 ls9 ws2">preserveDrawingBuffer选项（前面讨论过）。 </div><div class="t m0 x0 hb y33ef ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y33f0 ffb8 fs6 fc0 sc0 ls21 wsb">var gl = drawing.getContext(&quot;experimental-webgl&quot;, { preserveDrawingBuffer: true; }); </div><div class="t m0 x0 hb y33f1 ffb8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y33f2 ffb7 fs2 fc0 sc0 ls8 wseb">设置这个标志的意思是让帧缓冲区在下一次绘制之前，保留其最后的状态。这个选项会导致性能损</div><div class="t m0 x0 h5 y33f3 ffb7 fs2 fc0 sc0 ls8 wseb">失，因此能不用最好不要用。 </div><div class="t m0 x0 h20 y33f4 ffb5 fs3 fc0 sc0 ls248 ws214">15.3.3 支持 </div><div class="t m0 x0 h5 y33f5 ffb0 fs2 fc0 sc0 ls7a ws5b">Firefox 4+和Chrome都实现了WebGL API。Safari 5.1也实现了WebGL，但默认是禁用的。WebGL</div><div class="t m0 x0 h4 y33f6 ffb7 fs2 fc0 sc0 ls8 wseb">比较特别的地方在于，某个浏览器的某个版本实现了它，并不一定意味着就真能使用它。某个浏览器支</div><div class="t m0 x0 h5 y33f7 ffb7 fs2 fc0 sc0 ls3b">持WebGL，至少意味着两件事：首先，浏览器本身必须实现了WebGL API；其次，计算机必须升级显</div><div class="t m0 x0 h5 y33f8 ffb7 fs2 fc0 sc0 ls8 wseb">示驱动程序。运行Windows XP等操作系统的一些老机器，其驱动程序一般都不是最新的。因此，这些</div><div class="t m0 x0 h5 y33f9 ffb7 fs2 fc0 sc0 ls8 wseb">计算机中的浏览器都会禁用WebGL。从稳妥的角度考虑，在使用WebGL之前，最好检测其是否得到了</div><div class="t m0 x0 h5 y33fa ffb7 fs2 fc0 sc0 ls8 wseb">支持，而不是只检测特定的浏览器版本。 </div><div class="t m0 x0 h5 y33fb ffb7 fs2 fc0 sc0 ls6 wsf7">大家别忘了，WebGL还是一个正在制定和发展中的规范。不管是函数名、函数签名，还是数据类</div><div class="t m0 x0 h5 y33fc ffb7 fs2 fc0 sc0 ls8 wseb">型，都有可能改变。可以说，WebGL目前只适合实验性地学习，不适合真正开发和应用。 </div><div class="t m0 x0 hd y2234 ffb5 fs7 fc0 sc0 ls245">15.4 小结 </div><div class="t m0 x0 h5 y75c ffb0 fs2 fc0 sc0 ls17e ws13f">HTML5的&lt;canvas&gt;元素提供了一组JavaScript API，让我们可以动态地创建图形和图像。图形是在一</div><div class="t m0 x0 h5 y2ac4 ffb7 fs2 fc0 sc0 ls1f ws108">个特定的上下文中创建的，而上下文对象目前有两种。第一种是2D上下文，可以执行原始的绘图操作，</div><div class="t m0 x0 h5 y33fd ffb7 fs2 fc0 sc0 ls1f">比如： </div><div class="t m0 x0 h5 y2ac6 ffb6 fs1 fc0 sc0 ls2"> 设置填充、描边颜色和模式 </div><div class="t m0 x0 h5 y2ac7 ffb6 fs1 fc0 sc0 ls2"> 绘制矩形 </div><div class="t m0 x0 h5 y8c5 ffb6 fs1 fc0 sc0 ls2"> 绘制路径 </div></div></div>
<div id="pf1f1" class="pf w0 h0" data-page-no="1f1"><div class="pc pc1f1 w0 h0"><div class="t m0 x2 h2 y1 ffb0 fs0 fc0 sc0 ls7 ws0">15.4 小结  479 </div><div class="t m0 x0 h3 y2 ffb0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffb2 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ffb2 fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ffb2 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffb2 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffb2 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffb2 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffb2 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffb2 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffb2 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffb2 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffb2 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ffb2 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ffb2 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ffb6 fs1 fc0 sc0 ls2"> 绘制文本 </div><div class="t m0 x0 h5 y4 ffb6 fs1 fc0 sc0 ls2"> 创建渐变和模式 </div><div class="t m0 x0 h5 y5 ffb7 fs2 fc0 sc0 ls8 wseb">第二种是3D上下文，即WebGL上下文。WebGL是从OpenGL ES 2.0移植到浏览器中的，而OpenGL </div><div class="t m0 x0 h5 y6 ffb0 fs2 fc0 sc0 ls13 ws27c">ES 2.0是游戏开发人员在创建计算机图形图像时经常使用的一种语言。WebGL支持比2D上下文更丰富</div><div class="t m0 x0 h5 y7 ffb7 fs2 fc0 sc0 ls8 wseb">和更强大的图形图像处理能力，比如： </div><div class="t m0 x0 h5 y8 ffb6 fs1 fc0 sc0 ls2"> 用GLSL（OpenGL Shading Language，OpenGL着色语言）编写的顶点和片段着色器 </div><div class="t m0 x0 h5 y9 ffb6 fs1 fc0 sc0 ls2"> 支持类型化数组，即能够将数组中的数据限定为某种特定的数值类型 </div><div class="t m0 x0 h5 ya ffb6 fs1 fc0 sc0 ls2"> 创建和操作纹理 </div><div class="t m0 x0 h4 yb ffb7 fs2 fc0 sc0 ls6 wsf7">目前，主流浏览器的较新版本大都已经支持&lt;canvas&gt;标签。同样地，这些版本的浏览器基本上也</div><div class="t m0 x0 h5 y78a ffb7 fs2 fc0 sc0 ls8 wseb">都支持2D上下文。但对于WebGL而言，目前还只有Firefox 4+和Chrome 支持它。 </div><div class="t m0 x0 h5 y33fe ffb0 fs2 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf1f2" class="pf w0 h0" data-page-no="1f2"><div class="pc pc1f2 w0 h0"><div class="t m0 x0 h2 y1 ffc1 fs0 fc0 sc0 ls7 ws0">480  第16章 HTML5脚本编程 </div><div class="t m0 x0 h3 y2 ffc1 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h9 y2a ffc3 fs5 fc0 sc0 ls12 wsb">HTML5脚本编程 </div><div class="t m0 x0 h3c y2b ffc4 fs2 fc0 sc0 ls8">本章内容 </div><div class="t m0 x0 h5 y2c ffc6 fs1 fc0 sc0 ls2"> 使用跨文档消息传递 </div><div class="t m0 x0 h5 y2d ffc6 fs1 fc0 sc0 ls2"> 拖放API </div><div class="t m0 x0 h5 y2e ffc6 fs1 fc0 sc0 ls2"> 音频与视频 </div><div class="t m0 x0 h5 y8d9 ffc1 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y8da ffc7 fs2 fc0 sc0 ls8 ws1">书前面讨论过，HTML5规范定义了很多新HTML标记。为了配合这些标记的变化，HTML5</div><div class="t m0 x0 h5 y8db ffc7 fs2 fc0 sc0 ls8 ws1">规范也用显著篇幅定义了很多JavaScript API。定义这些API的用意就是简化此前实现起来困</div><div class="t m0 x0 h5 y8dc ffc7 fs2 fc0 sc0 ls8 ws1">难重重的任务，最终简化创建动态Web界面的工作。 </div><div class="t m0 x0 hd y33ff ffc5 fs7 fc0 sc0 ls245">16.1 跨文档消息传递 </div><div class="t m0 x0 h5 y3400 ffc4 fs2 fc0 sc0 ls8 ws12">跨文档消息传送（cross-document messaging），有时候简称为XDM，指的是在来自不同域的页面间</div><div class="t m0 x0 h5 y1299 ffc7 fs2 fc0 sc0 ls8 ws1">传递消息。例如，www.wrox.com域中的页面与位于一个内嵌框架中的p2p.wrox.com域中的页面通信。</div><div class="t m0 x0 h5 y3401 ffc7 fs2 fc0 sc0 ls8e">在XDM机制出现之前，要稳妥地实现这种通信需要花很多工夫。XDM把这种机制规范化，让我们能</div><div class="t m0 x0 h5 y3402 ffc7 fs2 fc0 sc0 ls8 ws1">既稳妥又简单地实现跨文档通信。 </div><div class="t m0 x0 h14 y3403 ffc1 fs2 fc0 sc0 ls81 ws76">XDM的核心是postMessage()方法。在HTML5规范中，除了XDM 部分之外的其他部分也会提</div><div class="t m0 x0 h5 y3404 ffc7 fs2 fc0 sc0 ls8 ws1">到这个方法名，但都是为了同一个目的：向另一个地方传递数据。对于XDM而言，“另一个地方”指的</div><div class="t m0 x0 hc y3405 ffc7 fs2 fc0 sc0 ls8 ws1">是包含在当前页面中的&lt;iframe&gt;元素，或者由当前页面弹出的窗口。 </div><div class="t m0 x0 h4 y160e ffc8 fs1 fc0 sc0 ls9 ws2">postMessage()方法接收两个参数：一条消息和一个表示消息接收方来自哪个域的字符串。第二</div><div class="t m0 x0 h5 y3406 ffc7 fs2 fc0 sc0 ls8 ws1">个参数对保障安全通信非常重要，可以防止浏览器把消息发送到不安全的地方。来看下面的例子。 </div><div class="t m0 x0 hb y11a1 ffc8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y3407 ffc8 fs6 fc0 sc0 ls21">//注意：所有支持XDM的浏览器也支持iframe的contentWindow属性 </div><div class="t m0 x0 hb y3408 ffc8 fs6 fc0 sc0 ls21 wsb">var iframeWindow = document.getElementById(&quot;myframe&quot;).contentWindow; </div><div class="t m0 x0 hb y3409 ffc8 fs6 fc0 sc0 ls21 wsb">iframeWindow.postMessage(&quot;A secret&quot;, &quot;http://www.wrox.com&quot;); </div><div class="t m0 x0 hb y340a ffc8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y245e ffc7 fs2 fc0 sc0 ls6f ws54">最后一行代码尝试向内嵌框架中发送一条消息，并指定框架中的文档必须来源于&quot;http:// </div><div class="t m0 x0 h4 y245f ffc8 fs1 fc0 sc0 ls9 ws2">www.wrox.com&quot;域。如果来源匹配，消息会传递到内嵌框架中；否则，postMessage()什么也不做。</div><div class="t m0 x0 h1e y2460 ffc7 fs2 fc0 sc0 ls8 ws1">这一限制可以避免窗口中的位置在你不知情的情况下发生改变。如果传给postMessage()的第二个参</div><div class="t m0 x0 hc y2461 ffc7 fs2 fc0 sc0 ls8 ws1">数是&quot;*&quot;，则表示可以把消息发送给来自任何域的文档，但我们不推荐这样做。 </div><div class="t m0 x0 h5 y340b ffc7 fs2 fc0 sc0 ls8 ws1">接收到XDM消息时，会触发window对象的message 事件。这个事件是以异步形式触发的，因此</div><div class="t m0 x0 h4 y28c9 ffc7 fs2 fc0 sc0 ls8 ws1">从发送消息到接收消息（触发接收窗口的message事件）可能要经过一段时间的延迟。触发message</div><div class="t m0 x0 h5 y340c ffc7 fs2 fc0 sc0 ls8 ws1">事件后，传递给onmessage处理程序的事件对象包含以下三方面的重要信息。 </div><div class="t m0 x0 h5 y340d ffc6 fs1 fc0 sc0 ls2"> data：作为postMessage()第一个参数传入的字符串数据。 </div><div class="t m0 x0 h5 y340e ffc6 fs1 fc0 sc0 ls2"> origin：发送消息的文档所在的域，例如&quot;http://www.wrox.com&quot;。 </div><div class="t m0 x0 h92 y8f4 ffc4 fs12 fc0 sc0 ls8 wsb">本 </div><div class="t m0 x0 h11 y4b ffc9 fsa fc0 sc0 ls8">第</div><div class="t m1 x0 h12 y4b ffca fsb fc3 sc0 ls247">16</div><div class="t m0 x5 h9 y4b ffc9 fsa fc0 sc0 ls8 ws1d">章 </div></div></div>
<div id="pf1f3" class="pf w0 h0" data-page-no="1f3"><div class="pc pc1f3 w0 h0"><div class="t m0 x2 h2 y1 ffc1 fs0 fc0 sc0 ls7 ws0">16.2 原生拖放    481 </div><div class="t m0 x0 h3 y2 ffc1 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffcb fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ffcb fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ffcb fs3 fc2 sc0 ls1d wsb">16 </div><div class="t m0 x3 h8 y20 ffcb fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffcb fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffcb fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffcb fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffcb fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffcb fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffcb fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffcb fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ffcb fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ffcb fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h4 y3 ffc6 fs1 fc0 sc0 ls2"> source：发送消息的文档的window对象的代理。这个代理对象主要用于在发送上一条消息的</div><div class="t m0 x5 h1e y4d ffc7 fs2 fc0 sc0 ls26 ws1f">窗口中调用postMessage()方法。如果发送消息的窗口来自同一个域，那这个对象就是</div><div class="t m0 x5 h5 y4e ffc8 fs1 fc0 sc0 ls9 ws2">window。 </div><div class="t m0 x0 h4 yd9 ffc7 fs2 fc0 sc0 ls8 ws1">接收到消息后验证发送窗口的来源是至关重要的。就像给postMessage()方法指定第二个参数，</div><div class="t m0 x0 h1e y15d ffc7 fs2 fc0 sc0 ls8 ws1">以确保浏览器不会把消息发送给未知页面一样，在onmessage处理程序中检测消息来源可以确保传入</div><div class="t m0 x0 h5 y21a ffc7 fs2 fc0 sc0 ls8 ws1">的消息来自已知的页面。基本的检测模式如下。 </div><div class="t m0 x0 hb y1707 ffc8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y340f ffc8 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(window, &quot;message&quot;, function(event){ </div><div class="t m0 x0 hb y3410 ffc8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y3411 ffc8 fs6 fc0 sc0 ls21 wsb">    //确保发送消息的域是已知的域 </div><div class="t m0 x0 hb y3412 ffc8 fs6 fc0 sc0 ls21 wsb">    if (event.origin == &quot;http://www.wrox.com&quot;){ </div><div class="t m0 x0 hb y3413 ffc8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y3414 ffc8 fs6 fc0 sc0 ls21 wsb">        //处理接收到的数据 </div><div class="t m0 x0 hb y3415 ffc8 fs6 fc0 sc0 ls21 wsb">        processMessage(event.data); </div><div class="t m0 x0 hb y3416 ffc8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y3417 ffc8 fs6 fc0 sc0 ls21 wsb">        //可选：向来源窗口发送回执 </div><div class="t m0 x0 hb y3418 ffc8 fs6 fc0 sc0 ls21 wsb">        event.source.postMessage(&quot;Received!&quot;, &quot;http://p2p.wrox.com&quot;); </div><div class="t m0 x0 hb y3419 ffc8 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y341a ffc8 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 hb y341b ffc8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y341c ffc7 fs2 fc0 sc0 ls8 ws1">还是要提醒大家，event.source大多数情况下只是window对象的代理，并非实际的window对</div><div class="t m0 x0 h1e y341d ffc7 fs2 fc0 sc0 ls8 ws1">象。换句话说，不能通过这个代理对象访问window对象的其他任何信息。记住，只通过这个代理调用</div><div class="t m0 x0 h5 y341e ffc8 fs1 fc0 sc0 ls9 ws2">postMessage()就好，这个方法永远存在，永远可以调用。 </div><div class="t m0 x0 hc y341f ffc1 fs2 fc0 sc0 ls81 ws76">XDM还有一些怪异之处。首先，postMessage()的第一个参数最早是作为“永远都是字符串”来实</div><div class="t m0 x0 h4 y3420 ffc7 fs2 fc0 sc0 ls8 ws1">现的。但后来这个参数的定义改了，改成允许传入任何数据结构。可是，并非所有浏览器都实现了这一</div><div class="t m0 x0 h1e y3421 ffc7 fs2 fc0 sc0 ls8 ws1">变化。为保险起见，使用postMessage()时，最好还是只传字符串。如果你想传入结构化的数据，最</div><div class="t m0 x0 h1e y3422 ffc7 fs2 fc0 sc0 ls8 ws1">佳选择是先在要传入的数据上调用JSON.stringify()，通过postMessage()传入得到的字符串，然</div><div class="t m0 x0 hc y3423 ffc7 fs2 fc0 sc0 ls8 ws1">后再在onmessage事件处理程序中调用JSON.parse()。 </div><div class="t m0 x0 h5 y3424 ffc7 fs2 fc0 sc0 ls8 ws1">在通过内嵌框架加载其他域的内容时，使用XDM是非常方便的。因此，在混搭（mashup）和社交</div><div class="t m0 x0 h5 y303b ffc7 fs2 fc0 sc0 ls8 ws1">网络应用中，这种传递消息的方法极为常用。有了XDM，包含&lt;iframe&gt;的页面可以确保自身不受恶意</div><div class="t m0 x0 h5 y19f3 ffc7 fs2 fc0 sc0 ls8 ws1">内容的侵扰，因为它只通过XDM与嵌入的框架通信。而XDM也可以在来自相同域的页面间使用。 </div><div class="t m0 x0 h5 y2099 ffc7 fs2 fc0 sc0 ls8 ws1">支持XDM的浏览器有IE8+、Firefox 3.5+、Safari 4+、Opera、Chrome、iOS版Safari及Android版</div><div class="t m0 x0 h5 y3425 ffc1 fs2 fc0 sc0 lsfd wscc">WebKit。XDM已经作为一个规范独立出来，现在它的名字叫 Web Messaging，官方页面是</div><div class="t m0 x0 h5 y3426 ffc1 fs2 fc0 sc0 ls25 wsb3">http://dev.w3.org/html5/postmsg/。 </div><div class="t m0 x0 h115 y3427 ffc5 fs7 fc0 sc0 ls245">16.2 原生拖放 </div><div class="t m0 x0 h5 y1f29 ffc7 fs2 fc0 sc0 ls8 ws1">最早在网页中引入JavaScript拖放功能的是IE4。当时，网页中只有两种对象可以拖放：图像和某</div><div class="t m0 x0 h4 y3428 ffc7 fs2 fc0 sc0 ls8 ws1">些文本。拖动图像时，把鼠标放在图像上，按住鼠标不放就可以拖动它。拖动文本时，要先选中文本，</div><div class="t m0 x0 h5 y3429 ffc7 fs2 fc0 sc0 ls8 ws1">然后可以像拖动图像一样拖动被选中的文本。在IE 4中，唯一有效的放置目标是文本框。到了IE5，拖</div><div class="t m0 x0 h5 y342a ffc7 fs2 fc0 sc0 ls8 ws1">放功能得到扩展，添加了新的事件，而且几乎网页中的任何元素都可以作为放置目标。IE5.5更进一步，</div><div class="t m0 x0 h5 y342b ffc7 fs2 fc0 sc0 ls8 ws1">让网页中的任何元素都可以拖放。（IE6同样也支持这些功能。）HTML5以IE的实例为基础制定了拖放</div><div class="t m0 x0 h5 y342c ffc7 fs2 fc0 sc0 ls8">规范。Firefox 3.5、Safari 3+和Chrome也根据HTML5规范实现了原生拖放功能。 </div><div class="t m0 x0 h4 y342d ffc7 fs2 fc0 sc0 ls8 ws1">说到拖放，最有意思的恐怕就是能够在框架间、窗口间，甚至在应用间拖放网页元素了。浏览器对</div><div class="t m0 x0 h5 y342e ffc7 fs2 fc0 sc0 ls8 ws1">拖放的支持为实现这些功能提供了便利。 </div></div></div>
<div id="pf1f4" class="pf w0 h0" data-page-no="1f4"><div class="pc pc1f4 w0 h0"><div class="t m0 x0 h2 y1 ffc1 fs0 fc0 sc0 ls7 ws0">482  第16章 HTML5脚本编程 </div><div class="t m0 x0 h3 y2 ffc1 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h116 y12d ffc5 fs3 fc0 sc0 ls248 ws214">16.2.1 拖放事件 </div><div class="t m0 x0 h4 y12e ffc7 fs2 fc0 sc0 ls8 ws1">通过拖放事件，可以控制拖放相关的各个方面。其中最关键的地方在于确定哪里发生了拖放事件，</div><div class="t m0 x0 h4 y12f ffc7 fs2 fc0 sc0 ls8 ws1">有些事件是在被拖动的元素上触发的，而有些事件是在放置目标上触发的。拖动某元素时，将依次触发</div><div class="t m0 x0 h5 y130 ffc7 fs2 fc0 sc0 ls8 ws1">下列事件： </div><div class="t m0 x0 h5 y31ec ffc1 fs2 fc0 sc0 ls13 wsb">(1) dragstart </div><div class="t m0 x0 h5 y73e ffc1 fs2 fc0 sc0 ls13 wsb">(2) drag </div><div class="t m0 x0 h5 y2df ffc1 fs2 fc0 sc0 ls13 wsb">(3) dragend </div><div class="t m0 x0 h5 y342f ffc7 fs2 fc0 sc0 ls8 ws1">按下鼠标键并开始移动鼠标时，会在被拖放的元素上触发dragstart事件。此时光标变成“不能放”</div><div class="t m0 x0 h4 y3430 ffc7 fs2 fc0 sc0 ls5 ws4">符号（圆环中有一条反斜线），表示不能把元素放到自己上面。拖动开始时，可以通过ondragstart</div><div class="t m0 x0 h5 y3431 ffc7 fs2 fc0 sc0 ls8 ws1">事件处理程序来运行JavaScript代码。 </div><div class="t m0 x0 h1e y3432 ffc7 fs2 fc0 sc0 ls8 ws1">触发dragstart事件后，随即会触发drag 事件，而且在元素被拖动期间会持续触发该事件。这</div><div class="t m0 x0 h1e y3433 ffc7 fs2 fc0 sc0 ls8 ws1">个事件与mousemove事件相似，在鼠标移动过程中，mousemove事件也会持续发生。当拖动停止时（无</div><div class="t m0 x0 hc y3434 ffc7 fs2 fc0 sc0 ls8 ws1">论是把元素放到了有效的放置目标，还是放到了无效的放置目标上），会触发dragend事件。 </div><div class="t m0 x0 h4 y2114 ffc7 fs2 fc0 sc0 ls8 ws1">上述三个事件的目标都是被拖动的元素。默认情况下，浏览器不会在拖动期间改变被拖动元素的外</div><div class="t m0 x0 h4 y3435 ffc7 fs2 fc0 sc0 ls8 ws1">观，但你可以自己修改。不过，大多数浏览器会为正被拖动的元素创建一个半透明的副本，这个副本始</div><div class="t m0 x0 h5 y3436 ffc7 fs2 fc0 sc0 ls8 ws1">终跟随着光标移动。 </div><div class="t m0 x0 h5 y3437 ffc7 fs2 fc0 sc0 ls8 ws1">当某个元素被拖动到一个有效的放置目标上时，下列事件会依次发生： </div><div class="t m0 x0 h5 y3438 ffc1 fs2 fc0 sc0 ls13 wsb">(1) dragenter </div><div class="t m0 x0 h5 y3439 ffc1 fs2 fc0 sc0 ls13 wsb">(2) dragover </div><div class="t m0 x0 h5 y343a ffc1 fs2 fc0 sc0 ls13 wsb">(3) dragleave或drop </div><div class="t m0 x0 h1e y343b ffc7 fs2 fc0 sc0 ls8 ws1">只要有元素被拖动到放置目标上，就会触发dragenter事件（类似于mouseover事件）。紧随其</div><div class="t m0 x0 h1e y343c ffc7 fs2 fc0 sc0 ls8 ws1">后的是dragover事件，而且在被拖动的元素还在放置目标的范围内移动时，就会持续触发该事件。如</div><div class="t m0 x0 h1e yf11 ffc7 fs2 fc0 sc0 ls8 ws1">果元素被拖出了放置目标，dragover事件不再发生，但会触发dragleave事件（类似于 mouseout</div><div class="t m0 x0 h4 y10cb ffc7 fs2 fc0 sc0 ls8 ws1">事件）。如果元素被放到了放置目标中，则会触发drop事件而不是dragleave事件。上述三个事件的</div><div class="t m0 x0 h5 y24a0 ffc7 fs2 fc0 sc0 ls8 ws1">目标都是作为放置目标的元素。 </div><div class="t m0 x0 h20 y343d ffc5 fs3 fc0 sc0 ls248 ws214">16.2.2 自定义放置目标 </div><div class="t m0 x0 h4 y1718 ffc7 fs2 fc0 sc0 ls6 ws6">在拖动元素经过某些无效放置目标时，可以看到一种特殊的光标（圆环中有一条反斜线），表示不</div><div class="t m0 x0 h4 y343e ffc7 fs2 fc0 sc0 ls8 ws1">能放置。虽然所有元素都支持放置目标事件，但这些元素默认是不允许放置的。如果拖动元素经过不允</div><div class="t m0 x0 h1c y343f ffc7 fs2 fc0 sc0 ls8 ws1">许放置的元素，无论用户如何操作，都不会发生drop事件。不过，你可以把任何元素变成有效的放置</div><div class="t m0 x0 h5 y2830 ffc7 fs2 fc0 sc0 ls6 ws6">目标，方法是重写dragenter和dragover事件的默认行为。例如，假设有一个ID为&quot;droptarget&quot;</div><div class="t m0 x0 h5 y498 ffc7 fs2 fc0 sc0 ls8 ws1">的&lt;div&gt;元素，可以用如下代码将它变成一个放置目标。 </div><div class="t m0 x0 hb y3440 ffc8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3441 ffc8 fs6 fc0 sc0 ls21 wsb">var droptarget = document.getElementById(&quot;droptarget&quot;); </div><div class="t m0 x0 hb y3442 ffc8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3443 ffc8 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(droptarget, &quot;dragover&quot;, function(event){  </div><div class="t m0 x0 hb y3444 ffc8 fs6 fc0 sc0 ls21 wsb">    EventUtil.preventDefault(event); </div><div class="t m0 x0 hb y3445 ffc8 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 hb y3446 ffc8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3447 ffc8 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(droptarget, &quot;dragenter&quot;, function(event){ </div><div class="t m0 x0 hb y3448 ffc8 fs6 fc0 sc0 ls21 wsb">    EventUtil.preventDefault(event); </div><div class="t m0 x0 hb y3449 ffc8 fs6 fc0 sc0 ls21 wsb">}); </div></div></div>
<div id="pf1f5" class="pf w0 h0" data-page-no="1f5"><div class="pc pc1f5 w0 h0"><div class="t m0 x2 h2 y1 ffc1 fs0 fc0 sc0 ls7 ws0">16.2 原生拖放    483 </div><div class="t m0 x0 h3 y2 ffc1 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffcb fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ffcb fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ffcb fs3 fc2 sc0 ls1d wsb">16 </div><div class="t m0 x3 h8 y20 ffcb fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffcb fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffcb fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffcb fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffcb fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffcb fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffcb fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffcb fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ffcb fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ffcb fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h4 y3 ffc7 fs2 fc0 sc0 ls8 ws1">以上代码执行后，你就会发现当拖动着元素移动到放置目标上时，光标变成了允许放置的符号。当</div><div class="t m0 x0 hc y4d ffc7 fs2 fc0 sc0 ls8 ws1">然，释放鼠标也会触发drop事件。 </div><div class="t m0 x0 h5 y5 ffc7 fs2 fc0 sc0 ls141">在Firefox 3.5+中，放置事件的默认行为是打开被放到放置目标上的URL。换句话说，如果是把图</div><div class="t m0 x0 h5 y6 ffc7 fs2 fc0 sc0 ls8 ws1">像拖放到放置目标上，页面就会转向图像文件；而如果是把文本拖放到放置目标上，则会导致无效URL</div><div class="t m0 x0 he y7 ffc7 fs2 fc0 sc0 ls8 ws1">错误。因此，为了让Firefox支持正常的拖放，还要取消drop事件的默认行为，阻止它打开URL： </div><div class="t m0 x0 hb y4ef ffc8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yfdc ffc8 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(droptarget, &quot;drop&quot;, function(event){ </div><div class="t m0 x0 hb yfdd ffc8 fs6 fc0 sc0 ls21 wsb">    EventUtil.preventDefault(event);  </div><div class="t m0 x0 hb yfde ffc8 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 h20 y55 ffc5 fs3 fc0 sc0 ls248 ws214">16.2.3 dataTransfer对象 </div><div class="t m0 x0 h5 y344a ffc7 fs2 fc0 sc0 ls5 ws4">只有简单的拖放而没有数据变化是没有什么用的。为了在拖放操作时实现数据交换，IE 5引入了</div><div class="t m0 x0 h4 y344b ffc8 fs1 fc0 sc0 ls9 ws2">dataTransfer对象，它是事件对象的一个属性，用于从被拖动元素向放置目标传递字符串格式的数据。</div><div class="t m0 x0 h1e y344c ffc7 fs2 fc0 sc0 ls8 ws1">因为它是事件对象的属性，所以只能在拖放事件的事件处理程序中访问dataTransfer对象。在事件</div><div class="t m0 x0 h5 y9ea ffc7 fs2 fc0 sc0 ls60 ws198">处理程序中，可以使用这个对象的属性和方法来完善拖放功能。目前，HTML5规范草案也收入了</div><div class="t m0 x0 h5 y9eb ffc8 fs1 fc0 sc0 ls9 ws2">dataTransfer对象。 </div><div class="t m0 x0 h4 y9ec ffc8 fs1 fc0 sc0 ls9 ws2">dataTransfer对象有两个主要方法：getData()和setData()。不难想象，getData()可以取</div><div class="t m0 x0 h1e y344d ffc7 fs2 fc0 sc0 ls8 ws1">得由setData()保存的值。setData()方法的第一个参数，也是getData()方法唯一的一个参数，是</div><div class="t m0 x0 hc y9ee ffc7 fs2 fc0 sc0 ls8 ws1">一个字符串，表示保存的数据类型，取值为&quot;text&quot;或&quot;URL&quot;，如下所示： </div><div class="t m0 x0 hb y344e ffc8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y344f ffc8 fs6 fc0 sc0 ls21">//设置和接收文本数据 </div><div class="t m0 x0 hb y3450 ffc8 fs6 fc0 sc0 ls21 wsb">event.dataTransfer.setData(&quot;text&quot;, &quot;some text&quot;); </div><div class="t m0 x0 hb y3451 ffc8 fs6 fc0 sc0 ls21 wsb">var text = event.dataTransfer.getData(&quot;text&quot;); </div><div class="t m0 x0 hb y3452 ffc8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y3453 ffc8 fs6 fc0 sc0 ls21">//设置和接收URL </div><div class="t m0 x0 hb y3454 ffc8 fs6 fc0 sc0 ls21 wsb">event.dataTransfer.setData(&quot;URL&quot;, &quot;http://www.wrox.com/&quot;); </div><div class="t m0 x0 hb y3455 ffc8 fs6 fc0 sc0 ls21 wsb">var url = event.dataTransfer.getData(&quot;URL&quot;); </div><div class="t m0 x0 hb y3456 ffc8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3457 ffc1 fs2 fc0 sc0 lse ws9">IE只定义了&quot;text&quot;和&quot;URL&quot;两种有效的数据类型，而HTML5则对此加以扩展，允许指定各种MIME</div><div class="t m0 x0 h5 y3458 ffc7 fs2 fc0 sc0 ls8 ws1">类型。考虑到向后兼容，HTML5也支持&quot;text&quot;和&quot;URL&quot;，但这两种类型会被映射为&quot;text/plain&quot;和</div><div class="t m0 x0 h5 y3459 ffc8 fs1 fc0 sc0 ls9 ws2">&quot;text/uri-list&quot;。 </div><div class="t m0 x0 h5 y345a ffc7 fs2 fc0 sc0 ls8 ws1">实际上，dataTransfer对象可以为每种MIME类型都保存一个值。换句话说，同时在这个对象</div><div class="t m0 x0 h5 y345b ffc7 fs2 fc0 sc0 ls8 ws1">中保存一段文本和一个URL不会有任何问题。不过，保存在dataTransfer对象中的数据只能在drop</div><div class="t m0 x0 h4 y345c ffc7 fs2 fc0 sc0 ls8 ws1">事件处理程序中读取。如果在ondrop处理程序中没有读到数据，那就是dataTransfer 对象已经被</div><div class="t m0 x0 h5 y345d ffc7 fs2 fc0 sc0 ls8 ws1">销毁，数据也丢失了。 </div><div class="t m0 x0 h1e y345e ffc7 fs2 fc0 sc0 ls30 ws2a">在拖动文本框中的文本时，浏览器会调用setData()方法，将拖动的文本以&quot;text&quot;格式保存在</div><div class="t m0 x0 h5 y345f ffc8 fs1 fc0 sc0 ls9 ws2">dataTransfer对象中。类似地，在拖放链接或图像时，会调用setData()方法并保存URL。然后，</div><div class="t m0 x0 h1e y3460 ffc7 fs2 fc0 sc0 ls6 ws6">在这些元素被拖放到放置目标时，就可以通过getData()读到这些数据。当然，作为开发人员，你也</div><div class="t m0 x0 hc y3461 ffc7 fs2 fc0 sc0 ls8 ws1">可以在dragstart事件处理程序中调用setData()，手工保存自己要传输的数据，以便将来使用。 </div><div class="t m0 x0 h5 y3462 ffc7 fs2 fc0 sc0 ls8 ws1">将数据保存为文本和保存为URL是有区别的。如果将数据保存为文本格式，那么数据不会得到任</div><div class="t m0 x0 h5 y3463 ffc7 fs2 fc0 sc0 ls8 ws1">何特殊处理。而如果将数据保存为URL，浏览器会将其当成网页中的链接。换句话说，如果你把它放置</div><div class="t m0 x0 h5 y3464 ffc7 fs2 fc0 sc0 ls8 ws1">到另一个浏览器窗口中，浏览器就会打开该URL。 </div><div class="t m0 x0 h5 y3465 ffc1 fs2 fc0 sc0 ls47 ws38">Firefox在其第5个版本之前不能正确地将&quot;url&quot;和&quot;text&quot; 映射为&quot;text/uri-list&quot;和</div><div class="t m0 x0 h5 y103 ffc8 fs1 fc0 sc0 ls9 ws2">&quot;text/plain&quot;。但是却能把&quot;Text&quot;（T大写）映射为&quot;text/plain&quot;。为了更好地在跨浏览器的情况</div></div></div>
<div id="pf1f6" class="pf w0 h0" data-page-no="1f6"><div class="pc pc1f6 w0 h0"><div class="t m0 x0 h2 y1 ffc1 fs0 fc0 sc0 ls7 ws0">484  第16章 HTML5脚本编程 </div><div class="t m0 x0 h3 y2 ffc1 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ffc7 fs2 fc0 sc0 ls8 ws1">下从dataTransfer对象取得数据，最好在取得 URL数据时检测两个值，而在取得文本数据时使用</div><div class="t m0 x0 h5 y4 ffc8 fs1 fc0 sc0 ls9 ws2">&quot;Text&quot;。 </div><div class="t m0 x0 hb y2d8 ffc8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2d9 ffc8 fs6 fc0 sc0 ls21 wsb">var dataTransfer = event.dataTransfer; </div><div class="t m0 x0 hb y2da ffc8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y2db ffc8 fs6 fc0 sc0 ls21">//读取URL </div><div class="t m0 x0 hb y2dc ffc8 fs6 fc0 sc0 ls21 wsb">var url = dataTransfer.getData(&quot;url&quot;) ||dataTransfer.getData(&quot;text/uri-list&quot;); </div><div class="t m0 x0 hb y2dd ffc8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y9e2 ffc8 fs6 fc0 sc0 ls21">//读取文本 </div><div class="t m0 x0 hb y9e3 ffc8 fs6 fc0 sc0 ls21 wsb">var text = dataTransfer.getData(&quot;Text&quot;); </div><div class="t m0 x0 hb y3467 ffc8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf yf6c ffcd fs2 fc0 sc0 ls5e wsb">DataTransferExample01.htm </div><div class="t m0 x0 h5 y3468 ffc7 fs2 fc0 sc0 ls8 ws1">注意，一定要把短数据类型放在前面，因为IE 10及之前的版本仍然不支持扩展的MIME类型名，</div><div class="t m0 x0 h5 y3469 ffc7 fs2 fc0 sc0 ls8 ws1">而它们在遇到无法识别的数据类型时，会抛出错误。 </div><div class="t m0 x0 h20 yc87 ffc5 fs3 fc0 sc0 ls248 ws214">16.2.4 dropEffect与effectAllowed </div><div class="t m0 x0 h4 y33cd ffc7 fs2 fc0 sc0 ls8 ws1">利用dataTransfer对象，可不光是能够传输数据，还能通过它来确定被拖动的元素以及作为放</div><div class="t m0 x0 h1e y33ce ffc7 fs2 fc0 sc0 ls8 ws1">置目标的元素能够接收什么操作。为此，需要访问dataTransfer对象的两个属性：dropEffect 和</div><div class="t m0 x0 h5 y346a ffc8 fs1 fc0 sc0 ls9 ws2">effectAllowed。 </div><div class="t m0 x0 hc y346b ffc7 fs2 fc0 sc0 ls8 ws1">其中，通过dropEffect属性可以知道被拖动的元素能够执行哪种放置行为。这个属性有下列 4</div><div class="t m0 x0 h5 y341f ffc7 fs2 fc0 sc0 ls8 ws1">个可能的值。 </div><div class="t m0 x0 h5 y346c ffc6 fs1 fc0 sc0 ls2"> &quot;none&quot;：不能把拖动的元素放在这里。这是除文本框之外所有元素的默认值。 </div><div class="t m0 x0 h5 y346d ffc6 fs1 fc0 sc0 ls2"> &quot;move&quot;：应该把拖动的元素移动到放置目标。 </div><div class="t m0 x0 h5 y346e ffc6 fs1 fc0 sc0 ls2"> &quot;copy&quot;：应该把拖动的元素复制到放置目标。 </div><div class="t m0 x0 h5 y346f ffc6 fs1 fc0 sc0 ls2"> &quot;link&quot;：表示放置目标会打开拖动的元素（但拖动的元素必须是一个链接，有URL）。 </div><div class="t m0 x0 h4 y3424 ffc7 fs2 fc0 sc0 ls8 ws1">在把元素拖动到放置目标上时，以上每一个值都会导致光标显示为不同的符号。然而，要怎样实现</div><div class="t m0 x0 h4 y303b ffc7 fs2 fc0 sc0 ls8 ws1">光标所指示的动作完全取决于你。换句话说，如果你不介入，没有什么会自动地移动、复制，也不会打</div><div class="t m0 x0 h4 y3470 ffc7 fs2 fc0 sc0 ls8 ws1">开链接。总之，浏览器只能帮你改变光标的样式，而其他的都要靠你自己来实现。要使用dropEffect</div><div class="t m0 x0 h5 y3471 ffc7 fs2 fc0 sc0 ls8 ws1">属性，必须在ondragenter事件处理程序中针对放置目标来设置它。 </div><div class="t m0 x0 h4 y3472 ffc8 fs1 fc0 sc0 ls9 ws2">dropEffect属性只有搭配effectAllowed属性才有用。effectAllowed 属性表示允许拖动元</div><div class="t m0 x0 hc y3473 ffc7 fs2 fc0 sc0 ls8 ws1">素的哪种dropEffect，effectAllowed属性可能的值如下。 </div><div class="t m0 x0 h5 y3474 ffc6 fs1 fc0 sc0 ls2"> &quot;uninitialized&quot;：没有给被拖动的元素设置任何放置行为。 </div><div class="t m0 x0 h5 y3475 ffc6 fs1 fc0 sc0 ls2"> &quot;none&quot;：被拖动的元素不能有任何行为。 </div><div class="t m0 x0 h5 y1988 ffc6 fs1 fc0 sc0 ls2"> &quot;copy&quot;：只允许值为&quot;copy&quot;的dropEffect。 </div><div class="t m0 x0 h5 y6b5 ffc6 fs1 fc0 sc0 ls2"> &quot;link&quot;：只允许值为&quot;link&quot;的dropEffect。 </div><div class="t m0 x0 h5 y198a ffc6 fs1 fc0 sc0 ls2"> &quot;move&quot;：只允许值为&quot;move&quot;的dropEffect。 </div><div class="t m0 x0 h5 y6b7 ffc6 fs1 fc0 sc0 ls2"> &quot;copyLink&quot;：允许值为&quot;copy&quot;和&quot;link&quot;的dropEffect。 </div><div class="t m0 x0 h5 y3476 ffc6 fs1 fc0 sc0 ls2"> &quot;copyMove&quot;：允许值为&quot;copy&quot;和&quot;move&quot;的dropEffect。 </div><div class="t m0 x0 h5 y3477 ffc6 fs1 fc0 sc0 ls2"> &quot;linkMove&quot;：允许值为&quot;link&quot;和&quot;move&quot;的dropEffect。 </div><div class="t m0 x0 h5 y3478 ffc6 fs1 fc0 sc0 ls2"> &quot;all&quot;：允许任意dropEffect。 </div><div class="t m0 x0 hc y3479 ffc7 fs2 fc0 sc0 ls8 ws1">必须在ondragstart事件处理程序中设置effectAllowed属性。 </div></div></div>
<div id="pf1f7" class="pf w0 h0" data-page-no="1f7"><div class="pc pc1f7 w0 h0"><div class="t m0 x2 h2 y1 ffc1 fs0 fc0 sc0 ls7 ws0">16.2 原生拖放    485 </div><div class="t m0 x0 h3 y2 ffc1 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffcb fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ffcb fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ffcb fs3 fc2 sc0 ls1d wsb">16 </div><div class="t m0 x3 h8 y20 ffcb fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffcb fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffcb fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffcb fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffcb fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffcb fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffcb fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffcb fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ffcb fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ffcb fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h4 y3 ffc7 fs2 fc0 sc0 ls55 ws49">假设你想允许用户把文本框中的文本拖放到一个&lt;div&gt;元素中。首先，必须将dropEffect和</div><div class="t m0 x0 h4 y4 ffc8 fs1 fc0 sc0 ls9 ws2">effectAllowed设置为&quot;move&quot;。但是，由于&lt;div&gt;元素的放置事件的默认行为是什么也不做，所以文</div><div class="t m0 x0 h4 y5 ffc7 fs2 fc0 sc0 ls8 ws1">本不可能自动移动。重写这个默认行为，就能从文本框中移走文本。然后你就可以自己编写代码将文本</div><div class="t m0 x0 h1e y6 ffc7 fs2 fc0 sc0 ls8 ws1">插入到&lt;div&gt;中，这样整个拖放操作就完成了。如果你将dropEffect和effectAllowed的值设置为</div><div class="t m0 x0 h5 y219 ffc8 fs1 fc0 sc0 ls9 ws2">&quot;copy&quot;，那就不会自动移走文本框中的文本。 </div><div class="t m0 x5 h5 y54b ffc1 fs2 fc0 sc0 ls2e ws27">Firefox 5及之前的版本在处理effectAllowed属性时有一个问题，即如果你在</div><div class="t m0 x5 h18 y1369 ffc2 fs2 fc0 sc0 ls8 ws14">代码中设置了这个属性的值，那不一定会触发drop事件。 </div><div class="t m0 x0 h20 y347a ffc5 fs3 fc0 sc0 ls248 ws214">16.2.5 可拖动 </div><div class="t m0 x0 h4 y347b ffc7 fs2 fc0 sc0 ls8 ws1">默认情况下，图像、链接和文本是可以拖动的，也就是说，不用额外编写代码，用户就可以拖动它</div><div class="t m0 x0 h5 y347c ffc7 fs2 fc0 sc0 ls8 ws1">们。文本只有在被选中的情况下才能拖动，而图像和链接在任何时候都可以拖动。 </div><div class="t m0 x0 h5 y347d ffc7 fs2 fc0 sc0 lsa ws53">让其他元素可以拖动也是可能的。HTML5为所有HTML元素规定了一个draggable属性，表</div><div class="t m0 x0 h4 y1be6 ffc7 fs2 fc0 sc0 lsa ws53">示元素是否可以拖动。图像和链接的draggable属性自动被设置成了true，而其他元素这个属性</div><div class="t m0 x0 h1e y3218 ffc7 fs2 fc0 sc0 lsa ws53">的默认值都是false。要想让其他元素可拖动，或者让图像或链接不能拖动，都可以设置这个属性。</div><div class="t m0 x0 h5 y285e ffc7 fs2 fc0 sc0 lsa">例如： </div><div class="t m0 x0 hb y347e ffc8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y347f ffc8 fs6 fc0 sc0 ls21 wsb">&lt;!-- 让这个图像不可以拖动 --&gt; </div><div class="t m0 x0 hb y3480 ffc8 fs6 fc0 sc0 ls21 wsb">&lt;img src=&quot;smile.gif&quot; draggable=&quot;false&quot; alt=&quot;Smiley face&quot;&gt; </div><div class="t m0 x0 hb y3481 ffc8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y3482 ffc8 fs6 fc0 sc0 ls21 wsb">&lt;!-- 让这个元素可以拖动 --&gt; </div><div class="t m0 x0 hb y3483 ffc8 fs6 fc0 sc0 ls21 wsb">&lt;div draggable=&quot;true&quot;&gt;...&lt;/div&gt; </div><div class="t m0 x0 hb y3484 ffc8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3485 ffc7 fs2 fc0 sc0 ls8 ws1">支持draggable属性的浏览器有IE 10+、Firefox 4+、Safari 5+和Chrome。Opera 11.5及之前的版</div><div class="t m0 x0 h5 y3486 ffc7 fs2 fc0 sc0 ls8 ws1">本都不支持HTML5的拖放功能。另外，为了让Firefox支持可拖动属性，还必须添加一个ondragstart</div><div class="t m0 x0 h5 y123b ffc7 fs2 fc0 sc0 ls8 ws1">事件处理程序，并在dataTransfer对象中保存一些信息。 </div><div class="t m0 x5 h5 y3487 ffc2 fs2 fc0 sc0 ls8c">在IE9及更早版本中，通过mousedown事件处理程序调用dragDrop()能够让</div><div class="t m0 x5 h5 y3488 ffc2 fs2 fc0 sc0 ls8 ws14">任何元素可拖动。而在Safari 4及之前版本中，必须额外给相应元素设置 CSS样式</div><div class="t m0 x5 h5 y3489 ffc8 fs1 fc0 sc0 ls9 wsb">–khtml-user-drag: element。 </div><div class="t m0 x0 h20 y17c1 ffc5 fs3 fc0 sc0 ls248 ws214">16.2.6 其他成员 </div><div class="t m0 x0 h5 y9ff ffc1 fs2 fc0 sc0 ls2f ws8a">HTML5规范规定dataTransfer对象还应该包含下列方法和属性。 </div><div class="t m0 x0 h4 y348a ffc6 fs1 fc0 sc0 ls2"> addElement(element)：为拖动操作添加一个元素。添加这个元素只影响数据（即增加作为拖</div><div class="t m0 x5 h5 y2ee0 ffc7 fs2 fc0 sc0 ls8 ws1">动源而响应回调的对象），不会影响拖动操作时页面元素的外观。在写作本书时，只有Firefox 3.5+</div><div class="t m0 x5 h5 y348b ffc7 fs2 fc0 sc0 ls8 ws1">实现了这个方法。 </div><div class="t m0 x0 h5 y348c ffc6 fs1 fc0 sc0 ls2"> clearData(format)：清除以特定格式保存的数据。实现这个方法的浏览器有IE、Fireforx 3.5+、</div><div class="t m0 x5 h5 y348d ffc1 fs2 fc0 sc0 ls50 ws41">Chrome和Safari 4+。 </div><div class="t m0 x0 h4 y348e ffc6 fs1 fc0 sc0 ls2"> setDragImage(element, x, y)：指定一幅图像，当拖动发生时，显示在光标下方。这个方</div></div></div>
<div id="pf1f8" class="pf w0 h0" data-page-no="1f8"><div class="pc pc1f8 w0 h0"><div class="t m0 x0 h2 y1 ffc1 fs0 fc0 sc0 ls7 ws0">486  第16章 HTML5脚本编程 </div><div class="t m0 x0 h3 y2 ffc1 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ffc7 fs2 fc0 sc0 ls8 ws1">法接收的三个参数分别是要显示的HTML元素和光标在图像中的x、y坐标。其中，HTML元素</div><div class="t m0 x0 h4 y4d ffc7 fs2 fc0 sc0 ls5 ws4">可以是一幅图像，也可以是其他元素。是图像则显示图像，是其他元素则显示渲染后的元素。</div><div class="t m0 x0 h5 yd8 ffc7 fs2 fc0 sc0 ls8 ws1">实现这个方法的浏览器有Firefox 3.5+、Safari 4+和Chrome。 </div><div class="t m0 x0 h4 yd9 ffc6 fs1 fc0 sc0 ls2"> types：当前保存的数据类型。这是一个类似数组的集合，以&quot;text&quot;这样的字符串形式保存着</div><div class="t m0 x0 h5 y15d ffc7 fs2 fc0 sc0 ls8 ws1">数据类型。实现这个属性的浏览器有IE10+、Firefox 3.5+和Chrome。 </div><div class="t m0 x0 hd y2290 ffc5 fs7 fc0 sc0 ls245">16.3 媒体元素 </div><div class="t m0 x0 h5 yb ffc7 fs2 fc0 sc0 ls8 ws1">随着音频和视频在Web上的迅速流行，大多数提供富媒体内容的站点为了保证跨浏览器兼容性，</div><div class="t m0 x0 h5 y78a ffc7 fs2 fc0 sc0 ls8 ws1">不得不选择使用Flash。HTML5新增了两个与媒体相关的标签，让开发人员不必依赖任何插件就能在网</div><div class="t m0 x0 hc yccd ffc7 fs2 fc0 sc0 ls8 ws1">页中嵌入跨浏览器的音频和视频内容。这两个标签就是&lt;audio&gt;和&lt;video&gt;。 </div><div class="t m0 x0 h5 ycce ffc7 fs2 fc0 sc0 ls6 ws6">这两个标签除了能让开发人员方便地嵌入媒体文件之外，都提供了用于实现常用功能的JavaScript </div><div class="t m0 x0 h5 y348f ffc1 fs2 fc0 sc0 ls25 wsb3">API，允许为媒体创建自定义的控件。这两个元素的用法如下。 </div><div class="t m0 x0 hb y21d ffc8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y21e ffc8 fs6 fc0 sc0 ls21 wsb">&lt;!-- 嵌入视频 --&gt; </div><div class="t m0 x0 hb y3490 ffc8 fs6 fc0 sc0 ls21 wsb">&lt;video src=&quot;conference.mpg&quot; id=&quot;myVideo&quot;&gt;Video player not available.&lt;/video&gt; </div><div class="t m0 x0 hb y220 ffc8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y221 ffc8 fs6 fc0 sc0 ls21 wsb">&lt;!-- 嵌入音频 --&gt; </div><div class="t m0 x0 hb y3491 ffc8 fs6 fc0 sc0 ls21 wsb">&lt;audio src=&quot;song.mp3&quot; id=&quot;myAudio&quot;&gt;Audio player not available.&lt;/audio&gt; </div><div class="t m0 x0 hb y3492 ffc8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3493 ffc7 fs2 fc0 sc0 ls8 ws1">使用这两个元素时，至少要在标签中包含src属性，指向要加载的媒体文件。还可以设置width</div><div class="t m0 x0 h5 y3494 ffc7 fs2 fc0 sc0 ls2c">和height属性以指定视频播放器的大小，而为poster属性指定图像的URI可以在加载视频内容期间</div><div class="t m0 x0 hc y3495 ffc7 fs2 fc0 sc0 ls8 ws1">显示一幅图像。另外，如果标签中有controls属性，则意味着浏览器应该显示UI控件，以便用户直</div><div class="t m0 x0 h4 y3496 ffc7 fs2 fc0 sc0 ls8 ws1">接操作媒体。位于开始和结束标签之间的任何内容都将作为后备内容，在浏览器不支持这两个媒体元素</div><div class="t m0 x0 h5 y3497 ffc7 fs2 fc0 sc0 ls8 ws1">的情况下显示。 </div><div class="t m0 x0 h4 y3498 ffc7 fs2 fc0 sc0 ls8 ws1">因为并非所有浏览器都支持所有媒体格式，所以可以指定多个不同的媒体来源。为此，不用在标签</div><div class="t m0 x0 h14 y3499 ffc7 fs2 fc0 sc0 ls8 ws1">中指定src属性，而是要像下面这样使用一或多个&lt;source&gt;元素。 </div><div class="t m0 x0 hb y2168 ffc8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y349a ffc8 fs6 fc0 sc0 ls21 wsb">&lt;!-- 嵌入视频 --&gt; </div><div class="t m0 x0 hb y349b ffc8 fs6 fc0 sc0 ls21 wsb">&lt;video id=&quot;myVideo&quot;&gt; </div><div class="t m0 x0 hb y349c ffc8 fs6 fc0 sc0 ls21 wsb">  &lt;source src=&quot;conference.webm&quot; type=&quot;video/webm; codecs=&apos;vp8, vorbis&apos;&quot;&gt; </div><div class="t m0 x0 hb y349d ffc8 fs6 fc0 sc0 ls21 wsb">  &lt;source src=&quot;conference.ogv&quot; type=&quot;video/ogg; codecs=&apos;theora, vorbis&apos;&quot;&gt; </div><div class="t m0 x0 hb y349e ffc8 fs6 fc0 sc0 ls21 wsb">  &lt;source src=&quot;conference.mpg&quot;&gt; </div><div class="t m0 x0 hb y349f ffc8 fs6 fc0 sc0 ls21 wsb">  Video player not available. </div><div class="t m0 x0 hb y34a0 ffc8 fs6 fc0 sc0 ls21 wsb">&lt;/video&gt; </div><div class="t m0 x0 hb y34a1 ffc8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y34a2 ffc8 fs6 fc0 sc0 ls21 wsb">&lt;!-- 嵌入音频 --&gt; </div><div class="t m0 x0 hb y34a3 ffc8 fs6 fc0 sc0 ls21 wsb">&lt;audio id=&quot;myAudio&quot;&gt; </div><div class="t m0 x0 hb y34a4 ffc8 fs6 fc0 sc0 ls21 wsb">  &lt;source src=&quot;song.ogg&quot; type=&quot;audio/ogg&quot;&gt; </div><div class="t m0 x0 hb y34a5 ffc8 fs6 fc0 sc0 ls21 wsb">  &lt;source src=&quot;song.mp3&quot; type=&quot;audio/mpeg&quot;&gt; </div><div class="t m0 x0 hb y34a6 ffc8 fs6 fc0 sc0 ls21 wsb">  Audio player not available. </div><div class="t m0 x0 hb y34a7 ffc8 fs6 fc0 sc0 ls21 ws34">&lt;/audio&gt; </div><div class="t m0 x0 h5 y1617 ffc1 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y34a8 ffc7 fs2 fc0 sc0 ls8 ws1">关于视频和音频编解码器的内容超出了本书讨论的范围。作者在此只想告诉大家，不同的浏览器支</div><div class="t m0 x0 h4 y34a9 ffc7 fs2 fc0 sc0 ls8 ws1">持不同的编解码器，因此一般来说指定多种格式的媒体来源是必需的。支持这两个媒体元素的浏览器有</div><div class="t m0 x0 h5 y34aa ffc1 fs2 fc0 sc0 ls46 ws37">IE9+、Firefox 3.5+、Safari 4+、Opera 10.5+、Chrome、iOS版Safari和Android版WebKit。 </div></div></div>
<div id="pf1f9" class="pf w0 h0" data-page-no="1f9"><div class="pc pc1f9 w0 h0"><div class="t m0 x2 h2 y1 ffc1 fs0 fc0 sc0 ls7 ws0">16.3 媒体元素    487 </div><div class="t m0 x0 h3 y2 ffc1 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffcb fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ffcb fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ffcb fs3 fc2 sc0 ls1d wsb">16 </div><div class="t m0 x3 h8 y20 ffcb fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffcb fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffcb fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffcb fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffcb fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffcb fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffcb fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffcb fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ffcb fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ffcb fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h20 y12d ffc5 fs3 fc0 sc0 ls248 ws214">16.3.1 属性 </div><div class="t m0 x0 h5 y12e ffc8 fs1 fc0 sc0 ls9 ws2">&lt;video&gt;和&lt;audio&gt;元素都提供了完善的JavaScript接口。下表列出了这两个元素共有的属性，通</div><div class="t m0 x0 h5 y12f ffc7 fs2 fc0 sc0 ls8 ws1">过这些属性可以知道媒体的当前状态。 </div><div class="t m0 x0 hb4 y34ab ffc5 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x5 h31 y181 ffc4 fs6 fc0 sc0 lsa7 wsb">属  性 数据类型 说  明 </div><div class="t m0 x0 hb y34ac ffc8 fs6 fc0 sc0 ls21 wsb">autoplay  布尔值 取得或设置autoplay标志 </div><div class="t m0 x0 hb y2157 ffc8 fs6 fc0 sc0 ls21 wsb">buffered  时间范围 表示已下载的缓冲的时间范围的对象 </div><div class="t m0 x0 hb y34ad ffc8 fs6 fc0 sc0 ls21 wsb">bufferedBytes  字节范围 表示已下载的缓冲的字节范围的对象 </div><div class="t m0 x0 hb y34ae ffc8 fs6 fc0 sc0 ls21 wsb">bufferingRate  整数 下载过程中每秒钟平均接收到的位数 </div><div class="t m0 x0 hb y34af ffc8 fs6 fc0 sc0 ls21 wsb">bufferingThrottled  布尔值 表示浏览器是否对缓冲进行了节流 </div><div class="t m0 x0 hb y34b0 ffc8 fs6 fc0 sc0 ls21 wsb">controls  布尔值 取得或设置controls属性，用于显示或隐藏浏览器内置的控件 </div><div class="t m0 x0 hb y34b1 ffc8 fs6 fc0 sc0 ls21 wsb">currentLoop  整数 媒体文件已经循环的次数 </div><div class="t m0 x0 hb y34b2 ffc8 fs6 fc0 sc0 ls21 wsb">currentSrc  字符串 当前播放的媒体文件的URL </div><div class="t m0 x0 hb y34b3 ffc8 fs6 fc0 sc0 ls21 wsb">currentTime  浮点数 已经播放的秒数 </div><div class="t m0 x0 hb y34b4 ffc8 fs6 fc0 sc0 ls21">defaultPlaybackRate</div><div class="c x1 y34b5 w18 hbd"><div class="t m0 x0 hb y21eb ffc8 fs6 fc0 sc0 ls8 wsb"> </div></div><div class="t m0 x1 h36 y2698 ffc7 fs6 fc0 sc0 ls31 ws24">浮点数 取得或设置默认的播放速度。默认值为1.0秒 </div><div class="t m0 x0 hb y34b6 ffc8 fs6 fc0 sc0 ls21 wsb">duration  浮点数 媒体的总播放时间（秒数） </div><div class="t m0 x0 hb y34b7 ffc8 fs6 fc0 sc0 ls21 wsb">ended  布尔值 表示媒体文件是否播放完成 </div><div class="t m0 x0 hb y34b8 ffc8 fs6 fc0 sc0 ls21 wsb">loop  布尔值 取得或设置媒体文件在播放完成后是否再从头开始播放 </div><div class="t m0 x0 hb y34b9 ffc8 fs6 fc0 sc0 ls21 wsb">muted  布尔值 取得或设置媒体文件是否静音 </div><div class="t m0 x0 hb y34ba ffc8 fs6 fc0 sc0 ls21 wsb">networkState  整数 表示当前媒体的网络连接状态：0表示空，1表示正在加载，2表示</div><div class="t m0 x7 h36 y34bb ffc7 fs6 fc0 sc0 ls8 ws33">正在加载元数据，3表示已经加载了第一帧，4表示加载完成 </div><div class="t m0 x0 hb y34bc ffc8 fs6 fc0 sc0 ls21 wsb">paused  布尔值 表示播放器是否暂停 </div><div class="t m0 x0 hb y34bd ffc8 fs6 fc0 sc0 ls21 wsb">playbackRate   浮点数 取得或设置当前的播放速度。用户可以改变这个值，让媒体播放速</div><div class="t m0 x7 h58 y34be ffc7 fs6 fc0 sc0 ls157 ws1af">度变快或变慢，这与defaultPlaybackRate只能由开发人员修改</div><div class="t m0 x7 h36 y34bf ffc7 fs6 fc0 sc0 ls95">的defaultPlaybackRate不同 </div><div class="t m0 x0 hb y34c0 ffc8 fs6 fc0 sc0 ls21 wsb">played  时间范围 到目前为止已经播放的时间范围 </div><div class="t m0 x0 hb y34c1 ffc8 fs6 fc0 sc0 ls21 wsb">readyState  整数 表示媒体是否已经就绪（可以播放了）。0表示数据不可用，1表示</div><div class="t m0 x7 h36 y34c2 ffc7 fs6 fc0 sc0 ls8 ws33">可以显示当前帧，2表示可以开始播放，3表示媒体可以从头到尾播放 </div><div class="t m0 x0 hb y34c3 ffc8 fs6 fc0 sc0 ls21 wsb">seekable  时间范围 可以搜索的时间范围 </div><div class="t m0 x0 hb y34c4 ffc8 fs6 fc0 sc0 ls21 wsb">seeking  布尔值 表示播放器是否正移动到媒体文件中的新位置 </div><div class="t m0 x0 hb y34c5 ffc8 fs6 fc0 sc0 ls21 wsb">src  字符串 媒体文件的来源。任何时候都可以重写这个属性 </div><div class="t m0 x0 hb y34c6 ffc8 fs6 fc0 sc0 ls21 wsb">start  浮点数 取得或设置媒体文件中开始播放的位置，以秒表示 </div><div class="t m0 x0 hb y34c7 ffc8 fs6 fc0 sc0 ls21 wsb">totalBytes  整数 当前资源所需的总字节数 </div><div class="t m0 x0 hb y34c8 ffc8 fs6 fc0 sc0 ls21 wsb">videoHeight  整数 返回视频（不一定是元素）的高度。只适用于&lt;video&gt; </div><div class="t m0 x0 hb y34c9 ffc8 fs6 fc0 sc0 ls21 wsb">videoWidth  整数 返回视频（不一定是元素）的宽度。只适用于&lt;video&gt; </div><div class="t m0 x0 hb y34ca ffc8 fs6 fc0 sc0 ls21 wsb">volume  浮点数 取得或设置当前音量，值为0.0到1.0 </div><div class="t m0 x0 h5 y34cb ffc1 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb5 y34cc ffc7 fs2 fc0 sc0 ls8 ws1">其中很多属性也可以直接在&lt;audio&gt;和&lt;video&gt;元素中设置。 </div></div></div>
<div id="pf1fa" class="pf w0 h0" data-page-no="1fa"><div class="pc pc1fa w0 h0"><div class="t m0 x0 h2 y1 ffc1 fs0 fc0 sc0 ls7 ws0">488  第16章 HTML5脚本编程 </div><div class="t m0 x0 h3 y2 ffc1 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h20 y12d ffc5 fs3 fc0 sc0 ls248 ws214">16.3.2 事件 </div><div class="t m0 x0 h4 y12e ffc7 fs2 fc0 sc0 ls8 ws1">除了大量属性之外，这两个媒体元素还可以触发很多事件。这些事件监控着不同的属性的变化，这</div><div class="t m0 x0 h5 y12f ffc7 fs2 fc0 sc0 ls8 ws1">些变化可能是媒体播放的结果，也可能是用户操作播放器的结果。下表列出了媒体元素相关的事件。 </div><div class="t m0 x0 h5 y34cd ffc1 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h31 y34ce ffc4 fs6 fc0 sc0 lsa7 wsb">事  件 触发时机 </div><div class="t m0 x0 hb y34cf ffc8 fs6 fc0 sc0 ls21 wsb">abort  下载中断 </div><div class="t m0 x0 hb y34d0 ffc8 fs6 fc0 sc0 ls21 wsb">canplay  可以播放时；readyState值为2 </div><div class="t m0 x0 hb y34d1 ffc8 fs6 fc0 sc0 ls21 wsb">canplaythrough  播放可继续，而且应该不会中断；readyState值为3 </div><div class="t m0 x0 hb y34d2 ffc8 fs6 fc0 sc0 ls21">canshowcurrentframe</div><div class="c x1 y34d3 w1d hbd"><div class="t m0 x0 hb y21eb ffc8 fs6 fc0 sc0 ls8 wsb"> </div></div><div class="t m0 x7 h36 y34d4 ffc7 fs6 fc0 sc0 ls8 ws33">当前帧已经下载完成；readyState值为1 </div><div class="t m0 x0 hb y34d5 ffc8 fs6 fc0 sc0 ls21 wsb">dataunavailable  因为没有数据而不能播放；readyState值为0 </div><div class="t m0 x0 hb y34d6 ffc8 fs6 fc0 sc0 ls21 wsb">durationchange  duration属性的值改变 </div><div class="t m0 x0 hb y34d7 ffc8 fs6 fc0 sc0 ls21 wsb">emptied  网络连接关闭 </div><div class="t m0 x0 hb y34d8 ffc8 fs6 fc0 sc0 ls21 wsb">empty  发生错误阻止了媒体下载 </div><div class="t m0 x0 hb y34d9 ffc8 fs6 fc0 sc0 ls21 wsb">ended  媒体已播放到末尾，播放停止 </div><div class="t m0 x0 hb y34da ffc8 fs6 fc0 sc0 ls21 wsb">error  下载期间发生网络错误 </div><div class="t m0 x0 hb y34db ffc8 fs6 fc0 sc0 ls21 wsb">load  所有媒体已加载完成。这个事件可能会被废弃，建议使用canplaythrough </div><div class="t m0 x0 hb y34dc ffc8 fs6 fc0 sc0 ls21 wsb">loadeddata  媒体的第一帧已加载完成 </div><div class="t m0 x0 hb y34dd ffc8 fs6 fc0 sc0 ls21 wsb">loadedmetadata  媒体的元数据已加载完成 </div><div class="t m0 x0 hb y34de ffc8 fs6 fc0 sc0 ls21 wsb">loadstart  下载已开始 </div><div class="t m0 x0 hb y34df ffc8 fs6 fc0 sc0 ls21 wsb">pause  播放已暂停 </div><div class="t m0 x0 hb y34e0 ffc8 fs6 fc0 sc0 ls21 wsb">play  媒体已接收到指令开始播放 </div><div class="t m0 x0 hb y34e1 ffc8 fs6 fc0 sc0 ls21 wsb">playing  媒体已实际开始播放 </div><div class="t m0 x0 hb y34e2 ffc8 fs6 fc0 sc0 ls21 wsb">progress  正在下载 </div><div class="t m0 x0 hb y34e3 ffc8 fs6 fc0 sc0 ls21 wsb">ratechange  播放媒体的速度改变 </div><div class="t m0 x0 hb y34e4 ffc8 fs6 fc0 sc0 ls21 wsb">seeked  搜索结束 </div><div class="t m0 x0 hb y34e5 ffc8 fs6 fc0 sc0 ls21 wsb">seeking  正移动到新位置 </div><div class="t m0 x0 hb y34e6 ffc8 fs6 fc0 sc0 ls21 wsb">stalled  浏览器尝试下载，但未接收到数据 </div><div class="t m0 x0 hb y34e7 ffc8 fs6 fc0 sc0 ls21 wsb">timeupdate  currentTime被以不合理或意外的方式更新 </div><div class="t m0 x0 hb y34e8 ffc8 fs6 fc0 sc0 ls21 wsb">volumechange  volume属性值或muted属性值已改变 </div><div class="t m0 x0 hb y34e9 ffc8 fs6 fc0 sc0 ls21 wsb">waiting  播放暂停，等待下载更多数据 </div><div class="t m0 x0 h5 y34ea ffc1 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y34eb ffc7 fs2 fc0 sc0 ls8 ws1">这些事件之所以如此具体，就是为了让开发人员只使用少量HTML和JavaScript（与创建Flash影</div><div class="t m0 x0 h5 y34ec ffc7 fs2 fc0 sc0 ls8 ws1">片相比）即可编写出自定义的音频/视频播放器。 </div><div class="t m0 x0 h20 y34ed ffc5 fs3 fc0 sc0 ls248 ws214">16.3.3 自定义媒体播放器 </div><div class="t m0 x0 h4 ycb8 ffc7 fs2 fc0 sc0 ls8 ws1">使用&lt;audio&gt;和&lt;video&gt;元素的play()和pause()方法，可以手工控制媒体文件的播放。组合使</div><div class="t m0 x0 h5 ycb9 ffc7 fs2 fc0 sc0 ls8 ws1">用属性、事件和这两个方法，很容易创建一个自定义的媒体播放器，如下面的例子所示。 </div><div class="t m0 x0 hb y1a88 ffc8 fs6 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf1fb" class="pf w0 h0" data-page-no="1fb"><div class="pc pc1fb w0 h0"><div class="t m0 x2 h2 y1 ffc1 fs0 fc0 sc0 ls7 ws0">16.3 媒体元素    489 </div><div class="t m0 x0 h3 y2 ffc1 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffcb fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ffcb fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ffcb fs3 fc2 sc0 ls1d wsb">16 </div><div class="t m0 x3 h8 y20 ffcb fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffcb fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffcb fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffcb fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffcb fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffcb fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffcb fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffcb fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ffcb fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ffcb fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y79 ffc8 fs6 fc0 sc0 ls21 wsb">&lt;div class=&quot;mediaplayer&quot;&gt;  </div><div class="t m0 x0 hb y7a ffc8 fs6 fc0 sc0 ls21 wsb">    &lt;div class=&quot;video&quot;&gt; </div><div class="t m0 x0 hb y7b ffc8 fs6 fc0 sc0 ls21 wsb">        &lt;video id=&quot;player&quot; src=&quot;movie.mov&quot; poster=&quot;mymovie.jpg&quot; </div><div class="t m0 x0 hb y7c ffc8 fs6 fc0 sc0 ls21 wsb">               width=&quot;300&quot; height=&quot;200&quot;&gt; </div><div class="t m0 x0 hb y7d ffc8 fs6 fc0 sc0 ls21 wsb">            Video player not available. </div><div class="t m0 x0 hb y7e ffc8 fs6 fc0 sc0 ls21 wsb">        &lt;/video&gt; </div><div class="t m0 x0 hb y7f ffc8 fs6 fc0 sc0 ls21 wsb">    &lt;/div&gt; </div><div class="t m0 x0 hb y80 ffc8 fs6 fc0 sc0 ls21 wsb">    &lt;div class=&quot;controls&quot;&gt; </div><div class="t m0 x0 hb y81 ffc8 fs6 fc0 sc0 ls21 wsb">        &lt;input type=&quot;button&quot; value=&quot;Play&quot; id=&quot;video-btn&quot;&gt; </div><div class="t m0 x0 hb y82 ffc8 fs6 fc0 sc0 ls21 wsb">        &lt;span id=&quot;curtime&quot;&gt;0&lt;/span&gt;/&lt;span id=&quot;duration&quot;&gt;0&lt;/span&gt; </div><div class="t m0 x0 hb y83 ffc8 fs6 fc0 sc0 ls21 wsb">    &lt;/div&gt; </div><div class="t m0 x0 hb y84 ffc8 fs6 fc0 sc0 ls21 wsb">&lt;/div&gt; </div><div class="t m0 x0 hb y1a22 ffc8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1a23 ffcd fs2 fc0 sc0 ls79 wsb">VideoPlayerExample01.htm </div><div class="t m0 x0 h5 y1a24 ffc7 fs2 fc0 sc0 ls8 ws1">以上基本的HTML再加上一些JavaScript就可以变成一个简单的视频播放器。以下就是 JavaScript</div><div class="t m0 x0 h5 y34ee ffc7 fs2 fc0 sc0 ls8">代码。 </div><div class="t m0 x0 hb ycbf ffc8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y34ef ffc8 fs6 fc0 sc0 ls21">//取得元素的引用 </div><div class="t m0 x0 hb y34f0 ffc8 fs6 fc0 sc0 ls21 wsb">var player = document.getElementById(&quot;player&quot;), </div><div class="t m0 x0 hb y34f1 ffc8 fs6 fc0 sc0 ls21 wsb">    btn = document.getElementById(&quot;video-btn&quot;), </div><div class="t m0 x0 hb y34f2 ffc8 fs6 fc0 sc0 ls21 wsb">    curtime = document.getElementById(&quot;curtime&quot;), </div><div class="t m0 x0 hb y34f3 ffc8 fs6 fc0 sc0 ls21 wsb">    duration = document.getElementById(&quot;duration&quot;); </div><div class="t m0 x0 hb y34f4 ffc8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y34f5 ffc8 fs6 fc0 sc0 ls21">//更新播放时间 </div><div class="t m0 x0 hb y34f6 ffc8 fs6 fc0 sc0 ls21 wsb">duration.innerHTML = player.duration; </div><div class="t m0 x0 hb y34f7 ffc8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y34f8 ffc8 fs6 fc0 sc0 ls21">//为按钮添加事件处理程序 </div><div class="t m0 x0 hb y34f9 ffc8 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(btn, &quot;click&quot;, function(event){ </div><div class="t m0 x0 hb y34fa ffc8 fs6 fc0 sc0 ls21 wsb">    if (player.paused){ </div><div class="t m0 x0 hb y34fb ffc8 fs6 fc0 sc0 ls21 wsb">        player.play(); </div><div class="t m0 x0 hb y34fc ffc8 fs6 fc0 sc0 ls21 wsb">        btn.value = &quot;Pause&quot;; </div><div class="t m0 x0 hb y34fd ffc8 fs6 fc0 sc0 ls21 wsb">    } else { </div><div class="t m0 x0 hb y34fe ffc8 fs6 fc0 sc0 ls21 wsb">        player.pause(); </div><div class="t m0 x0 hb y34ff ffc8 fs6 fc0 sc0 ls21 wsb">        btn.value = &quot;Play&quot;; </div><div class="t m0 x0 hb y3500 ffc8 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y3501 ffc8 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 hb y3502 ffc8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y3503 ffc8 fs6 fc0 sc0 ls21">//定时更新当前时间 </div><div class="t m0 x0 hb y3504 ffc8 fs6 fc0 sc0 ls21 wsb">setInterval(function(){ </div><div class="t m0 x0 hb y3505 ffc8 fs6 fc0 sc0 ls21 wsb">    curtime.innerHTML = player.currentTime; </div><div class="t m0 x0 hb y3506 ffc8 fs6 fc0 sc0 ls21 wsb">}, 250); </div><div class="t m0 x0 hb y3507 ffc8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1502 ffcd fs2 fc0 sc0 ls79 wsb">VideoPlayerExample01.htm </div><div class="t m0 x0 h5 y2be6 ffc7 fs2 fc0 sc0 ls8 ws1">以上JavaScript代码给按钮添加了一个事件处理程序，单击它能让视频在暂停时播放，在播放时暂</div><div class="t m0 x0 h4 y14da ffc7 fs2 fc0 sc0 ls8 ws1">停。通过&lt;video&gt;元素的load事件处理程序，设置了加载完视频后显示播放时间。最后，设置了一个</div><div class="t m0 x0 h4 y3508 ffc7 fs2 fc0 sc0 ls8 ws1">计时器，以更新当前显示的时间。你可以进一步扩展这个视频播放器，监听更多事件，利用更多属性。</div><div class="t m0 x0 he y3509 ffc7 fs2 fc0 sc0 ls8 ws1">而同样的代码也可以用于&lt;audio&gt;元素，以创建自定义的音频播放器。 </div><div class="t m0 x0 h20 y350a ffc5 fs3 fc0 sc0 ls248 ws214">16.3.4 检测编解码器的支持情况 </div><div class="t m0 x0 h4 y2354 ffc7 fs2 fc0 sc0 ls8 ws1">如前所述，并非所有浏览器都支持&lt;video&gt;和&lt;audio&gt;的所有编解码器，而这基本上就意味着你必</div><div class="t m0 x0 h5 y2355 ffc7 fs2 fc0 sc0 ls8 ws1">须提供多个媒体来源。不过，也有一个JavaScript API能够检测浏览器是否支持某种格式和编解码器。</div></div></div>
<div id="pf1fc" class="pf w0 h0" data-page-no="1fc"><div class="pc pc1fc w0 h0"><div class="t m0 x0 h2 y1 ffc1 fs0 fc0 sc0 ls7 ws0">490  第16章 HTML5脚本编程 </div><div class="t m0 x0 h3 y2 ffc1 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ffc7 fs2 fc0 sc0 ls2a1 ws261">这两个媒体元素都有一个canPlayType()方法，该方法接收一种格式/编解码器字符串，返回</div><div class="t m0 x0 h5 y4 ffc8 fs1 fc0 sc0 ls9 ws2">&quot;probably&quot;、&quot;maybe&quot;或&quot;&quot;（ 空字符串）。空字符串是假值，因此可以像下面这样在if语句中使用</div><div class="t m0 x0 h5 y4e ffc8 fs1 fc0 sc0 ls9 ws2">canPlayType()： </div><div class="t m0 x0 hb y6bd ffc8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y6be ffc8 fs6 fc0 sc0 ls21 wsb">if (audio.canPlayType(&quot;audio/mpeg&quot;)){ </div><div class="t m0 x0 h34 y6bf ffc8 fs6 fc0 sc0 ls21 wsb">    //进一步处理 </div><div class="t m0 x0 hb y6c0 ffc8 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y302f ffc8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y2321 ffc7 fs2 fc0 sc0 ls8 ws1">而&quot;probably&quot;和&quot;maybe&quot;都是真值，因此在if语句的条件测试中可以转换成true。 </div><div class="t m0 x0 hc y2733 ffc7 fs2 fc0 sc0 ls8 ws1">如果给canPlayType()传入了一种MIME类型，则返回值很可能是&quot;maybe&quot;或空字符串。这是因</div><div class="t m0 x0 h4 y2734 ffc7 fs2 fc0 sc0 ls8 ws1">为媒体文件本身只不过是音频或视频的一个容器，而真正决定文件能否播放的还是编码的格式。在同时</div><div class="t m0 x0 h5 y350c ffc7 fs2 fc0 sc0 ls8 ws1">传入MIME类型和编解码器的情况下，可能性就会增加，返回的字符串会变成&quot;probably&quot;。下面来看</div><div class="t m0 x0 h5 y147e ffc7 fs2 fc0 sc0 ls8 ws1">几个例子。 </div><div class="t m0 x0 hb y18a9 ffc8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y18aa ffc8 fs6 fc0 sc0 ls21 wsb">var audio = document.getElementById(&quot;audio-player&quot;); </div><div class="t m0 x0 hb y18ab ffc8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y18ac ffc8 fs6 fc0 sc0 ls21">//很可能&quot;maybe&quot; </div><div class="t m0 x0 hb y350d ffc8 fs6 fc0 sc0 ls21 wsb">if (audio.canPlayType(&quot;audio/mpeg&quot;)){ </div><div class="t m0 x0 h34 y350e ffc8 fs6 fc0 sc0 ls21 wsb">    //进一步处理 </div><div class="t m0 x0 hb y350f ffc8 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y3510 ffc8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h34 y3511 ffc8 fs6 fc0 sc0 ls21">//可能是&quot;probably&quot; </div><div class="t m0 x0 hb y3512 ffc8 fs6 fc0 sc0 ls21 wsb">if (audio.canPlayType(&quot;audio/ogg; codecs=\&quot;vorbis\&quot;&quot;)){ </div><div class="t m0 x0 h34 y3513 ffc8 fs6 fc0 sc0 ls21 wsb">    //进一步处理 </div><div class="t m0 x0 h36 y3514 ffc8 fs6 fc0 sc0 ls16f">}  </div><div class="t m0 x0 h5 y3515 ffc7 fs2 fc0 sc0 ls8 ws1">注意，编解码器必须用引号引起来才行。下表列出了已知的已得到支持的音频格式和编解码器。 </div><div class="t m0 x0 h5 y3516 ffc1 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h31 y2ed8 ffc4 fs6 fc0 sc0 lsa7 wsb">音  频 字 符 串 支持的浏览器 </div><div class="t m0 x0 h36 y3517 ffc1 fs6 fc0 sc0 ls1b6 wsb">AAC  audio/mp4; codecs=&quot;mp4a.40.2&quot;  IE9+、Safari 4+、iOS版Safari </div><div class="t m0 x0 h36 y1a93 ffc1 fs6 fc0 sc0 ls279 wsb">MP3  audio/mpeg  IE9+、Chrome </div><div class="t m0 x0 h36 y3518 ffc1 fs6 fc0 sc0 ls1bf wsb">Vorbis  audio/ogg; codecs=&quot;vorbis&quot;  Firefox 3.5+、Chrome、Opera 10.5+ </div><div class="t m0 x0 h36 y3519 ffc1 fs6 fc0 sc0 ls409 wsb">WAV  audio/wav; codecs=&quot;1&quot;  Firefox 3.5+、Opera 10.5+、Chrome </div><div class="t m0 x0 h5 y351a ffc1 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y351b ffc7 fs2 fc0 sc0 ls8 ws1">当然，也可以使用canPlayType()来检测视频格式。下表列出了已知的已得到支持的音频格式和</div><div class="t m0 x0 h5 y351c ffc7 fs2 fc0 sc0 ls8 ws1">编解码器。 </div><div class="t m0 x0 h5 y351d ffc1 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h31 y2ae5 ffc4 fs6 fc0 sc0 lsa7 wsb">视  频 字 符 串 支持的浏览器 </div><div class="t m0 x0 h36 y1d87 ffc1 fs6 fc0 sc0 ls22f wsb">H.264  video/mp4; codecs=&quot;avc1.42E01E, mp4a.40.2&quot;  IE9 +、Safari 4+、iOS版Safari、Android</div><div class="t m0 x4 h36 y351e ffc7 fs6 fc0 sc0 ls95">版WebKit </div><div class="t m0 x0 h36 y379 ffc1 fs6 fc0 sc0 lsab wsb">Theora  video/ogg; codecs=&quot;theora&quot;  Firefox 3.5+、Opera 10.5、Chrome </div><div class="t m0 x0 h36 y351f ffc1 fs6 fc0 sc0 ls214 wsb">WebM  video/webm; codecs=&quot;vp8, vorbis&quot;  Firefox 4+、Opera 10.6、Chrome </div><div class="t m0 x0 h20 y166b ffc5 fs3 fc0 sc0 ls248 ws214">16.3.5 Audio类型 </div><div class="t m0 x0 h5 y3520 ffc8 fs1 fc0 sc0 ls9 ws2">&lt;audio&gt;元素还有一个原生的JavaScript构造函数Audio，可以在任何时候播放音频。从同为DOM</div><div class="t m0 x0 h4 y3521 ffc7 fs2 fc0 sc0 ls8 ws1">元素的角度看，Audio与Image很相似，但Audio不用像Image 那样必须插入到文档中。只要创建一</div></div></div>
<div id="pf1fd" class="pf w0 h0" data-page-no="1fd"><div class="pc pc1fd w0 h0"><div class="t m0 x2 h2 y1 ffc1 fs0 fc0 sc0 ls7 ws0">16.4 历史状态管理    491 </div><div class="t m0 x0 h3 y2 ffc1 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffcb fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ffcb fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ffcb fs3 fc2 sc0 ls1d wsb">16 </div><div class="t m0 x3 h8 y20 ffcb fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ffcb fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffcb fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffcb fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffcb fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffcb fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffcb fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffcb fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ffcb fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ffcb fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ffc7 fs2 fc0 sc0 ls8 ws1">个新实例，并传入音频源文件即可。 </div><div class="t m0 x0 hb yfb2 ffc8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yfb3 ffc8 fs6 fc0 sc0 ls21 wsb">var audio = new Audio(&quot;sound.mp3&quot;); </div><div class="t m0 x0 hb yfb4 ffc8 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(audio, &quot;canplaythrough&quot;, function(event){ </div><div class="t m0 x0 hb yfb5 ffc8 fs6 fc0 sc0 ls21 wsb">    audio.play(); </div><div class="t m0 x0 hb yfb6 ffc8 fs6 fc0 sc0 ls21 wsb">});  </div><div class="t m0 x0 hb y3522 ffc8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3523 ffc7 fs2 fc0 sc0 ls8 ws1">创建新的Audio实例即可开始下载指定的文件。下载完成后，调用play()就可以播放音频。 </div><div class="t m0 x0 h5 y1707 ffc7 fs2 fc0 sc0 ls141">在iOS中，调用play()时会弹出一个对话框，得到用户的许可后才能播放声音。如果想在一段音</div><div class="t m0 x0 hc y1708 ffc7 fs2 fc0 sc0 ls8 ws1">频播放后再播放另一段音频，必须在onfinish事件处理程序中调用play()方法。 </div><div class="t m0 x0 hd y10b5 ffc5 fs7 fc0 sc0 ls245">16.4 历史状态管理 </div><div class="t m0 x0 h5 y1dfe ffc7 fs2 fc0 sc0 ls8 ws1">历史状态管理是现代Web应用开发中的一个难点。在现代Web 应用中，用户的每次操作不一定会</div><div class="t m0 x0 h4 y3524 ffc7 fs2 fc0 sc0 ls8 ws1">打开一个全新的页面，因此“后退”和“前进”按钮也就失去了作用，导致用户很难在不同状态间切换。</div><div class="t m0 x0 he y3525 ffc7 fs2 fc0 sc0 ls8 ws1">要解决这个问题，首选使用hashchange事件（第13章曾讨论过）。HTML5通过更新history对象为</div><div class="t m0 x0 h5 y3526 ffc7 fs2 fc0 sc0 ls8 ws1">管理历史状态提供了方便。 </div><div class="t m0 x0 hc y3195 ffc7 fs2 fc0 sc0 ls8 ws1">通过hashchange事件，可以知道URL的参数什么时候发生了变化，即什么时候该有所反应。而</div><div class="t m0 x0 h5 y338f ffc7 fs2 fc0 sc0 ls371 ws374">通过状态管理API，能够在不加载新页面的情况下改变浏览器的URL 。为此，需要使用</div><div class="t m0 x0 h5 y10b9 ffc8 fs1 fc0 sc0 ls9 ws2">history.pushState()方法，该方法可以接收三个参数：状态对象、新状态的标题和可选的相对URL。</div><div class="t m0 x0 h5 y10ba ffc7 fs2 fc0 sc0 ls8">例如： </div><div class="t m0 x0 hb y3199 ffc8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y319a ffc8 fs6 fc0 sc0 ls21 wsb">history.pushState({name:&quot;Nicholas&quot;}, &quot;Nicholas&apos; page&quot;, &quot;nicholas.html&quot;); </div><div class="t m0 x0 hb y3527 ffc8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 yef6 ffc7 fs2 fc0 sc0 ls8 ws1">执行pushState()方法后，新的状态信息就会被加入历史状态栈，而浏览器地址栏也会变成新的</div><div class="t m0 x0 h5 y3528 ffc7 fs2 fc0 sc0 ls8 ws1">相对URL。但是，浏览器并不会真的向服务器发送请求，即使状态改变之后查询location.href也会</div><div class="t m0 x0 h4 y3529 ffc7 fs2 fc0 sc0 ls8 ws1">返回与地址栏中相同的地址。另外，第二个参数目前还没有浏览器实现，因此完全可以只传入一个空字</div><div class="t m0 x0 h5 yef9 ffc7 fs2 fc0 sc0 ls8 ws1">符串，或者一个短标题也可以。而第一个参数则应该尽可能提供初始化页面状态所需的各种信息。 </div><div class="t m0 x0 h1c y352a ffc7 fs2 fc0 sc0 ls8 ws1">因为pushState()会创建新的历史状态，所以你会发现“后退”按钮也能使用了。按下“后退”</div><div class="t m0 x0 h69 y352b ffc7 fs2 fc0 sc0 ls8 ws1">按钮，会触发window对象的popstate事件①。popstate 事件的事件对象有一个state属性，这个</div><div class="t m0 x0 hc y352c ffc7 fs2 fc0 sc0 ls8 ws1">属性就包含着当初以第一个参数传递给pushState()的状态对象。 </div><div class="t m0 x0 hb y14d3 ffc8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y352d ffc8 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(window, &quot;popstate&quot;, function(event){ </div><div class="t m0 x0 hb y352e ffc8 fs6 fc0 sc0 ls21 wsb">    var state = event.state; </div><div class="t m0 x0 h34 y352f ffc8 fs6 fc0 sc0 ls21 wsb">    if (state){   //第一个页面加载时state为空 </div><div class="t m0 x0 hb y3530 ffc8 fs6 fc0 sc0 ls21 wsb">        processState(state); </div><div class="t m0 x0 hb y3531 ffc8 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y3532 ffc8 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 hb y3533 ffc8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3534 ffc7 fs2 fc0 sc0 ls8 ws1">得到这个状态对象后，必须把页面重置为状态对象中的数据表示的状态（因为浏览器不会自动为你</div><div class="t m0 x0 h4 y3535 ffc7 fs2 fc0 sc0 ls6 ws6">做这些）。记住，浏览器加载的第一个页面没有状态，因此单击“后退”按钮返回浏览器加载的第一个</div><div class="t m0 x0 he y3536 ffc7 fs2 fc0 sc0 ls8 ws1">页面时，event.state值为null。 </div><div class="t m0 x0 h1e y3537 ffc7 fs2 fc0 sc0 ls8 ws1">要更新当前状态，可以调用replaceState()，传入的参数与pushState()的前两个参数相同。</div><div class="t m0 x0 h5 y3538 ffc7 fs2 fc0 sc0 ls8 ws1">调用这个方法不会在历史状态栈中创建新状态，只会重写当前状态。 </div><div class="t m0 x0 hb y1d57 ffc8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h3c y2d6 ffc4 fs2 fc0 sc0 ls7b wsb">—————————— </div><div class="t m0 x0 h36 ycc6 ffc7 fs6 fc0 sc0 ls95">① popstate事件发生后，事件对象中的状态对象（event.state）是当前状态。 </div></div></div>
<div id="pf1fe" class="pf w0 h0" data-page-no="1fe"><div class="pc pc1fe w0 h0"><div class="t m0 x0 h2 y1 ffc1 fs0 fc0 sc0 ls7 ws0">492  第16章 HTML5脚本编程 </div><div class="t m0 x0 h3 y2 ffc1 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 ffc8 fs6 fc0 sc0 ls21 wsb">history.replaceState({name:&quot;Greg&quot;}, &quot;Greg&apos;s page&quot;); </div><div class="t m0 x0 hb y1b0b ffc8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1b0c ffc7 fs2 fc0 sc0 ls8 ws1">支持HTML5历史状态管理的浏览器有Firefox 4+、Safari 5+、Opera 11.5+和Chrome。在Safari和</div><div class="t m0 x0 hc y1b0d ffc1 fs2 fc0 sc0 ls50 ws41">Chrome中，传递给pushState()或replaceState()的状态对象中不能包含DOM 元素。而Firefox</div><div class="t m0 x0 h5 y1b0e ffc7 fs2 fc0 sc0 ls8 ws1">支持在状态对象中包含DOM元素。Opera还支持一个history.state 属性，它返回当前状态的状态</div><div class="t m0 x0 h5 y353a ffc7 fs2 fc0 sc0 ls8">对象。 </div><div class="t m0 x5 h5 y353b ffc2 fs2 fc0 sc0 ls8 ws14">在使用HTML5的状态管理机制时，请确保使用pushState()创造的每一个“假”</div><div class="t m0 x0 h5 y353c ffc1 fs2 fc0 sc0 ls50 ws41">URL，在Web服务器上都有一个真的、实际存在的URL与之对应。否则，单击“刷</div><div class="t m0 x0 h5 y353d ffc2 fs2 fc0 sc0 ls8 ws14">新”按钮会导致404错误。 </div><div class="t m0 x0 hd y1ad1 ffc5 fs7 fc0 sc0 ls245">16.5 小结 </div><div class="t m0 x0 h5 y353e ffc1 fs2 fc0 sc0 ls2f ws8a">HTML5除了定义了新的标记规则，还定义了一些JavaScript API。这些API是为了让开发人员创建</div><div class="t m0 x0 h5 y353f ffc7 fs2 fc0 sc0 ls8 ws1">出更好的、能够与桌面应用媲美的用户界面而设计的。本章讨论了如下API。 </div><div class="t m0 x0 h5 y3540 ffc6 fs1 fc0 sc0 ls2"> 跨文档消息传递API能够让我们在不降低同源策略安全性的前提下，在来自不同域的文档间传</div><div class="t m0 x0 h5 y3541 ffc7 fs2 fc0 sc0 ls8">递消息。 </div><div class="t m0 x0 h4 y3333 ffc6 fs1 fc0 sc0 ls2"> 原生拖放功能让我们可以方便地指定某个元素可拖动，并在操作系统要放置时做出响应。还可</div><div class="t m0 x0 h5 y3542 ffc7 fs2 fc0 sc0 ls8 ws1">以创建自定义的可拖动元素及放置目标。 </div><div class="t m0 x0 h5 y3543 ffc6 fs1 fc0 sc0 ls2"> 新的媒体元素&lt;audio&gt;和&lt;video&gt;拥有自己的与音频和视频交互的API。并非所有浏览器支持所</div><div class="t m0 x0 hc y3544 ffc7 fs2 fc0 sc0 ls8 ws1">有的媒体格式，因此应该使用canPlayType()检查浏览器是否支持特定的格式。 </div><div class="t m0 x0 h4 y3545 ffc6 fs1 fc0 sc0 ls2"> 历史状态管理让我们不必卸载当前页面即可修改浏览器的历史状态栈。有了这种机制，用户就</div><div class="t m0 x0 h5 y3546 ffc7 fs2 fc0 sc0 ls8 ws1">可以通过“后退”和“前进”按钮在页面状态间切换，而这些状态完全由JavaScript进行控制。 </div><div class="t m0 x0 h5 y3547 ffc1 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3548 ffc1 fs2 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf1ff" class="pf w0 h0" data-page-no="1ff"><div class="pc pc1ff w0 h0"><div class="t m0 x4 h2 y1 ffcf fs0 fc0 sc0 ls7 ws0">17.1 浏览器报告的错误    493 </div><div class="t m0 x0 h3 y2 ffcf fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffd1 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ffd1 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffd1 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffd1 fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ffd1 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffd1 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffd1 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffd1 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffd1 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffd1 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffd1 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffd1 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ffd1 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h9 y2a ffd2 fs5 fc0 sc0 ls8 wsb">错误处理与调试 </div><div class="t m0 x0 h11a y2e94 ffd3 fs17 fc0 sc0 ls8">本章内容 </div><div class="t m0 x0 h5 y3549 ffd5 fs1 fc0 sc0 ls2"> 理解浏览器报告的错误 </div><div class="t m0 x0 h5 y354a ffd5 fs1 fc0 sc0 ls2"> 处理错误 </div><div class="t m0 x0 h5 y354b ffd5 fs1 fc0 sc0 ls2"> 调试JavaScript代码 </div><div class="t m0 x0 h5 y354c ffcf fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x5 h5 y354d ffd6 fs2 fc0 sc0 ls3b">于JavaScript本身是动态语言，而且多年来一直没有固定的开发工具，因此人们普遍认为它是</div><div class="t m0 x5 h5 y354e ffd6 fs2 fc0 sc0 ls8 wseb">一种最难于调试的编程语言。脚本出错时，浏览器通常会给出类似于“object expected”（缺少</div><div class="t m0 x0 h5 y354f ffd6 fs2 fc0 sc0 ls8 wseb">对象）这样的消息，没有上下文信息，让人摸不着头脑。ECMAScript第3版致力于解决这个问题，专</div><div class="t m0 x0 h11b y3550 ffd6 fs2 fc0 sc0 ls8 wseb">门引入了try-catch和throw语句以及一些错误类型，意在让开发人员能够适当地处理错误。几年之</div><div class="t m0 x0 h5 y3551 ffd6 fs2 fc0 sc0 ls8 wseb">后，Web浏览器中也出现了一些JavaScript调试程序和工具。2008年以来，大多数Web浏览器都已经具</div><div class="t m0 x0 h5 y3552 ffd6 fs2 fc0 sc0 ls8 wseb">备了一些调试JavaScript代码的能力。 </div><div class="t m0 x0 h4 y3553 ffd6 fs2 fc0 sc0 ls8 wseb">在有了语言特性和工具支持之后，现在的开发人员已经能够适当地实现错误处理，并且能够找到错</div><div class="t m0 x0 h5 y3554 ffd6 fs2 fc0 sc0 ls8 wseb">误的根源。 </div><div class="t m0 x0 hd y3555 ffd4 fs7 fc0 sc0 ls245">17.1 浏览器报告的错误 </div><div class="t m0 x0 h5 y1b84 ffcf fs2 fc0 sc0 ls2dc">IE、Firefox、Safari、Chrome和Opera等主流浏览器，都具有某种向用户报告JavaScript错误的机</div><div class="t m0 x0 h4 y4b9 ffd6 fs2 fc0 sc0 ls24">制。默认情况下，所有浏览器都会隐藏此类信息，毕竟除了开发人员之外，很少有人关心这些内容。</div><div class="t m0 x0 h5 y4ba ffd6 fs2 fc0 sc0 ls5 wsec">因此，在基于浏览器编写JavaScript脚本时，别忘了启用浏览器的JavaScript报告功能，以便及时收到</div><div class="t m0 x0 h5 y4bb ffd6 fs2 fc0 sc0 ls5 wsec">错误通知。 </div><div class="t m0 x0 h20 y3556 ffd4 fs3 fc0 sc0 ls248 ws214">17.1.1 IE </div><div class="t m0 x0 h5 y3557 ffcf fs2 fc0 sc0 lse ws9">IE是唯一一个在浏览器的界面窗体（chrome）中显示JavaScript错误信息的浏览器。在发生JavaScript</div><div class="t m0 x0 h4 y3558 ffd6 fs2 fc0 sc0 ls8 wseb">错误时，浏览器左下角会出现一个黄色的图标，图标旁边则显示着&quot;Error on page&quot;（页面中有错误）。</div><div class="t m0 x0 h4 y3559 ffd6 fs2 fc0 sc0 ls8 wseb">假如不是存心去看的话，你很可能不会注意这个图标。双击这个图标，就会看到一个包含错误消息的对</div><div class="t m0 x0 h5 y355a ffd6 fs2 fc0 sc0 ls8 wseb">话框，其中还包含诸如行号、字符数、错误代码及文件名（其实就是你在查看的页面的URL）等相关信</div><div class="t m0 x0 h5 y355b ffd6 fs2 fc0 sc0 ls8 wseb">息。图17-1展示了IE的错误消息对话框。 </div><div class="t m0 x0 h5 y355c ffd6 fs2 fc0 sc0 ls8 wseb">这些信息对于一般用户还算说得过去，但对Web开发来说就远远不够了。可以通过设置让错误对</div><div class="t m0 x0 h5 y355d ffd6 fs2 fc0 sc0 ls8 wseb">话框一发生错误就显示出来。为此，要打开“Tools”（工具）菜单中的“Internet Options”（Internet 选项）</div><div class="t m0 x0 h5 y355e ffd6 fs2 fc0 sc0 ls8 wseb">对话框，切换到“Advanced”（高级）选项卡，选中“Display a notification about every script error”（显</div><div class="t m0 x0 h5 y355f ffd6 fs2 fc0 sc0 ls8 wseb">示每个脚本错误的通知）复选框（参见图17-2）。单击“OK”（确定）按钮保存设置。 </div><div class="t m0 x0 h92 y3560 ffd3 fs12 fc0 sc0 ls8 wsb">由 </div><div class="t m0 x0 h11 y4b ffd8 fsa fc0 sc0 ls8">第</div><div class="t m1 x0 h12 y4b ffd9 fsb fc3 sc0 ls247">17</div><div class="t m0 x5 h11 y4b ffd8 fsa fc0 sc0 ls8 ws1d">章 </div></div></div>
<div id="pf200" class="pf w0 h0" data-page-no="200"><div class="pc pc200 w0 h0"><div class="t m0 x0 h2 y1 ffcf fs0 fc0 sc0 ls7 ws0">494  第17章 错误处理与调试 </div><div class="t m0 x0 h3 y2 ffcf fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 h5 y3562 ffcf fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x7 h3 y3563 ffd6 fs1 fc0 sc0 ls8 wsb">图 17-1 </div><div class="t m0 x2 h11d y3564 ffda fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x7 h3 y3565 ffd6 fs1 fc0 sc0 ls8 wsb">图 17-2 </div><div class="t m0 x0 h4 y120d ffd6 fs2 fc0 sc0 ls4">保存了设置之后，通常要双击黄色图标才会显示的对话</div><div class="t m0 x0 h5 y261a ffd6 fs2 fc0 sc0 lsa ws10a">框，就会变成一有错误发生随即自动显示出来。 </div><div class="t m0 x0 h4 y3566 ffd6 fs2 fc0 sc0 ls8 wseb">另外，如果启用了脚本调试功能的话（默认是禁用的），那</div><div class="t m0 x0 h4 y3567 ffd6 fs2 fc0 sc0 ls8 wseb">么在发生错误时，你不仅会显示错误通知，而且还会看到另一</div><div class="t m0 x0 h5 y3568 ffd6 fs2 fc0 sc0 ls8 wseb">个对话框，询问是否想要调试错误（参见图17-3）。 </div><div class="t m0 x0 h5 y3569 ffd6 fs2 fc0 sc0 ls6 wsf7">要启用脚本调试功能，必须要在IE中安装某种脚本调试</div><div class="t m0 x0 h5 y356a ffd6 fs2 fc0 sc0 ls8 wseb">器。（IE8和IE9自带调试器。）本章后面会单独讨论调试器。 </div><div class="t m0 x0 hb y356b ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x5 h5 y356c ffd0 fs2 fc0 sc0 ls93">在IE7及更早版本中，如果错误发生在位于外部文件的脚本中，行号通常会与</div><div class="t m0 x0 h5 y356d ffd0 fs2 fc0 sc0 ls5 wsd7">错误所在的行号差1。如果是嵌入在页面中的脚本发生错误，则行号就是错误所在的</div><div class="t m0 x0 h5 y356e ffd0 fs2 fc0 sc0 ls5">行号。 </div><div class="t m0 x0 h20 y356f ffd4 fs3 fc0 sc0 ls248 ws214">17.1.2 Firefox </div><div class="t m0 x0 h5 y1aa1 ffd6 fs2 fc0 sc0 ls8 wseb">默认情况下，Firefox在JavaScript发生错误时不会通过浏览器界面给出提示。但它会在后台将错误</div><div class="t m0 x6 h5 y1d50 ffcf fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 h3 yd16 ffd6 fs1 fc0 sc0 ls8 wsb">图 17-3 </div></div></div>
<div id="pf201" class="pf w0 h0" data-page-no="201"><div class="pc pc201 w0 h0"><div class="t m0 x4 h2 y1 ffcf fs0 fc0 sc0 ls7 ws0">17.1 浏览器报告的错误    495 </div><div class="t m0 x0 h3 y2 ffcf fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffd1 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ffd1 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffd1 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffd1 fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ffd1 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffd1 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffd1 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffd1 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffd1 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffd1 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffd1 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffd1 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ffd1 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ffd6 fs2 fc0 sc0 ls8 wseb">记录到错误控制台中。单击“Tools”（工具）菜单中的“Error Console”（错误控制台）可以显示错误控</div><div class="t m0 x0 h5 y4d ffd6 fs2 fc0 sc0 ls8 wseb">制台（见图17-4）。你会发现，错误控制台中实际上还包含与JavaScript、CSS和HTML相关的警告和</div><div class="t m0 x0 h5 yd8 ffd6 fs2 fc0 sc0 ls8 wseb">信息，可以通过筛选找到错误。 </div><div class="t m0 x2 h5 y1f39 ffcf fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 h3 y3570 ffd6 fs1 fc0 sc0 ls8 wsb">图 17-4 </div><div class="t m0 x0 h5 y9c9 ffd6 fs2 fc0 sc0 ls8 wseb">在发生JavaScript错误时，Firefox会将其记录为一个错误，包括错误消息、引发错误的URL和错误</div><div class="t m0 x0 h5 y3571 ffd6 fs2 fc0 sc0 ls8 wseb">所在的行号等信息。单击文件名即可以只读方式打开发生错误的脚本，发生错误的代码行会突出显示。 </div><div class="t m0 x0 h5 y3572 ffd6 fs2 fc0 sc0 ls8 wseb">目前，最流行的Firefox插件Firebug，已经成为开发人员必备的 JavaScript纠错工具。这个可以从</div><div class="t m0 x0 h5 y3573 ffcf fs2 fc0 sc0 ls15 ws13">www.getfirebug.com下载到的插件，会在Firefox状态栏的右下角区域添加一个图标。默认情况下，右下</div><div class="t m0 x0 h5 y3574 ffd6 fs2 fc0 sc0 ls8 wseb">角区域显示的是一个绿色对勾图标。在有JavaScript错误发生时，图标会变成红叉，同时旁边显示错误</div><div class="t m0 x0 h5 y3575 ffd6 fs2 fc0 sc0 ls8 wseb">的数量。单击这个红叉会打开Firebug控制台，其中显示有错误消息、错误所在的代码行（不包含上下</div><div class="t m0 x0 h5 y3576 ffd6 fs2 fc0 sc0 ls8 wseb">文）、错误所在的URL以及行号（参见图17-5）。 </div><div class="t m0 x2 h5 y3577 ffcf fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 h3 y241c ffd6 fs1 fc0 sc0 ls8 wsb">图 17-5 </div></div></div>
<div id="pf202" class="pf w0 h0" data-page-no="202"><div class="pc pc202 w0 h0"><div class="t m0 x0 h2 y1 ffcf fs0 fc0 sc0 ls7 ws0">496  第17章 错误处理与调试 </div><div class="t m0 x0 h3 y2 ffcf fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ffd6 fs2 fc0 sc0 ls3b">在Firebug中单击导致错误的代码行，将在一个新Firebug视图中打开整个脚本，该代码行在其中突</div><div class="t m0 x0 h5 y4d ffd6 fs2 fc0 sc0 ls8">出显示。 </div><div class="t m0 x5 h5 y3579 ffd0 fs2 fc0 sc0 ls8 ws14">除了显示错误之外，Firebug还有更多的用处。实际上，它还是针对Firefox的成</div><div class="t m0 x0 h5 y357a ffd0 fs2 fc0 sc0 ls8 ws14">熟的调试环境，为调试JavaScript、CSS、DOM和网络连接错误提供了诸多功能。 </div><div class="t m0 x0 h20 y357b ffd4 fs3 fc0 sc0 ls248 ws214">17.1.3 Safari </div><div class="t m0 x0 h5 y357c ffcf fs2 fc0 sc0 ls1b1 ws37a">Windows和Mac OS平台的Safari在默认情况下都会隐藏全部JavaScript错误。为了访问到这些信</div><div class="t m0 x0 h5 y357d ffd6 fs2 fc0 sc0 ls5 wsec">息，必须启用“Develop”（开发）菜单。为此，需要单击“Edit”（编辑）菜单中的“Preferences”（偏</div><div class="t m0 x0 h5 y357e ffd6 fs2 fc0 sc0 ls5 wsec">好设置），然后在“Advanced”（高级）选项卡中，选中“Show develop menu in menubar”（在菜单栏中</div><div class="t m0 x0 h5 y357f ffd6 fs2 fc0 sc0 ls5 wsec">显示“开发”菜单）。启用此项设置之后，就会在Safari的菜单栏中看到一个“Develop”菜单（参见</div><div class="t m0 x0 h5 y3580 ffd6 fs2 fc0 sc0 ls8d">图17-6）。 </div><div class="t m0 x6 h5 y3581 ffcf fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x7 h3 y2c21 ffd6 fs1 fc0 sc0 ls8 wsb">图 17-6 </div><div class="t m0 x0 h5 y3582 ffd6 fs2 fc0 sc0 ls24">“Develop”菜单中提供了一些与调试有关的选项，还有一些选项可以影响当前加载的页面。单击</div><div class="t m0 x0 h5 y3583 ffd6 fs2 fc0 sc0 ls8">“Show Error Console”（显示错误控制台）选项，将会看到一组JavaScript及其他错误。控制台中显示着</div><div class="t m0 x0 h5 y3584 ffd6 fs2 fc0 sc0 ls8 wseb">错误消息、错误的URL及错误的行号（参见图17-7）。 </div><div class="t m0 x0 h5 y3585 ffd6 fs2 fc0 sc0 ls24 wsf5">单击控制台中的错误消息，就可以打开导致错误的源代码。除了被输出到控制台之外，JavaScript</div><div class="t m0 x0 h5 y3586 ffd6 fs2 fc0 sc0 ls8 wseb">错误不会影响Safari窗口的外观。 </div></div></div>
<div id="pf203" class="pf w0 h0" data-page-no="203"><div class="pc pc203 w0 h0"><div class="t m0 x4 h2 y1 ffcf fs0 fc0 sc0 ls7 ws0">17.1 浏览器报告的错误    497 </div><div class="t m0 x0 h3 y2 ffcf fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffd1 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ffd1 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffd1 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffd1 fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ffd1 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffd1 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffd1 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffd1 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffd1 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffd1 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffd1 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffd1 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ffd1 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x6 h5 y3587 ffcf fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 h3 y2227 ffd6 fs1 fc0 sc0 ls8 wsb">图 17-7 </div><div class="t m0 x0 h20 y3588 ffd4 fs3 fc0 sc0 ls248 ws214">17.1.4 Opera </div><div class="t m0 x0 h5 y3589 ffcf fs2 fc0 sc0 ls2b ws22">Opera在默认情况下也会隐藏JavaScript错误，所有错误都会被记录到错误控制台中。要打开错误</div><div class="t m0 x0 h5 y358a ffd6 fs2 fc0 sc0 ls8 wseb">控制台，需要单击“Tools”（工具）菜单，在“Advanced”（高级）子菜单项下面再单击“Error Console”</div><div class="t m0 x0 h5 y358b ffd6 fs2 fc0 sc0 ls8 wseb">（错误控制台）。与Firefox一样，Opera的错误控制台中也包含了除JavaScript错误之外的很多来源（如</div><div class="t m0 x0 h5 y358c ffcf fs2 fc0 sc0 lsfa wsc9">HTML、CSS、XML、XSLT等）的错误和警告信息。要分类查看不同来源的消息，可以使用左下角的</div><div class="t m0 x0 h5 y358d ffd6 fs2 fc0 sc0 ls8 wseb">下拉选择框（参见图17-8）。 </div><div class="t m0 x0 h5 y358e ffd6 fs2 fc0 sc0 ls8 wseb">错误消息中显示着导致错误的URL和错误所在的线程。有时候，还会有栈跟踪信息。除了错误控</div><div class="t m0 x0 h5 y358f ffd6 fs2 fc0 sc0 ls8 wseb">制台中显示的信息之外，没有其他途径可以获得更多信息。 </div><div class="t m0 x0 h5 y3590 ffd6 fs2 fc0 sc0 ls8 wseb">也可以让Opera一发生错误就弹出错误控制台。为此，要在“Tools”（工具）菜单中单击“Preferences”</div><div class="t m0 x0 h5 y3591 ffd6 fs2 fc0 sc0 ls8 wseb">（首选项），再单击“Advanced”（高级）选项卡，然后从左侧菜单中选择“Content”（内容）。单击“JavaScrip </div><div class="t m0 x0 h5 y3592 ffcf fs2 fc0 sc0 ls25 wsb3">Options”（JavaScript 选项）按钮，显示选项对话框（如图17-9所示）。 </div><div class="t m0 x0 h5 y3593 ffd6 fs2 fc0 sc0 ls30 wsf6">在这个选项对话框中，选中“Open console on error”（出错时打开控制台），单击“OK”（确定）</div><div class="t m0 x0 h5 y3594 ffd6 fs2 fc0 sc0 ls30 wsf6">按钮。这样，每当发生JavaScript错误时，就会弹出错误控制台。另外，还可以针对特定的站点来作</div><div class="t m0 x0 h5 y3595 ffd6 fs2 fc0 sc0 ls30 wsf6">此设置，方法是单击“Tools”（工具）、“Quick Preferences”（快速参数）、“Edit Site Preferences”（编</div><div class="t m0 x0 h11f y3596 ffd6 fs2 fc0 sc0 ls415">辑站点首选项），选择“Scripting”（脚本）选项卡，最后选中“Open console on error”（出错时打开</div><div class="t m0 x0 h5 y3597 ffd6 fs2 fc0 sc0 ls30 wsf6">控制台）。 </div></div></div>
<div id="pf204" class="pf w0 h0" data-page-no="204"><div class="pc pc204 w0 h0"><div class="t m0 x0 h2 y1 ffcf fs0 fc0 sc0 ls7 ws0">498  第17章 错误处理与调试 </div><div class="t m0 x0 h3 y2 ffcf fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 h5 y3599 ffcf fs2 fc0 sc0 ls8 wsb">   </div><div class="t m0 x1 h3 y359a ffd6 fs1 fc0 sc0 ls8 wsb">图 17-8  图 17-9 </div><div class="t m0 x0 h20 y323e ffd4 fs3 fc0 sc0 ls248 ws214">17.1.5 Chrome </div><div class="t m0 x0 h5 y359b ffd6 fs2 fc0 sc0 ls25c">与Safari和Opera一样，Chrome在默认情况下也会隐藏 JavaScript错误。所有错误都将被记录到</div><div class="t m0 x0 h5 y359c ffcf fs2 fc0 sc0 lsb ws384">Web Inspector控制台中。要查看错误消息，必须打开Web Inspector。为此，要单击位于地址栏右侧的</div><div class="t m0 x0 h5 y359d ffd6 fs2 fc0 sc0 ls8">“Control this page”（控制当前页）按钮，选择“Developer”（开发人员）、“JavaScript console”（JavaScript </div><div class="t m0 x0 h5 y359e ffd6 fs2 fc0 sc0 ls8 wseb">控制台），参见图17-10。 </div><div class="t m0 x2 h5 y26d7 ffcf fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x7 h3 y359f ffd6 fs1 fc0 sc0 ls8 wsb">图 17-10 </div></div></div>
<div id="pf205" class="pf w0 h0" data-page-no="205"><div class="pc pc205 w0 h0"><div class="t m0 x2 h2 y1 ffcf fs0 fc0 sc0 ls7 ws0">17.2 错误处理    499 </div><div class="t m0 x0 h3 y2 ffcf fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffd1 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ffd1 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffd1 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffd1 fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ffd1 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffd1 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffd1 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffd1 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffd1 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffd1 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffd1 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffd1 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ffd1 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ffd6 fs2 fc0 sc0 ls8 wseb">打开的Web Inspector中包含着有关页面的信息和JavaScript控制台。控制台中显示着错误消息、错</div><div class="t m0 x0 h5 y4d ffd6 fs2 fc0 sc0 ls8 wseb">误的URL和错误的行号（参见图17-11）。 </div><div class="t m0 x2 h5 y2a1a ffcf fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 h3 y35a0 ffd6 fs1 fc0 sc0 ls8 wsb">图 17-11 </div><div class="t m0 x0 h5 y273c ffd6 fs2 fc0 sc0 ls8 wseb">单击JavaScript控制台中的错误，就可以定位到导致错误的源代码行。 </div><div class="t m0 x0 hd y35a1 ffd4 fs7 fc0 sc0 ls245">17.2 错误处理 </div><div class="t m0 x0 h5 y14b3 ffd6 fs2 fc0 sc0 ls8 wseb">错误处理在程序设计中的重要性是勿庸置疑的。任何有影响力的Web应用程序都需要一套完善的</div><div class="t m0 x0 h4 y35a2 ffd6 fs2 fc0 sc0 ls8 wseb">错误处理机制，当然，大多数佼佼者确实做到了这一点，但通常只有服务器端应用程序才能做到如此。</div><div class="t m0 x0 h4 y35a3 ffd6 fs2 fc0 sc0 ls8 wseb">实际上，服务器端团队往往会在错误处理机制上投入较大的精力，通常要考虑按照类型、频率，或者其</div><div class="t m0 x0 h4 y35a4 ffd6 fs2 fc0 sc0 ls8 wseb">他重要的标准对错误进行分类。这样一来，开发人员就能够理解用户在使用简单数据库查询或者报告生</div><div class="t m0 x0 h5 y35a5 ffd6 fs2 fc0 sc0 ls8 wseb">成脚本时，应用程序可能会出现的问题。 </div><div class="t m0 x0 h4 y35a6 ffd6 fs2 fc0 sc0 ls8 wseb">虽然客户端应用程序的错误处理也同样重要，但真正受到重视，还是最近几年的事。实际上，我们</div><div class="t m0 x0 h5 y35a7 ffd6 fs2 fc0 sc0 ls8 wseb">要面对这样一个不争的事实：使用Web的绝大多数人都不是技术高手，其中甚至有很多人根本就不明</div><div class="t m0 x0 h5 y35a8 ffd6 fs2 fc0 sc0 ls8 wseb">白浏览器到底是什么，更不用说让他们说喜欢哪一个了。本章前面讨论过，每个浏览器在发生JavaScript</div><div class="t m0 x0 h5 y35a9 ffd6 fs2 fc0 sc0 ls8 wseb">错误时的行为都或多或少有一些差异。有的会显示小图标，有的则什么动静也没有，浏览器对JavaScript</div><div class="t m0 x0 h4 y35aa ffd6 fs2 fc0 sc0 ls8 wseb">错误的这些默认行为对最终用户而言，毫无规律可循。最理想的情况下，用户遇到错误搞不清为什么，</div></div></div>
<div id="pf206" class="pf w0 h0" data-page-no="206"><div class="pc pc206 w0 h0"><div class="t m0 x0 h2 y1 ffcf fs0 fc0 sc0 ls7 ws0">500  第17章 错误处理与调试 </div><div class="t m0 x0 h3 y2 ffcf fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ffd6 fs2 fc0 sc0 ls8 wseb">他们会再试着重做一次；最糟糕的情况下，用户会恼羞成怒，一去不复返了。良好的错误处理机制可以</div><div class="t m0 x0 h4 y4d ffd6 fs2 fc0 sc0 ls8 wseb">让用户及时得到提醒，知道到底发生了什么事，因而不会惊惶失措。为此，作为开发人员，我们必须理</div><div class="t m0 x0 h5 yd8 ffd6 fs2 fc0 sc0 ls8 wseb">解在处理JavaScript错误的时候，都有哪些手段和工具可以利用。 </div><div class="t m0 x0 h20 y1008 ffd4 fs3 fc0 sc0 ls248 ws214">17.2.1 try-catch语句 </div><div class="t m0 x0 h5 y1f4 ffcf fs2 fc0 sc0 ls5e ws66">ECMA-262第3版引入了try-catch语句，作为JavaScript中处理异常的一种标准方式。基本的语</div><div class="t m0 x0 hc y1f5 ffd6 fs2 fc0 sc0 ls8 wseb">法如下所示，显而易见，这与Java中的try-catch语句是完全相同的。 </div><div class="t m0 x0 hb yc80 ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1e44 ffd7 fs6 fc0 sc0 ls21 wsb">try{ </div><div class="t m0 x0 h16 y1e45 ffd7 fs6 fc0 sc0 ls21 wsb">    // 可能会导致错误的代码 </div><div class="t m0 x0 hb y35ac ffd7 fs6 fc0 sc0 ls21 wsb">} catch(error){ </div><div class="t m0 x0 h16 y35ad ffd7 fs6 fc0 sc0 ls21 wsb">    // 在错误发生时怎么处理 </div><div class="t m0 x0 hb y35ae ffd7 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h4 y35e ffd6 fs2 fc0 sc0 ls8 wseb">也就是说，我们应该把所有可能会抛出错误的代码都放在try语句块中，而把那些用于错误处理的</div><div class="t m0 x0 hc y35f ffd6 fs2 fc0 sc0 ls8 wseb">代码放在catch块中。例如： </div><div class="t m0 x0 hb y386 ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y35af ffd7 fs6 fc0 sc0 ls21 wsb">try { </div><div class="t m0 x0 hb y35b0 ffd7 fs6 fc0 sc0 ls21 wsb">    window.someNonexistentFunction(); </div><div class="t m0 x0 hb y35b1 ffd7 fs6 fc0 sc0 ls21 wsb">} catch (error){ </div><div class="t m0 x0 hb y35b2 ffd7 fs6 fc0 sc0 ls21 wsb">    alert(&quot;An error happened!&quot;); </div><div class="t m0 x0 hb y35b3 ffd7 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h4 y33f2 ffd6 fs2 fc0 sc0 ls8 wseb">如果try块中的任何代码发生了错误，就会立即退出代码执行过程，然后接着执行catch块。此</div><div class="t m0 x0 h1e y33f3 ffd6 fs2 fc0 sc0 ls8 wseb">时，catch块会接收到一个包含错误信息的对象。与在其他语言中不同的是，即使你不想使用这个错误</div><div class="t m0 x0 h4 y35b4 ffd6 fs2 fc0 sc0 ls8 wseb">对象，也要给它起个名字。这个对象中包含的实际信息会因浏览器而异，但共同的是有一个保存着错误</div><div class="t m0 x0 hc y35b5 ffd6 fs2 fc0 sc0 ls8 wseb">消息的message属性。ECMA-262还规定了一个保存错误类型的name属性；当前所有浏览器都支持这</div><div class="t m0 x0 h5 y35b6 ffd6 fs2 fc0 sc0 ls8 wseb">个属性（Opera 9之前的版本不支持这个属性）。因此，在发生错误时，就可以像下面这样实事求是地显</div><div class="t m0 x0 h5 y35b7 ffd6 fs2 fc0 sc0 ls8 wseb">示浏览器给出的消息。 </div><div class="t m0 x0 hb y35b8 ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y35b9 ffd7 fs6 fc0 sc0 ls21 wsb">try { </div><div class="t m0 x0 hb y35ba ffd7 fs6 fc0 sc0 ls21 wsb">    window.someNonexistentFunction();     </div><div class="t m0 x0 hb y35bb ffd7 fs6 fc0 sc0 ls21 wsb">} catch (error){ </div><div class="t m0 x0 h15 y35bc ffdb fs6 fc0 sc0 ls21 wsb">    alert(error.message); </div><div class="t m0 x0 hb y35bd ffd7 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x2 hf y35be ffdd fs2 fc0 sc0 ls7a wsb">TryCatchExample01.htm </div><div class="t m0 x0 h4 y35bf ffd6 fs2 fc0 sc0 ls8 wseb">这个例子在向用户显示错误消息时，使用了错误对象的message属性。这个message属性是唯一</div><div class="t m0 x0 h5 y35c0 ffd6 fs2 fc0 sc0 ls8 wseb">一个能够保证所有浏览器都支持的属性，除此之外，IE、Firefox、Safari、Chrome以及Opera都为事件</div><div class="t m0 x0 h5 y35c1 ffd6 fs2 fc0 sc0 ls8 wseb">对象添加了其他相关信息。IE添加了与message属性完全相同的description 属性，还添加了保存</div><div class="t m0 x0 h5 y7ce ffd6 fs2 fc0 sc0 ls8 wseb">着内部错误数量的number属性。Firefox添加了fileName、lineNumber和stack（包含栈跟踪信息）</div><div class="t m0 x0 h5 y35c2 ffd6 fs2 fc0 sc0 ls8">属性。Safari添加了line（表示行号）、sourceId（表示内部错误代码）和sourceURL属性。当然，</div><div class="t m0 x0 hc y35c3 ffd6 fs2 fc0 sc0 ls8 wseb">在跨浏览器编程时，最好还是只使用message属性。 </div><div class="t m0 x0 h47 y35c4 ffd4 fs2 fc0 sc0 ls2e wsb">1. finally子句 </div><div class="t m0 x0 h4 y35c5 ffd6 fs2 fc0 sc0 ls8 wseb">虽然在try-catch语句中是可选的，但finally子句一经使用，其代码无论如何都会执行。换句</div><div class="t m0 x0 h1e y35c6 ffd6 fs2 fc0 sc0 ls8 wseb">话说，try语句块中的代码全部正常执行，finally子句会执行；如果因为出错而执行了catch语句</div></div></div>
<div id="pf207" class="pf w0 h0" data-page-no="207"><div class="pc pc207 w0 h0"><div class="t m0 x2 h2 y1 ffcf fs0 fc0 sc0 ls7 ws0">17.2 错误处理    501 </div><div class="t m0 x0 h3 y2 ffcf fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffd1 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ffd1 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffd1 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffd1 fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ffd1 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffd1 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffd1 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffd1 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffd1 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffd1 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffd1 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffd1 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ffd1 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h4 y3 ffd6 fs2 fc0 sc0 ls8 wseb">块，finally子句照样还会执行。只要代码中包含finally子句，则无论try 或catch语句块中包</div><div class="t m0 x0 hc y4d ffd6 fs2 fc0 sc0 ls8 wseb">含什么代码——甚至return语句，都不会阻止finally子句的执行。来看下面这个函数。 </div><div class="t m0 x5 hb y2d8 ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2d9 ffd7 fs6 fc0 sc0 ls21 wsb">function testFinally(){ </div><div class="t m0 x0 hb y2da ffd7 fs6 fc0 sc0 ls21 wsb">    try { </div><div class="t m0 x0 hb y2db ffd7 fs6 fc0 sc0 ls21 wsb">        return 2; </div><div class="t m0 x0 hb y2dc ffd7 fs6 fc0 sc0 ls21 wsb">    } catch (error){ </div><div class="t m0 x0 hb y2dd ffd7 fs6 fc0 sc0 ls21 wsb">        return 1; </div><div class="t m0 x0 hb y9e2 ffd7 fs6 fc0 sc0 ls21 wsb">    } finally { </div><div class="t m0 x0 hb y9e3 ffd7 fs6 fc0 sc0 ls21 wsb">        return 0; </div><div class="t m0 x0 hb y9e4 ffd7 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y9e5 ffd7 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x2 hf y35c7 ffdd fs2 fc0 sc0 ls7a wsb">TryCatchExample02.htm </div><div class="t m0 x0 h4 y35c8 ffd6 fs2 fc0 sc0 ls8 wseb">这个函数在try-catch语句的每一部分都放了一条return语句。表面上看，调用这个函数会返</div><div class="t m0 x0 h5 yfbf ffd6 fs2 fc0 sc0 ls3b">回2，因为返回2的return语句位于try语句块中，而执行该语句又不会出错。可是，由于最后还有</div><div class="t m0 x0 hc yfc0 ffd6 fs2 fc0 sc0 ls8 wseb">一个finally子句，结果就会导致该return语句被忽略；也就是说，调用这个函数只能返回0。如果</div><div class="t m0 x0 hc y35c9 ffd6 fs2 fc0 sc0 ls3a3">把finally子句拿掉，这个函数将返回2。 </div><div class="t m0 x0 hc y35ca ffd6 fs2 fc0 sc0 ls8 wseb">如果提供finally子句，则catch子句就成了可选的（catch 或finally有一个即可）。IE7及</div><div class="t m0 x0 h5 ya48 ffd6 fs2 fc0 sc0 ls8 wseb">更早版本中有一个bug：除非有catch子句，否则finally 中的代码永远不会执行。如果你仍然要考</div><div class="t m0 x0 hc ya49 ffd6 fs2 fc0 sc0 ls3b">虑IE的早期版本，那就只好提供一个catch子句，哪怕里面什么都不写。IE8修复了这个bug。 </div><div class="t m0 x5 ha y35cb ffd0 fs2 fc0 sc0 lse2 ws386">请读者务必要记住，只要代码中包含finally子句，那么无论try还是catch 语句块</div><div class="t m0 x5 ha y35cc ffd0 fs2 fc0 sc0 ls3a9 ws388">中的return语句都将被忽略。因此，在使用finally子句之前，一定要非常清楚你想让代</div><div class="t m0 x5 h5 y35cd ffd0 fs2 fc0 sc0 lse2 ws386">码怎么样。 </div><div class="t m0 x0 h3c y35ce ffd4 fs2 fc0 sc0 ls2e wsb">2. 错误类型 </div><div class="t m0 x0 h4 y35cf ffd6 fs2 fc0 sc0 ls8 wseb">执行代码期间可能会发生的错误有多种类型。每种错误都有对应的错误类型，而当错误发生时，就</div><div class="t m0 x0 h5 y35d0 ffd6 fs2 fc0 sc0 ls8 wseb">会抛出相应类型的错误对象。ECMA-262定义了下列7种错误类型： </div><div class="t m0 x0 h28 y35d1 ffd5 fs1 fc0 sc0 ls2"> Error </div><div class="t m0 x0 h28 y35d2 ffd5 fs1 fc0 sc0 ls2"> EvalError </div><div class="t m0 x0 h28 y35d3 ffd5 fs1 fc0 sc0 ls2"> RangeError </div><div class="t m0 x0 h28 y35d4 ffd5 fs1 fc0 sc0 ls2"> ReferenceError </div><div class="t m0 x0 h28 y35d5 ffd5 fs1 fc0 sc0 ls2"> SyntaxError </div><div class="t m0 x0 h28 y35d6 ffd5 fs1 fc0 sc0 ls2"> TypeError </div><div class="t m0 x0 h28 y35d7 ffd5 fs1 fc0 sc0 ls2"> URIError </div><div class="t m0 x0 h4 y2a47 ffd6 fs2 fc0 sc0 ls8 wseb">其中，Error是基类型，其他错误类型都继承自该类型。因此，所有错误类型共享了一组相同的属</div><div class="t m0 x0 h4 y25ec ffd6 fs2 fc0 sc0 ls8 wseb">性（错误对象中的方法全是默认的对象方法）。Error类型的错误很少见，如果有也是浏览器抛出的；</div><div class="t m0 x0 h5 y35d8 ffd6 fs2 fc0 sc0 ls8 wseb">这个基类型的主要目的是供开发人员抛出自定义错误。 </div><div class="t m0 x0 h5 y35d9 ffd7 fs1 fc0 sc0 ls9 ws2">EvalError类型的错误会在使用eval()函数而发生异常时被抛出。ECMA-262中对这个错误有如</div><div class="t m0 x0 h1e y35da ffd6 fs2 fc0 sc0 ls30 wsf6">下描述：“如果以非直接调用的方式使用eval属性的值（换句话说，没有明确地将其名称作为一个</div><div class="t m0 x0 h4 y35db ffd7 fs1 fc0 sc0 ls9 ws2">Identifier，即用作CallExpression中的MemberExpression），或者为eval属性赋值。”简单</div><div class="t m0 x0 h5 yd3f ffd6 fs2 fc0 sc0 ls8 wseb">地说，如果没有把eval()当成函数调用，就会抛出错误，例如： </div><div class="t m0 x0 hb y35dc ffd7 fs6 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf208" class="pf w0 h0" data-page-no="208"><div class="pc pc208 w0 h0"><div class="t m0 x0 h2 y1 ffcf fs0 fc0 sc0 ls7 ws0">502  第17章 错误处理与调试 </div><div class="t m0 x0 h3 y2 ffcf fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y44f ffd7 fs6 fc0 sc0 ls21 wsb">new eval();   //抛出EvalError </div><div class="t m0 x0 h16 y450 ffd7 fs6 fc0 sc0 ls21 wsb">eval = foo;   //抛出EvalError </div><div class="t m0 x0 hb y35dd ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y35de ffd6 fs2 fc0 sc0 ls8 wseb">在实践中，浏览器不一定会在应该抛出错误时就抛出EvalError。例如，Firefox 4+和IE8对第一</div><div class="t m0 x0 h1e y35df ffd6 fs2 fc0 sc0 ls6 wsf7">种情况会抛出TypeError，而第二种情况会成功执行，不发生错误。有鉴于此，加上在实际开发中极</div><div class="t m0 x0 h4 y35e0 ffd6 fs2 fc0 sc0 ls8 wseb">少会这样使用eval()，所以遇到这种错误类型的可能性极小。 </div><div class="t m0 x0 h42 y35e1 ffd7 fs1 fc0 sc0 ls9 ws2">RangeError类型的错误会在数值超出相应范围时触发。例如，在定义数组时，如果指定了数组不</div><div class="t m0 x0 h25 y35e2 ffd6 fs2 fc0 sc0 ls8 wseb">支持的项数（如20或Number.MAX_VALUE），就会触发这种错误。下面是具体的例子。 </div><div class="t m0 x0 hb y1251 ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y35e3 ffd7 fs6 fc0 sc0 ls21 wsb">var items1 = new Array(-20);                    //抛出RangeError </div><div class="t m0 x0 h16 y35e4 ffd7 fs6 fc0 sc0 ls21 wsb">var items2 = new Array(Number.MAX_VALUE);      //抛出RangeError </div><div class="t m0 x0 hb y35e5 ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y2b8 ffcf fs2 fc0 sc0 lsb ws5">JavaScript中经常会出现这种范围错误。 </div><div class="t m0 x0 h1e y2110 ffd6 fs2 fc0 sc0 ls8 wseb">在找不到对象的情况下，会发生ReferenceError（这种情况下，会直接导致人所共知的&quot;object </div><div class="t m0 x0 h21 y35e6 ffd7 fs1 fc0 sc0 ls9 ws2">expected&quot;浏览器错误）。通常，在访问不存在的变量时，就会发生这种错误，例如： </div><div class="t m0 x0 hb y35e7 ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y35e8 ffd7 fs6 fc0 sc0 ls21 wsb">var obj = x;         //在x并未声明的情况下抛出 ReferenceError </div><div class="t m0 x0 hb y35e9 ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y35ea ffd6 fs2 fc0 sc0 ls8 wseb">至于SyntaxError，当我们把语法错误的JavaScript字符串传入eval()函数时，就会导致此类错</div><div class="t m0 x0 h5 y35eb ffd6 fs2 fc0 sc0 ls8 wseb">误。例如： </div><div class="t m0 x0 hb y35ec ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y35ed ffd7 fs6 fc0 sc0 ls21 wsb">eval(&quot;a ++ b&quot;);     //抛出SyntaxError </div><div class="t m0 x0 hb y35ee ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y35ef ffd6 fs2 fc0 sc0 ls8 wseb">如果语法错误的代码出现在eval()函数之外，则不太可能使用SyntaxError，因为此时的语法错</div><div class="t m0 x0 h5 y1e2c ffd6 fs2 fc0 sc0 ls8 wseb">误会导致JavaScript代码立即停止执行。 </div><div class="t m0 x0 h5 y1e2d ffd7 fs1 fc0 sc0 ls9 ws2">TypeError类型在JavaScript中会经常用到，在变量中保存着意外的类型时，或者在访问不存在的</div><div class="t m0 x0 h4 y35f0 ffd6 fs2 fc0 sc0 ls8 wseb">方法时，都会导致这种错误。错误的原因虽然多种多样，但归根结底还是由于在执行特定于类型的操作</div><div class="t m0 x0 h5 y35f1 ffd6 fs2 fc0 sc0 ls8 wseb">时，变量的类型并不符合要求所致。下面来看几个例子。 </div><div class="t m0 x0 hb y35f2 ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y35f3 ffd7 fs6 fc0 sc0 ls21 wsb">var o = new 10;                   //抛出TypeError </div><div class="t m0 x0 h16 y35f4 ffd7 fs6 fc0 sc0 ls21 wsb">alert(&quot;name&quot; in true);            //抛出TypeError </div><div class="t m0 x0 h16 y35f5 ffd7 fs6 fc0 sc0 ls21 wsb">Function.prototype.toString.call(&quot;name&quot;);      //抛出TypeError </div><div class="t m0 x0 hb y35f6 ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y35f7 ffd6 fs2 fc0 sc0 ls1f ws108">最常发生类型错误的情况，就是传递给函数的参数事先未经检查，结果传入类型与预期类型不相符。 </div><div class="t m0 x0 h5 y35f8 ffd6 fs2 fc0 sc0 ls8 wseb">在使用encodeURI()或decodeURI()，而URI格式不正确时，就会导致URIError 错误。这种</div><div class="t m0 x0 h5 y35f9 ffd6 fs2 fc0 sc0 ls8 wseb">错误也很少见，因为前面说的这两个函数的容错性非常高。 </div><div class="t m0 x0 h4 y35fa ffd6 fs2 fc0 sc0 ls8 wseb">利用不同的错误类型，可以获悉更多有关异常的信息，从而有助于对错误作出恰当的处理。要想知</div><div class="t m0 x0 h14 y35fb ffd6 fs2 fc0 sc0 ls8 wseb">道错误的类型，可以像下面这样在try-catch语句的catch语句中使用 instanceof操作符。 </div><div class="t m0 x0 hb y24a6 ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y35fc ffd7 fs6 fc0 sc0 ls21 wsb">try { </div><div class="t m0 x0 hb y35fd ffd7 fs6 fc0 sc0 ls21 wsb">    someFunction(); </div><div class="t m0 x0 hb y35fe ffd7 fs6 fc0 sc0 ls21 wsb">} catch (error){ </div><div class="t m0 x0 hb y35ff ffd7 fs6 fc0 sc0 ls21 wsb">    if (error instanceof TypeError){ </div><div class="t m0 x0 h16 y3600 ffdb fs6 fc0 sc0 ls21 wsb">        //处理类型错误 </div><div class="t m0 x0 h15 y3601 ffdb fs6 fc0 sc0 ls21 wsb">    } else if (error instanceof ReferenceError){ </div><div class="t m0 x0 h16 y3602 ffdb fs6 fc0 sc0 ls21 wsb">        //处理引用错误 </div><div class="t m0 x0 h15 y3603 ffdb fs6 fc0 sc0 ls21 wsb">    } else { </div><div class="t m0 x0 h16 y3604 ffdb fs6 fc0 sc0 ls21 wsb">        //处理其他类型的错误 </div><div class="t m0 x0 h15 y3605 ffdb fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y3606 ffd7 fs6 fc0 sc0 ls21 wsb">}  </div></div></div>
<div id="pf209" class="pf w0 h0" data-page-no="209"><div class="pc pc209 w0 h0"><div class="t m0 x2 h2 y1 ffcf fs0 fc0 sc0 ls7 ws0">17.2 错误处理    503 </div><div class="t m0 x0 h3 y2 ffcf fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffd1 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ffd1 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffd1 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffd1 fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ffd1 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffd1 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffd1 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffd1 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffd1 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffd1 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffd1 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffd1 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ffd1 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h4 y3 ffd6 fs2 fc0 sc0 ls8 wseb">在跨浏览器编程中，检查错误类型是确定处理方式的最简便途径；包含在message属性中的错误</div><div class="t m0 x0 h5 y4d ffd6 fs2 fc0 sc0 ls8 wseb">消息会因浏览器而异。 </div><div class="t m0 x0 h3c y2041 ffd4 fs2 fc0 sc0 ls2e wsb">3. 合理使用try-catch </div><div class="t m0 x0 h4 y3607 ffd6 fs2 fc0 sc0 lsb4">当try-catch语句中发生错误时，浏览器会认为错误已经被处理了，因而不会通过本章前面讨论</div><div class="t m0 x0 h5 y6e4 ffd6 fs2 fc0 sc0 ls8 wseb">的机制记录或报告错误。对于那些不要求用户懂技术，也不需要用户理解错误的Web应用程序，这应</div><div class="t m0 x0 hc y1a00 ffd6 fs2 fc0 sc0 ls8 wseb">该说是个理想的结果。不过，try-catch能够让我们实现自己的错误处理机制。 </div><div class="t m0 x0 hc y2088 ffd6 fs2 fc0 sc0 ls8 wseb">使用try-catch最适合处理那些我们无法控制的错误。假设你在使用一个大型JavaScript 库中的</div><div class="t m0 x0 h4 y1ed4 ffd6 fs2 fc0 sc0 ls8 wseb">函数，该函数可能会有意无意地抛出一些错误。由于我们不能修改这个库的源代码，所以大可将对该函</div><div class="t m0 x0 he y334d ffd6 fs2 fc0 sc0 ls8 wseb">数的调用放在try-catch语句当中，万一有什么错误发生，也好恰当地处理它们。 </div><div class="t m0 x0 h4 y2043 ffd6 fs2 fc0 sc0 ls8 wseb">在明明白白地知道自己的代码会发生错误时，再使用try-catch语句就不太合适了。例如，如果</div><div class="t m0 x0 h4 ycbd ffd6 fs2 fc0 sc0 ls8 wseb">传递给函数的参数是字符串而非数值，就会造成函数出错，那么就应该先检查参数的类型，然后再决定</div><div class="t m0 x0 he y3608 ffd6 fs2 fc0 sc0 ls8 wseb">如何去做。在这种情况下，不应用使用try-catch语句。 </div><div class="t m0 x0 h20 y3609 ffd4 fs3 fc0 sc0 ls248 ws214">17.2.2 抛出错误 </div><div class="t m0 x0 h4 y360a ffd6 fs2 fc0 sc0 ls2c">与try-catch语句相配的还有一个throw操作符，用于随时抛出自定义错误。抛出错误时，必须</div><div class="t m0 x0 hc y360b ffd6 fs2 fc0 sc0 ls8 wseb">要给throw操作符指定一个值，这个值是什么类型，没有要求。下列代码都是有效的。 </div><div class="t m0 x5 hb y360c ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y360d ffd7 fs6 fc0 sc0 ls21 wsb">throw 12345; </div><div class="t m0 x0 hb y360e ffd7 fs6 fc0 sc0 ls21 wsb">throw &quot;Hello world!&quot;; </div><div class="t m0 x0 hb y360f ffd7 fs6 fc0 sc0 ls21 wsb">throw true; </div><div class="t m0 x0 hb y3610 ffd7 fs6 fc0 sc0 ls21 wsb">throw { name: &quot;JavaScript&quot;}; </div><div class="t m0 x5 hb y3611 ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3612 ffd6 fs2 fc0 sc0 ls8 wseb">在遇到throw操作符时，代码会立即停止执行。仅当有try-catch语句捕获到被抛出的值时，代</div><div class="t m0 x0 h5 y230c ffd6 fs2 fc0 sc0 ls8 wseb">码才会继续执行。 </div><div class="t m0 x0 h4 y3613 ffd6 fs2 fc0 sc0 ls8 wseb">通过使用某种内置错误类型，可以更真实地模拟浏览器错误。每种错误类型的构造函数接收一个参</div><div class="t m0 x0 h5 y3614 ffd6 fs2 fc0 sc0 ls8 wseb">数，即实际的错误消息。下面是一个例子。 </div><div class="t m0 x5 hb y3615 ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3616 ffd7 fs6 fc0 sc0 ls21 wsb">throw new Error(&quot;Something bad happened.&quot;); </div><div class="t m0 x5 hb y3617 ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1f45 ffd6 fs2 fc0 sc0 ls8 wseb">这行代码抛出了一个通用错误，带有一条自定义错误消息。浏览器会像处理自己生成的错误一样，</div><div class="t m0 x0 h4 y3618 ffd6 fs2 fc0 sc0 ls8 wseb">来处理这行代码抛出的错误。换句话说，浏览器会以常规方式报告这一错误，并且会显示这里的自定义</div><div class="t m0 x0 h5 y3619 ffd6 fs2 fc0 sc0 ls8 wseb">错误消息。像下面使用其他错误类型，也可以模拟出类似的浏览器错误。 </div><div class="t m0 x5 hb y1f48 ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1f49 ffd7 fs6 fc0 sc0 ls21 wsb">throw new SyntaxError(&quot;I don’t like your syntax.&quot;); </div><div class="t m0 x0 hb y1f4a ffd7 fs6 fc0 sc0 ls21 wsb">throw new TypeError(&quot;What type of variable do you take me for?&quot;); </div><div class="t m0 x0 hb y361a ffd7 fs6 fc0 sc0 ls21 wsb">throw new RangeError(&quot;Sorry, you just don’t have the range.&quot;); </div><div class="t m0 x0 hb y1f4c ffd7 fs6 fc0 sc0 ls21 wsb">throw new EvalError(&quot;That doesn’t evaluate.&quot;); </div><div class="t m0 x0 hb y1f4d ffd7 fs6 fc0 sc0 ls21 wsb">throw new URIError(&quot;Uri, is that you?&quot;); </div><div class="t m0 x0 hb y361b ffd7 fs6 fc0 sc0 ls21 wsb">throw new ReferenceError(&quot;You didn’t cite your references properly.&quot;); </div><div class="t m0 x5 hb y361c ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1c26 ffd6 fs2 fc0 sc0 ls7b wsee">在创建自定义错误消息时最常用的错误类型是Error、RangeError、ReferenceError和TypeError。 </div><div class="t m0 x0 hc y1c27 ffd6 fs2 fc0 sc0 ls8 wseb">另外，利用原型链还可以通过继承Error来创建自定义错误类型（原型链在第6章中介绍）。此时，</div><div class="t m0 x0 hc y361d ffd6 fs2 fc0 sc0 ls8 wseb">需要为新创建的错误类型指定name和message属性。来看一个例子。 </div><div class="t m0 x5 hb y13d2 ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y361e ffd7 fs6 fc0 sc0 ls21 wsb">function CustomError(message){ </div><div class="t m0 x0 hb y361f ffd7 fs6 fc0 sc0 ls21 wsb">    this.name = &quot;CustomError&quot;; </div><div class="t m0 x0 hb y3620 ffd7 fs6 fc0 sc0 ls21 wsb">    this.message = message; </div><div class="t m0 x0 hb y3621 ffd7 fs6 fc0 sc0 ls21 wsb">} </div></div></div>
<div id="pf20a" class="pf w0 h0" data-page-no="20a"><div class="pc pc20a w0 h0"><div class="t m0 x0 h2 y1 ffcf fs0 fc0 sc0 ls7 ws0">504  第17章 错误处理与调试 </div><div class="t m0 x0 h3 y2 ffcf fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y8f5 ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y8f6 ffd7 fs6 fc0 sc0 ls21 wsb">CustomError.prototype = new Error(); </div><div class="t m0 x0 hb y8f7 ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y8f8 ffd7 fs6 fc0 sc0 ls21 wsb">throw new CustomError(&quot;My message&quot;); </div><div class="t m0 x0 hb y20aa ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y20ab ffdd fs2 fc0 sc0 ls79 wsb">ThrowingErrorsExample01.htm </div><div class="t m0 x0 h4 y20ac ffd6 fs2 fc0 sc0 ls8 wseb">浏览器对待继承自Error的自定义错误类型，就像对待其他错误类型一样。如果要捕获自己抛出</div><div class="t m0 x0 h5 y3623 ffd6 fs2 fc0 sc0 ls8 wseb">的错误并且把它与浏览器错误区别对待的话，创建自定义错误是很有用的。 </div><div class="t m0 x5 h5 y3624 ffcf fs2 fc0 sc0 lse ws9">IE只有在抛出Error对象的时候才会显示自定义错误消息。对于其他类型，它</div><div class="t m0 x0 ha y3625 ffd0 fs2 fc0 sc0 ls8 ws14">都无一例外地显示&quot;exception thrown and not caught&quot;（抛出了异常，且未被</div><div class="t m0 x0 h5 y3626 ffd0 fs2 fc0 sc0 ls8">捕获）。 </div><div class="t m0 x0 h3c y3627 ffd4 fs2 fc0 sc0 ls2e wsb">1. 抛出错误的时机 </div><div class="t m0 x0 h4 y3628 ffd6 fs2 fc0 sc0 ls8 wseb">要针对函数为什么会执行失败给出更多信息，抛出自定义错误是一种很方便的方式。应该在出现某</div><div class="t m0 x0 h4 y3629 ffd6 fs2 fc0 sc0 ls8 wseb">种特定的已知错误条件，导致函数无法正常执行时抛出错误。换句话说，浏览器会在某种特定的条件下</div><div class="t m0 x0 h5 y362a ffd6 fs2 fc0 sc0 ls8 wseb">执行函数时抛出错误。例如，下面的函数会在参数不是数组的情况下失败。 </div><div class="t m0 x0 hb y362b ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y362c ffd7 fs6 fc0 sc0 ls21 wsb">function process(values){ </div><div class="t m0 x0 hb y362d ffd7 fs6 fc0 sc0 ls21 wsb">    values.sort(); </div><div class="t m0 x0 hb y362e ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y362f ffd7 fs6 fc0 sc0 ls21 wsb">    for (var i=0, len=values.length; i &lt; len; i++){ </div><div class="t m0 x0 hb y3630 ffd7 fs6 fc0 sc0 ls21 wsb">        if (values[i] &gt; 100){ </div><div class="t m0 x0 hb y3631 ffd7 fs6 fc0 sc0 ls21 wsb">            return values[i]; </div><div class="t m0 x0 hb y3632 ffd7 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y3633 ffd7 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y3634 ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3635 ffd7 fs6 fc0 sc0 ls21 wsb">    return -1; </div><div class="t m0 x0 hb y3636 ffd7 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x2 hf y1bef ffdd fs2 fc0 sc0 ls79 wsb">ThrowingErrorsExample02.htm </div><div class="t m0 x0 h4 y3637 ffd6 fs2 fc0 sc0 ls8 wseb">如果执行这个函数时传给它一个字符串参数，那么对sort()的调用就会失败。对此，不同浏览器</div><div class="t m0 x0 h5 y3638 ffd6 fs2 fc0 sc0 ls8 wseb">会给出不同的错误消息，但都不是特别明确，如下所示。 </div><div class="t m0 x0 h5 y3639 ffd5 fs1 fc0 sc0 ls2"> IE：属性或方法不存在。 </div><div class="t m0 x0 h5 y363a ffd5 fs1 fc0 sc0 ls2"> Firefox：values.sort()不是函数。 </div><div class="t m0 x0 h5 y13ce ffd5 fs1 fc0 sc0 ls2"> Safari：值undefined（表达式values.sort的结果）不是对象。 </div><div class="t m0 x0 h5 y363b ffd5 fs1 fc0 sc0 ls2"> Chrome：对象名没有方法&apos;sort&apos;。 </div><div class="t m0 x0 h5 y363c ffd5 fs1 fc0 sc0 ls2"> Opera：类型不匹配（通常是在需要对象的地方使用了非对象值）。 </div><div class="t m0 x0 h5 y363d ffd6 fs2 fc0 sc0 ls8 wseb">尽管Firefox、Chrome和Safari都明确指出了代码中导致错误的部分，但错误消息并没有清楚地告</div><div class="t m0 x0 h4 y363e ffd6 fs2 fc0 sc0 ls8 wseb">诉我们到底出了什么问题，该怎么修复问题。在处理类似前面例子中的那个函数时，通过调试处理这些</div><div class="t m0 x0 h5 y363f ffd6 fs2 fc0 sc0 ls8 wseb">错误消息没有什么困难。但是，在面对包含数千行JavaScript代码的复杂的Web应用程序时，要想查找</div><div class="t m0 x0 h4 y3640 ffd6 fs2 fc0 sc0 ls8 wseb">错误来源就没有那么容易了。这种情况下，带有适当信息的自定义错误能够显著提升代码的可维护性。</div><div class="t m0 x0 h5 y3641 ffd6 fs2 fc0 sc0 ls8 wseb">来看下面的例子。 </div><div class="t m0 x0 hb y3642 ffd7 fs6 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf20b" class="pf w0 h0" data-page-no="20b"><div class="pc pc20b w0 h0"><div class="t m0 x2 h2 y1 ffcf fs0 fc0 sc0 ls7 ws0">17.2 错误处理    505 </div><div class="t m0 x0 h3 y2 ffcf fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffd1 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ffd1 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffd1 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffd1 fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ffd1 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffd1 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffd1 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffd1 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffd1 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffd1 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffd1 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffd1 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ffd1 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y2f78 ffd7 fs6 fc0 sc0 ls21 wsb">function process(values){ </div><div class="t m0 x0 hb y3643 ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y3644 ffdb fs6 fc0 sc0 ls21 wsb">    if (!(values instanceof Array)){ </div><div class="t m0 x0 h15 y3645 ffdb fs6 fc0 sc0 ls21 wsb">        throw new Error(&quot;process(): Argument must be an array.&quot;); </div><div class="t m0 x0 h15 y3646 ffdb fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y3647 ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3648 ffd7 fs6 fc0 sc0 ls21 wsb">    values.sort(); </div><div class="t m0 x0 hb y3649 ffd7 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 hb y364a ffd7 fs6 fc0 sc0 ls21 wsb">    for (var i=0, len=values.length; i &lt; len; i++){ </div><div class="t m0 x0 hb y364b ffd7 fs6 fc0 sc0 ls21 wsb">        if (values[i] &gt; 100){ </div><div class="t m0 x0 hb y364c ffd7 fs6 fc0 sc0 ls21 wsb">            return values[i]; </div><div class="t m0 x0 hb y364d ffd7 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y364e ffd7 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y364f ffd7 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 hb y3650 ffd7 fs6 fc0 sc0 ls21 wsb">    return -1; </div><div class="t m0 x0 hb y3651 ffd7 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x2 hf y8cc ffdd fs2 fc0 sc0 ls79 wsb">ThrowingErrorsExample02.htm </div><div class="t m0 x0 h4 y3652 ffd6 fs2 fc0 sc0 ls8 wseb">在重写后的这个函数中，如果values参数不是数组，就会抛出一个错误。错误消息中包含了函数</div><div class="t m0 x0 h5 y3653 ffd6 fs2 fc0 sc0 ls8 wseb">的名称，以及为什么会发生错误的明确描述。如果一个复杂的Web应用程序发生了这个错误，那么查</div><div class="t m0 x0 h5 y3654 ffd6 fs2 fc0 sc0 ls8 wseb">找问题的根源也就容易多了。 </div><div class="t m0 x0 h5 y3655 ffd6 fs2 fc0 sc0 ls8 wseb">建议读者在开发JavaScript代码的过程中，重点关注函数和可能导致函数执行失败的因素。良好的</div><div class="t m0 x0 h5 y3656 ffd6 fs2 fc0 sc0 ls8 wseb">错误处理机制应该可以确保代码中只发生你自己抛出的错误。 </div><div class="t m0 x5 h113 y3657 ffd0 fs2 fc0 sc0 ls55 ws38a">在多框架环境下使用instanceof来检测数组有一些问题。详细内容请参考</div><div class="t m0 x5 h5 y3658 ffcf fs2 fc0 sc0 ls4e ws42">22.1.1节。 </div><div class="t m0 x0 h3c y3659 ffd4 fs2 fc0 sc0 ls2e wsb">2. 抛出错误与使用try-catch </div><div class="t m0 x0 h4 y365a ffd6 fs2 fc0 sc0 ls8 wseb">关于何时该抛出错误，而何时该使用try-catch来捕获它们，是一个老生常谈的问题。一般来说，</div><div class="t m0 x0 h4 y365b ffd6 fs2 fc0 sc0 ls8 wseb">应用程序架构的较低层次中经常会抛出错误，但这个层次并不会影响当前执行的代码，因而错误通常得</div><div class="t m0 x0 h5 y365c ffd6 fs2 fc0 sc0 ls8 wseb">不到真正的处理。如果你打算编写一个要在很多应用程序中使用的JavaScript库，甚至只编写一个可能</div><div class="t m0 x0 h4 y365d ffd6 fs2 fc0 sc0 ls8 wseb">会在应用程序内部多个地方使用的辅助函数，我都强烈建议你在抛出错误时提供详尽的信息。然后，即</div><div class="t m0 x0 h5 y365e ffd6 fs2 fc0 sc0 ls8 wseb">可在应用程序中捕获并适当地处理这些错误。 </div><div class="t m0 x0 h4 y365f ffd6 fs2 fc0 sc0 ls8 wseb">说到抛出错误与捕获错误，我们认为只应该捕获那些你确切地知道该如何处理的错误。捕获错误的</div><div class="t m0 x0 h5 y3660 ffd6 fs2 fc0 sc0 ls8 wseb">目的在于避免浏览器以默认方式处理它们；而抛出错误的目的在于提供错误发生具体原因的消息。 </div><div class="t m0 x0 h20 y3475 ffd4 fs3 fc0 sc0 ls248 ws214">17.2.3 错误（error）事件 </div><div class="t m0 x0 h5 y631 ffd6 fs2 fc0 sc0 ls8 wseb">任何没有通过try-catch处理的错误都会触发window对象的 error事件。这个事件是Web浏览</div><div class="t m0 x0 h5 y3661 ffd6 fs2 fc0 sc0 ls8 wseb">器最早支持的事件之一，IE、Firefox和Chrome为保持向后兼容，并没有对这个事件作任何修改（Opera</div><div class="t m0 x0 hc y3662 ffd6 fs2 fc0 sc0 ls3b">和Safari不支持error事件）。在任何Web浏览器中，onerror事件处理程序都不会创建event 对象，</div><div class="t m0 x0 h5 y3663 ffd6 fs2 fc0 sc0 ls8 wseb">但它可以接收三个参数：错误消息、错误所在的URL和行号。多数情况下，只有错误消息有用，因为</div><div class="t m0 x0 h5 y3664 ffcf fs2 fc0 sc0 ls50 ws41">URL只是给出了文档的位置，而行号所指的代码行既可能出自嵌入的JavaScript代码，也可能出自外部</div><div class="t m0 x0 h14 y3665 ffd6 fs2 fc0 sc0 ls8 wseb">的文件。要指定onerror事件处理程序，必须使用如下所示的DOM0级技术，它没有遵循“DOM2级</div><div class="t m0 x0 h5 y516 ffd6 fs2 fc0 sc0 ls8 wseb">事件”的标准格式。 </div><div class="t m0 x0 hb y3666 ffd7 fs6 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf20c" class="pf w0 h0" data-page-no="20c"><div class="pc pc20c w0 h0"><div class="t m0 x0 h2 y1 ffcf fs0 fc0 sc0 ls7 ws0">506  第17章 错误处理与调试 </div><div class="t m0 x0 h3 y2 ffcf fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y8f5 ffd7 fs6 fc0 sc0 ls21 wsb">window.onerror = function(message, url, line){ </div><div class="t m0 x0 hb y8f6 ffd7 fs6 fc0 sc0 ls21 wsb">    alert(message); </div><div class="t m0 x0 hb y8f7 ffd7 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y3668 ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3669 ffd6 fs2 fc0 sc0 ls8 wseb">只要发生错误，无论是不是浏览器生成的，都会触发error事件，并执行这个事件处理程序。然</div><div class="t m0 x0 h4 y366a ffd6 fs2 fc0 sc0 ls4">后，浏览器默认的机制发挥作用，像往常一样显示出错误消息。像下面这样在事件处理程序中返回</div><div class="t m0 x0 h5 y366b ffd7 fs1 fc0 sc0 ls9 ws2">false，可以阻止浏览器报告错误的默认行为。 </div><div class="t m0 x0 hb y366c ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y366d ffd7 fs6 fc0 sc0 ls21 wsb">window.onerror = function(message, url, line){ </div><div class="t m0 x0 hb y366e ffd7 fs6 fc0 sc0 ls21 wsb">    alert(message); </div><div class="t m0 x0 h15 y366f ffdb fs6 fc0 sc0 ls21 wsb">    return false; </div><div class="t m0 x0 hb y3670 ffd7 fs6 fc0 sc0 ls21 wsb">};  </div><div class="t m0 x2 hf y3671 ffdd fs2 fc0 sc0 ls2b wsb">OnErrorExample01.htm </div><div class="t m0 x0 h4 y3672 ffd6 fs2 fc0 sc0 ls8 wseb">通过返回false，这个函数实际上就充当了整个文档中的try-catch语句，可以捕获所有无代码</div><div class="t m0 x0 h4 y3673 ffd6 fs2 fc0 sc0 ls8 wseb">处理的运行时错误。这个事件处理程序是避免浏览器报告错误的最后一道防线，理想情况下，只要可能</div><div class="t m0 x0 h1c y3674 ffd6 fs2 fc0 sc0 ls24 wsf5">就不应该使用它。只要能够适当地使用try-catch语句，就不会有错误交给浏览器，也就不会触发</div><div class="t m0 x0 h5 yab4 ffd7 fs1 fc0 sc0 ls9 ws2">error事件。 </div><div class="t m0 x5 h5 y3675 ffd0 fs2 fc0 sc0 ls8 ws14">浏览器在使用这个事件处理错误时的方式有明显不同。在IE中，即使发生error</div><div class="t m0 x0 ha y3676 ffd0 fs2 fc0 sc0 ls8 ws14">事件，代码仍然会正常执行；所有变量和数据都将得到保留，因此能在onerror事</div><div class="t m0 x0 h5 y3677 ffd0 fs2 fc0 sc0 ls8 ws14">件处理程序中访问它们。但在Firefox中，常规代码会停止执行，事件发生之前的所</div><div class="t m0 x0 h5 y3678 ffd0 fs2 fc0 sc0 ls8 ws14">有变量和数据都将被销毁，因此几乎就无法判断错误了。 </div><div class="t m0 x0 h124 y3679 ffd6 fs2 fc0 sc0 ls8 wseb">图像也支持error事件。只要图像的src特性中的URL 不能返回可以被识别的图像格式，就会触</div><div class="t m0 x0 hc y367a ffd6 fs2 fc0 sc0 ls32b">发error事件。此时的error事件遵循DOM格式，会返回一个以图像为目标的 event对象。下面是</div><div class="t m0 x0 h5 y367b ffd6 fs2 fc0 sc0 ls8 wseb">一个例子。 </div><div class="t m0 x0 hb y2183 ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y367c ffd7 fs6 fc0 sc0 ls21 wsb">var image = new Image(); </div><div class="t m0 x0 hb y367d ffd7 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(image, &quot;load&quot;, function(event){ </div><div class="t m0 x0 hb y367e ffd7 fs6 fc0 sc0 ls21 wsb">    alert(&quot;Image loaded!&quot;); </div><div class="t m0 x0 hb y367f ffd7 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 hb y3680 ffd7 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(image, &quot;error&quot;, function(event){ </div><div class="t m0 x0 hb y3681 ffd7 fs6 fc0 sc0 ls21 wsb">    alert(&quot;Image not loaded!&quot;); </div><div class="t m0 x0 hb y3682 ffd7 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 h16 y3683 ffd7 fs6 fc0 sc0 ls21 wsb">image.src = &quot;smilex.gif&quot;; //指定不存在的文件 </div><div class="t m0 x0 hb y3684 ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1bf3 ffdd fs2 fc0 sc0 ls2b wsb">OnErrorExample02.htm </div><div class="t m0 x0 h4 y1bd2 ffd6 fs2 fc0 sc0 ls8 wseb">在这个例子中，当加载图像失败时就会显示一个警告框。需要注意的是，发生error事件时，图</div><div class="t m0 x0 h5 y3685 ffd6 fs2 fc0 sc0 ls8 wseb">像下载过程已经结束，也就是说不能再重新下载了。 </div><div class="t m0 x0 h20 y3686 ffd4 fs3 fc0 sc0 ls248 ws214">17.2.4 处理错误的策略 </div><div class="t m0 x0 h5 y7f0 ffd6 fs2 fc0 sc0 ls8 wseb">过去，所谓Web应用程序的错误处理策略仅限于服务器端。在谈到错误与错误处理时，通常要考</div><div class="t m0 x0 h4 y7f1 ffd6 fs2 fc0 sc0 ls8 wseb">虑很多方面，涉及一些工具，例如记录和监控系统。这些工具的用途在于分析错误模式，追查错误原因，</div><div class="t m0 x0 h5 y3687 ffd6 fs2 fc0 sc0 ls8 wseb">同时帮助确定错误会影响到多少用户。 </div></div></div>
<div id="pf20d" class="pf w0 h0" data-page-no="20d"><div class="pc pc20d w0 h0"><div class="t m0 x2 h2 y1 ffcf fs0 fc0 sc0 ls7 ws0">17.2 错误处理    507 </div><div class="t m0 x0 h3 y2 ffcf fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffd1 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ffd1 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffd1 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffd1 fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ffd1 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffd1 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffd1 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffd1 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffd1 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffd1 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffd1 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffd1 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ffd1 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ffd6 fs2 fc0 sc0 lsea">在Web应用程序的JavaScript这一端，错误处理策略也同样重要。由于任何JavaScript 错误都可能</div><div class="t m0 x0 h5 y4d ffd6 fs2 fc0 sc0 ls8 wseb">导致网页无法使用，因此搞清楚何时以及为什么发生错误至关重要。绝大多数Web应用程序的用户都</div><div class="t m0 x0 h4 yd8 ffd6 fs2 fc0 sc0 ls8 wseb">不懂技术，遇到错误时很容易心烦意乱。有时候，他们可能会刷新页面以期解决问题，而有时候则会放</div><div class="t m0 x0 h4 y28b ffd6 fs2 fc0 sc0 ls8 wseb">弃努力。作为开发人员，必须要知道代码何时可能出错，会出什么错，同时还要有一个跟踪此类问题的</div><div class="t m0 x0 h5 yfdb ffd6 fs2 fc0 sc0 ls8">系统。 </div><div class="t m0 x0 h20 y3688 ffd4 fs3 fc0 sc0 ls248 ws214">17.2.5 常见的错误类型 </div><div class="t m0 x0 h5 y3689 ffd6 fs2 fc0 sc0 ls8 wseb">错误处理的核心，是首先要知道代码里会发生什么错误。由于JavaScript是松散类型的，而且也不</div><div class="t m0 x0 h5 y1109 ffd6 fs2 fc0 sc0 ls8 wseb">会验证函数的参数，因此错误只会在代码运行期间出现。一般来说，需要关注三种错误： </div><div class="t m0 x0 h5 y368a ffd5 fs1 fc0 sc0 ls2"> 类型转换错误 </div><div class="t m0 x0 h5 y368b ffd5 fs1 fc0 sc0 ls2"> 数据类型错误 </div><div class="t m0 x0 h5 y13be ffd5 fs1 fc0 sc0 ls2"> 通信错误 </div><div class="t m0 x0 h5 yed6 ffd6 fs2 fc0 sc0 ls8 wseb">以上错误分别会在特定的模式下或者没有对值进行足够的检查的情况下发生。 </div><div class="t m0 x0 h3c y368c ffd4 fs2 fc0 sc0 ls2e wsb">1. 类型转换错误 </div><div class="t m0 x0 h4 y368d ffd6 fs2 fc0 sc0 ls8 wseb">类型转换错误发生在使用某个操作符，或者使用其他可能会自动转换值的数据类型的语言结构时。</div><div class="t m0 x0 h5 y368e ffd6 fs2 fc0 sc0 ls8 wseb">在使用相等（==）和不相等（!=）操作符，或者在if、for及while等流控制语句中使用非布尔值时，</div><div class="t m0 x0 h5 y13e ffd6 fs2 fc0 sc0 ls8 wseb">最常发生类型转换错误。 </div><div class="t m0 x0 h5 y368f ffd6 fs2 fc0 sc0 ls3b">第3章讨论的相等和不相等操作符在执行比较之前会先转换不同类型的值。由于在非动态语言中，</div><div class="t m0 x0 h5 y3690 ffd6 fs2 fc0 sc0 ls8 wseb">开发人员都使用相同的符号执行直观的比较，因此在JavaScript中往往也会以相同方式错误地使用它们。</div><div class="t m0 x0 h5 y3691 ffd6 fs2 fc0 sc0 ls8 wseb">多数情况下，我们建议使用全等（===）和不全等（!==）操作符，以避免类型转换。来看一个例子。 </div><div class="t m0 x5 hb y3692 ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3693 ffd7 fs6 fc0 sc0 ls21 wsb">alert(5 == &quot;5&quot;);       //true </div><div class="t m0 x0 hb y3694 ffd7 fs6 fc0 sc0 ls21 wsb">alert(5 === &quot;5&quot;);      //false </div><div class="t m0 x0 hb y3695 ffd7 fs6 fc0 sc0 ls21 wsb">alert(1 == true);      //true </div><div class="t m0 x0 hb y3696 ffd7 fs6 fc0 sc0 ls21 wsb">alert(1 === true);     //false </div><div class="t m0 x5 hb y3697 ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y27a ffd6 fs2 fc0 sc0 ls8 wseb">这里使用了相等和全等操作符比较了数值5和字符串&quot;5&quot;。相等操作符首先会将数值5转换成字符</div><div class="t m0 x0 h4 y68 ffd6 fs2 fc0 sc0 ls8 wseb">串&quot;5&quot;，然后再将其与另一个字符串&quot;5&quot;进行比较，结果是true。全等操作符知道要比较的是两种不同</div><div class="t m0 x0 h1e y15f0 ffd6 fs2 fc0 sc0 ls8 wseb">的数据类型，因而直接返回false。对于1和true也是如此：相等操作符认为它们相等，而全等操作</div><div class="t m0 x0 h4 y3698 ffd6 fs2 fc0 sc0 ls8 wseb">符认为它们不相等。使用全等和非全等操作符，可以避免发生因为使用相等和不相等操作符引发的类型</div><div class="t m0 x0 h5 y3699 ffd6 fs2 fc0 sc0 ls8 wseb">转换错误，因此我们强烈推荐使用。 </div><div class="t m0 x0 h4b y369a ffd6 fs2 fc0 sc0 ls8 wseb">容易发生类型转换错误的另一个地方，就是流控制语句。像if之类的语句在确定下一步操作之前，</div><div class="t m0 x0 h5 y2ae5 ffd6 fs2 fc0 sc0 ls8 wseb">会自动把任何值转换成布尔值。尤其是if语句，如果使用不当，最容易出错。来看下面的例子。 </div><div class="t m0 x5 hb yacb ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y369b ffd7 fs6 fc0 sc0 ls21 wsb">function concat(str1, str2, str3){ </div><div class="t m0 x0 hb y369c ffd7 fs6 fc0 sc0 ls21 wsb">    var result = str1 + str2; </div><div class="t m0 x0 h16 y369d ffd7 fs6 fc0 sc0 ls21 wsb">    if (str3){     //绝对不要这样!!! </div><div class="t m0 x0 hb y369e ffd7 fs6 fc0 sc0 ls21 wsb">        result += str3; </div><div class="t m0 x0 hb y369f ffd7 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y36a0 ffd7 fs6 fc0 sc0 ls21 wsb">    return result; </div><div class="t m0 x0 hb y36a1 ffd7 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h4 y2b0 ffd6 fs2 fc0 sc0 ls8 wseb">这个函数的用意是拼接两或三个字符串，然后返回结果。其中，第三个字符串是可选的，因此必须</div><div class="t m0 x0 h5 y205f ffd6 fs2 fc0 sc0 ls8 wseb">要检查。第3章曾经介绍过，未使用过的命名变量会自动被赋予undefined值。而undefined值可以</div><div class="t m0 x0 h1e y2060 ffd6 fs2 fc0 sc0 ls8 wseb">被转换成布尔值false，因此这个函数中的if语句实际上只适用于提供了第三个参数的情况。问题在</div></div></div>
<div id="pf20e" class="pf w0 h0" data-page-no="20e"><div class="pc pc20e w0 h0"><div class="t m0 x0 h2 y1 ffcf fs0 fc0 sc0 ls7 ws0">508  第17章 错误处理与调试 </div><div class="t m0 x0 h3 y2 ffcf fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ffd6 fs2 fc0 sc0 ls8 wseb">于，并不是只有undefined才会被转换成false，也不是只有字符串值才可以转换为 true。例如，</div><div class="t m0 x0 hc y4d ffd6 fs2 fc0 sc0 ls8 wseb">假设第三个参数是数值0，那么if语句的测试就会失败，而对数值1的测试则会通过。 </div><div class="t m0 x0 h4 y5 ffd6 fs2 fc0 sc0 ls8 wseb">在流控制语句中使用非布尔值，是极为常见的一个错误来源。为避免此类错误，就要做到在条件比</div><div class="t m0 x0 h4 y6 ffd6 fs2 fc0 sc0 ls8 wseb">较时切实传入布尔值。实际上，执行某种形式的比较就可以达到这个目的。例如，我们可以将前面的函</div><div class="t m0 x0 h5 y7 ffd6 fs2 fc0 sc0 ls8 wseb">数重写如下。 </div><div class="t m0 x0 hb y4ef ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yfdc ffd7 fs6 fc0 sc0 ls21 wsb">function concat(str1, str2, str3){ </div><div class="t m0 x0 hb yfdd ffd7 fs6 fc0 sc0 ls21 wsb">    var result = str1 + str2; </div><div class="t m0 x0 h16 yfde ffdb fs6 fc0 sc0 ls21 wsb">    if (typeof str3 == &quot;string&quot;){     //恰当的比较 </div><div class="t m0 x0 hb yfdf ffd7 fs6 fc0 sc0 ls21 wsb">        result += str3; </div><div class="t m0 x0 hb yfe0 ffd7 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb yfe1 ffd7 fs6 fc0 sc0 ls21 wsb">    return result; </div><div class="t m0 x0 hb yfe2 ffd7 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h4 y1976 ffd6 fs2 fc0 sc0 ls8 wseb">在这个重写后的函数中，if语句的条件会基于比较返回一个布尔值。这个函数相对可靠得多，不</div><div class="t m0 x0 h5 y1751 ffd6 fs2 fc0 sc0 ls8 wseb">容易受非正常值的影响。 </div><div class="t m0 x0 h3c y36a2 ffd4 fs2 fc0 sc0 ls2e wsb">2. 数据类型错误 </div><div class="t m0 x0 h5 y36a3 ffcf fs2 fc0 sc0 lsb ws5">JavaScript是松散类型的，也就是说，在使用变量和函数参数之前，不会对它们进行比较以确保它</div><div class="t m0 x0 h4 y1754 ffd6 fs2 fc0 sc0 ls8 wseb">们的数据类型正确。为了保证不会发生数据类型错误，只能依靠开发人员编写适当的数据类型检测代码。</div><div class="t m0 x0 h5 y1755 ffd6 fs2 fc0 sc0 ls8 wseb">在将预料之外的值传递给函数的情况下，最容易发生数据类型错误。 </div><div class="t m0 x0 h4 y1756 ffd6 fs2 fc0 sc0 ls8 wseb">在前面的例子中，通过检测第三个参数可以确保它是一个字符串，但是并没有检测另外两个参数。</div><div class="t m0 x0 h4 y36a4 ffd6 fs2 fc0 sc0 ls8 wseb">如果该函数必须要返回一个字符串，那么只要给它传入两个数值，忽略第三个参数，就可以轻易地导致</div><div class="t m0 x0 h5 y36a5 ffd6 fs2 fc0 sc0 ls8 wseb">它的执行结果错误。类似的情况也存在于下面这个函数中。 </div><div class="t m0 x0 hb y219e ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y36a6 ffd7 fs6 fc0 sc0 ls21">//不安全的函数，任何非字符串值都会导致错误 </div><div class="t m0 x0 hb y36a7 ffd7 fs6 fc0 sc0 ls21 wsb">function getQueryString(url){ </div><div class="t m0 x0 hb y36a8 ffd7 fs6 fc0 sc0 ls21 wsb">    var pos = url.indexOf(&quot;?&quot;); </div><div class="t m0 x0 hb y36a9 ffd7 fs6 fc0 sc0 ls21 wsb">    if (pos &gt; -1){ </div><div class="t m0 x0 hb y36aa ffd7 fs6 fc0 sc0 ls21 wsb">        return url.substring(pos +1); </div><div class="t m0 x0 hb y36ab ffd7 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y36ac ffd7 fs6 fc0 sc0 ls21 wsb">    return &quot;&quot;; </div><div class="t m0 x0 hb y36ad ffd7 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h5 y36ae ffd6 fs2 fc0 sc0 ls8 wseb">这个函数的用意是返回给定URL中的查询字符串。为此，它首先使用indexOf()寻找字符串中的</div><div class="t m0 x0 h1e y36af ffd6 fs2 fc0 sc0 ls8 wseb">问号。如果找到了，利用substring()方法返回问号后面的所有字符串。这个例子中的两个函数只能</div><div class="t m0 x0 h4 y36b0 ffd6 fs2 fc0 sc0 ls8 wseb">操作字符串，因此只要传入其他数据类型的值就会导致错误。而添加一条简单的类型检测语句，就可以</div><div class="t m0 x0 h5 y36b1 ffd6 fs2 fc0 sc0 ls8 wseb">确保函数不那么容易出错。 </div><div class="t m0 x0 hb ycd ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yce ffd7 fs6 fc0 sc0 ls21 wsb">function getQueryString(url){ </div><div class="t m0 x0 h16 ycf ffdb fs6 fc0 sc0 ls21 wsb">    if (typeof url == &quot;string&quot;){        //通过检查类型确保安全 </div><div class="t m0 x0 hb y36b2 ffd7 fs6 fc0 sc0 ls21 wsb">        var pos = url.indexOf(&quot;?&quot;); </div><div class="t m0 x0 hb yd1 ffd7 fs6 fc0 sc0 ls21 wsb">        if (pos &gt; -1){ </div><div class="t m0 x0 hb y36b3 ffd7 fs6 fc0 sc0 ls21 wsb">            return url.substring(pos +1); </div><div class="t m0 x0 hb y36b4 ffd7 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 h15 y36b5 ffdb fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y36b6 ffd7 fs6 fc0 sc0 ls21 wsb">    return &quot;&quot;; </div><div class="t m0 x0 hb y36b7 ffd7 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h4 y36b8 ffd6 fs2 fc0 sc0 ls8 wseb">重写后的这个函数首先检查了传入的值是不是字符串。这样，就确保了函数不会因为接收到非字符</div><div class="t m0 x0 h5 y36b9 ffd6 fs2 fc0 sc0 ls8 wseb">串值而导致错误。 </div></div></div>
<div id="pf20f" class="pf w0 h0" data-page-no="20f"><div class="pc pc20f w0 h0"><div class="t m0 x2 h2 y1 ffcf fs0 fc0 sc0 ls7 ws0">17.2 错误处理    509 </div><div class="t m0 x0 h3 y2 ffcf fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffd1 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ffd1 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffd1 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffd1 fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ffd1 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffd1 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffd1 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffd1 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffd1 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffd1 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffd1 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffd1 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ffd1 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h4 y3 ffd6 fs2 fc0 sc0 ls8 wseb">前一节提到过，在流控制语句中使用非布尔值作为条件很容易导致类型转换错误。同样，这样做也</div><div class="t m0 x0 h5 y4d ffd6 fs2 fc0 sc0 ls8 wseb">经常会导致数据类型错误。来看下面的例子。 </div><div class="t m0 x5 hb y2d8 ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2d9 ffd7 fs6 fc0 sc0 ls21">//不安全的函数，任何非数组值都会导致错误 </div><div class="t m0 x0 hb y2da ffd7 fs6 fc0 sc0 ls21 wsb">function reverseSort(values){ </div><div class="t m0 x0 h16 y2db ffd7 fs6 fc0 sc0 ls21 wsb">    if (values){     //绝对不要这样!!! </div><div class="t m0 x0 hb y2dc ffd7 fs6 fc0 sc0 ls21 wsb">        values.sort(); </div><div class="t m0 x0 hb y2dd ffd7 fs6 fc0 sc0 ls21 wsb">        values.reverse(); </div><div class="t m0 x0 hb y9e2 ffd7 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y9e3 ffd7 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h4 y2965 ffd6 fs2 fc0 sc0 ls8 wseb">这个reverseSort()函数可以将数组反向排序，其中用到了sort()和reverse()方法。对于if</div><div class="t m0 x0 h4 y1974 ffd6 fs2 fc0 sc0 ls8 wseb">语句中的控制条件而言，任何会转换为true的非数组值都会导致错误。另一个常见的错误就是将参数</div><div class="t m0 x0 hc y36ba ffd6 fs2 fc0 sc0 ls68">与null值进行比较，如下所示。 </div><div class="t m0 x5 hb y2294 ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y36bb ffd7 fs6 fc0 sc0 ls21">//不安全的函数，任何非数组值都会导致错误 </div><div class="t m0 x0 hb y36bc ffd7 fs6 fc0 sc0 ls21 wsb">function reverseSort(values){ </div><div class="t m0 x0 h16 y36bd ffdb fs6 fc0 sc0 ls21 wsb">    if (values != null){     //绝对不要这样!!! </div><div class="t m0 x0 hb y36be ffd7 fs6 fc0 sc0 ls21 wsb">        values.sort(); </div><div class="t m0 x0 hb y36bf ffd7 fs6 fc0 sc0 ls21 wsb">        values.reverse(); </div><div class="t m0 x0 hb y36c0 ffd7 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y36c1 ffd7 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h4 y36c2 ffd6 fs2 fc0 sc0 lse4">与null进行比较只能确保相应的值不是null 和undefined（这就相当于使用相等和不相等操</div><div class="t m0 x0 h1e y36c3 ffd6 fs2 fc0 sc0 ls8 wseb">作）。要确保传入的值有效，仅检测null值是不够的；因此，不应该使用这种技术。同样，我们也不</div><div class="t m0 x0 hc y36c4 ffd6 fs2 fc0 sc0 ls8 wseb">推荐将某个值与undefined作比较。 </div><div class="t m0 x0 h5 y36c5 ffd6 fs2 fc0 sc0 ls8 wseb">另一种错误的做法，就是只针对要使用的某一个特性执行特性检测。来看下面的例子。 </div><div class="t m0 x5 hb y36c6 ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y36c7 ffd7 fs6 fc0 sc0 ls21">//还是不安全，任何非数组值都会导致错误 </div><div class="t m0 x0 hb y36c8 ffd7 fs6 fc0 sc0 ls21 wsb">function reverseSort(values){ </div><div class="t m0 x0 h16 y36c9 ffdb fs6 fc0 sc0 ls21 wsb">    if (typeof values.sort == &quot;function&quot;){         //绝对不要这样!!! </div><div class="t m0 x0 hb y36ca ffd7 fs6 fc0 sc0 ls21 wsb">        values.sort(); </div><div class="t m0 x0 hb y36cb ffd7 fs6 fc0 sc0 ls21 wsb">        values.reverse(); </div><div class="t m0 x0 hb y36cc ffd7 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y36cd ffd7 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h4 y96 ffd6 fs2 fc0 sc0 ls8 wseb">在这个例子中，代码首先检测了参数中是否存在sort()方法。这样，如果传入一个包含sort()</div><div class="t m0 x0 h4 y1b2a ffd6 fs2 fc0 sc0 ls6 wsf7">方法的对象（而不是数组）当然也会通过检测，但在调用reverse()函数时可能就会出错了。在确切</div><div class="t m0 x0 hc y1b2b ffd6 fs2 fc0 sc0 ls8 wseb">知道应该传入什么类型的情况下，最好是使用instanceof来检测其数据类型，如下所示。 </div><div class="t m0 x5 hb y36ce ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y36cf ffd7 fs6 fc0 sc0 ls21">//安全，非数组值将被忽略 </div><div class="t m0 x0 hb y36d0 ffd7 fs6 fc0 sc0 ls21 wsb">function reverseSort(values){ </div><div class="t m0 x0 h16 y36d1 ffdb fs6 fc0 sc0 ls21 wsb">    if (values instanceof Array){         //问题解决了 </div><div class="t m0 x0 hb y36d2 ffd7 fs6 fc0 sc0 ls21 wsb">        values.sort(); </div><div class="t m0 x0 hb y36d3 ffd7 fs6 fc0 sc0 ls21 wsb">        values.reverse(); </div><div class="t m0 x0 hb y36d4 ffd7 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y36d5 ffd7 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h4 y2c58 ffd6 fs2 fc0 sc0 ls8 wseb">最后一个reverseSort()函数是安全的：它检测了values，以确保这个参数是Array类型的实</div><div class="t m0 x0 h5 y36d6 ffd6 fs2 fc0 sc0 ls8 wseb">例。这样一来，就可以保证函数忽略任何非数组值。 </div><div class="t m0 x0 h1c y36d7 ffd6 fs2 fc0 sc0 ls8 wseb">大体上来说，基本类型的值应该使用typeof来检测，而对象的值则应该使用instanceof来检测。</div><div class="t m0 x0 h5 y205f ffd6 fs2 fc0 sc0 ls8 wseb">根据使用函数的方式，有时候并不需要逐个检测所有参数的数据类型。但是，面向公众的API则必须无</div><div class="t m0 x0 h5 y2060 ffd6 fs2 fc0 sc0 ls8 wseb">条件地执行类型检查，以确保函数始终能够正常地执行。 </div></div></div>
<div id="pf210" class="pf w0 h0" data-page-no="210"><div class="pc pc210 w0 h0"><div class="t m0 x0 h2 y1 ffcf fs0 fc0 sc0 ls7 ws0">510  第17章 错误处理与调试 </div><div class="t m0 x0 h3 y2 ffcf fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h3c y68b ffd4 fs2 fc0 sc0 ls2e wsb">3. 通信错误 </div><div class="t m0 x0 h5 y68c ffd6 fs2 fc0 sc0 ls8 wseb">随着Ajax编程的兴起（第21章讨论 Ajax），Web应用程序在其生命周期内动态加载信息或功能，</div><div class="t m0 x0 h5 y15dc ffd6 fs2 fc0 sc0 ls8 wseb">已经成为一件司空见惯的事。不过，JavaScript与服务器之间的任何一次通信，都有可能会产生错误。 </div><div class="t m0 x0 h5 y15dd ffd6 fs2 fc0 sc0 ls8 wseb">第一种通信错误与格式不正确的URL或发送的数据有关。最常见的问题是在将数据发送给服务器</div><div class="t m0 x0 hfb y15de ffd6 fs2 fc0 sc0 ls8 wseb">之前，没有使用encodeURIComponent()对数据进行编码。例如，下面这个URL的格式就是不正确的： </div><div class="t m0 x0 hb y36d9 ffd7 fs6 fc0 sc0 ls21 wsb">http://www.yourdomain.com/?redir=http://www.someotherdomain.com?a=b&amp;c=d </div><div class="t m0 x0 hb y36da ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y2889 ffd6 fs2 fc0 sc0 ls8 wseb">针对&quot;redir=&quot;后面的所有字符串调用encodeURIComponent()就可以解决这个问题，结果将产生</div><div class="t m0 x0 h5 y36db ffd6 fs2 fc0 sc0 ls8 wseb">如下字符串： </div><div class="t m0 x0 hb y36dc ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y36dd ffd7 fs6 fc0 sc0 ls216 wsb">http://www.yourdomain.com/?redir=http%3A%2F%2Fwww.someotherdomain.com%3Fa%3Db%26c%3Dd </div><div class="t m0 x0 hb y36de ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y36df ffd6 fs2 fc0 sc0 ls8 wseb">对于查询字符串，应该记住必须要使用encodeURIComponent()方法。为了确保这一点，有时候</div><div class="t m0 x0 h5 y36e0 ffd6 fs2 fc0 sc0 ls8 wseb">可以定义一个处理查询字符串的函数，例如： </div><div class="t m0 x0 hb y36e1 ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y36e2 ffd7 fs6 fc0 sc0 ls21 wsb">function addQueryStringArg(url, name, value){ </div><div class="t m0 x0 hb y36e3 ffd7 fs6 fc0 sc0 ls21 wsb">    if (url.indexOf(&quot;?&quot;) == -1){ </div><div class="t m0 x0 hb y36e4 ffd7 fs6 fc0 sc0 ls21 wsb">        url += &quot;?&quot;; </div><div class="t m0 x0 hb y36e5 ffd7 fs6 fc0 sc0 ls21 wsb">    } else { </div><div class="t m0 x0 hb y36e6 ffd7 fs6 fc0 sc0 ls21 wsb">        url += &quot;&amp;&quot;; </div><div class="t m0 x0 hb y36e7 ffd7 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y36e8 ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y36e9 ffd7 fs6 fc0 sc0 ls21 wsb">    url += encodeURIComponent(name) + &quot;=&quot; + encodeURIComponent(value); </div><div class="t m0 x0 hb y36ea ffd7 fs6 fc0 sc0 ls21 wsb">    return url; </div><div class="t m0 x0 hb y36eb ffd7 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h5 y36ec ffd6 fs2 fc0 sc0 ls8 wseb">这个函数接收三个参数：要追加查询字符串的URL、参数名和参数值。如果传入的URL不包含问</div><div class="t m0 x0 h4 y1beb ffd6 fs2 fc0 sc0 ls8 wseb">号，还要给它添加问号；否则，就要添加一个和号，因为有问号就意味着有其他查询字符串。然后，再</div><div class="t m0 x0 h5 y2c54 ffd6 fs2 fc0 sc0 ls8 wseb">将经过编码的查询字符串的名和值添加到URL后面。可以像下面这样使用这个函数： </div><div class="t m0 x0 hb y3588 ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y36ed ffd7 fs6 fc0 sc0 ls21 wsb">var url = &quot;http://www.somedomain.com&quot;; </div><div class="t m0 x0 hb y36ee ffd7 fs6 fc0 sc0 ls21 wsb">var newUrl = addQueryStringArg(url, &quot;redir&quot;, </div><div class="t m0 x0 hb y36ef ffd7 fs6 fc0 sc0 ls21 wsb">                               &quot;http://www.someotherdomain.com?a=b&amp;c=d&quot;); </div><div class="t m0 x0 hb y36f0 ffd7 fs6 fc0 sc0 ls21 wsb">alert(newUrl); </div><div class="t m0 x0 hb y36f1 ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y36f2 ffd6 fs2 fc0 sc0 ls8 wseb">使用这个函数而不是手工构建URL，可以确保编码正确并避免相关错误。 </div><div class="t m0 x0 h5 y30fc ffd6 fs2 fc0 sc0 ls8 wseb">另外，在服务器响应的数据不正确时，也会发生通信错误。第10章曾经讨论过动态加载脚本和动</div><div class="t m0 x0 h5 y36f3 ffd6 fs2 fc0 sc0 ls8 wseb">态加载样式，运用这两种技术都有可能遇到资源不可用的情况。在没有返回相应资源的情况下，Firefox、</div><div class="t m0 x0 h5 y36f4 ffcf fs2 fc0 sc0 ls50 ws41">Chrome和Safari会默默地失败，IE和Opera则都会报错。然而，对于使用这两种技术产生的错误，很</div><div class="t m0 x0 h5 y36f5 ffd6 fs2 fc0 sc0 ls8 wseb">难判断和处理。在某些情况下，使用Ajax通信可以提供有关错误状态的更多信息。 </div><div class="t m0 x5 h5 y36f6 ffd0 fs2 fc0 sc0 ls8 ws14">在使用Ajax通信的情况下，也可能会发生通信错误。相关的问题和错误将在第</div><div class="t m0 x0 h5 y36f7 ffcf fs2 fc0 sc0 ls8 ws20">21章讨论。 </div><div class="t m0 x0 h20 y36f8 ffd4 fs3 fc0 sc0 ls248 ws214">17.2.6 区分致命错误和非致命错误 </div><div class="t m0 x0 h4 y36f9 ffd6 fs2 fc0 sc0 ls8 wseb">任何错误处理策略中最重要的一个部分，就是确定错误是否致命。对于非致命错误，可以根据下列</div><div class="t m0 x0 h5 y36fa ffd6 fs2 fc0 sc0 ls8 wseb">一或多个条件来确定： </div></div></div>
<div id="pf211" class="pf w0 h0" data-page-no="211"><div class="pc pc211 w0 h0"><div class="t m0 x2 h2 y1 ffcf fs0 fc0 sc0 ls7 ws0">17.2 错误处理    511 </div><div class="t m0 x0 h3 y2 ffcf fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffd1 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ffd1 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffd1 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffd1 fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ffd1 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffd1 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffd1 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffd1 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffd1 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffd1 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffd1 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffd1 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ffd1 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ffd5 fs1 fc0 sc0 ls2"> 不影响用户的主要任务； </div><div class="t m0 x0 h5 y4 ffd5 fs1 fc0 sc0 ls2"> 只影响页面的一部分； </div><div class="t m0 x0 h5 y4e ffd5 fs1 fc0 sc0 ls2"> 可以恢复； </div><div class="t m0 x0 h5 yd9 ffd5 fs1 fc0 sc0 ls2"> 重复相同操作可以消除错误。 </div><div class="t m0 x0 h5 y15d ffd6 fs2 fc0 sc0 ls8 wseb">本质上，非致命错误并不是需要关注的问题。例如，Yahoo! Mail（http://mail.yahoo.com）有一项功</div><div class="t m0 x0 h4 y2b3 ffd6 fs2 fc0 sc0 ls8 wseb">能，允许用户在其界面上发送手机短信。如果由于某种原因，发不了手机短信了，那也不算是致命错误，</div><div class="t m0 x0 h5 y765 ffd6 fs2 fc0 sc0 ls8 wseb">因为并不是应用程序的主要功能有问题。用户使用Yahoo! Mail主要是为了查收和撰写电子邮件。只在</div><div class="t m0 x0 h4 y15fc ffd6 fs2 fc0 sc0 ls8 wseb">这个主要功能正常，就没有理由打断用户。没有必要因为发生了非致命错误而对用户给出提示——可以</div><div class="t m0 x0 h4 y36fb ffd6 fs2 fc0 sc0 ls8 wseb">把页面中受到影响的区域替换掉，比如替换成说明相应功能无法使用的消息。但是，如果因此打断用户，</div><div class="t m0 x0 h5 y36fc ffd6 fs2 fc0 sc0 ls8 wseb">那确实没有必要。 </div><div class="t m0 x0 h5 y36fd ffd6 fs2 fc0 sc0 ls8 wseb">致命错误，可以通过以下一或多个条件来确定： </div><div class="t m0 x0 h5 y21b ffd5 fs1 fc0 sc0 ls2"> 应用程序根本无法继续运行； </div><div class="t m0 x0 h5 y21c ffd5 fs1 fc0 sc0 ls2"> 错误明显影响到了用户的主要操作；  </div><div class="t m0 x0 h5 y10 ffd5 fs1 fc0 sc0 ls2"> 会导致其他连带错误。 </div><div class="t m0 x0 h5 y1e96 ffd6 fs2 fc0 sc0 ls8 wseb">要想采取适当的措施，必须要知道JavaScript在什么情况下会发生致命错误。在发生致命错误时，</div><div class="t m0 x0 h4 y1e97 ffd6 fs2 fc0 sc0 ls8 wseb">应该立即给用户发送一条消息，告诉他们无法再继续手头的事情了。假如必须刷新页面才能让应用程序</div><div class="t m0 x0 h5 y36fe ffd6 fs2 fc0 sc0 ls8 wseb">正常运行，就必须通知用户，同时给用户提供一个点击即可刷新页面的按钮。 </div><div class="t m0 x0 h4 y36ff ffd6 fs2 fc0 sc0 ls8 wseb">区分非致命错误和致命错误的主要依据，就是看它们对用户的影响。设计良好的代码，可以做到应</div><div class="t m0 x0 h5 y3700 ffd6 fs2 fc0 sc0 ls339 ws2f0">用程序某一部分发生错误不会不必要地影响另一个实际上毫不相干的部分。例如，My Yahoo!</div><div class="t m0 x0 h5 y3701 ffd6 fs2 fc0 sc0 ls8">（http://my.yahoo.com）的个性化主页上包含了很多互不依赖的模块。如果每个模块都需要通过JavaScript</div><div class="t m0 x0 h5 y3702 ffd6 fs2 fc0 sc0 ls8 wseb">调用来初始化，那么你可能会看到类似下面这样的代码： </div><div class="t m0 x5 hb y1c1d ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3703 ffd7 fs6 fc0 sc0 ls21 wsb">for (var i=0, len=mods.length; i &lt; len; i++){ </div><div class="t m0 x0 h16 y3704 ffd7 fs6 fc0 sc0 ls21 wsb">    mods[i].init(); //可能会导致致命错误 </div><div class="t m0 x0 hb y3705 ffd7 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h4 y3706 ffd6 fs2 fc0 sc0 ls8 wseb">表面上看，这些代码没什么问题：依次对每个模块调用init()方法。问题在于，任何模块的init()</div><div class="t m0 x0 h4 y3707 ffd6 fs2 fc0 sc0 ls8 wseb">方法如果出错，都会导致数组中后续的所有模块无法再进行初始化。从逻辑上说，这样编写代码没有什</div><div class="t m0 x0 h4 y3708 ffd6 fs2 fc0 sc0 ls8 wseb">么意义。毕竟，每个模块相互之间没有依赖关系，各自实现不同功能。可能会导致致命错误的原因是代</div><div class="t m0 x0 h5 y3709 ffd6 fs2 fc0 sc0 ls8 wseb">码的结构。不过，经过下面这样修改，就可以把所有模块的错误变成非致命的： </div><div class="t m0 x5 hb y33df ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y370a ffd7 fs6 fc0 sc0 ls21 wsb">for (var i=0, len=mods.length; i &lt; len; i++){ </div><div class="t m0 x0 h15 y370b ffdb fs6 fc0 sc0 ls21 wsb">    try { </div><div class="t m0 x0 hb y370c ffd7 fs6 fc0 sc0 ls21 wsb">        mods[i].init(); </div><div class="t m0 x0 h15 y370d ffdb fs6 fc0 sc0 ls21 wsb">    } catch (ex) { </div><div class="t m0 x0 h16 y370e ffd7 fs6 fc0 sc0 ls21 wsb">        //在这里处理错误 </div><div class="t m0 x0 h15 y370f ffdb fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y3710 ffd7 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h4 y3711 ffd6 fs2 fc0 sc0 ls1f ws108">通过在for循环中添加try-catch语句，任何模块初始化时出错，都不会影响其他模块的初始化。</div><div class="t m0 x0 h5 y3712 ffd6 fs2 fc0 sc0 ls1f">在以上重写的代码中，如果有错误发生，相应的错误将会得到独立的处理，并不会影响到用户的体验。 </div><div class="t m0 x0 h20 ya06 ffd4 fs3 fc0 sc0 ls248 ws214">17.2.7 把错误记录到服务器 </div><div class="t m0 x0 h5 y3713 ffd6 fs2 fc0 sc0 ls8 wseb">开发Web应用程序过程中的一种常见的做法，就是集中保存错误日志，以便查找重要错误的原因。</div></div></div>
<div id="pf212" class="pf w0 h0" data-page-no="212"><div class="pc pc212 w0 h0"><div class="t m0 x0 h2 y1 ffcf fs0 fc0 sc0 ls7 ws0">512  第17章 错误处理与调试 </div><div class="t m0 x0 h3 y2 ffcf fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ffd6 fs2 fc0 sc0 ls8 wseb">例如数据库和服务器错误都会定期写入日志，而且会按照常用API进行分类。在复杂的Web 应用程序</div><div class="t m0 x0 h5 y4d ffd6 fs2 fc0 sc0 ls8 wseb">中，我们同样推荐你把JavaScript错误也回写到服务器。换句话说，也要将这些错误写入到保存服务器</div><div class="t m0 x0 h5 yd8 ffd6 fs2 fc0 sc0 ls8 wseb">端错误的地方，只不过要标明它们来自前端。把前后端的错误集中起来，能够极大地方便对数据的分析。 </div><div class="t m0 x0 h5 y28b ffd6 fs2 fc0 sc0 ls8 wseb">要建立这样一种JavaScript错误记录系统，首先需要在服务器上创建一个页面（或者一个服务器入</div><div class="t m0 x0 h4 yfdb ffd6 fs2 fc0 sc0 ls6 wsf7">口点），用于处理错误数据。这个页面的作用无非就是从查询字符串中取得数据，然后再将数据写入错</div><div class="t m0 x0 h5 y14e1 ffd6 fs2 fc0 sc0 ls8 wseb">误日志中。这个页面可能会使用如下所示的函数： </div><div class="t m0 x0 hb yb70 ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y14e2 ffd7 fs6 fc0 sc0 ls21 wsb">function logError(sev, msg){ </div><div class="t m0 x0 hb y174b ffd7 fs6 fc0 sc0 ls21 wsb">    var img = new Image(); </div><div class="t m0 x0 hb y174c ffd7 fs6 fc0 sc0 ls21 wsb">    img.src = &quot;log.php?sev=&quot; + encodeURIComponent(sev) + &quot;&amp;msg=&quot; + </div><div class="t m0 x0 hb y174d ffd7 fs6 fc0 sc0 ls21 wsb">              encodeURIComponent(msg); </div><div class="t m0 x0 hb y174e ffd7 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h4 y1aaa ffd6 fs2 fc0 sc0 ls8 wseb">这个logError()函数接收两个参数：表示严重程度的数值或字符串（视所用系统而异）及错误消</div><div class="t m0 x0 hc y3714 ffd6 fs2 fc0 sc0 ls8 wseb">息。其中，使用了Image对象来发送请求，这样做非常灵活，主要表现如下几方面。 </div><div class="t m0 x0 h5 y3715 ffd5 fs1 fc0 sc0 ls2"> 所有浏览器都支持Image对象，包括那些不支持XMLHttpRequest对象的浏览器。 </div><div class="t m0 x0 h4 y3716 ffd5 fs1 fc0 sc0 ls2"> 可以避免跨域限制。通常都是一台服务器要负责处理多台服务器的错误，而这种情况下使用</div><div class="t m0 x0 h5 y3717 ffd7 fs1 fc0 sc0 ls9 ws2">XMLHttpRequest是不行的。 </div><div class="t m0 x0 h5 y2649 ffd5 fs1 fc0 sc0 ls2"> 在记录错误的过程中出问题的概率比较低。大多数Ajax通信都是由JavaScript库提供的包装函</div><div class="t m0 x0 h4 y3718 ffd6 fs2 fc0 sc0 ls5 wsec">数来处理的，如果库代码本身有问题，而你还在依赖该库记录错误，可想而知，错误消息是不</div><div class="t m0 x0 h5 y2a5c ffd6 fs2 fc0 sc0 ls8 wseb">可能得到记录的。 </div><div class="t m0 x0 he y3719 ffd6 fs2 fc0 sc0 ls8 wseb">只要是使用try-catch语句，就应该把相应错误记录到日志中。来看下面的例子。 </div><div class="t m0 x0 hb y371a ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y371b ffd7 fs6 fc0 sc0 ls21 wsb">for (var i=0, len=mods.length; i &lt; len; i++){ </div><div class="t m0 x0 hb y371c ffd7 fs6 fc0 sc0 ls21 wsb">    try { </div><div class="t m0 x0 hb y371d ffd7 fs6 fc0 sc0 ls21 wsb">        mods[i].init(); </div><div class="t m0 x0 hb y371e ffd7 fs6 fc0 sc0 ls21 wsb">    } catch (ex){ </div><div class="t m0 x0 h15 y371f ffdb fs6 fc0 sc0 ls21 wsb">        logError(&quot;nonfatal&quot;, &quot;Module init failed: &quot; + ex.message); </div><div class="t m0 x0 hb y3720 ffd7 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y3721 ffd7 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h4 y14d1 ffd6 fs2 fc0 sc0 ls8 wseb">在这里，一旦模块初始化失败，就会调用logError()。第一个参数是&quot;nonfatal&quot;（非致命），表</div><div class="t m0 x0 h5 y3722 ffd6 fs2 fc0 sc0 ls8 wseb">示错误的严重程度。第二个参数是上下文信息加上真正的JavaScript错误消息。记录到服务器中的错误</div><div class="t m0 x0 h5 y3723 ffd6 fs2 fc0 sc0 ls8 wseb">消息应该尽可能多地带有上下文信息，以便鉴别导致错误的真正原因。 </div><div class="t m0 x0 hd y8b8 ffd4 fs7 fc0 sc0 ls245">17.3 调试技术 </div><div class="t m0 x0 h5 y3724 ffd6 fs2 fc0 sc0 ls8 wseb">在不那么容易找到JavaScript调试程序的年代，开发人员不得不发挥自己的创造力，通过各种方法</div><div class="t m0 x0 h4 y3725 ffd6 fs2 fc0 sc0 ls8 wseb">来调试自己的代码。结果，就出现了以这样或那样的方式置入代码，从而输出调试信息的做法。其中，</div><div class="t m0 x0 h1c y3726 ffd6 fs2 fc0 sc0 ls8 wseb">最常见的做法就是在要调试的代码中随处插入alert()函数。但这种做法一方面比较麻烦（调试之后还</div><div class="t m0 x0 h1e y32a ffd6 fs2 fc0 sc0 ls8 wseb">需要清理），另一方面还可能引入新问题（想象一下把某个alert()函数遗留在产品代码中的结果）。如</div><div class="t m0 x0 h5 y1d39 ffd6 fs2 fc0 sc0 ls8 wseb">今，已经有了很多更好的调试工具，因此我们也不再建议在调试中使用alert()了。 </div><div class="t m0 x0 h20 y3727 ffd4 fs3 fc0 sc0 ls248 ws214">17.3.1 将消息记录到控制台 </div><div class="t m0 x0 h5 y3728 ffcf fs2 fc0 sc0 ls2a ws21">IE8、Firefox、Opera、Chrome和Safari都有JavaScript控制台，可以用来查看 JavaScript错误。而</div></div></div>
<div id="pf213" class="pf w0 h0" data-page-no="213"><div class="pc pc213 w0 h0"><div class="t m0 x2 h2 y1 ffcf fs0 fc0 sc0 ls7 ws0">17.3 调试技术    513 </div><div class="t m0 x0 h3 y2 ffcf fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffd1 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ffd1 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffd1 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffd1 fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ffd1 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffd1 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffd1 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffd1 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffd1 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffd1 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffd1 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffd1 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ffd1 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ffd6 fs2 fc0 sc0 ls6f ws113">且，在这些浏览器中，都可以通过代码向控制台输出消息。对Firefox而言，需要安装 Firebug</div><div class="t m0 x0 h5 y4d ffd6 fs2 fc0 sc0 ls8">（www.getfirebug.com），因为Firefox要使用Firebug的控制台。对IE8、Firefox、Chrome和Safari来说，</div><div class="t m0 x0 he yd8 ffd6 fs2 fc0 sc0 ls8 wseb">则可以通过console对象向JavaScript控制台中写入消息，这个对象具有下列方法。 </div><div class="t m0 x0 h5 yd9 ffd5 fs1 fc0 sc0 ls2"> error(message)：将错误消息记录到控制台 </div><div class="t m0 x0 h5 y219 ffd5 fs1 fc0 sc0 ls2"> info(message)：将信息性消息记录到控制台 </div><div class="t m0 x0 h5 y8 ffd5 fs1 fc0 sc0 ls2"> log(message)：将一般消息记录到控制台 </div><div class="t m0 x0 h5 y9 ffd5 fs1 fc0 sc0 ls2"> warn(message)：将警告消息记录到控制台 </div><div class="t m0 x0 h5 y15f ffd6 fs2 fc0 sc0 ls71">在IE8、Firebug、Chrome和Safari中，用来记录消息的方法不同，控制台中显示的错误消息也不</div><div class="t m0 x0 h4 y2df1 ffd6 fs2 fc0 sc0 ls24">一样。错误消息带有红色图标，而警告消息带有黄色图标。以下函数展示了使用控制台输出消息的一</div><div class="t m0 x0 h5 y3729 ffd6 fs2 fc0 sc0 ls5">个示例。 </div><div class="t m0 x5 hb yeb5 ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1564 ffd7 fs6 fc0 sc0 ls21 wsb">function sum(num1, num2){ </div><div class="t m0 x0 hb y1565 ffd7 fs6 fc0 sc0 ls21 wsb">    console.log(&quot;Entering sum(), arguments are &quot; + num1 + &quot;,&quot; + num2); </div><div class="t m0 x0 hb y372a ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y372b ffd7 fs6 fc0 sc0 ls21 wsb">    console.log(&quot;Before calculation&quot;); </div><div class="t m0 x0 hb y372c ffd7 fs6 fc0 sc0 ls21 wsb">    var result = num1 + num2; </div><div class="t m0 x0 hb y372d ffd7 fs6 fc0 sc0 ls21 wsb">    console.log(&quot;After calculation&quot;); </div><div class="t m0 x0 hb y372e ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y372f ffd7 fs6 fc0 sc0 ls21 wsb">    console.log(&quot;Exiting sum()&quot;); </div><div class="t m0 x0 hb y3730 ffd7 fs6 fc0 sc0 ls21 wsb">    return result; </div><div class="t m0 x0 hb y3731 ffd7 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h5 y3732 ffd6 fs2 fc0 sc0 lsa ws10a">在调用这个sum()函数时，控制台中会出现一些消息，可以用来辅助调试。在Safari 中，通过</div><div class="t m0 x0 h5 y3733 ffd6 fs2 fc0 sc0 ls8">“Develop”（开发）菜单可以打开其JavaScript控制台（前面讨论过）；在Chrome中，单击“Control this </div><div class="t m0 x0 h5 y3734 ffcf fs2 fc0 sc0 lsb ws5">page”（控制当前页）按钮并选择“Developer”（开发人员）和“JavaScript console”（JavaScript 控制台）</div><div class="t m0 x0 h5 y3735 ffd6 fs2 fc0 sc0 ls8 wseb">即可；而在Firefox中，要打开控制台需要单击Firefox状态栏右下角的图标。IE8的控制台是其Developer </div><div class="t m0 x0 h5 y3736 ffcf fs2 fc0 sc0 ls1b ws6e">Tools（开发人员工具）扩展的一部分，通过“Tools”（工具）菜单可以找到，其控制台在“Script”（脚</div><div class="t m0 x0 h5 y3737 ffd6 fs2 fc0 sc0 ls8 wseb">本）选项卡中。 </div><div class="t m0 x0 h5 y3738 ffcf fs2 fc0 sc0 ls2b ws156">Opera 10.5之前的版本中，JavaScript控制台可以通过opera.postError()方法来访问。这个方法</div><div class="t m0 x0 h5 y1980 ffd6 fs2 fc0 sc0 ls8 wseb">接受一个参数，即要写入到控制台中的参数，其用法如下。 </div><div class="t m0 x5 hb y3739 ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y373a ffd7 fs6 fc0 sc0 ls21 wsb">function sum(num1, num2){ </div><div class="t m0 x0 h15 y373b ffdb fs6 fc0 sc0 ls21 wsb">    opera.postError(&quot;Entering sum(), arguments are &quot; + num1 + &quot;,&quot; + num2); </div><div class="t m0 x0 hb y373c ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y373d ffdb fs6 fc0 sc0 ls21 wsb">    opera.postError(&quot;Before calculation&quot;); </div><div class="t m0 x0 hb y373e ffd7 fs6 fc0 sc0 ls21 wsb">    var result = num1 + num2; </div><div class="t m0 x0 h15 y373f ffdb fs6 fc0 sc0 ls21 wsb">    opera.postError(&quot;After calculation&quot;); </div><div class="t m0 x0 hb y3740 ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y3741 ffdb fs6 fc0 sc0 ls21 wsb">    opera.postError(&quot;Exiting sum()&quot;); </div><div class="t m0 x0 hb y3742 ffd7 fs6 fc0 sc0 ls21 wsb">    return result; </div><div class="t m0 x0 hb y3743 ffd7 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h5 y470 ffd6 fs2 fc0 sc0 ls8 wseb">别看opera.postError()方法的名字好像是只能输出错误，但实际上能通过它向JavaScript控制</div><div class="t m0 x0 h5 y3744 ffd6 fs2 fc0 sc0 ls8 wseb">台中写入任何信息。 </div><div class="t m0 x0 h5 y472 ffd6 fs2 fc0 sc0 ls8 wseb">还有一种方案是使用LiveConnect，也就是在JavaScript中运行Java 代码。Firefox、Safari和Opera</div><div class="t m0 x0 h5 y3745 ffd6 fs2 fc0 sc0 ls8 wseb">都支持LiveConnect，因此可以操作Java控制台。例如，通过下列代码就可以在 JavaScript中把消息写</div><div class="t m0 x0 h5 y3746 ffd6 fs2 fc0 sc0 ls8 wseb">入到Java控制台。 </div><div class="t m0 x5 hb y3747 ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3748 ffd7 fs6 fc0 sc0 ls21 wsb">java.lang.System.out.println(&quot;Your message&quot;); </div></div></div>
<div id="pf214" class="pf w0 h0" data-page-no="214"><div class="pc pc214 w0 h0"><div class="t m0 x0 h2 y1 ffcf fs0 fc0 sc0 ls7 ws0">514  第17章 错误处理与调试 </div><div class="t m0 x0 h3 y2 ffcf fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ffd6 fs2 fc0 sc0 ls8 wseb">可以用这行代码替代console.log()或opera.postError()，如下所示。 </div><div class="t m0 x0 hb yfb2 ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3749 ffd7 fs6 fc0 sc0 ls21 wsb">function sum(num1, num2){ </div><div class="t m0 x0 h15 y374a ffdb fs6 fc0 sc0 ls21 ws38c">    java.lang.System.out.println(&quot;Entering sum(), arguments are &quot; + num1 + &quot;,&quot; + num2); </div><div class="t m0 x0 hb y374b ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y374c ffdb fs6 fc0 sc0 ls21 wsb">    java.lang.System.out.println(&quot;Before calculation&quot;); </div><div class="t m0 x0 hb y374d ffd7 fs6 fc0 sc0 ls21 wsb">    var result = num1 + num2; </div><div class="t m0 x0 h15 y374e ffdb fs6 fc0 sc0 ls21 wsb">    java.lang.System.out.println(&quot;After calculation&quot;); </div><div class="t m0 x0 hb y374f ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y3750 ffdb fs6 fc0 sc0 ls21 wsb">    java.lang.System.out.println(&quot;Exiting sum()&quot;); </div><div class="t m0 x0 hb y3751 ffd7 fs6 fc0 sc0 ls21 wsb">    return result; </div><div class="t m0 x0 hb y3752 ffd7 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h5 y3753 ffd6 fs2 fc0 sc0 ls8 wseb">如果系统设置恰当，可以在调用LiveConnect时就立即显示Java控制台。在Firefox中，通过“Tools”</div><div class="t m0 x0 h5 y3754 ffd6 fs2 fc0 sc0 ls8 wseb">（工具）菜单可以打开Java控制台；在Opera中，要打开 Java控制台，可以选择菜单“Tools”（工具）</div><div class="t m0 x0 h5 y3755 ffd6 fs2 fc0 sc0 ls8">及“Advanced”（高级）。Safari没有内置对Java控制台的支持，必须单独运行。 </div><div class="t m0 x0 h5 y3756 ffd6 fs2 fc0 sc0 ls8 wseb">不存在一种跨浏览器向JavaScript控制台写入消息的机制，但下面的函数倒可以作为统一的接口。 </div><div class="t m0 x0 hb y3757 ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3758 ffd7 fs6 fc0 sc0 ls21 wsb">function log(message){ </div><div class="t m0 x0 hb y3759 ffd7 fs6 fc0 sc0 ls21 wsb">    if (typeof console == &quot;object&quot;){ </div><div class="t m0 x0 hb y375a ffd7 fs6 fc0 sc0 ls21 wsb">        console.log(message); </div><div class="t m0 x0 hb y375b ffd7 fs6 fc0 sc0 ls21 wsb">    } else if (typeof opera == &quot;object&quot;){ </div><div class="t m0 x0 hb y375c ffd7 fs6 fc0 sc0 ls21 wsb">        opera.postError(message); </div><div class="t m0 x0 hb y375d ffd7 fs6 fc0 sc0 ls21 wsb">    } else if (typeof java == &quot;object&quot; &amp;&amp; typeof java.lang == &quot;object&quot;){ </div><div class="t m0 x0 hb y375e ffd7 fs6 fc0 sc0 ls21 wsb">        java.lang.System.out.println(message); </div><div class="t m0 x0 hb y375f ffd7 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y3760 ffd7 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x2 hf y232b ffdd fs2 fc0 sc0 ls25 wsb">ConsoleLoggingExample01.htm </div><div class="t m0 x0 h5 y1327 ffd6 fs2 fc0 sc0 ls8 wseb">这个log()函数检测了哪个JavaScript控制台接口可用，然后使用相应的接口。可以在任何浏览器</div><div class="t m0 x0 h5 y3761 ffd6 fs2 fc0 sc0 ls8 wseb">中安全地使用这个函数，不会导致任何错误，例如： </div><div class="t m0 x0 hb y3762 ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3763 ffd7 fs6 fc0 sc0 ls21 wsb">function sum(num1, num2){ </div><div class="t m0 x0 h15 y3764 ffdb fs6 fc0 sc0 ls21 wsb">    log(&quot;Entering sum(), arguments are &quot; + num1 + &quot;,&quot; + num2); </div><div class="t m0 x0 hb y3765 ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y3766 ffdb fs6 fc0 sc0 ls21 wsb">    log(&quot;Before calculation&quot;); </div><div class="t m0 x0 hb y3767 ffd7 fs6 fc0 sc0 ls21 wsb">    var result = num1 + num2; </div><div class="t m0 x0 h15 y3768 ffdb fs6 fc0 sc0 ls21 wsb">    log(&quot;After calculation&quot;); </div><div class="t m0 x0 hb y3769 ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y376a ffdb fs6 fc0 sc0 ls21 wsb">    log(&quot;Exiting sum()&quot;); </div><div class="t m0 x0 hb y376b ffd7 fs6 fc0 sc0 ls21 wsb">    return result; </div><div class="t m0 x0 hb y376c ffd7 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x2 hf y376d ffdd fs2 fc0 sc0 ls25 wsb">ConsoleLoggingExample01.htm </div><div class="t m0 x0 h5 y376e ffd6 fs2 fc0 sc0 ls3b">向JavaScript控制台中写入消息可以辅助调试代码，但在发布应用程序时，还必须要移除所有消息。</div><div class="t m0 x0 h5 y130c ffd6 fs2 fc0 sc0 ls8 wseb">在部署应用程序时，可以通过手工或通过特定的代码处理步骤来自动完成清理工作。 </div><div class="t m0 x5 ha y376f ffd0 fs2 fc0 sc0 ls8 ws14">记录消息要比使用alert()函数更可取，因为警告框会阻断程序的执行，而在测</div><div class="t m0 x0 h5 y3770 ffd0 fs2 fc0 sc0 ls8 ws14">定异步处理对时间的影响时，使用警告框会影响结果。 </div></div></div>
<div id="pf215" class="pf w0 h0" data-page-no="215"><div class="pc pc215 w0 h0"><div class="t m0 x2 h2 y1 ffcf fs0 fc0 sc0 ls7 ws0">17.3 调试技术    515 </div><div class="t m0 x0 h3 y2 ffcf fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffd1 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ffd1 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffd1 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffd1 fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ffd1 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffd1 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffd1 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffd1 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffd1 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffd1 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffd1 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffd1 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ffd1 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h20 y12d ffd4 fs3 fc0 sc0 ls248 ws214">17.3.2 将消息记录到当前页面 </div><div class="t m0 x0 h4 y3771 ffd6 fs2 fc0 sc0 ls8 wseb">另一种输出调试消息的方式，就是在页面中开辟一小块区域，用以显示消息。这个区域通常是一个</div><div class="t m0 x0 h4 y3772 ffd6 fs2 fc0 sc0 ls8 wseb">元素，而该元素可以总是出现在页面中，但仅用于调试目的；也可以是一个根据需要动态创建的元素。</div><div class="t m0 x0 he y3773 ffd6 fs2 fc0 sc0 ls8 wseb">例如，可以将log()函数修改为如下所示： </div><div class="t m0 x5 hb y3774 ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3775 ffd7 fs6 fc0 sc0 ls21 wsb">function log(message){ </div><div class="t m0 x0 hb y3776 ffd7 fs6 fc0 sc0 ls21 wsb">    var console = document.getElementById(&quot;debuginfo&quot;); </div><div class="t m0 x0 hb y3777 ffd7 fs6 fc0 sc0 ls21 wsb">    if (console === null){ </div><div class="t m0 x0 hb y3778 ffd7 fs6 fc0 sc0 ls21 wsb">        console = document.createElement(&quot;div&quot;); </div><div class="t m0 x0 hb y3779 ffd7 fs6 fc0 sc0 ls21 wsb">        console.id = &quot;debuginfo&quot;; </div><div class="t m0 x0 hb y377a ffd7 fs6 fc0 sc0 ls21 wsb">        console.style.background = &quot;#dedede&quot;; </div><div class="t m0 x0 hb y377b ffd7 fs6 fc0 sc0 ls21 wsb">        console.style.border = &quot;1px solid silver&quot;; </div><div class="t m0 x0 hb y377c ffd7 fs6 fc0 sc0 ls21 wsb">        console.style.padding = &quot;5px&quot;; </div><div class="t m0 x0 hb y377d ffd7 fs6 fc0 sc0 ls21 wsb">        console.style.width = &quot;400px&quot;; </div><div class="t m0 x0 hb y377e ffd7 fs6 fc0 sc0 ls21 wsb">        console.style.position = &quot;absolute&quot;; </div><div class="t m0 x0 hb y377f ffd7 fs6 fc0 sc0 ls21 wsb">        console.style.right = &quot;0px&quot;; </div><div class="t m0 x0 hb y3780 ffd7 fs6 fc0 sc0 ls21 wsb">        console.style.top = &quot;0px&quot;; </div><div class="t m0 x0 hb y3781 ffd7 fs6 fc0 sc0 ls21 wsb">        document.body.appendChild(console); </div><div class="t m0 x0 hb y3782 ffd7 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y3783 ffd7 fs6 fc0 sc0 ls21 wsb">    console.innerHTML += &quot;&lt;p&gt;&quot; + message + &quot;&lt;/p&gt;&quot;; </div><div class="t m0 x0 hb y3784 ffd7 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x2 hf y3785 ffdd fs2 fc0 sc0 ls79 wsb">PageLoggingExample01.htm </div><div class="t m0 x0 h4 y3786 ffd6 fs2 fc0 sc0 ls8 wseb">这个修改后的log()函数首先检测是否已经存在调试元素，如果没有则会新创建一个&lt;div&gt;元素，</div><div class="t m0 x0 h4 y3787 ffd6 fs2 fc0 sc0 ls8 wseb">并为该元素应用一些样式，以便与页面中的其他元素区别开。然后，又使用innerHTML将消息写入到</div><div class="t m0 x0 hc y3788 ffd6 fs2 fc0 sc0 ls8 wseb">这个&lt;div&gt;元素中。结果就是页面中会有一小块区域显示错误消息。这种技术在不支持JavaScript控制</div><div class="t m0 x0 h5 y3789 ffd6 fs2 fc0 sc0 ls8 wseb">台的IE7及更早版本或其他浏览器中十分有用。 </div><div class="t m0 x5 h5 y378a ffd0 fs2 fc0 sc0 ls30 ws12c">与把错误消息记录到控制台相似，把错误消息输出到页面的代码也要在发布前 </div><div class="t m0 x5 h5 y378b ffd0 fs2 fc0 sc0 ls8">删除。 </div><div class="t m0 x0 h20 y378c ffd4 fs3 fc0 sc0 ls248 ws214">17.3.3 抛出错误 </div><div class="t m0 x0 h4 y2584 ffd6 fs2 fc0 sc0 ls8 wseb">如前所述，抛出错误也是一种调试代码的好办法。如果错误消息很具体，基本上就可以把它当作确</div><div class="t m0 x0 h4 y378d ffd6 fs2 fc0 sc0 ls8 wseb">定错误来源的依据。但这种错误消息必须能够明确给出导致错误的原因，才能省去其他调试操作。来看</div><div class="t m0 x0 h5 y378e ffd6 fs2 fc0 sc0 ls8 wseb">下面的函数： </div><div class="t m0 x5 hb y378f ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3790 ffd7 fs6 fc0 sc0 ls21 wsb">function divide(num1, num2){ </div><div class="t m0 x0 hb y3791 ffd7 fs6 fc0 sc0 ls21 wsb">    return num1 / num2; </div><div class="t m0 x0 hb y3792 ffd7 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h4 y3793 ffd6 fs2 fc0 sc0 ls8 wseb">这个简单的函数计算两个数的除法，但如果有一个参数不是数值，它会返回NaN。类似这样简单的</div><div class="t m0 x0 hc y3794 ffd6 fs2 fc0 sc0 ls8 wseb">计算如果返回NaN，就会在Web应用程序中导致问题。对此，可以在计算之前，先检测每个参数是否都</div><div class="t m0 x0 h5 y3795 ffd6 fs2 fc0 sc0 ls8 wseb">是数值。例如： </div><div class="t m0 x5 hb y4eb ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3796 ffd7 fs6 fc0 sc0 ls21 wsb">function divide(num1, num2){ </div><div class="t m0 x0 h15 y3797 ffdb fs6 fc0 sc0 ls21 wsb">    if (typeof num1 != &quot;number&quot; || typeof num2 != &quot;number&quot;){ </div><div class="t m0 x0 h15 y3798 ffdb fs6 fc0 sc0 ls21 wsb">        throw new Error(&quot;divide(): Both arguments must be numbers.&quot;); </div><div class="t m0 x0 h15 y3799 ffdb fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y379a ffd7 fs6 fc0 sc0 ls21 wsb">    return num1 / num2; </div><div class="t m0 x0 hb y379b ffd7 fs6 fc0 sc0 ls21 wsb">} </div></div></div>
<div id="pf216" class="pf w0 h0" data-page-no="216"><div class="pc pc216 w0 h0"><div class="t m0 x0 h2 y1 ffcf fs0 fc0 sc0 ls7 ws0">516  第17章 错误处理与调试 </div><div class="t m0 x0 h3 y2 ffcf fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ffd6 fs2 fc0 sc0 ls8 wseb">在此，如果有一个参数不是数值，就会抛出错误。错误消息中包含了函数的名字，以及导致错误的</div><div class="t m0 x0 h4 y4d ffd6 fs2 fc0 sc0 ls8 wseb">真正原因。浏览器只要报告了这个错误消息，我们就可以立即知道错误来源及问题的性质。相对来说，</div><div class="t m0 x0 h5 yd8 ffd6 fs2 fc0 sc0 ls8 wseb">这种具体的错误消息要比那些泛泛的浏览器错误消息更有用。 </div><div class="t m0 x0 h1c y28b ffd6 fs2 fc0 sc0 ls8 wseb">对于大型应用程序来说，自定义的错误通常都使用assert()函数抛出。这个函数接受两个参数，</div><div class="t m0 x0 h1e y15d ffd6 fs2 fc0 sc0 ls8 wseb">一个是求值结果应该为true的条件，另一个是条件为false时要抛出的错误。以下就是一个非常基本</div><div class="t m0 x0 hc y21a ffd6 fs2 fc0 sc0 ls170">的assert()函数。 </div><div class="t m0 x0 hb yb70 ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y14e2 ffd7 fs6 fc0 sc0 ls21 wsb">function assert(condition, message){ </div><div class="t m0 x0 hb y174b ffd7 fs6 fc0 sc0 ls21 wsb">    if (!condition){ </div><div class="t m0 x0 hb y174c ffd7 fs6 fc0 sc0 ls21 wsb">        throw new Error(message); </div><div class="t m0 x0 hb y174d ffd7 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y174e ffd7 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x2 hf y1454 ffdd fs2 fc0 sc0 lsb wsb">AssertExample01.htm </div><div class="t m0 x0 h4 y379d ffd6 fs2 fc0 sc0 ls8 wseb">可以用这个assert()函数代替某些函数中需要调试的if语句，以便输出错误消息。下面是使用</div><div class="t m0 x0 h5 y379e ffd6 fs2 fc0 sc0 ls8 wseb">这个函数的例子。 </div><div class="t m0 x0 hb y379f ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y37a0 ffd7 fs6 fc0 sc0 ls21 wsb">function divide(num1, num2){ </div><div class="t m0 x0 h15 y37a1 ffdb fs6 fc0 sc0 ls21 wsb">    assert(typeof num1 == &quot;number&quot; &amp;&amp; typeof num2 == &quot;number&quot;, </div><div class="t m0 x0 h15 y37a2 ffdb fs6 fc0 sc0 ls21 wsb">           &quot;divide(): Both arguments must be numbers.&quot;); </div><div class="t m0 x0 hb y37a3 ffd7 fs6 fc0 sc0 ls21 wsb">    return num1 / num2; </div><div class="t m0 x0 hb y37a4 ffd7 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x2 hf y2c18 ffdd fs2 fc0 sc0 lsb wsb">AssertExample01.htm </div><div class="t m0 x0 h5 y8ad ffd6 fs2 fc0 sc0 ls8 wseb">可见，使用assert()函数可以减少抛出错误所需的代码量，而且也比前面的代码更容易看懂。 </div><div class="t m0 x0 hd y37a5 ffd4 fs7 fc0 sc0 ls245">17.4 常见的IE 错误 </div><div class="t m0 x0 h5 y37a6 ffd6 fs2 fc0 sc0 ls8 wseb">多年以来，IE一直都是最难于调试JavaScript错误的浏览器。IE给出的错误消息一般很短又语焉不</div><div class="t m0 x0 h5 y29b5 ffd6 fs2 fc0 sc0 ls8 wseb">详，而且上下文信息也很少，有时甚至一点都没有。但作为用户最多的浏览器，如何看懂IE给出的错</div><div class="t m0 x0 h5 y37a7 ffd6 fs2 fc0 sc0 ls8 wseb">误也是最受关注的。下面几小节将分别探讨一些在IE中难于调试的JavaScript错误。 </div><div class="t m0 x0 h20 y1b86 ffd4 fs3 fc0 sc0 ls248 ws214">17.4.1 操作终止 </div><div class="t m0 x0 h5 y37a8 ffd6 fs2 fc0 sc0 ls3b">在IE8之前的版本中，存在一个相对于其他浏览器而言，最令人迷惑、讨厌，也最难于调试的错误：</div><div class="t m0 x0 h5 y37a9 ffd6 fs2 fc0 sc0 ls6 wsf7">操作终止（operation aborted）。在修改尚未加载完成的页面时，就会发生操作终止错误。发生错误时，</div><div class="t m0 x0 h5 y37aa ffd6 fs2 fc0 sc0 ls8 wseb">会出现一个模态对话框，告诉你“操作终止。”单击确定（OK）按钮，则卸载整个页面，继而显示一张</div><div class="t m0 x0 h5 yedf ffd6 fs2 fc0 sc0 ls8 wseb">空白屏幕；此时要进行调试非常困难。下面的示例将会导致操作终止错误。 </div><div class="t m0 x0 hb y37ab ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y37ac ffd7 fs6 fc0 sc0 ls21 wsb">&lt;!DOCTYPE html&gt; </div><div class="t m0 x0 hb y37ad ffd7 fs6 fc0 sc0 ls21 wsb">&lt;html&gt; </div><div class="t m0 x0 hb y37ae ffd7 fs6 fc0 sc0 ls21 wsb">&lt;head&gt; </div><div class="t m0 x0 hb y37af ffd7 fs6 fc0 sc0 ls21 wsb">    &lt;title&gt;Operation Aborted Example&lt;/title&gt; </div><div class="t m0 x0 hb y37b0 ffd7 fs6 fc0 sc0 ls21 wsb">&lt;/head&gt; </div><div class="t m0 x0 hb y37b1 ffd7 fs6 fc0 sc0 ls21 wsb">&lt;body&gt; </div><div class="t m0 x0 hb y37b2 ffd7 fs6 fc0 sc0 ls21 wsb">    &lt;p&gt;The following code should cause an Operation Aborted error in IE versions  </div><div class="t m0 x0 hb y37b3 ffd7 fs6 fc0 sc0 ls21 wsb">    prior to 8.&lt;/p&gt; </div></div></div>
<div id="pf217" class="pf w0 h0" data-page-no="217"><div class="pc pc217 w0 h0"><div class="t m0 x2 h2 y1 ffcf fs0 fc0 sc0 ls7 ws0">17.4 常见的IE错误   517 </div><div class="t m0 x0 h3 y2 ffcf fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffd1 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ffd1 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffd1 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffd1 fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ffd1 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffd1 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffd1 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffd1 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffd1 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffd1 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffd1 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffd1 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ffd1 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y44f ffd7 fs6 fc0 sc0 ls21 wsb">    &lt;div&gt; </div><div class="t m0 x0 hb y450 ffd7 fs6 fc0 sc0 ls21 wsb">        &lt;script type=&quot;text/javascript&quot;&gt;         </div><div class="t m0 x0 hb y451 ffd7 fs6 fc0 sc0 ls21 wsb">            document.body.appendChild(document.createElement(&quot;div&quot;));     </div><div class="t m0 x0 hb y452 ffd7 fs6 fc0 sc0 ls21 wsb">        &lt;/script&gt; </div><div class="t m0 x0 hb y453 ffd7 fs6 fc0 sc0 ls21 wsb">    &lt;/div&gt; </div><div class="t m0 x0 hb y454 ffd7 fs6 fc0 sc0 ls21 wsb">&lt;/body&gt; </div><div class="t m0 x0 hb y455 ffd7 fs6 fc0 sc0 ls21 wsb">&lt;/html&gt; </div><div class="t m0 x5 hb y37b4 ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y37b5 ffdd fs2 fc0 sc0 ls25 wsb">OperationAbortedExample01.htm </div><div class="t m0 x0 h5 y2fdf ffd6 fs2 fc0 sc0 ls8 wseb">这个例子中存在的问题是：JavaScript代码在页面尚未加载完毕时就要修改document.body，而且</div><div class="t m0 x0 h4 y37b6 ffd7 fs1 fc0 sc0 ls9 ws2">&lt;script&gt;元素还不是&lt;body&gt;元素的直接子元素。准确一点说，当&lt;script&gt;节点被包含在某个元素中，</div><div class="t m0 x0 hc y37b7 ffd6 fs2 fc0 sc0 ls8 wseb">而且JavaScript代码又要使用appendChild()、innerHTML或其他 DOM方法修改该元素的父元素或</div><div class="t m0 x0 h5 y37b8 ffd6 fs2 fc0 sc0 ls8 wseb">祖先元素时，将会发生操作终止错误（因为只能修改已经加载完毕的元素）。 </div><div class="t m0 x0 h4 yfbe ffd6 fs2 fc0 sc0 ls8 wseb">要避免这个问题，可以等到目标元素加载完毕后再对它进行操作，或者使用其他操作方法。例如，</div><div class="t m0 x0 h1c y37b9 ffd6 fs2 fc0 sc0 ls420">为document.body添加一个绝对定位在页面上的覆盖层，就是一种非常常见的操作。通常，开发人员</div><div class="t m0 x0 h1e y37ba ffd6 fs2 fc0 sc0 ls8 wseb">都是使用appendChild()方法来添加这个元素的，但换成使用insertBefore()方法也很容易。因此，</div><div class="t m0 x0 h5 y37bb ffd6 fs2 fc0 sc0 ls8 wseb">只要修改前面例子中的一行代码，就可以避免操作终止错误。 </div><div class="t m0 x5 hb y37bc ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y37bd ffd7 fs6 fc0 sc0 ls21 wsb">&lt;!DOCTYPE html&gt; </div><div class="t m0 x0 hb y37be ffd7 fs6 fc0 sc0 ls21 wsb">&lt;html&gt; </div><div class="t m0 x0 hb y37bf ffd7 fs6 fc0 sc0 ls21 wsb">&lt;head&gt; </div><div class="t m0 x0 hb y37c0 ffd7 fs6 fc0 sc0 ls21 wsb">    &lt;title&gt;Operation Aborted Example&lt;/title&gt; </div><div class="t m0 x0 hb y37c1 ffd7 fs6 fc0 sc0 ls21 wsb">&lt;/head&gt; </div><div class="t m0 x0 hb y37c2 ffd7 fs6 fc0 sc0 ls21 wsb">&lt;body&gt; </div><div class="t m0 x0 hb y37c3 ffd7 fs6 fc0 sc0 ls21 wsb">    &lt;p&gt;The following code should not cause an Operation Aborted error in IE  </div><div class="t m0 x0 hb y37c4 ffd7 fs6 fc0 sc0 ls21 wsb">    versions prior to 8.&lt;/p&gt; </div><div class="t m0 x0 hb y37c5 ffd7 fs6 fc0 sc0 ls21 wsb">    &lt;div&gt; </div><div class="t m0 x0 hb y37c6 ffd7 fs6 fc0 sc0 ls21 wsb">        &lt;script type=&quot;text/javascript&quot;&gt;         </div><div class="t m0 x0 h15 y37c7 ffdb fs6 fc0 sc0 ls21 wsb">            document.body.insertBefore(document.createElement(&quot;div&quot;),  </div><div class="t m0 x0 h15 y37c8 ffdb fs6 fc0 sc0 ls21 wsb">                                       document.body.firstChild);     </div><div class="t m0 x0 hb y37c9 ffd7 fs6 fc0 sc0 ls21 wsb">        &lt;/script&gt; </div><div class="t m0 x0 hb y37ca ffd7 fs6 fc0 sc0 ls21 wsb">    &lt;/div&gt; </div><div class="t m0 x0 hb y37cb ffd7 fs6 fc0 sc0 ls21 wsb">&lt;/body&gt; </div><div class="t m0 x0 hb y37cc ffd7 fs6 fc0 sc0 ls21 wsb">&lt;/html&gt; </div><div class="t m0 x2 hf y37cd ffdd fs2 fc0 sc0 ls25 wsb">OperationAbortedExample02.htm </div><div class="t m0 x0 h4 y37ce ffd6 fs2 fc0 sc0 ls8 wseb">在这个例子中，新的&lt;div&gt;元素被添加到document.body的开头部分而不是末尾。因为完成这一</div><div class="t m0 x0 h5 y37cf ffd6 fs2 fc0 sc0 ls8 wseb">操作所需的所有信息在脚本运行时都是已知的，所以这不会引发错误。 </div><div class="t m0 x0 hc y37d0 ffd6 fs2 fc0 sc0 ls1f ws108">除了改变方法之外，还可以把&lt;script&gt;元素从包含元素中移出来，直接作为&lt;body&gt;的子元素。例如： </div><div class="t m0 x0 hb y37d1 ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y37d2 ffd7 fs6 fc0 sc0 ls21 wsb">&lt;!DOCTYPE html&gt; </div><div class="t m0 x0 hb y37d3 ffd7 fs6 fc0 sc0 ls21 wsb">&lt;html&gt; </div><div class="t m0 x0 hb y37d4 ffd7 fs6 fc0 sc0 ls21 wsb">&lt;head&gt; </div><div class="t m0 x0 hb y37d5 ffd7 fs6 fc0 sc0 ls21 wsb">    &lt;title&gt;Operation Aborted Example&lt;/title&gt; </div><div class="t m0 x0 hb y37d6 ffd7 fs6 fc0 sc0 ls21 wsb">&lt;/head&gt; </div><div class="t m0 x0 hb y37d7 ffd7 fs6 fc0 sc0 ls21 wsb">&lt;body&gt; </div><div class="t m0 x0 hb y37d8 ffd7 fs6 fc0 sc0 ls21 wsb">    &lt;p&gt;The following code should not cause an Operation Aborted error in IE </div><div class="t m0 x0 hb y37d9 ffd7 fs6 fc0 sc0 ls21 wsb">    versions prior to 8.&lt;/p&gt; </div><div class="t m0 x0 hb y37da ffd7 fs6 fc0 sc0 ls21 wsb">    &lt;div&gt; </div><div class="t m0 x0 hb y37db ffd7 fs6 fc0 sc0 ls21 wsb">    &lt;/div&gt; </div><div class="t m0 x0 h15 y37dc ffdb fs6 fc0 sc0 ls21 wsb">    &lt;script type=&quot;text/javascript&quot;&gt;         </div><div class="t m0 x0 h15 y37dd ffdb fs6 fc0 sc0 ls21 wsb">        document.body.appendChild(document.createElement(&quot;div&quot;));     </div><div class="t m0 x0 h15 y37de ffdb fs6 fc0 sc0 ls21 wsb">    &lt;/script&gt; </div></div></div>
<div id="pf218" class="pf w0 h0" data-page-no="218"><div class="pc pc218 w0 h0"><div class="t m0 x0 h2 y1 ffcf fs0 fc0 sc0 ls7 ws0">518  第17章 错误处理与调试 </div><div class="t m0 x0 h3 y2 ffcf fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y44f ffd7 fs6 fc0 sc0 ls21 wsb">&lt;/body&gt; </div><div class="t m0 x0 hb y450 ffd7 fs6 fc0 sc0 ls21 wsb">&lt;/html&gt; </div><div class="t m0 x2 hf y2d8 ffdd fs2 fc0 sc0 ls25 wsb">OperationAbortedExample03.htm </div><div class="t m0 x0 h5 y37e0 ffd6 fs2 fc0 sc0 ls8 wseb">这一次也不会发生错误，因为脚本修改的是它的直接父元素，而不再是间接的祖先元素。 </div><div class="t m0 x0 h5 y37e1 ffd6 fs2 fc0 sc0 ls42 wsf0">在同样的情况下，IE8不再抛出操作终止错误，而是抛出常规的JavaScript错误，带有如下错误消息： </div><div class="t m0 x0 hb y37e2 ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y37e3 ffd7 fs6 fc0 sc0 ls21 wsb">HTML Parsing Error: Unable to modify the parent container element before the child </div><div class="t m0 x0 hb y37e4 ffd7 fs6 fc0 sc0 ls21 wsb">element is closed (KB927917). </div><div class="t m0 x0 hb y37e5 ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y31b1 ffd6 fs2 fc0 sc0 ls8 wseb">不过，虽然浏览器抛出的错误不同，但解决方案仍然是一样的。 </div><div class="t m0 x0 h20 y37e6 ffd4 fs3 fc0 sc0 ls248 ws214">17.4.2 无效字符 </div><div class="t m0 x0 h5 y37e7 ffd6 fs2 fc0 sc0 ls8 wseb">根据语法，JavaScript文件必须只包含特定的字符。在JavaScript文件中存在无效字符时，IE会抛出</div><div class="t m0 x0 h5 y37e8 ffd6 fs2 fc0 sc0 ls8 wseb">无效字符（invalid character）错误。所谓无效字符，就是JavaScript语法中未定义的字符。例如，有一</div><div class="t m0 x0 hc y37e9 ffd6 fs2 fc0 sc0 ls8 wseb">个很像减号但却由Unicode值8211表示的字符（\u2013），就不能用作常规的减号（ASCII编码为45），</div><div class="t m0 x0 h5 y37ea ffd6 fs2 fc0 sc0 ls8 wseb">因为JavaScript语法中没有定义该字符。这个字符通常是在Word 文档中自动插入的。如果你的代码是</div><div class="t m0 x0 h5 y37eb ffd6 fs2 fc0 sc0 ls3b">从Word文档中复制到文本编辑器中，然后又在IE中运行的，那么就可能会遇到无效字符错误。其他浏</div><div class="t m0 x0 h5 y37ec ffd6 fs2 fc0 sc0 ls8 wseb">览器对无效字符做出的反应与IE类似，Firefox会抛出非法字符（illegal character）错误，Safari会报告</div><div class="t m0 x0 h5 y37ed ffd6 fs2 fc0 sc0 ls8 wseb">发生了语法错误，而Opera则会报告发生了ReferenceError（引用错误），因为它会将无效字符解释</div><div class="t m0 x0 h5 y37ee ffd6 fs2 fc0 sc0 ls8 wseb">为未定义的标识符。 </div><div class="t m0 x0 h20 y3146 ffd4 fs3 fc0 sc0 ls248 ws214">17.4.3 未找到成员 </div><div class="t m0 x0 h5 ydad ffd6 fs2 fc0 sc0 ls8 wseb">如前所述，IE中的所有DOM对象都是以COM 对象，而非原生JavaScript对象的形式实现的。这</div><div class="t m0 x0 h5 y1b63 ffd6 fs2 fc0 sc0 ls8 wseb">会导致一些与垃圾收集相关的非常奇怪的行为。IE中的未找到成员（Member not found）错误，就是由</div><div class="t m0 x0 h5 y37ef ffd6 fs2 fc0 sc0 ls8 wseb">于垃圾收集例程配合错误所直接导致的。 </div><div class="t m0 x0 h4 y37f0 ffd6 fs2 fc0 sc0 ls8 wseb">具体来说，如果在对象被销毁之后，又给该对象赋值，就会导致未找到成员错误。而导致这个错误</div><div class="t m0 x0 h14 y37f1 ffd6 fs2 fc0 sc0 ls8 wseb">的，一定是COM对象。发生这个错误的最常见情形是使用event对象的时候。IE 中的event对象是</div><div class="t m0 x0 h4 y26ba ffd7 fs1 fc0 sc0 ls9 ws2">window的属性，该对象在事件发生时创建，在最后一个事件处理程序执行完毕后销毁。假设你在一个</div><div class="t m0 x0 h4 y345 ffd6 fs2 fc0 sc0 ls8 wseb">闭包中使用了event对象，而该闭包不会立即执行，那么在将来调用它并给event的属性赋值时，就</div><div class="t m0 x0 h5 y2b20 ffd6 fs2 fc0 sc0 ls8 wseb">会导致未找到成员错误，如下面的例子所示。 </div><div class="t m0 x0 hb y37f2 ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y37f3 ffd7 fs6 fc0 sc0 ls21 wsb">document.onclick = function(){ </div><div class="t m0 x0 hb y37f4 ffd7 fs6 fc0 sc0 ls21 wsb">    var event = window.event; </div><div class="t m0 x0 hb y37f5 ffd7 fs6 fc0 sc0 ls21 wsb">    setTimeout(function(){ </div><div class="t m0 x0 h16 y37f6 ffd7 fs6 fc0 sc0 ls21 wsb">        event.returnValue = false;        //未找到成员错误 </div><div class="t m0 x0 hb y37f7 ffd7 fs6 fc0 sc0 ls21 wsb">    }, 1000); </div><div class="t m0 x0 hb y37f8 ffd7 fs6 fc0 sc0 ls21 wsb">};  </div><div class="t m0 x0 h4 y37f9 ffd6 fs2 fc0 sc0 ls8 wseb">在这段代码中，我们将一个单击事件处理程序指定给了文档。在事件处理程序中，window.event</div><div class="t m0 x0 h4 y3122 ffd6 fs2 fc0 sc0 ls8 wseb">被保存在event变量中。然后，传入setTimeout()中的闭包里又包含了event变量。当单击事件处</div><div class="t m0 x0 h4 y37fa ffd6 fs2 fc0 sc0 ls8 wseb">理程序执行完毕后，event对象就会被销毁，因而闭包中引用对象的成员就成了不存在的了。换句话说，</div><div class="t m0 x0 h5 y37fb ffd6 fs2 fc0 sc0 ls8 wseb">由于不能在COM对象被销毁之后再给其成员赋值，在闭包中给returnValue赋值就会导致未找到成</div><div class="t m0 x0 h5 y37fc ffd6 fs2 fc0 sc0 ls8">员错误。 </div></div></div>
<div id="pf219" class="pf w0 h0" data-page-no="219"><div class="pc pc219 w0 h0"><div class="t m0 x2 h2 y1 ffcf fs0 fc0 sc0 ls7 ws0">17.4 常见的IE错误   519 </div><div class="t m0 x0 h3 y2 ffcf fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffd1 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ffd1 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffd1 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffd1 fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ffd1 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ffd1 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffd1 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffd1 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffd1 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffd1 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffd1 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffd1 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ffd1 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h20 y12d ffd4 fs3 fc0 sc0 ls248 ws214">17.4.4 未知运行时错误 </div><div class="t m0 x0 h5 y12e ffd6 fs2 fc0 sc0 ls8 wseb">当使用innerHTML或outerHTML以下列方式指定HTML时，就会发生未知运行时错误（Unknown </div><div class="t m0 x0 h5 y12f ffcf fs2 fc0 sc0 lsd2 ws390">runtime error）：一是把块元素插入到行内元素时，二是访问表格任意部分（&lt;table&gt;、&lt;tbody&gt;等）的</div><div class="t m0 x0 h1e y130 ffd6 fs2 fc0 sc0 ls8 wseb">任意属性时。例如，从技术角度说，&lt;span&gt;标签不能包含&lt;div&gt;之类的块级元素，因此下面的代码就会</div><div class="t m0 x0 h5 y131 ffd6 fs2 fc0 sc0 ls8 wseb">导致未知运行时错误： </div><div class="t m0 x5 hb y132 ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 yc0b ffd7 fs6 fc0 sc0 ls21 wsb">span.innerHTML = &quot;&lt;div&gt;Hi&lt;/div&gt;&quot;;        //这里，span包含了&lt;div&gt;元素 </div><div class="t m0 x5 hb y1f33 ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1f34 ffd6 fs2 fc0 sc0 ls8 wseb">在遇到把块级元素插入到不恰当位置的情况时，其他浏览器会尝试纠正并隐藏错误，而IE在这一</div><div class="t m0 x0 h5 y1f35 ffd6 fs2 fc0 sc0 ls8 wseb">点上反倒很较真儿。 </div><div class="t m0 x0 h20 y30dd ffd4 fs3 fc0 sc0 ls248 ws214">17.4.5 语法错误 </div><div class="t m0 x0 h5 y37fd ffd6 fs2 fc0 sc0 ls8 wseb">通常，只要IE一报告发生了语法错误（syntax error），都可以很快找到错误的原因。这时候，原因</div><div class="t m0 x0 h4 y37fe ffd6 fs2 fc0 sc0 ls8 wseb">可能是代码中少了一个分号，或者花括号前后不对应。然而，还有一种原因不十分明显的情况需要格外</div><div class="t m0 x0 h5 y37ff ffd6 fs2 fc0 sc0 ls8">注意。 </div><div class="t m0 x0 h5 y3800 ffd6 fs2 fc0 sc0 ls8 wseb">如果你引用了外部的JavaScript文件，而该文件最终并没有返回JavaScript代码，IE 也会抛出语法</div><div class="t m0 x0 h14 y3801 ffd6 fs2 fc0 sc0 ls8 wseb">错误。例如，&lt;script&gt;元素的src特性指向了一个HTML文件，就会导致语法错误。报告语法错误的</div><div class="t m0 x0 h5 y3802 ffd6 fs2 fc0 sc0 ls8 wseb">位置时，通常都会说该错误位于脚本第一行的第一个字符处。Opera和Safari也会报告语法错误，但它</div><div class="t m0 x0 h5 ybe ffd6 fs2 fc0 sc0 ls8 wseb">们会给出导致问题的外部文件的信息；IE就不会给出这个信息，因此就需要我们自己重复检查一遍引用</div><div class="t m0 x0 h5 ybf ffd6 fs2 fc0 sc0 ls1f ws108">的外部JavaScript文件。但Firefox会忽略那些被当作JavaScript内容嵌入到文档中的非 JavaScript文件中的</div><div class="t m0 x0 h5 y3803 ffd6 fs2 fc0 sc0 ls8 wseb">解析错误。 </div><div class="t m0 x0 h5 y3804 ffd6 fs2 fc0 sc0 ls8 wseb">在服务器端组件动态生成JavaScript的情况下，比较容易出现这种错误。很多服务器端语言都会在</div><div class="t m0 x0 h5 y3805 ffd6 fs2 fc0 sc0 ls8 wseb">发生运行时错误时，向输出中插入HTML代码，而这种包含HTML 的输出很容易就会违反JavaScript</div><div class="t m0 x0 h4 y3806 ffd6 fs2 fc0 sc0 ls8 wseb">语法。如果在追查语法错误时遇到了麻烦，我们建议你再仔细检查一遍引用的外部文件，确保这些文件</div><div class="t m0 x0 h5 y3807 ffd6 fs2 fc0 sc0 ls8 wseb">中没有包含服务器因错误而插入到其中的HTML。 </div><div class="t m0 x0 h20 y3808 ffd4 fs3 fc0 sc0 ls248 ws214">17.4.6 系统无法找到指定资源 </div><div class="t m0 x0 h5 y3809 ffd6 fs2 fc0 sc0 ls8 wseb">系统无法找到指定资源（The system cannot locate the resource specified）这种说法，恐怕要算是IE</div><div class="t m0 x0 h5 y1a98 ffd6 fs2 fc0 sc0 ls8 wseb">给出的最有价值的错误消息了。在使用JavaScript请求某个资源URL，而该URL的长度超过了IE对URL</div><div class="t m0 x0 h5 y380a ffd6 fs2 fc0 sc0 ls8 wseb">最长不能超过2083个字符的限制时，就会发生这个错误。IE不仅限制JavaScript中使用的URL的长度，</div><div class="t m0 x0 h5 y380b ffd6 fs2 fc0 sc0 ls8 wseb">而且也限制用户在浏览器自身中使用的URL长度（其他浏览器对URL的限制没有这么严格）。IE对URL</div><div class="t m0 x0 h5 y380c ffd6 fs2 fc0 sc0 ls8 wseb">路径还有一个不能超过2048个字符的限制。下面的代码将会导致错误。 </div><div class="t m0 x5 hb y860 ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y380d ffd7 fs6 fc0 sc0 ls21 wsb">function createLongUrl(url){ </div><div class="t m0 x0 hb y380e ffd7 fs6 fc0 sc0 ls21 wsb">    var s = &quot;?&quot;; </div><div class="t m0 x0 hb y380f ffd7 fs6 fc0 sc0 ls21 wsb">    for (var i=0, len=2500; i &lt; len; i++){ </div><div class="t m0 x0 hb y3810 ffd7 fs6 fc0 sc0 ls21 wsb">        s += &quot;a&quot;; </div><div class="t m0 x0 hb y3811 ffd7 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y3812 ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3813 ffd7 fs6 fc0 sc0 ls21 wsb">    return url + s; </div><div class="t m0 x0 hb y3814 ffd7 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y3815 ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3816 ffd7 fs6 fc0 sc0 ls21 wsb">var x = new XMLHttpRequest(); </div></div></div>
<div id="pf21a" class="pf w0 h0" data-page-no="21a"><div class="pc pc21a w0 h0"><div class="t m0 x0 h2 y1 ffcf fs0 fc0 sc0 ls7 ws0">520  第17章 错误处理与调试 </div><div class="t m0 x0 h3 y2 ffcf fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 ffd7 fs6 fc0 sc0 ls21 wsb">x.open(&quot;get&quot;, createLongUrl(&quot;http://www.somedomain.com/&quot;), true); </div><div class="t m0 x0 hb y7a ffd7 fs6 fc0 sc0 ls21 wsb">x.send(null); </div><div class="t m0 x0 hb y1c6a ffd7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y10b0 ffdd fs2 fc0 sc0 ls47 wsb">LongURLErrorExample01.htm </div><div class="t m0 x0 h5 y10b1 ffd6 fs2 fc0 sc0 ls5 wsec">在这个例子中，XMLHttpRequest对象试图向一个超出最大长度限制的URL 发送请求。在调用</div><div class="t m0 x0 h4 y3523 ffd7 fs1 fc0 sc0 ls9 ws2">open()方法时，就会发生错误。避免这个问题的办法，无非就是通过给查询字符串参数起更短的名字，</div><div class="t m0 x0 h1e y10b3 ffd6 fs2 fc0 sc0 ls8 wseb">或者减少不必要的数据，来缩短查询字符串的长度。另外，还可以把请求方法改为POST，通过请求体</div><div class="t m0 x0 hc y10b4 ffd6 fs2 fc0 sc0 ls8 wseb">而不是查询字符串来发送数据。有关Ajax（或者说XMLHttpRequest 对象）的详细内容，将在第21</div><div class="t m0 x0 h5 y1452 ffd6 fs2 fc0 sc0 ls8 wseb">章全面讨论。 </div><div class="t m0 x0 hd y1db4 ffd4 fs7 fc0 sc0 ls245">17.5 小结 </div><div class="t m0 x0 h5 y2b81 ffd6 fs2 fc0 sc0 ls8 wseb">错误处理对于今天复杂的Web应用程序开发而言至关重要。不能提前预测到可能发生的错误，不</div><div class="t m0 x0 h4 y1d97 ffd6 fs2 fc0 sc0 ls8 wseb">能提前采取恢复策略，可能导致较差的用户体验，最终引发用户不满。多数浏览器在默认情况下都不会</div><div class="t m0 x0 h4 y3526 ffd6 fs2 fc0 sc0 ls8 wseb">向用户报告错误，因此在开发和调试期间需要启用浏览器的错误报告功能。然而，在投入运行的产品代</div><div class="t m0 x0 h5 y3817 ffd6 fs2 fc0 sc0 ls8 wseb">码中，则不应该再有诸如此类的错误报告出现。 </div><div class="t m0 x0 h5 y3818 ffd6 fs2 fc0 sc0 ls8 wseb">下面是几种避免浏览器响应JavaScript错误的方法。 </div><div class="t m0 x0 h4 y10b9 ffd5 fs1 fc0 sc0 ls2"> 在可能发生错误的地方使用try-catch语句，这样你还有机会以适当的方式对错误给出响应，</div><div class="t m0 x0 h5 y10ba ffd6 fs2 fc0 sc0 ls8 wseb">而不必沿用浏览器处理错误的机制。 </div><div class="t m0 x0 h4 y3819 ffd5 fs1 fc0 sc0 ls2"> 使用window.onerror事件处理程序，这种方式可以接受try-catch不能处理的所有错误（仅</div><div class="t m0 x0 h5 y381a ffd6 fs2 fc0 sc0 ls8 wseb">限于IE、Firefox和Chrome）。 </div><div class="t m0 x0 h5 y381b ffd6 fs2 fc0 sc0 ls8 wseb">另外，对任何Web应用程序都应该分析可能的错误来源，并制定处理错误的方案。 </div><div class="t m0 x0 h5 yc21 ffd5 fs1 fc0 sc0 ls2"> 首先，必须要明确什么是致命错误，什么是非致命错误。 </div><div class="t m0 x0 h5 y10be ffd5 fs1 fc0 sc0 ls2"> 其次，再分析代码，以判断最可能发生的错误。JavaScript中发生错误的主要原因如下。 </div><div class="t m0 x0 h5 y381c ffd5 fsc fc0 sc0 ls8 ws393"> 类型转换 </div><div class="t m0 x0 h5 y2a3 ffd5 fsc fc0 sc0 ls8 ws393"> 未充分检测数据类型 </div><div class="t m0 x0 h5 y10c0 ffd5 fsc fc0 sc0 ls8 ws393"> 发送给服务器或从服务器接收到的数据有错误 </div><div class="t m0 x0 h5 y10c1 ffcf fs2 fc0 sc0 lse ws9">IE、Firefox、Chrome、Opera和Safari都有JavaScript调试器，有的是内置的，有的是以需要下载的</div><div class="t m0 x0 h5 y10c2 ffd6 fs2 fc0 sc0 ls8 wseb">扩展形式存在的。这些调试器都支持设置断点、控制代码执行及在运行时检测变量的值。 </div><div class="t m0 x0 h5 y381d ffcf fs2 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf21b" class="pf w0 h0" data-page-no="21b"><div class="pc pc21b w0 h0"><div class="t m0 x4 h2 y1 ffe0 fs0 fc0 sc0 ls7 ws0">18.1 浏览器对XML DOM的支持   521 </div><div class="t m0 x0 h3 y2 ffe0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffe2 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ffe2 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffe2 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffe2 fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ffe2 fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ffe2 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffe2 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffe2 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffe2 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffe2 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffe2 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffe2 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ffe2 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h9 y2a ffe3 fs5 fc0 sc0 ls8 wsb">JavaScript与XML </div><div class="t m0 x0 h3c y2b ffe4 fs2 fc0 sc0 ls8">本章内容 </div><div class="t m0 x0 h5 y2c ffe6 fs1 fc0 sc0 ls2"> 检测浏览器对XML DOM的支持 </div><div class="t m0 x0 h5 y2d ffe6 fs1 fc0 sc0 ls2"> 理解JavaScript中的XPath </div><div class="t m0 x0 h5 y2e ffe6 fs1 fc0 sc0 ls2"> 使用XSLT处理器 </div><div class="t m0 x0 h5 y381e ffe0 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x5 h5 y381f ffe7 fs2 fc0 sc0 ls8 ws1">几何时，XML一度成为存储和通过因特网传输结构化数据的标准。透过XML的发展，能够</div><div class="t m0 x5 h5 y3820 ffe7 fs2 fc0 sc0 ls8 ws1">清晰地看到Web技术发展的轨迹。DOM规范的制定，不仅是为了方便在 Web浏览器中使用</div><div class="t m0 x0 h5 y3821 ffe0 fs2 fc0 sc0 ls4a ws3a">XML，也是为了在桌面及服务器应用程序中处理XML数据。此前，由于浏览器无法解析XML数据，</div><div class="t m0 x0 h5 y3822 ffe7 fs2 fc0 sc0 ls8 ws1">很多开发人员都要动手编写自己的XML解析器。而自从DOM出现后，所有浏览器都内置了对XML的</div><div class="t m0 x0 h5 y3823 ffe7 fs2 fc0 sc0 ls8 ws1">原生支持（XML DOM），同时也提供了一系列相关的技术支持。 </div><div class="t m0 x0 hd y24a ffe5 fs7 fc0 sc0 ls245">18.1 浏览器对XML DOM 的支持 </div><div class="t m0 x0 h5 y3824 ffe7 fs2 fc0 sc0 ls8 ws1">在正式的规范诞生以前，浏览器提供商实现的XML解决方案不仅对XML 的支持程度参差不齐，</div><div class="t m0 x0 h5 y3825 ffe7 fs2 fc0 sc0 ls8 ws1">而且对同一特性的支持也各不相同。DOM2级是第一个提到动态创建XML DOM概念的规范。DOM3</div><div class="t m0 x0 h5 y3826 ffe7 fs2 fc0 sc0 ls8 ws1">级进一步增强了XML DOM，新增了解析和序列化等特性。然而，当DOM3级规范的各项条款尘埃落</div><div class="t m0 x0 h5 y3827 ffe7 fs2 fc0 sc0 ls8 ws1">定之后，大多数浏览器也都实现了各自不同的解决方案。 </div><div class="t m0 x0 h20 y33b1 ffe5 fs3 fc0 sc0 ls248 ws214">18.1.1 DOM2级核心 </div><div class="t m0 x0 h5 y1c44 ffe7 fs2 fc0 sc0 ls42 ws30">我们在第12章曾经提到过，DOM2级在document.implementation中引入了createDocument()</div><div class="t m0 x0 h5 y125f ffe7 fs2 fc0 sc0 ls8 ws1">方法。IE9+、Firefox、Opera、Chrome和Safari都支持这个方法。想一想，或许你还记得可以在支持 DOM2</div><div class="t m0 x0 h5 y3828 ffe7 fs2 fc0 sc0 ls8 ws1">级的浏览器中使用以下语法来创建一个空白的XML文档： </div><div class="t m0 x5 hb y3829 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y382a ffe8 fs6 fc0 sc0 ls21 wsb">var xmldom = document.implementation.createDocument(namespaceUri, root, doctype); </div><div class="t m0 x5 hb y382b ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1cb0 ffe7 fs2 fc0 sc0 ls8 ws1">在通过JavaScript处理XML时，通常只使用参数root，因为这个参数指定的是XML DOM 文档元</div><div class="t m0 x0 h5 y1491 ffe7 fs2 fc0 sc0 ls8 ws1">素的标签名。而namespaceUri参数则很少用到，原因是在JavaScrip中管理命名空间比较困难。最后，</div><div class="t m0 x0 h5 y12d8 ffe8 fs1 fc0 sc0 ls9 ws2">doctype参数用得就更少了。 </div><div class="t m0 x0 hc y12d9 ffe7 fs2 fc0 sc0 ls8 ws1">因此，要想创建一个新的、文档元素为&lt;root&gt;的XML文档，可以使用如下代码： </div><div class="t m0 x5 hb yd60 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y382c ffe8 fs6 fc0 sc0 ls21 wsb">var xmldom = document.implementation.createDocument(&quot;&quot;, &quot;root&quot;, null); </div><div class="t m0 x0 hb y382d ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y382e ffe8 fs6 fc0 sc0 ls21 wsb">alert(xmldom.documentElement.tagName);     //&quot;root&quot; </div><div class="t m0 x0 hb y382f ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1428 ffe8 fs6 fc0 sc0 ls21 wsb">var child = xmldom.createElement(&quot;child&quot;); </div><div class="t m0 x0 hb y3830 ffe8 fs6 fc0 sc0 ls21 wsb">xmldom.documentElement.appendChild(child); </div><div class="t m0 x2 hf y3831 ffe9 fs2 fc0 sc0 ls8 wsb">DOMLevel2CoreExample01.htm </div><div class="t m0 x0 h129 y3832 ffe4 fs18 fc0 sc0 ls8">曾</div><div class="t m0 x0 h11 y4b ffea fsa fc0 sc0 ls8">第</div><div class="t m1 x0 h12 y4b ffeb fsb fc3 sc0 ls426">18</div><div class="t m0 x5 h11 y4b ffea fsa fc0 sc0 ls8 ws1d">章 </div></div></div>
<div id="pf21c" class="pf w0 h0" data-page-no="21c"><div class="pc pc21c w0 h0"><div class="t m0 x0 h2 y1 ffe0 fs0 fc0 sc0 ls7 ws0">522  第18章 JavaScript与XML </div><div class="t m0 x0 h3 y2 ffe0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ffe7 fs2 fc0 sc0 ls8 ws1">这个例子创建了一个XML DOM文档，没有默认的命名空间，也没有文档类型。但要注意的是，尽</div><div class="t m0 x0 h5 y4d ffe7 fs2 fc0 sc0 ls8 ws1">管不需要指定命名空间和文档类型，也必须传入相应的参数。具体来说，给命名空间URI传入一个空字</div><div class="t m0 x0 h1c yd8 ffe7 fs2 fc0 sc0 ls6 ws6">符串，就意味着未指定命名空间，而给文档类型传入null，就意味着不指定文档类型。变量xmldom</div><div class="t m0 x0 h5 yd9 ffe7 fs2 fc0 sc0 ls8 ws1">中保存着一个DOM2级Document类型的实例，带有第12 章讨论过的所有DOM方法和属性。我们这</div><div class="t m0 x0 h5 y15d ffe7 fs2 fc0 sc0 ls8 ws1">个例子显示了文档元素的标签名，然后又创建并给文档元素添加了一个新的子元素。 </div><div class="t m0 x0 h5 y2b3 ffe7 fs2 fc0 sc0 ls8 ws1">要检测浏览器是否支持DOM2级XML，可以使用下面这行代码： </div><div class="t m0 x0 hb yb70 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y14e2 ffe8 fs6 fc0 sc0 ls21 wsb">var hasXmlDom = document.implementation.hasFeature(&quot;XML&quot;, &quot;2.0&quot;); </div><div class="t m0 x0 hb y14e3 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y14e4 ffe7 fs2 fc0 sc0 ls8 ws1">在实际开发中，很少需要从头开始创建一个XML文档，然后再使用DOM文档为其添加元素。更</div><div class="t m0 x0 h5 y23d7 ffe7 fs2 fc0 sc0 ls8 ws1">常见的情况往往是将某个XML文档解析为DOM结构，或者反之。由于DOM2 级规范没有提供这种功</div><div class="t m0 x0 h5 y3834 ffe7 fs2 fc0 sc0 ls8 ws1">能，因此就出现了一些事实标准。 </div><div class="t m0 x0 h20 y3835 ffe5 fs3 fc0 sc0 ls248 ws214">18.1.2 DOMParser类型 </div><div class="t m0 x0 h5 y3757 ffe7 fs2 fc0 sc0 ls8 ws1">为了将XML解析为DOM文档，Firefox引入了 DOMParser类型；后来，IE9、Safari、Chrome和</div><div class="t m0 x0 h5 y3836 ffe0 fs2 fc0 sc0 ls2b ws22">Opera也支持了这个类型。在解析XML 之前，首先必须创建一个DOMParser的实例，然后再调用</div><div class="t m0 x0 h5 y172c ffe8 fs1 fc0 sc0 ls9 ws2">parseFromString()方法。这个方法接受两个参数：要解析的XML字符串和内容类型（内容类型始</div><div class="t m0 x0 hc y172d ffe7 fs2 fc0 sc0 ls8 ws1">终都应该是&quot;text/xml&quot;）。返回的值是一个Document的实例。来看下面的例子。 </div><div class="t m0 x0 hb y1cc7 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3837 ffe8 fs6 fc0 sc0 ls21 wsb">var parser = new DOMParser(); </div><div class="t m0 x0 hb y3838 ffe8 fs6 fc0 sc0 ls21 wsb">var xmldom = parser.parseFromString(&quot;&lt;root&gt;&lt;child/&gt;&lt;/root&gt;&quot;, &quot;text/xml&quot;); </div><div class="t m0 x0 hb y3839 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y383a ffe8 fs6 fc0 sc0 ls21 wsb">alert(xmldom.documentElement.tagName);     //&quot;root&quot; </div><div class="t m0 x0 hb y383b ffe8 fs6 fc0 sc0 ls21 wsb">alert(xmldom.documentElement.firstChild.tagName);     //&quot;child&quot; </div><div class="t m0 x0 hb y383c ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y383d ffe8 fs6 fc0 sc0 ls21 wsb">var anotherChild = xmldom.createElement(&quot;child&quot;); </div><div class="t m0 x0 hb y383e ffe8 fs6 fc0 sc0 ls21 wsb">xmldom.documentElement.appendChild(anotherChild); </div><div class="t m0 x0 hb y383f ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3840 ffe8 fs6 fc0 sc0 ls21 wsb">var children = xmldom.getElementsByTagName(&quot;child&quot;); </div><div class="t m0 x0 hb y3841 ffe8 fs6 fc0 sc0 ls21 wsb">alert(children.length);     //2 </div><div class="t m0 x0 hb y3842 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y14fc ffe9 fs2 fc0 sc0 ls2b wsb">DOMParserExample01.htm </div><div class="t m0 x0 h5 y911 ffe7 fs2 fc0 sc0 ls8 ws1">在这个例子中，我们把一个简单的XML字符串解析成了一个DOM文档。解析得到的DOM结构以</div><div class="t m0 x0 h5 y3843 ffe8 fs1 fc0 sc0 ls9 ws2">&lt;root&gt;作为其文档元素，该元素还有一个&lt;child&gt;子元素。此后，就可以使用DOM方法对返回的这个</div><div class="t m0 x0 h5 y3844 ffe7 fs2 fc0 sc0 ls8 ws1">文档进行操作了。 </div><div class="t m0 x0 h5 y3845 ffe8 fs1 fc0 sc0 ls9 ws2">DOMParser只能解析格式良好的XML，因而不能把HTML 解析为HTML文档。在发生解析错误</div><div class="t m0 x0 h1e y3846 ffe7 fs2 fc0 sc0 ls2d9 ws39c">时，仍然会从parseFromString()中返回一个Document 对象，但这个对象的文档元素是</div><div class="t m0 x0 h5 y3847 ffe8 fs1 fc0 sc0 ls9 ws2">&lt;parsererror&gt;，而文档元素的内容是对解析错误的描述。下面是一个例子。 </div><div class="t m0 x0 hb y3848 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3849 ffe8 fs6 fc0 sc0 ls21 wsb">&lt;parsererror xmlns=&quot;http://www.mozilla.org/newlayout/xml/parsererror.xml&quot;&gt;XML </div><div class="t m0 x0 hb y384a ffe8 fs6 fc0 sc0 ls21 wsb">Parsing Error: no element found Location: file:///I:/My%20Writing/My%20Books/ </div><div class="t m0 x0 hb y384b ffe8 fs6 fc0 sc0 ls21 wsb">Professional%20JavaScript/Second%20Edition/Examples/Ch15/DOMParserExample2.htm Line </div><div class="t m0 x0 hb y384c ffe8 fs6 fc0 sc0 ls429 wsb">Number 1, Column 7: &lt;sourcetext&gt; &amp; lt;root &amp; gt; ------^&lt;/sourcetext &gt; &lt; /parsererror&gt; </div><div class="t m0 x0 hb y384d ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y384e ffe0 fs2 fc0 sc0 ls42a ws39d">Firefox和Opera都会返回这种格式的文档。Safari和Chrome返回的文档也包含&lt;parsererror&gt;元素，</div><div class="t m0 x0 h5 y384f ffe7 fs2 fc0 sc0 ls5f ws4c">但该元素会出现在发生解析错误的地方。IE9会在调用parseFromString()的地方抛出一个解析错误。</div><div class="t m0 x0 h1e y2b95 ffe7 fs2 fc0 sc0 ls5f ws4c">由于存在这些差别，因此确定是否发生解析错误的最佳方式就是，使用一个try-catch语句块，如果没</div></div></div>
<div id="pf21d" class="pf w0 h0" data-page-no="21d"><div class="pc pc21d w0 h0"><div class="t m0 x4 h2 y1 ffe0 fs0 fc0 sc0 ls7 ws0">18.1 浏览器对XML DOM的支持   523 </div><div class="t m0 x0 h3 y2 ffe0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffe2 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ffe2 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffe2 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffe2 fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ffe2 fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ffe2 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffe2 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffe2 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffe2 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffe2 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffe2 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffe2 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ffe2 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h4 y3 ffe7 fs2 fc0 sc0 ls10b wsdc">有错误，则通过getElementsByTagName()来查找文档中是否存在&lt;parsererror&gt;元素，如下面的例</div><div class="t m0 x0 h5 y4d ffe7 fs2 fc0 sc0 ls5f">子所示。 </div><div class="t m0 x0 hb y3850 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3851 ffe8 fs6 fc0 sc0 ls21 wsb">var parser = new DOMParser(), </div><div class="t m0 x0 hb y3852 ffe8 fs6 fc0 sc0 ls21 wsb">    xmldom, </div><div class="t m0 x0 hb y3853 ffe8 fs6 fc0 sc0 ls21 wsb">    errors;  </div><div class="t m0 x0 hb y3854 ffe8 fs6 fc0 sc0 ls21 wsb">try { </div><div class="t m0 x0 hb y3855 ffe8 fs6 fc0 sc0 ls21 wsb">    xmldom = parser.parseFromString(&quot;&lt;root&gt;&quot;, &quot;text/xml&quot;); </div><div class="t m0 x0 hb y3856 ffe8 fs6 fc0 sc0 ls21 wsb">    errors = xmldom.getElementsByTagName(&quot;parsererror&quot;); </div><div class="t m0 x0 hb y3857 ffe8 fs6 fc0 sc0 ls21 wsb">    if (errors.length &gt; 0){ </div><div class="t m0 x0 hb y3858 ffe8 fs6 fc0 sc0 ls21 wsb">        throw new Error(&quot;Parsing error!&quot;); </div><div class="t m0 x0 hb y3859 ffe8 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y385a ffe8 fs6 fc0 sc0 ls21 wsb">} catch (ex) { </div><div class="t m0 x0 hb y385b ffe8 fs6 fc0 sc0 ls21 wsb">    alert(&quot;Parsing error!&quot;); </div><div class="t m0 x0 hb y385c ffe8 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y385d ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y18eb ffe9 fs2 fc0 sc0 ls2b wsb">DOMParserExample02.htm </div><div class="t m0 x0 h5 y385e ffe7 fs2 fc0 sc0 ls8 ws1">这例子显示，要解析的字符串中缺少了闭标签&lt;/root&gt;，而这会导致解析错误。在IE9+中，此时会</div><div class="t m0 x0 hc y385f ffe7 fs2 fc0 sc0 ls60 ws198">抛出错误。在Firefox和Opera 中，文档元素将是&lt;parsererror&gt;，而在Safari和Chrome中，</div><div class="t m0 x0 h4 y2495 ffe8 fs1 fc0 sc0 ls9 ws2">&lt;parsererror&gt;是&lt;root&gt;的第一个子元素。调用getElementsByTagName(&quot;parsererror&quot;)能够</div><div class="t m0 x0 h4 y2496 ffe7 fs2 fc0 sc0 ls6 ws6">应对这两种情况。如果这个方法返回了元素，就说明有错误发生，继而通过一个警告框显示出来。当</div><div class="t m0 x0 h5 y3860 ffe7 fs2 fc0 sc0 ls8 ws1">然，你还可以更进一步，从错误元素中提取出错误信息。 </div><div class="t m0 x0 h20 y125c ffe5 fs3 fc0 sc0 ls248 ws214">18.1.3 XMLSerializer类型 </div><div class="t m0 x0 h5 y3861 ffe7 fs2 fc0 sc0 ls8 ws1">在引入DOMParser的同时，Firefox还引入了XMLSerializer类型，提供了相反的功能：将DOM</div><div class="t m0 x0 hc y3862 ffe7 fs2 fc0 sc0 ls8 ws1">文档序列化为XML字符串。后来，IE9+、Opera、Chrome和Safari都支持了XMLSerializer。 </div><div class="t m0 x0 h5 y3863 ffe7 fs2 fc0 sc0 ls8 ws1">要序列化DOM文档，首先必须创建XMLSerializer的实例，然后将文档传入其serializeTo- </div><div class="t m0 x0 h21 y3864 ffe8 fs1 fc0 sc0 ls9 wsb">String ()方法，如下面的例子所示。 </div><div class="t m0 x5 hb y3865 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3866 ffe8 fs6 fc0 sc0 ls21 wsb">var serializer = new XMLSerializer(); </div><div class="t m0 x0 hb y3867 ffe8 fs6 fc0 sc0 ls21 wsb">var xml = serializer.serializeToString(xmldom); </div><div class="t m0 x0 hb y3868 ffe8 fs6 fc0 sc0 ls21 wsb">alert(xml); </div><div class="t m0 x5 hb y3869 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y11a1 ffe9 fs2 fc0 sc0 ls2f wsb">XMLSerializerExample01.htm </div><div class="t m0 x0 h5 y13cc ffe7 fs2 fc0 sc0 ls8 ws1">但是，serializeToString()方法返回的字符串并不适合打印，因此看起来会显得乱糟糟的。 </div><div class="t m0 x0 h5 y85f ffe8 fs1 fc0 sc0 ls9 ws2">XMLSerializer可以序列化任何有效的DOM对象，不仅包括个别的节点，也包括HTML 文档。</div><div class="t m0 x0 hc y2b6d ffe7 fs2 fc0 sc0 ls3b">将HTML文档传入serializeToString()以后，HTML文档将被视为XML文档，因此得到的代码也</div><div class="t m0 x0 h5 y386a ffe7 fs2 fc0 sc0 ls8 ws1">将是格式良好的。 </div><div class="t m0 x5 h12b y386b ffe1 fs2 fc0 sc0 ls8 ws14">如果将非DOM对象传入serializeToString()，会导致错误发生。 </div><div class="t m0 x0 h20 y386c ffe5 fs3 fc0 sc0 ls248 ws214">18.1.4 IE8及之前版本中的XML  </div><div class="t m0 x0 h5 y386d ffe7 fs2 fc0 sc0 ls8">事实上，IE是第一个原生支持XML的浏览器，而这一支持是通过ActiveX对象实现的。为了便于</div><div class="t m0 x0 h5 y386e ffe7 fs2 fc0 sc0 ls8 ws1">桌面应用程序开发人员处理XML，微软创建了MSXML库；但微软并没有针对JavaScript创建不同的对</div></div></div>
<div id="pf21e" class="pf w0 h0" data-page-no="21e"><div class="pc pc21e w0 h0"><div class="t m0 x0 h2 y1 ffe0 fs0 fc0 sc0 ls7 ws0">524  第18章 JavaScript与XML </div><div class="t m0 x0 h3 y2 ffe0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ffe7 fs2 fc0 sc0 ls8 ws1">象，而只是让Web开发人员能够通过浏览器访问相同的对象。 </div><div class="t m0 x0 hc y4d ffe7 fs2 fc0 sc0 ls71">第8章曾经介绍过ActiveXObject类型，通过这个类型可以在JavaScript中创建 ActiveX对象的</div><div class="t m0 x0 h5 y5 ffe7 fs2 fc0 sc0 ls8 ws1">实例。同样，要创建一个XML文档的实例，也要使用ActiveXObject构造函数并为其传入一个表示</div><div class="t m0 x0 h5 yd9 ffe0 fs2 fc0 sc0 ls4a ws3a">XML文档版本的字符串。有6种不同的XML文档版本可以供选择。 </div><div class="t m0 x0 h5 y219 ffe6 fs1 fc0 sc0 ls2"> Microsoft.XmlDom：最初随同IE发布；不建议使用。 </div><div class="t m0 x0 h4 y8 ffe6 fs1 fc0 sc0 ls23f"> MSXML2.DOMDocument：为方便脚本处理而更新的版本，建议仅在特殊情况下作为后备版本</div><div class="t m0 x0 h5 y15e ffe7 fs2 fc0 sc0 ls24 ws1e">使用。 </div><div class="t m0 x0 h5 ya ffe6 fs1 fc0 sc0 ls2"> MSXML2.DOMDocument.3.0：为了在JavaScript中使用，这是最低的建议版本。 </div><div class="t m0 x0 h5 yb ffe6 fs1 fc0 sc0 ls2"> MSXML2.DOMDocument.4.0：在通过脚本处理时并不可靠，使用这个版本可能导致安全警告。 </div><div class="t m0 x0 h4 yc ffe6 fs1 fc0 sc0 ls31f"> MSXML2.DOMDocument.5.0：在通过脚本处理时并不可靠，使用这个版本同样可能导致安全</div><div class="t m0 x0 h5 y116b ffe7 fs2 fc0 sc0 ls5">警告。 </div><div class="t m0 x0 h5 y21b ffe6 fs1 fc0 sc0 ls2"> MSXML2.DOMDocument.6.0：通过脚本能够可靠处理的最新版本。 </div><div class="t m0 x0 h5 y21c ffe7 fs2 fc0 sc0 ls8 ws1">在这6个版本中，微软只推荐使用MSXML2.DOMDocument.6.0或MSXML2.DOMDocument.3.0；</div><div class="t m0 x0 h5 y116c ffe7 fs2 fc0 sc0 ls6 ws6">前者是最新最可靠的版本，而后者则是大多数Windows操作系统都支持的版本。可以作为后备版本的</div><div class="t m0 x0 h5 y11 ffe8 fs1 fc0 sc0 ls9 ws2">MSXML2.DOMDocument，仅在针对IE5.5之前的浏览器开发时才有必要使用。 </div><div class="t m0 x0 h5 y12 ffe7 fs2 fc0 sc0 ls8 ws1">通过尝试创建每个版本的实例并观察是否有错误发生，可以确定哪个版本可用。例如： </div><div class="t m0 x0 hb y3870 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3871 ffe8 fs6 fc0 sc0 ls21 wsb">function createDocument(){ </div><div class="t m0 x0 hb y3872 ffe8 fs6 fc0 sc0 ls21 wsb">    if (typeof arguments.callee.activeXString != &quot;string&quot;){ </div><div class="t m0 x0 hb y3873 ffe8 fs6 fc0 sc0 ls21 wsb">        var versions = [&quot;MSXML2.DOMDocument.6.0&quot;, &quot;MSXML2.DOMDocument.3.0&quot;, </div><div class="t m0 x0 hb y3874 ffe8 fs6 fc0 sc0 ls21 wsb">                        &quot;MSXML2.DOMDocument&quot;], </div><div class="t m0 x0 hb y3875 ffe8 fs6 fc0 sc0 ls21 wsb">            i, len; </div><div class="t m0 x0 hb y3876 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3877 ffe8 fs6 fc0 sc0 ls21 wsb">        for (i=0,len=versions.length; i &lt; len; i++){ </div><div class="t m0 x0 hb y3878 ffe8 fs6 fc0 sc0 ls21 wsb">            try { </div><div class="t m0 x0 hb y3879 ffe8 fs6 fc0 sc0 ls21 wsb">                new ActiveXObject(versions[i]); </div><div class="t m0 x0 hb y387a ffe8 fs6 fc0 sc0 ls21 wsb">                arguments.callee.activeXString = versions[i]; </div><div class="t m0 x0 hb y387b ffe8 fs6 fc0 sc0 ls21 wsb">                break; </div><div class="t m0 x0 hb y387c ffe8 fs6 fc0 sc0 ls21 wsb">            } catch (ex){ </div><div class="t m0 x0 h16 y387d ffe8 fs6 fc0 sc0 ls21 wsb">                //跳过 </div><div class="t m0 x0 hb y387e ffe8 fs6 fc0 sc0 ls21 wsb">            } </div><div class="t m0 x0 hb y387f ffe8 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y3880 ffe8 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y3881 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3882 ffe8 fs6 fc0 sc0 ls21 wsb">    return new ActiveXObject(arguments.callee.activeXString); </div><div class="t m0 x0 hb y3883 ffe8 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x2 hf y706 ffe9 fs2 fc0 sc0 ls7a wsb">IEXmlDomExample01.htm </div><div class="t m0 x0 h5 y707 ffe7 fs2 fc0 sc0 ls107 wsd8">这个函数中使用for循环迭代了每个可能的 ActiveX版本。如果版本无效，则创建新</div><div class="t m0 x0 h4 yb14 ffe8 fs1 fc0 sc0 ls9 ws2">ActiveXObject的调用就会抛出错误；此时，catch语句会捕获错误，循环继续。如果没有发生错误，</div><div class="t m0 x0 h1e y3884 ffe7 fs2 fc0 sc0 ls8 ws1">则可用的版本将被保存在这个函数的activeXString属性中。这样，就不必在每次调用这个函数时都</div><div class="t m0 x0 h5 y70a ffe7 fs2 fc0 sc0 ls8 ws1">重复检查可用版本了——直接创建并返回对象即可。 </div><div class="t m0 x0 he y3885 ffe7 fs2 fc0 sc0 ls8 ws1">要解析XML字符串，首先必须创建一个DOM文档，然后调用 loadXML()方法。新创建的XML</div><div class="t m0 x0 h5 y7d1 ffe7 fs2 fc0 sc0 ls8 ws1">文档完全是一个空文档，因而不能对其执行任何操作。为loadXML()方法传入的XML字符串经解析之</div><div class="t m0 x0 h5 y7d2 ffe7 fs2 fc0 sc0 ls8 ws1">后会被填充到DOM文档中。来看下面的例子。 </div></div></div>
<div id="pf21f" class="pf w0 h0" data-page-no="21f"><div class="pc pc21f w0 h0"><div class="t m0 x4 h2 y1 ffe0 fs0 fc0 sc0 ls7 ws0">18.1 浏览器对XML DOM的支持   525 </div><div class="t m0 x0 h3 y2 ffe0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffe2 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ffe2 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffe2 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffe2 fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ffe2 fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ffe2 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffe2 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffe2 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffe2 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffe2 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffe2 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffe2 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ffe2 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y79 ffe8 fs6 fc0 sc0 ls21 wsb">var xmldom = createDocument(); </div><div class="t m0 x0 hb y7a ffe8 fs6 fc0 sc0 ls21 wsb">xmldom.loadXML(&quot;&lt;root&gt;&lt;child/&gt;&lt;/root&gt;&quot;); </div><div class="t m0 x0 hb y1d67 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1d68 ffe8 fs6 fc0 sc0 ls21 wsb">alert(xmldom.documentElement.tagName);      //&quot;root&quot; </div><div class="t m0 x0 hb y1d69 ffe8 fs6 fc0 sc0 ls21 wsb">alert(xmldom.documentElement.firstChild.tagName);     //&quot;child&quot; </div><div class="t m0 x0 hb y1d6a ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1d6b ffe8 fs6 fc0 sc0 ls21 wsb">var anotherChild = xmldom.createElement(&quot;child&quot;); </div><div class="t m0 x0 hb y1d6c ffe8 fs6 fc0 sc0 ls21 wsb">xmldom.documentElement.appendChild(anotherChild); </div><div class="t m0 x0 hb y1d6d ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1d6e ffe8 fs6 fc0 sc0 ls21 wsb">var children = xmldom.getElementsByTagName(&quot;child&quot;); </div><div class="t m0 x0 hb y1d6f ffe8 fs6 fc0 sc0 ls21 wsb">alert(children.length);   //2         </div><div class="t m0 x5 hb y1d70 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1d71 ffe9 fs2 fc0 sc0 ls7a wsb">IEXmlDomExample01.htm </div><div class="t m0 x0 h5 y1d72 ffe7 fs2 fc0 sc0 ls8 ws1">在新DOM文档中填充了XML内容之后，就可以像操作其他DOM文档一样操作它了（可以使用任</div><div class="t m0 x0 h5 y1d73 ffe7 fs2 fc0 sc0 ls8 ws1">何方法和属性）。 </div><div class="t m0 x0 h1c y3886 ffe7 fs2 fc0 sc0 ls8 ws1">如果解析过程中出错，可以在parseError属性中找到错误消息。这个属性本身是一个包含多个属</div><div class="t m0 x0 h5 y3887 ffe7 fs2 fc0 sc0 ls8 ws1">性的对象，每个属性都保存着有关解析错误的某一方面信息。 </div><div class="t m0 x0 h5 y3888 ffe6 fs1 fc0 sc0 ls2"> errorCode：错误类型的数值编码；在没有发生错误时值为0。 </div><div class="t m0 x0 h5 y3889 ffe6 fs1 fc0 sc0 ls2"> filePos：文件中导致错误发生的位置。 </div><div class="t m0 x0 h5 y388a ffe6 fs1 fc0 sc0 ls2"> line：发生错误的行。 </div><div class="t m0 x0 h5 y388b ffe6 fs1 fc0 sc0 ls2"> linepos：发生错误的行中的字符。 </div><div class="t m0 x0 h5 y388c ffe6 fs1 fc0 sc0 ls2"> reason：对错误的文本解释。 </div><div class="t m0 x0 h5 y388d ffe6 fs1 fc0 sc0 ls2"> srcText：导致错误的代码。 </div><div class="t m0 x0 h5 y9a2 ffe6 fs1 fc0 sc0 ls2"> url：导致错误的文件的URL（如果有这个文件的话）。 </div><div class="t m0 x0 h1e y388e ffe7 fs2 fc0 sc0 ls8 ws1">另外，parseError的valueOf()方法返回errorCode的值，因此可以通过下列代码检测是否发</div><div class="t m0 x0 h5 y388f ffe7 fs2 fc0 sc0 ls8 ws1">生了解析错误。 </div><div class="t m0 x5 hb y3890 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3891 ffe8 fs6 fc0 sc0 ls21 wsb">if (xmldom.parseError != 0){ </div><div class="t m0 x0 hb y3892 ffe8 fs6 fc0 sc0 ls21 wsb">    alert(&quot;Parsing error occurred.&quot;); </div><div class="t m0 x0 hb y3893 ffe8 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h5 y27ee ffe7 fs2 fc0 sc0 ls8 ws1">错误类型的数值编码可能是正值，也可能是负值，因此我们只需检测它是不是等于0。要取得有关</div><div class="t m0 x0 h5 y3894 ffe7 fs2 fc0 sc0 ls8 ws1">解析错误的详细信息也很容易，而且可以将这些信息组合起来给出更有价值的解释。来看下面的例子。 </div><div class="t m0 x5 hb y911 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3895 ffe8 fs6 fc0 sc0 ls21 wsb">if (xmldom.parseError != 0){ </div><div class="t m0 x0 h15 y3896 ffec fs6 fc0 sc0 ls21 wsb">    alert(&quot;An error occurred:\nError Code: &quot; </div><div class="t m0 x0 h15 y3897 ffec fs6 fc0 sc0 ls21 wsb">        + xmldom.parseError.errorCode + &quot;\n&quot; </div><div class="t m0 x0 h15 y3898 ffec fs6 fc0 sc0 ls21 wsb">        + &quot;Line: &quot; + xmldom.parseError.line + &quot;\n&quot; </div><div class="t m0 x0 h15 y3899 ffec fs6 fc0 sc0 ls21 wsb">        + &quot;Line Pos: &quot; + xmldom.parseError.linepos + &quot;\n&quot; </div><div class="t m0 x0 h15 y389a ffec fs6 fc0 sc0 ls21 wsb">        + &quot;Reason: &quot; + xmldom.parseError.reason); </div><div class="t m0 x0 hb y389b ffe8 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x2 hf y25ec ffe9 fs2 fc0 sc0 ls7a wsb">IEXmlDomExample02.htm </div><div class="t m0 x0 h5 y34b ffe7 fs2 fc0 sc0 ls8 ws1">应该在调用loadXML()之后、查询XML文档之前，检查是否发生了解析错误。 </div><div class="t m0 x0 h3c y389c ffe5 fs2 fc0 sc0 ls2e wsb">1. 序列化XML </div><div class="t m0 x0 h5 y389d ffe0 fs2 fc0 sc0 lse ws9">IE将序列化XML的能力内置在了DOM文档中。每个 DOM节点都有一个xml属性，其中保存着</div><div class="t m0 x0 h5 y12df ffe7 fs2 fc0 sc0 ls8 ws1">表示该节点的XML字符串。例如： </div><div class="t m0 x0 h5 y389e ffe0 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y517 ffe8 fs6 fc0 sc0 ls21 wsb">alert(xmldom.xml); </div></div></div>
<div id="pf220" class="pf w0 h0" data-page-no="220"><div class="pc pc220 w0 h0"><div class="t m0 x0 h2 y1 ffe0 fs0 fc0 sc0 ls7 ws0">526  第18章 JavaScript与XML </div><div class="t m0 x0 h3 y2 ffe0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ffe7 fs2 fc0 sc0 ls8 ws1">文档中的每个节点都支持这个简单的序列化机制，无论是序列化整个文档还是某个子文档树，都非</div><div class="t m0 x0 h5 y4d ffe7 fs2 fc0 sc0 ls8">常方便。 </div><div class="t m0 x0 h3c y2041 ffe5 fs2 fc0 sc0 ls2e wsb">2. 加载XML文件 </div><div class="t m0 x0 h5 y20ed ffe0 fs2 fc0 sc0 lse ws9">IE中的XML文档对象也可以加载来自服务器的文件。与DOM3级中的功能类似，要加载 的XML</div><div class="t m0 x0 h5 y334a ffe7 fs2 fc0 sc0 ls8 ws1">文档必须与页面中运行的JavaScript代码来自同一台服务器。同样与DOM3级规范类似，加载文档的方</div><div class="t m0 x0 ha4 y334b ffe7 fs2 fc0 sc0 ls8 ws1">式也可以分为同步和异步两种。要指定加载文档的方式，可以设置async属性，true表示异步，false</div><div class="t m0 x0 h5 y1ed3 ffe7 fs2 fc0 sc0 ls8 ws1">表示同步（默认值为true）。来看下面的例子。 </div><div class="t m0 x0 hb yd44 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yd45 ffe8 fs6 fc0 sc0 ls21 wsb">var xmldom = createDocument(); </div><div class="t m0 x0 hb yd46 ffe8 fs6 fc0 sc0 ls21 wsb">xmldom.async = false; </div><div class="t m0 x0 hb y17d2 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y17d3 ffe7 fs2 fc0 sc0 ls8 ws1">在确定了加载XML文档的方式后，调用load()可以启动下载过程。这个方法接受一个参数，即</div><div class="t m0 x0 hc y17d4 ffe7 fs2 fc0 sc0 ls8 ws1">要加载的XML文件的URL。在同步方式下，调用load()后可以立即检测解析错误并执行相关的XML</div><div class="t m0 x0 h5 y38a0 ffe7 fs2 fc0 sc0 ls8 ws1">处理，例如： </div><div class="t m0 x0 hb y38a1 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y38a2 ffe8 fs6 fc0 sc0 ls21 wsb">var xmldom = createDocument(); </div><div class="t m0 x0 hb y38a3 ffe8 fs6 fc0 sc0 ls21 wsb">xmldom.async = false; </div><div class="t m0 x0 h15 y38a4 ffec fs6 fc0 sc0 ls21 wsb">xmldom.load(&quot;example.xml&quot;); </div><div class="t m0 x0 h15 y38a5 ffec fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y38a6 ffec fs6 fc0 sc0 ls21 wsb">if (xmldom.parseError != 0){ </div><div class="t m0 x0 h16 y38a7 ffec fs6 fc0 sc0 ls21 wsb">   //处理错误 </div><div class="t m0 x0 h15 y38a8 ffec fs6 fc0 sc0 ls21 wsb">} else { </div><div class="t m0 x0 h15 y38a9 ffec fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y38aa ffec fs6 fc0 sc0 ls21 wsb">    alert(xmldom.documentElement.tagName);  //&quot;root&quot; </div><div class="t m0 x0 h15 y38ab ffec fs6 fc0 sc0 ls21 wsb">    alert(xmldom.documentElement.firstChild.tagName); //&quot;child&quot; </div><div class="t m0 x0 h15 y38ac ffec fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 h15 y38ad ffec fs6 fc0 sc0 ls21 wsb">    var anotherChild = xmldom.createElement(&quot;child&quot;); </div><div class="t m0 x0 h15 y38ae ffec fs6 fc0 sc0 ls21 wsb">    xmldom.documentElement.appendChild(anotherChild); </div><div class="t m0 x0 h15 y38af ffec fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 h15 y38b0 ffec fs6 fc0 sc0 ls21 wsb">    var children = xmldom.getElementsByTagName(&quot;child&quot;); </div><div class="t m0 x0 h15 y38b1 ffec fs6 fc0 sc0 ls21 wsb">    alert(children.length);   //2         </div><div class="t m0 x0 h15 y38b2 ffec fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 h15 y38b3 ffec fs6 fc0 sc0 ls21 wsb">    alert(xmldom.xml);         </div><div class="t m0 x0 h15 y38b4 ffec fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y38b5 ffec fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x2 hf y38b6 ffe9 fs2 fc0 sc0 ls7a wsb">IEXmlDomExample03.htm </div><div class="t m0 x0 h5 y38b7 ffe7 fs2 fc0 sc0 ls8 ws1">由于是以同步方式处理XML文件，因此在解析完成之前，代码不会继续执行，这样的编程工作要</div><div class="t m0 x0 h5 y38b8 ffe7 fs2 fc0 sc0 ls8 ws1">简单一点。虽然同步方式比较方便，但如果下载时间太长，会导致程序反应很慢。因此，在加载XML</div><div class="t m0 x0 h5 y38b9 ffe7 fs2 fc0 sc0 ls8 ws1">文档时，通常都使用异步方式。 </div><div class="t m0 x0 h5 y38ba ffe7 fs2 fc0 sc0 ls8 ws1">在异步加载XML文件的情况下，需要为XML DOM文档的onreadystatechange 事件指定处理</div><div class="t m0 x0 h5 y1d52 ffe7 fs2 fc0 sc0 ls8 ws1">程序。有4个就绪状态（ready state）。 </div><div class="t m0 x0 h5 y1c6 ffe6 fs1 fc0 sc0 ls2"> 1：DOM正在加载数据。 </div><div class="t m0 x0 h5 y1d54 ffe6 fs1 fc0 sc0 ls2"> 2：DOM已经加载完数据。 </div><div class="t m0 x0 h5 y1d55 ffe6 fs1 fc0 sc0 ls2"> 3：DOM已经可以使用，但某些部分可能还无法访问。 </div><div class="t m0 x0 h5 y1d56 ffe6 fs1 fc0 sc0 ls2"> 4：DOM已经完全可以使用。 </div><div class="t m0 x0 h5 y1ca ffe7 fs2 fc0 sc0 ls8 ws1">在实际开发中，要关注的只有一个就绪状态：4。这个状态表示XML文件已经全部加载完毕，而且</div><div class="t m0 x0 h5 y1cb ffe7 fs2 fc0 sc0 ls8 ws1">已经全部解析为DOM文档。通过XML文档的readyState 属性可以取得其就绪状态。以异步方式加</div><div class="t m0 x0 h5 y38bb ffe7 fs2 fc0 sc0 ls3b">载XML文件的典型模式如下。 </div></div></div>
<div id="pf221" class="pf w0 h0" data-page-no="221"><div class="pc pc221 w0 h0"><div class="t m0 x4 h2 y1 ffe0 fs0 fc0 sc0 ls7 ws0">18.1 浏览器对XML DOM的支持   527 </div><div class="t m0 x0 h3 y2 ffe0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffe2 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ffe2 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffe2 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffe2 fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ffe2 fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ffe2 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffe2 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffe2 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffe2 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffe2 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffe2 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffe2 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ffe2 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y79 ffe8 fs6 fc0 sc0 ls21 wsb">var xmldom = createDocument(); </div><div class="t m0 x0 h15 y7a ffec fs6 fc0 sc0 ls21 wsb">xmldom.async = true; </div><div class="t m0 x0 h15 y7b ffec fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y7c ffec fs6 fc0 sc0 ls21 wsb">xmldom.onreadystatechange = function(){ </div><div class="t m0 x0 h15 y7d ffec fs6 fc0 sc0 ls21 wsb">    if (xmldom.readyState == 4){ </div><div class="t m0 x0 h15 y7e ffec fs6 fc0 sc0 ls21 wsb">        if (xmldom.parseError != 0){ </div><div class="t m0 x0 h15 y7f ffec fs6 fc0 sc0 ls21 wsb">            alert(&quot;An error occurred:\nError Code: &quot; </div><div class="t m0 x0 h15 y80 ffec fs6 fc0 sc0 ls21 wsb">                  + xmldom.parseError.errorCode + &quot;\n&quot; </div><div class="t m0 x0 h15 y81 ffec fs6 fc0 sc0 ls21 wsb">                  + &quot;Line: &quot; + xmldom.parseError.line + &quot;\n&quot; </div><div class="t m0 x0 h15 y82 ffec fs6 fc0 sc0 ls21 wsb">                  + &quot;Line Pos: &quot; + xmldom.parseError.linepos + &quot;\n&quot; </div><div class="t m0 x0 h15 y83 ffec fs6 fc0 sc0 ls21 wsb">                  + &quot;Reason: &quot; + xmldom.parseError.reason); </div><div class="t m0 x0 h15 y84 ffec fs6 fc0 sc0 ls21 wsb">        } else { </div><div class="t m0 x0 h15 y85 ffec fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y86 ffec fs6 fc0 sc0 ls21 wsb">            alert(xmldom.documentElement.tagName);  //&quot;root&quot; </div><div class="t m0 x0 h15 y87 ffec fs6 fc0 sc0 ls21 wsb">            alert(xmldom.documentElement.firstChild.tagName); //&quot;child&quot; </div><div class="t m0 x0 h15 y88 ffec fs6 fc0 sc0 ls21 wsb">             </div><div class="t m0 x0 h15 y89 ffec fs6 fc0 sc0 ls21 wsb">            var anotherChild = xmldom.createElement(&quot;child&quot;); </div><div class="t m0 x0 h15 y8a ffec fs6 fc0 sc0 ls21 wsb">            xmldom.documentElement.appendChild(anotherChild); </div><div class="t m0 x0 h15 y1823 ffec fs6 fc0 sc0 ls21 wsb">             </div><div class="t m0 x0 h15 y1824 ffec fs6 fc0 sc0 ls21 wsb">            var children = xmldom.getElementsByTagName(&quot;child&quot;); </div><div class="t m0 x0 h15 y1825 ffec fs6 fc0 sc0 ls21 wsb">            alert(children.length);   //2         </div><div class="t m0 x0 h15 y1826 ffec fs6 fc0 sc0 ls21 wsb">             </div><div class="t m0 x0 h15 y1827 ffec fs6 fc0 sc0 ls21 wsb">            alert(xmldom.xml);                         </div><div class="t m0 x0 h15 y1828 ffec fs6 fc0 sc0 ls21 wsb">        }                 </div><div class="t m0 x0 h15 y1829 ffec fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 h15 y182a ffec fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 h15 y182b ffec fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y182c ffec fs6 fc0 sc0 ls21 wsb">xmldom.load(&quot;example.xml&quot;); </div><div class="t m0 x0 h15 y182d ffec fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y38bc ffe9 fs2 fc0 sc0 ls7a wsb">IEXmlDomExample04.htm </div><div class="t m0 x0 h4 y38bd ffe7 fs2 fc0 sc0 ls8 ws1">要注意的是，为onreadystatechange事件指定处理程序的语句，必须放在调用load()方法的</div><div class="t m0 x0 h4 y38be ffe7 fs2 fc0 sc0 ls8 ws1">语句之前；这样，才能确保在就绪状态变化时调用该事件处理程序。另外，在事件处理程序内部，还必</div><div class="t m0 x0 he y38bf ffe7 fs2 fc0 sc0 ls8 ws1">须注意要使用XML文档变量的名称（xmldom），不能使用this对象。原因是ActiveX控件为预防安全</div><div class="t m0 x0 hc y38c0 ffe7 fs2 fc0 sc0 ls8 ws1">问题不允许使用this对象。当文档的就绪状态变化为4时，就可以放心地检测是否发生了解析错误，</div><div class="t m0 x0 h5 y38c1 ffe7 fs2 fc0 sc0 ls8 ws1">并在未发生错误的情况下处理XML了。 </div><div class="t m0 x5 h5 y38c2 ffe1 fs2 fc0 sc0 ls8 ws14">虽然可以通过XML DOM文档对象加载XML文件，但公认的还是使用XMLHttp- </div><div class="t m0 x5 h5 y38c3 ffe8 fs1 fc0 sc0 ls9 ws2">Request对象比较好。有关XMLHttpRequest对象及 Ajax的相关内容，将在第21</div><div class="t m0 x5 h5 y38c4 ffe1 fs2 fc0 sc0 ls8">章讨论。 </div><div class="t m0 x0 h20 y38c5 ffe5 fs3 fc0 sc0 ls248 ws214">18.1.5 跨浏览器处理XML </div><div class="t m0 x0 h5 y2d54 ffe7 fs2 fc0 sc0 ls8 ws1">很少有开发人员能够有福气专门针对一款浏览器做开发。因此，编写能够跨浏览器处理XML的函</div><div class="t m0 x0 h5 yc6f ffe7 fs2 fc0 sc0 ls8 ws1">数就成为了常见的需求。对解析XML而言，下面这个函数可以在所有四种主要浏览器中使用。 </div><div class="t m0 x0 hb y38c6 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y38c7 ffe8 fs6 fc0 sc0 ls21 wsb">function parseXml(xml){ </div><div class="t m0 x0 hb y38c8 ffe8 fs6 fc0 sc0 ls21 wsb">    var xmldom = null;  </div><div class="t m0 x0 hb y38c9 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y38ca ffe8 fs6 fc0 sc0 ls21 wsb">    if (typeof DOMParser != &quot;undefined&quot;){ </div><div class="t m0 x0 hb y38cb ffe8 fs6 fc0 sc0 ls21 wsb">        xmldom = (new DOMParser()).parseFromString(xml, &quot;text/xml&quot;); </div></div></div>
<div id="pf222" class="pf w0 h0" data-page-no="222"><div class="pc pc222 w0 h0"><div class="t m0 x0 h2 y1 ffe0 fs0 fc0 sc0 ls7 ws0">528  第18章 JavaScript与XML </div><div class="t m0 x0 h3 y2 ffe0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 ffe8 fs6 fc0 sc0 ls21 wsb">        var errors = xmldom.getElementsByTagName(&quot;parsererror&quot;); </div><div class="t m0 x0 hb y7a ffe8 fs6 fc0 sc0 ls21 wsb">        if (errors.length){ </div><div class="t m0 x0 hb y7b ffe8 fs6 fc0 sc0 ls21 wsb">            throw new Error(&quot;XML parsing error:&quot; + errors[0].textContent); </div><div class="t m0 x0 hb y7c ffe8 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y7d ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y7e ffe8 fs6 fc0 sc0 ls21 wsb">    } else if (typeof ActiveXObject != &quot;undefined&quot;){ </div><div class="t m0 x0 hb y7f ffe8 fs6 fc0 sc0 ls21 wsb">        xmldom = createDocument(); </div><div class="t m0 x0 hb y80 ffe8 fs6 fc0 sc0 ls21 wsb">        xmldom.loadXML(xml); </div><div class="t m0 x0 hb y81 ffe8 fs6 fc0 sc0 ls21 wsb">        if (xmldom.parseError != 0){ </div><div class="t m0 x0 hb y82 ffe8 fs6 fc0 sc0 ls21 wsb">            throw new Error(&quot;XML parsing error: &quot; + xmldom.parseError.reason); </div><div class="t m0 x0 hb y83 ffe8 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y84 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y85 ffe8 fs6 fc0 sc0 ls21 wsb">    } else { </div><div class="t m0 x0 hb y86 ffe8 fs6 fc0 sc0 ls21 wsb">        throw new Error(&quot;No XML parser available.&quot;); </div><div class="t m0 x0 hb y87 ffe8 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y88 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y89 ffe8 fs6 fc0 sc0 ls21 wsb">    return xmldom; </div><div class="t m0 x0 hb y8a ffe8 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y38cd ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y38ce ffe9 fs2 fc0 sc0 ls5e wsb">CrossBrowserXmlExample01.htm </div><div class="t m0 x0 h5 y360a ffe7 fs2 fc0 sc0 ls8 ws1">这个parseXml()函数只接收一个参数，即可解析的XML字符串。在函数内部，我们通过能力检</div><div class="t m0 x0 h5 y360b ffe7 fs2 fc0 sc0 ls8 ws1">测来确定要使用的XML解析方式。DOMParser类型是受支持最多的解决方案，因此首先检测该类型是</div><div class="t m0 x0 h5 y7db ffe7 fs2 fc0 sc0 ls8 ws1">否有效。如果是，则创建一个新的DOMParser对象，并将解析XML字符串的结果保存在变量xmldom</div><div class="t m0 x0 h5 y2297 ffe7 fs2 fc0 sc0 ls8 ws1">中。由于DOMParser对象在发生解析错误时不抛出错误（除IE9+之外），因此还要检测返回的文档以</div><div class="t m0 x0 h5 y7dd ffe7 fs2 fc0 sc0 ls8 ws1">确定解析过程是否顺利。如果发现了解析错误，则根据错误消息抛出一个错误。 </div><div class="t m0 x0 h5 y38cf ffe7 fs2 fc0 sc0 ls8 ws1">函数的最后一部分代码检测了对ActiveX的支持，并使用前面定义的createDocument()函数来创</div><div class="t m0 x0 h5 y831 ffe7 fs2 fc0 sc0 ls8 ws1">建适当版本的XML文档。与使用DOMParser 时一样，这里也需要检测结果，以防有错误发生。如果</div><div class="t m0 x0 h5 y38d0 ffe7 fs2 fc0 sc0 ls8 ws1">确实有错误发生，同样也需要抛出一个包含错误原因的错误。 </div><div class="t m0 x0 h5 y38d1 ffe7 fs2 fc0 sc0 ls8 ws1">如果上述XML解析器都不可用，函数就会抛出一个错误，表示无法解析了。 </div><div class="t m0 x0 h5 y38d2 ffe7 fs2 fc0 sc0 ls8 ws1">在使用这个函数解析XML字符串时，应该将它放在try-catch 语句当中，以防发生错误。来看</div><div class="t m0 x0 h5 y15cd ffe7 fs2 fc0 sc0 ls8 ws1">下面的例子。 </div><div class="t m0 x0 hb y38d3 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y38d4 ffe8 fs6 fc0 sc0 ls21 wsb">var xmldom = null; </div><div class="t m0 x0 hb y38d5 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y38d6 ffe8 fs6 fc0 sc0 ls21 wsb">try { </div><div class="t m0 x0 hb y38d7 ffe8 fs6 fc0 sc0 ls21 wsb">    xmldom = parseXml(&quot;&lt;root&gt;&lt;child/&gt;&lt;/root&gt;&quot;); </div><div class="t m0 x0 hb y38d8 ffe8 fs6 fc0 sc0 ls21 wsb">} catch (ex){ </div><div class="t m0 x0 hb y38d9 ffe8 fs6 fc0 sc0 ls21 wsb">    alert(ex.message); </div><div class="t m0 x0 hb y38da ffe8 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y38db ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y38dc ffe8 fs6 fc0 sc0 ls21">//进一步处理 </div><div class="t m0 x0 hb y38dd ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1cfc ffe9 fs2 fc0 sc0 ls5e wsb">CrossBrowserXmlExample01.htm </div><div class="t m0 x0 h5 y38de ffe7 fs2 fc0 sc0 ls8 ws1">对序列化XML而言，也可以按照同样的方式编写一个能够在四大浏览器中运行的函数。例如： </div><div class="t m0 x0 hb y2881 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y38df ffe8 fs6 fc0 sc0 ls21 wsb">function serializeXml(xmldom){ </div><div class="t m0 x0 hb y38e0 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y38e1 ffe8 fs6 fc0 sc0 ls21 wsb">    if (typeof XMLSerializer != &quot;undefined&quot;){ </div><div class="t m0 x0 hb y38e2 ffe8 fs6 fc0 sc0 ls21 wsb">        return (new XMLSerializer()).serializeToString(xmldom); </div><div class="t m0 x0 hb y38e3 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y38e4 ffe8 fs6 fc0 sc0 ls21 wsb">    } else if (typeof xmldom.xml != &quot;undefined&quot;){ </div></div></div>
<div id="pf223" class="pf w0 h0" data-page-no="223"><div class="pc pc223 w0 h0"><div class="t m0 x4 h2 y1 ffe0 fs0 fc0 sc0 ls7 ws0">18.2 浏览器对XPath的支持   529 </div><div class="t m0 x0 h3 y2 ffe0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffe2 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ffe2 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffe2 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffe2 fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ffe2 fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ffe2 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffe2 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffe2 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffe2 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffe2 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffe2 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffe2 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ffe2 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y79 ffe8 fs6 fc0 sc0 ls21 wsb">        return xmldom.xml; </div><div class="t m0 x0 hb y7a ffe8 fs6 fc0 sc0 ls21 wsb">    } else { </div><div class="t m0 x0 hb y7b ffe8 fs6 fc0 sc0 ls21 wsb">        throw new Error(&quot;Could not serialize XML DOM.&quot;); </div><div class="t m0 x0 hb y7c ffe8 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y7d ffe8 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x2 hf y3fd ffe9 fs2 fc0 sc0 ls1a6 wsb">CrossBrowserXmlExample02.htm </div><div class="t m0 x0 h5 y3fe ffe7 fs2 fc0 sc0 ls8 ws1">这个serializeXml()函数接收一个参数，即要序列化的XML DOM文档。与parseXml()函数</div><div class="t m0 x0 h1e y3ff ffe7 fs2 fc0 sc0 ls8 ws1">一样，这个函数首先也是检测受到最广泛支持的特性，即XMLSerializer。如果这个类型有效，则使</div><div class="t m0 x0 h5 y400 ffe7 fs2 fc0 sc0 ls8 ws1">用它来生成并返回文档的XML字符串。由于ActiveX方案比较简单，只使用了一个xml 属性，因此这</div><div class="t m0 x0 h4 y401 ffe7 fs2 fc0 sc0 ls8 ws1">个函数直接检测了该属性。如果上述两方面尝试都失败了，函数就会抛出一个错误，说明序列化不能进</div><div class="t m0 x0 h5 y36ba ffe7 fs2 fc0 sc0 ls8 ws1">行。一般来说，只要针对浏览器使用了适当的XML DOM对象，就不会出现无法序列化的情况，因而也</div><div class="t m0 x0 he y38e5 ffe7 fs2 fc0 sc0 ls8 ws1">就没有必要在try-catch语句中调用serializeXml()。结果，就只需如下一行代码即可： </div><div class="t m0 x5 hb y7d6 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y38e6 ffe8 fs6 fc0 sc0 ls21 wsb">var xml = serializeXml(xmldom); </div><div class="t m0 x5 hb y38e7 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y38e8 ffe7 fs2 fc0 sc0 ls8 ws1">只不过由于序列化过程的差异，相同的DOM对象在不同的浏览器下，有可能会得到不同的XML</div><div class="t m0 x0 h5 y38e9 ffe7 fs2 fc0 sc0 ls8">字符串。 </div><div class="t m0 x0 hd y2699 ffe5 fs7 fc0 sc0 ls245">18.2 浏览器对XPath 的支持 </div><div class="t m0 x0 h5 y38ea ffe0 fs2 fc0 sc0 ls8 ws20">XPath是设计用来在DOM文档中查找节点的一种手段，因而对XML处理也很重要。但是，DOM3</div><div class="t m0 x0 h5 y2918 ffe7 fs2 fc0 sc0 ls8 ws1">级以前的标准并没有就XPath的API作出规定；XPath是在DOM3级XPath 模块中首次跻身推荐标准行</div><div class="t m0 x0 h5 y38eb ffe7 fs2 fc0 sc0 ls8 ws1">列的。很多浏览器都实现了这个推荐标准，但IE则以自己的方式实现了XPath。 </div><div class="t m0 x0 h20 y38ec ffe5 fs3 fc0 sc0 ls248 ws214">18.2.1 DOM3级XPath </div><div class="t m0 x0 h5 y38ed ffe0 fs2 fc0 sc0 ls24a ws215">DOM3级XPath规范定义了在DOM中对XPath表达式求值的接口。要确定某浏览器是否支持DOM3</div><div class="t m0 x0 h5 y32dd ffe7 fs2 fc0 sc0 ls3b">级XPath，可以使用以下JavaScript代码： </div><div class="t m0 x5 hb y1576 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1577 ffe8 fs6 fc0 sc0 ls21 wsb">var supportsXPath = document.implementation.hasFeature(&quot;XPath&quot;, &quot;3.0&quot;); </div><div class="t m0 x5 hb y1578 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1579 ffe7 fs2 fc0 sc0 ls3b">在DOM3级XPath规范定义的类型中，最重要的两个类型是XPathEvaluator和XPathResult。</div><div class="t m0 x0 h5 y1b6b ffe8 fs1 fc0 sc0 ls9 ws2">XPathEvaluator用于在特定的上下文中对XPath表达式求值。这个类型有下列3个方法。 </div><div class="t m0 x0 h5 y23c7 ffe6 fs1 fc0 sc0 ls2"> createExpression(expression, nsresolver)：将XPath表达式及相应的命名空间信息转</div><div class="t m0 x5 h5 y3427 ffe7 fs2 fc0 sc0 ls8 ws1">换成一个XPathExpression，这是查询的编译版。在多次使用同一个查询时很有用。 </div><div class="t m0 x0 h4 y38ee ffe6 fs1 fc0 sc0 ls2"> createNSResolver(node)：根据node的命名空间信息创建一个新的XPathNSResolver对</div><div class="t m0 x5 hc y38ef ffe7 fs2 fc0 sc0 ls8 ws1">象。在基于使用命名空间的XML文档求值时，需要使用XPathNSResolver对象。 </div><div class="t m0 x0 h4 y38f0 ffe6 fs1 fc0 sc0 ls2"> evaluate(expression, context, nsresolver, type, result)：在给定的上下文中，</div><div class="t m0 x5 h5 y38f1 ffe7 fs2 fc0 sc0 ls8 ws1">基于特定的命名空间信息来对XPath表达式求值。剩下的参数指定如何返回结果。 </div><div class="t m0 x0 h5 y302a ffe7 fs2 fc0 sc0 ls3b">在Firefox、Safari、Chrome和Opera中，Document类型通常都是与XPathEvaluator接口一起实</div><div class="t m0 x0 h1e y302b ffe7 fs2 fc0 sc0 ls8 ws1">现的。换句话说，在这些浏览器中，既可以创建XPathEvaluator的新实例，也可以使用Document</div><div class="t m0 x0 h5 y38f2 ffe7 fs2 fc0 sc0 ls8 ws1">实例中的方法（XML或HTML文档均是如此）。 </div><div class="t m0 x0 h5 ye5a ffe7 fs2 fc0 sc0 ls8 ws1">在上面这三个方法中，evaluate()是最常用的。这个方法接收5个参数：XPath表达式、上下文</div></div></div>
<div id="pf224" class="pf w0 h0" data-page-no="224"><div class="pc pc224 w0 h0"><div class="t m0 x0 h2 y1 ffe0 fs0 fc0 sc0 ls7 ws0">530  第18章 JavaScript与XML </div><div class="t m0 x0 h3 y2 ffe0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ffe7 fs2 fc0 sc0 ls8 ws1">节点、命名空间求解器、返回结果的类型和保存结果的XPathResult对象（通常是null，因为结果</div><div class="t m0 x0 h5 y4d ffe7 fs2 fc0 sc0 ls8 ws1">也会以函数值的形式返回）。其中，第三个参数（命名空间求解器）只在XML代码中使用了XML命名</div><div class="t m0 x0 h5 yd8 ffe7 fs2 fc0 sc0 ls8 ws1">空间时有必要指定；如果XML代码中没有使用命名空间，则这个参数应该指定为null。第四个参数（返</div><div class="t m0 x0 h5 yd9 ffe7 fs2 fc0 sc0 ls8 ws1">回结果的类型）的取值范围是下列常量之一。 </div><div class="t m0 x0 h5 y219 ffe6 fs1 fc0 sc0 ls2"> XPathResult.ANY_TYPE：返回与XPath表达式匹配的数据类型。 </div><div class="t m0 x0 h5 y8 ffe6 fs1 fc0 sc0 ls2"> XPathResult.NUMBER_TYPE：返回数值。 </div><div class="t m0 x0 h5 y9 ffe6 fs1 fc0 sc0 ls2"> XPathResult.STRING_TYPE：返回字符串值。 </div><div class="t m0 x0 h5 ya ffe6 fs1 fc0 sc0 ls2"> XPathResult.BOOLEAN_TYPE：返回布尔值。 </div><div class="t m0 x0 h4 yb ffe6 fs1 fc0 sc0 ls2"> XPathResult.UNORDERED_NODE_ITERATOR_TYPE：返回匹配的节点集合，但集合中节点的次</div><div class="t m0 x0 h5 y78a ffe7 fs2 fc0 sc0 ls8 ws1">序不一定与它们在文档中的次序一致。 </div><div class="t m0 x0 h4 yd ffe6 fs1 fc0 sc0 ls2"> XPathResult.ORDERED_NODE_ITERATOR_TYPE：返回匹配的节点集合，集合中节点的次序与</div><div class="t m0 x0 h5 ye ffe7 fs2 fc0 sc0 ls8 ws1">它们在文档中的次序一致。这是最常用的结果类型。 </div><div class="t m0 x0 h4 y21c ffe6 fs1 fc0 sc0 ls2"> XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE：返回节点集合的快照，由于是在文档外部</div><div class="t m0 x0 h4 y116c ffe7 fs2 fc0 sc0 ls5 ws4">捕获节点，因此对文档的后续操作不会影响到这个节点集合。集合中节点的次序不一定与它们</div><div class="t m0 x0 h5 y26c5 ffe7 fs2 fc0 sc0 ls8 ws1">在文档中的次序一致。 </div><div class="t m0 x0 h4 y1a57 ffe6 fs1 fc0 sc0 ls2"> XPathResult.ORDERED_NODE_SNAPSHOT_TYPE：返回节点集合的快照，由于是在文档外部捕</div><div class="t m0 x0 h4 y13 ffe7 fs2 fc0 sc0 ls5 ws4">获节点，因此对文档的后续操作不会影响到这个节点集合。集合中节点的次序与它们在文档中</div><div class="t m0 x0 h5 y14 ffe7 fs2 fc0 sc0 ls8 ws1">的次序一致。 </div><div class="t m0 x0 h4 y38f3 ffe6 fs1 fc0 sc0 ls2"> XPathResult.ANY_UNORDERED_NODE_TYPE：返回匹配的节点集合，但集合中节点的次序不</div><div class="t m0 x0 h5 y2df2 ffe7 fs2 fc0 sc0 ls8 ws1">一定与它们在文档中的次序一致。 </div><div class="t m0 x0 h4 y17 ffe6 fs1 fc0 sc0 ls2"> XPathResult.FIRST_ORDERED_NODE_TYPE：返回只包含一个节点的节点集合，包含的这个</div><div class="t m0 x0 h5 y18 ffe7 fs2 fc0 sc0 ls8 ws1">节点就是文档中第一个匹配的节点。 </div><div class="t m0 x0 h5 y38f4 ffe7 fs2 fc0 sc0 ls8 ws1">指定的结果类型决定了如何取得结果的值。下面来看一个典型的例子。 </div><div class="t m0 x0 hb y300e ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y38f5 ffe8 fs6 fc0 sc0 ls21 wsb">var result = xmldom.evaluate(&quot;employee/name&quot;, xmldom.documentElement, null, </div><div class="t m0 x0 hb y38f6 ffe8 fs6 fc0 sc0 ls21 wsb">                                  XPathResult.ORDERED_NODE_ITERATOR_TYPE, null); </div><div class="t m0 x0 h28 y1a95 ffe8 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ye9d ffe8 fs6 fc0 sc0 ls21 wsb">if (result !== null) { </div><div class="t m0 x0 hb y38f7 ffe8 fs6 fc0 sc0 ls21 wsb">    var node = result.iterateNext(); </div><div class="t m0 x0 hb y38f8 ffe8 fs6 fc0 sc0 ls21 wsb">    while(node) { </div><div class="t m0 x0 hb y38f9 ffe8 fs6 fc0 sc0 ls21 wsb">        alert(node.tagName); </div><div class="t m0 x0 hb y38fa ffe8 fs6 fc0 sc0 ls21 wsb">        node = node.iterateNext(); </div><div class="t m0 x0 hb y38fb ffe8 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y38fc ffe8 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x2 hf y38fd ffe9 fs2 fc0 sc0 ls7a wsb">DomXPathExample01.htm </div><div class="t m0 x0 h4 y1134 ffe7 fs2 fc0 sc0 ls8 ws1">这个例子中为返回结果指定的是XPathResult.ORDERED_NODE_ITERATOR_TYPE，也是最常用的</div><div class="t m0 x0 h5 y38fe ffe7 fs2 fc0 sc0 ls8 ws1">结果类型。如果没有节点匹配XPath表达式，evaluate()返回null；否则，它会返回一个XPathResult</div><div class="t m0 x0 h4 y2dc6 ffe7 fs2 fc0 sc0 ls8 ws1">对象。这个XPathResult对象带有的属性和方法，可以用来取得特定类型的结果。如果节点是一个节</div><div class="t m0 x0 h4 y1137 ffe7 fs2 fc0 sc0 ls8 ws1">点迭代器，无论是次序一致还是次序不一致的，都必须要使用iterateNext()方法从节点中取得匹配</div><div class="t m0 x0 hc y1138 ffe7 fs2 fc0 sc0 ls8 ws1">的节点。在没有更多的匹配节点时，iterateNext()返回null。 </div><div class="t m0 x0 h4 y310b ffe7 fs2 fc0 sc0 ls8 ws1">如果指定的是快照结果类型（不管是次序一致还是次序不一致的），就必须使用snapshotItem()</div><div class="t m0 x0 h5 y2086 ffe7 fs2 fc0 sc0 ls8 ws1">方法和snapshotLength属性，例如：  </div></div></div>
<div id="pf225" class="pf w0 h0" data-page-no="225"><div class="pc pc225 w0 h0"><div class="t m0 x4 h2 y1 ffe0 fs0 fc0 sc0 ls7 ws0">18.2 浏览器对XPath的支持   531 </div><div class="t m0 x0 h3 y2 ffe0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffe2 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ffe2 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffe2 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffe2 fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ffe2 fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ffe2 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffe2 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffe2 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffe2 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffe2 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffe2 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffe2 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ffe2 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y79 ffe8 fs6 fc0 sc0 ls21 wsb">var result = xmldom.evaluate(&quot;employee/name&quot;, xmldom.documentElement, null, </div><div class="t m0 x0 h15 y7a ffec fs6 fc0 sc0 ls21 wsb">                                  XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null); </div><div class="t m0 x0 hb y7b ffe8 fs6 fc0 sc0 ls21 wsb">if (result !== null) { </div><div class="t m0 x0 hb y7c ffe8 fs6 fc0 sc0 ls21 wsb">    for (var i=0, len=result.snapshotLength; i &lt; len; i++) { </div><div class="t m0 x0 h15 y7d ffec fs6 fc0 sc0 ls21 wsb">        alert(result.snapshotItem(i).tagName); </div><div class="t m0 x0 h15 y7e ffec fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y7f ffe8 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x2 hf y1ac ffe9 fs2 fc0 sc0 ls7a wsb">DomXPathExample02.htm </div><div class="t m0 x0 h4 y1ad ffe7 fs2 fc0 sc0 ls8 ws1">这里，snapshotLength返回的是快照中节点的数量，而snapshotItem()则返回快照中给定位</div><div class="t m0 x0 hc y1ae ffe7 fs2 fc0 sc0 ls8 ws1">置的节点（与NodeList中的length和item()相似）。 </div><div class="t m0 x0 h3c y38ff ffe5 fs2 fc0 sc0 ls2e wsb">1. 单节点结果 </div><div class="t m0 x0 h4 y3900 ffe7 fs2 fc0 sc0 ls8 ws1">指定常量XPathResult.FIRST_ORDERED_NODE_TYPE会返回第一个匹配的节点，可以通过结果</div><div class="t m0 x0 hc y3b4 ffe7 fs2 fc0 sc0 ls15a">的singleNodeValue属性来访问该节点。例如： </div><div class="t m0 x5 hb y3901 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3902 ffe8 fs6 fc0 sc0 ls21 wsb">var result = xmldom.evaluate(&quot;employee/name&quot;, xmldom.documentElement, null, </div><div class="t m0 x0 h15 y3903 ffec fs6 fc0 sc0 ls21 wsb">                                  XPathResult.FIRST_ORDERED_NODE_TYPE, null); </div><div class="t m0 x0 hb y3904 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3905 ffe8 fs6 fc0 sc0 ls21 wsb">if (result !== null) { </div><div class="t m0 x0 h15 y3906 ffec fs6 fc0 sc0 ls21 wsb">    alert(result.singleNodeValue.tagName); </div><div class="t m0 x0 hb y3907 ffe8 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x2 hf y2c8a ffe9 fs2 fc0 sc0 ls7a wsb">DomXPathExample03.htm </div><div class="t m0 x0 h4 y3908 ffe7 fs2 fc0 sc0 ls8 ws1">与前面的查询一样，在没有匹配节点的情况下，evaluate()返回null。如果有节点返回，那么就</div><div class="t m0 x0 h5 y36ec ffe7 fs2 fc0 sc0 ls8 ws1">可以通过singleNodeValue属性来访问它。 </div><div class="t m0 x0 h3c y3909 ffe5 fs2 fc0 sc0 ls2e wsb">2. 简单类型结果 </div><div class="t m0 x0 h5 y390a ffe7 fs2 fc0 sc0 ls8 ws1">通过XPath也可以取得简单的非节点数据类型，这时候就要使用XPathResult的布尔值、数值和</div><div class="t m0 x0 h1e y16ba ffe7 fs2 fc0 sc0 ls8 ws1">字符串类型了。这几个结果类型分别会通过booleanValue、numberValue和stringValue属性返</div><div class="t m0 x0 h5 y390b ffe7 fs2 fc0 sc0 ls8 ws1">回一个值。对于布尔值类型，如果至少有一个节点与XPath表达式匹配，则求值结果返回true，否则</div><div class="t m0 x0 hc y390c ffe7 fs2 fc0 sc0 ls8 ws1">返回false。来看下面的例子。 </div><div class="t m0 x5 hb y2811 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y390d ffe8 fs6 fc0 sc0 ls21 wsb">var result = xmldom.evaluate(&quot;employee/name&quot;, xmldom.documentElement, null, </div><div class="t m0 x0 hb y390e ffec fs6 fc0 sc0 ls21 wsb">                                  XPathResult.BOOLEAN_TYPE, null); </div><div class="t m0 x0 hb y390f ffe8 fs6 fc0 sc0 ls21 wsb">alert(result.booleanValue); </div><div class="t m0 x5 hb y3910 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y3911 ffe9 fs2 fc0 sc0 ls7a wsb">DomXPathExample04.htm </div><div class="t m0 x0 h5 y3912 ffe7 fs2 fc0 sc0 ls8 ws1">在这个例子中，如果有节点匹配&quot;employee/name&quot;，则booleanValue属性的值就是true。 </div><div class="t m0 x0 h5 y3913 ffe7 fs2 fc0 sc0 ls8 ws1">对于数值类型，必须在XPath表达式参数的位置上指定一个能够返回数值的XPath函数，例如计算</div><div class="t m0 x0 hc y3914 ffe7 fs2 fc0 sc0 ls8 ws1">与给定模式匹配的所有节点数量的count()。来看下面的例子。 </div><div class="t m0 x5 hb y363c ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3915 ffe8 fs6 fc0 sc0 ls21 wsb">var result = xmldom.evaluate(&quot;count(employee/name)&quot;, xmldom.documentElement, </div><div class="t m0 x0 hb y3916 ffec fs6 fc0 sc0 ls21 wsb">                                  null, XPathResult.NUMBER_TYPE, null); </div><div class="t m0 x0 hb y3917 ffe8 fs6 fc0 sc0 ls21 wsb">alert(result.numberValue); </div><div class="t m0 x5 hb y3918 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y8c1 ffe9 fs2 fc0 sc0 ls7a wsb">DomXPathExample05.htm </div><div class="t m0 x0 h4 y3919 ffe7 fs2 fc0 sc0 ls8 ws1">以上代码会输出与&quot;employee/name&quot;匹配的节点数量（即2）。如果使用这个方法的时候没有指定</div><div class="t m0 x0 hc y391a ffe7 fs2 fc0 sc0 ls8 ws1">与前例类似的XPath函数，那么numberValue的值将等于NaN。 </div></div></div>
<div id="pf226" class="pf w0 h0" data-page-no="226"><div class="pc pc226 w0 h0"><div class="t m0 x0 h2 y1 ffe0 fs0 fc0 sc0 ls7 ws0">532  第18章 JavaScript与XML </div><div class="t m0 x0 h3 y2 ffe0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ffe7 fs2 fc0 sc0 ls8 ws1">对于字符串类型，evaluate()方法会查找与XPath表达式匹配的第一个节点，然后返回其第一个</div><div class="t m0 x0 h4 y4d ffe7 fs2 fc0 sc0 ls8 ws1">子节点的值（实际上是假设第一个子节点为文本节点）。如果没有匹配的节点，结果就是一个空字符串。</div><div class="t m0 x0 h5 yd8 ffe7 fs2 fc0 sc0 ls8 ws1">来看一个例子。 </div><div class="t m0 x0 hb y6bd ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y6be ffe8 fs6 fc0 sc0 ls21 wsb">var result = xmldom.evaluate(&quot;employee/name&quot;, xmldom.documentElement, null, </div><div class="t m0 x0 hb y6bf ffec fs6 fc0 sc0 ls21 wsb">                                  XPathResult.STRING_TYPE, null); </div><div class="t m0 x0 hb y6c0 ffe8 fs6 fc0 sc0 ls21 wsb">alert(result.stringValue); </div><div class="t m0 x0 hb y302f ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y2593 ffe9 fs2 fc0 sc0 ls7a wsb">DomXPathExample06.htm </div><div class="t m0 x0 h4 y33a5 ffe7 fs2 fc0 sc0 ls30 ws2a">这个例子的输出结果中包含着与&quot;element/name&quot;匹配的第一个元素的第一个子节点中包含的字</div><div class="t m0 x0 h5 y33a6 ffe7 fs2 fc0 sc0 ls24 ws1e">符串。 </div><div class="t m0 x0 h3c y391c ffe5 fs2 fc0 sc0 ls2e wsb">3. 默认类型结果 </div><div class="t m0 x0 h5 y391d ffe7 fs2 fc0 sc0 ls8 ws1">所有XPath表达式都会自动映射到特定的结果类型。像前面那样设置特定的结果类型，可以限制表</div><div class="t m0 x0 ha4 y391e ffe7 fs2 fc0 sc0 ls8 ws1">达式的输出。而使用XPathResult.ANY_TYPE常量可以自动确定返回结果的类型。一般来说，自动选</div><div class="t m0 x0 h4 y391f ffe7 fs2 fc0 sc0 ls8 ws1">择的结果类型可能是布尔值、数值、字符串值或一个次序不一致的节点迭代器。要确定返回的是什么结</div><div class="t m0 x0 hc y3920 ffe7 fs2 fc0 sc0 ls8 ws1">果类型，可以检测结果的resultType属性，如下面的例子所示。 </div><div class="t m0 x0 hb y6f0 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3921 ffe8 fs6 fc0 sc0 ls21 wsb">var result = xmldom.evaluate(&quot;employee/name&quot;, xmldom.documentElement, null, </div><div class="t m0 x0 hb y3922 ffe8 fs6 fc0 sc0 ls21 wsb">                                  XPathResult.ANY_TYPE, null); </div><div class="t m0 x0 hb y3923 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3924 ffe8 fs6 fc0 sc0 ls21 wsb">if (result !== null) { </div><div class="t m0 x0 h15 y3925 ffec fs6 fc0 sc0 ls21 wsb">    switch(result.resultType) { </div><div class="t m0 x0 hb y3926 ffe8 fs6 fc0 sc0 ls21 wsb">        case XPathResult.STRING_TYPE: </div><div class="t m0 x0 h16 y3927 ffec fs6 fc0 sc0 ls21 wsb">            //处理字符串类型 </div><div class="t m0 x0 h15 y3928 ffec fs6 fc0 sc0 ls21 wsb">            break; </div><div class="t m0 x0 h15 y3929 ffec fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y392a ffec fs6 fc0 sc0 ls21 wsb">        case XPathResult.NUMBER_TYPE: </div><div class="t m0 x0 h16 y392b ffec fs6 fc0 sc0 ls21 wsb">            //处理数值类型 </div><div class="t m0 x0 h15 y392c ffec fs6 fc0 sc0 ls21 wsb">            break; </div><div class="t m0 x0 h15 y392d ffec fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y392e ffec fs6 fc0 sc0 ls21 wsb">        case XPathResult.BOOLEAN_TYPE: </div><div class="t m0 x0 h16 y392f ffec fs6 fc0 sc0 ls21 wsb">            //处理布尔值类型 </div><div class="t m0 x0 h15 y3930 ffec fs6 fc0 sc0 ls21 wsb">            break; </div><div class="t m0 x0 h15 y3931 ffec fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y3932 ffec fs6 fc0 sc0 ls21 wsb">        case XPathResult.UNORDERED_NODE_ITERATOR_TYPE: </div><div class="t m0 x0 h16 y3933 ffec fs6 fc0 sc0 ls21 wsb">            //处理次序不一致的节点迭代器类型 </div><div class="t m0 x0 h15 y3934 ffec fs6 fc0 sc0 ls21 wsb">            break; </div><div class="t m0 x0 h15 y3935 ffec fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y3936 ffec fs6 fc0 sc0 ls21 wsb">        default: </div><div class="t m0 x0 h16 y3937 ffec fs6 fc0 sc0 ls21 wsb">            //处理其他可能的结果类型 </div><div class="t m0 x0 h15 y3938 ffec fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y3939 ffec fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y393a ffe8 fs6 fc0 sc0 ls21 wsb">}   </div><div class="t m0 x0 h5 y393b ffe7 fs2 fc0 sc0 ls8 ws1">显然，XPathResult.ANY_TYPE可以让我们更灵活地使用XPath，但是却要求有更多的处理代码</div><div class="t m0 x0 h5 y2faa ffe7 fs2 fc0 sc0 ls8 ws1">来处理返回的结果。 </div><div class="t m0 x0 h3c y393c ffe5 fs2 fc0 sc0 ls2e wsb">4. 命名空间支持 </div><div class="t m0 x0 h5 y393d ffe7 fs2 fc0 sc0 ls8 ws1">对于利用了命名空间的XML文档，XPathEvaluator必须知道命名空间信息，然后才能正确地进</div><div class="t m0 x0 h5 y393e ffe7 fs2 fc0 sc0 ls8 ws1">行求值。处理命名空间的方法也不止一种。我们以下面的XML代码为例。 </div></div></div>
<div id="pf227" class="pf w0 h0" data-page-no="227"><div class="pc pc227 w0 h0"><div class="t m0 x4 h2 y1 ffe0 fs0 fc0 sc0 ls7 ws0">18.2 浏览器对XPath的支持   533 </div><div class="t m0 x0 h3 y2 ffe0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffe2 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ffe2 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffe2 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffe2 fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ffe2 fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ffe2 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffe2 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffe2 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffe2 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffe2 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffe2 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffe2 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ffe2 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y79 ffe8 fs6 fc0 sc0 ls21 wsb">&lt;?xml version=&quot;1.0&quot; ?&gt; </div><div class="t m0 x0 hb y7a ffe8 fs6 fc0 sc0 ls21 wsb">&lt;wrox:books xmlns:wrox=&quot;http://www.wrox.com/&quot;&gt; </div><div class="t m0 x0 hb y7b ffe8 fs6 fc0 sc0 ls21 wsb">    &lt;wrox:book&gt; </div><div class="t m0 x0 hb y7c ffe8 fs6 fc0 sc0 ls21 wsb">        &lt;wrox:title&gt;Professional JavaScript for Web Developers&lt;/wrox:title&gt; </div><div class="t m0 x0 hb y7d ffe8 fs6 fc0 sc0 ls21 wsb">        &lt;wrox:author&gt;Nicholas C. Zakas&lt;/wrox:author&gt; </div><div class="t m0 x0 hb y7e ffe8 fs6 fc0 sc0 ls21 wsb">    &lt;/wrox:book&gt; </div><div class="t m0 x0 hb y7f ffe8 fs6 fc0 sc0 ls21 wsb">    &lt;wrox:book&gt; </div><div class="t m0 x0 hb y80 ffe8 fs6 fc0 sc0 ls21 wsb">        &lt;wrox:title&gt;Professional Ajax&lt;/wrox:title&gt; </div><div class="t m0 x0 hb y81 ffe8 fs6 fc0 sc0 ls21 wsb">        &lt;wrox:author&gt;Nicholas C. Zakas&lt;/wrox:author&gt; </div><div class="t m0 x0 hb y82 ffe8 fs6 fc0 sc0 ls21 wsb">        &lt;wrox:author&gt;Jeremy McPeak&lt;/wrox:author&gt; </div><div class="t m0 x0 hb y83 ffe8 fs6 fc0 sc0 ls21 wsb">        &lt;wrox:author&gt;Joe Fawcett&lt;/wrox:author&gt; </div><div class="t m0 x0 hb y84 ffe8 fs6 fc0 sc0 ls21 wsb">    &lt;/wrox:book&gt; </div><div class="t m0 x0 hb y85 ffe8 fs6 fc0 sc0 ls21 wsb">&lt;/wrox:books&gt; </div><div class="t m0 x5 hb y10f8 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y999 ffe7 fs2 fc0 sc0 ls8 ws1">在这个XML文档中，所有元素定义都来自http://www.wrox.com/命名空间，以前缀wrox标识。</div><div class="t m0 x0 h5 y99a ffe7 fs2 fc0 sc0 ls8 ws1">如果要对这个文档使用XPath，就需要定义要使用的命名空间；否则求值将会失败。 </div><div class="t m0 x0 h1e y393f ffe7 fs2 fc0 sc0 ls8 ws1">处理命名空间的第一种方法是通过createNSResolver()来创建XPathNSResolver对象。这个</div><div class="t m0 x0 h5 y3940 ffe7 fs2 fc0 sc0 ls8 ws1">方法接受一个参数，即文档中包含命名空间定义的节点。对于前面的XML文档来说，这个节点就是文</div><div class="t m0 x0 h1c y3941 ffe7 fs2 fc0 sc0 lsed wsbd">档元素&lt;wrox:books&gt;，它的xmlns特性定义了命名空间。可以把这个节点传递给 createNS- </div><div class="t m0 x0 h21 y3942 ffe8 fs1 fc0 sc0 ls9 ws2">Resolver()，然后可以像下面这样在evaluate()中使用返回的结果。 </div><div class="t m0 x5 hb y3943 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3944 ffe8 fs6 fc0 sc0 ls21 wsb">var nsresolver = xmldom.createNSResolver(xmldom.documentElement); </div><div class="t m0 x0 hb y3945 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3946 ffe8 fs6 fc0 sc0 ls21 wsb">var result = xmldom.evaluate(&quot;wrox:book/wrox:author&quot;, </div><div class="t m0 x0 hb y3947 ffe8 fs6 fc0 sc0 ls21 wsb">                             xmldom.documentElement, nsresolver, </div><div class="t m0 x0 hb y3948 ffe8 fs6 fc0 sc0 ls21 wsb">                             XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null); </div><div class="t m0 x0 hb y3949 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y394a ffe8 fs6 fc0 sc0 ls21 wsb">alert(result.snapshotLength); </div><div class="t m0 x5 hb y394b ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf yc8d ffe9 fs2 fc0 sc0 ls7a wsb">DomXPathExample07.htm </div><div class="t m0 x0 h5 y394c ffe7 fs2 fc0 sc0 ls8 ws1">在将nsresolver对象传入到evaluate()之后，就可以确保它能够理解 XPath表达式中使用的</div><div class="t m0 x0 h5 y394d ffe8 fs1 fc0 sc0 ls9 ws2">wrox前缀。读者可以试一试使用相同的表达式，如果不使用XPathNSResolver的话，就会导致错误。 </div><div class="t m0 x0 h5 y394e ffe7 fs2 fc0 sc0 ls5 ws4">处理命名空间的第二种方法就是定义一个函数，让它接收一个命名空间前缀，返回关联的URI，</div><div class="t m0 x0 h5 y394f ffe7 fs2 fc0 sc0 ls5">例如： </div><div class="t m0 x5 hb y3022 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y3950 ffec fs6 fc0 sc0 ls21 wsb">var nsresolver = function(prefix){ </div><div class="t m0 x0 h15 y3951 ffec fs6 fc0 sc0 ls21 wsb">    switch(prefix){ </div><div class="t m0 x0 h15 y3952 ffec fs6 fc0 sc0 ls21 wsb">        case &quot;wrox&quot;: return &quot;http://www.wrox.com/&quot;; </div><div class="t m0 x0 h16 y3953 ffec fs6 fc0 sc0 ls21 wsb">        //其他前缀 </div><div class="t m0 x0 h15 y3954 ffec fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 h15 y3955 ffec fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y3956 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3957 ffe8 fs6 fc0 sc0 ls21 wsb">var result = xmldom.evaluate(&quot;count(wrox:book/wrox:author)&quot;, </div><div class="t m0 x0 hb y3958 ffe8 fs6 fc0 sc0 ls21 wsb">                xmldom.documentElement, nsresolver, XPathResult.NUMBER_TYPE, null); </div><div class="t m0 x0 hb y3959 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y395a ffe8 fs6 fc0 sc0 ls21 wsb">alert(result.numberValue); </div><div class="t m0 x5 hb y395b ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y286 ffe9 fs2 fc0 sc0 ls7a wsb">DomXPathExample08.htm </div><div class="t m0 x0 h4 y384e ffe7 fs2 fc0 sc0 ls24 ws1e">在不确定文档中的哪个节点包含命名空间定义的情况下，这个命名空间解析函数就可以派上用场</div><div class="t m0 x0 h5 y384f ffe7 fs2 fc0 sc0 ls55 ws49">了。只要你知道前缀和URI，就可以定义一个返回该信息的函数，然后将它作为第三个参数传递给</div><div class="t m0 x0 h5 y395c ffe8 fs1 fc0 sc0 ls9 ws2">evaluate()即可。 </div></div></div>
<div id="pf228" class="pf w0 h0" data-page-no="228"><div class="pc pc228 w0 h0"><div class="t m0 x0 h2 y1 ffe0 fs0 fc0 sc0 ls7 ws0">534  第18章 JavaScript与XML </div><div class="t m0 x0 h3 y2 ffe0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h20 y12d ffe5 fs3 fc0 sc0 ls248 ws214">18.2.2 IE中的XPath </div><div class="t m0 x0 h5 y12e ffe0 fs2 fc0 sc0 lse ws9">IE对XPath的支持是内置在基于ActiveX的XML DOM文档对象中的，没有使用 DOMParser返回</div><div class="t m0 x0 h5 y12f ffe7 fs2 fc0 sc0 ls61">的DOM对象。因此，为了在IE9及之前的版本中使用XPath，必须使用基于 ActiveX的实现。这个接</div><div class="t m0 x0 h1e y130 ffe7 fs2 fc0 sc0 ls2d9 ws39c">口在每个节点上额外定义了两个的方法：selectSingleNode()和selectNodes()。其中，</div><div class="t m0 x0 h5 y1c95 ffe8 fs1 fc0 sc0 ls9 ws2">selectSingleNode()方法接受一个XPath模式，在找到匹配节点时返回第一个匹配的节点，如果没有</div><div class="t m0 x0 hc y1c96 ffe7 fs2 fc0 sc0 ls8 ws1">找到匹配的节点就返回null。例如： </div><div class="t m0 x0 hb y2157 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2158 ffe8 fs6 fc0 sc0 ls21 wsb">var element = xmldom.documentElement.selectSingleNode(&quot;employee/name&quot;); </div><div class="t m0 x0 hb y2159 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y395e ffe8 fs6 fc0 sc0 ls21 wsb">if (element !== null){ </div><div class="t m0 x0 hb y395f ffe8 fs6 fc0 sc0 ls21 wsb">    alert(element.xml); </div><div class="t m0 x0 hb y3960 ffe8 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x2 hf y3961 ffe9 fs2 fc0 sc0 ls94 wsb">IEXPathExample01.htm </div><div class="t m0 x0 h4 ye8e ffe7 fs2 fc0 sc0 ls6 ws6">这里，会返回匹配&quot;employee/name&quot;的第一个节点。上下文节点是xmldom.documentElement，</div><div class="t m0 x0 h4 y166 ffe7 fs2 fc0 sc0 ls8 ws1">因此就调用了该节点上的selectSingleNode()。由于调用这个方法可能会返回null值，因而有必</div><div class="t m0 x0 hc y167 ffe7 fs2 fc0 sc0 ls8 ws1">要在使用返回的节点之前，先检查确定它不是null。 </div><div class="t m0 x0 hc y3962 ffe7 fs2 fc0 sc0 ls8 ws1">另一个方法selectNodes()也接收一个XPath模式作为参数，但它返回与模式匹配的所有节点的</div><div class="t m0 x0 h5 y3269 ffe8 fs1 fc0 sc0 ls9 ws2">NodeList（如果没有匹配的节点，则返回一个包含零项的NodeList）。来看下面的例子。 </div><div class="t m0 x0 hb y2a6e ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3963 ffe8 fs6 fc0 sc0 ls21 wsb">var elements = xmldom.documentElement.selectNodes(&quot;employee/name&quot;); </div><div class="t m0 x0 hb y3964 ffe8 fs6 fc0 sc0 ls21 wsb">alert(elements.length); </div><div class="t m0 x0 hb y3965 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1c3f ffe9 fs2 fc0 sc0 ls94 wsb">IEXPathExample02.htm </div><div class="t m0 x0 h4 y24d ffe7 fs2 fc0 sc0 ls8 ws1">对这个例子而言，匹配&quot;employee/name&quot;的所有元素都会通过NodeList返回。由于不可能返回</div><div class="t m0 x0 h4 y3966 ffe8 fs1 fc0 sc0 ls9 ws2">null值，因此可以放心地使用返回的结果。但要记住，既然结果是NodeList，而其包含的元素可能</div><div class="t m0 x0 h5 y3967 ffe7 fs2 fc0 sc0 ls8 ws1">会动态变化，所以每次访问它都有可能得到不同的结果。 </div><div class="t m0 x0 h5 y3968 ffe0 fs2 fc0 sc0 ls2dc ws2a5">IE对XPath的支持非常简单。除了能够取得一个节点或一个NodeList外，不可能取得其他结果</div><div class="t m0 x0 h5 y251 ffe7 fs2 fc0 sc0 ls5">类型。 </div><div class="t m0 x0 h3c y3969 ffe5 fs2 fc0 sc0 ls2f ws2bd">IE对命名空间的支持 </div><div class="t m0 x0 h5 y396a ffe7 fs2 fc0 sc0 ls8 ws1">要在IE中处理包含命名空间的XPath 表达式，你必须知道自己使用的命名空间，并按照下列格式</div><div class="t m0 x0 h5 y396b ffe7 fs2 fc0 sc0 ls8 ws1">创建一个字符串： </div><div class="t m0 x0 hb y396c ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y396d ffe8 fs6 fc0 sc0 ls21 wsb">&quot;xmlns:prefix1=&apos;uri1&apos; xmlns:prefix2=&apos;uri2&apos; xmlns:prefix3=&apos;uri3&apos;&quot; </div><div class="t m0 x0 hb y396e ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1c25 ffe7 fs2 fc0 sc0 ls8 ws1">然后，必须将这个字符串传入到XML DOM文档对象的特殊方法setProperty()中，这个方法接</div><div class="t m0 x0 h1e y396f ffe7 fs2 fc0 sc0 ls8 ws1">收两个参数：要设置的属性名和属性值。在这里，属性名应该是&quot;SelectionNamespaces&quot;，属性值就</div><div class="t m0 x0 h5 y28e4 ffe7 fs2 fc0 sc0 ls8 ws1">是按照前面格式创建的字符串。下面来看一个在DOM XPath命名空间中对XML文档求值的例子。 </div><div class="t m0 x0 hb y3970 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3971 ffe8 fs6 fc0 sc0 ls21 wsb">xmldom.setProperty(&quot;SelectionNamespaces&quot;, &quot;xmlns:wrox=’http://www.wrox.com/’&quot;); </div><div class="t m0 x0 hb y3972 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3973 ffe8 fs6 fc0 sc0 ls21 wsb">var result = xmldom.documentElement.selectNodes(&quot;wrox:book/wrox:author&quot;); </div><div class="t m0 x0 hb y3974 ffe8 fs6 fc0 sc0 ls21 wsb">alert(result.length); </div><div class="t m0 x0 hb y3975 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y3976 ffe9 fs2 fc0 sc0 ls94 wsb">IEXPathExample03.htm </div></div></div>
<div id="pf229" class="pf w0 h0" data-page-no="229"><div class="pc pc229 w0 h0"><div class="t m0 x4 h2 y1 ffe0 fs0 fc0 sc0 ls7 ws0">18.2 浏览器对XPath的支持   535 </div><div class="t m0 x0 h3 y2 ffe0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffe2 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ffe2 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffe2 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffe2 fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ffe2 fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ffe2 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffe2 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffe2 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffe2 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffe2 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffe2 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffe2 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ffe2 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ffe7 fs2 fc0 sc0 ls8 ws1">对于这个DOM XPath的例子来说，如果不提供命名空间解析信息，就会在对表达式求值时导致一</div><div class="t m0 x0 h5 y4d ffe7 fs2 fc0 sc0 ls8">个错误。 </div><div class="t m0 x0 h20 y1f2 ffe5 fs3 fc0 sc0 ls248 ws214">18.2.3 跨浏览器使用XPath </div><div class="t m0 x0 h5 y1f3 ffe7 fs2 fc0 sc0 ls8 ws1">鉴于IE对XPath功能的支持有限，因此跨浏览器XPath只能保证达到 IE支持的功能。换句话说，</div><div class="t m0 x0 h5 y1f4 ffe7 fs2 fc0 sc0 ls28b ws273">也就是要在其他使用DOM3级XPath 对象的浏览器中，重新创建selectSingleNode()和</div><div class="t m0 x0 h5 y1251 ffe8 fs1 fc0 sc0 ls9 ws2">selectNodes()方法。第一个函数是selectSingleNode()，它接收三个参数：上下文节点、XPath</div><div class="t m0 x0 h5 y1f6 ffe7 fs2 fc0 sc0 ls8 ws1">表达式和可选的命名空间对象。命名空间对象应该是下面这种字面量的形式。 </div><div class="t m0 x5 hb y3977 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3978 ffe8 fs6 fc0 sc0 ls21 wsb">{ </div><div class="t m0 x0 hb y3979 ffe8 fs6 fc0 sc0 ls21 wsb">    prefix1: &quot;uri1&quot;, </div><div class="t m0 x0 hb y397a ffe8 fs6 fc0 sc0 ls21 wsb">    prefix2: &quot;uri2&quot;, </div><div class="t m0 x0 hb y397b ffe8 fs6 fc0 sc0 ls21 wsb">    prefix3: &quot;uri3&quot; </div><div class="t m0 x0 hb y397c ffe8 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h4 y397d ffe7 fs2 fc0 sc0 ls8 ws1">以这种方式提供的命名空间信息，可以方便地转换为针对特定浏览器的命名空间解析格式。下面给</div><div class="t m0 x0 hc y397e ffe7 fs2 fc0 sc0 ls8 ws1">出了selectSingleNode()函数的完整代码。 </div><div class="t m0 x5 hb y397f ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3980 ffe8 fs6 fc0 sc0 ls21 wsb">function selectSingleNode(context, expression, namespaces){ </div><div class="t m0 x0 hb y3981 ffe8 fs6 fc0 sc0 ls21 wsb">    var doc = (context.nodeType != 9 ? context.ownerDocument : context); </div><div class="t m0 x0 hb y3982 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3983 ffe8 fs6 fc0 sc0 ls21 wsb">    if (typeof doc.evaluate != &quot;undefined&quot;){ </div><div class="t m0 x0 hb y3984 ffe8 fs6 fc0 sc0 ls21 wsb">        var nsresolver = null; </div><div class="t m0 x0 hb y3985 ffe8 fs6 fc0 sc0 ls21 wsb">        if (namespaces instanceof Object){ </div><div class="t m0 x0 hb y3986 ffe8 fs6 fc0 sc0 ls21 wsb">            nsresolver = function(prefix){ </div><div class="t m0 x0 hb y3987 ffe8 fs6 fc0 sc0 ls21 wsb">                return namespaces[prefix]; </div><div class="t m0 x0 hb y3988 ffe8 fs6 fc0 sc0 ls21 wsb">            }; </div><div class="t m0 x0 hb y3989 ffe8 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y398a ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y398b ffe8 fs6 fc0 sc0 ls21 wsb">        var result = doc.evaluate(expression, context, nsresolver,  </div><div class="t m0 x0 hb y398c ffe8 fs6 fc0 sc0 ls21 wsb">                                  XPathResult.FIRST_ORDERED_NODE_TYPE, null); </div><div class="t m0 x0 hb y398d ffe8 fs6 fc0 sc0 ls21 wsb">        return (result !== null ? result.singleNodeValue : null); </div><div class="t m0 x0 hb y398e ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y398f ffe8 fs6 fc0 sc0 ls21 wsb">    } else if (typeof context.selectSingleNode != &quot;undefined&quot;){ </div><div class="t m0 x0 hb y3990 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y3991 ffe8 fs6 fc0 sc0 ls21 wsb">        //创建命名空间字符串 </div><div class="t m0 x0 hb y3992 ffe8 fs6 fc0 sc0 ls21 wsb">        if (namespaces instanceof Object){ </div><div class="t m0 x0 hb y3993 ffe8 fs6 fc0 sc0 ls21 wsb">            var ns = &quot;&quot;; </div><div class="t m0 x0 hb y3994 ffe8 fs6 fc0 sc0 ls21 wsb">            for (var prefix in namespaces){ </div><div class="t m0 x0 hb y3995 ffe8 fs6 fc0 sc0 ls21 wsb">                if (namespaces.hasOwnProperty(prefix)){ </div><div class="t m0 x0 hb y3996 ffe8 fs6 fc0 sc0 ls21 wsb">                    ns += &quot;xmlns:&quot; + prefix + &quot;=&apos;&quot; + namespaces[prefix] + &quot;&apos; &quot;; </div><div class="t m0 x0 hb y3997 ffe8 fs6 fc0 sc0 ls21 wsb">                } </div><div class="t m0 x0 hb y3998 ffe8 fs6 fc0 sc0 ls21 wsb">            } </div><div class="t m0 x0 hb y3999 ffe8 fs6 fc0 sc0 ls21 wsb">            doc.setProperty(&quot;SelectionNamespaces&quot;, ns); </div><div class="t m0 x0 hb y399a ffe8 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y399b ffe8 fs6 fc0 sc0 ls21 wsb">        return context.selectSingleNode(expression); </div><div class="t m0 x0 hb y399c ffe8 fs6 fc0 sc0 ls21 wsb">    } else { </div><div class="t m0 x0 hb y399d ffe8 fs6 fc0 sc0 ls21 wsb">        throw new Error(&quot;No XPath engine found.&quot;); </div><div class="t m0 x0 hb y399e ffe8 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y399f ffe8 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x2 hf y39a0 ffe9 fs2 fc0 sc0 ls5e wsb">CrossBrowserXPathExample01.htm </div></div></div>
<div id="pf22a" class="pf w0 h0" data-page-no="22a"><div class="pc pc22a w0 h0"><div class="t m0 x0 h2 y1 ffe0 fs0 fc0 sc0 ls7 ws0">536  第18章 JavaScript与XML </div><div class="t m0 x0 h3 y2 ffe0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ffe7 fs2 fc0 sc0 ls8 ws1">这个函数首先要确定XML文档，以便基于该文档对表达式求值。由于上下文节点可能是文档，所</div><div class="t m0 x0 hc y4d ffe7 fs2 fc0 sc0 ls8 ws1">以必须要检测nodeType属性。此后，变量doc中就会保存对XML 文档的引用。然后，可以检测文档</div><div class="t m0 x0 hc y5 ffe7 fs2 fc0 sc0 ls57 wsa9">中是否存在evaluate()方法，即是否支持DOM3 级XPath。如果支持，接下来就是检测传入的</div><div class="t m0 x0 h4 yd9 ffe8 fs1 fc0 sc0 ls9 ws2">namespaces对象。在这里使用instanceof 操作符而不是typeof，是因为后者对null 也返回</div><div class="t m0 x0 h4 y219 ffe8 fs1 fc0 sc0 ls9 ws2">&quot;object&quot;。然后将nsresolver变量初始化为null，如果提供了命名空间信息的话，就将其改为一</div><div class="t m0 x0 hc y21a ffe7 fs2 fc0 sc0 ls8 ws1">个函数。这个函数是一个闭包，它使用传入的namespaces对象来返回命名空间的 URI。此后，调用</div><div class="t m0 x0 h5 y9 ffe8 fs1 fc0 sc0 ls9 ws2">evaluate()方法，并对其结果进行检测，在确定是节点之后再返回该结果。 </div><div class="t m0 x0 hc y15f ffe7 fs2 fc0 sc0 ls127 wse8">在这个函数针对IE的分支中，需要检查context节点中是否存在selectSingleNode()方法。与DOM</div><div class="t m0 x0 h4 yb ffe7 fs2 fc0 sc0 ls127 wse8">分支一样，这里的第一步是有选择地构建命名空间信息。如果传入了namespaces对象，则迭代其属性并以</div><div class="t m0 x0 h1e y78a ffe7 fs2 fc0 sc0 ls127 wse8">适当格式创建一个字符串。注意，这里使用了hasOwnProperty()方法来确保对Object.prototype的任何</div><div class="t m0 x0 hc y116b ffe7 fs2 fc0 sc0 ls127 wse8">修改都不会影响到当前函数。最后，调用原生的selectSingleNode()方法并返回结果。 </div><div class="t m0 x0 h5 ye ffe7 fs2 fc0 sc0 ls8 ws1">如果前面两种方法都没有得到支持，这个函数就会抛出一个错误，表示找不到XPath处理引擎。下</div><div class="t m0 x0 hc yf ffe7 fs2 fc0 sc0 ls8 ws1">面是使用selectSingleNode()函数的示例。 </div><div class="t m0 x0 hb y21d ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y21e ffe8 fs6 fc0 sc0 ls21 wsb">var result = selectSingleNode(xmldom.documentElement, &quot;wrox:book/wrox:author&quot;, </div><div class="t m0 x0 hb y21f ffe8 fs6 fc0 sc0 ls21 wsb">                              { wrox: &quot;http://www.wrox.com/&quot; }); </div><div class="t m0 x0 hb y220 ffe8 fs6 fc0 sc0 ls21 wsb">alert(serializeXml(result)); </div><div class="t m0 x0 hb y39a2 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf y39a3 ffe9 fs2 fc0 sc0 ls5e wsb">CrossBrowserXPathExample01.htm </div><div class="t m0 x0 h4 y39a4 ffe7 fs2 fc0 sc0 ls55 ws49">类似地，也可以创建一个跨浏览器的selectNodes()函数。这个函数接收与selectSingle- </div><div class="t m0 x0 h42 y39a5 ffe8 fs1 fc0 sc0 ls9 ws2">Node()相同的三个参数，而且大部分逻辑都相似。为了便于看清楚，我们用加粗字体突出了这两个函</div><div class="t m0 x0 h5 y39a6 ffe7 fs2 fc0 sc0 ls8 ws1">数的差别所在。 </div><div class="t m0 x0 hb y39a7 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y39a8 ffec fs6 fc0 sc0 ls21 wsb">function selectNodes(context, expression, namespaces){ </div><div class="t m0 x0 hb y39a9 ffe8 fs6 fc0 sc0 ls21 wsb">    var doc = (context.nodeType != 9 ? context.ownerDocument : context); </div><div class="t m0 x0 hb y39aa ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y39ab ffe8 fs6 fc0 sc0 ls21 wsb">    if (typeof doc.evaluate != &quot;undefined&quot;){ </div><div class="t m0 x0 hb y39ac ffe8 fs6 fc0 sc0 ls21 wsb">        var nsresolver = null; </div><div class="t m0 x0 hb y39ad ffe8 fs6 fc0 sc0 ls21 wsb">        if (namespaces instanceof Object){ </div><div class="t m0 x0 hb y39ae ffe8 fs6 fc0 sc0 ls21 wsb">            nsresolver = function(prefix){ </div><div class="t m0 x0 hb y39af ffe8 fs6 fc0 sc0 ls21 wsb">                return namespaces[prefix]; </div><div class="t m0 x0 hb y39b0 ffe8 fs6 fc0 sc0 ls21 wsb">            }; </div><div class="t m0 x0 hb y39b1 ffe8 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y39b2 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y39b3 ffec fs6 fc0 sc0 ls21 wsb">        var result = doc.evaluate(expression, context, nsresolver, </div><div class="t m0 x0 h15 y39b4 ffec fs6 fc0 sc0 ls21 wsb">                                  XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null); </div><div class="t m0 x0 h15 y39b5 ffec fs6 fc0 sc0 ls21 wsb">        var nodes = new Array(); </div><div class="t m0 x0 h15 y39b6 ffec fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y39b7 ffec fs6 fc0 sc0 ls21 wsb">        if (result !== null){ </div><div class="t m0 x0 h15 y39b8 ffec fs6 fc0 sc0 ls21 wsb">            for (var i=0, len=result.snapshotLength; i &lt; len; i++){ </div><div class="t m0 x0 h15 y39b9 ffec fs6 fc0 sc0 ls21 wsb">                nodes.push(result.snapshotItem(i)); </div><div class="t m0 x0 h15 y39ba ffec fs6 fc0 sc0 ls21 wsb">            } </div><div class="t m0 x0 h15 y39bb ffec fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 h15 y39bc ffec fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y39bd ffec fs6 fc0 sc0 ls21 wsb">        return nodes; </div><div class="t m0 x0 hb y39be ffe8 fs6 fc0 sc0 ls21 wsb">    } else if (typeof context.selectNodes != &quot;undefined&quot;){ </div><div class="t m0 x0 hb y39bf ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y39c0 ffe8 fs6 fc0 sc0 ls21 wsb">        //创建命名空间字符串 </div><div class="t m0 x0 hb y39c1 ffe8 fs6 fc0 sc0 ls21 wsb">        if (namespaces instanceof Object){ </div><div class="t m0 x0 hb y39c2 ffe8 fs6 fc0 sc0 ls21 wsb">            var ns = &quot;&quot;; </div></div></div>
<div id="pf22b" class="pf w0 h0" data-page-no="22b"><div class="pc pc22b w0 h0"><div class="t m0 x4 h2 y1 ffe0 fs0 fc0 sc0 ls7 ws0">18.3 浏览器对XSLT的支持   537 </div><div class="t m0 x0 h3 y2 ffe0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffe2 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ffe2 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffe2 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffe2 fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ffe2 fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ffe2 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffe2 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffe2 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffe2 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffe2 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffe2 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffe2 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ffe2 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y79 ffe8 fs6 fc0 sc0 ls21 wsb">            for (var prefix in namespaces){ </div><div class="t m0 x0 hb y7a ffe8 fs6 fc0 sc0 ls21 wsb">                if (namespaces.hasOwnProperty(prefix)){ </div><div class="t m0 x0 hb y7b ffe8 fs6 fc0 sc0 ls21 wsb">                    ns += &quot;xmlns:&quot; + prefix + &quot;=&apos;&quot; + namespaces[prefix] + &quot;&apos; &quot;; </div><div class="t m0 x0 hb y7c ffe8 fs6 fc0 sc0 ls21 wsb">                } </div><div class="t m0 x0 hb y7d ffe8 fs6 fc0 sc0 ls21 wsb">            } </div><div class="t m0 x0 hb y7e ffe8 fs6 fc0 sc0 ls21 wsb">            doc.setProperty(&quot;SelectionNamespaces&quot;, ns); </div><div class="t m0 x0 hb y7f ffe8 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 h15 y80 ffec fs6 fc0 sc0 ls21 wsb">        var result = context.selectNodes(expression); </div><div class="t m0 x0 h15 y81 ffec fs6 fc0 sc0 ls21 wsb">        var nodes = new Array(); </div><div class="t m0 x0 h15 y82 ffec fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y83 ffec fs6 fc0 sc0 ls21 wsb">        for (var i=0,len=result.length; i &lt; len; i++){ </div><div class="t m0 x0 h15 y84 ffec fs6 fc0 sc0 ls21 wsb">            nodes.push(result[i]); </div><div class="t m0 x0 h15 y85 ffec fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 h15 y86 ffec fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y87 ffec fs6 fc0 sc0 ls21 wsb">        return nodes; </div><div class="t m0 x0 hb y88 ffe8 fs6 fc0 sc0 ls21 wsb">    } else { </div><div class="t m0 x0 hb y89 ffe8 fs6 fc0 sc0 ls21 wsb">        throw new Error(&quot;No XPath engine found.&quot;); </div><div class="t m0 x0 hb y8a ffe8 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y1823 ffe8 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x2 hf y2211 ffe9 fs2 fc0 sc0 ls5e wsb">CrossBrowserXPathExample02.htm </div><div class="t m0 x0 h5 y39c3 ffe7 fs2 fc0 sc0 ls8 ws1">很明显，其中有很多逻辑都与selectSingleNode()方法相同。在函数针对DOM的部分，使用</div><div class="t m0 x0 h5 y39c4 ffe7 fs2 fc0 sc0 ls8 ws1">了有序快照结果类型，然后将结果保存在了一个数组中。为了与IE的实现看齐，这个函数应该在没找</div><div class="t m0 x0 hc y39c5 ffe7 fs2 fc0 sc0 ls8 ws1">到匹配项的情况下也返回一个数组，因而最终都要返回数组nodes。在函数针对IE的分支中，调用了</div><div class="t m0 x0 h5 yc60 ffe8 fs1 fc0 sc0 ls9 ws2">selectNodes()方法并将结果复制到了一个数组中。因为IE返回的是一个NodeList，所以最好将节</div><div class="t m0 x0 h4 yc61 ffe7 fs2 fc0 sc0 ls8 ws1">点都复制到一个数组中，这样就可以确保在不同浏览器下，函数都能返回相同的数据类型。使用这个函</div><div class="t m0 x0 h5 y39c6 ffe7 fs2 fc0 sc0 ls8 ws1">数的示例如下： </div><div class="t m0 x5 hb y24c ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y39c7 ffe8 fs6 fc0 sc0 ls21 wsb">var result = selectNodes(xmldom.documentElement, &quot;wrox:book/wrox:author&quot;, </div><div class="t m0 x0 hb y39c8 ffe8 fs6 fc0 sc0 ls21 wsb">                               { wrox: &quot;http://www.wrox.com/&quot; }); </div><div class="t m0 x0 hb y39c9 ffe8 fs6 fc0 sc0 ls21 wsb">alert(result.length); </div><div class="t m0 x5 hb y39ca ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y2c94 ffe9 fs2 fc0 sc0 ls5e wsb">CrossBrowserXPathExample02.htm </div><div class="t m0 x0 h5 y39cb ffe7 fs2 fc0 sc0 ls8 ws1">为了求得最佳的浏览器兼容性，我们建议在JavaScript中使用XPath时，只考虑使用这两个方法。 </div><div class="t m0 x0 hd y39cc ffe5 fs7 fc0 sc0 ls245">18.3 浏览器对XSLT 的支持 </div><div class="t m0 x0 h5 y2740 ffe0 fs2 fc0 sc0 ls25 wsb3">XSLT是与XML相关的一种技术，它利用XPath将文档从一种表现形式转换成另一种表现形式。与</div><div class="t m0 x0 h5 y39cd ffe0 fs2 fc0 sc0 ls4a ws3a">XML和XPath不同，XSLT没有正式的API，在正式的DOM 规范中也没有它的位置。结果，只能依靠</div><div class="t m0 x0 h5 y39ce ffe7 fs2 fc0 sc0 ls8 ws1">浏览器开发商以自己的方式来实现它。IE是第一个支持通过JavaScript处理XSLT的浏览器。 </div><div class="t m0 x0 h20 y39cf ffe5 fs3 fc0 sc0 ls248 ws214">18.3.1 IE中的XSLT </div><div class="t m0 x0 h5 y2c58 ffe7 fs2 fc0 sc0 lsdd">与IE对其他XML功能的支持一样，它对XSLT的支持也是通过ActiveX对象实现的。从MSXML 3.0</div><div class="t m0 x0 h5 y36d6 ffe7 fs2 fc0 sc0 ls8 ws1">（即IE6.0）时代起，IE就支持通过JavaScript实现完整的 XSLT 1.0操作。IE9中通过DOMParser创建</div><div class="t m0 x0 h5 y205e ffe7 fs2 fc0 sc0 ls3b">的DOM文档不能使用XSLT。 </div><div class="t m0 x0 h3c y39d0 ffe5 fs2 fc0 sc0 ls2e wsb">1. 简单的XSLT转换 </div><div class="t m0 x0 h5 y39d1 ffe7 fs2 fc0 sc0 ls8 ws1">使用XSLT样式表转换XML文档的最简单方式，就是将它们分别加到一个 DOM文档中，然后再</div></div></div>
<div id="pf22c" class="pf w0 h0" data-page-no="22c"><div class="pc pc22c w0 h0"><div class="t m0 x0 h2 y1 ffe0 fs0 fc0 sc0 ls7 ws0">538  第18章 JavaScript与XML </div><div class="t m0 x0 h3 y2 ffe0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ffe7 fs2 fc0 sc0 ls8 ws1">使用transformNode()方法。这个方法存在于文档的所有节点中，它接受一个参数，即包含XSLT样</div><div class="t m0 x0 hc y4d ffe7 fs2 fc0 sc0 ls8 ws1">式表的文档。调用transformNode()方法会返回一个包含转换信息的字符串。来看一个例子。 </div><div class="t m0 x0 hb y2d8 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h36 y2d9 ffe8 fs6 fc0 sc0 ls21">//加载XML和XSLT（仅限于IE） </div><div class="t m0 x0 hb y2da ffe8 fs6 fc0 sc0 ls21 wsb">xmldom.load(&quot;employees.xml&quot;); </div><div class="t m0 x0 hb y2db ffe8 fs6 fc0 sc0 ls21 wsb">xsltdom.load(&quot;employees.xslt&quot;); </div><div class="t m0 x0 hb y2dc ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2dd ffe8 fs6 fc0 sc0 ls21">//转换 </div><div class="t m0 x0 hb y9e2 ffe8 fs6 fc0 sc0 ls21 wsb">var result = xmldom.transformNode(xsltdom); </div><div class="t m0 x0 hb y39d2 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y10a ffe9 fs2 fc0 sc0 ls2f wsb">IEXsltExample01.htm </div><div class="t m0 x0 h5 y39d3 ffe7 fs2 fc0 sc0 ls8 ws1">这个例子加载了一个XML的DOM文档和一个XSLT样式表的DOM 文档。然后，在XML文档节</div><div class="t m0 x0 h5 y8cb ffe7 fs2 fc0 sc0 ls8 ws1">点上调用了transformNode()方法，并传入XSLT。变量result 中最后就会保存一个转换之后得到</div><div class="t m0 x0 h1e y128e ffe7 fs2 fc0 sc0 ls8 ws1">的字符串。需要注意的是，由于是在文档节点级别上调用的transformNode()，因此转换是从文档节</div><div class="t m0 x0 h5 y39d4 ffe7 fs2 fc0 sc0 ls60">点开始的。实际上，XSLT转换可以在文档的任何级别上进行，只要在想要开始转换的节点上调用</div><div class="t m0 x0 h5 y39d5 ffe8 fs1 fc0 sc0 ls9 ws2">transformNode()方法即可。下面我们来看一个例子。 </div><div class="t m0 x0 hb y1599 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y39d6 ffe8 fs6 fc0 sc0 ls21 wsb">result = xmldom.documentElement.transformNode(xsltdom); </div><div class="t m0 x0 hb y39d7 ffe8 fs6 fc0 sc0 ls21 wsb">result = xmldom.documentElement.childNodes[1].transformNode(xsltdom); </div><div class="t m0 x0 hb y39d8 ffe8 fs6 fc0 sc0 ls21 wsb">result = xmldom.getElementsByTagName(&quot;name&quot;)[0].transformNode(xsltdom); </div><div class="t m0 x0 hb y39d9 ffe8 fs6 fc0 sc0 ls21 wsb">result = xmldom.documentElement.firstChild.lastChild.transformNode(xsltdom); </div><div class="t m0 x0 hb y39da ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1788 ffe7 fs2 fc0 sc0 ls8 ws1">如果不是在文档元素上调用transformNode()，那么转换就会从调用节点上面开始。不过，XSLT</div><div class="t m0 x0 h5 y39db ffe7 fs2 fc0 sc0 ls8 ws1">样式表则始终都可以针对调用节点所在的整个XML文档，而无需更换。 </div><div class="t m0 x0 h3c y39dc ffe5 fs2 fc0 sc0 ls2e wsb">2. 复杂的XSLT转换 </div><div class="t m0 x0 hdf y39dd ffe7 fs2 fc0 sc0 ls8 ws1">虽然transformNode()方法提供了基本的XSLT转换能力，但还有使用这种语言的更复杂的方式。</div><div class="t m0 x0 h5 y388f ffe7 fs2 fc0 sc0 ls8 ws1">为此，必须要使用XSL模板和XSL 处理器。第一步是要把XSLT样式表加载到一个线程安全的XML</div><div class="t m0 x0 hc y39de ffe7 fs2 fc0 sc0 ls8 ws1">文档中。而这可以通过使用ActiveX对象MSXML2.FreeThreadedDOMDocument来做到。这个ActiveX</div><div class="t m0 x0 h5 y66 ffe7 fs2 fc0 sc0 ls8 ws1">对象与IE中常规的DOM支持相同的接口。此外，创建这个对象时应该尽可能使用最新的版本。例如： </div><div class="t m0 x0 hb y39df ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y39e0 ffe8 fs6 fc0 sc0 ls21 wsb">function createThreadSafeDocument(){ </div><div class="t m0 x0 hb y39e1 ffe8 fs6 fc0 sc0 ls21 wsb">    if (typeof arguments.callee.activeXString != &quot;string&quot;){ </div><div class="t m0 x0 hb y39e2 ffe8 fs6 fc0 sc0 ls21 wsb">        var versions = [&quot;MSXML2.FreeThreadedDOMDocument.6.0&quot;,  </div><div class="t m0 x0 hb y39e3 ffe8 fs6 fc0 sc0 ls21 wsb">                        &quot;MSXML2.FreeThreadedDOMDocument.3.0&quot;, </div><div class="t m0 x0 hb y39e4 ffe8 fs6 fc0 sc0 ls21 wsb">                        &quot;MSXML2.FreeThreadedDOMDocument&quot;], </div><div class="t m0 x0 hb y39e5 ffe8 fs6 fc0 sc0 ls21 wsb">        i, len; </div><div class="t m0 x0 hb y39e6 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y39e7 ffe8 fs6 fc0 sc0 ls21 wsb">        for (i=0,len=versions.length; i &lt; len; i++){ </div><div class="t m0 x0 hb y39e8 ffe8 fs6 fc0 sc0 ls21 wsb">            try { </div><div class="t m0 x0 hb y39e9 ffe8 fs6 fc0 sc0 ls21 wsb">                new ActiveXObject(versions[i]); </div><div class="t m0 x0 hb y39ea ffe8 fs6 fc0 sc0 ls21 wsb">                arguments.callee.activeXString = versions[i]; </div><div class="t m0 x0 hb y39eb ffe8 fs6 fc0 sc0 ls21 wsb">                break; </div><div class="t m0 x0 hb y39ec ffe8 fs6 fc0 sc0 ls21 wsb">            } catch (ex){ </div><div class="t m0 x0 h16 y39ed ffe8 fs6 fc0 sc0 ls21 wsb">                //跳过 </div><div class="t m0 x0 hb y39ee ffe8 fs6 fc0 sc0 ls21 wsb">            } </div><div class="t m0 x0 hb y39ef ffe8 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y39f0 ffe8 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y39f1 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y39f2 ffe8 fs6 fc0 sc0 ls21 wsb">    return new ActiveXObject(arguments.callee.activeXString); </div><div class="t m0 x0 hb y39f3 ffe8 fs6 fc0 sc0 ls21 wsb">}       </div><div class="t m0 x0 hb y39f4 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y3521 ffe9 fs2 fc0 sc0 ls2f wsb">IEXsltExample02.htm </div></div></div>
<div id="pf22d" class="pf w0 h0" data-page-no="22d"><div class="pc pc22d w0 h0"><div class="t m0 x4 h2 y1 ffe0 fs0 fc0 sc0 ls7 ws0">18.3 浏览器对XSLT的支持   539 </div><div class="t m0 x0 h3 y2 ffe0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffe2 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ffe2 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffe2 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffe2 fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ffe2 fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ffe2 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffe2 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffe2 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffe2 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffe2 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffe2 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffe2 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ffe2 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ffe7 fs2 fc0 sc0 ls8 ws1">除了签名不同之外，线程安全的XML DOM文档与常规XML DOM文档的使用仍然是一样的，如</div><div class="t m0 x0 h5 y4d ffe7 fs2 fc0 sc0 ls8">下所示： </div><div class="t m0 x5 hb y1701 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2984 ffe8 fs6 fc0 sc0 ls21 wsb">var xsltdom = createThreadSafeDocument(); </div><div class="t m0 x0 hb y2985 ffe8 fs6 fc0 sc0 ls21 wsb">xsltdom.async = false; </div><div class="t m0 x0 hb y2986 ffe8 fs6 fc0 sc0 ls21 wsb">xsltdom.load(&quot;employees.xslt&quot;); </div><div class="t m0 x5 hb y39f5 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y39f6 ffe7 fs2 fc0 sc0 ls8 ws1">在创建并加载了自由线程的DOM文档之后，必须将它指定给一个XSL模板，这也是一个ActiveX</div><div class="t m0 x0 h5 y39f7 ffe7 fs2 fc0 sc0 ls8 ws1">对象。而这个模板是用来创建XSL处理器对象的，后者则是用来转换XML文档的。同样，也需要使用</div><div class="t m0 x0 h5 y39f8 ffe7 fs2 fc0 sc0 ls8 ws1">最新版本来创建这个对象，如下所示： </div><div class="t m0 x5 hb y3162 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y39f9 ffe8 fs6 fc0 sc0 ls21 wsb">function createXSLTemplate(){ </div><div class="t m0 x0 hb y39fa ffe8 fs6 fc0 sc0 ls21 wsb">    if (typeof arguments.callee.activeXString != &quot;string&quot;){ </div><div class="t m0 x0 hb y39fb ffe8 fs6 fc0 sc0 ls21 wsb">        var versions = [&quot;MSXML2.XSLTemplate.6.0&quot;,  </div><div class="t m0 x0 hb y39fc ffe8 fs6 fc0 sc0 ls21 wsb">                        &quot;MSXML2.XSLTemplate.3.0&quot;, </div><div class="t m0 x0 hb y39fd ffe8 fs6 fc0 sc0 ls21 wsb">                        &quot;MSXML2.XSLTemplate&quot;], </div><div class="t m0 x0 hb y39fe ffe8 fs6 fc0 sc0 ls21 wsb">            i, len; </div><div class="t m0 x0 hb y39ff ffe8 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 hb y3a00 ffe8 fs6 fc0 sc0 ls21 wsb">        for (i=0,len=versions.length; i &lt; len; i++){ </div><div class="t m0 x0 hb y3a01 ffe8 fs6 fc0 sc0 ls21 wsb">            try { </div><div class="t m0 x0 hb y3a02 ffe8 fs6 fc0 sc0 ls21 wsb">                new ActiveXObject(versions[i]); </div><div class="t m0 x0 hb y3a03 ffe8 fs6 fc0 sc0 ls21 wsb">                arguments.callee.activeXString = versions[i]; </div><div class="t m0 x0 hb y3a04 ffe8 fs6 fc0 sc0 ls21 wsb">                break; </div><div class="t m0 x0 hb y3a05 ffe8 fs6 fc0 sc0 ls21 wsb">            } catch (ex){ </div><div class="t m0 x0 h16 y3a06 ffe8 fs6 fc0 sc0 ls21 wsb">                //跳过 </div><div class="t m0 x0 hb y3a07 ffe8 fs6 fc0 sc0 ls21 wsb">            } </div><div class="t m0 x0 hb y3a08 ffe8 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y3a09 ffe8 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y3a0a ffe8 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 hb y3a0b ffe8 fs6 fc0 sc0 ls21 wsb">    return new ActiveXObject(arguments.callee.activeXString); </div><div class="t m0 x0 hb y3a0c ffe8 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x2 hf y3a0d ffe9 fs2 fc0 sc0 ls2f wsb">IEXsltExample02.htm </div><div class="t m0 x0 h5 y3a0e ffe7 fs2 fc0 sc0 ls8 ws1">使用这个createXSLTemplate()函数可以创建这个对象最新版本的实例，用法如下： </div><div class="t m0 x5 hb y1bee ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3a0f ffe8 fs6 fc0 sc0 ls21 wsb">var template = createXSLTemplate(); </div><div class="t m0 x0 hb y3a10 ffe8 fs6 fc0 sc0 ls21 wsb">template.stylesheet = xsltdom; </div><div class="t m0 x0 hb y3a11 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3a12 ffe8 fs6 fc0 sc0 ls21 wsb">var processor = template.createProcessor(); </div><div class="t m0 x0 hb y3a13 ffe8 fs6 fc0 sc0 ls21 wsb">processor.input = xmldom; </div><div class="t m0 x0 hb y3a14 ffe8 fs6 fc0 sc0 ls21 wsb">processor.transform(); </div><div class="t m0 x0 hb y3a15 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3a16 ffe8 fs6 fc0 sc0 ls21 wsb">var result = processor.output; </div><div class="t m0 x5 hb y3a17 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1a9a ffe9 fs2 fc0 sc0 ls2f wsb">IEXsltExample02.htm </div><div class="t m0 x0 h5 y3a18 ffe7 fs2 fc0 sc0 ls8 ws1">在创建了XSL处理器之后，必须将要转换的节点指定给input属性。这个值可以是一个文档，也</div><div class="t m0 x0 h1e y3a19 ffe7 fs2 fc0 sc0 lsa ws53">可以是文档中的任何节点。然后，调用transform()方法即可执行转换并将结果作为字符串保存在</div><div class="t m0 x0 h5 y3a1a ffe8 fs1 fc0 sc0 ls9 ws2">output属性中。这些代码实现了与transformNode()相同的功能。 </div><div class="t m0 x5 h5 y3a1b ffe0 fs2 fc0 sc0 ls25 wsb3">XSL模板对象的3.0和6.0版本存在显著的差别。在 3.0版本中，必须给input</div><div class="t m0 x5 h5 yf6a ffe1 fs2 fc0 sc0 ls8 ws14">属性指定一个完整的文档；如果指定的是节点，就会导致错误。而在6.0版本中，则</div><div class="t m0 x5 h18 y3a1c ffe1 fs2 fc0 sc0 ls8 ws14">可以为input属性指定文档中的任何节点。 </div></div></div>
<div id="pf22e" class="pf w0 h0" data-page-no="22e"><div class="pc pc22e w0 h0"><div class="t m0 x0 h2 y1 ffe0 fs0 fc0 sc0 ls7 ws0">540  第18章 JavaScript与XML </div><div class="t m0 x0 h3 y2 ffe0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ffe7 fs2 fc0 sc0 ls8 ws1">使用XSL处理器可以对转换进行更多的控制，同时也支持更高级的XSLT特性。例如，XSLT样式</div><div class="t m0 x0 h5 y4d ffe7 fs2 fc0 sc0 ls8 ws1">表可以接受传入的参数，并将其用作局部变量。以下面的样式表为例： </div><div class="t m0 x0 hb y2d8 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2d9 ffe8 fs6 fc0 sc0 ls21 wsb">&lt;?xml version=&quot;1.0&quot;?&gt; </div><div class="t m0 x0 hb y2da ffe8 fs6 fc0 sc0 ls21 wsb">&lt;xsl:stylesheet version=&quot;1.0&quot; xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;&gt; </div><div class="t m0 x0 hb y2db ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2dc ffe8 fs6 fc0 sc0 ls21 wsb">    &lt;xsl:output method=&quot;html&quot;/&gt; </div><div class="t m0 x0 hb y2dd ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y9e2 ffe8 fs6 fc0 sc0 ls21 wsb">    &lt;xsl:param name=&quot;message&quot;/&gt; </div><div class="t m0 x0 hb y9e3 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y9e4 ffe8 fs6 fc0 sc0 ls21 wsb">    &lt;xsl:template match=&quot;/&quot;&gt; </div><div class="t m0 x0 hb y9e5 ffe8 fs6 fc0 sc0 ls21 wsb">        &lt;ul&gt; </div><div class="t m0 x0 hb y9e6 ffe8 fs6 fc0 sc0 ls21 wsb">            &lt;xsl:apply-templates select=&quot;*&quot;/&gt; </div><div class="t m0 x0 hb y9e7 ffe8 fs6 fc0 sc0 ls21 wsb">        &lt;/ul&gt; </div><div class="t m0 x0 hb y3a1e ffe8 fs6 fc0 sc0 ls21 wsb">        &lt;p&gt;Message: &lt;xsl:value-of select=&quot;$message&quot;/&gt;&lt;/p&gt; </div><div class="t m0 x0 hb y3a1f ffe8 fs6 fc0 sc0 ls21 wsb">    &lt;/xsl:template&gt; </div><div class="t m0 x0 hb y3a20 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3a21 ffe8 fs6 fc0 sc0 ls21 wsb">    &lt;xsl:template match=&quot;employee&quot;&gt; </div><div class="t m0 x0 hb y3a22 ffe8 fs6 fc0 sc0 ls21 wsb">        &lt;li&gt;&lt;xsl:value-of select=&quot;name&quot;/&gt;, </div><div class="t m0 x0 hb y3a23 ffe8 fs6 fc0 sc0 ls21 wsb">            &lt;em&gt;&lt;xsl:value-of select=&quot;@title&quot;/&gt;&lt;/em&gt;&lt;/li&gt; </div><div class="t m0 x0 hb y3a24 ffe8 fs6 fc0 sc0 ls21 wsb">    &lt;/xsl:template&gt; </div><div class="t m0 x0 hb y3a25 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3a26 ffe8 fs6 fc0 sc0 ls21 wsb">&lt;/xsl:stylesheet&gt; </div><div class="t m0 x0 hb y3a27 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y33ff ffe9 fs2 fc0 sc0 ls5e wsb">employees.xslt </div><div class="t m0 x0 h4 y1fad ffe7 fs2 fc0 sc0 ls8 ws1">这个样式表定义了一个名为message的参数，然后将该参数输出到转换结果中。要设置message</div><div class="t m0 x0 h4 y3a28 ffe7 fs2 fc0 sc0 ls8 ws1">的值，可以在调用transform()之前使用addParameter()方法。addParameter()方法接收两个参</div><div class="t m0 x0 h4 y11c0 ffe7 fs2 fc0 sc0 ls8 ws1">数：要设置的参数名称（与在&lt;xsl:param&gt;的name特性中指定的一样）和要指定的值（多数情况下是</div><div class="t m0 x0 h5 y3a29 ffe7 fs2 fc0 sc0 ls8 ws1">字符串，但也可以是数值或布尔值）。下面就是这样一个例子。 </div><div class="t m0 x0 hb y1e52 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3a2a ffe8 fs6 fc0 sc0 ls21 wsb">processor.input = xmldom.documentElement; </div><div class="t m0 x0 hb y3a2b ffe8 fs6 fc0 sc0 ls21 wsb">processor.addParameter(&quot;message&quot;, &quot;Hello World!&quot;); </div><div class="t m0 x0 hb y3a2c ffe8 fs6 fc0 sc0 ls21 wsb">processor.transform(); </div><div class="t m0 x0 hb y3a2d ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y38c1 ffe9 fs2 fc0 sc0 ls2f wsb">IEXsltExample03.htm </div><div class="t m0 x0 h5 y3a2e ffe7 fs2 fc0 sc0 ls8 ws1">通过设置参数的值，这个值就可以在输出中反映出来。 </div><div class="t m0 x0 h5 y3a2f ffe0 fs2 fc0 sc0 ls25 wsb3">XSL处理器的另一个高级特性，就是能够设置一种操作模式。在XSLT中，可以使用mode特性为</div><div class="t m0 x0 h4 y3a30 ffe7 fs2 fc0 sc0 ls8 ws1">模板定义一种模式。在定义了模式后，如果没有将&lt;xsl:apply-templates&gt;与匹配的mode特性一起</div><div class="t m0 x0 h5 y3a31 ffe7 fs2 fc0 sc0 ls8 ws1">使用，就不会运行该模板。下面来看一个例子。 </div><div class="t m0 x0 hb y3a32 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3a33 ffe8 fs6 fc0 sc0 ls21 wsb">&lt;xsl:stylesheet version=&quot;1.0&quot; xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;&gt; </div><div class="t m0 x0 hb y3a34 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3a35 ffe8 fs6 fc0 sc0 ls21 wsb">    &lt;xsl:output method=&quot;html&quot;/&gt; </div><div class="t m0 x0 hb y3a36 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3a37 ffe8 fs6 fc0 sc0 ls21 wsb">    &lt;xsl:param name=&quot;message&quot;/&gt; </div><div class="t m0 x0 hb y3a38 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3a39 ffe8 fs6 fc0 sc0 ls21 wsb">    &lt;xsl:template match=&quot;/&quot;&gt; </div><div class="t m0 x0 hb y3a3a ffe8 fs6 fc0 sc0 ls21 wsb">        &lt;ul&gt; </div><div class="t m0 x0 hb y3a3b ffe8 fs6 fc0 sc0 ls21 wsb">            &lt;xsl:apply-templates select=&quot;*&quot;/&gt; </div><div class="t m0 x0 hb y3a3c ffe8 fs6 fc0 sc0 ls21 wsb">        &lt;/ul&gt; </div><div class="t m0 x0 hb y3a3d ffe8 fs6 fc0 sc0 ls21 wsb">        &lt;p&gt;Message: &lt;xsl:value-of select=&quot;$message&quot;/&gt;&lt;/p&gt; </div><div class="t m0 x0 hb y3a3e ffe8 fs6 fc0 sc0 ls21 wsb">    &lt;/xsl:template&gt; </div></div></div>
<div id="pf22f" class="pf w0 h0" data-page-no="22f"><div class="pc pc22f w0 h0"><div class="t m0 x4 h2 y1 ffe0 fs0 fc0 sc0 ls7 ws0">18.3 浏览器对XSLT的支持   541 </div><div class="t m0 x0 h3 y2 ffe0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffe2 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ffe2 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffe2 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffe2 fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ffe2 fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ffe2 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffe2 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffe2 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffe2 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffe2 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffe2 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffe2 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ffe2 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y79 ffe8 fs6 fc0 sc0 ls21 wsb">    &lt;xsl:template match=&quot;employee&quot;&gt; </div><div class="t m0 x0 hb y7a ffe8 fs6 fc0 sc0 ls21 wsb">        &lt;li&gt;&lt;xsl:value-of select=&quot;name&quot;/&gt;, </div><div class="t m0 x0 hb y7b ffe8 fs6 fc0 sc0 ls21 wsb">            &lt;em&gt;&lt;xsl:value-of select=&quot;@title&quot;/&gt;&lt;/em&gt;&lt;/li&gt; </div><div class="t m0 x0 hb y7c ffe8 fs6 fc0 sc0 ls21 wsb">    &lt;/xsl:template&gt; </div><div class="t m0 x0 hb y7d ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y7e ffe8 fs6 fc0 sc0 ls21 wsb">    &lt;xsl:template match=&quot;employee&quot; mode=&quot;title-first&quot;&gt; </div><div class="t m0 x0 hb y7f ffe8 fs6 fc0 sc0 ls21 wsb">        &lt;li&gt;&lt;em&gt;&lt;xsl:value-of select=&quot;@title&quot;/&gt;&lt;/em&gt;, </div><div class="t m0 x0 hb y80 ffe8 fs6 fc0 sc0 ls21 wsb">            &lt;xsl:value-of select=&quot;name&quot;/&gt;&lt;/li&gt; </div><div class="t m0 x0 hb y81 ffe8 fs6 fc0 sc0 ls21 wsb">    &lt;/xsl:template&gt; </div><div class="t m0 x0 hb y82 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y83 ffe8 fs6 fc0 sc0 ls21 wsb">&lt;/xsl:stylesheet&gt; </div><div class="t m0 x5 hb y3a3f ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x6 hf y3a40 ffe9 fs2 fc0 sc0 ls25 wsb">employees3.xslt </div><div class="t m0 x0 h4 y344a ffe7 fs2 fc0 sc0 ls8 ws1">这个样式表定义了一个模板，并将其mode特性设置为&quot;title-first&quot;（即“先显示职位”）。在这</div><div class="t m0 x0 h4 y3a41 ffe7 fs2 fc0 sc0 ls6f ws54">个模板中，首先会输出员工的职位，其次才输出员工的名字。为了使用这个模板，必须也要将</div><div class="t m0 x0 h4 y9e9 ffe8 fs1 fc0 sc0 ls9 ws2">&lt;xsl:apply-templates&gt;元素的模式设置为&quot;title-first&quot;。在使用这个样式表时，默认情况下其</div><div class="t m0 x0 h4 y9ea ffe7 fs2 fc0 sc0 ls8 ws1">输出结果与前面一样，先显示员工的名字，再显示员工的职位。但是，如果在使用这个样式表时，使用</div><div class="t m0 x0 hc y244e ffe0 fs2 fc0 sc0 lsb ws5">JavaScript将模式设置为&quot;title-first&quot;，那么结果就会先输出员工的职位。在JavaScript 中使用</div><div class="t m0 x0 h5 y9ec ffe8 fs1 fc0 sc0 ls9 ws2">setStartMode()方法设置模式的例子如下。 </div><div class="t m0 x5 hb y3a42 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3a43 ffe8 fs6 fc0 sc0 ls21 wsb">processor.input = xmldom; </div><div class="t m0 x0 hb y3a44 ffe8 fs6 fc0 sc0 ls21 wsb">processor.addParameter(&quot;message&quot;, &quot;Hello World!&quot;); </div><div class="t m0 x0 hb y3a45 ffe8 fs6 fc0 sc0 ls21 wsb">processor.setStartMode(&quot;title-first&quot;); </div><div class="t m0 x0 hb y3a46 ffe8 fs6 fc0 sc0 ls21 wsb">processor.transform(); </div><div class="t m0 x5 hb y3a47 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y3a48 ffe9 fs2 fc0 sc0 ls2f wsb">IEXsltExample05.htm </div><div class="t m0 x0 h4 y3a49 ffe8 fs1 fc0 sc0 ls9 ws2">setStartMode()方法只接受一个参数，即要为处理器设置的模式。与addParameter()一样，设</div><div class="t m0 x0 hc y35b6 ffe7 fs2 fc0 sc0 ls8 ws1">置模式也必须在调用transform()之前进行。 </div><div class="t m0 x0 h4 y2a9b ffe7 fs2 fc0 sc0 ls8 ws1">如果你打算使用同一个样式表进行多次转换，可以在每次转换之后重置处理器。调用reset()方法</div><div class="t m0 x0 hc y2a9c ffe7 fs2 fc0 sc0 ls8 ws1">后，就会清除原先的输入和输出属性、启动模式及其他指定的参数。调用reset()方法的例子如下： </div><div class="t m0 x5 hb y3a4a ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y3a4b ffe8 fs6 fc0 sc0 ls21 wsb">processor.reset();     //准备下一次转换 </div><div class="t m0 x5 hb y3a4c ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y8e6 ffe7 fs2 fc0 sc0 ls8 ws1">因为处理器已经编译了XSLT样式表，所以与使用transformNode()相比，这样进行重复转换的</div><div class="t m0 x0 h5 y2a6 ffe7 fs2 fc0 sc0 ls8 ws1">速度会更快一些。 </div><div class="t m0 x5 h5 y3a4d ffe0 fs2 fc0 sc0 lsb5 ws93">MSXML只支持XSLT 1.0。由于微软的战略重点转移到了.NET Framework，因而</div><div class="t m0 x5 h5 y3a4e ffe0 fs2 fc0 sc0 lsb5 ws93">MSXML的开发被停止了。我们希望在不久的将来，能够通过JavaScript访问XML和</div><div class="t m0 x5 h5 y3a4f ffe0 fs2 fc0 sc0 ls67 ws275">XSLT .NET对象。 </div><div class="t m0 x0 h20 y2ee0 ffe5 fs3 fc0 sc0 ls248 ws214">18.3.2 XSLTProcessor类型 </div><div class="t m0 x0 h5 ye10 ffe0 fs2 fc0 sc0 lsb ws5">Mozilla通过在Firefox 中创建新的类型，实现了JavaScript对XSLT的支持。开发人员可以通过</div><div class="t m0 x0 h5 y221f ffe8 fs1 fc0 sc0 ls9 ws2">XSLTProcessor类型使用XSLT转换XML文档，其方式与在IE 中使用XSL处理器类似。因为这个类</div><div class="t m0 x0 h5 y26c3 ffe7 fs2 fc0 sc0 ls8 ws1">型是率先出现的，所以Chrome、Safari和Opera都借鉴了相同的实现，最终使XSLTProcessor成为了</div><div class="t m0 x0 h5 y26c4 ffe7 fs2 fc0 sc0 ls8 ws1">通过JavaScript进行XSLT转换的事实标准。 </div></div></div>
<div id="pf230" class="pf w0 h0" data-page-no="230"><div class="pc pc230 w0 h0"><div class="t m0 x0 h2 y1 ffe0 fs0 fc0 sc0 ls7 ws0">542  第18章 JavaScript与XML </div><div class="t m0 x0 h3 y2 ffe0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ffe7 fs2 fc0 sc0 ls61">与IE的实现类似，第一步也是加载两个DOM文档，一个基于XML，另一个基于 XSLT。然后，</div><div class="t m0 x0 hc y4d ffe7 fs2 fc0 sc0 ls5 ws4">创建一个新XSLTProcessor对象，并使用importStylesheet()方法为其指定一个 XSLT，如下面</div><div class="t m0 x0 h5 y5 ffe7 fs2 fc0 sc0 ls5 ws4">的例子所示。 </div><div class="t m0 x0 hb y4f ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3a51 ffe8 fs6 fc0 sc0 ls21 wsb">var processor = new XSLTProcessor() </div><div class="t m0 x0 hb y3a52 ffe8 fs6 fc0 sc0 ls21 wsb">processor.importStylesheet(xsltdom); </div><div class="t m0 x0 hb y3a53 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y3a54 ffe9 fs2 fc0 sc0 ls79 wsb">XsltProcessorExample01.htm </div><div class="t m0 x0 h5 y3a55 ffe7 fs2 fc0 sc0 ls8 ws1">最后一步就是执行转换。这一步有两种不同的方式，如果想返回一个完整的DOM文档，可以调用</div><div class="t m0 x0 h4 y3a56 ffe8 fs1 fc0 sc0 ls9 ws2">transformToDocument()。而通过调用transformToFragment()则可以得到一个文档片段对象。一</div><div class="t m0 x0 hc y2d5e ffe7 fs2 fc0 sc0 ls8 ws1">般来说，使用transformToFragment()的唯一理由，就是你还想把返回的结果添加到另一个DOM文</div><div class="t m0 x0 h5 y20b1 ffe7 fs2 fc0 sc0 ls8">档中。 </div><div class="t m0 x0 hc y3a57 ffe7 fs2 fc0 sc0 ls8 ws1">在使用transformToDocument()时，只要传入XML DOM，就可以将结果作为一个完全不同的</div><div class="t m0 x0 h5 y2d60 ffe0 fs2 fc0 sc0 ls81 ws76">DOM文档来使用。来看下面的例子。 </div><div class="t m0 x0 hb y69b ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3a58 ffe8 fs6 fc0 sc0 ls21 wsb">var result = processor.transformToDocument(xmldom); </div><div class="t m0 x0 hb y3a59 ffe8 fs6 fc0 sc0 ls21 wsb">alert(serializeXml(result)); </div><div class="t m0 x0 hb y69e ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y3a5a ffe9 fs2 fc0 sc0 ls79 wsb">XsltProcessorExample01.htm </div><div class="t m0 x0 h5 y3a5b ffe7 fs2 fc0 sc0 ls15f">而transformToFragment()方法接收两个参数：要转换的XML DOM和应该拥有结果片段的文</div><div class="t m0 x0 h1e y3a5c ffe7 fs2 fc0 sc0 ls8 ws1">档。换句话说，如果你想将返回的片段插入到页面中，只要将document作为第二个参数即可。下面来</div><div class="t m0 x0 h5 y3a5d ffe7 fs2 fc0 sc0 ls8 ws1">看一个例子。 </div><div class="t m0 x0 hb y3a5e ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3a5f ffe8 fs6 fc0 sc0 ls21 wsb">var fragment = processor.transformToDocument(xmldom, document); </div><div class="t m0 x0 hb y3a60 ffe8 fs6 fc0 sc0 ls21 wsb">var div = document.getElementById(&quot;divResult&quot;); </div><div class="t m0 x0 hb y3a61 ffe8 fs6 fc0 sc0 ls21 wsb">div.appendChild(fragment); </div><div class="t m0 x0 hb y3a62 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y3a63 ffe9 fs2 fc0 sc0 ls79 wsb">XsltProcessorExample02.htm </div><div class="t m0 x0 h4 y754 ffe7 fs2 fc0 sc0 ls8 ws1">这里，处理器创建了一个由document对象拥有的片段。这样，就可以将返回的片段添加到页面中</div><div class="t m0 x0 hc y3a64 ffe7 fs2 fc0 sc0 ls8 ws1">已有的&lt;div&gt;元素中了。 </div><div class="t m0 x0 h5 y3a65 ffe7 fs2 fc0 sc0 ls3b">在XSLT样式表的输出格式为&quot;xml&quot;或&quot;html&quot;的情况下，创建文档或文档片段会非常有用。不过，</div><div class="t m0 x0 h1e y3a66 ffe7 fs2 fc0 sc0 ls5 ws4">在输出格式为&quot;text&quot;时，我们通常只希望得到转换的文本结果。可惜的是，没有方法能够直接返回文</div><div class="t m0 x0 h5 y3a67 ffe7 fs2 fc0 sc0 ls8 ws1">本。当输出格式为&quot;text&quot;时调用transformToDocument()，仍然会返回一个完整的XML文档，但</div><div class="t m0 x0 h5 y3a68 ffe7 fs2 fc0 sc0 ls8 ws1">这个文档的内容在不同浏览器中却不一样。例如，Safari会返回一个完整的HTML文档，而 Opera和</div><div class="t m0 x0 h5 y3a69 ffe0 fs2 fc0 sc0 ls47 ws38">Firefox则会返回一个只包含一个元素的文档，这个元素中包含着输出的文本。 </div><div class="t m0 x0 h4b y3a6a ffe7 fs2 fc0 sc0 ls8 ws1">使用transformToFragment()方法可以解决这个问题，这个方法返回的是只包含一个子节点的文</div><div class="t m0 x0 h5 y3a6b ffe7 fs2 fc0 sc0 ls8 ws1">档片段，而子节点中包含着结果文本。然后，使用下列代码就可以取得其中的文本。 </div><div class="t m0 x0 hb y3a6c ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3a6d ffe8 fs6 fc0 sc0 ls21 wsb">var fragment = processor.transformToFragment(xmldom, document); </div><div class="t m0 x0 hb y3a6e ffe8 fs6 fc0 sc0 ls21 wsb">var text = fragment.firstChild.nodeValue; </div><div class="t m0 x0 hb y3a6f ffe8 fs6 fc0 sc0 ls21 wsb">alert(text); </div><div class="t m0 x0 hb y3a70 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1102 ffe7 fs2 fc0 sc0 ls8 ws1">以上代码能够在支持的浏览器中一致地运行，而且能够恰好返回转换得到的输出文本。 </div><div class="t m0 x0 h3c y3a71 ffe5 fs2 fc0 sc0 ls2e wsb">1. 使用参数 </div><div class="t m0 x0 h5 y2220 ffe8 fs1 fc0 sc0 ls128 wse9">XSLTProcessor也支持使用setParameter()来设置XSLT的参数，这个方法接收三个参数：命名空间</div></div></div>
<div id="pf231" class="pf w0 h0" data-page-no="231"><div class="pc pc231 w0 h0"><div class="t m0 x4 h2 y1 ffe0 fs0 fc0 sc0 ls7 ws0">18.3 浏览器对XSLT的支持   543 </div><div class="t m0 x0 h3 y2 ffe0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffe2 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ffe2 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffe2 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffe2 fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ffe2 fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ffe2 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffe2 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffe2 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffe2 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffe2 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffe2 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffe2 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ffe2 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ffe0 fs2 fc0 sc0 ls436 ws3b3">URI、参数的内部名称和要设置的值。通常，命名空间URI都是null，而内部名称就是参数的名称。另外，</div><div class="t m0 x0 hc y4d ffe7 fs2 fc0 sc0 ls127 wse8">必须在调用transformToDocument()或transformToFragment()之前调用这个方法。下面来看例子。 </div><div class="t m0 x5 hb y2d8 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y639 ffe8 fs6 fc0 sc0 ls21 wsb">var processor = new XSLTProcessor() </div><div class="t m0 x0 hb y63a ffe8 fs6 fc0 sc0 ls21 wsb">processor.importStylesheet(xsltdom); </div><div class="t m0 x0 hb y63b ffe8 fs6 fc0 sc0 ls21 wsb">processor.setParameter(null, &quot;message&quot;, &quot;Hello World! &quot;); </div><div class="t m0 x0 hb y63c ffe8 fs6 fc0 sc0 ls21 wsb">var result = processor.transformToDocument(xmldom); </div><div class="t m0 x5 hb y3a72 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y9 ffe9 fs2 fc0 sc0 ls2f wsb">XsltProcessorExample03.htm </div><div class="t m0 x0 h4 y3162 ffe7 fs2 fc0 sc0 ls8 ws1">还有两个与参数有关的方法，getParameter()和removeParameter()，分别用于取得和移除当</div><div class="t m0 x0 hc y3a73 ffe7 fs2 fc0 sc0 ls8 ws1">前参数的值。这两个方法都要接受命名空间参数（同样，通常是null）和参数的内部名称。例如： </div><div class="t m0 x5 hb y3a74 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3a75 ffe8 fs6 fc0 sc0 ls21 wsb">var processor = new XSLTProcessor() </div><div class="t m0 x0 hb y3a76 ffe8 fs6 fc0 sc0 ls21 wsb">processor.importStylesheet(xsltdom); </div><div class="t m0 x0 hb y3a77 ffe8 fs6 fc0 sc0 ls21 wsb">processor.setParameter(null, &quot;message&quot;, &quot;Hello World! &quot;); </div><div class="t m0 x0 hb y3a78 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y3a79 ffe8 fs6 fc0 sc0 ls21 wsb">alert(processor.getParameter(null, &quot;message&quot;));     //输出&quot;Hello World!&quot; </div><div class="t m0 x0 hb y3a7a ffe8 fs6 fc0 sc0 ls21 wsb">processor.removeParameter(null, &quot;message&quot;); </div><div class="t m0 x0 hb y3a7b ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3a7c ffe8 fs6 fc0 sc0 ls21 wsb">var result = processor.transformToDocument(xmldom); </div><div class="t m0 x0 hb y3a7d ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3a7e ffe7 fs2 fc0 sc0 ls8 ws1">这两个方法并不常用，提供它们只是为了方便起见。 </div><div class="t m0 x0 h3c y3a7f ffe5 fs2 fc0 sc0 ls2e wsb">2. 重置处理器 </div><div class="t m0 x0 hb8 y3a80 ffe7 fs2 fc0 sc0 ls8 ws1">每个XSLTProcessor的实例都可以重用，以便使用不同的XSLT样式表执行不同的转换。重置处</div><div class="t m0 x0 h1e y36c5 ffe7 fs2 fc0 sc0 ls8 ws1">理器时要调用reset()方法，这个方法会从处理器中移除所有参数和样式表。然后，你就可以再次调用</div><div class="t m0 x0 h5 y2862 ffe8 fs1 fc0 sc0 ls9 ws2">importStylesheet()，以加载不同的XSLT样式表，如下面的例子所示。 </div><div class="t m0 x5 hb y3a81 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3a82 ffe8 fs6 fc0 sc0 ls21 wsb">var processor = new XSLTProcessor() </div><div class="t m0 x0 hb y3a83 ffe8 fs6 fc0 sc0 ls21 wsb">processor.importStylesheet(xsltdom); </div><div class="t m0 x0 hb y3a84 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y3a85 ffe8 fs6 fc0 sc0 ls21">//执行转换 </div><div class="t m0 x0 hb y3a86 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3a87 ffe8 fs6 fc0 sc0 ls21 wsb">processor.reset(); </div><div class="t m0 x0 hb y3a88 ffe8 fs6 fc0 sc0 ls21 wsb">processor.importStylesheet(xsltdom2); </div><div class="t m0 x0 hb y3a89 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y3a8a ffe8 fs6 fc0 sc0 ls21">//再执行转换 </div><div class="t m0 x5 hb y3a8b ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y15d1 ffe7 fs2 fc0 sc0 ls8 ws1">在需要基于多个样式表进行转换时，重用一个XSLTProcessor可以节省内存。 </div><div class="t m0 x0 h20 y3a8c ffe5 fs3 fc0 sc0 ls248 ws214">18.3.3 跨浏览器使用XSLT </div><div class="t m0 x0 h5 y3a8d ffe0 fs2 fc0 sc0 lse ws9">IE对XSLT转换的支持与XSLTProcessor的区别实在太大，因此要想重新实现二者所有这方面的</div><div class="t m0 x0 h5 y3a8e ffe7 fs2 fc0 sc0 ls8 ws1">功能并不现实。因此，跨浏览器兼容性最好的XSLT转换技术，只能是返回结果字符串。为此在 IE中只</div><div class="t m0 x0 h1c y3a8f ffe7 fs2 fc0 sc0 ls60 ws198">需在上下文节点上调用transformNode()即可，而在其他浏览器中则需要序列化transformTo- </div><div class="t m0 x0 h21 y3a90 ffe8 fs1 fc0 sc0 ls9 ws2">Document()操作的结果。下面这个函数可以在IE、Firefox、Chrome、Safari和Opera中使用。 </div><div class="t m0 x5 hb y3a91 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3a92 ffe8 fs6 fc0 sc0 ls21 wsb">function transform(context, xslt){ </div><div class="t m0 x0 hb y3a93 ffe8 fs6 fc0 sc0 ls21 wsb">    if (typeof XSLTProcessor != &quot;undefined&quot;){ </div><div class="t m0 x0 hb y3a94 ffe8 fs6 fc0 sc0 ls21 wsb">        var processor = new XSLTProcessor(); </div><div class="t m0 x0 hb y3a95 ffe8 fs6 fc0 sc0 ls21 wsb">        processor.importStylesheet(xslt); </div></div></div>
<div id="pf232" class="pf w0 h0" data-page-no="232"><div class="pc pc232 w0 h0"><div class="t m0 x0 h2 y1 ffe0 fs0 fc0 sc0 ls7 ws0">544  第18章 JavaScript与XML </div><div class="t m0 x0 h3 y2 ffe0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 ffe8 fs6 fc0 sc0 ls21 wsb">        var result = processor.transformToDocument(context); </div><div class="t m0 x0 hb y7a ffe8 fs6 fc0 sc0 ls21 wsb">        return (new XMLSerializer()).serializeToString(result); </div><div class="t m0 x0 hb y7b ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y7c ffe8 fs6 fc0 sc0 ls21 wsb">    } else if (typeof context.transformNode != &quot;undefined&quot;) { </div><div class="t m0 x0 hb y7d ffe8 fs6 fc0 sc0 ls21 wsb">        return context.transformNode(xslt); </div><div class="t m0 x0 hb y7e ffe8 fs6 fc0 sc0 ls21 wsb">    } else { </div><div class="t m0 x0 hb y7f ffe8 fs6 fc0 sc0 ls21 wsb">        throw new Error(&quot;No XSLT processor available.&quot;); </div><div class="t m0 x0 hb y80 ffe8 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y81 ffe8 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x2 hf y1108 ffe9 fs2 fc0 sc0 lsb wsb">CrossBrowserXsltExample01.htm </div><div class="t m0 x0 h5 y1109 ffe7 fs2 fc0 sc0 ls8 ws1">这个transform()函数接收两个参数：要执行转换的上下文节点和XSLT文档对象。首先，它检</div><div class="t m0 x0 h1e y2b13 ffe7 fs2 fc0 sc0 lsa ws53">测是否有XSLTProcessor类型的定义，如果有则使用该类型来进行转换。在调用 transformTo- </div><div class="t m0 x0 h42 y3a96 ffe8 fs1 fc0 sc0 ls9 ws2">Document()方法之后，将返回的结果序列化为字符串。如果上下文节点中有transformNode()方法，</div><div class="t m0 x0 h5 y3a97 ffe7 fs2 fc0 sc0 ls8 ws1">则调用该方法并返回结果。与本章中其他的跨浏览器函数一样，transform()也会在XSLT处理器无效</div><div class="t m0 x0 h5 y3a98 ffe7 fs2 fc0 sc0 ls8 ws1">的情况下抛出错误。下面是使用这个函数的示例。 </div><div class="t m0 x0 hb y3a99 ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3a9a ffe8 fs6 fc0 sc0 ls21 wsb">var result = transform(xmldom, xsltdom); </div><div class="t m0 x0 hb y3a9b ffe8 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3a9c ffe7 fs2 fc0 sc0 ls8 ws1">使用IE的transformNode()方法，可以确保不必使用线程安全的DOM文档进行转换。 </div><div class="t m0 x5 h5 y3a9d ffe1 fs2 fc0 sc0 ls8 ws14">注意，由于不同浏览器的XSLT引擎不一样，因此转换得到的结果在不同浏览器</div><div class="t m0 x0 h5 y3a9e ffe1 fs2 fc0 sc0 ls8 ws14">间可能会稍有不同，也可能会差别很大。因此，不能绝对依赖在 JavaScript中使用XSLT</div><div class="t m0 x0 h5 y3a9f ffe1 fs2 fc0 sc0 ls8 ws14">进行转换的结果。 </div><div class="t m0 x0 hd y38ec ffe5 fs7 fc0 sc0 ls245">18.4 小结 </div><div class="t m0 x0 h5 y21a4 ffe0 fs2 fc0 sc0 lsb ws5">JavaScript对XML及其相关技术有相当大的支持。然而，由于缺乏规范，共同的功能却存在一些不</div><div class="t m0 x0 h5 y3aa0 ffe7 fs2 fc0 sc0 ls8 ws1">同的实现。DOM2级提供了创建空XML文档的API，但没有涉及解析和序列化。既然规范没有对这些</div><div class="t m0 x0 h5 y3aa1 ffe7 fs2 fc0 sc0 ls8 ws1">功能作出规定，浏览器提供商就各行其是，拿出了自己的实现方案。IE采取了下列方式。 </div><div class="t m0 x0 h5 y343d ffe6 fs1 fc0 sc0 ls2"> 通过ActiveX对象来支持处理XML，而相同的对象也可以用来构建桌面应用程序。 </div><div class="t m0 x0 h5 y3aa2 ffe6 fs1 fc0 sc0 ls2"> Windows携带了MSXML库，JavaScript能够访问这个库。 </div><div class="t m0 x0 h5 y1ba9 ffe6 fs1 fc0 sc0 ls2"> 这个库中包含对基本XML解析和序列化的支持，同时也支持XPath和XSLT等技术。 </div><div class="t m0 x0 h5 y3aa3 ffe0 fs2 fc0 sc0 ls47 ws38">Firefox为处理XML的解析和序列化，实现了两个新类型，简介如下。 </div><div class="t m0 x0 h5 y146e ffe6 fs1 fc0 sc0 ls2"> DOMParser类型比较简单，其对象可以将XML字符串解析为DOM文档。 </div><div class="t m0 x0 h5 y146f ffe6 fs1 fc0 sc0 ls2"> XMLSerializer类型执行相反的操作，即将DOM文档序列化为XML字符串。 </div><div class="t m0 x0 h5 y1470 ffe7 fs2 fc0 sc0 ls8 ws1">由于Firefox中的类型比较简单，用户众多，IE9、Opera、Chrome和Safari都相继实现了相同的类</div><div class="t m0 x0 h5 y1471 ffe7 fs2 fc0 sc0 ls8 ws1">型。因此，这些类型也就成为了Web开发中的事实标准。 </div><div class="t m0 x0 h5 y3aa4 ffe0 fs2 fc0 sc0 ls24a ws215">DOM3级引入了一个针对XPath API的规范，该规范已经由Firefox、Safari、Chrome和Opera实现。</div><div class="t m0 x0 h5 y3aa5 ffe7 fs2 fc0 sc0 ls8 ws1">这些API可以让JavaScript基于DOM 文档运行任何XPath查询，并且能够返回任何数据的结果。IE以</div><div class="t m0 x0 h5 y3aa6 ffe7 fs2 fc0 sc0 ls164 ws3b5">自己的方式实现了对XPath的支持；具体来说，就是两个方法：selectSingleNode() 和</div><div class="t m0 x0 h5 y3aa7 ffe8 fs1 fc0 sc0 ls9 ws2">selectNodes()。虽然与DOM3级API相比还存在诸多限制，但使用这两个方法仍然能够执行基本的</div><div class="t m0 x0 h5 y3aa8 ffe0 fs2 fc0 sc0 ls8 ws20">XPath功能，即在DOM文档中查找节点或节点集合。 </div></div></div>
<div id="pf233" class="pf w0 h0" data-page-no="233"><div class="pc pc233 w0 h0"><div class="t m0 x2 h2 y1 ffe0 fs0 fc0 sc0 ls7 ws0">18.4 小结  545 </div><div class="t m0 x0 h3 y2 ffe0 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ffe2 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ffe2 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ffe2 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ffe2 fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ffe2 fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ffe2 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ffe2 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ffe2 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ffe2 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ffe2 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ffe2 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ffe2 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ffe2 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ffe7 fs2 fc0 sc0 ls3b">与XML相关的最后一种技术是XSLT，没有公开发布的标准针对这种技术的功能定义相应的API。</div><div class="t m0 x0 hc y4d ffe0 fs2 fc0 sc0 ls47 ws38">Firefox为通过JavaScript处理转换创建了XSLTProcessor类型；此后不久，Safari、Chrome、和 Opera</div><div class="t m0 x0 h5 y5 ffe7 fs2 fc0 sc0 ls8 ws1">也都实现了同样的类型。IE则针对XSLT提供了自己的方案，一个是简单的transformNode()方法，</div><div class="t m0 x0 h5 yd9 ffe7 fs2 fc0 sc0 ls8 ws1">另一个是较为复杂的模板/处理器手段。 </div><div class="t m0 x0 h5 y15d ffe7 fs2 fc0 sc0 ls8 ws1">目前，IE、Firefox、Chrome和Opera都能够较好地支持XML。虽然IE的实现与其他浏览器相比差</div><div class="t m0 x0 h5 y2b3 ffe7 fs2 fc0 sc0 ls8 ws1">异比较大，但仍然还是有较多的公共功能可供我们实现跨浏览器的方案。 </div><div class="t m0 x0 h5 y3aa9 ffe0 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3aaa ffe0 fs2 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf234" class="pf w0 h0" data-page-no="234"><div class="pc pc234 w0 h0"><div class="t m0 x0 h2 y1 ffef fs0 fc0 sc0 ls7 ws0">546  第19章 E4X </div><div class="t m0 x0 h3 y2 ffef fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h9 y2a fff1 fs5 fc0 sc0 ls3a4 wsb">E4X </div><div class="t m0 x0 h3c y2b fff2 fs2 fc0 sc0 ls8">本章内容 </div><div class="t m0 x0 h5 y2c fff4 fs1 fc0 sc0 ls2"> E4X新增的类型 </div><div class="t m0 x0 h5 y2d fff4 fs1 fc0 sc0 ls2"> 使用E4X操作XML </div><div class="t m0 x0 h5 y2e fff4 fs1 fc0 sc0 ls2"> 语法的变化 </div><div class="t m0 x0 h5 y8d9 ffef fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y8da ffef fs2 fc0 sc0 ls8 ws20">002年，由BEA Systems为首的几家公司建议为ECMAScript 增加一项扩展，以便在这门语言</div><div class="t m0 x0 h5 y8db fff5 fs2 fc0 sc0 ls8 ws1">中添加原生的XML支持。2004年6月，E4X（ECMAScript for XML）以ECMA-357标准的形</div><div class="t m0 x0 h5 y8dc fff5 fs2 fc0 sc0 ls8 ws1">式发布；2005年12月又发布了修订版。E4X本身不是一门语言，它只是ECMAScript语言的可选扩展。</div><div class="t m0 x0 h5 y8dd fff5 fs2 fc0 sc0 ls8 ws1">就其本身而言，E4X为处理XML定义了新的语法，也定义了特定于XML的对象。 </div><div class="t m0 x0 h5 y8de fff5 fs2 fc0 sc0 ls8 ws1">尽管浏览器实现这个扩展标准的步伐非常缓慢，但Firefox 1.5及更高版本则支持几乎全部E4X标准。</div><div class="t m0 x0 h5 y8df fff5 fs2 fc0 sc0 ls8 ws1">本章主要讨论Firefox对E4X的实现。 </div><div class="t m0 x0 hd y1fd0 fff3 fs7 fc0 sc0 ls245">19.1 E4X的类型 </div><div class="t m0 x0 h5 y3aab fff5 fs2 fc0 sc0 ls8 ws1">作为对ECMAScript的扩展，E4X定义了如下几个新的全局类型。 </div><div class="t m0 x0 h5 y10ca fff4 fs1 fc0 sc0 ls2"> XML：XML结构中的任何一个独立的部分。 </div><div class="t m0 x0 h5 y10cb fff4 fs1 fc0 sc0 ls2"> XMLList：XML对象的集合。 </div><div class="t m0 x0 h5 y8e4 fff4 fs1 fc0 sc0 ls2"> Namespace：命名空间前缀与命名空间URI之间的映射。 </div><div class="t m0 x0 h5 y10cd fff4 fs1 fc0 sc0 ls2"> QName：由内部名称和命名空间URI组成的一个限定名。 </div><div class="t m0 x0 h5 y3aac ffef fs2 fc0 sc0 lsd2 ws19b">E4X定义的这个4个类型可以表现XML文档中的所有部分，其内部机制是将每一种类型（特别是</div><div class="t m0 x0 h5 y2c55 fff6 fs1 fc0 sc0 ls9 ws2">XML和XMLList）都映射为多个DOM类型。 </div><div class="t m0 x0 h20 y914 fff3 fs3 fc0 sc0 ls248 ws214">19.1.1 XML类型 </div><div class="t m0 x0 h5 y3aad fff6 fs1 fc0 sc0 ls9 ws2">XML类型是E4X中定义的一个重要的新类型，可以用它来表现XML 结构中任何独立的部分。XML</div><div class="t m0 x0 h4 y9dc fff5 fs2 fc0 sc0 ls8 ws1">的实例可以表现元素、特性、注释、处理指令或文本节点。XML类型继承自Object类型，因此它也继</div><div class="t m0 x0 h1e y3aae fff5 fs2 fc0 sc0 ls8 ws1">承了所有对象默认的所有属性和方法。创建XML对象的方式不止一种，第一种方式是像下面这样调用其</div><div class="t m0 x0 h5 y3aaf fff5 fs2 fc0 sc0 ls8 ws1">构造函数： </div><div class="t m0 x0 hb y2ee1 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3ab0 fff6 fs6 fc0 sc0 ls21 wsb">var x = new XML(); </div><div class="t m0 x0 hb y3ab1 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y33b9 fff5 fs2 fc0 sc0 ls8 ws1">这行代码会创建一个空的XML对象，我们能够向其中添加数据。另外，也可以向构造函数中传入一</div><div class="t m0 x0 h5 y310b fff5 fs2 fc0 sc0 ls3b">个XML字符串，如下面的例子所示： </div><div class="t m0 x0 hb y49 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hf0 y12c6 fff8 fs14 fc0 sc0 ls43a wsb">2 </div><div class="t m0 x0 h11 y4b fff9 fsa fc0 sc0 ls8">第</div><div class="t m1 x0 h12 y4b fffa fsb fc3 sc0 ls247">19</div><div class="t m0 x5 h11 y4b fff9 fsa fc0 sc0 ls8 ws1d">章 </div></div></div>
<div id="pf235" class="pf w0 h0" data-page-no="235"><div class="pc pc235 w0 h0"><div class="t m0 x2 h2 y1 ffef fs0 fc0 sc0 ls7 ws0">19.1 E4X的类型   547 </div><div class="t m0 x0 h3 y2 ffef fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d fffb fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e fffb fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f fffb fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 fffb fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 fffb fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 fffb fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 fffb fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 fffb fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 fffb fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 fffb fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 fffb fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 fffb fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce fffb fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y79 fff6 fs6 fc0 sc0 ls21 wsb">var x = new XML(&quot;&lt;employee position=\&quot;Software Engineer\&quot;&gt;&lt;name&gt;Nicholas &quot; + </div><div class="t m0 x0 hb y7a fff6 fs6 fc0 sc0 ls21 wsb">                &quot;Zakas&lt;/name&gt;&lt;/employee&gt;&quot;);  </div><div class="t m0 x5 hb y1c6a fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1c6b fff5 fs2 fc0 sc0 ls8 ws1">传入到构造函数中的XML字符串会被解析为分层的XML 对象。除此之外，还可以向构造函数中</div><div class="t m0 x0 h5 y1e20 fff5 fs2 fc0 sc0 ls8 ws1">传入DOM文档或节点，以便它们的数据可以通过E4X来表现，语法如下： </div><div class="t m0 x5 hb y3ab2 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3ab3 fff6 fs6 fc0 sc0 ls21 wsb">var x = new XML(xmldom); </div><div class="t m0 x5 hb y3ab4 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y34ac fff5 fs2 fc0 sc0 ls8 ws1">虽然这些创建XML对象的方式都还不错，但最强大也最吸引人的方法，则是使用XML字面量将XML</div><div class="t m0 x0 h5 y3ab5 fff5 fs2 fc0 sc0 ls8 ws1">数据直接指定给一个变量。XML字面量就是嵌入到JavaScript代码中的XML代码。下面来看一个例子。 </div><div class="t m0 x5 hb y3ab6 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3ab7 fff6 fs6 fc0 sc0 ls21 wsb">var employee = &lt;employee position=&quot;Software Engineer&quot;&gt; </div><div class="t m0 x0 hb y3ab8 fff6 fs6 fc0 sc0 ls21 wsb">                    &lt;name&gt;Nicholas C. Zakas&lt;/name&gt; </div><div class="t m0 x0 hb y3ab9 fff6 fs6 fc0 sc0 ls21 wsb">               &lt;/employee&gt;; </div><div class="t m0 x5 hb y3aba fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y3abb fffc fs2 fc0 sc0 ls7a wsb">XMLTypeExample01.htm </div><div class="t m0 x0 h5 y3abc fff5 fs2 fc0 sc0 ls8 ws1">在这个例子中，我们将一个XML数据结构直接指定给了一个变量。这种简洁的语法同样可以创建</div><div class="t m0 x0 hc y3abd fff5 fs2 fc0 sc0 ls8 ws1">一个XML对象，并将它赋值给employee变量。 </div><div class="t m0 x5 h5 y3abe ffef fs2 fc0 sc0 ls47 ws38">Firefox对E4X的实现不支持解析 XML的开头代码（prolog）。无论&lt;?xml </div><div class="t m0 x5 h5 y3abf fff6 fs1 fc0 sc0 ls9 wsb">version=&quot;1.0&quot; ?&gt;出现在传递给XML构造函数的文本中，还是出现在XML字面量</div><div class="t m0 x5 h5 y3ac0 fff0 fs2 fc0 sc0 ls8 ws14">中，都会导致语法错误。 </div><div class="t m0 x0 h5 y2db7 fff6 fs1 fc0 sc0 ls9 ws2">XML类型的toXMLString()方法会返回XML 对象及其子节点的XML字符串表示。另一方面，该</div><div class="t m0 x0 h4 y3ac1 fff5 fs2 fc0 sc0 ls8 ws1">类型的toString()方法则会基于不同XML对象的内容返回不同的字符串。如果内容简单（纯文本），</div><div class="t m0 x0 hc y3ac2 fff5 fs2 fc0 sc0 ls8 ws1">则返回文本；否则，toString()方法与toXMLString()方法返回的字符串一样。来看下面的例子。 </div><div class="t m0 x5 hb y2fb9 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3ac3 fff6 fs6 fc0 sc0 ls21 wsb">var data = &lt;name&gt;Nicholas C. Zakas&lt;/name&gt;; </div><div class="t m0 x0 hb y3ac4 fff6 fs6 fc0 sc0 ls21 wsb">alert(data.toString());      //&quot;Nicholas C. Zakas&quot; </div><div class="t m0 x0 hb y3ac5 fff6 fs6 fc0 sc0 ls21 wsb">alert(data.toXMLString());    //&quot;&lt;name&gt;Nicholas C. Zakas&lt;/name&gt;&quot; </div><div class="t m0 x5 hb y3ac6 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3ac7 fff5 fs2 fc0 sc0 ls8 ws1">使用这两个方法，几乎可以满足所有序列化XML的需求。 </div><div class="t m0 x0 h20 y3ac8 fff3 fs3 fc0 sc0 ls248 ws214">19.1.2 XMLList类型 </div><div class="t m0 x0 h5 y3ac9 fff6 fs1 fc0 sc0 ls9 ws2">XMLList类型表现XML对象的有序集合。XMLList的DOM对等类型是 NodeList，但与Node和</div><div class="t m0 x0 h4 y3aca fff6 fs1 fc0 sc0 ls9 ws2">NodeList之间的区别相比，XML和XMLList之间的区别是有意设计得比较小的。要显式地创建一个</div><div class="t m0 x0 h5 y3acb fff6 fs1 fc0 sc0 ls9 ws2">XMLList对象，可以像下面这样使用XMLList构造函数： </div><div class="t m0 x5 hb y3acc fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3acd fff6 fs6 fc0 sc0 ls21 wsb">var list = new XMLList(); </div><div class="t m0 x5 hb y3ace fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y13d0 fff5 fs2 fc0 sc0 ls2c">与XML构造函数一样，也可以向其中传入一个待解析的XML字符串。这个字符串可以不止包含一</div><div class="t m0 x0 h5 y3acf fff5 fs2 fc0 sc0 ls8 ws1">个文档元素，如下面的例子所示： </div><div class="t m0 x5 hb y18e5 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3ad0 fff6 fs6 fc0 sc0 ls21 wsb">var list = new XMLList(&quot;&lt;item/&gt;&lt;item/&gt;&quot;); </div><div class="t m0 x5 hb y3ad1 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y3ad2 fffc fs2 fc0 sc0 ls7a wsb">XMLListTypeExample01.htm </div><div class="t m0 x0 h5 y3ad3 fff5 fs2 fc0 sc0 ls8 ws1">结果，保存在这个list变量中的XMLList就包含了两个 XML对象，分别是两个&lt;item/&gt;元素。 </div></div></div>
<div id="pf236" class="pf w0 h0" data-page-no="236"><div class="pc pc236 w0 h0"><div class="t m0 x0 h2 y1 ffef fs0 fc0 sc0 ls7 ws0">548  第19章 E4X </div><div class="t m0 x0 h3 y2 ffef fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 fff5 fs2 fc0 sc0 ls8 ws1">还可以使用加号（+）操作符来组合两个或多个XML对象，从而创建XMLList 对象。加号操作符</div><div class="t m0 x0 hc y4d fff5 fs2 fc0 sc0 ls3b">在E4X中已经被重载，可以用于创建XMLList，如下所示： </div><div class="t m0 x0 hb y1701 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2984 fff6 fs6 fc0 sc0 ls21 wsb">var list = &lt;item/&gt; + &lt;item/&gt; ; </div><div class="t m0 x0 hb y3ad5 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3ad6 fff5 fs2 fc0 sc0 ls8 ws1">这个例子使用加号操作符组合了两个XML字面量，结果得到一个XMLList。同样的组合操作也可</div><div class="t m0 x0 h5 y3ad7 fff5 fs2 fc0 sc0 ls8 ws1">以使用特殊的&lt;&gt;和&lt;/&gt;语法来完成，此时不使用加号操作符，例如： </div><div class="t m0 x0 hb y3ad8 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3ad9 fff6 fs6 fc0 sc0 ls21 wsb">var list = &lt;&gt;&lt;item/&gt;&lt;item/&gt;&lt;/&gt;; </div><div class="t m0 x0 hb y3ada fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3adb fff5 fs2 fc0 sc0 ls8 ws1">尽管可以创建独立的XMLList对象，但是这类对象通常是在解析较大的XML结构的过程中捎带着</div><div class="t m0 x0 h5 y3adc fff5 fs2 fc0 sc0 ls8 ws1">被创建出来的。来看下面的例子： </div><div class="t m0 x0 hb y3add fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3ade fff6 fs6 fc0 sc0 ls21 wsb">var employees = &lt;employees&gt; </div><div class="t m0 x0 hb y3adf fff6 fs6 fc0 sc0 ls21 wsb">    &lt;employee position=&quot;Software Engineer&quot;&gt; </div><div class="t m0 x0 hb y3ae0 fff6 fs6 fc0 sc0 ls21 wsb">        &lt;name&gt;Nicholas C. Zakas&lt;/name&gt; </div><div class="t m0 x0 hb y3ae1 fff6 fs6 fc0 sc0 ls21 wsb">    &lt;/employee&gt; </div><div class="t m0 x0 hb y3ae2 fff6 fs6 fc0 sc0 ls21 wsb">    &lt;employee position=&quot;Salesperson&quot;&gt; </div><div class="t m0 x0 hb y3ae3 fff6 fs6 fc0 sc0 ls21 wsb">        &lt;name&gt;Jim Smith&lt;/name&gt; </div><div class="t m0 x0 hb y3ae4 fff6 fs6 fc0 sc0 ls21 wsb">    &lt;/employee&gt; </div><div class="t m0 x0 hb y3ae5 fff6 fs6 fc0 sc0 ls21 wsb">&lt;/employees&gt;; </div><div class="t m0 x0 hb y3ae6 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y3ae7 fffc fs2 fc0 sc0 ls7a wsb">XMLListTypeExample02.htm </div><div class="t m0 x0 h4 y3ae8 fff5 fs2 fc0 sc0 ls8 ws1">以上代码定义的employees变量中包含着一个XML对象，表示&lt;employees/&gt;元素。由于这个元</div><div class="t m0 x0 hc y3ae9 fff5 fs2 fc0 sc0 ls24 ws1e">素又包含两个&lt;employee/&gt;元素，因而就会创建相应的XMLList对象，并将其保存在 employees. </div><div class="t m0 x0 h5 y219d fff6 fs1 fc0 sc0 ls9 ws2">employee中。然后，可以使用方括号语法及位置来访问每个元素： </div><div class="t m0 x0 hb y1526 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3aea fff6 fs6 fc0 sc0 ls21 wsb">var firstEmployee = employees.employee[0]; </div><div class="t m0 x0 hb y3aeb fff6 fs6 fc0 sc0 ls21 wsb">var secondEmployee = employees.employee[1]; </div><div class="t m0 x0 hb y3aec fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3aed fff5 fs2 fc0 sc0 ls8 ws1">每个XMLList对象都有length()方法，用于返回对象中包含的元素数量。例如： </div><div class="t m0 x0 hb y3aee fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3aef fff6 fs6 fc0 sc0 ls21 wsb">alert(employees.employee.length()); //2 </div><div class="t m0 x0 hb y3af0 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1a79 fff5 fs2 fc0 sc0 ls8 ws1">注意，length()是方法，不是属性。这一点是故意与数组和NodeList相区别的。 </div><div class="t m0 x0 h5 y3af1 ffef fs2 fc0 sc0 lsd2 ws19b">E4X有意模糊XML和XMLList类型之间的区别，这一点很值得关注。实际上，一个XML 对象与一</div><div class="t m0 x0 h1e y3af2 fff5 fs2 fc0 sc0 ls8 ws1">个只包含一个XML对象的XMLList之间，并没有显而易见的区别。为了减少两者之间的区别，每个XML</div><div class="t m0 x0 h5 y50d fff5 fs2 fc0 sc0 ls8 ws1">对象也同样有一个length()方法和一个由[0]引用的属性（返回XML对象自身）。 </div><div class="t m0 x0 h5 y3af3 fff6 fs1 fc0 sc0 ls9 ws2">XML与XMLList之间的这种兼容性可以简化E4X的使用，因为有些方法可以返回任意一个类型。 </div><div class="t m0 x0 h4 y3af4 fff6 fs1 fc0 sc0 ls9 ws2">XMLList对象的toString()和toXMLString()方法返回相同的字符串值，也就是将其包含的</div><div class="t m0 x0 h5 y3af5 ffef fs2 fc0 sc0 ls4a ws3a">XML对象序列化之后再拼接起来的结果。 </div><div class="t m0 x0 h20 y3af6 fff3 fs3 fc0 sc0 ls248 ws214">19.1.3 Namespace类型 </div><div class="t m0 x0 h5 y3013 ffef fs2 fc0 sc0 lsd2 ws19b">E4X中使用Namespace对象来表现命名空间。通常，Namespace对象是用来映射命名空间前缀和</div><div class="t m0 x0 h5 y3663 fff5 fs2 fc0 sc0 ls8 ws1">命名空间URI的，不过有时候并不需要前缀。要创建Namespace对象，可以像下面这样使用Namespace</div><div class="t m0 x0 h5 y514 fff5 fs2 fc0 sc0 ls8 ws1">构造函数： </div><div class="t m0 x0 hb y8c2 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3af7 fff6 fs6 fc0 sc0 ls21 wsb">var ns = new Namespace(); </div><div class="t m0 x0 hb y3af8 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y894 fff5 fs2 fc0 sc0 ls8 ws1">而传入URI或前缀加URI，就可以初始化Namespace对象，如下所示： </div></div></div>
<div id="pf237" class="pf w0 h0" data-page-no="237"><div class="pc pc237 w0 h0"><div class="t m0 x2 h2 y1 ffef fs0 fc0 sc0 ls7 ws0">19.1 E4X的类型   549 </div><div class="t m0 x0 h3 y2 ffef fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d fffb fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e fffb fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f fffb fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 fffb fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 fffb fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 fffb fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 fffb fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 fffb fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 fffb fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 fffb fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 fffb fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 fffb fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce fffb fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h16 y79 fff6 fs6 fc0 sc0 ls21 wsb">var ns = new Namespace(&quot;http://www.wrox.com/&quot;);              //没有前缀的命名空间 </div><div class="t m0 x0 h16 y7a fff6 fs6 fc0 sc0 ls21 wsb">var wrox = new Namespace(&quot;wrox&quot;, &quot;http://www.wrox.com/&quot;);   //wrox命名空间 </div><div class="t m0 x5 hb y1311 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y2885 fffc fs2 fc0 sc0 lsb wsb">NamespaceTypeExample01.htm </div><div class="t m0 x0 h5 y3af9 fff5 fs2 fc0 sc0 ls8 ws1">可以使用prefix和uri属性来取得Namespace 对象中的信息： </div><div class="t m0 x5 hb y3afa fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3afb fff6 fs6 fc0 sc0 ls21 wsb">alert(ns.uri);          //&quot;http://www.wrox.com/&quot; </div><div class="t m0 x0 hb y3afc fff6 fs6 fc0 sc0 ls21 wsb">alert(ns.prefix);       //undefined </div><div class="t m0 x0 hb y3afd fff6 fs6 fc0 sc0 ls21 wsb">alert(wrox.uri);        //&quot;http://www.wrox.com/&quot; </div><div class="t m0 x0 hb y3afe fff6 fs6 fc0 sc0 ls21 wsb">alert(wrox.prefix);      //&quot;wrox&quot; </div><div class="t m0 x5 hb y3aff fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y3b00 fffc fs2 fc0 sc0 lsb wsb">NamespaceTypeExample01.htm </div><div class="t m0 x0 h4 y3b01 fff5 fs2 fc0 sc0 ls8 ws1">在没有给Namespace对象指定前缀的情况下，prefix属性会返回undefined。要想创建默认的</div><div class="t m0 x0 h5 y3b02 fff5 fs2 fc0 sc0 ls8 ws1">命名空间，应该将前缀设置为空字符串。 </div><div class="t m0 x0 h1e y3b03 fff5 fs2 fc0 sc0 ls8 ws1">如果XML字面量中包含命名空间，或者通过XML构造函数解析的XML字符串中包含命名空间信息，</div><div class="t m0 x0 h1e y33cc fff5 fs2 fc0 sc0 ls8 ws1">那么就会自动创建Namespace对象。然后，就可以通过前缀和namespace()方法来取得对Namespace</div><div class="t m0 x0 h5 y379f fff5 fs2 fc0 sc0 ls8 ws1">对象的引用。来看下面的例子： </div><div class="t m0 x5 hb y3b04 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3b05 fff6 fs6 fc0 sc0 ls21 wsb">var xml = &lt;wrox:root xmlns:wrox=&quot;http://www.wrox.com/&quot;&gt; </div><div class="t m0 x0 hb y3b06 fff6 fs6 fc0 sc0 ls21 wsb">            &lt;wrox:message&gt;Hello World!&lt;/wrox:message&gt; </div><div class="t m0 x0 hb y3b07 fff6 fs6 fc0 sc0 ls21 wsb">          &lt;/wrox:root&gt;; </div><div class="t m0 x0 hb y3b08 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3b09 fff6 fs6 fc0 sc0 ls21 wsb">var wrox = xml.namespace(&quot;wrox&quot;); </div><div class="t m0 x0 hb y3b0a fff6 fs6 fc0 sc0 ls21 wsb">alert(wrox.uri); </div><div class="t m0 x0 hb y3b0b fff6 fs6 fc0 sc0 ls21 wsb">alert(wrox.prefix); </div><div class="t m0 x5 hb y3b0c fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y2c48 fffc fs2 fc0 sc0 lsb wsb">NamespaceTypeExample02.htm </div><div class="t m0 x0 h4 y119c fff5 fs2 fc0 sc0 ls8 ws1">在这个例子中，我们以XML字面量的形式创建了一个包含命名空间的XML 片段。而表现wrox命</div><div class="t m0 x0 h1e y3b0d fff5 fs2 fc0 sc0 ls8 ws1">名空间的Namespace对象可以通过namespace(&quot;wrox&quot;) 取得，然后就可以访问这个对象的 uri和</div><div class="t m0 x0 h4 y3b0e fff6 fs1 fc0 sc0 ls9 ws2">prefix属性了。如果XML片段中有默认的命名空间，那么向 namespace()中传入空字符串，即可取</div><div class="t m0 x0 hc y3b0f fff5 fs2 fc0 sc0 ls8 ws1">得相应的Namespace对象。 </div><div class="t m0 x0 h5 y38b6 fff6 fs1 fc0 sc0 ls9 ws2">Namespace对象的toString()方法始终会返回命名空间URI。 </div><div class="t m0 x0 h20 y2fb fff3 fs3 fc0 sc0 ls248 ws214">19.1.4 QName类型 </div><div class="t m0 x0 h4 y2fc fff6 fs1 fc0 sc0 ls9 ws2">QName类型表现的是XML对象的限定名，即命名空间与内部名称的组合。向QName 构造函数中传</div><div class="t m0 x0 hc y3b10 fff5 fs2 fc0 sc0 ls8 ws1">入名称或Namespace对象和名称，可以手工创建新的QName对象，如下所示： </div><div class="t m0 x5 hb y3913 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3b11 fff6 fs6 fc0 sc0 ls21 wsb">var wrox = new Namespace(&quot;wrox&quot;, &quot;http://www.wrox.com/&quot;); </div><div class="t m0 x0 h16 y3b12 fff6 fs6 fc0 sc0 ls21 wsb">var wroxMessage = new QName(wrox, &quot;message&quot;);     //表示&quot;wrox:message&quot; </div><div class="t m0 x5 hb y3b13 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y3b14 fffc fs2 fc0 sc0 ls5e wsb">QNameTypeExample01.htm </div><div class="t m0 x0 h4 y3b15 fff5 fs2 fc0 sc0 ls8 ws1">创建了QName对象之后，可以访问它的两个属性：uri和localName。其中，uri属性返回在创</div><div class="t m0 x0 h5 y3b16 fff5 fs2 fc0 sc0 ls8 ws1">建对象时指定的命名空间的URI（如果未指定命名空间，则返回空字符串），而localName属性返回限</div><div class="t m0 x0 h5 y3b17 fff5 fs2 fc0 sc0 ls8 ws1">定名中的内部名称，如下面的例子所示： </div><div class="t m0 x5 hb y2d6 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y2f50 ffef fs2 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf238" class="pf w0 h0" data-page-no="238"><div class="pc pc238 w0 h0"><div class="t m0 x0 h2 y1 ffef fs0 fc0 sc0 ls7 ws0">550  第19章 E4X </div><div class="t m0 x0 h3 y2 ffef fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 fff6 fs6 fc0 sc0 ls21 wsb">alert(wroxMessage.uri);             //&quot;http://www.wrox.com/&quot; </div><div class="t m0 x0 hb y7a fff6 fs6 fc0 sc0 ls21 wsb">alert(wroxMessage.localName);       //&quot;message&quot; </div><div class="t m0 x0 hb y3b19 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y3b1a fffc fs2 fc0 sc0 ls5e wsb">QNameTypeExample01.htm </div><div class="t m0 x0 h4 y161c fff5 fs2 fc0 sc0 ls8 ws1">这两个属性是只读的，如果你想修改它们的值，会导致错误发生。QName对象重写了toString()</div><div class="t m0 x0 h4 y3b1b fff5 fs2 fc0 sc0 ls8 ws1">方法，会以uri::localName形式返回一个字符串，对于前面的例子来说，就是&quot;http://www.wrox. </div><div class="t m0 x0 h21 y3b1c fff6 fs1 fc0 sc0 ls9 ws2">com/::message&quot;。 </div><div class="t m0 x0 h1e y3b1d fff5 fs2 fc0 sc0 ls8 ws1">在解析XML结构时，会为表示相应元素或特性的XML对象自动创建QName对象。可以使用这个XML</div><div class="t m0 x0 h5 y3b1e fff5 fs2 fc0 sc0 ls8 ws1">对象的name()方法取得与该XML对象关联的QName 对象，如下面的例子所示： </div><div class="t m0 x0 hb y2e0 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3b1f fff6 fs6 fc0 sc0 ls21 wsb">var xml = &lt; wrox:root xmlns:wrox=&quot;http://www.wrox.com/&quot;&gt; </div><div class="t m0 x0 hb y3b20 fff6 fs6 fc0 sc0 ls21 wsb">            &lt;wrox:message&gt;Hello World!&lt;/wrox:message&gt; </div><div class="t m0 x0 hb y3b21 fff6 fs6 fc0 sc0 ls21 wsb">          &lt;/wrox:root&gt; ; </div><div class="t m0 x0 hb y3b22 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3b23 fff6 fs6 fc0 sc0 ls21 wsb">var wroxRoot = xml.name(); </div><div class="t m0 x0 hb y3b24 fff6 fs6 fc0 sc0 ls21 wsb">alert(wroxRoot.uri);             //&quot;http://www.wrox.com/&quot; </div><div class="t m0 x0 hb y3b25 fff6 fs6 fc0 sc0 ls21 wsb">alert(wroxRoot.localName);       //&quot;root&quot; </div><div class="t m0 x0 hb y3b26 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1be6 fffc fs2 fc0 sc0 ls5e wsb">QNameTypeExample02.htm </div><div class="t m0 x0 h5 y1be7 fff5 fs2 fc0 sc0 ls8 ws1">这样，即便没有指定命名空间信息，也会根据XML结构中的元素和特性创建一个QName对象。 </div><div class="t m0 x0 hc y3b27 fff5 fs2 fc0 sc0 ls8 ws1">使用setName()方法并传入一个新QName对象，可以修改XML 对象的限定名，如下所示： </div><div class="t m0 x0 hb y1d77 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3b28 fff6 fs6 fc0 sc0 ls21 wsb">xml.setName(new QName(&quot;newroot&quot;)); </div><div class="t m0 x0 hb y3b29 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3b2a fff5 fs2 fc0 sc0 ls8 ws1">通常，这个方法会在修改相应命名空间下的元素标签名或特性名时用到。如果该名称不属于任何命</div><div class="t m0 x0 hc y3b2b fff5 fs2 fc0 sc0 ls8 ws1">名空间，则可以像下面这样使用setLocalName()方法来修改内部名称： </div><div class="t m0 x0 hb y3b2c fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3b2d fff6 fs6 fc0 sc0 ls21 wsb">xml.setLocalName(&quot;newtagname&quot;); </div><div class="t m0 x0 hd y3b2e fff3 fs7 fc0 sc0 ls245">19.2 一般用法 </div><div class="t m0 x0 h4 y18db fff5 fs2 fc0 sc0 ls8 ws1">在将XML对象、元素、特性和文本集合到一个层次化对象之后，就可以使用点号加特性或标签名的</div><div class="t m0 x0 h4 y3b2f fff5 fs2 fc0 sc0 ls8 ws1">方式来访问其中不同的层次和结构。每个子元素都是父元素的一个属性，而属性名与元素的内部名称相</div><div class="t m0 x0 h5 y3b30 fff5 fs2 fc0 sc0 ls8 ws1">同。如果子元素只包含文本，则相应的属性只返回文本，如下面的例子所示。 </div><div class="t m0 x0 hb y146a fff6 fs6 fc0 sc0 ls21 wsb">var employee = &lt;employee position=&quot;Software Engineer&quot;&gt; </div><div class="t m0 x0 hb y3b31 fff6 fs6 fc0 sc0 ls21 wsb">                     &lt;name&gt;Nicholas C. Zakas&lt;/name&gt; </div><div class="t m0 x0 hb y3b32 fff6 fs6 fc0 sc0 ls21 wsb">               &lt;/employee&gt;; </div><div class="t m0 x0 h15 y3b33 fff7 fs6 fc0 sc0 ls21 wsb">alert(employee.name); //&quot;Nicholas C. Zakas&quot; </div><div class="t m0 x0 hb y3b34 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3b35 fff5 fs2 fc0 sc0 ls8 ws1">以上代码中的&lt;name/&gt;元素只包含文本。访问employee.name即可取得该文本，而在内部需要定</div><div class="t m0 x0 h4 y3b36 fff5 fs2 fc0 sc0 ls8 ws1">位到&lt;name/&gt;元素，然后返回相应文本。由于传入到alert()时，会隐式调用toString()方法，因此</div><div class="t m0 x0 h1e y3b37 fff5 fs2 fc0 sc0 ls8 ws1">显示的是&lt;name/&gt;中包含的文本。这就使得访问XML文档中包含的文本数据非常方便。如果有多个元素</div><div class="t m0 x0 hc y3b38 fff5 fs2 fc0 sc0 ls8 ws1">具有相同的标签名，则会返回XMLList。下面再看一个例子。 </div><div class="t m0 x0 hb y3b39 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3b3a fff6 fs6 fc0 sc0 ls21 wsb">var employees = &lt;employees&gt; </div><div class="t m0 x0 hb y3b3b fff6 fs6 fc0 sc0 ls21 wsb">    &lt;employee position=&quot;Software Engineer&quot;&gt; </div><div class="t m0 x0 hb y3b3c fff6 fs6 fc0 sc0 ls21 wsb">        &lt;name&gt;Nicholas C. Zakas&lt;/name&gt; </div><div class="t m0 x0 hb y3b3d fff6 fs6 fc0 sc0 ls21 wsb">    &lt;/employee&gt; </div><div class="t m0 x0 hb y3b3e fff6 fs6 fc0 sc0 ls21 wsb">    &lt;employee position=&quot;Salesperson&quot;&gt; </div></div></div>
<div id="pf239" class="pf w0 h0" data-page-no="239"><div class="pc pc239 w0 h0"><div class="t m0 x2 h2 y1 ffef fs0 fc0 sc0 ls7 ws0">19.2 一般用法    551 </div><div class="t m0 x0 h3 y2 ffef fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d fffb fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e fffb fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f fffb fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 fffb fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 fffb fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 fffb fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 fffb fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 fffb fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 fffb fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 fffb fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 fffb fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 fffb fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce fffb fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y79 fff6 fs6 fc0 sc0 ls21 wsb">        &lt;name&gt;Jim Smith&lt;/name&gt; </div><div class="t m0 x0 hb y7a fff6 fs6 fc0 sc0 ls21 wsb">    &lt;/employee&gt; </div><div class="t m0 x0 hb y7b fff6 fs6 fc0 sc0 ls21 wsb">&lt;/employees&gt;; </div><div class="t m0 x0 hb y3b3f fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 yd6b fff7 fs6 fc0 sc0 ls21 wsb">alert(employees.employee[0].name);    //&quot;Nicholas C. Zakas&quot; </div><div class="t m0 x0 h15 yd6c fff7 fs6 fc0 sc0 ls21 wsb">alert(employees.employee[1].name);    //&quot;Jim Smith&quot; </div><div class="t m0 x0 h15 y3b40 fff7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y13fb fff5 fs2 fc0 sc0 ls8 ws1">这个例子访问了每个&lt;employee/&gt;元素并返回了它们&lt;name/&gt;元素的值。如果你不确定子元素的内</div><div class="t m0 x0 hc y13fc fff5 fs2 fc0 sc0 ls8 ws1">部名称，或者你想访问所有子元素，不管其名称是什么，也可以像下面这样使用星号（*）。 </div><div class="t m0 x0 hb y11ad fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y3b41 fff6 fs6 fc0 sc0 ls21 wsb">var allChildren = employees.*;     //返回所有子元素，不管其名称是什么 </div><div class="t m0 x0 hb y3b42 fff6 fs6 fc0 sc0 ls21 wsb">alert(employees.*[0].name);        //&quot;Nicholas C. Zakas&quot; </div><div class="t m0 x2 hf y3b43 fffc fs2 fc0 sc0 ls25 wsb">UsageExample01.htm </div><div class="t m0 x0 h5 y3b44 fff5 fs2 fc0 sc0 ls8 ws1">与其他属性一样，星号也可能返回XML对象，或返回XMLList对象，这要取决于 XML结构。 </div><div class="t m0 x0 h1e y3b45 fff5 fs2 fc0 sc0 ls8 ws1">要达到同样的目的，除了属性之外，还可以使用child()方法。将属性名或索引值传递给child()</div><div class="t m0 x0 h5 y29a9 fff5 fs2 fc0 sc0 ls8 ws1">方法，也会得到相同的值。来看下面的例子。 </div><div class="t m0 x0 hb y1ad2 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y3b46 fff6 fs6 fc0 sc0 ls21 wsb">var firstChild = employees.child(0);                 //与employees.*[0]相同 </div><div class="t m0 x0 h16 y3b47 fff6 fs6 fc0 sc0 ls21 wsb">var employeeList = employees.child(&quot;employee&quot;);      //与employees.employee相同 </div><div class="t m0 x0 h16 y3b48 fff6 fs6 fc0 sc0 ls21 wsb">var allChildren = employees.child(&quot;*&quot;);             //与employees.*相同 </div><div class="t m0 x0 hb y3b49 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y2875 fff5 fs2 fc0 sc0 ls8 ws1">为了再方便一些，还有一个children()方法始终返回所有子元素。例如： </div><div class="t m0 x0 hb y3b4a fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y3b4b fff6 fs6 fc0 sc0 ls21 wsb">var allChildren = employees.children();              //与employees.*相同 </div><div class="t m0 x0 hb y3b4c fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3b4d fff5 fs2 fc0 sc0 ls5c ws4a">而另一个方法elements()的行为与child()类似，区别仅在于它只返回表示元素的XML对象。例如： </div><div class="t m0 x0 hb y3b4e fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y3b4f fff6 fs6 fc0 sc0 ls21 wsb">var employeeList = employees.elements(&quot;employee&quot;);   //与employees.employee相同 </div><div class="t m0 x0 h16 y3b50 fff6 fs6 fc0 sc0 ls21 wsb">var allChildren = employees.elements(&quot;*&quot;);          //与employees.*相同 </div><div class="t m0 x0 hb y3b51 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3b52 fff5 fs2 fc0 sc0 ls8 ws1">这些方法为JavaScript开发人员提供了访问XML数据的较为熟悉的语法。 </div><div class="t m0 x0 hc y3b53 fff5 fs2 fc0 sc0 ls8 ws1">要删除子元素，可以使用delete操作符，如下所示： </div><div class="t m0 x5 hb y3b54 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3b55 fff6 fs6 fc0 sc0 ls21 wsb">delete employees.employee[0]; </div><div class="t m0 x0 hb y3b56 fff6 fs6 fc0 sc0 ls21 wsb">alert(employees.employee.length());     //1 </div><div class="t m0 x5 hb y3b57 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3b58 fff5 fs2 fc0 sc0 ls8 ws1">显然，这也正是将子节点看成属性的一个主要的优点。 </div><div class="t m0 x0 h20 y3b59 fff3 fs3 fc0 sc0 ls248 ws214">19.2.1 访问特性 </div><div class="t m0 x0 h4 y3b5a fff5 fs2 fc0 sc0 ls8 ws1">访问特性也可以使用点语法，不过其语法稍有扩充。为了区分特性名与子元素的标签名，必须在名</div><div class="t m0 x0 hc y810 fff5 fs2 fc0 sc0 ls8 ws1">称前面加上一个@字符。这是从XPath中借鉴的语法；XPath也是使用@来区分特性和标签的名称。不过，</div><div class="t m0 x0 h5 y3b5b fff5 fs2 fc0 sc0 ls8 ws1">结果可能就是这种语法看起来比较奇怪，例如： </div><div class="t m0 x5 hb y20a0 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3b5c fff6 fs6 fc0 sc0 ls21 wsb">var employees = &lt;employees&gt; </div><div class="t m0 x0 hb y3b5d fff6 fs6 fc0 sc0 ls21 wsb">    &lt;employee position=&quot;Software Engineer&quot;&gt; </div><div class="t m0 x0 hb y3b5e fff6 fs6 fc0 sc0 ls21 wsb">        &lt;name&gt;Nicholas C. Zakas&lt;/name&gt; </div><div class="t m0 x0 hb y3b5f fff6 fs6 fc0 sc0 ls21 wsb">    &lt;/employee&gt; </div><div class="t m0 x0 hb y3b60 fff6 fs6 fc0 sc0 ls21 wsb">    &lt;employee position=&quot;Salesperson&quot;&gt; </div><div class="t m0 x0 hb y3b61 fff6 fs6 fc0 sc0 ls21 wsb">        &lt;name&gt;Jim Smith&lt;/name&gt; </div><div class="t m0 x0 hb y3b62 fff6 fs6 fc0 sc0 ls21 wsb">    &lt;/employee&gt; </div><div class="t m0 x0 hb y3b63 fff6 fs6 fc0 sc0 ls21 wsb">&lt;/employees&gt;; </div><div class="t m0 x0 h28 y3b64 fff6 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y3b65 fff7 fs6 fc0 sc0 ls21 wsb">alert(employees.employee[0].@position); //&quot;Software Engineer&quot; </div><div class="t m0 x2 hf y3b66 fffc fs2 fc0 sc0 ls2b wsb">AttributesExample01.htm </div></div></div>
<div id="pf23a" class="pf w0 h0" data-page-no="23a"><div class="pc pc23a w0 h0"><div class="t m0 x0 h2 y1 ffef fs0 fc0 sc0 ls7 ws0">552  第19章 E4X </div><div class="t m0 x0 h3 y2 ffef fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 fff5 fs2 fc0 sc0 ls8 ws1">与元素一样，每个特性都由一个属性来表示，而且可以通过这种简写语法来访问。以这种语法访问</div><div class="t m0 x0 h1e y4d fff5 fs2 fc0 sc0 ls8 ws1">特性会得到一个表示特性的XML对象，对象的toString()方法始终会返回特性的值。要取得特性的名</div><div class="t m0 x0 hc y5 fff5 fs2 fc0 sc0 ls8 ws1">称，可以使用对象的name()方法。 </div><div class="t m0 x0 h5 yd9 fff5 fs2 fc0 sc0 ls8 ws1">另外，也可以使用child()方法来访问特性，只要传入带有@前缀的特性的名称即可。 </div><div class="t m0 x0 hb ya81 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ya82 fff6 fs6 fc0 sc0 ls21 wsb">alert(employees.employee[0].child(&quot;@position&quot;));     //&quot;Software Engineer&quot; </div><div class="t m0 x0 hb y3b68 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y3b69 fffc fs2 fc0 sc0 ls2b wsb">AttributesExample01.htm </div><div class="t m0 x0 h5 y3b6a fff5 fs2 fc0 sc0 ls8 ws1">由于访问XML对象的属性时也可以使用child()，因此必须使用@字符来区分标签名和特性名。 </div><div class="t m0 x0 hc y3b6b fff5 fs2 fc0 sc0 ls8 ws1">使用attribute()方法并传入特性名，可以只访问XML对象的特性。与 child()方法不同，使</div><div class="t m0 x0 h5 y3b6c fff5 fs2 fc0 sc0 ls43d">用attribute()方法时，不需要传入带@字符的特性名。下面是一个例子。 </div><div class="t m0 x0 hb y3b6d fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3b6e fff6 fs6 fc0 sc0 ls21 wsb">alert(employees.employee[0].attribute(&quot;position&quot;)); //&quot;Software Engineer&quot; </div><div class="t m0 x0 hb y3b6f fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y3b70 fffc fs2 fc0 sc0 ls2b wsb">AttributesExample01.htm </div><div class="t m0 x0 h4 y3560 fff5 fs2 fc0 sc0 ls8 ws1">这三种访问特性的方式同时适用于XML和XMLList类型。对于XML对象来说，会返回一个表示相</div><div class="t m0 x0 h4 y9ec fff5 fs2 fc0 sc0 ls8 ws1">应特性的XML对象；对XMLList 对象来说，会返回一个XMLList对象，其中包含列表中所有元素的</div><div class="t m0 x0 h1e y344d fff5 fs2 fc0 sc0 ls8 ws1">特性XML对象。对于前面的例子而言，employees.employee.@position返回的XMLList将包含两</div><div class="t m0 x0 h1e y9ee fff5 fs2 fc0 sc0 ls8 ws1">个对象：一个对象表示第一个&lt;employee/&gt;元素中的position特性，另一个对象表示第二个元素中</div><div class="t m0 x0 h5 y9ef fff5 fs2 fc0 sc0 ls8 ws1">的同一特性。 </div><div class="t m0 x0 h1e y9f0 fff5 fs2 fc0 sc0 ls8 ws1">要取得XML或XMLList对象中的所有特性，可以使用attributes()方法。这个方法会返回一个</div><div class="t m0 x0 hc y3b71 fff5 fs2 fc0 sc0 ls8 ws1">表示所有特性的XMLList对象。使用这个方法与使用@*的结果相同，如下面的例子所示。 </div><div class="t m0 x0 hb y3496 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y3b72 fff6 fs6 fc0 sc0 ls21">//下面两种方式都会取得所有特性 </div><div class="t m0 x0 hb y3b73 fff6 fs6 fc0 sc0 ls21 wsb">var atts1 = employees.employee[0].@*; </div><div class="t m0 x0 hb y3b74 fff6 fs6 fc0 sc0 ls21 wsb">var atts2 = employees.employee[0].attributes(); </div><div class="t m0 x0 hb y3b75 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1279 fff5 fs2 fc0 sc0 ls3b">在E4X中修改特性的值与修改属性的值一样非常简单，只要像下面这样为特性指定一个新值即可。 </div><div class="t m0 x0 hb y3c0 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y3b76 fff6 fs6 fc0 sc0 ls21 wsb">employees.employee[0].@position = &quot;Author&quot;;        //修改position特性 </div><div class="t m0 x0 hb y3b77 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y7c6 fff5 fs2 fc0 sc0 ls8 ws1">修改的特性会在内部反映出来，换句话说，此后再序列化XML对象，就会使用新的特性值。同样，</div><div class="t m0 x0 h5 y3b78 fff5 fs2 fc0 sc0 ls8 ws1">为特性赋值的语法也可以用来添加新特性，如下面的例子所示。 </div><div class="t m0 x0 hb y189e fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y3b79 fff6 fs6 fc0 sc0 ls21 wsb">employees.employee[0].@experience = &quot;8 years&quot;;     //添加experience特性 </div><div class="t m0 x0 h16 y3b7a fff6 fs6 fc0 sc0 ls21 wsb">employees.employee[0].@manager = &quot;Jim Smith&quot;;      //添加manager特性 </div><div class="t m0 x0 hb y3b7b fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y146e fff5 fs2 fc0 sc0 ls8 ws1">由于特性与其他ECMAScript属性类似，因此也可以使用delete操作符来删除特性，如下所示。 </div><div class="t m0 x0 hb y3b7c fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y3b7d fff6 fs6 fc0 sc0 ls21 wsb">delete employees.employee[0].@position;            //删除 position特性 </div><div class="t m0 x0 hb y3b7e fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3b7f fff5 fs2 fc0 sc0 ls8 ws1">通过属性来访问特性极大地简化了与底层XML结构交互的操作。 </div><div class="t m0 x0 h20 y3b80 fff3 fs3 fc0 sc0 ls248 ws214">19.2.2 其他节点类型 </div><div class="t m0 x0 h5 y3b81 ffef fs2 fc0 sc0 lsd2 ws19b">E4X定义了表现XML文档中所有部分的类型，包括注释和处理指令。在默认情况上，E4X不会解</div><div class="t m0 x0 h4 y18e8 fff5 fs2 fc0 sc0 ls8 ws1">析注释或处理指令，因此这些部分不会出现在最终的对象层次中。如果想让解析器解析这些部分，可以</div><div class="t m0 x0 h5 y3b82 fff5 fs2 fc0 sc0 ls8 ws1">像下面这样设置XML构造函数的下列两个属性。 </div></div></div>
<div id="pf23b" class="pf w0 h0" data-page-no="23b"><div class="pc pc23b w0 h0"><div class="t m0 x2 h2 y1 ffef fs0 fc0 sc0 ls7 ws0">19.2 一般用法    553 </div><div class="t m0 x0 h3 y2 ffef fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d fffb fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e fffb fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f fffb fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 fffb fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 fffb fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 fffb fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 fffb fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 fffb fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 fffb fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 fffb fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 fffb fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 fffb fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce fffb fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y70f fff6 fs6 fc0 sc0 ls21 wsb">XML.ignoreComments = false; </div><div class="t m0 x0 hb y3b83 fff6 fs6 fc0 sc0 ls21 wsb">XML.ignoreProcessingInstructions = false; </div><div class="t m0 x5 hb y3b84 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y2d36 fff5 fs2 fc0 sc0 ls8 ws1">在设置了这两个属性之后，E4X就会将注释和处理指令解析到XML结构中。 </div><div class="t m0 x0 h1e y3b85 fff5 fs2 fc0 sc0 ls8 ws1">由于XML类型可以表示所有节点，因此必须有一种方式来确定节点类型。使用nodeKind()方法可</div><div class="t m0 x0 h1e y2d38 fff5 fs2 fc0 sc0 ls8 ws1">以得到XML对象表示的类型，该访问可能会返回&quot;text&quot;、&quot;element&quot;、&quot;comment&quot;、&quot;processing- </div><div class="t m0 x0 h21 y3b86 fff6 fs1 fc0 sc0 ls9 ws2">instruction&quot;或&quot;attribute&quot;。以下面的XML对象为例。 </div><div class="t m0 x5 hb y3b87 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3b88 fff6 fs6 fc0 sc0 ls21 wsb">var employees = &lt;employees&gt; </div><div class="t m0 x0 h15 y3b89 fff7 fs6 fc0 sc0 ls21 wsb">    &lt;?Dont forget the donuts?&gt; </div><div class="t m0 x0 hb y3b8a fff6 fs6 fc0 sc0 ls21 wsb">    &lt;employee position=&quot;Software Engineer&quot;&gt; </div><div class="t m0 x0 hb y3b8b fff6 fs6 fc0 sc0 ls21 wsb">        &lt;name&gt;Nicholas C. Zakas&lt;/name&gt; </div><div class="t m0 x0 hb y3b8c fff6 fs6 fc0 sc0 ls21 wsb">    &lt;/employee&gt; </div><div class="t m0 x0 h15 y3b8d fff7 fs6 fc0 sc0 ls21 wsb">    &lt;!--just added--&gt; </div><div class="t m0 x0 hb y3b8e fff6 fs6 fc0 sc0 ls21 wsb">    &lt;employee position=&quot;Salesperson&quot;&gt; </div><div class="t m0 x0 hb y3b8f fff6 fs6 fc0 sc0 ls21 wsb">        &lt;name&gt;Jim Smith&lt;/name&gt; </div><div class="t m0 x0 hb y3b90 fff6 fs6 fc0 sc0 ls21 wsb">    &lt;/employee&gt; </div><div class="t m0 x0 hb y3b91 fff6 fs6 fc0 sc0 ls21 wsb">&lt;/employees&gt; ; </div><div class="t m0 x5 hb y3b92 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3b93 fff5 fs2 fc0 sc0 ls8 ws1">我们可以通过下面的表格来说明nodeKind()返回的节点类型。 </div><div class="t m0 x5 hb y385e fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x1 h31 y3b94 fff2 fs6 fc0 sc0 lsa7 wsb">语  句  返 回 值 </div><div class="t m0 x5 h32 y3b95 fff6 fsc fc0 sc0 ls238 ws3ba">employees.nodeKind() &quot;element&quot; </div><div class="t m0 x5 h32 y2a82 fff6 fsc fc0 sc0 ls238 ws3bb">employees.*[0].nodeKind() &quot;processing-instruction&quot; </div><div class="t m0 x5 h32 y3b96 fff6 fsc fc0 sc0 ls238 ws3bc">employees.employee[0].@position.nodeKind() &quot;attribute&quot; </div><div class="t m0 x5 h32 y1b7e fff6 fsc fc0 sc0 ls238 ws3bd">employees.employee[0].nodeKind() &quot;element&quot; </div><div class="t m0 x5 h32 y6a1 fff6 fsc fc0 sc0 ls238 ws3bb">employees.*[2].nodeKind() &quot;comment&quot; </div><div class="t m0 x5 h32 y2752 fff6 fsc fc0 sc0 ls238 ws3bc">employees.employee[0].name.*[0].nodeKind() &quot;text&quot; </div><div class="t m0 x5 hb y38f3 fff6 fs6 fc0 sc0 ls8 wsb">   </div><div class="t m0 x0 h5 y3b97 fff5 fs2 fc0 sc0 ls8 ws1">不能在包含多个XML对象的XMLList上调用 nodeKind()方法；否则，会抛出一个错误。 </div><div class="t m0 x0 h5 y3b98 fff5 fs2 fc0 sc0 ls8 ws1">可以只取得特定类型的节点，而这就要用到下列方法。 </div><div class="t m0 x0 h5 y3b99 fff4 fs1 fc0 sc0 ls2"> attributes()：返回XML对象的所有特性。 </div><div class="t m0 x0 h5 y3b9a fff4 fs1 fc0 sc0 ls2"> comments()：返回XML对象的所有子注释节点。 </div><div class="t m0 x0 h4 y77a fff4 fs1 fc0 sc0 ls2"> elements(tagName)：返回XML对象的所有子元素。可以通过提供元素的tagName（标签名）</div><div class="t m0 x5 h5 y77b fff5 fs2 fc0 sc0 ls8 ws1">来过滤想要返回的结果。 </div><div class="t m0 x0 h4 y1e6 fff4 fs1 fc0 sc0 ls2"> processingInstructions(name)：返回XML对象的所有处理指令。可以通过提供处理指令</div><div class="t m0 x5 hc y3b9b fff5 fs2 fc0 sc0 ls2ca">的name（名称）来过滤想要返回的结果。 </div><div class="t m0 x0 h5 y77d fff4 fs1 fc0 sc0 ls2"> text()：返回XML对象的所有文本子节点。 </div><div class="t m0 x0 hc y77e fff5 fs2 fc0 sc0 ls8 ws1">上述的每一个方法都返回一个包含适当XML对象的XMLList。 </div><div class="t m0 x0 h4 y3b9c fff5 fs2 fc0 sc0 ls8 ws1">使用hasSimpleContent()和hasComplexContent()方法，可以确定XML对象中是只包含文本，</div><div class="t m0 x0 h1e y3b9d fff5 fs2 fc0 sc0 ls8 ws1">还是包含更复杂的内容。如果XML对象中只包含子文本节点，则前一个方法会返回true；如果XML 对</div><div class="t m0 x0 hc y3b9e fff5 fs2 fc0 sc0 ls8 ws1">象的子节点中有任何非文本节点，则后一个方法返回true。来看下面的例子。 </div><div class="t m0 x5 hb y3b9f fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3ba0 fff6 fs6 fc0 sc0 ls21 wsb">alert(employees.employee[0].hasComplexContent());        //true </div><div class="t m0 x0 hb y3ba1 fff6 fs6 fc0 sc0 ls21 wsb">alert(employees.employee[0].hasSimpleContent());         //false </div><div class="t m0 x0 hb y3ba2 fff6 fs6 fc0 sc0 ls21 wsb">alert(employees.employee[0].name.hasComplexContent());      //false </div><div class="t m0 x0 hb y3ba3 fff6 fs6 fc0 sc0 ls21 wsb">alert(employees.employee[0].name.hasSimpleContent());      //true </div><div class="t m0 x5 hb y3ba4 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3ba5 fff5 fs2 fc0 sc0 ls8 ws1">利用这些方法，以及前面提到的其他方法，可以极大地方便查找XML结构中的数据。 </div><div class="t m0 x0 h20 y3ba6 fff3 fs3 fc0 sc0 ls248 ws214">19.2.3 查询 </div><div class="t m0 x0 h5 y1310 fff5 fs2 fc0 sc0 ls8 ws1">实际上，E4X提供的查询语法在很多方面都与XPath类似。取得元素或特性值的简单操作是最基本</div></div></div>
<div id="pf23c" class="pf w0 h0" data-page-no="23c"><div class="pc pc23c w0 h0"><div class="t m0 x0 h2 y1 ffef fs0 fc0 sc0 ls7 ws0">554  第19章 E4X </div><div class="t m0 x0 h3 y2 ffef fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 fff5 fs2 fc0 sc0 ls8 ws1">的查询。在查询之前，不会创建表现XML文档结构中不同部分的XML对象。从底层来看，XML和XMLList</div><div class="t m0 x0 h4 y4 fff5 fs2 fc0 sc0 ls30 ws2a">的所有属性事实上都是查询的结果。也就是说，引用不表现XML结构中某一部分的属性仍然会返回</div><div class="t m0 x0 h4 y4e fff6 fs1 fc0 sc0 ls9 ws2">XMLList；只不过这个XMLList中什么也不会包含。例如，如果基于前面的XML示例执行下列代码，</div><div class="t m0 x0 h5 yd9 fff5 fs2 fc0 sc0 ls8 ws1">则返回的结果就是空的。 </div><div class="t m0 x0 hb ya81 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ya82 fff6 fs6 fc0 sc0 ls21 wsb">var cats = employees.cat; </div><div class="t m0 x0 hb ya83 fff6 fs6 fc0 sc0 ls21 wsb">alert(cats.length());     //0 </div><div class="t m0 x0 hb ya84 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf yd44 fffc fs2 fc0 sc0 ls2b wsb">QueryingExample01.htm </div><div class="t m0 x0 h4 y3977 fff5 fs2 fc0 sc0 ls8 ws1">这个查询想要查找&lt;employees/&gt;中的&lt;cat/&gt;元素，但这个元素并不存在。上面的第一行代码会返</div><div class="t m0 x0 hc y3ba7 fff5 fs2 fc0 sc0 ls8 ws1">回一个空的XMLList对象。虽然返回的是空对象，但查询可以照常进行，而不会发生异常。 </div><div class="t m0 x0 h4 y3ba8 fff5 fs2 fc0 sc0 ls8 ws1">前面我们看到的大多数例子都使用点语法来访问直接的子节点。而像下面这样使用两个点，则可以</div><div class="t m0 x0 h5 y3ba9 fff5 fs2 fc0 sc0 ls8 ws1">进一步扩展查询的深度，查询到所有后代节点。 </div><div class="t m0 x0 hb y84f fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y3baa fff6 fs6 fc0 sc0 ls21 wsb">var allDescendants = employees..*;         //取得&lt;employees/&gt;的所有后代节点 </div><div class="t m0 x0 hb y3bab fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3bac fff5 fs2 fc0 sc0 ls8 ws1">上面的代码会返回&lt;employees/&gt;元素的所有后代节点。结果中将会包含元素、文本、注释和处理</div><div class="t m0 x0 h1e y3bad fff5 fs2 fc0 sc0 ls8 ws1">指令，最后两种节点的有无取决于在XML构造函数上的设置（前面曾经讨论过）；但结果中不会包含特</div><div class="t m0 x0 h5 y3bae fff5 fs2 fc0 sc0 ls8 ws1">性。要想取得特定标签的元素，需要将星号替换成实际的标签名。 </div><div class="t m0 x0 hb y3baf fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y3bb0 fff6 fs6 fc0 sc0 ls21 wsb">var allNames = employees..name;     //取得作为&lt;employees/&gt;后代的所有&lt;name/&gt;节点 </div><div class="t m0 x0 hb y3bb1 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1ca5 fff5 fs2 fc0 sc0 ls5 ws4">同样的查询可以使用descendants()方法来完成。在不给这个方法传递参数的情况下，它会返回</div><div class="t m0 x0 h1e y30f3 fff5 fs2 fc0 sc0 ls5 ws4">所有后代节点（与使用..*相同），而传递一个名称作为参数则可以限制结果。下面就是这两种情况的</div><div class="t m0 x0 h5 y3bb2 fff5 fs2 fc0 sc0 ls5">例子。 </div><div class="t m0 x0 hb y3bb3 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y3bb4 fff6 fs6 fc0 sc0 ls21 wsb">var allDescendants = employees.descendants();     //所有后代节点 </div><div class="t m0 x0 h16 y3bb5 fff6 fs6 fc0 sc0 ls21 wsb">var allNames = employees.descendants(&quot;name&quot;);     //后代中的所有&lt;name/&gt;元素 </div><div class="t m0 x0 hb y3bb6 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3bb7 fff5 fs2 fc0 sc0 ls8 ws1">还可以取得所有后代元素中的所有特性，方法是使用下列任何一行代码。 </div><div class="t m0 x0 hb y119e fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y3bb8 fff6 fs6 fc0 sc0 ls21 wsb">var allAttributes = employees..@*;     //取得所有后代元素中的所有特性 </div><div class="t m0 x0 h16 y3bb9 fff6 fs6 fc0 sc0 ls21 wsb">var allAttributes2 = employees.descendants(&quot;@*&quot;);     //同上 </div><div class="t m0 x0 hb y3bba fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1d0d fff5 fs2 fc0 sc0 ls8 ws1">与限制结果中的后代元素一样，也可以通过用完整的特性名来替换星号达到过滤特性的目的。例如： </div><div class="t m0 x0 hb y3bbb fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y3bbc fff6 fs6 fc0 sc0 ls21 wsb">var allAttributes = employees..@position;         //取得所有position特性 </div><div class="t m0 x0 h16 y3bbd fff6 fs6 fc0 sc0 ls21 wsb">var allAttributes2 = employees.descendants(&quot;@position&quot;);     //同上 </div><div class="t m0 x0 hb y3bbe fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3bbf fff5 fs2 fc0 sc0 ls221 ws1d9">除了访问后代元素之外，还可以指定查询的条件。例如，要想返回position特性值为</div><div class="t m0 x0 h5 y3bc0 fff6 fs1 fc0 sc0 ls9 ws2">&quot;Salesperson&quot;的所有&lt;employee/&gt;元素，可以使用下面的查询： </div><div class="t m0 x0 hb y3bc1 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3bc2 fff6 fs6 fc0 sc0 ls21 wsb">var salespeople = employees.employee.(@position == &quot;Salesperson&quot;); </div><div class="t m0 x0 hb y3bc3 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3bc4 fff5 fs2 fc0 sc0 ls8 ws1">同样的语法也可以用于修改XML结构中的某一部分。例如，可以将第一位销售员（salesperson）</div><div class="t m0 x0 hc y3bc5 fff5 fs2 fc0 sc0 ls43e">的position特性修改为&quot;Senior Salesperson&quot;，代码如下： </div><div class="t m0 x0 hb y3bc6 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3bc7 fff6 fs6 fc0 sc0 ls21 wsb">employees.employee.(@position == &quot;Salesperson&quot;)[0].@position= &quot;Senior Salesperson&quot;; </div><div class="t m0 x0 hb y3bc8 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y2aa9 fff5 fs2 fc0 sc0 ls8 ws1">注意，圆括号中的表达式会返回一个包含结果的XMLList，而方括号返回其中的第一项，然后我们</div><div class="t m0 x0 hc y2aaa fff5 fs2 fc0 sc0 ls8 ws1">重写了@position属性的值。 </div></div></div>
<div id="pf23d" class="pf w0 h0" data-page-no="23d"><div class="pc pc23d w0 h0"><div class="t m0 x2 h2 y1 ffef fs0 fc0 sc0 ls7 ws0">19.2 一般用法    555 </div><div class="t m0 x0 h3 y2 ffef fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d fffb fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e fffb fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f fffb fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 fffb fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 fffb fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 fffb fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 fffb fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 fffb fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 fffb fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 fffb fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 fffb fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 fffb fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce fffb fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 fff5 fs2 fc0 sc0 ls8 ws1">使用parent()方法能够在XML结构中上溯，这个方法会返回一个XML对象，表示当前 XML对象</div><div class="t m0 x0 h1e y4d fff5 fs2 fc0 sc0 ls8 ws1">的父元素。如果在XMLList上调用parent()方法，则会返回列表中所有对象的公共父元素。下面是</div><div class="t m0 x0 h5 y5 fff5 fs2 fc0 sc0 ls8 ws1">一个例子。 </div><div class="t m0 x5 hb y4f fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y50 fff6 fs6 fc0 sc0 ls21 wsb">var employees2 = employees.employee.parent(); </div><div class="t m0 x5 hb y3bc9 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3ad7 fff5 fs2 fc0 sc0 ls8 ws1">这里，变量employees2中包含着与变量employees相同的值。在处理来源未知的 XML对象时，</div><div class="t m0 x0 hc y3bca fff5 fs2 fc0 sc0 ls8 ws1">经常会用到parent()方法。 </div><div class="t m0 x0 h20 y3bcb fff3 fs3 fc0 sc0 ls248 ws214">19.2.4 构建和操作XML </div><div class="t m0 x0 h5 y32cd fff5 fs2 fc0 sc0 lscd">将XML数据转换成XML对象的方式有很多种。前面曾经讨论过，可以将XML 字符串传递到XML</div><div class="t m0 x0 h4 y3bcc fff5 fs2 fc0 sc0 ls8 ws1">构造函数中，也可以使用XML字面量。相对而言，XML字面量方式更方便一些，因为可以在字面量中嵌</div><div class="t m0 x0 hc y3bcd fff5 fs2 fc0 sc0 ls3b">入JavaScript变量，语法是使用花括号（{}）。可以将JavaScript变量嵌入到字面量中的任意位置上，如</div><div class="t m0 x0 h5 y3bce fff5 fs2 fc0 sc0 ls8 ws1">下面的例子所示。 </div><div class="t m0 x5 hb y131a fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3bcf fff6 fs6 fc0 sc0 ls21 wsb">var tagName = &quot;color&quot;; </div><div class="t m0 x0 hb y3bd0 fff6 fs6 fc0 sc0 ls21 wsb">var color = &quot;red&quot;; </div><div class="t m0 x0 hb y3bd1 fff6 fs6 fc0 sc0 ls21 wsb">var xml = &lt;{tagName}&gt;{color}&lt;/{tagName}&gt;; </div><div class="t m0 x0 hb y3bd2 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3bd3 fff6 fs6 fc0 sc0 ls21 wsb">alert(xml.toXMLString());     //&quot;&lt;color&gt;red&lt;/color&gt; </div><div class="t m0 x5 hb y3bd4 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y3bd5 fffc fs2 fc0 sc0 ls2b wsb">XMLConstructionExample01.htm </div><div class="t m0 x0 h4 y203 fff5 fs2 fc0 sc0 ls8 ws1">在这个例子中，XML字面量的标签名和文本值都是使用花括号语法插入的。有了这个语法，就可以</div><div class="t m0 x0 h5 y3bd6 fff5 fs2 fc0 sc0 ls8 ws1">省去在构建XML结构时拼接字符串的麻烦。 </div><div class="t m0 x0 h5 y3bd7 ffef fs2 fc0 sc0 lsd2 ws19b">E4X也支持使用标准的JavaScript语法来构建完整的 XML结构。如前所述，大多数必要的操作都</div><div class="t m0 x0 h4 y3bd8 fff5 fs2 fc0 sc0 ls8 ws1">是查询，而且即便元素或特性不存在也不会抛出错误。在此基础上更进一步，如果将一个值指定给一个</div><div class="t m0 x0 h5 y3bd9 fff5 fs2 fc0 sc0 ls8 ws1">不存在的元素或特性，E4X就会首先在底层创建相应的结构，然后完成赋值。来看下面的例子。 </div><div class="t m0 x5 hb y3bda fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3bdb fff6 fs6 fc0 sc0 ls21 wsb">var employees = &lt;employees/&gt;; </div><div class="t m0 x0 hb y3bdc fff6 fs6 fc0 sc0 ls21 wsb">employees.employee.name = &quot;Nicholas C. Zakas&quot;; </div><div class="t m0 x0 hb y3bdd fff6 fs6 fc0 sc0 ls21 wsb">employees.employee.@position = &quot;Software Engineer&quot;; </div><div class="t m0 x5 hb y3bde fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y3bdf fffc fs2 fc0 sc0 ls2b wsb">XMLConstructionExample02.htm </div><div class="t m0 x0 h5 y3be0 fff5 fs2 fc0 sc0 ls8 ws1">这个例子一开始声明了&lt;employees/&gt;元素，然后在这个元素基础上开始构建XML结构。第二行</div><div class="t m0 x0 h1e y3be1 fff5 fs2 fc0 sc0 ls8 ws1">代码在&lt;employees/&gt;中创建了一个&lt;employee/&gt;元素和一个&lt;name/&gt;元素，并指定了文本值。第三行</div><div class="t m0 x0 hc y3a31 fff5 fs2 fc0 sc0 ls8 ws1">代码添加了一个position特性并为该特性指定了值。此时构建的XML结构如下所示。 </div><div class="t m0 x5 hb y287f fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3be2 fff6 fs6 fc0 sc0 ls21 wsb">&lt;employees&gt; </div><div class="t m0 x0 hb y3be3 fff6 fs6 fc0 sc0 ls21 wsb">    &lt;employee position=&quot;Software Engineer&quot;&gt; </div><div class="t m0 x0 hb y3be4 fff6 fs6 fc0 sc0 ls21 wsb">        &lt;name&gt;Nicholas C. Zakas&lt;/name&gt; </div><div class="t m0 x0 hb y3be5 fff6 fs6 fc0 sc0 ls21 wsb">    &lt;/employee&gt; </div><div class="t m0 x0 hb y3be6 fff6 fs6 fc0 sc0 ls21 wsb">&lt;/employees&gt; </div><div class="t m0 x5 hb y3be7 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3be8 fff5 fs2 fc0 sc0 ls8 ws1">当然，使用加号操作符也可以再添加一个&lt;employee/&gt;元素，如下所示。 </div><div class="t m0 x5 hb y2af fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3be9 fff6 fs6 fc0 sc0 ls21 wsb">employees.employee += &lt;employee position=&quot;Salesperson&quot;&gt; </div><div class="t m0 x0 hb y3bea fff6 fs6 fc0 sc0 ls21 wsb">                          &lt;name&gt;Jim Smith&lt;/name&gt; </div><div class="t m0 x0 hb y3beb fff6 fs6 fc0 sc0 ls21 wsb">                      &lt;/employee&gt;; </div><div class="t m0 x2 hf y17cc fffc fs2 fc0 sc0 ls2b wsb">XMLConstructionExample02.htm </div></div></div>
<div id="pf23e" class="pf w0 h0" data-page-no="23e"><div class="pc pc23e w0 h0"><div class="t m0 x0 h2 y1 ffef fs0 fc0 sc0 ls7 ws0">556  第19章 E4X </div><div class="t m0 x0 h3 y2 ffef fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 fff5 fs2 fc0 sc0 ls8 ws1">最终构建的XML结构如下所示： </div><div class="t m0 x0 hb yfb2 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yfb3 fff6 fs6 fc0 sc0 ls21 wsb">&lt;employees&gt; </div><div class="t m0 x0 hb yfb4 fff6 fs6 fc0 sc0 ls21 wsb">    &lt;employee position=&quot;Software Engineer&quot;&gt; </div><div class="t m0 x0 hb yfb5 fff6 fs6 fc0 sc0 ls21 wsb">        &lt;name&gt;Nicholas C. Zakas&lt;/name&gt; </div><div class="t m0 x0 hb yfb6 fff6 fs6 fc0 sc0 ls21 wsb">    &lt;/employee&gt; </div><div class="t m0 x0 hb yfb7 fff6 fs6 fc0 sc0 ls21 wsb">    &lt;employee position=&quot;Salesperson&quot;&gt; </div><div class="t m0 x0 hb yfb8 fff6 fs6 fc0 sc0 ls21 wsb">        &lt;name&gt;Jim Smith&lt;/name&gt; </div><div class="t m0 x0 hb yfb9 fff6 fs6 fc0 sc0 ls21 wsb">    &lt;/employee&gt; </div><div class="t m0 x0 hb yfba fff6 fs6 fc0 sc0 ls21 wsb">&lt;/employees&gt; </div><div class="t m0 x0 hb y3bec fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3bed fff5 fs2 fc0 sc0 ls8 ws1">除了上面介绍的基本的XML构建语法之外，还有一些类似DOM的方法，简介如下。 </div><div class="t m0 x0 h5 yfbc fff4 fs1 fc0 sc0 ls2"> appendChild(child)：将给定的child作为子节点添加到XMLList的末尾。 </div><div class="t m0 x0 h5 y35c7 fff4 fs1 fc0 sc0 ls2"> copy()：返回XML对象副本。 </div><div class="t m0 x0 h5 y288c fff4 fs1 fc0 sc0 ls8 ws134"> insertChildAfter(refNode, child)：将child作为子节点插入到XMLList中refNode的后面。 </div><div class="t m0 x0 h5 y3bee fff4 fs1 fc0 sc0 ls8 ws134"> insertChildBefore(refNode, child)：将child作为子节点插入到XMLList中refNode的前面。 </div><div class="t m0 x0 h5 y3bef fff4 fs1 fc0 sc0 ls2"> prependChild(child)：将给定的child作为子节点添加到XMLList的开始位置。 </div><div class="t m0 x0 h4 y3bf0 fff4 fs1 fc0 sc0 ls2"> replace(propertyName, value)：用value值替换名为propertyName的属性，这个属性</div><div class="t m0 x0 h5 y3bf1 fff5 fs2 fc0 sc0 ls8 ws1">可能是一个元素，也可能是一个特性。 </div><div class="t m0 x0 h5 y3bf2 fff4 fs1 fc0 sc0 ls2"> setChildren(children)：用children替换当前所有的子元素，children可以是XML对</div><div class="t m0 x0 hc y3bf3 fff5 fs2 fc0 sc0 ls8 ws1">象，也可是XMLList对象。 </div><div class="t m0 x0 h5 y3bf4 fff5 fs2 fc0 sc0 ls8 ws1">这些方法既非常有用，也非常容易使用。下列代码展示了这些方法的用途。 </div><div class="t m0 x0 hb y3bf5 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3bf6 fff6 fs6 fc0 sc0 ls21 wsb">var employees = &lt;employees&gt; </div><div class="t m0 x0 hb y3bf7 fff6 fs6 fc0 sc0 ls21 wsb">    &lt;employee position=&quot;Software Engineer&quot;&gt; </div><div class="t m0 x0 hb y3bf8 fff6 fs6 fc0 sc0 ls21 wsb">        &lt;name&gt;Nicholas C. Zakas&lt;/name&gt; </div><div class="t m0 x0 hb y3bf9 fff6 fs6 fc0 sc0 ls21 wsb">    &lt;/employee&gt; </div><div class="t m0 x0 hb y3bfa fff6 fs6 fc0 sc0 ls21 wsb">    &lt;employee position=&quot;Salesperson&quot;&gt; </div><div class="t m0 x0 hb y3bfb fff6 fs6 fc0 sc0 ls21 wsb">        &lt;name&gt;Jim Smith&lt;/name&gt; </div><div class="t m0 x0 hb y3bfc fff6 fs6 fc0 sc0 ls21 wsb">    &lt;/employee&gt; </div><div class="t m0 x0 hb y3bfd fff6 fs6 fc0 sc0 ls21 wsb">&lt;/employees&gt;; </div><div class="t m0 x0 hb y3bfe fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y3bff fff7 fs6 fc0 sc0 ls21 wsb">employees.appendChild(&lt;employee position=&quot;Vice President&quot;&gt; </div><div class="t m0 x0 h15 y3c00 fff7 fs6 fc0 sc0 ls21 wsb">                      &lt;name&gt;Benjamin Anderson&lt;/name&gt; </div><div class="t m0 x0 h15 y3c01 fff7 fs6 fc0 sc0 ls21 wsb">                  &lt;/employee&gt;); </div><div class="t m0 x0 h15 y3c02 fff7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y3c03 fff7 fs6 fc0 sc0 ls21 wsb">employees.prependChild(&lt;employee position=&quot;User Interface Designer&quot;&gt; </div><div class="t m0 x0 h15 y3c04 fff7 fs6 fc0 sc0 ls21 wsb">                       &lt;name&gt;Michael Johnson&lt;/name&gt; </div><div class="t m0 x0 h15 y3c05 fff7 fs6 fc0 sc0 ls21 wsb">                   &lt;/employee&gt;); </div><div class="t m0 x0 h15 y3c06 fff7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y3c07 fff7 fs6 fc0 sc0 ls21 wsb">employees.insertChildBefore(employees.child(2),  </div><div class="t m0 x0 h15 y3c08 fff7 fs6 fc0 sc0 ls21 wsb">                           &lt;employee position=&quot;Human Resources Manager&quot;&gt; </div><div class="t m0 x0 h15 y3c09 fff7 fs6 fc0 sc0 ls21 wsb">                               &lt;name&gt;Margaret Jones&lt;/name&gt; </div><div class="t m0 x0 h15 y3c0a fff7 fs6 fc0 sc0 ls21 wsb">                           &lt;/employee&gt;); </div><div class="t m0 x0 h15 y3c0b fff7 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y3c0c fff7 fs6 fc0 sc0 ls21 wsb">employees.setChildren(&lt;employee position=&quot;President&quot;&gt; </div><div class="t m0 x0 h15 y3c0d fff7 fs6 fc0 sc0 ls21 wsb">                           &lt;name&gt;Richard McMichael&lt;/name&gt; </div><div class="t m0 x0 h15 y3c0e fff7 fs6 fc0 sc0 ls21 wsb">                      &lt;/employee&gt; + </div><div class="t m0 x0 h15 y3c0f fff7 fs6 fc0 sc0 ls21 wsb">                      &lt;employee position=&quot;Vice President&quot;&gt; </div><div class="t m0 x0 h15 y3c10 fff7 fs6 fc0 sc0 ls21 wsb">                          &lt;name&gt;Rebecca Smith&lt;/name&gt; </div><div class="t m0 x0 h15 y3c11 fff7 fs6 fc0 sc0 ls21 wsb">                      &lt;/employee&gt;); </div><div class="t m0 x0 hb y3c12 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y33c7 fffc fs2 fc0 sc0 ls1b wsb">XMLConstructionExample03.htm </div></div></div>
<div id="pf23f" class="pf w0 h0" data-page-no="23f"><div class="pc pc23f w0 h0"><div class="t m0 x2 h2 y1 ffef fs0 fc0 sc0 ls7 ws0">19.2 一般用法    557 </div><div class="t m0 x0 h3 y2 ffef fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d fffb fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e fffb fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f fffb fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 fffb fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 fffb fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 fffb fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 fffb fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 fffb fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 fffb fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 fffb fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 fffb fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 fffb fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce fffb fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 fff5 fs2 fc0 sc0 ls8 ws1">以上代码首先在员工列表的底部添加了一个名为Benjamin Anderson的副总统（vice president）。然</div><div class="t m0 x0 h5 y4d fff5 fs2 fc0 sc0 ls8 ws1">后，在员工列表顶部又添加了一个名为Michael Johnson的界面设计师。接着，在列表中位置为2的员 </div><div class="t m0 x0 h5 yd8 fff5 fs2 fc0 sc0 ls8 ws1">工——此时这个员工是Jim Smith，因为他前面还有Michael Johnson和Nicholas C. Zakas——之前又添加</div><div class="t m0 x0 h5 y28b fff5 fs2 fc0 sc0 ls8 ws1">了一个名为Margaret Jones的人力资源部经理。最后，所有这些子元素都被总统Richard McMichael和副</div><div class="t m0 x0 h5 yfdb fff5 fs2 fc0 sc0 ls8 ws1">总统Rebecca Smith替代。结果XML如下所示。 </div><div class="t m0 x5 hb y4ef fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1c4f fff6 fs6 fc0 sc0 ls21 wsb">&lt;employees&gt; </div><div class="t m0 x0 hb y1c50 fff6 fs6 fc0 sc0 ls21 wsb">    &lt;employee position=&quot;President&quot;&gt; </div><div class="t m0 x0 hb y1c51 fff6 fs6 fc0 sc0 ls21 wsb">    &lt;name&gt;Richard McMichael&lt;/name&gt; </div><div class="t m0 x0 hb y1c52 fff6 fs6 fc0 sc0 ls21 wsb">    &lt;/employee&gt; </div><div class="t m0 x0 hb y1c53 fff6 fs6 fc0 sc0 ls21 wsb">    &lt;employee position=&quot;Vice President&quot;&gt; </div><div class="t m0 x0 hb y1c54 fff6 fs6 fc0 sc0 ls21 wsb">        &lt;name&gt;Rebecca Smith&lt;/name&gt; </div><div class="t m0 x0 hb y3c13 fff6 fs6 fc0 sc0 ls21 wsb">    &lt;/employee&gt; </div><div class="t m0 x0 hb y3c14 fff6 fs6 fc0 sc0 ls21 wsb">&lt;/employees&gt; </div><div class="t m0 x5 hb y3c15 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1596 fff5 fs2 fc0 sc0 ls8 ws1">熟练运用这些技术和方法，就能够使用E4X执行任何DOM风格的操作。 </div><div class="t m0 x0 h20 ye4 fff3 fs3 fc0 sc0 ls248 ws214">19.2.5 解析和序列化 </div><div class="t m0 x0 h5 y3c16 ffef fs2 fc0 sc0 lsd2 ws19b">E4X将解析和序列化数据的控制放在了XML构造函数的一些设置当中。与XML解析相关的设置有</div><div class="t m0 x0 h5 y3c17 fff5 fs2 fc0 sc0 ls8 ws1">如下三个。 </div><div class="t m0 x0 h5 y2325 fff4 fs1 fc0 sc0 ls2"> ignoreComments：表示解析器应该忽略标记中的注释。默认设置为true。 </div><div class="t m0 x0 h5 y3c18 fff4 fs1 fc0 sc0 ls8 ws134"> ignoreProcessingInstructions：表示解析器应该忽略标记中的处理指令。默认设置为true。 </div><div class="t m0 x0 h4 y3c19 fff4 fs1 fc0 sc0 ls2"> ignoreWhitespace：表示解析器应该忽略元素间的空格，而不是创建表现这些空格的文本节</div><div class="t m0 x5 hc y3c1a fff5 fs2 fc0 sc0 ls8 ws1">点。默认设置为true。 </div><div class="t m0 x0 hc y3c1b fff5 fs2 fc0 sc0 ls8 ws1">这三个设置会影响对传入到XML构造函数中的字符串以及XML字面量的解析。 </div><div class="t m0 x0 h5 y4da fff5 fs2 fc0 sc0 ls8 ws1">另外，与XML数据序列化相关的设置有如下两个。 </div><div class="t m0 x0 h5 y287b fff4 fs1 fc0 sc0 ls2"> prettyIndent：表示在序列化XML时，每次缩进的空格数量。默认值为2。 </div><div class="t m0 x0 h5 y342 fff4 fs1 fc0 sc0 ls2"> prettyPrinting：表示应该以方便人类认读的方式输出XML，即每个元素重起一行，而且子</div><div class="t m0 x5 hc y3c1c fff5 fs2 fc0 sc0 ls8 ws1">元素都要缩进。默认设置为true。 </div><div class="t m0 x0 hc y3c1d fff5 fs2 fc0 sc0 ls8 ws1">这两个设置将影响到toString()和toXMLString()的输出。 </div><div class="t m0 x0 h1e y3c1e fff5 fs2 fc0 sc0 ls8 ws1">以上五个设置都保存在settings对象中，通过XML构造函数的settings()方法可以取得这个对</div><div class="t m0 x0 h5 y3c1f fff5 fs2 fc0 sc0 ls8 ws1">象，如下所示。 </div><div class="t m0 x5 hb y2e45 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3c20 fff6 fs6 fc0 sc0 ls21 wsb">var settings = XML.settings(); </div><div class="t m0 x0 hb y3c21 fff6 fs6 fc0 sc0 ls21 wsb">alert(settings.ignoreWhitespace);     //true </div><div class="t m0 x0 hb y3c22 fff6 fs6 fc0 sc0 ls21 wsb">alert(settings.ignoreComments);       //true </div><div class="t m0 x0 hb y3c23 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf y3c24 fffc fs2 fc0 sc0 ls5e wsb">ParsingAndSerializationExample01.htm </div><div class="t m0 x0 h5 y3c25 fff5 fs2 fc0 sc0 ls8 ws1">通过向setSettings()方法中传入包含全部5项设置的对象，可以一次性指定所有设置。在需要</div><div class="t m0 x0 h5 y3c26 fff5 fs2 fc0 sc0 ls8 ws1">临时改变设置的情况下，这种设置方式非常有用，如下所示。 </div><div class="t m0 x0 hb y3c27 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3c28 fff6 fs6 fc0 sc0 ls21 wsb">var settings = XML.settings(); </div><div class="t m0 x0 hb y3c29 fff6 fs6 fc0 sc0 ls21 wsb">XML.prettyIndent = 8; </div><div class="t m0 x0 hb y3c2a fff6 fs6 fc0 sc0 ls21 wsb">XML.ignoreComments = false; </div><div class="t m0 x0 hb y3c2b fff6 fs6 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf240" class="pf w0 h0" data-page-no="240"><div class="pc pc240 w0 h0"><div class="t m0 x0 h2 y1 ffef fs0 fc0 sc0 ls7 ws0">558  第19章 E4X </div><div class="t m0 x0 h3 y2 ffef fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y8f5 fff6 fs6 fc0 sc0 ls21">//执行某些处理 </div><div class="t m0 x0 hb y3c2c fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y3c2d fff6 fs6 fc0 sc0 ls21 wsb">XML.setSettings(settings);     //重置前面的设置 </div><div class="t m0 x0 hb y3c2e fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3c2f fff5 fs2 fc0 sc0 ls8 ws1">而使用defaultSettings()方法则可以取得一个包含默认设置的对象，因此任何时候都可以使用</div><div class="t m0 x0 h5 y3c30 fff5 fs2 fc0 sc0 ls8 ws1">下面的代码重置设置。 </div><div class="t m0 x0 hb y3c31 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3c32 fff6 fs6 fc0 sc0 ls21 wsb">XML.setSettings(XML.defaultSettings()); </div><div class="t m0 x0 h20 y3c33 fff3 fs3 fc0 sc0 ls248 ws214">19.2.6 命名空间 </div><div class="t m0 x0 h5 y3c34 ffef fs2 fc0 sc0 lsd2 ws19b">E4X提供了方便使用命名空间的特性。前面曾经讨论过，使用namspace()方法可以取得与特定前</div><div class="t m0 x0 h1e y3c35 fff5 fs2 fc0 sc0 ls8 ws1">缀对应的Namespace对象。而通过使用setNamespace()并传入Namespace 对象，也可以为给定元</div><div class="t m0 x0 h5 y3c36 fff5 fs2 fc0 sc0 ls8 ws1">素设置命名空间。来看下面的例子。 </div><div class="t m0 x0 hb y1aaa fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3c37 fff6 fs6 fc0 sc0 ls21 wsb">var messages = &lt;messages&gt; </div><div class="t m0 x0 hb y3c38 fff6 fs6 fc0 sc0 ls21 wsb">    &lt;message&gt;Hello world!&lt;/message&gt; </div><div class="t m0 x0 hb y3c39 fff6 fs6 fc0 sc0 ls21 wsb">&lt;/messages&gt;; </div><div class="t m0 x0 hb y3c3a fff6 fs6 fc0 sc0 ls21 wsb">messages.setNamespace(new Namespace(&quot;wrox&quot;, &quot;http://www.wrox.com/&quot;)); </div><div class="t m0 x0 hb y3c3b fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y24d8 fff5 fs2 fc0 sc0 ls6 ws6">调用setNamespace()方法后，相应的命名空间只会应用到调用这个方法的元素。此时，序列化</div><div class="t m0 x0 h5 y3c3c fff6 fs1 fc0 sc0 ls9 ws2">messages变量会得到如下结果。 </div><div class="t m0 x0 hb y3c3d fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3c3e fff6 fs6 fc0 sc0 ls21 wsb">&lt;wrox:messages xmlns:wrox=&quot;http://www.wrox.com/&quot;&gt; </div><div class="t m0 x0 hb y3c3f fff6 fs6 fc0 sc0 ls21 wsb">    &lt;message&gt;Hello world!&lt;/message&gt; </div><div class="t m0 x0 hb y3c40 fff6 fs6 fc0 sc0 ls21 wsb">&lt;/wrox:messages&gt; </div><div class="t m0 x0 hb y3c41 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3c42 fff5 fs2 fc0 sc0 ls19 ws1b">可见，由于调用了setNamespace()方法，&lt;messages/&gt;元素有了wrox 命名空间前缀，而</div><div class="t m0 x0 h5 y92f fff6 fs1 fc0 sc0 ls9 ws2">&lt;message/&gt;元素则没有变化。 </div><div class="t m0 x0 h1e y3c43 fff5 fs2 fc0 sc0 ls441 ws3c1">如果只想添加一个命名空间声明，而不想改变元素，可以使用addNamespace()方法并传入</div><div class="t m0 x0 h5 y3c44 fff6 fs1 fc0 sc0 ls9 ws2">Namespace对象，如下面的例子所示。 </div><div class="t m0 x0 hb y3c45 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3c46 fff6 fs6 fc0 sc0 ls21 wsb">messages.addNamespace(new Namespace(&quot;wrox&quot;, &quot;http://www.wrox.com/&quot;)); </div><div class="t m0 x0 hb y3c47 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y14fb fff5 fs2 fc0 sc0 ls8 ws1">在将这行代码应用于原先的&lt;messages/&gt;元素时，就会创建如下所示的XML结构。 </div><div class="t m0 x0 hb y14fc fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y14fd fff6 fs6 fc0 sc0 ls21 wsb">&lt;messages xmlns:wrox=&quot;http://www.wrox.com/&quot;&gt; </div><div class="t m0 x0 hb y3c48 fff6 fs6 fc0 sc0 ls21 wsb">    &lt;message&gt;Hello world!&lt;/message&gt; </div><div class="t m0 x0 hb y3c49 fff6 fs6 fc0 sc0 ls21 wsb">&lt;/messages&gt; </div><div class="t m0 x0 hb y3c4a fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y2c56 fff5 fs2 fc0 sc0 ls8 ws1">调用removeNamespace()方法并传入Namespace对象，可以移除表示特定命名空间前缀和URI</div><div class="t m0 x0 hc y3c4b fff5 fs2 fc0 sc0 ls8 ws1">的命名空间声明；注意，必须传入丝毫不差的表示命名空间的Namespace对象。例如： </div><div class="t m0 x0 hb y28e3 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3c4c fff6 fs6 fc0 sc0 ls21 wsb">messages.removeNamespace(new Namespace(&quot;wrox&quot;, &quot;http://www.wrox.com/&quot;)); </div><div class="t m0 x0 hb y3c4d fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y305e fff5 fs2 fc0 sc0 ls8 ws1">这行代码可以移除wrox命名空间。不过，引用前缀的限定名不会受影响。 </div><div class="t m0 x0 h1e y305f fff5 fs2 fc0 sc0 ls19 ws1b">有两个方法可以返回与节点相关的Namespace对象的数组：namespaceDeclarations()和</div><div class="t m0 x0 h4 y3c4e fff6 fs1 fc0 sc0 ls9 ws2">inScopeNamespaces()。前者返回在给定节点上声明的所有命名空间的数组，后者返回位于给定节点</div><div class="t m0 x0 h5 y3c4f fff5 fs2 fc0 sc0 ls8 ws1">作用域中（即包括在节点自身和祖先元素中声明的）所有命名空间的数组。如下面的例子所示： </div><div class="t m0 x0 hb yc07 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3061 fff6 fs6 fc0 sc0 ls21 wsb">var messages = &lt;messages xmlns:wrox=&quot;http://www.wrox.com/&quot;&gt; </div><div class="t m0 x0 hb y3062 fff6 fs6 fc0 sc0 ls21 wsb">    &lt;message&gt;Hello world!&lt;/message&gt; </div><div class="t m0 x0 hb y3063 fff6 fs6 fc0 sc0 ls21 wsb">&lt;/messages&gt;; </div><div class="t m0 x0 hb y3064 fff6 fs6 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf241" class="pf w0 h0" data-page-no="241"><div class="pc pc241 w0 h0"><div class="t m0 x2 h2 y1 ffef fs0 fc0 sc0 ls7 ws0">19.3 其他变化    559 </div><div class="t m0 x0 h3 y2 ffef fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d fffb fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e fffb fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f fffb fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 fffb fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 fffb fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 fffb fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 fffb fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 fffb fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 fffb fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 fffb fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 fffb fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 fffb fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce fffb fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y79 fff6 fs6 fc0 sc0 ls21 wsb">alert(messages.namespaceDeclarations());     //&quot;http://www.wrox.com&quot; </div><div class="t m0 x0 hb y7a fff6 fs6 fc0 sc0 ls21 wsb">alert(messages.inScopeNamespaces());         //&quot;,http://www.wrox.com&quot; </div><div class="t m0 x0 hb y7b fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y7c fff6 fs6 fc0 sc0 ls21 wsb">alert(messages.message.namespaceDeclarations());     //&quot;&quot; </div><div class="t m0 x0 hb y7d fff6 fs6 fc0 sc0 ls21 wsb">alert(messages.message.inScopeNamespaces());         //&quot;,http://www.wrox.com&quot; </div><div class="t m0 x5 hb y3fc fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1dce fff5 fs2 fc0 sc0 ls1f ws15">这里，&lt;messages/&gt;元素在调用namespaceDeclarations()时，会返回包含一个命名空间的数组，</div><div class="t m0 x0 h1e y3c50 fff5 fs2 fc0 sc0 ls1f ws15">而在调用inScopeNamespaces()时，则会返回包含两个命名空间的数组。作用域中的这两个命名空间，</div><div class="t m0 x0 h1e y1dd0 fff5 fs2 fc0 sc0 ls8 ws1">分别是默认命名空间（由空字符串表示）和wrox命名空间。在&lt;message/&gt;元素上调用这些方法时，</div><div class="t m0 x0 h4 y3c51 fff6 fs1 fc0 sc0 ls20 ws16">namespaceDeclarations()，会返回一个空数组，而inScopeNamespaces()方法返回的结果与在</div><div class="t m0 x0 h5 y3c52 fff6 fs1 fc0 sc0 ls9 ws2">&lt;messages/&gt;元素上调用时的返回结果相同。 </div><div class="t m0 x0 h5 y1dd3 fff5 fs2 fc0 sc0 ls8 ws1">使用双冒号（::）也可以基于Namespace对象来查询XML 结构中具有特定命名空间的元素。例</div><div class="t m0 x0 hc y1dd4 fff5 fs2 fc0 sc0 ls8 ws1">如，要取得包含在wrox命名空间中的所有&lt;message/&gt;元素，可以参考下面的代码。 </div><div class="t m0 x5 hb y3c53 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3c54 fff6 fs6 fc0 sc0 ls21 wsb">var messages = &lt;messages xmlns:wrox=&quot;http://www.wrox.com/&quot;&gt; </div><div class="t m0 x0 hb y3c55 fff6 fs6 fc0 sc0 ls21 wsb">    &lt;wrox:message&gt;Hello world!&lt;/message&gt; </div><div class="t m0 x0 hb y3c56 fff6 fs6 fc0 sc0 ls21 wsb">&lt;/messages&gt;; </div><div class="t m0 x0 hb y3c57 fff6 fs6 fc0 sc0 ls21 wsb">var wroxNS = new Namespace(&quot;wrox&quot;, &quot;http://www.wrox.com/&quot;); </div><div class="t m0 x0 hb y3c58 fff6 fs6 fc0 sc0 ls21 wsb">var wroxMessages = messages.wroxNS::message; </div><div class="t m0 x5 hb y3c59 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3c5a fff5 fs2 fc0 sc0 ls8 ws1">这里的双冒号表示返回的元素应该位于其中的命名空间。注意，这里使用的是JavaScript变量，而</div><div class="t m0 x0 h5 y3c5b fff5 fs2 fc0 sc0 ls8 ws1">不是命名空间前缀。 </div><div class="t m0 x0 h1c y3c5c fff5 fs2 fc0 sc0 ls8 ws1">还可以为某个作用域中的所有XML对象设置默认命名空间。为此，要使用default xml namespace</div><div class="t m0 x0 h5 y3c5d fff5 fs2 fc0 sc0 ls8 ws1">语句，并将一个Namespace对象或一个命名空间URI作为值赋给它。例如： </div><div class="t m0 x5 hb y2db7 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3c5e fff6 fs6 fc0 sc0 ls21 wsb">default xml namespace = &quot;http://www.wrox.com/&quot;; </div><div class="t m0 x0 hb y3c5f fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3c60 fff6 fs6 fc0 sc0 ls21 wsb">function doSomething(){ </div><div class="t m0 x0 hb y3c61 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y3c62 fff6 fs6 fc0 sc0 ls21 wsb">    //只为这个函数设置默认的命名空间 </div><div class="t m0 x0 hb y3c63 fff6 fs6 fc0 sc0 ls21 wsb">    default xml namespace = new Namespace(&quot;your&quot;, &quot;http://www.yourdomain.com&quot;); </div><div class="t m0 x0 hb y3c64 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3c65 fff6 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h5 y16bd fff5 fs2 fc0 sc0 ls11c">在doSomething()函数体内设置默认命名空间并不会改变全局作用域中的默认XML命名空间。</div><div class="t m0 x0 h5 y3c66 fff5 fs2 fc0 sc0 ls8 ws1">在给定作用域中，当所有XML数据都需要使用特定的命名空间时，就可以使用这个语句，从而避免多</div><div class="t m0 x0 h5 y3c67 fff5 fs2 fc0 sc0 ls8 ws1">次引用命名空间的麻烦。 </div><div class="t m0 x0 hd y3c68 fff3 fs7 fc0 sc0 ls245">19.3 其他变化 </div><div class="t m0 x0 h5 y3c69 fff5 fs2 fc0 sc0 ls55 ws49">为了与ECMAScript做到无缝集成，E4X 也对语言基础进行了一些修改。其中之一就是引入了</div><div class="t m0 x0 h5 y3364 fff6 fs1 fc0 sc0 ls9 ws2">for-each-in循环，以便迭代遍历每一个属性并返回属性的值，如下面的例子所示。 </div><div class="t m0 x5 hb y3c6a fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3c6b fff6 fs6 fc0 sc0 ls21 wsb">var employees = &lt;employees&gt; </div><div class="t m0 x0 hb y3c6c fff6 fs6 fc0 sc0 ls21 wsb">                    &lt;employee position=&quot;Software Engineer&quot;&gt; </div><div class="t m0 x0 hb y3c6d fff6 fs6 fc0 sc0 ls21 wsb">                        &lt;name&gt;Nicholas C. Zakas&lt;/name&gt; </div><div class="t m0 x0 hb y3c6e fff6 fs6 fc0 sc0 ls21 wsb">                    &lt;/employee&gt; </div><div class="t m0 x0 hb y3c6f fff6 fs6 fc0 sc0 ls21 wsb">                    &lt;employee position=&quot;Salesperson&quot;&gt; </div><div class="t m0 x0 hb y3c70 fff6 fs6 fc0 sc0 ls21 wsb">                        &lt;name&gt;Jim Smith&lt;/name&gt; </div><div class="t m0 x0 hb y3c71 fff6 fs6 fc0 sc0 ls21 wsb">                    &lt;/employee&gt; </div><div class="t m0 x0 hb y3c72 fff6 fs6 fc0 sc0 ls21 wsb">                &lt;/employees&gt;; </div></div></div>
<div id="pf242" class="pf w0 h0" data-page-no="242"><div class="pc pc242 w0 h0"><div class="t m0 x0 h2 y1 ffef fs0 fc0 sc0 ls7 ws0">560  第19章 E4X </div><div class="t m0 x0 h3 y2 ffef fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 fff6 fs6 fc0 sc0 ls21 wsb">for each (var child in employees){ </div><div class="t m0 x0 hb y7a fff6 fs6 fc0 sc0 ls21 wsb">    alert(child.toXMLString()); </div><div class="t m0 x0 hb y7b fff6 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x2 hf y106 fffc fs2 fc0 sc0 ls2b wsb">ForEachInExample01.htm </div><div class="t m0 x0 h4 y107 fff5 fs2 fc0 sc0 ls5 ws4">在这个例子的for-each-in循环中，&lt;employees/&gt;的每个子节点会依次被赋值给child变量，</div><div class="t m0 x0 h5 y108 fff5 fs2 fc0 sc0 ls5 ws4">其中包括注释、处理指令和/或文本节点。要想返回特性节点，则需要对一个由特性节点组成的XMLList</div><div class="t m0 x0 h5 y109 fff5 fs2 fc0 sc0 ls8 ws1">对象进行操作，如下所示。 </div><div class="t m0 x0 hb y426 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y3bcb fff6 fs6 fc0 sc0 ls21 wsb">for each (var attribute in employees.@*){ //遍历特性 </div><div class="t m0 x0 hb y3c74 fff6 fs6 fc0 sc0 ls21 wsb">    alert(attribute); </div><div class="t m0 x0 hb y3c75 fff6 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h5 y3c76 fff5 fs2 fc0 sc0 ls8 ws1">虽然for-each-in循环是在E4X中定义的，但这个语句也可以用于常规的数组和对象，例如： </div><div class="t m0 x0 hb y3c77 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3c78 fff6 fs6 fc0 sc0 ls21 wsb">var colors = [&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;]; </div><div class="t m0 x0 hb y3c79 fff6 fs6 fc0 sc0 ls21 wsb">for each(var color in colors){ </div><div class="t m0 x0 hb y3c7a fff6 fs6 fc0 sc0 ls21 wsb">    alert(color); </div><div class="t m0 x0 hb y3c7b fff6 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x2 hf y3c7c fffc fs2 fc0 sc0 ls2b wsb">ForEachInExample01.htm </div><div class="t m0 x0 h4 y3c7d fff5 fs2 fc0 sc0 ls8 ws1">对于数组，for-each-in循环会返回数组中的每一项。对于非XML对象，这个循环返回对象每个</div><div class="t m0 x0 h5 y3c7e fff5 fs2 fc0 sc0 ls8 ws1">属性的值。 </div><div class="t m0 x0 h5 y3c7f ffef fs2 fc0 sc0 lsd2 ws19b">E4X还添加了一个全局函数，名叫isXMLName()。这个函数接受一个字符串，并在这个字符串是</div><div class="t m0 x0 hc y3c80 fff5 fs2 fc0 sc0 ls8 ws1">元素或特性的有效内部名称的情况下返回true。在使用未知字符串构建XML数据结构时，这个函数可</div><div class="t m0 x0 h5 y3c81 fff5 fs2 fc0 sc0 ls8 ws1">以为开发人员提供方便。来看下面的例子。 </div><div class="t m0 x0 hb y21c4 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1f03 fff6 fs6 fc0 sc0 ls21 wsb">alert(isXMLName(&quot;color&quot;));           //true </div><div class="t m0 x0 hb y3c82 fff6 fs6 fc0 sc0 ls21 wsb">alert(isXMLName(&quot;hello world&quot;));     //false </div><div class="t m0 x0 hb y3c83 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3c84 fff5 fs2 fc0 sc0 ls8 ws1">如果你不确定某个字符串的来源，而又需要将该字符串用作一个内部名称，那么最好在使用它之前</div><div class="t m0 x0 hc y3c85 fff5 fs2 fc0 sc0 ls8 ws1">先通过isXMLName()检测一下是否有效，以防发生错误。 </div><div class="t m0 x0 h5 y3c86 ffef fs2 fc0 sc0 lsd2 ws19b">E4X对标准ECMAScript的最后一个修改是typeof 操作符。在对XML对象或XMLList对象使用</div><div class="t m0 x0 h4 y440 fff5 fs2 fc0 sc0 ls8 ws1">这个操作符时，typeof返回字符串&quot;xml&quot;。但在对其他对象使用这个操作符时，返回的都是&quot;object&quot;，</div><div class="t m0 x0 h5 y3170 fff5 fs2 fc0 sc0 ls8">例如： </div><div class="t m0 x0 hb y3c87 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3c88 fff6 fs6 fc0 sc0 ls21 wsb">var xml = new XML(); </div><div class="t m0 x0 hb y3c89 fff6 fs6 fc0 sc0 ls21 wsb">var list = new XMLList(); </div><div class="t m0 x0 hb y3c8a fff6 fs6 fc0 sc0 ls21 wsb">var object = {}; </div><div class="t m0 x0 hb y3c8b fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3c8c fff6 fs6 fc0 sc0 ls21 wsb">alert(typeof xml);  //&quot;xml&quot; </div><div class="t m0 x0 hb y3c8d fff6 fs6 fc0 sc0 ls21 wsb">alert(typeof list);  //&quot;xml&quot; </div><div class="t m0 x0 hb y3c8e fff6 fs6 fc0 sc0 ls21 wsb">alert(typeof object); //&quot;object&quot; </div><div class="t m0 x0 hb y3c8f fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3c90 fff5 fs2 fc0 sc0 ls8 ws1">多数情况下，都没有必要区分XML和XMLList对象。在E4X中，这两个对象都被看成是基本数据</div><div class="t m0 x0 h5 y3c91 fff5 fs2 fc0 sc0 ls8 ws1">类型，因而也无法通过instanceof操作符来将它们区分开来。 </div><div class="t m0 x0 hd y3c92 fff3 fs7 fc0 sc0 ls245">19.4 全面启用E4X </div><div class="t m0 x0 h5 y2086 fff5 fs2 fc0 sc0 ls8 ws1">鉴于E4X在很多方面给标准JavaScript带来了不同，因此 Firefox在默认情况下只启用E4X中与其</div></div></div>
<div id="pf243" class="pf w0 h0" data-page-no="243"><div class="pc pc243 w0 h0"><div class="t m0 x2 h2 y1 ffef fs0 fc0 sc0 ls7 ws0">19.5 小结  561 </div><div class="t m0 x0 h3 y2 ffef fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d fffb fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e fffb fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f fffb fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 fffb fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 fffb fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 fffb fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 fffb fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 fffb fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 fffb fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 fffb fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 fffb fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 fffb fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce fffb fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 fff5 fs2 fc0 sc0 ls24 ws1e">他代码能够相安无事的那些特性。要想完整地启用E4X，需要将&lt;script&gt;标签的type 特性设置为</div><div class="t m0 x0 h5 y4 fff6 fs1 fc0 sc0 ls9 ws2">&quot;text/javascript;e4x=1&quot;，例如： </div><div class="t m0 x5 hb y2d8 fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2d9 fff6 fs6 fc0 sc0 ls21 wsb">&lt;script type=&quot;text/javascript;e4x=1&quot; src=&quot;e4x_file.js&quot;&gt;&lt;/script&gt; </div><div class="t m0 x5 hb y1bfe fff6 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1512 fff5 fs2 fc0 sc0 ls8 ws1">在打开这个“开关”之后，就会全面启用E4X，从而能够正确地解析嵌入在E4X字面量中的注释</div><div class="t m0 x0 h5 y15b3 fff5 fs2 fc0 sc0 ls3b">和CData片段。在没有完整启用E4X的情况下使用注释和/或CData片段会导致语法错误。 </div><div class="t m0 x0 hd yd44 fff3 fs7 fc0 sc0 ls245">19.5 小结 </div><div class="t m0 x0 h5 y55 ffef fs2 fc0 sc0 lsd2 ws19b">E4X是以ECMA-357标准的形式发布的对ECMAScript的一个扩展。E4X 的目的是为操作XML数</div><div class="t m0 x0 h5 y56 fff5 fs2 fc0 sc0 ls8 ws1">据提供与标准ECMAScript更相近的语法。E4X具有下列特征。 </div><div class="t m0 x0 h5 y3c93 fff4 fs1 fc0 sc0 ls2"> 与DOM不同，E4X只用一个类型来表示XML中的各种节点。 </div><div class="t m0 x0 h4 y384 fff4 fs1 fc0 sc0 ls2"> XML对象中封装了对所有节点都有用的数据和行为。为表现多个节点的集合，这个规范定义了</div><div class="t m0 x5 h5 y59 fff6 fs1 fc0 sc0 ls9 ws2">XMLList类型。 </div><div class="t m0 x0 h5 y386 fff4 fs1 fc0 sc0 ls2"> 另外两个类型，Namespace和QName，分别表现命名空间和限定名。 </div><div class="t m0 x0 h5 y5b fff5 fs2 fc0 sc0 ls8 ws1">为便于查询XML结构，E4X还修改了标准了的ECMAScript语法，修改的地方如下。 </div><div class="t m0 x0 h5 y3a42 fff4 fs1 fc0 sc0 ls2"> 使用两个点（..）表示要匹配所有后代元素，使用@字符表示应该返回一或多个特性。 </div><div class="t m0 x0 h5 y2e11 fff4 fs1 fc0 sc0 ls2"> 星号字符（*）是一个通配符，可以匹配任意类型的节点。 </div><div class="t m0 x0 h5 y388 fff4 fs1 fc0 sc0 ls2"> 所有这些查询都可以通过一组执行相同操作的方法来实现。 </div><div class="t m0 x0 h5 y3c94 fff5 fs2 fc0 sc0 ls108">到2011年底，Firefox还是唯一一个支持E4X的浏览器。尽管没有其他浏览器提供商承诺会实现E4X，</div><div class="t m0 x0 h5 y3c95 fff5 fs2 fc0 sc0 ls8 ws1">但在服务器上，由于BEA Workshop for WebLogic和Yhaoo! YQL的推动，E4X已经取得了不小的成功。 </div><div class="t m0 x0 h5 y3c96 ffef fs2 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf244" class="pf w0 h0" data-page-no="244"><div class="pc pc244 w0 h0"><div class="t m0 x0 h2 y1 ffff fs0 fc0 sc0 ls7 ws0">562  第20章 JSON </div><div class="t m0 x0 h3 y2 ffff fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h9 y2a ff101 fs5 fc0 sc0 ls8 wsb">JSON </div><div class="t m0 x0 h3c y2b ff102 fs2 fc0 sc0 ls8">本章内容 </div><div class="t m0 x0 h5 y2c ff104 fs1 fc0 sc0 ls2"> 理解JSON语法 </div><div class="t m0 x0 h5 y2d ff104 fs1 fc0 sc0 ls2"> 解析JSON </div><div class="t m0 x0 h5 y2e ff104 fs1 fc0 sc0 ls2"> 序列化JSON </div><div class="t m0 x0 h5 y8d9 ffff fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y8da ff105 fs2 fc0 sc0 ls8 ws1">经有一段时间，XML是互联网上传输结构化数据的事实标准。Web服务的第一次浪潮很大程</div><div class="t m0 x0 h5 y8db ff105 fs2 fc0 sc0 ls8 ws1">度上都是建立在XML之上的，突出的特点是服务器与服务器间通信。然而，业界一直不乏质</div><div class="t m0 x0 h5 y8dc ff105 fs2 fc0 sc0 ls3b">疑XML的声音。不少人认为XML过于烦琐、冗长。为解决这个问题，也涌现了一些方案。不过，Web</div><div class="t m0 x0 h5 y8dd ff105 fs2 fc0 sc0 ls8 ws1">的发展方向已经改变了。 </div><div class="t m0 x0 h5 y8de ffff fs2 fc0 sc0 ls8 ws20">2006年，Douglas Crockford把JSON（JavaScript Object Notation，JavaScript对象表示法）作为IETF </div><div class="t m0 x0 h5 y8df ffff fs2 fc0 sc0 ls14d ws3c4">RFC 4627提交给IETF，而JSON的应用早在 2001年就已经开始了。JSON是JavaScript的一个严格的子</div><div class="t m0 x0 h5 y8e0 ff105 fs2 fc0 sc0 ls8 ws1">集，利用了JavaScript中的一些模式来表示结构化数据。Crockford认为与XML相比，JSON是在JavaScript</div><div class="t m0 x0 h138 y8e1 ff105 fs2 fc0 sc0 ls8 ws1">中读写结构化数据的更好的方式。因为可以把JSON直接传给eval()，而且不必创建DOM对象。 </div><div class="t m0 x0 h5 y3c97 ff105 fs2 fc0 sc0 ls8 ws1">关于JSON，最重要的是要理解它是一种数据格式，不是一种编程语言。虽然具有相同的语法形式，</div><div class="t m0 x0 h5 y3c98 ff105 fs2 fc0 sc0 lsea">但JSON并不从属于JavaScript。而且，并不是只有JavaScript才使用 JSON，毕竟JSON只是一种数据</div><div class="t m0 x0 h5 y3c99 ff105 fs2 fc0 sc0 ls8 ws1">格式。很多编程语言都有针对JSON的解析器和序列化器。 </div><div class="t m0 x0 hd y3059 ff103 fs7 fc0 sc0 ls245">20.1 语法 </div><div class="t m0 x0 h5 y28e8 ffff fs2 fc0 sc0 lsfa wsc9">JSON的语法可以表示以下三种类型的值。 </div><div class="t m0 x0 h5 y2c55 ff104 fs1 fc0 sc0 ls2"> 简单值：使用与JavaScript相同的语法，可以在JSON中表示字符串、数值、布尔值和 null。</div><div class="t m0 x0 hc y305a ff105 fs2 fc0 sc0 ls3b">但JSON不支持JavaScript中的特殊值undefined。 </div><div class="t m0 x0 h4 y2101 ff104 fs1 fc0 sc0 ls2"> 对象：对象作为一种复杂数据类型，表示的是一组无序的键值对儿。而每个键值对儿中的值可</div><div class="t m0 x0 h5 y2102 ff105 fs2 fc0 sc0 ls8 ws1">以是简单值，也可以是复杂数据类型的值。 </div><div class="t m0 x0 h4 y1d60 ff104 fs1 fc0 sc0 ls2"> 数组：数组也是一种复杂数据类型，表示一组有序的值的列表，可以通过数值索引来访问其中</div><div class="t m0 x0 h5 y1d61 ff105 fs2 fc0 sc0 ls8 ws1">的值。数组的值也可以是任意类型——简单值、对象或数组。 </div><div class="t m0 x0 h5 y3c9a ffff fs2 fc0 sc0 lsfa wsc9">JSON不支持变量、函数或对象实例，它就是一种表示结构化数据的格式，虽然与JavaScript中表示</div><div class="t m0 x0 h5 y3c9b ff105 fs2 fc0 sc0 ls8 ws1">数据的某些语法相同，但它并不局限于JavaScript的范畴。 </div><div class="t m0 x0 h20 y1aa0 ff103 fs3 fc0 sc0 ls248 ws214">20.1.1 简单值 </div><div class="t m0 x0 h5 y3c9c ff105 fs2 fc0 sc0 ls8 ws1">最简单的JSON数据形式就是简单值。例如，下面这个值是有效的JSON数据： </div><div class="t m0 x0 hb y3c9d ff106 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h139 y8f4 ff102 fs19 fc0 sc0 ls8 wsb">曾 </div><div class="t m0 x0 h11 y4b ff107 fsa fc0 sc0 ls8">第</div><div class="t m1 x0 h12 y4b ff108 fsb fc3 sc0 ls247">20</div><div class="t m0 x5 h9 y4b ff107 fsa fc0 sc0 ls8 ws1d">章 </div></div></div>
<div id="pf245" class="pf w0 h0" data-page-no="245"><div class="pc pc245 w0 h0"><div class="t m0 x2 h2 y1 ffff fs0 fc0 sc0 ls7 ws0">20.1 语法  563 </div><div class="t m0 x0 h3 y2 ffff fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff109 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff109 fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ff109 fs3 fc2 sc0 ls1d wsb">16 </div><div class="t m0 x3 h8 y20 ff109 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff109 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff109 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff109 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff109 fs3 fc2 sc0 ls1d wsb">20 </div><div class="t m0 x3 h8 y25 ff109 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff109 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff109 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ff109 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff109 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y79 ff106 fs6 fc0 sc0 ls21 wsb">5 </div><div class="t m0 x0 hb y1b0b ff106 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1b0c ff105 fs2 fc0 sc0 ls8 ws1">这是JSON表示数值5的方式。类似地，下面是JSON表示字符串的方式： </div><div class="t m0 x0 hb y3c9e ff106 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3c9f ff106 fs6 fc0 sc0 ls21 wsb">&quot;Hello world!&quot; </div><div class="t m0 x0 hb y3ca0 ff106 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3ca1 ffff fs2 fc0 sc0 lsb ws5">JavaScript字符串与JSON字符串的最大区别在于，JSON字符串必须使用双引号（单引号会导致语</div><div class="t m0 x0 h5 y3ca2 ff105 fs2 fc0 sc0 ls8 ws1">法错误）。 </div><div class="t m0 x0 he y3ca3 ff105 fs2 fc0 sc0 ls8 ws1">布尔值和null也是有效的JSON形式。但是，在实际应用中，JSON更多地用来表示更复杂的数据</div><div class="t m0 x0 h5 y1b13 ff105 fs2 fc0 sc0 ls8 ws1">结构，而简单值只是整个数据结构中的一部分。 </div><div class="t m0 x0 h20 y333 ff103 fs3 fc0 sc0 ls248 ws214">20.1.2 对象 </div><div class="t m0 x0 h5 y3178 ffff fs2 fc0 sc0 lsfa wsc9">JSON中的对象与JavaScript字面量稍微有一些不同。下面是一个JavaScript中的对象字面量： </div><div class="t m0 x0 hb y3ca4 ff106 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3ca5 ff106 fs6 fc0 sc0 ls21 wsb">var person = {  </div><div class="t m0 x0 hb y3ca6 ff106 fs6 fc0 sc0 ls21 wsb">    name: &quot;Nicholas&quot;, </div><div class="t m0 x0 hb y3ca7 ff106 fs6 fc0 sc0 ls21 wsb">    age: 29 </div><div class="t m0 x0 hb y3ca8 ff106 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y3ca9 ff106 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3540 ff105 fs2 fc0 sc0 ls8 ws1">这虽然是开发人员在JavaScript中创建对象字面量的标准方式，但JSON中的对象要求给属性加引</div><div class="t m0 x0 h5 y3541 ff105 fs2 fc0 sc0 ls8 ws1">号。实际上，在JavaScript中，前面的对象字面量完全可以写成下面这样： </div><div class="t m0 x0 hb y3caa ff106 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3cab ff106 fs6 fc0 sc0 ls21 wsb">var object = {  </div><div class="t m0 x0 hb y3cac ff106 fs6 fc0 sc0 ls21 wsb">    &quot;name&quot;: &quot;Nicholas&quot;, </div><div class="t m0 x0 hb y3cad ff106 fs6 fc0 sc0 ls21 wsb">    &quot;age&quot;: 29 </div><div class="t m0 x0 hb y3cae ff106 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y3caf ff106 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3cb0 ffff fs2 fc0 sc0 lsfa wsc9">JSON表示上述对象的方式如下： </div><div class="t m0 x0 hb y3cb1 ff106 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3cb2 ff106 fs6 fc0 sc0 ls21 wsb">{  </div><div class="t m0 x0 hb y3cb3 ff106 fs6 fc0 sc0 ls21 wsb">    &quot;name&quot;: &quot;Nicholas&quot;, </div><div class="t m0 x0 hb y3cb4 ff106 fs6 fc0 sc0 ls21 wsb">    &quot;age&quot;: 29 </div><div class="t m0 x0 hb y3cb5 ff106 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y3cb6 ff106 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y67b ff105 fs2 fc0 sc0 ls3b">与JavaScript的对象字面量相比，JSON对象有两个地方不一样。首先，没有声明变量（JSON中没</div><div class="t m0 x0 h5 y3cb7 ff105 fs2 fc0 sc0 ls8 ws1">有变量的概念）。其次，没有末尾的分号（因为这不是JavaScript语句，所以不需要分号）。再说一遍，</div><div class="t m0 x0 h5 y3cb8 ff105 fs2 fc0 sc0 ls8 ws1">对象的属性必须加双引号，这在JSON中是必需的。属性的值可以是简单值，也可以是复杂类型值，因</div><div class="t m0 x0 h5 y3cb9 ff105 fs2 fc0 sc0 ls8 ws1">此可以像下面这样在对象中嵌入对象： </div><div class="t m0 x0 hb y17bf ff106 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3cba ff106 fs6 fc0 sc0 ls21 wsb">{  </div><div class="t m0 x0 hb y3cbb ff106 fs6 fc0 sc0 ls21 wsb">    &quot;name&quot;: &quot;Nicholas&quot;, </div><div class="t m0 x0 hb y3cbc ff106 fs6 fc0 sc0 ls21 wsb">    &quot;age&quot;: 29, </div><div class="t m0 x0 hb y3cbd ff106 fs6 fc0 sc0 ls21 wsb">    &quot;school&quot;: { </div><div class="t m0 x0 hb y3cbe ff106 fs6 fc0 sc0 ls21 wsb">        &quot;name&quot;: &quot;Merrimack College&quot;, </div><div class="t m0 x0 hb y3cbf ff106 fs6 fc0 sc0 ls21 wsb">        &quot;location&quot;: &quot;North Andover, MA&quot; </div><div class="t m0 x0 hb y3cc0 ff106 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y3cc1 ff106 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y3cc2 ff106 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y26d5 ff105 fs2 fc0 sc0 ls8 ws1">这个例子在顶级对象中嵌入了学校（&quot;school&quot;）信息。虽然有两个&quot;name&quot;属性，但由于它们分别</div><div class="t m0 x0 h5 y26d6 ff105 fs2 fc0 sc0 ls8 ws1">属于不同的对象，因此这样完全没有问题。不过，同一个对象中绝对不应该出现两个同名属性。 </div><div class="t m0 x0 h5 y3cc3 ff105 fs2 fc0 sc0 ls3b">与JavaScript不同，JSON中对象的属性名任何时候都必须加双引号。手工编写JSON时，忘了给对</div><div class="t m0 x0 h5 y3cc4 ff105 fs2 fc0 sc0 ls8 ws1">象属性名加双引号或者把双引号写成单引号都是常见的错误。 </div></div></div>
<div id="pf246" class="pf w0 h0" data-page-no="246"><div class="pc pc246 w0 h0"><div class="t m0 x0 h2 y1 ffff fs0 fc0 sc0 ls7 ws0">564  第20章 JSON </div><div class="t m0 x0 h3 y2 ffff fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h20 y12d ff103 fs3 fc0 sc0 ls248 ws214">20.1.3 数组 </div><div class="t m0 x0 h5 y12e ffff fs2 fc0 sc0 lsfa wsc9">JSON中的第二种复杂数据类型是数组。JSON数组采用的就是JavaScript中的数组字面量形式。例</div><div class="t m0 x0 h5 y12f ff105 fs2 fc0 sc0 ls8 ws1">如，下面是JavaScript中的数组字面量： </div><div class="t m0 x0 hb y49e ff106 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1476 ff106 fs6 fc0 sc0 ls21 wsb">var values = [25, &quot;hi&quot;, true]; </div><div class="t m0 x0 hb y3cc5 ff106 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3cc6 ff105 fs2 fc0 sc0 ls3b">在JSON中，可以采用同样的语法表示同一个数组： </div><div class="t m0 x0 hb y3cc7 ff106 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3cc8 ff106 fs6 fc0 sc0 ls21 wsb">[25, &quot;hi&quot;, true] </div><div class="t m0 x0 hb y3cc9 ff106 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3cca ff105 fs2 fc0 sc0 ls8 ws1">同样要注意，JSON数组也没有变量和分号。把数组和对象结合起来，可以构成更复杂的数据集合，</div><div class="t m0 x0 h5 y3ccb ff105 fs2 fc0 sc0 ls8">例如： </div><div class="t m0 x0 hb y3ccc ff106 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3ccd ff106 fs6 fc0 sc0 ls21 wsb">[ </div><div class="t m0 x0 hb y3cce ff106 fs6 fc0 sc0 ls21 wsb">    { </div><div class="t m0 x0 hb y3ccf ff106 fs6 fc0 sc0 ls21 wsb">         &quot;title&quot;: &quot;Professional JavaScript&quot;, </div><div class="t m0 x0 hb y3cd0 ff106 fs6 fc0 sc0 ls21 wsb">         &quot;authors&quot;: [ </div><div class="t m0 x0 hb y3cd1 ff106 fs6 fc0 sc0 ls21 wsb">             &quot;Nicholas C. Zakas&quot; </div><div class="t m0 x0 hb y3cd2 ff106 fs6 fc0 sc0 ls21 wsb">         ], </div><div class="t m0 x0 hb y3cd3 ff106 fs6 fc0 sc0 ls21 wsb">         edition: 3, </div><div class="t m0 x0 hb y3cd4 ff106 fs6 fc0 sc0 ls21 wsb">         year: 2011 </div><div class="t m0 x0 hb y3cd5 ff106 fs6 fc0 sc0 ls21 wsb">    }, </div><div class="t m0 x0 hb y3cd6 ff106 fs6 fc0 sc0 ls21 wsb">    { </div><div class="t m0 x0 hb y3cd7 ff106 fs6 fc0 sc0 ls21 wsb">         &quot;title&quot;: &quot;Professional JavaScript&quot;, </div><div class="t m0 x0 hb y3cd8 ff106 fs6 fc0 sc0 ls21 wsb">         &quot;authors&quot;: [ </div><div class="t m0 x0 hb y3cd9 ff106 fs6 fc0 sc0 ls21 wsb">              &quot;Nicholas C. Zakas&quot; </div><div class="t m0 x0 hb y3cda ff106 fs6 fc0 sc0 ls21 wsb">         ], </div><div class="t m0 x0 hb y3cdb ff106 fs6 fc0 sc0 ls21 wsb">         edition: 2, </div><div class="t m0 x0 hb y3cdc ff106 fs6 fc0 sc0 ls21 wsb">         year: 2009 </div><div class="t m0 x0 hb y3cdd ff106 fs6 fc0 sc0 ls21 wsb">    }, </div><div class="t m0 x0 hb y3cde ff106 fs6 fc0 sc0 ls21 wsb">    { </div><div class="t m0 x0 hb y3cdf ff106 fs6 fc0 sc0 ls21 wsb">         &quot;title&quot;: &quot;Professional Ajax&quot;, </div><div class="t m0 x0 hb y3ce0 ff106 fs6 fc0 sc0 ls21 wsb">         &quot;authors&quot;: [ </div><div class="t m0 x0 hb y3ce1 ff106 fs6 fc0 sc0 ls21 wsb">             &quot;Nicholas C. Zakas&quot;, </div><div class="t m0 x0 hb y3ce2 ff106 fs6 fc0 sc0 ls21 wsb">             &quot;Jeremy McPeak&quot;, </div><div class="t m0 x0 hb y3ce3 ff106 fs6 fc0 sc0 ls21 wsb">             &quot;Joe Fawcett&quot; </div><div class="t m0 x0 hb y3ce4 ff106 fs6 fc0 sc0 ls21 wsb">         ], </div><div class="t m0 x0 hb y3ce5 ff106 fs6 fc0 sc0 ls21 wsb">         edition: 2, </div><div class="t m0 x0 hb y3ce6 ff106 fs6 fc0 sc0 ls21 wsb">         year: 2008 </div><div class="t m0 x0 hb y3ce7 ff106 fs6 fc0 sc0 ls21 wsb">    }, </div><div class="t m0 x0 hb y3ce8 ff106 fs6 fc0 sc0 ls21 wsb">    { </div><div class="t m0 x0 hb y3ce9 ff106 fs6 fc0 sc0 ls21 wsb">         &quot;title&quot;: &quot;Professional Ajax&quot;, </div><div class="t m0 x0 hb y3cea ff106 fs6 fc0 sc0 ls21 wsb">         &quot;authors&quot;: [ </div><div class="t m0 x0 hb y3ceb ff106 fs6 fc0 sc0 ls21 wsb">             &quot;Nicholas C. Zakas&quot;, </div><div class="t m0 x0 hb y3cec ff106 fs6 fc0 sc0 ls21 wsb">             &quot;Jeremy McPeak&quot;, </div><div class="t m0 x0 hb y3ced ff106 fs6 fc0 sc0 ls21 wsb">             &quot;Joe Fawcett&quot; </div><div class="t m0 x0 hb y3cee ff106 fs6 fc0 sc0 ls21 wsb">         ], </div><div class="t m0 x0 hb y3cef ff106 fs6 fc0 sc0 ls21 wsb">         edition: 1, </div><div class="t m0 x0 hb y3cf0 ff106 fs6 fc0 sc0 ls21 wsb">         year: 2007 </div><div class="t m0 x0 hb y3cf1 ff106 fs6 fc0 sc0 ls21 wsb">    }, </div><div class="t m0 x0 hb y3cf2 ff106 fs6 fc0 sc0 ls21 wsb">    { </div><div class="t m0 x0 hb y3cf3 ff106 fs6 fc0 sc0 ls21 wsb">         &quot;title&quot;: &quot;Professional JavaScript&quot;, </div><div class="t m0 x0 hb y3cf4 ff106 fs6 fc0 sc0 ls21 wsb">         &quot;authors&quot;: [ </div><div class="t m0 x0 hb y3cf5 ff106 fs6 fc0 sc0 ls21 wsb">              &quot;Nicholas C. Zakas&quot; </div><div class="t m0 x0 hb y3cf6 ff106 fs6 fc0 sc0 ls21 wsb">         ], </div><div class="t m0 x0 hb y3cf7 ff106 fs6 fc0 sc0 ls21 wsb">         edition: 1, </div></div></div>
<div id="pf247" class="pf w0 h0" data-page-no="247"><div class="pc pc247 w0 h0"><div class="t m0 x2 h2 y1 ffff fs0 fc0 sc0 ls7 ws0">20.2 解析与序列化    565 </div><div class="t m0 x0 h3 y2 ffff fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff109 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff109 fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ff109 fs3 fc2 sc0 ls1d wsb">16 </div><div class="t m0 x3 h8 y20 ff109 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff109 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff109 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff109 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff109 fs3 fc2 sc0 ls1d wsb">20 </div><div class="t m0 x3 h8 y25 ff109 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff109 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff109 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ff109 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff109 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y79 ff106 fs6 fc0 sc0 ls21 wsb">             year: 2006 </div><div class="t m0 x0 hb y7a ff106 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y7b ff106 fs6 fc0 sc0 ls21 wsb">] </div><div class="t m0 x0 hb y105 ff106 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3066 ff105 fs2 fc0 sc0 ls8 ws1">这个数组中包含一些表示图书的对象。每个对象都有几个属性，其中一个属性是&quot;authors&quot;，这个</div><div class="t m0 x0 h5 y3067 ff105 fs2 fc0 sc0 ls8 ws1">属性的值又是一个数组。对象和数组通常是JSON数据结构的最外层形式（当然，这不是强制规定的），</div><div class="t m0 x0 h5 y3cf8 ff105 fs2 fc0 sc0 ls8 ws1">利用它们能够创造出各种各样的数据结构。 </div><div class="t m0 x0 hd y3cf9 ff103 fs7 fc0 sc0 ls245">20.2 解析与序列化 </div><div class="t m0 x0 h5 y3cfa ffff fs2 fc0 sc0 lsb5 ws93">JSON之所以流行，拥有与JavaScript类似的语法并不是全部原因。更重要的一个原因是，可以把</div><div class="t m0 x0 h5 y3cfb ffff fs2 fc0 sc0 lsfa wsc9">JSON数据结构解析为有用的JavaScript对象。与XML数据结构要解析成 DOM文档而且从中提取数据</div><div class="t m0 x0 h5 y3cfc ff105 fs2 fc0 sc0 ls8 ws1">极为麻烦相比，JSON可以解析为JavaScript对象的优势极其明显。就以上一节中包含一组图书的JSON</div><div class="t m0 x0 h5 y3cfd ff105 fs2 fc0 sc0 ls8 ws1">数据结构为例，在解析为JavaScript对象后，只需要下面一行简单的代码就可以取得第三本书的书名： </div><div class="t m0 x0 hb y3cfe ff106 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3cff ff106 fs6 fc0 sc0 ls21 wsb">books[2].title </div><div class="t m0 x0 hb y3d00 ff106 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3d01 ff105 fs2 fc0 sc0 ls8 ws1">当然，这里是假设把解析JSON数据结构后得到的对象保存到了变量books中。再看看下面在DOM</div><div class="t m0 x0 h5 y25da ff105 fs2 fc0 sc0 ls8 ws1">结构中查找数据的代码： </div><div class="t m0 x0 hb y3d02 ff106 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3d03 ff106 fs6 fc0 sc0 ls21 wsb">doc.getElementsByTagName(&quot;book&quot;)[2].getAttribute(&quot;title&quot;) </div><div class="t m0 x0 hb y3d04 ff106 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3d05 ff105 fs2 fc0 sc0 ls8 ws1">看看这些多余的方法调用，就不难理解为什么JSON能得到JavaScript开发人员的热烈欢迎了。从</div><div class="t m0 x0 h5 yd55 ff105 fs2 fc0 sc0 ls8 ws1">此以后，JSON就成了Web服务开发中交换数据的事实标准。 </div><div class="t m0 x0 h20 y3d06 ff103 fs3 fc0 sc0 ls248 ws214">20.2.1 JSON对象 </div><div class="t m0 x0 h5 y1409 ff105 fs2 fc0 sc0 ls8 ws1">早期的JSON解析器基本上就是使用JavaScript的eval()函数。由于 JSON是JavaScript语法的子</div><div class="t m0 x0 hc y140a ff105 fs2 fc0 sc0 ls8 ws1">集，因此eval()函数可以解析、解释并返回JavaScript对象和数组。ECMAScript 5对解析 JSON的行</div><div class="t m0 x0 hc y3d07 ff105 fs2 fc0 sc0 ls8 ws1">为进行规范，定义了全局对象JSON。支持这个对象的浏览器有IE 8+、Firefox 3.5+、Safari 4+、Chrome</div><div class="t m0 x0 h5 y140c ff105 fs2 fc0 sc0 ls3b">和Opera 10.5+。对于较早版本的浏览器，可以使用一个shim：https://github.com/douglascrockford/JSON-js。</div><div class="t m0 x0 hc y3d08 ff105 fs2 fc0 sc0 ls8 ws1">在旧版本的浏览器中，使用eval()对JSON数据结构求值存在风险，因为可能会执行一些恶意代码。</div><div class="t m0 x0 h5 y6ad ff105 fs2 fc0 sc0 ls8 ws1">对于不能原生支持JSON解析的浏览器，使用这个shim是最佳选择。 </div><div class="t m0 x0 h5 y3d09 ffff fs2 fc0 sc0 lsfa wsc9">JSON对象有两个方法：stringify()和parse()。在最简单的情况下，这两个方法分别用于把</div><div class="t m0 x0 h5 y3d0a ffff fs2 fc0 sc0 lsb ws5">JavaScript对象序列化为JSON字符串和把JSON字符串解析为原生 JavaScript值。例如： </div><div class="t m0 x0 hb y1dab ff106 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3d0b ff106 fs6 fc0 sc0 ls21 wsb">var book = {  </div><div class="t m0 x0 hb y3d0c ff106 fs6 fc0 sc0 ls21 wsb">                title: &quot;Professional JavaScript&quot;, </div><div class="t m0 x0 hb y3d0d ff106 fs6 fc0 sc0 ls21 wsb">                authors: [ </div><div class="t m0 x0 hb y3d0e ff106 fs6 fc0 sc0 ls21 wsb">                   &quot;Nicholas C. Zakas&quot; </div><div class="t m0 x0 hb y3d0f ff106 fs6 fc0 sc0 ls21 wsb">                ], </div><div class="t m0 x0 hb y3d10 ff106 fs6 fc0 sc0 ls21 wsb">                edition: 3, </div><div class="t m0 x0 hb y3d11 ff106 fs6 fc0 sc0 ls21 wsb">                year: 2011 </div><div class="t m0 x0 hb y3d12 ff106 fs6 fc0 sc0 ls21 wsb">           }; </div><div class="t m0 x0 hb y3d13 ff106 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3d14 ff106 fs6 fc0 sc0 ls21 wsb">var jsonText = JSON.stringify(book); </div><div class="t m0 x2 hf y3d15 ff10b fs2 fc0 sc0 ls1b wsb">JSONStringifyExample01.htm </div></div></div>
<div id="pf248" class="pf w0 h0" data-page-no="248"><div class="pc pc248 w0 h0"><div class="t m0 x0 h2 y1 ffff fs0 fc0 sc0 ls7 ws0">566  第20章 JSON </div><div class="t m0 x0 h3 y2 ffff fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff105 fs2 fc0 sc0 ls8 ws1">这个例子使用JSON.stringify()把一个JavaScript对象序列化为一个JSON字符串，然后将它保</div><div class="t m0 x0 hc y4d ff105 fs2 fc0 sc0 ls8 ws1">存在变量jsonText中。默认情况下，JSON.stringify()输出的JSON字符串不包含任何空格字符或</div><div class="t m0 x0 hc y5 ff105 fs2 fc0 sc0 ls8 ws1">缩进，因此保存在jsonText中的字符串如下所示： </div><div class="t m0 x0 hb y6bd ff106 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y6be ff106 fs6 fc0 sc0 ls21 wsb">{&quot;title&quot;:&quot;Professional JavaScript&quot;,&quot;authors&quot;:[&quot;Nicholas C. Zakas&quot;],&quot;edition&quot;:3, </div><div class="t m0 x0 hb y6bf ff106 fs6 fc0 sc0 ls21 wsb">&quot;year&quot;:2011} </div><div class="t m0 x0 hb y1aeb ff106 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y7b1 ff105 fs2 fc0 sc0 ls8 ws1">在序列化JavaScript对象时，所有函数及原型成员都会被有意忽略，不体现在结果中。此外，值为</div><div class="t m0 x0 h5 ya85 ff106 fs1 fc0 sc0 ls9 ws2">undefined的任何属性也都会被跳过。结果中最终都是值为有效JSON数据类型的实例属性。 </div><div class="t m0 x0 h5 ya86 ff105 fs2 fc0 sc0 ls71">将JSON字符串直接传递给JSON.parse()就可以得到相应的JavaScript值。例如，使用下列代码</div><div class="t m0 x0 hc ya87 ff105 fs2 fc0 sc0 ls8 ws1">就可以创建与book类似的对象： </div><div class="t m0 x0 hb y2065 ff106 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2066 ff106 fs6 fc0 sc0 ls21 wsb">var bookCopy = JSON.parse(jsonText); </div><div class="t m0 x0 hb y2067 ff106 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y19bd ff105 fs2 fc0 sc0 ls8 ws1">注意，虽然book与bookCopy具有相同的属性，但它们是两个独立的、没有任何关系的对象。 </div><div class="t m0 x0 h5 y19be ff105 fs2 fc0 sc0 ls8 ws1">如果传给JSON.parse()的字符串不是有效的JSON，该方法会抛出错误。 </div><div class="t m0 x0 h20 y8f4 ff103 fs3 fc0 sc0 ls248 ws214">20.2.2 序列化选项 </div><div class="t m0 x0 h5 y69f ff105 fs2 fc0 sc0 ls8 ws1">实际上，JSON.stringify()除了要序列化的JavaScript对象外，还可以接收另外两个参数，这两</div><div class="t m0 x0 h5 y6a0 ff105 fs2 fc0 sc0 ls8 ws1">个参数用于指定以不同的方式序列化JavaScript对象。第一个参数是个过滤器，可以是一个数组，也可</div><div class="t m0 x0 h5 y3d17 ff105 fs2 fc0 sc0 ls8 ws1">以是一个函数；第二个参数是一个选项，表示是否在JSON字符串中保留缩进。单独或组合使用这两个</div><div class="t m0 x0 h5 y3d18 ff105 fs2 fc0 sc0 ls8 ws1">参数，可以更全面深入地控制JSON的序列化。 </div><div class="t m0 x0 h3c y3d19 ff103 fs2 fc0 sc0 ls2e wsb">1. 过滤结果 </div><div class="t m0 x0 ha4 y3d1a ff105 fs2 fc0 sc0 ls6 ws6">如果过滤器参数是数组，那么JSON.stringify()的结果中将只包含数组中列出的属性。来看下</div><div class="t m0 x0 h5 y2bd9 ff105 fs2 fc0 sc0 ls8 ws1">面的例子。 </div><div class="t m0 x0 hb y90c ff106 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3d1b ff106 fs6 fc0 sc0 ls21 wsb">var book = {  </div><div class="t m0 x0 hb y3d1c ff106 fs6 fc0 sc0 ls21 wsb">               &quot;title&quot;: &quot;Professional JavaScript&quot;, </div><div class="t m0 x0 hb y3d1d ff106 fs6 fc0 sc0 ls21 wsb">                &quot;authors&quot;: [ </div><div class="t m0 x0 hb y3d1e ff106 fs6 fc0 sc0 ls21 wsb">                   &quot;Nicholas C. Zakas&quot; </div><div class="t m0 x0 hb y3d1f ff106 fs6 fc0 sc0 ls21 wsb">                ], </div><div class="t m0 x0 hb y3d20 ff106 fs6 fc0 sc0 ls21 wsb">                edition: 3, </div><div class="t m0 x0 hb y3d21 ff106 fs6 fc0 sc0 ls21 wsb">                year: 2011 </div><div class="t m0 x0 hb y3d22 ff106 fs6 fc0 sc0 ls21 wsb">           }; </div><div class="t m0 x0 hb y3d23 ff106 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3d24 ff106 fs6 fc0 sc0 ls21 wsb">var jsonText = JSON.stringify(book, [&quot;title&quot;, &quot;edition&quot;]); </div><div class="t m0 x0 hb y3d25 ff106 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1b46 ff10b fs2 fc0 sc0 ls1b wsb">JSONStringifyExample01.htm </div><div class="t m0 x0 h4 y631 ff106 fs1 fc0 sc0 ls9 ws2">JSON.stringify()的第二个参数是一个数组，其中包含两个字符串：&quot;title&quot;和&quot;edition&quot;。这</div><div class="t m0 x0 h5 y3661 ff105 fs2 fc0 sc0 ls8 ws1">两个属性与将要序列化的对象中的属性是对应的，因此在返回的结果字符串中，就只会包含这两个属性： </div><div class="t m0 x0 hb y3d26 ff106 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3d27 ff106 fs6 fc0 sc0 ls21 wsb">{&quot;title&quot;:&quot;Professional JavaScript&quot;,&quot;edition&quot;:3} </div><div class="t m0 x0 hb y3d28 ff106 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y270c ff105 fs2 fc0 sc0 ls8 ws1">如果第二个参数是函数，行为会稍有不同。传入的函数接收两个参数，属性（键）名和属性值。根</div><div class="t m0 x0 h4 y3d29 ff105 fs2 fc0 sc0 ls8 ws1">据属性（键）名可以知道应该如何处理要序列化的对象中的属性。属性名只能是字符串，而在值并非键</div><div class="t m0 x0 h5 y3d2a ff105 fs2 fc0 sc0 ls8 ws1">值对儿结构的值时，键名可以是空字符串。 </div><div class="t m0 x0 h4 y3d2b ff105 fs2 fc0 sc0 ls19 ws1b">为了改变序列化对象的结果，函数返回的值就是相应键的值。不过要注意，如果函数返回了</div></div></div>
<div id="pf249" class="pf w0 h0" data-page-no="249"><div class="pc pc249 w0 h0"><div class="t m0 x2 h2 y1 ffff fs0 fc0 sc0 ls7 ws0">20.2 解析与序列化    567 </div><div class="t m0 x0 h3 y2 ffff fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff109 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff109 fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ff109 fs3 fc2 sc0 ls1d wsb">16 </div><div class="t m0 x3 h8 y20 ff109 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff109 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff109 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff109 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff109 fs3 fc2 sc0 ls1d wsb">20 </div><div class="t m0 x3 h8 y25 ff109 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff109 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff109 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ff109 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff109 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff106 fs1 fc0 sc0 ls9 ws2">undefined，那么相应的属性会被忽略。还是看一个例子吧。 </div><div class="t m0 x0 hb yfb2 ff106 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yfb3 ff106 fs6 fc0 sc0 ls21 wsb">var book = {  </div><div class="t m0 x0 hb yfb4 ff106 fs6 fc0 sc0 ls21 wsb">                &quot;title&quot;: &quot;Professional JavaScript&quot;, </div><div class="t m0 x0 hb yfb5 ff106 fs6 fc0 sc0 ls21 wsb">                &quot;authors&quot;: [ </div><div class="t m0 x0 hb yfb6 ff106 fs6 fc0 sc0 ls21 wsb">                    &quot;Nicholas C. Zakas&quot; </div><div class="t m0 x0 hb yfb7 ff106 fs6 fc0 sc0 ls21 wsb">                ], </div><div class="t m0 x0 hb yfb8 ff106 fs6 fc0 sc0 ls21 wsb">                edition: 3, </div><div class="t m0 x0 hb yfb9 ff106 fs6 fc0 sc0 ls21 wsb">                year: 2011 </div><div class="t m0 x0 hb yfba ff106 fs6 fc0 sc0 ls21 wsb">          }; </div><div class="t m0 x0 hb yfbb ff106 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2005 ff106 fs6 fc0 sc0 ls21 wsb">var jsonText = JSON.stringify(book, function(key, value){ </div><div class="t m0 x0 h15 y2006 ff10a fs6 fc0 sc0 ls21 wsb">    switch(key){ </div><div class="t m0 x0 h15 y30db ff10a fs6 fc0 sc0 ls21 wsb">        case &quot;authors&quot;: </div><div class="t m0 x0 h15 y3d2c ff10a fs6 fc0 sc0 ls21 wsb">            return value.join(&quot;,&quot;) </div><div class="t m0 x0 h15 y3d2d ff10a fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y3d2e ff10a fs6 fc0 sc0 ls21 wsb">        case &quot;year&quot;: </div><div class="t m0 x0 h15 y3d2f ff10a fs6 fc0 sc0 ls21 wsb">            return 5000; </div><div class="t m0 x0 h15 y3d30 ff10a fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y3d31 ff10a fs6 fc0 sc0 ls21 wsb">        case &quot;edition&quot;: </div><div class="t m0 x0 h15 y3d32 ff10a fs6 fc0 sc0 ls21 wsb">            return undefined; </div><div class="t m0 x0 h15 y3d33 ff10a fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y3d34 ff10a fs6 fc0 sc0 ls21 wsb">        default: </div><div class="t m0 x0 h15 y3d35 ff10a fs6 fc0 sc0 ls21 wsb">            return value; </div><div class="t m0 x0 h15 y3d36 ff10a fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y3d37 ff10a fs6 fc0 sc0 ls16f">}); </div><div class="t m0 x0 hb y3d38 ff106 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y3d39 ff10b fs2 fc0 sc0 ls1b wsb">JSONStringifyExample02.htm </div><div class="t m0 x0 h4 y29cc ff105 fs2 fc0 sc0 ls8 ws1">这里，函数过滤器根据传入的键来决定结果。如果键为&quot;authors&quot;，就将数组连接为一个字符串；</div><div class="t m0 x0 h1e y29cd ff105 fs2 fc0 sc0 ls8 ws1">如果键为&quot;year&quot;，则将其值设置为5000；如果键为&quot;edition&quot;，通过返回undefined删除该属性。</div><div class="t m0 x0 h4 y679 ff105 fs2 fc0 sc0 ls8 ws1">最后，一定要提供default项，此时返回传入的值，以便其他值都能正常出现在结果中。实际上，第</div><div class="t m0 x0 hc y3d3a ff105 fs2 fc0 sc0 ls8 ws1">一次调用这个函数过滤器，传入的键是一个空字符串，而值就是book对象。序列化后的JSON字符串</div><div class="t m0 x0 h5 y3d3b ff105 fs2 fc0 sc0 ls8 ws1">如下所示： </div><div class="t m0 x0 hb y3d3c ff106 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3d3d ff106 fs6 fc0 sc0 ls21 wsb">{&quot;title&quot;:&quot;Professional JavaScript&quot;,&quot;authors&quot;:&quot;Nicholas C. Zakas&quot;,&quot;year&quot;:5000} </div><div class="t m0 x0 hb y3d3e ff106 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3d3f ff105 fs2 fc0 sc0 ls8 ws1">要序列化的对象中的每一个对象都要经过过滤器，因此数组中的每个带有这些属性的对象经过过滤</div><div class="t m0 x0 hc y3d40 ff105 fs2 fc0 sc0 ls8 ws1">之后，每个对象都只会包含&quot;title&quot;、&quot;authors&quot;和&quot;year&quot;属性。 </div><div class="t m0 x0 hc y3d41 ffff fs2 fc0 sc0 ls47 wsaa">Firefox 3.5和3.6对JSON.stringify()的实现有一个bug，在将函数作为该方法的第二个参数时</div><div class="t m0 x0 h5 y3d42 ff105 fs2 fc0 sc0 ls8 ws1">这个bug就会出现，即这个函数只能作为过滤器：返回undefined意味着要跳过某个属性，而返回其</div><div class="t m0 x0 h5 y3d43 ff105 fs2 fc0 sc0 ls8 ws1">他任何值都会在结果中包含相应的属性。Firefox 4修复了这个bug。 </div><div class="t m0 x0 h3c y3d44 ff103 fs2 fc0 sc0 ls2e wsb">2. 字符串缩进 </div><div class="t m0 x0 h4 y107a ff106 fs1 fc0 sc0 ls9 ws2">JSON.stringify()方法的第三个参数用于控制结果中的缩进和空白符。如果这个参数是一个数</div><div class="t m0 x0 h5 y107b ff105 fs2 fc0 sc0 ls8 ws1">值，那它表示的是每个级别缩进的空格数。例如，要在每个级别缩进4个空格，可以这样写代码： </div><div class="t m0 x0 hb y11f4 ff106 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3d45 ff106 fs6 fc0 sc0 ls21 wsb">var book = {  </div><div class="t m0 x0 hb y3d46 ff106 fs6 fc0 sc0 ls21 wsb">                &quot;title&quot;: &quot;Professional JavaScript&quot;, </div><div class="t m0 x0 hb y3d47 ff106 fs6 fc0 sc0 ls21 wsb">                &quot;authors&quot;: [ </div><div class="t m0 x0 hb y3d48 ff106 fs6 fc0 sc0 ls21 wsb">                    &quot;Nicholas C. Zakas&quot; </div><div class="t m0 x0 hb y3d49 ff106 fs6 fc0 sc0 ls21 wsb">                ], </div><div class="t m0 x0 hb y3d4a ff106 fs6 fc0 sc0 ls21 wsb">                edition: 3, </div><div class="t m0 x0 hb y3d4b ff106 fs6 fc0 sc0 ls21 wsb">                year: 2011 </div></div></div>
<div id="pf24a" class="pf w0 h0" data-page-no="24a"><div class="pc pc24a w0 h0"><div class="t m0 x0 h2 y1 ffff fs0 fc0 sc0 ls7 ws0">568  第20章 JSON </div><div class="t m0 x0 h3 y2 ffff fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 ff106 fs6 fc0 sc0 ls21 wsb">           }; </div><div class="t m0 x0 hb y7a ff106 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y7b ff106 fs6 fc0 sc0 ls21 wsb">var jsonText = JSON.stringify(book, null, 4); </div><div class="t m0 x0 hb y105 ff106 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y106 ff10b fs2 fc0 sc0 ls1b wsb">JSONStringifyExample03.htm </div><div class="t m0 x0 h5 y107 ff105 fs2 fc0 sc0 ls8 ws1">保存在jsonText中的字符串如下所示： </div><div class="t m0 x0 hb y3d4d ff106 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3d4e ff106 fs6 fc0 sc0 ls21 wsb">{  </div><div class="t m0 x0 hb y3d4f ff106 fs6 fc0 sc0 ls21 wsb">    &quot;title&quot;: &quot;Professional JavaScript&quot;, </div><div class="t m0 x0 hb y3d50 ff106 fs6 fc0 sc0 ls21 wsb">    &quot;authors&quot;: [ </div><div class="t m0 x0 hb y3d51 ff106 fs6 fc0 sc0 ls21 wsb">        &quot;Nicholas C. Zakas&quot; </div><div class="t m0 x0 hb y3d52 ff106 fs6 fc0 sc0 ls21 wsb">    ], </div><div class="t m0 x0 hb y3d53 ff106 fs6 fc0 sc0 ls21 wsb">    &quot;edition&quot;: 3, </div><div class="t m0 x0 hb y3d54 ff106 fs6 fc0 sc0 ls21 wsb">    &quot;year&quot;: 2011 </div><div class="t m0 x0 hb y3d55 ff106 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y3d56 ff106 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y36e1 ff105 fs2 fc0 sc0 ls8 ws1">不知道读者注意到没有，JSON.stringify()也在结果字符串中插入了换行符以提高可读性。只要</div><div class="t m0 x0 h4 y3d57 ff105 fs2 fc0 sc0 ls8 ws1">传入有效的控制缩进的参数值，结果字符串就会包含换行符。（只缩进而不换行意义不大。）最大缩进空</div><div class="t m0 x0 h5 y3d58 ff105 fs2 fc0 sc0 ls8 ws1">格数为10，所有大于10的值都会自动转换为10。 </div><div class="t m0 x0 h5 y3d59 ff105 fs2 fc0 sc0 ls8 ws1">如果缩进参数是一个字符串而非数值，则这个字符串将在JSON字符串中被用作缩进字符（不再使</div><div class="t m0 x0 h5 y3d5a ff105 fs2 fc0 sc0 ls8 ws1">用空格）。在使用字符串的情况下，可以将缩进字符设置为制表符，或者两个短划线之类的任意字符。 </div><div class="t m0 x0 hb y2047 ff106 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3d5b ff106 fs6 fc0 sc0 ls21 wsb">var jsonText = JSON.stringify(book, null, &quot; - -&quot;); </div><div class="t m0 x0 hb y3d5c ff106 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 yc60 ff105 fs2 fc0 sc0 ls8 ws1">这样，jsonText中的字符串将变成如下所示： </div><div class="t m0 x0 hb y3d5d ff106 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3d5e ff106 fs6 fc0 sc0 ls21 wsb">{ </div><div class="t m0 x0 hb y3d5f ff106 fs6 fc0 sc0 ls21 wsb">--&quot;title&quot;: &quot;Professional JavaScript&quot;, </div><div class="t m0 x0 hb y3d60 ff106 fs6 fc0 sc0 ls21 wsb">--&quot;authors&quot;: [ </div><div class="t m0 x0 hb y3d61 ff106 fs6 fc0 sc0 ls21 wsb">----&quot;Nicholas C. Zakas&quot; </div><div class="t m0 x0 hb y3d62 ff106 fs6 fc0 sc0 ls21 wsb">--], </div><div class="t m0 x0 hb y3d63 ff106 fs6 fc0 sc0 ls21 wsb">--&quot;edition&quot;: 3, </div><div class="t m0 x0 hb y3d64 ff106 fs6 fc0 sc0 ls21 wsb">--&quot;year&quot;: 2011 </div><div class="t m0 x0 hb y3d65 ff106 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y3d66 ff106 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3d67 ff105 fs2 fc0 sc0 ls8 ws1">缩进字符串最长不能超过10个字符长。如果字符串长度超过了10个，结果中将只出现前 10个字</div><div class="t m0 x0 h5 y3d68 ff105 fs2 fc0 sc0 ls8">符。 </div><div class="t m0 x0 h47 y3d69 ff103 fs2 fc0 sc0 ls2e wsb">3. toJSON()方法 </div><div class="t m0 x0 h4 y3d6a ff105 fs2 fc0 sc0 ls8 ws1">有时候，JSON.stringify()还是不能满足对某些对象进行自定义序列化的需求。在这些情况下，</div><div class="t m0 x0 hc y3d6b ff105 fs2 fc0 sc0 ls8 ws1">可以给对象定义toJSON()方法，返回其自身的JSON数据格式。原生Date对象有一个toJSON()方法，</div><div class="t m0 x0 hc y3d6c ff105 fs2 fc0 sc0 ls8 ws1">能够将JavaScript的Date对象自动转换成ISO 8601日期字符串（与在Date对象上调用toISOString()</div><div class="t m0 x0 h5 y22cb ff105 fs2 fc0 sc0 ls8 ws1">的结果完全一样）。 </div><div class="t m0 x0 hc y29bc ff105 fs2 fc0 sc0 ls8 ws1">可以为任何对象添加toJSON()方法，比如： </div><div class="t m0 x0 hb y1a2 ff106 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3d6d ff106 fs6 fc0 sc0 ls21 wsb">var book = { </div><div class="t m0 x0 hb y3d6e ff106 fs6 fc0 sc0 ls21 wsb">            &quot;title&quot;: &quot;Professional JavaScript&quot;, </div><div class="t m0 x0 hb y3d6f ff106 fs6 fc0 sc0 ls21 wsb">             &quot;authors&quot;: [ </div><div class="t m0 x0 hb y3d70 ff106 fs6 fc0 sc0 ls21 wsb">                 &quot;Nicholas C. Zakas&quot; </div><div class="t m0 x0 hb y3d71 ff106 fs6 fc0 sc0 ls21 wsb">            ], </div><div class="t m0 x0 hb y3d72 ff106 fs6 fc0 sc0 ls21 wsb">            edition: 3, </div><div class="t m0 x0 hb y3d73 ff106 fs6 fc0 sc0 ls21 wsb">            year: 2011, </div><div class="t m0 x0 h15 y3d74 ff10a fs6 fc0 sc0 ls21 wsb">             toJSON: function(){ </div></div></div>
<div id="pf24b" class="pf w0 h0" data-page-no="24b"><div class="pc pc24b w0 h0"><div class="t m0 x2 h2 y1 ffff fs0 fc0 sc0 ls7 ws0">20.2 解析与序列化    569 </div><div class="t m0 x0 h3 y2 ffff fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff109 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff109 fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ff109 fs3 fc2 sc0 ls1d wsb">16 </div><div class="t m0 x3 h8 y20 ff109 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff109 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff109 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff109 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff109 fs3 fc2 sc0 ls1d wsb">20 </div><div class="t m0 x3 h8 y25 ff109 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff109 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff109 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ff109 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff109 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h15 y79 ff10a fs6 fc0 sc0 ls21 wsb">                      return this.title; </div><div class="t m0 x0 h15 y7a ff10a fs6 fc0 sc0 ls21 wsb">                 } </div><div class="t m0 x0 hb y7b ff106 fs6 fc0 sc0 ls21 wsb">           }; </div><div class="t m0 x0 hb y7c ff106 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y7d ff106 fs6 fc0 sc0 ls21 wsb">var jsonText = JSON.stringify(book); </div><div class="t m0 x2 hf yb9c ff10b fs2 fc0 sc0 ls1b wsb">JSONStringifyExample05.htm </div><div class="t m0 x0 h4 y3d75 ff105 fs2 fc0 sc0 ls8 ws1">以上代码在book对象上定义了一个toJSON()方法，该方法返回图书的书名。与Date对象类似，</div><div class="t m0 x0 h1e y3d76 ff105 fs2 fc0 sc0 ls8 ws1">这个对象也将被序列化为一个简单的字符串而非对象。可以让toJSON()方法返回任何值，它都能正常</div><div class="t m0 x0 h1e y3d77 ff105 fs2 fc0 sc0 ls6 ws6">工作。比如，可以让这个方法返回undefined，此时如果包含它的对象嵌入在另一个对象中，会导致</div><div class="t m0 x0 hc y3d78 ff105 fs2 fc0 sc0 ls8 ws1">它的值变成null，而如果它是顶级对象，结果就是undefined。 </div><div class="t m0 x0 h4 y3d79 ff106 fs1 fc0 sc0 ls9 ws2">toJSON()可以作为函数过滤器的补充，因此理解序列化的内部顺序十分重要。假设把一个对象传</div><div class="t m0 x0 hc y3d7a ff105 fs2 fc0 sc0 ls2cf">入JSON.stringify()，序列化该对象的顺序如下。 </div><div class="t m0 x0 hc y3d7b ffff fs2 fc0 sc0 ls13 wsb">(1) 如果存在toJSON()方法而且能通过它取得有效的值，则调用该方法。否则，返回对象本身。 </div><div class="t m0 x0 h5 y3d7c ffff fs2 fc0 sc0 ls13 wsb">(2) 如果提供了第二个参数，应用这个函数过滤器。传入函数过滤器的值是第(1)步返回的值。 </div><div class="t m0 x0 h5 y3d7d ffff fs2 fc0 sc0 ls13 wsb">(3) 对第(2)步返回的每个值进行相应的序列化。 </div><div class="t m0 x0 h5 y3d7e ffff fs2 fc0 sc0 ls13 wsb">(4) 如果提供了第三个参数，执行相应的格式化。 </div><div class="t m0 x0 h4b y3d7f ff105 fs2 fc0 sc0 ls8 ws1">无论是考虑定义toJSON()方法，还是考虑使用函数过滤器，亦或需要同时使用两者，理解这个顺</div><div class="t m0 x0 h5 y3d80 ff105 fs2 fc0 sc0 ls8 ws1">序都是至关重要的。 </div><div class="t m0 x0 h20 y501 ff103 fs3 fc0 sc0 ls248 ws214">20.2.3 解析选项 </div><div class="t m0 x0 h4 y585 ff106 fs1 fc0 sc0 ls9 ws2">JSON.parse()方法也可以接收另一个参数，该参数是一个函数，将在每个键值对儿上调用。为了</div><div class="t m0 x0 h5 y3d81 ff105 fs2 fc0 sc0 ls6 ws6">区别JSON.stringify()接收的替换（过滤）函数（replacer），这个函数被称为还原函数（reviver），</div><div class="t m0 x0 h4 y3d82 ff105 fs2 fc0 sc0 ls5 ws4">但实际上这两个函数的签名是相同的——它们都接收两个参数，一个键和一个值，而且都需要返回一</div><div class="t m0 x0 h5 y3d83 ff105 fs2 fc0 sc0 ls5 ws4">个值。 </div><div class="t m0 x0 h4b y3d84 ff105 fs2 fc0 sc0 ls6 ws6">如果还原函数返回undefined，则表示要从结果中删除相应的键；如果返回其他值，则将该值插</div><div class="t m0 x0 h5 y222d ff105 fs2 fc0 sc0 ls8 ws1">入到结果中。在将日期字符串转换为Date对象时，经常要用到还原函数。例如： </div><div class="t m0 x0 hb y3d85 ff106 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3d86 ff106 fs6 fc0 sc0 ls21 wsb">var book = {  </div><div class="t m0 x0 hb y3d87 ff106 fs6 fc0 sc0 ls21 wsb">              &quot;title&quot;: &quot;Professional JavaScript&quot;, </div><div class="t m0 x0 hb y3d88 ff106 fs6 fc0 sc0 ls21 wsb">               &quot;authors&quot;: [ </div><div class="t m0 x0 hb y3d89 ff106 fs6 fc0 sc0 ls21 wsb">                   &quot;Nicholas C. Zakas&quot; </div><div class="t m0 x0 hb y3d8a ff106 fs6 fc0 sc0 ls21 wsb">                ], </div><div class="t m0 x0 hb y3d8b ff106 fs6 fc0 sc0 ls21 wsb">                edition: 3, </div><div class="t m0 x0 hb y3d8c ff106 fs6 fc0 sc0 ls21 wsb">                year: 2011, </div><div class="t m0 x0 h15 y3d8d ff10a fs6 fc0 sc0 ls21 wsb">                releaseDate: new Date(2011, 11, 1) </div><div class="t m0 x0 hb y3d8e ff106 fs6 fc0 sc0 ls21 wsb">           }; </div><div class="t m0 x0 hb y3d8f ff106 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3d90 ff106 fs6 fc0 sc0 ls21 wsb">var jsonText = JSON.stringify(book); </div><div class="t m0 x0 hb y3d91 ff106 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y3d92 ff10a fs6 fc0 sc0 ls21 wsb">var bookCopy = JSON.parse(jsonText, function(key, value){ </div><div class="t m0 x0 h15 y3d93 ff10a fs6 fc0 sc0 ls21 wsb">    if (key == &quot;releaseDate&quot;){ </div><div class="t m0 x0 h15 y3d94 ff10a fs6 fc0 sc0 ls21 wsb">        return new Date(value); </div><div class="t m0 x0 h15 y3d95 ff10a fs6 fc0 sc0 ls21 wsb">    } else { </div><div class="t m0 x0 h15 y3d96 ff10a fs6 fc0 sc0 ls21 wsb">        return value; </div><div class="t m0 x0 h15 y3d97 ff10a fs6 fc0 sc0 ls21 wsb">    } </div></div></div>
<div id="pf24c" class="pf w0 h0" data-page-no="24c"><div class="pc pc24c w0 h0"><div class="t m0 x0 h2 y1 ffff fs0 fc0 sc0 ls7 ws0">570  第20章 JSON </div><div class="t m0 x0 h3 y2 ffff fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y79 ff10a fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 h15 y7a ff10a fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y7b ff10a fs6 fc0 sc0 ls21 wsb">alert(bookCopy.releaseDate.getFullYear()); </div><div class="t m0 x0 hb y105 ff106 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y106 ff10b fs2 fc0 sc0 ls1b wsb">JSONParseExample02.htm </div><div class="t m0 x0 h4 y107 ff105 fs2 fc0 sc0 ls8 ws1">以上代码先是为book对象新增了一个releaseDate 属性，该属性保存着一个Date对象。这个</div><div class="t m0 x0 h5 y108 ff105 fs2 fc0 sc0 ls8 ws1">对象在经过序列化之后变成了有效的JSON字符串，然后经过解析又在bookCopy中还原为一个 Date</div><div class="t m0 x0 h4 y109 ff105 fs2 fc0 sc0 lsa ws53">对象。还原函数在遇到&quot;releaseDate&quot;键时，会基于相应的值创建一个新的Date对象。结果就是</div><div class="t m0 x0 h4 y10a ff106 fs1 fc0 sc0 ls9 ws2">bookCopy.releaseDate属性中会保存一个Date 对象。正因为如此，才能基于这个对象调用</div><div class="t m0 x0 h5 y3d99 ff106 fs1 fc0 sc0 ls9 ws2">getFullYear()方法。 </div><div class="t m0 x0 hd y1543 ff103 fs7 fc0 sc0 ls245">20.3 小结 </div><div class="t m0 x0 h5 y3d9a ffff fs2 fc0 sc0 lsfa wsc9">JSON是一个轻量级的数据格式，可以简化表示复杂数据结构的工作量。JSON使用JavaScript语法</div><div class="t m0 x0 hc y3d9b ff105 fs2 fc0 sc0 ls8 ws1">的子集表示对象、数组、字符串、数值、布尔值和null。即使XML也能表示同样复杂的数据结果，但</div><div class="t m0 x0 h5 y385f ffff fs2 fc0 sc0 lsfa wsc9">JSON没有那么烦琐，而且在JavaScript中使用更便利。 </div><div class="t m0 x0 he y3d9c ffff fs2 fc0 sc0 ls25 ws61">ECMAScript 5定义了一个原生的JSON对象，可以用来将对象序列化为JSON 字符串或者将JSON</div><div class="t m0 x0 h5 y5d4 ff105 fs2 fc0 sc0 ls8 ws1">数据解析为JavaScript对象。JSON.stringify()和JSON.parse()方法分别用来实现上述两项功能。</div><div class="t m0 x0 h5 y3d9d ff105 fs2 fc0 sc0 ls8 ws1">这两个方法都有一些选项，通过它们可以改变过滤的方式，或者改变序列化的过程。 </div><div class="t m0 x0 h5 y3d9e ff105 fs2 fc0 sc0 ls8 ws1">原生的JSON对象也得到了很多浏览器的支持，比如IE8+、Firefox 3.5+、Safari 4+、Opera 10.5和</div><div class="t m0 x0 h5 y3d9f ffff fs2 fc0 sc0 ls50 ws41">Chrome。 </div><div class="t m0 x0 h5 y3da0 ffff fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3da1 ffff fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3da2 ffff fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3da3 ffff fs2 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf24d" class="pf w0 h0" data-page-no="24d"><div class="pc pc24d w0 h0"><div class="t m0 x4 h2 y1 ff10c fs0 fc0 sc0 ls7 ws0">21.1 XMLHttpRequest对象   571 </div><div class="t m0 x0 h3 y2 ff10c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff10e fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff10e fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ff10e fs3 fc2 sc0 ls1d wsb">16 </div><div class="t m0 x3 h8 y20 ff10e fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff10e fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff10e fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff10e fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff10e fs3 fc2 sc0 ls1d wsb">20 </div><div class="t m0 x3 h8 y25 ff10e fs3 fc2 sc0 ls1d wsb">21 </div><div class="t m0 x3 h8 y26 ff10e fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff10e fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ff10e fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff10e fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h9 y2a ff10f fs5 fc0 sc0 ls446 wsb">Ajax与Comet </div><div class="t m0 x0 h3c y2b ff110 fs2 fc0 sc0 ls8">本章内容 </div><div class="t m0 x0 h5 y2c ff112 fs1 fc0 sc0 ls2"> 使用XMLHttpRequest对象 </div><div class="t m0 x0 h5 y2d ff112 fs1 fc0 sc0 ls2"> 使用XMLHttpRequest事件 </div><div class="t m0 x0 h5 y2e ff112 fs1 fc0 sc0 ls2"> 跨域Ajax通信的限制 </div><div class="t m0 x0 h5 y8d9 ff10c fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x5 h5 y8da ff10c fs2 fc0 sc0 ls8 ws20">005年，Jesse James Garrett发表了一篇在线文章，题为“Ajax: A new Approach to Web </div><div class="t m0 x5 h5 y8db ff10c fs2 fc0 sc0 ls1b1 ws37a">Applications”（http://www.adaptivepath.com/ideas/essays/archives/000385.php）。他在这篇文章</div><div class="t m0 x0 h5 y8dc ff113 fs2 fc0 sc0 ls5 wsec">里介绍了一种技术，用他的话说，就叫Ajax，是对Asynchronous JavaScript + XML的简写。这一技术</div><div class="t m0 x0 h5 y8dd ff113 fs2 fc0 sc0 ls5 wsec">能够向服务器请求额外的数据而无须卸载页面，会带来更好的用户体验。Garrett还解释了怎样使用这</div><div class="t m0 x0 h5 y8de ff113 fs2 fc0 sc0 ls5 wsec">一技术改变自从Web诞生以来就一直沿用的“单击，等待”的交互模式。 </div><div class="t m0 x0 h13d y8df ff10c fs2 fc0 sc0 lsf wsa">Ajax技术的核心是XMLHttpRequest对象（简称XHR），这是由微软首先引入的一个特性，其他</div><div class="t m0 x0 h5 y1fcf ff113 fs2 fc0 sc0 ls8 wseb">浏览器提供商后来都提供了相同的实现。在XHR出现之前，Ajax式的通信必须借助一些hack手段来实</div><div class="t m0 x0 h5 y3055 ff113 fs2 fc0 sc0 ls6 wsf7">现，大多数是使用隐藏的框架或内嵌框架。XHR为向服务器发送请求和解析服务器响应提供了流畅的</div><div class="t m0 x0 h4 y3056 ff113 fs2 fc0 sc0 ls8 wseb">接口。能够以异步方式从服务器取得更多信息，意味着用户单击后，可以不必刷新页面也能取得新数据。</div><div class="t m0 x0 h5 y3057 ff113 fs2 fc0 sc0 ls8 wseb">也就是说，可以使用XHR对象取得新数据，然后再通过DOM 将新数据插入到页面中。另外，虽然名</div><div class="t m0 x0 h5 y3058 ff113 fs2 fc0 sc0 ls8 wseb">字中包含XML的成分，但Ajax通信与数据格式无关；这种技术就是无须刷新页面即可从服务器取得数</div><div class="t m0 x0 h5 y3da4 ff113 fs2 fc0 sc0 ls8 wseb">据，但不一定是XML数据。 </div><div class="t m0 x0 h5 y3da5 ff113 fs2 fc0 sc0 ls8 wseb">实际上，Garrett提到的这种技术已经存在很长时间了。在Garrett撰写那篇文章之前，人们通常将</div><div class="t m0 x0 h5 y3da6 ff113 fs2 fc0 sc0 ls8 wseb">这种技术叫做远程脚本（remote scripting），而且早在1998年就有人采用不同的手段实现了这种浏览器</div><div class="t m0 x0 h5 y3da7 ff113 fs2 fc0 sc0 ls8 wseb">与服务器的通信。再往前推，JavaScript需要通过Java applet或Flash电影等中间层向服务器发送请求。</div><div class="t m0 x0 h5 y3da8 ff113 fs2 fc0 sc0 ls3b">而XHR则将浏览器原生的通信能力提供给了开发人员，简化了实现同样操作的任务。 </div><div class="t m0 x0 h5 y3da9 ff113 fs2 fc0 sc0 ls8 wseb">在重命名为Ajax之后，大约是2005年底 2006年初，这种浏览器与服务器的通信技术可谓红极一</div><div class="t m0 x0 h5 y3daa ff113 fs2 fc0 sc0 ls8 wseb">时。人们对JavaScript和Web的全新认识，催生了很多使用原有特性的新技术和新模式。就目前来说，</div><div class="t m0 x0 h5 y3dab ff113 fs2 fc0 sc0 ls8 wseb">熟练使用XHR对象已经成为所有Web开发人员必须掌握的一种技能。 </div><div class="t m0 x0 hd yee0 ff111 fs7 fc0 sc0 ls245">21.1 XMLHttpRequest对象 </div><div class="t m0 x0 h5 y29 ff10c fs2 fc0 sc0 ls2a ws21">IE5是第一款引入XHR对象的浏览器。在IE5 中，XHR对象是通过MSXML库中的一个ActiveX</div><div class="t m0 x0 h5 y3dac ff113 fs2 fc0 sc0 ls339 ws2f0">对象实现的。因此，在IE中可能会遇到三种不同版本的 XHR对象，即MSXML2.XMLHttp、</div><div class="t m0 x0 h5 y3dad ff114 fs1 fc0 sc0 ls9 ws2">MSXML2.XMLHttp.3.0和MXSML2.XMLHttp.6.0。要使用MSXML库中的 XHR对象，需要像第18</div><div class="t m0 x0 h5 y3dae ff113 fs2 fc0 sc0 ls8 wseb">章讨论创建XML文档时一样，编写一个函数，例如： </div><div class="t m0 x0 hb y3daf ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h13e y12c6 ff111 fs1a fc0 sc0 ls411 wsb">2 </div><div class="t m0 x0 h11 y4b ff116 fsa fc0 sc0 ls8">第</div><div class="t m1 x0 h12 y4b ff117 fsb fc3 sc0 ls247">21</div><div class="t m0 x5 h9 y4b ff116 fsa fc0 sc0 ls8 ws1d">章 </div></div></div>
<div id="pf24e" class="pf w0 h0" data-page-no="24e"><div class="pc pc24e w0 h0"><div class="t m0 x0 h2 y1 ff10c fs0 fc0 sc0 ls7 ws0">572  第21章 Ajax与Comet </div><div class="t m0 x0 h3 y2 ff10c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h36 y79 ff114 fs6 fc0 sc0 ls21">//适用于IE7之前的版本 </div><div class="t m0 x0 hb y7a ff114 fs6 fc0 sc0 ls21 wsb">function createXHR(){ </div><div class="t m0 x0 hb y7b ff114 fs6 fc0 sc0 ls21 wsb">    if (typeof arguments.callee.activeXString != &quot;string&quot;){ </div><div class="t m0 x0 hb y7c ff114 fs6 fc0 sc0 ls21 wsb">        var versions = [&quot;MSXML2.XMLHttp.6.0&quot;, &quot;MSXML2.XMLHttp.3.0&quot;, </div><div class="t m0 x0 hb y7d ff114 fs6 fc0 sc0 ls21 wsb">                        &quot;MSXML2.XMLHttp&quot;], </div><div class="t m0 x0 hb y7e ff114 fs6 fc0 sc0 ls21 wsb">            i, len; </div><div class="t m0 x0 hb y7f ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y80 ff114 fs6 fc0 sc0 ls21 wsb">        for (i=0,len=versions.length; i &lt; len; i++){ </div><div class="t m0 x0 hb y81 ff114 fs6 fc0 sc0 ls21 wsb">            try { </div><div class="t m0 x0 hb y82 ff114 fs6 fc0 sc0 ls21 wsb">                new ActiveXObject(versions[i]); </div><div class="t m0 x0 hb y83 ff114 fs6 fc0 sc0 ls21 wsb">                arguments.callee.activeXString = versions[i]; </div><div class="t m0 x0 hb y84 ff114 fs6 fc0 sc0 ls21 wsb">                break; </div><div class="t m0 x0 hb y85 ff114 fs6 fc0 sc0 ls21 wsb">            } catch (ex){ </div><div class="t m0 x0 h16 y86 ff114 fs6 fc0 sc0 ls21 wsb">                //跳过 </div><div class="t m0 x0 hb y87 ff114 fs6 fc0 sc0 ls21 wsb">            } </div><div class="t m0 x0 hb y88 ff114 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y89 ff114 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y8a ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1823 ff114 fs6 fc0 sc0 ls21 wsb">    return new ActiveXObject(arguments.callee.activeXString); </div><div class="t m0 x0 hb y1824 ff114 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y3db0 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y2494 ff113 fs2 fc0 sc0 ls8 wseb">这个函数会尽力根据IE中可用的MSXML库的情况创建最新版本的XHR 对象。 </div><div class="t m0 x0 h5 y2795 ff10c fs2 fc0 sc0 ls46 ws37">IE7+、Firefox、Opera、Chrome和Safari都支持原生的XHR对象，在这些浏览器中创建XHR 对象</div><div class="t m0 x0 he y3db1 ff113 fs2 fc0 sc0 ls8 wseb">要像下面这样使用XMLHttpRequest构造函数。 </div><div class="t m0 x0 hb y23bb ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3db2 ff114 fs6 fc0 sc0 ls21 wsb">var xhr = new XMLHttpRequest(); </div><div class="t m0 x0 hb y3db3 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y74d ff113 fs2 fc0 sc0 ls8 wseb">假如你只想支持IE7及更高版本，那么大可丢掉前面定义的那个函数，而只用原生的XHR实现。</div><div class="t m0 x0 hc y74e ff113 fs2 fc0 sc0 ls8 wseb">但是，如果你必须还要支持IE的早期版本，那么则可以在这个createXHR()函数中加入对原生 XHR</div><div class="t m0 x0 h5 y74f ff113 fs2 fc0 sc0 ls8 wseb">对象的支持。 </div><div class="t m0 x0 hb y3db4 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3db5 ff114 fs6 fc0 sc0 ls21 wsb">function createXHR(){   </div><div class="t m0 x0 h15 y3db6 ff115 fs6 fc0 sc0 ls21 wsb">    if (typeof XMLHttpRequest != &quot;undefined&quot;){ </div><div class="t m0 x0 h15 y3db7 ff115 fs6 fc0 sc0 ls21 wsb">        return new XMLHttpRequest(); </div><div class="t m0 x0 h15 y3db8 ff115 fs6 fc0 sc0 ls21 wsb">    } else if (typeof ActiveXObject != &quot;undefined&quot;){ </div><div class="t m0 x0 hb y3db9 ff114 fs6 fc0 sc0 ls21 wsb">       if (typeof arguments.callee.activeXString != &quot;string&quot;){ </div><div class="t m0 x0 hb y3dba ff114 fs6 fc0 sc0 ls21 wsb">           var versions = [ &quot;MSXML2.XMLHttp.6.0&quot;, &quot;MSXML2.XMLHttp.3.0&quot;, </div><div class="t m0 x0 hb y3dbb ff114 fs6 fc0 sc0 ls21 wsb">                            &quot;MSXML2.XMLHttp&quot;], </div><div class="t m0 x0 hb y3dbc ff114 fs6 fc0 sc0 ls21 wsb">               i, len; </div><div class="t m0 x0 hb y3dbd ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3dbe ff114 fs6 fc0 sc0 ls21 wsb">           for (i=0,len=versions.length; i &lt; len; i++){ </div><div class="t m0 x0 hb y3dbf ff114 fs6 fc0 sc0 ls21 wsb">               try { </div><div class="t m0 x0 hb y3dc0 ff114 fs6 fc0 sc0 ls21 wsb">                   new ActiveXObject(versions[i]); </div><div class="t m0 x0 hb y3dc1 ff114 fs6 fc0 sc0 ls21 wsb">                   arguments.callee.activeXString = versions[i]; </div><div class="t m0 x0 hb y3dc2 ff114 fs6 fc0 sc0 ls21 wsb">                   break; </div><div class="t m0 x0 hb y3dc3 ff114 fs6 fc0 sc0 ls21 wsb">               } catch (ex){ </div><div class="t m0 x0 h16 y3dc4 ff114 fs6 fc0 sc0 ls21 wsb">                   //跳过 </div><div class="t m0 x0 hb y3dc5 ff114 fs6 fc0 sc0 ls21 wsb">               } </div><div class="t m0 x0 hb y3dc6 ff114 fs6 fc0 sc0 ls21 wsb">           } </div><div class="t m0 x0 hb y3dc7 ff114 fs6 fc0 sc0 ls21 wsb">       } </div><div class="t m0 x0 hb y3dc8 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3dc9 ff114 fs6 fc0 sc0 ls21 wsb">       return new ActiveXObject(arguments.callee.activeXString); </div><div class="t m0 x0 h15 y3dca ff115 fs6 fc0 sc0 ls21 wsb">    } else { </div><div class="t m0 x0 h15 y3dcb ff115 fs6 fc0 sc0 ls21 wsb">        throw new Error(&quot;No XHR object available.&quot;); </div><div class="t m0 x0 h15 y3dcc ff115 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y3dcd ff114 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y3dce ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y3dcf ff119 fs2 fc0 sc0 ls79 wsb">XHRExample01.htm </div></div></div>
<div id="pf24f" class="pf w0 h0" data-page-no="24f"><div class="pc pc24f w0 h0"><div class="t m0 x4 h2 y1 ff10c fs0 fc0 sc0 ls7 ws0">21.1 XMLHttpRequest对象   573 </div><div class="t m0 x0 h3 y2 ff10c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff10e fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff10e fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ff10e fs3 fc2 sc0 ls1d wsb">16 </div><div class="t m0 x3 h8 y20 ff10e fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff10e fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff10e fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff10e fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff10e fs3 fc2 sc0 ls1d wsb">20 </div><div class="t m0 x3 h8 y25 ff10e fs3 fc2 sc0 ls1d wsb">21 </div><div class="t m0 x3 h8 y26 ff10e fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff10e fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ff10e fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff10e fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff113 fs2 fc0 sc0 ls8 wseb">这个函数中新增的代码首先检测原生XHR对象是否存在，如果存在则返回它的新实例。如果原生</div><div class="t m0 x0 h5 y4d ff113 fs2 fc0 sc0 ls8 wseb">对象不存在，则检测ActiveX对象。如果这两种对象都不存在，就抛出一个错误。然后，就可以使用下</div><div class="t m0 x0 h5 yd8 ff113 fs2 fc0 sc0 ls8 wseb">面的代码在所有浏览器中创建XHR对象了。 </div><div class="t m0 x0 hb y6bd ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y6be ff114 fs6 fc0 sc0 ls21 wsb">var xhr = createXHR(); </div><div class="t m0 x0 hb y153b ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y6e5 ff113 fs2 fc0 sc0 ls8 wseb">由于其他浏览器中对XHR的实现与IE最早的实现是兼容的，因此就可以在所有浏览器中都以相同</div><div class="t m0 x0 hc y1727 ff113 fs2 fc0 sc0 ls8 wseb">方式使用上面创建的xhr对象。 </div><div class="t m0 x0 h20 y3dd0 ff111 fs3 fc0 sc0 ls248 ws214">21.1.1 XHR的用法 </div><div class="t m0 x0 h5 y3dd1 ff113 fs2 fc0 sc0 ls5 wsec">在使用XHR对象时，要调用的第一个方法是 open()，它接受3个参数：要发送的请求的类型</div><div class="t m0 x0 h5 y84d ff113 fs2 fc0 sc0 ls452">（&quot;get&quot;、&quot;post&quot;等）、请求的URL和表示是否异步发送请求的布尔值。下面就是调用这个方法的例子。 </div><div class="t m0 x0 hb y3abb ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3dd2 ff114 fs6 fc0 sc0 ls21 wsb">xhr.open(&quot;get&quot;, &quot;example.php&quot;, false); </div><div class="t m0 x0 hb y3dd3 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3dd4 ff113 fs2 fc0 sc0 ls8 wseb">这行代码会启动一个针对example.php的GET请求。有关这行代码，需要说明两点：一是 URL</div><div class="t m0 x0 h1e y3dd5 ff113 fs2 fc0 sc0 ls8 wseb">相对于执行代码的当前页面（当然也可以使用绝对路径）；二是调用open()方法并不会真正发送请求，</div><div class="t m0 x0 h5 y3dd6 ff113 fs2 fc0 sc0 ls8 wseb">而只是启动一个请求以备发送。 </div><div class="t m0 x5 h5 y3dd7 ff10d fs2 fc0 sc0 ls8 ws14">只能向同一个域中使用相同端口和协议的URL发送请求。如果URL与启动请求</div><div class="t m0 x5 h5 y3dd8 ff10d fs2 fc0 sc0 ls8 ws14">的页面有任何差别，都会引发安全错误。 </div><div class="t m0 x0 h13f y3dd9 ff113 fs2 fc0 sc0 ls8 wseb">要发送特定的请求，必须像下面这样调用send()方法： </div><div class="t m0 x0 hb yb58 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3dda ff114 fs6 fc0 sc0 ls21 wsb">xhr.open(&quot;get&quot;, &quot;example.txt&quot;, false); </div><div class="t m0 x0 hb y3ddb ff114 fs6 fc0 sc0 ls21 wsb">xhr.send(null); </div><div class="t m0 x0 hb y3ddc ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y30f6 ff119 fs2 fc0 sc0 ls79 wsb">XHRExample01.htm </div><div class="t m0 x0 h4 y3c0 ff113 fs2 fc0 sc0 ls8 wseb">这里的send()方法接收一个参数，即要作为请求主体发送的数据。如果不需要通过请求主体发送</div><div class="t m0 x0 h1e y3ddd ff113 fs2 fc0 sc0 ls6 wsf7">数据，则必须传入null，因为这个参数对有些浏览器来说是必需的。调用send()之后，请求就会被分</div><div class="t m0 x0 h5 y3c2 ff113 fs2 fc0 sc0 ls8 wseb">派到服务器。 </div><div class="t m0 x0 h5 y2e65 ff113 fs2 fc0 sc0 ls6 wsf7">由于这次请求是同步的，JavaScript代码会等到服务器响应之后再继续执行。在收到响应后，响应</div><div class="t m0 x0 h5 y3dde ff113 fs2 fc0 sc0 ls8 wseb">的数据会自动填充XHR对象的属性，相关的属性简介如下。 </div><div class="t m0 x0 h5 y3ddf ff112 fs1 fc0 sc0 ls2"> responseText：作为响应主体被返回的文本。 </div><div class="t m0 x0 h4 y1dac ff112 fs1 fc0 sc0 ls2"> responseXML：如果响应的内容类型是&quot;text/xml&quot;或&quot;application/xml&quot;，这个属性中将保</div><div class="t m0 x5 h5 y1dad ff113 fs2 fc0 sc0 ls8 wseb">存包含着响应数据的XML DOM文档。 </div><div class="t m0 x0 h5 y2f48 ff112 fs1 fc0 sc0 ls2"> status：响应的HTTP状态。 </div><div class="t m0 x0 h5 y1181 ff112 fs1 fc0 sc0 ls2"> statusText：HTTP状态的说明。 </div><div class="t m0 x0 hc y3de0 ff113 fs2 fc0 sc0 ls8 wseb">在接收到响应后，第一步是检查status属性，以确定响应已经成功返回。一般来说，可以将HTTP</div><div class="t m0 x0 h5 y2f4b ff113 fs2 fc0 sc0 ls8 wseb">状态代码为200作为成功的标志。此时，responseText属性的内容已经就绪，而且在内容类型正确的</div><div class="t m0 x0 h5 y384e ff113 fs2 fc0 sc0 ls8 wseb">情况下，responseXML也应该能够访问了。此外，状态代码为304表示请求的资源并没有被修改，可</div><div class="t m0 x0 h4 y384f ff113 fs2 fc0 sc0 ls8 wseb">以直接使用浏览器中缓存的版本；当然，也意味着响应是有效的。为确保接收到适当的响应，应该像下</div><div class="t m0 x0 h5 y3de1 ff113 fs2 fc0 sc0 ls8 wseb">面这样检查上述这两种状态代码： </div></div></div>
<div id="pf250" class="pf w0 h0" data-page-no="250"><div class="pc pc250 w0 h0"><div class="t m0 x0 h2 y1 ff10c fs0 fc0 sc0 ls7 ws0">574  第21章 Ajax与Comet </div><div class="t m0 x0 h3 y2 ff10c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 ff114 fs6 fc0 sc0 ls21 wsb">xhr.open(&quot;get&quot;, &quot;example.txt&quot;, false); </div><div class="t m0 x0 hb y7a ff114 fs6 fc0 sc0 ls21 wsb">xhr.send(null); </div><div class="t m0 x0 hb y7b ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y7c ff115 fs6 fc0 sc0 ls21 wsb">if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304){  </div><div class="t m0 x0 h15 y7d ff115 fs6 fc0 sc0 ls21 wsb">    alert(xhr.responseText); </div><div class="t m0 x0 h15 y7e ff115 fs6 fc0 sc0 ls21 wsb">} else { </div><div class="t m0 x0 h15 y7f ff115 fs6 fc0 sc0 ls21 wsb">    alert(&quot;Request was unsuccessful: &quot; + xhr.status); </div><div class="t m0 x0 h15 y80 ff115 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb yf4a ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf yf4b ff119 fs2 fc0 sc0 ls79 wsb">XHRExample01.htm </div><div class="t m0 x0 h4 yf4c ff113 fs2 fc0 sc0 ls8 wseb">根据返回的状态代码，这个例子可能会显示由服务器返回的内容，也可能会显示一条错误消息。我</div><div class="t m0 x0 h1e y3de3 ff113 fs2 fc0 sc0 ls8 wseb">们建议读者要通过检测status来决定下一步的操作，不要依赖statusText，因为后者在跨浏览器使</div><div class="t m0 x0 h1e yf4d ff113 fs2 fc0 sc0 ls8 wseb">用时不太可靠。另外，无论内容类型是什么，响应主体的内容都会保存到responseText属性中；而</div><div class="t m0 x0 hc y3de4 ff113 fs2 fc0 sc0 ls8 wseb">对于非XML数据而言，responseXML属性的值将为null。 </div><div class="t m0 x5 h5 y3de5 ff10d fs2 fc0 sc0 ls8 ws14">有的浏览器会错误地报告204状态代码。IE中XHR的ActiveX版本会将 204设</div><div class="t m0 x0 h5 y3de6 ff10d fs2 fc0 sc0 ls8 ws14">置为1223，而IE中原生的XHR则会将 204规范化为200。Opera会在取得204时报</div><div class="t m0 x0 h141 y3de7 ff10d fs2 fc0 sc0 ls453">告status的值为0。 </div><div class="t m0 x0 h4 y3de8 ff113 fs2 fc0 sc0 ls19 wsfb">像前面这样发送同步请求当然没有问题，但多数情况下，我们还是要发送异步请求，才能让</div><div class="t m0 x0 h5 y3de9 ff10c fs2 fc0 sc0 lsb ws5">JavaScript继续执行而不必等待响应。此时，可以检测XHR对象的readyState属性，该属性表示请求</div><div class="t m0 x0 h5 y3dea ff10c fs2 fc0 sc0 ls8">/响应过程的当前活动阶段。这个属性可取的值如下。 </div><div class="t m0 x0 h5 y2a17 ff112 fs1 fc0 sc0 ls2"> 0：未初始化。尚未调用open()方法。 </div><div class="t m0 x0 h5 y39a7 ff112 fs1 fc0 sc0 ls2"> 1：启动。已经调用open()方法，但尚未调用send()方法。 </div><div class="t m0 x0 h5 y206 ff112 fs1 fc0 sc0 ls2"> 2：发送。已经调用send()方法，但尚未接收到响应。 </div><div class="t m0 x0 h5 y2a1a ff112 fs1 fc0 sc0 ls2"> 3：接收。已经接收到部分响应数据。 </div><div class="t m0 x0 h5 y3deb ff112 fs1 fc0 sc0 ls2"> 4：完成。已经接收到全部响应数据，而且已经可以在客户端使用了。 </div><div class="t m0 x0 h1e y3dec ff113 fs2 fc0 sc0 ls8 wseb">只要readyState属性的值由一个值变成另一个值，都会触发一次readystatechange事件。可</div><div class="t m0 x0 h5 y3ded ff113 fs2 fc0 sc0 ls8 wseb">以利用这个事件来检测每次状态变化后readyState的值。通常，我们只对readyState 值为4的阶</div><div class="t m0 x0 h1e y2a1e ff113 fs2 fc0 sc0 ls8 wseb">段感兴趣，因为这时所有数据都已经就绪。不过，必须在调用open()之前指定onreadystatechange</div><div class="t m0 x0 h5 y3dee ff113 fs2 fc0 sc0 ls8 wseb">事件处理程序才能确保跨浏览器兼容性。下面来看一个例子。 </div><div class="t m0 x0 hb y3def ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3df0 ff114 fs6 fc0 sc0 ls21 wsb">var xhr = createXHR(); </div><div class="t m0 x0 hb y3df1 ff114 fs6 fc0 sc0 ls21 wsb">xhr.onreadystatechange = function(){ </div><div class="t m0 x0 hb y3df2 ff115 fs6 fc0 sc0 ls21 wsb">    if (xhr.readyState == 4){ </div><div class="t m0 x0 hb y3df3 ff115 fs6 fc0 sc0 ls21 wsb">        if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304){ </div><div class="t m0 x0 hb y3df4 ff115 fs6 fc0 sc0 ls21 wsb">             alert(xhr.responseText); </div><div class="t m0 x0 hb y3df5 ff115 fs6 fc0 sc0 ls21 wsb">        } else { </div><div class="t m0 x0 hb y3df6 ff115 fs6 fc0 sc0 ls21 wsb">             alert(&quot;Request was unsuccessful: &quot; + xhr.status); </div><div class="t m0 x0 hb y3df7 ff115 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y3df8 ff115 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y3df9 ff114 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y3dfa ff114 fs6 fc0 sc0 ls21 wsb">xhr.open(&quot;get&quot;, &quot;example.txt&quot;, true); </div><div class="t m0 x0 hb y3dfb ff114 fs6 fc0 sc0 ls21 wsb">xhr.send(null); </div><div class="t m0 x0 hb y3dfc ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y3dfd ff119 fs2 fc0 sc0 ls2b wsb">XHRAsyncExample01.htm </div></div></div>
<div id="pf251" class="pf w0 h0" data-page-no="251"><div class="pc pc251 w0 h0"><div class="t m0 x4 h2 y1 ff10c fs0 fc0 sc0 ls7 ws0">21.1 XMLHttpRequest对象   575 </div><div class="t m0 x0 h3 y2 ff10c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff10e fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff10e fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ff10e fs3 fc2 sc0 ls1d wsb">16 </div><div class="t m0 x3 h8 y20 ff10e fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff10e fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff10e fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff10e fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff10e fs3 fc2 sc0 ls1d wsb">20 </div><div class="t m0 x3 h8 y25 ff10e fs3 fc2 sc0 ls1d wsb">21 </div><div class="t m0 x3 h8 y26 ff10e fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff10e fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ff10e fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff10e fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff113 fs2 fc0 sc0 ls1f ws108">以上代码利用DOM 0级方法为XHR对象添加了事件处理程序，原因是并非所有浏览器都支持DOM 2</div><div class="t m0 x0 h1e y4d ff113 fs2 fc0 sc0 ls1f ws108">级方法。与其他事件处理程序不同，这里没有向onreadystatechange事件处理程序中传递event对象；</div><div class="t m0 x0 hc y5 ff113 fs2 fc0 sc0 ls1f ws108">必须通过XHR对象本身来确定下一步该怎么做。 </div><div class="t m0 x5 h40 y59e ff10d fs2 fc0 sc0 ls8 ws14">这个例子在onreadystatechange事件处理程序中使用了xhr对象，没有使用</div><div class="t m0 x5 ha y3dfe ff114 fs1 fc0 sc0 ls9 ws2">this对象，原因是onreadystatechange事件处理程序的作用域问题。如果使用</div><div class="t m0 x5 ha y5a0 ff114 fs1 fc0 sc0 ls9 ws2">this对象，在有的浏览器中会导致函数执行失败，或者导致错误发生。因此，使用</div><div class="t m0 x5 h5 y3dff ff10d fs2 fc0 sc0 ls8 ws14">实际的XHR对象实例变量是较为可靠的一种方式。 </div><div class="t m0 x0 h44 y3e00 ff113 fs2 fc0 sc0 ls8 wseb">另外，在接收到响应之前还可以调用abort()方法来取消异步请求，如下所示： </div><div class="t m0 x0 hb y3e01 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3e02 ff114 fs6 fc0 sc0 ls21 wsb">xhr.abort(); </div><div class="t m0 x0 hb y3e03 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 yeea ff113 fs2 fc0 sc0 ls8 wseb">调用这个方法后，XHR对象会停止触发事件，而且也不再允许访问任何与响应有关的对象属性。在</div><div class="t m0 x0 hc yeeb ff113 fs2 fc0 sc0 ls8 wseb">终止请求之后，还应该对XHR对象进行解引用操作。由于内存原因，不建议重用XHR对象。 </div><div class="t m0 x0 h20 y28d5 ff111 fs3 fc0 sc0 ls248 ws214">21.1.2 HTTP头部信息 </div><div class="t m0 x0 h5 y3e04 ff113 fs2 fc0 sc0 ls8 wseb">每个HTTP请求和响应都会带有相应的头部信息，其中有的对开发人员有用，有的也没有什么用。</div><div class="t m0 x0 h5 y2a83 ff114 fs1 fc0 sc0 ls9 ws2">XHR对象也提供了操作这两种头部（即请求头部和响应头部）信息的方法。 </div><div class="t m0 x0 hc yd26 ff113 fs2 fc0 sc0 ls8 wseb">默认情况下，在发送XHR请求的同时，还会发送下列头部信息。 </div><div class="t m0 x0 h5 y2a84 ff112 fs1 fc0 sc0 ls2"> Accept：浏览器能够处理的内容类型。 </div><div class="t m0 x0 h5 y16b ff112 fs1 fc0 sc0 ls2"> Accept-Charset：浏览器能够显示的字符集。 </div><div class="t m0 x0 h5 y2a85 ff112 fs1 fc0 sc0 ls2"> Accept-Encoding：浏览器能够处理的压缩编码。 </div><div class="t m0 x0 h5 y2a86 ff112 fs1 fc0 sc0 ls2"> Accept-Language：浏览器当前设置的语言。 </div><div class="t m0 x0 h5 y2a87 ff112 fs1 fc0 sc0 ls2"> Connection：浏览器与服务器之间连接的类型。 </div><div class="t m0 x0 h5 yfce ff112 fs1 fc0 sc0 ls2"> Cookie：当前页面设置的任何Cookie。 </div><div class="t m0 x0 h5 yfcf ff112 fs1 fc0 sc0 ls2"> Host：发出请求的页面所在的域 。 </div><div class="t m0 x0 h5 y3e05 ff112 fs1 fc0 sc0 ls2"> Referer：发出请求的页面的URI。注意，HTTP规范将这个头部字段拼写错了，而为保证与规</div><div class="t m0 x5 h5 y3e06 ff113 fs2 fc0 sc0 ls8 wseb">范一致，也只能将错就错了。（这个英文单词的正确拼法应该是referrer。） </div><div class="t m0 x0 h5 y1260 ff112 fs1 fc0 sc0 ls2"> User-Agent：浏览器的用户代理字符串。 </div><div class="t m0 x0 h4 y3e07 ff113 fs2 fc0 sc0 ls8 wseb">虽然不同浏览器实际发送的头部信息会有所不同，但以上列出的基本上是所有浏览器都会发送的。</div><div class="t m0 x0 h1e y3e08 ff113 fs2 fc0 sc0 ls8 wseb">使用setRequestHeader()方法可以设置自定义的请求头部信息。这个方法接受两个参数：头部字段</div><div class="t m0 x0 h1e y3e09 ff113 fs2 fc0 sc0 ls8 wseb">的名称和头部字段的值。要成功发送请求头部信息，必须在调用open()方法之后且调用send()方法</div><div class="t m0 x0 hc y3e0a ff113 fs2 fc0 sc0 ls8 wseb">之前调用setRequestHeader()，如下面的例子所示。 </div><div class="t m0 x0 hb y3e0b ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3e0c ff114 fs6 fc0 sc0 ls21 wsb">var xhr = createXHR();  </div><div class="t m0 x0 hb y3e0d ff114 fs6 fc0 sc0 ls21 wsb">xhr.onreadystatechange = function(){ </div><div class="t m0 x0 hb y3e0e ff114 fs6 fc0 sc0 ls21 wsb">    if (xhr.readyState == 4){ </div><div class="t m0 x0 hb y3e0f ff114 fs6 fc0 sc0 ls21 wsb">        if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304){ </div><div class="t m0 x0 hb y3e10 ff114 fs6 fc0 sc0 ls21 wsb">            alert(xhr.responseText); </div><div class="t m0 x0 hb y3e11 ff114 fs6 fc0 sc0 ls21 wsb">        } else { </div><div class="t m0 x0 hb y3e12 ff114 fs6 fc0 sc0 ls21 wsb">            alert(&quot;Request was unsuccessful: &quot; + xhr.status); </div><div class="t m0 x0 hb y3e13 ff114 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y3e14 ff114 fs6 fc0 sc0 ls21 wsb">    } </div></div></div>
<div id="pf252" class="pf w0 h0" data-page-no="252"><div class="pc pc252 w0 h0"><div class="t m0 x0 h2 y1 ff10c fs0 fc0 sc0 ls7 ws0">576  第21章 Ajax与Comet </div><div class="t m0 x0 h3 y2 ff10c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 ff114 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y7a ff114 fs6 fc0 sc0 ls21 wsb">xhr.open(&quot;get&quot;, &quot;example.php&quot;, true); </div><div class="t m0 x0 h15 y7b ff115 fs6 fc0 sc0 ls21 wsb">xhr.setRequestHeader(&quot;MyHeader&quot;, &quot;MyValue&quot;); </div><div class="t m0 x0 hb y7c ff114 fs6 fc0 sc0 ls21 wsb">xhr.send(null); </div><div class="t m0 x0 hb y3e16 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf y3e17 ff119 fs2 fc0 sc0 ls1b wsb">XHRRequestHeadersExample01.htm </div><div class="t m0 x0 h4 y3e18 ff113 fs2 fc0 sc0 ls8 wseb">服务器在接收到这种自定义的头部信息之后，可以执行相应的后续操作。我们建议读者使用自定义</div><div class="t m0 x0 h4 y3e19 ff113 fs2 fc0 sc0 ls8 wseb">的头部字段名称，不要使用浏览器正常发送的字段名称，否则有可能会影响服务器的响应。有的浏览器</div><div class="t m0 x0 h5 y3e1a ff113 fs2 fc0 sc0 ls8 wseb">允许开发人员重写默认的头部信息，但有的浏览器则不允许这样做。 </div><div class="t m0 x0 h1c y3e1b ff113 fs2 fc0 sc0 ls8 wseb">调用XHR对象的getResponseHeader()方法并传入头部字段名称，可以取得相应的响应头部信</div><div class="t m0 x0 h1e y3e1c ff113 fs2 fc0 sc0 ls6 wsf7">息。而调用getAllResponseHeaders()方法则可以取得一个包含所有头部信息的长字符串。来看下</div><div class="t m0 x0 h5 y3e1d ff113 fs2 fc0 sc0 ls8 wseb">面的例子。 </div><div class="t m0 x0 hb y114a ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3e1e ff114 fs6 fc0 sc0 ls21 wsb">var myHeader = xhr.getResponseHeader(&quot;MyHeader&quot;); </div><div class="t m0 x0 hb y3e1f ff114 fs6 fc0 sc0 ls21 wsb">var allHeaders = xhr.getAllResponseHeaders(); </div><div class="t m0 x0 hb y3e20 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3e21 ff113 fs2 fc0 sc0 ls8 wseb">在服务器端，也可以利用头部信息向浏览器发送额外的、结构化的数据。在没有自定义信息的情况</div><div class="t m0 x0 hc y3e22 ff113 fs2 fc0 sc0 ls8 wseb">下，getAllResponseHeaders()方法通常会返回如下所示的多行文本内容： </div><div class="t m0 x0 hb yd23 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3e23 ff114 fs6 fc0 sc0 ls21 wsb">Date: Sun, 14 Nov 2004 18:04:03 GMT </div><div class="t m0 x0 hb y3e24 ff114 fs6 fc0 sc0 ls21 wsb">Server: Apache/1.3.29 (Unix) </div><div class="t m0 x0 hb y3e25 ff114 fs6 fc0 sc0 ls21 wsb">Vary: Accept </div><div class="t m0 x0 hb y3e26 ff114 fs6 fc0 sc0 ls21 wsb">X-Powered-By: PHP/4.3.8 </div><div class="t m0 x0 hb y3e27 ff114 fs6 fc0 sc0 ls21 wsb">Connection: close </div><div class="t m0 x0 hb y3e28 ff114 fs6 fc0 sc0 ls21 wsb">Content-Type: text/html; charset=iso-8859-1 </div><div class="t m0 x0 hb y3e29 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y2878 ff113 fs2 fc0 sc0 ls8 wseb">这种格式化的输出可以方便我们检查响应中所有头部字段的名称，而不必一个一个地检查某个字段</div><div class="t m0 x0 h5 y3e2a ff113 fs2 fc0 sc0 ls8 wseb">是否存在。 </div><div class="t m0 x0 h20 y1d0b ff111 fs3 fc0 sc0 ls248 ws214">21.1.3 GET请求 </div><div class="t m0 x0 h4 y3b0e ff114 fs1 fc0 sc0 ls9 ws2">GET是最常见的请求类型，最常用于向服务器查询某些信息。必要时，可以将查询字符串参数追加</div><div class="t m0 x0 h5 y3e2b ff113 fs2 fc0 sc0 ls3b">到URL的末尾，以便将信息发送给服务器。对XHR而言，位于传入open()方法的URL末尾的查询字</div><div class="t m0 x0 h5 y3e2c ff113 fs2 fc0 sc0 ls8 wseb">符串必须经过正确的编码才行。 </div><div class="t m0 x0 h1c y3e2d ff113 fs2 fc0 sc0 ls8 wseb">使用GET请求经常会发生的一个错误，就是查询字符串的格式有问题。查询字符串中每个参数的名</div><div class="t m0 x0 hc y3e2e ff113 fs2 fc0 sc0 ls8 wseb">称和值都必须使用encodeURIComponent()进行编码，然后才能放到URL的末尾；而且所有名-值对</div><div class="t m0 x0 h5 y3e2f ff113 fs2 fc0 sc0 ls8 wseb">儿都必须由和号（&amp;）分隔，如下面的例子所示。 </div><div class="t m0 x0 hb ye3b ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3e30 ff114 fs6 fc0 sc0 ls21 wsb">xhr.open(&quot;get&quot;, &quot;example.php?name1=value1&amp;name2=value2&quot;, true); </div><div class="t m0 x0 hb y3e31 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3e32 ff113 fs2 fc0 sc0 ls8 wseb">下面这个函数可以辅助向现有URL的末尾添加查询字符串参数： </div><div class="t m0 x0 hb y25eb ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3e33 ff114 fs6 fc0 sc0 ls21 wsb">function addURLParam(url, name, value) {  </div><div class="t m0 x0 hb y3e34 ff114 fs6 fc0 sc0 ls21 wsb">    url += (url.indexOf(&quot;?&quot;) == -1 ? &quot;?&quot; : &quot;&amp;&quot;); </div><div class="t m0 x0 hb y3e35 ff114 fs6 fc0 sc0 ls21 wsb">    url += encodeURIComponent(name) + &quot;=&quot; + encodeURIComponent(value); </div><div class="t m0 x0 hb y3e36 ff114 fs6 fc0 sc0 ls21 wsb">    return url; </div><div class="t m0 x0 hb y3e37 ff114 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y3e38 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3e39 ff113 fs2 fc0 sc0 ls8 wseb">这个addURLParam()函数接受三个参数：要添加参数的URL、参数的名称和参数的值。这个函数</div><div class="t m0 x0 h5 y516 ff113 fs2 fc0 sc0 ls8 wseb">首先检查URL是否包含问号（以确定是否已经有参数存在）。如果没有，就添加一个问号；否则，就添</div><div class="t m0 x0 h5 y2762 ff113 fs2 fc0 sc0 ls8 wseb">加一个和号。然后，将参数名称和值进行编码，再添加到URL的末尾。最后返回添加参数之后的URL。 </div></div></div>
<div id="pf253" class="pf w0 h0" data-page-no="253"><div class="pc pc253 w0 h0"><div class="t m0 x4 h2 y1 ff10c fs0 fc0 sc0 ls7 ws0">21.1 XMLHttpRequest对象   577 </div><div class="t m0 x0 h3 y2 ff10c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff10e fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff10e fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ff10e fs3 fc2 sc0 ls1d wsb">16 </div><div class="t m0 x3 h8 y20 ff10e fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff10e fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff10e fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff10e fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff10e fs3 fc2 sc0 ls1d wsb">20 </div><div class="t m0 x3 h8 y25 ff10e fs3 fc2 sc0 ls1d wsb">21 </div><div class="t m0 x3 h8 y26 ff10e fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff10e fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ff10e fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff10e fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff113 fs2 fc0 sc0 ls8 wseb">下面是使用这个函数来构建请求URL的示例。 </div><div class="t m0 x0 hb yfb2 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yfb3 ff114 fs6 fc0 sc0 ls21 wsb">var url = &quot;example.php&quot;; </div><div class="t m0 x0 hb yfb4 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 yfb5 ff114 fs6 fc0 sc0 ls21">//添加参数 </div><div class="t m0 x0 hb yfb6 ff114 fs6 fc0 sc0 ls21 wsb">url = addURLParam(url, &quot;name&quot;, &quot;Nicholas&quot;); </div><div class="t m0 x0 hb yfb7 ff114 fs6 fc0 sc0 ls21 wsb">url = addURLParam(url, &quot;book&quot;, &quot;Professional JavaScript&quot;); </div><div class="t m0 x0 hb yfb8 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 yfb9 ff114 fs6 fc0 sc0 ls21">//初始化请求 </div><div class="t m0 x0 hb yfba ff114 fs6 fc0 sc0 ls21 wsb">xhr.open(&quot;get&quot;, url, false); </div><div class="t m0 x0 hb y3bec ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3bed ff113 fs2 fc0 sc0 ls8 wseb">在这里使用addURLParam()函数可以确保查询字符串的格式良好，并可靠地用于XHR对象。 </div><div class="t m0 x0 h20 y47c ff111 fs3 fc0 sc0 ls248 ws214">21.1.4 POST请求 </div><div class="t m0 x0 h4 y1f14 ff113 fs2 fc0 sc0 ls8 wseb">使用频率仅次于GET的是POST请求，通常用于向服务器发送应该被保存的数据。POST 请求应该</div><div class="t m0 x0 h1e y1d96 ff113 fs2 fc0 sc0 ls8 wseb">把数据作为请求的主体提交，而GET请求传统上不是这样。POST请求的主体可以包含非常多的数据，</div><div class="t m0 x0 h1e y3e3a ff113 fs2 fc0 sc0 ls8 wseb">而且格式不限。在open()方法第一个参数的位置传入&quot;post&quot;，就可以初始化一个POST请求，如下面</div><div class="t m0 x0 h5 y1f16 ff113 fs2 fc0 sc0 ls8 wseb">的例子所示。 </div><div class="t m0 x0 hb y27fd ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3e3b ff114 fs6 fc0 sc0 ls21 wsb">xhr.open(&quot;post&quot;, &quot;example.php&quot;, true); </div><div class="t m0 x0 hb y3e3c ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y219b ff113 fs2 fc0 sc0 ls8 wseb">发送POST请求的第二步就是向send()方法中传入某些数据。由于XHR最初的设计主要是为了处</div><div class="t m0 x0 h5 y3e3d ff113 fs2 fc0 sc0 ls3b">理XML，因此可以在此传入XML DOM文档，传入的文档经序列化之后将作为请求主体被提交到服务</div><div class="t m0 x0 h5 y3e3e ff113 fs2 fc0 sc0 ls8 wseb">器。当然，也可以在此传入任何想发送到服务器的字符串。 </div><div class="t m0 x0 he y3e3f ff113 fs2 fc0 sc0 ls8 wseb">默认情况下，服务器对POST请求和提交Web表单的请求并不会一视同仁。因此，服务器端必须有</div><div class="t m0 x0 h5 y3e40 ff113 fs2 fc0 sc0 ls8 wseb">程序来读取发送过来的原始数据，并从中解析出有用的部分。不过，我们可以使用XHR来模仿表单提</div><div class="t m0 x0 h1c y3e41 ff113 fs2 fc0 sc0 ls8 wseb">交：首先将Content-Type头部信息设置为application/x-www-form-urlencoded，也就是表单</div><div class="t m0 x0 h5 y30ce ff113 fs2 fc0 sc0 ls8 wseb">提交时的内容类型，其次是以适当的格式创建一个字符串。第14章曾经讨论过，POST数据的格式与查</div><div class="t m0 x0 h5 y3e42 ff113 fs2 fc0 sc0 ls8 wseb">询字符串格式相同。如果需要将页面中表单的数据进行序列化，然后再通过XHR发送到服务器，那么</div><div class="t m0 x0 he y3e43 ff113 fs2 fc0 sc0 ls8 wseb">就可以使用第14章介绍的serialize()函数来创建这个字符串： </div><div class="t m0 x0 hb y3e44 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3e45 ff114 fs6 fc0 sc0 ls21 wsb">function submitData(){  </div><div class="t m0 x0 hb y3e46 ff114 fs6 fc0 sc0 ls21 wsb">    var xhr = createXHR(); </div><div class="t m0 x0 hb y3e47 ff114 fs6 fc0 sc0 ls21 wsb">    xhr.onreadystatechange = function(){ </div><div class="t m0 x0 hb y3e48 ff114 fs6 fc0 sc0 ls21 wsb">        if (xhr.readyState == 4){ </div><div class="t m0 x0 hb y3e49 ff114 fs6 fc0 sc0 ls21 wsb">            if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304){ </div><div class="t m0 x0 hb y3e4a ff114 fs6 fc0 sc0 ls21 wsb">                alert(xhr.responseText); </div><div class="t m0 x0 hb y3e4b ff114 fs6 fc0 sc0 ls21 wsb">            } else { </div><div class="t m0 x0 hb y3e4c ff114 fs6 fc0 sc0 ls21 wsb">                alert(&quot;Request was unsuccessful: &quot; + xhr.status); </div><div class="t m0 x0 hb y3e4d ff114 fs6 fc0 sc0 ls21 wsb">            } </div><div class="t m0 x0 hb y3e4e ff114 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y3e4f ff114 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 h143 y3e50 ff11a fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3e51 ff115 fs6 fc0 sc0 ls21 wsb">    xhr.open(&quot;post&quot;, &quot;postexample.php&quot;, true); </div><div class="t m0 x0 h15 y3e52 ff115 fs6 fc0 sc0 ls21 wsb">    xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;); </div><div class="t m0 x0 h15 y3e53 ff115 fs6 fc0 sc0 ls21 wsb">    var form = document.getElementById(&quot;user-info&quot;); </div><div class="t m0 x0 h15 y3e54 ff115 fs6 fc0 sc0 ls21 wsb">    xhr.send(serialize(form)); </div><div class="t m0 x0 hb y3e55 ff114 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y3e56 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y3e57 ff119 fs2 fc0 sc0 ls7a wsb">XHRPostExample01.htm </div></div></div>
<div id="pf254" class="pf w0 h0" data-page-no="254"><div class="pc pc254 w0 h0"><div class="t m0 x0 h2 y1 ff10c fs0 fc0 sc0 ls7 ws0">578  第21章 Ajax与Comet </div><div class="t m0 x0 h3 y2 ff10c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff113 fs2 fc0 sc0 ls8 wseb">这个函数可以将ID为&quot;user-info&quot;的表单中的数据序列化之后发送给服务器。而下面的示例PHP</div><div class="t m0 x0 hc y4d ff113 fs2 fc0 sc0 ls8 wseb">文件postexample.php就可以通过$_POST取得提交的数据了： </div><div class="t m0 x0 hb y2d8 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2d9 ff114 fs6 fc0 sc0 ls21 wsb">&lt;?php  </div><div class="t m0 x0 hb y2da ff114 fs6 fc0 sc0 ls21 wsb">    header(&quot;Content-Type: text/plain&quot;); </div><div class="t m0 x0 hb y2db ff114 fs6 fc0 sc0 ls21 wsb">    echo &lt;&lt;&lt;EOF </div><div class="t m0 x0 h16 y2dc ff114 fs6 fc0 sc0 ls21 wsb">Name: {$_POST[‘user-name’]} </div><div class="t m0 x0 h16 y2dd ff114 fs6 fc0 sc0 ls21 wsb">Email: {$_POST[‘user-email’]} </div><div class="t m0 x0 hb y9e2 ff114 fs6 fc0 sc0 ls21 wsb">EOF; </div><div class="t m0 x0 hb y9e3 ff114 fs6 fc0 sc0 ls21 wsb">?&gt; </div><div class="t m0 x0 hb y3467 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf yf6c ff119 fs2 fc0 sc0 ls79 wsb">postexample.php </div><div class="t m0 x0 h4 y3468 ff113 fs2 fc0 sc0 ls8 wseb">如果不设置Content-Type头部信息，那么发送给服务器的数据就不会出现在$_POST超级全局变</div><div class="t m0 x0 hc y3469 ff113 fs2 fc0 sc0 ls8 wseb">量中。这时候，要访问同样的数据，就必须借助$HTTP_RAW_POST_DATA。 </div><div class="t m0 x5 ha y3e59 ff10d fs2 fc0 sc0 ls184">与GET请求相比，POST请求消耗的资源会更多一些。从性能角度来看，以发送</div><div class="t m0 x0 h18 y3e5a ff10d fs2 fc0 sc0 ls8 ws14">相同的数据计，GET请求的速度最多可达到POST请求的两倍。 </div><div class="t m0 x0 hd y1602 ff111 fs7 fc0 sc0 ls245">21.2 XMLHttpRequest 2级 </div><div class="t m0 x0 h5 y5fc ff113 fs2 fc0 sc0 lsa ws10a">鉴于XHR已经得到广泛接受，成为了事实标准，W3C也着手制定相应的标准以规范其行为。</div><div class="t m0 x0 h5 y3e5b ff10c fs2 fc0 sc0 lsc1 ws20c">XMLHttpRequest 1级只是把已有的XHR对象的实现细节描述了出来。而XMLHttpRequest 2级则进一步</div><div class="t m0 x0 h5 y3e5c ff113 fs2 fc0 sc0 ls8 wseb">发展了XHR。并非所有浏览器都完整地实现了XMLHttpRequest 2级规范，但所有浏览器都实现了它规</div><div class="t m0 x0 h5 y3e5d ff113 fs2 fc0 sc0 ls8 wseb">定的部分内容。 </div><div class="t m0 x0 h20 yd2a ff111 fs3 fc0 sc0 ls248 ws214">21.2.1 FormData </div><div class="t m0 x0 h5 y2f62 ff113 fs2 fc0 sc0 ls24 wsf5">现代Web应用中频繁使用的一项功能就是表单数据的序列化，XMLHttpRequest 2 级为此定义了</div><div class="t m0 x0 h5 y3e5e ff114 fs1 fc0 sc0 ls9 ws2">FormData类型。FormData为序列化表单以及创建与表单格式相同的数据（用于通过XHR传输）提供</div><div class="t m0 x0 hc y3e5f ff113 fs2 fc0 sc0 ls8 wseb">了便利。下面的代码创建了一个FormData对象，并向其中添加了一些数据。 </div><div class="t m0 x0 hb y3e60 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3e61 ff114 fs6 fc0 sc0 ls21 wsb">var data = new FormData(); </div><div class="t m0 x0 hb y3e62 ff114 fs6 fc0 sc0 ls21 wsb">data.append(&quot;name&quot;, &quot;Nicholas&quot;); </div><div class="t m0 x0 hb y3e63 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3e64 ff113 fs2 fc0 sc0 ls8 wseb">这个append()方法接收两个参数：键和值，分别对应表单字段的名字和字段中包含的值。可以像</div><div class="t m0 x0 h1e y3e65 ff113 fs2 fc0 sc0 ls8 wseb">这样添加任意多个键值对儿。而通过向FormData构造函数中传入表单元素，也可以用表单元素的数据</div><div class="t m0 x0 h5 y3e66 ff113 fs2 fc0 sc0 ls8 wseb">预先向其中填入键值对儿： </div><div class="t m0 x0 hb y1505 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3e67 ff114 fs6 fc0 sc0 ls21 wsb">var data = new FormData(document.forms[0]); </div><div class="t m0 x0 hb y3e68 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y23f3 ff113 fs2 fc0 sc0 ls8 wseb">创建了FormData的实例后，可以将它直接传给XHR的send()方法，如下所示： </div><div class="t m0 x0 hb y3e69 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3e6a ff114 fs6 fc0 sc0 ls21 wsb">var xhr = createXHR(); </div><div class="t m0 x0 hb y3e6b ff114 fs6 fc0 sc0 ls21 wsb">xhr.onreadystatechange = function(){ </div><div class="t m0 x0 hb y3e6c ff114 fs6 fc0 sc0 ls21 wsb">    if (xhr.readyState == 4){ </div><div class="t m0 x0 hb y3e6d ff114 fs6 fc0 sc0 ls21 wsb">        if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304){ </div><div class="t m0 x0 hb y3e6e ff114 fs6 fc0 sc0 ls21 wsb">            alert(xhr.responseText); </div></div></div>
<div id="pf255" class="pf w0 h0" data-page-no="255"><div class="pc pc255 w0 h0"><div class="t m0 x4 h2 y1 ff10c fs0 fc0 sc0 ls7 ws0">21.2 XMLHttpRequest 2级  579 </div><div class="t m0 x0 h3 y2 ff10c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff10e fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff10e fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ff10e fs3 fc2 sc0 ls1d wsb">16 </div><div class="t m0 x3 h8 y20 ff10e fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff10e fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff10e fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff10e fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff10e fs3 fc2 sc0 ls1d wsb">20 </div><div class="t m0 x3 h8 y25 ff10e fs3 fc2 sc0 ls1d wsb">21 </div><div class="t m0 x3 h8 y26 ff10e fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff10e fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ff10e fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff10e fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y79 ff114 fs6 fc0 sc0 ls21 wsb">        } else { </div><div class="t m0 x0 hb y7a ff114 fs6 fc0 sc0 ls21 wsb">            alert(&quot;Request was unsuccessful: &quot; + xhr.status); </div><div class="t m0 x0 hb y7b ff114 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y7c ff114 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y7d ff114 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y7e ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y7f ff114 fs6 fc0 sc0 ls21 wsb">xhr.open(&quot;post&quot;,&quot;postexample.php&quot;, true); </div><div class="t m0 x0 hb y80 ff115 fs6 fc0 sc0 ls21 wsb">var form = document.getElementById(&quot;user-info&quot;); </div><div class="t m0 x0 h15 y81 ff115 fs6 fc0 sc0 ls21 wsb">xhr.send(new FormData(form)); </div><div class="t m0 x0 h15 y1107 ff115 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1108 ff119 fs2 fc0 sc0 ls7a wsb">XHRFormDataExample01.htm </div><div class="t m0 x0 h5 y1109 ff113 fs2 fc0 sc0 ls8 wseb">使用FormData的方便之处体现在不必明确地在XHR对象上设置请求头部。XHR 对象能够识别传</div><div class="t m0 x0 hc y2b13 ff113 fs2 fc0 sc0 ls8 wseb">入的数据类型是FormData的实例，并配置适当的头部信息。 </div><div class="t m0 x0 hc y3e6f ff113 fs2 fc0 sc0 ls8 wseb">支持FormData的浏览器有Firefox 4+、Safari 5+、Chrome和Android 3+版WebKit 。 </div><div class="t m0 x0 h20 y3e70 ff111 fs3 fc0 sc0 ls248 ws214">21.2.2 超时设定 </div><div class="t m0 x0 h5 yb7a ff10c fs2 fc0 sc0 ls2a ws21">IE8为XHR对象添加了一个 timeout属性，表示请求在等待响应多少毫秒之后就终止。在给</div><div class="t m0 x0 h4 y3e71 ff114 fs1 fc0 sc0 ls9 ws2">timeout设置一个数值后，如果在规定的时间内浏览器还没有接收到响应，那么就会触发timeout事</div><div class="t m0 x0 hc y1276 ff113 fs2 fc0 sc0 ls8 wseb">件，进而会调用ontimeout事件处理程序。这项功能后来也被收入了XMLHttpRequest 2级规范中。来</div><div class="t m0 x0 h5 y3e72 ff113 fs2 fc0 sc0 ls8 wseb">看下面的例子。 </div><div class="t m0 x0 hb y3e73 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3e74 ff114 fs6 fc0 sc0 ls21 wsb">var xhr = createXHR(); </div><div class="t m0 x0 hb y3e75 ff114 fs6 fc0 sc0 ls21 wsb">xhr.onreadystatechange = function(){ </div><div class="t m0 x0 hb y3e76 ff114 fs6 fc0 sc0 ls21 wsb">    if (xhr.readyState == 4){ </div><div class="t m0 x0 hb y3e77 ff114 fs6 fc0 sc0 ls21 wsb">        try { </div><div class="t m0 x0 hb y3e78 ff114 fs6 fc0 sc0 ls21 wsb">            if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304){ </div><div class="t m0 x0 hb y3e79 ff114 fs6 fc0 sc0 ls21 wsb">                alert(xhr.responseText); </div><div class="t m0 x0 hb y3e7a ff114 fs6 fc0 sc0 ls21 wsb">            } else { </div><div class="t m0 x0 hb y3e7b ff114 fs6 fc0 sc0 ls21 wsb">                alert(&quot;Request was unsuccessful: &quot; + xhr.status); </div><div class="t m0 x0 hb y3e7c ff114 fs6 fc0 sc0 ls21 wsb">            } </div><div class="t m0 x0 hb y3e7d ff114 fs6 fc0 sc0 ls21 wsb">        } catch (ex){ </div><div class="t m0 x0 h145 y3e7e ff114 fs6 fc0 sc0 ls21 wsb">            //假设由ontimeout事件处理程序处理 </div><div class="t m0 x0 hb y3e7f ff114 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y3e80 ff114 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y3e81 ff114 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y3e82 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3e83 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3e84 ff114 fs6 fc0 sc0 ls21 wsb">xhr.open(&quot;get&quot;, &quot;timeout.php&quot;, true); </div><div class="t m0 x0 h16 y3e85 ff115 fs6 fc0 sc0 ls21 wsb">xhr.timeout = 1000; //将超时设置为1秒钟（仅适用于IE8+） </div><div class="t m0 x0 h15 y3e86 ff115 fs6 fc0 sc0 ls21 wsb">xhr.ontimeout = function(){ </div><div class="t m0 x0 h15 y3e87 ff115 fs6 fc0 sc0 ls21 wsb">    alert(&quot;Request did not return in a second.&quot;); </div><div class="t m0 x0 h15 y3e88 ff115 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y3e89 ff114 fs6 fc0 sc0 ls21 wsb">xhr.send(null); </div><div class="t m0 x0 hb y3e8a ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y39d ff119 fs2 fc0 sc0 ls2f wsb">XHRTimeoutExample01.htm </div><div class="t m0 x0 h5 y3b15 ff113 fs2 fc0 sc0 ls8 wseb">这个例子示范了如何使用timeout属性。将这个属性设置为1000毫秒，意味着如果请求在1秒钟</div><div class="t m0 x0 h1e y3b16 ff113 fs2 fc0 sc0 ls8 wseb">内还没有返回，就会自动终止。请求终止时，会调用ontimeout事件处理程序。但此时readyState</div><div class="t m0 x0 h5 ybc6 ff113 fs2 fc0 sc0 ls8 wseb">可能已经改变为4了，这意味着会调用onreadystatechange事件处理程序。可是，如果在超时终止</div><div class="t m0 x0 h4 y3e8b ff113 fs2 fc0 sc0 ls8 wseb">请求之后再访问status属性，就会导致错误。为避免浏览器报告错误，可以将检查status属性的语</div></div></div>
<div id="pf256" class="pf w0 h0" data-page-no="256"><div class="pc pc256 w0 h0"><div class="t m0 x0 h2 y1 ff10c fs0 fc0 sc0 ls7 ws0">580  第21章 Ajax与Comet </div><div class="t m0 x0 h3 y2 ff10c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff113 fs2 fc0 sc0 ls8 wseb">句封装在一个try-catch语句当中。 </div><div class="t m0 x0 h5 y4d ff113 fs2 fc0 sc0 ls8 wseb">在写作本书时，IE 8+仍然是唯一支持超时设定的浏览器。 </div><div class="t m0 x0 h20 y3e8c ff111 fs3 fc0 sc0 ls248 ws214">21.2.3 overrideMimeType()方法 </div><div class="t m0 x0 h5 y3e8d ff10c fs2 fc0 sc0 ls47 ws38">Firefox最早引入了overrideMimeType()方法，用于重写XHR响应的 MIME类型。这个方法后</div><div class="t m0 x0 h5 y3e8e ff113 fs2 fc0 sc0 ls8 wseb">来也被纳入了XMLHttpRequest 2级规范。因为返回响应的MIME类型决定了XHR对象如何处理它，所</div><div class="t m0 x0 h5 y3e8f ff113 fs2 fc0 sc0 ls8 wseb">以提供一种方法能够重写服务器返回的MIME类型是很有用的。 </div><div class="t m0 x0 h14 y3e90 ff113 fs2 fc0 sc0 ls8 wseb">比如，服务器返回的MIME类型是text/plain，但数据中实际包含的是XML。根据MIME 类型，</div><div class="t m0 x0 h5 y32cd ff113 fs2 fc0 sc0 ls8 wseb">即使数据是XML，responseXML属性中仍然是null。通过调用overrideMimeType()方法，可以保</div><div class="t m0 x0 h5 y3e91 ff113 fs2 fc0 sc0 ls8 wseb">证把响应当作XML而非纯文本来处理。 </div><div class="t m0 x0 hb y3e92 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3e93 ff114 fs6 fc0 sc0 ls21 wsb">var xhr = createXHR(); </div><div class="t m0 x0 hb y3e94 ff114 fs6 fc0 sc0 ls21 wsb">xhr.open(&quot;get&quot;, &quot;text.php&quot;, true); </div><div class="t m0 x0 h15 y3e95 ff115 fs6 fc0 sc0 ls21 wsb">xhr.overrideMimeType(&quot;text/xml&quot;); </div><div class="t m0 x0 hb y3e96 ff114 fs6 fc0 sc0 ls21 wsb">xhr.send(null); </div><div class="t m0 x0 hb y3e97 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y2307 ff113 fs2 fc0 sc0 ls8 wseb">这个例子强迫XHR对象将响应当作XML而非纯文本来处理。调用overrideMimeType()必须在</div><div class="t m0 x0 h5 y3bf2 ff114 fs1 fc0 sc0 ls9 ws2">send()方法之前，才能保证重写响应的MIME类型。 </div><div class="t m0 x0 hc y3bf3 ff113 fs2 fc0 sc0 ls8 wseb">支持overrideMimeType()方法的浏览器有Firefox、Safari 4+、Opera 10.5和Chrome。 </div><div class="t m0 x0 hd y3e98 ff111 fs7 fc0 sc0 ls245">21.3 进度事件 </div><div class="t m0 x0 h5 y232a ff10c fs2 fc0 sc0 lsb ws210">Progress Events规范是W3C的一个工作草案，定义了与客户端服务器通信有关的事件。这些事件最</div><div class="t m0 x0 h5 y2d66 ff113 fs2 fc0 sc0 ls8 wseb">早其实只针对XHR操作，但目前也被其他API借鉴。有以下6个进度事件。 </div><div class="t m0 x0 h5 y264f ff112 fs1 fc0 sc0 ls2"> loadstart：在接收到响应数据的第一个字节时触发。 </div><div class="t m0 x0 h5 y3e99 ff112 fs1 fc0 sc0 ls2"> progress：在接收响应期间持续不断地触发。 </div><div class="t m0 x0 h5 y3e9a ff112 fs1 fc0 sc0 ls2"> error：在请求发生错误时触发。 </div><div class="t m0 x0 h5 y119f ff112 fs1 fc0 sc0 ls2"> abort：在因为调用abort()方法而终止连接时触发。 </div><div class="t m0 x0 h5 y24ca ff112 fs1 fc0 sc0 ls2"> load：在接收到完整的响应数据时触发。 </div><div class="t m0 x0 h5 y30fc ff112 fs1 fc0 sc0 ls2"> loadend：在通信完成或者触发error、abort或load事件后触发。 </div><div class="t m0 x0 h4 y3e9b ff113 fs2 fc0 sc0 ls8 wseb">每个请求都从触发loadstart事件开始，接下来是一或多个progress事件，然后触发 error、</div><div class="t m0 x0 h5 y1ff9 ff114 fs1 fc0 sc0 ls9 ws2">abort或load事件中的一个，最后以触发loadend事件结束。 </div><div class="t m0 x0 h5 y3e9c ff113 fs2 fc0 sc0 ls8 wseb">支持前5个事件的浏览器有Firefox 3.5+、Safari 4+、Chrome、iOS版Safari和Android版WebK it。</div><div class="t m0 x0 he y3e9d ff10c fs2 fc0 sc0 ls2b ws22">Opera（从第11版开始）、IE 8+只支持load事件。目前还没有浏览器支持loadend事件。 </div><div class="t m0 x0 h5 y1422 ff113 fs2 fc0 sc0 ls8 wseb">这些事件大都很直观，但其中两个事件有一些细节需要注意。 </div><div class="t m0 x0 h20 y22f3 ff111 fs3 fc0 sc0 ls248 ws214">21.3.1 load事件 </div><div class="t m0 x0 h5 y2af ff10c fs2 fc0 sc0 ls47 ws38">Firefox在实现XHR对象的某个版本时，曾致力于简化异步交互模型。最终，Firefox实现中引入了</div><div class="t m0 x0 h4 y3ad2 ff114 fs1 fc0 sc0 ls9 ws2">load事件，用以替代readystatechange事件。响应接收完毕后将触发load事件，因此也就没有必</div><div class="t m0 x0 h1e y3e9e ff113 fs2 fc0 sc0 ls8 wseb">要去检查readyState属性了。而onload事件处理程序会接收到一个 event对象，其target属性</div><div class="t m0 x0 h5 y81d ff113 fs2 fc0 sc0 ls8 wseb">就指向XHR对象实例，因而可以访问到XHR对象的所有方法和属性。然而，并非所有浏览器都为这个</div></div></div>
<div id="pf257" class="pf w0 h0" data-page-no="257"><div class="pc pc257 w0 h0"><div class="t m0 x2 h2 y1 ff10c fs0 fc0 sc0 ls7 ws0">21.3 进度事件    581 </div><div class="t m0 x0 h3 y2 ff10c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff10e fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff10e fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ff10e fs3 fc2 sc0 ls1d wsb">16 </div><div class="t m0 x3 h8 y20 ff10e fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff10e fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff10e fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff10e fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff10e fs3 fc2 sc0 ls1d wsb">20 </div><div class="t m0 x3 h8 y25 ff10e fs3 fc2 sc0 ls1d wsb">21 </div><div class="t m0 x3 h8 y26 ff10e fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff10e fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ff10e fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff10e fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff113 fs2 fc0 sc0 ls8 wseb">事件实现了适当的事件对象。结果，开发人员还是要像下面这样被迫使用XHR对象变量。 </div><div class="t m0 x0 hb yfb2 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yfb3 ff114 fs6 fc0 sc0 ls21 wsb">var xhr = createXHR(); </div><div class="t m0 x0 h15 yfb4 ff115 fs6 fc0 sc0 ls21 wsb">xhr.onload = function(){ </div><div class="t m0 x0 h15 yfb5 ff115 fs6 fc0 sc0 ls21 wsb">    if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304){ </div><div class="t m0 x0 h15 yfb6 ff115 fs6 fc0 sc0 ls21 wsb">        alert(xhr.responseText); </div><div class="t m0 x0 h15 yfb7 ff115 fs6 fc0 sc0 ls21 wsb">    } else { </div><div class="t m0 x0 h15 yfb8 ff115 fs6 fc0 sc0 ls21 wsb">        alert(&quot;Request was unsuccessful: &quot; + xhr.status); </div><div class="t m0 x0 h15 yfb9 ff115 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 h15 yfba ff115 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb yfbb ff114 fs6 fc0 sc0 ls21 wsb">xhr.open(&quot;get&quot;, &quot;altevents.php&quot;, true); </div><div class="t m0 x0 hb y2005 ff114 fs6 fc0 sc0 ls21 wsb">xhr.send(null); </div><div class="t m0 x0 hb y3e9f ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1af ff119 fs2 fc0 sc0 ls138 wsb">XHRProgressEventExample01.htm </div><div class="t m0 x0 h4 yf28 ff113 fs2 fc0 sc0 ls8 wseb">只要浏览器接收到服务器的响应，不管其状态如何，都会触发load事件。而这意味着你必须要检</div><div class="t m0 x0 h5 y3ea0 ff113 fs2 fc0 sc0 ls459">查status属性，才能确定数据是否真的已经可用了。Firefox、Opera、Chrome和Safari都支持 load</div><div class="t m0 x0 h5 y3ea1 ff113 fs2 fc0 sc0 ls8">事件。 </div><div class="t m0 x0 h20 y405 ff111 fs3 fc0 sc0 ls248 ws214">21.3.2 progress事件 </div><div class="t m0 x0 h5 y3ea2 ff10c fs2 fc0 sc0 lsb ws5">Mozilla对XHR的另一个革新是添加了progress事件，这个事件会在浏览器接收新数据期间周期</div><div class="t m0 x0 h1e y1a72 ff113 fs2 fc0 sc0 ls8 wseb">性地触发。而onprogress事件处理程序会接收到一个event对象，其 target属性是XHR对象，但</div><div class="t m0 x0 hc y3ea3 ff113 fs2 fc0 sc0 ls8 wseb">包含着三个额外的属性：lengthComputable、position和totalSize。其中，lengthComputable </div><div class="t m0 x0 h1e y3ea4 ff113 fs2 fc0 sc0 lsa ws10a">是一个表示进度信息是否可用的布尔值，position表示已经接收的字节数，totalSize表示根据</div><div class="t m0 x0 h4 y3ea5 ff114 fs1 fc0 sc0 ls9 ws2">Content-Length响应头部确定的预期字节数。有了这些信息，我们就可以为用户创建一个进度指示器</div><div class="t m0 x0 h5 y32da ff113 fs2 fc0 sc0 ls8 wseb">了。下面展示了为用户创建进度指示器的一个示例。 </div><div class="t m0 x0 hb y1fee ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3ea6 ff114 fs6 fc0 sc0 ls21 wsb">var xhr = createXHR(); </div><div class="t m0 x0 hb y3ea7 ff114 fs6 fc0 sc0 ls21 wsb">xhr.onload = function(event){ </div><div class="t m0 x0 hb y3ea8 ff114 fs6 fc0 sc0 ls21 wsb">    if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || </div><div class="t m0 x0 hb y3ea9 ff114 fs6 fc0 sc0 ls21 wsb">            xhr.status == 304){ </div><div class="t m0 x0 hb y3eaa ff114 fs6 fc0 sc0 ls21 wsb">        alert(xhr.responseText); </div><div class="t m0 x0 hb y3eab ff114 fs6 fc0 sc0 ls21 wsb">    } else { </div><div class="t m0 x0 hb y3eac ff114 fs6 fc0 sc0 ls21 wsb">        alert(&quot;Request was unsuccessful: &quot; + xhr.status); </div><div class="t m0 x0 hb y3ead ff114 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y3eae ff114 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 h15 y3eaf ff115 fs6 fc0 sc0 ls21 wsb">xhr.onprogress = function(event){ </div><div class="t m0 x0 h15 y3eb0 ff115 fs6 fc0 sc0 ls21 wsb">    var divStatus = document.getElementById(&quot;status&quot;); </div><div class="t m0 x0 h15 y3eb1 ff115 fs6 fc0 sc0 ls21 wsb">    if (event.lengthComputable){ </div><div class="t m0 x0 h15 y3eb2 ff115 fs6 fc0 sc0 ls21 wsb">        divStatus.innerHTML = &quot;Received &quot; + event.position + &quot; of &quot; + </div><div class="t m0 x0 h15 y3eb3 ff115 fs6 fc0 sc0 ls21 wsb">            event.totalSize +&quot; bytes&quot;; </div><div class="t m0 x0 h15 y3eb4 ff115 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 h15 y3eb5 ff115 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y3eb6 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3eb7 ff114 fs6 fc0 sc0 ls21 wsb">xhr.open(&quot;get&quot;, &quot;altevents.php&quot;, true); </div><div class="t m0 x0 hb y3eb8 ff114 fs6 fc0 sc0 ls21 wsb">xhr.send(null); </div><div class="t m0 x0 hb y3eb9 ff114 fs6 fc0 sc0 ls8 wsb">  </div><div class="t m0 x2 hf y21ff ff119 fs2 fc0 sc0 ls138 wsb">XHRProgressEventExample01.htm </div><div class="t m0 x0 h4 y3eba ff113 fs2 fc0 sc0 ls8 wseb">为确保正常执行，必须在调用open()方法之前添加onprogress事件处理程序。在前面的例子中，</div></div></div>
<div id="pf258" class="pf w0 h0" data-page-no="258"><div class="pc pc258 w0 h0"><div class="t m0 x0 h2 y1 ff10c fs0 fc0 sc0 ls7 ws0">582  第21章 Ajax与Comet </div><div class="t m0 x0 h3 y2 ff10c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff113 fs2 fc0 sc0 ls19 wsfb">每次触发progress事件，都会以新的状态信息更新 HTML元素的内容。如果响应头部中包含</div><div class="t m0 x0 h5 y4 ff114 fs1 fc0 sc0 ls9 ws2">Content-Length字段，那么也可以利用此信息来计算从响应中已经接收到的数据的百分比。 </div><div class="t m0 x0 hd y8c6 ff111 fs7 fc0 sc0 ls245">21.4 跨源资源共享 </div><div class="t m0 x0 h5 y8c7 ff113 fs2 fc0 sc0 ls8 wseb">通过XHR实现Ajax 通信的一个主要限制，来源于跨域安全策略。默认情况下，XHR对象只能访</div><div class="t m0 x0 h4 y8c8 ff113 fs2 fc0 sc0 ls8 wseb">问与包含它的页面位于同一个域中的资源。这种安全策略可以预防某些恶意行为。但是，实现合理的跨</div><div class="t m0 x0 h5 y3ebb ff113 fs2 fc0 sc0 ls8 wseb">域请求对开发某些浏览器应用程序也是至关重要的。 </div><div class="t m0 x0 h5 y3ebc ff10c fs2 fc0 sc0 ls90 ws6b">CORS（Cross-Origin Resource Sharing，跨源资源共享）是W3C的一个工作草案，定义了在必须访</div><div class="t m0 x0 h5 y3ebd ff113 fs2 fc0 sc0 ls8 wseb">问跨源资源时，浏览器与服务器应该如何沟通。CORS背后的基本思想，就是使用自定义的HTTP头部</div><div class="t m0 x0 h5 y3ebe ff113 fs2 fc0 sc0 ls8 wseb">让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。 </div><div class="t m0 x0 h146 y3ebf ff113 fs2 fc0 sc0 ls8 wseb">比如一个简单的使用GET或POST发送的请求，它没有自定义的头部，而主体内容是text/plain。在</div><div class="t m0 x0 h4 y8cd ff113 fs2 fc0 sc0 ls8 wseb">发送该请求时，需要给它附加一个额外的Origin头部，其中包含请求页面的源信息（协议、域名和端</div><div class="t m0 x0 hc y8ce ff113 fs2 fc0 sc0 ls8 wseb">口），以便服务器根据这个头部信息来决定是否给予响应。下面是Origin头部的一个示例： </div><div class="t m0 x0 hb y1599 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y39d6 ff114 fs6 fc0 sc0 ls21 wsb">Origin: http://www.nczonline.net </div><div class="t m0 x0 hb y3ec0 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3a42 ff113 fs2 fc0 sc0 ls8 wseb">如果服务器认为这个请求可以接受，就在Access-Control-Allow-Origin头部中回发相同的源</div><div class="t m0 x0 h5 y2e11 ff113 fs2 fc0 sc0 ls8 wseb">信息（如果是公共资源，可以回发&quot;*&quot;）。例如： </div><div class="t m0 x0 hb y3ec1 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3ec2 ff114 fs6 fc0 sc0 ls21 wsb">Access-Control-Allow-Origin: http://www.nczonline.net </div><div class="t m0 x0 hb y3ec3 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 ybae ff113 fs2 fc0 sc0 ls8 wseb">如果没有这个头部，或者有这个头部但源信息不匹配，浏览器就会驳回请求。正常情况下，浏览器</div><div class="t m0 x0 h5 ybaf ff113 fs2 fc0 sc0 ls8 wseb">会处理请求。注意，请求和响应都不包含cookie信息。 </div><div class="t m0 x0 h20 y3ec4 ff111 fs3 fc0 sc0 ls248 ws214">21.4.1 IE对CORS的实现 </div><div class="t m0 x0 h5 y3ec5 ff113 fs2 fc0 sc0 ls8 wseb">微软在IE8中引入了XDR（XDomainRequest）类型。这个对象与XHR类似，但能实现安全可靠</div><div class="t m0 x0 h5 y3ec6 ff113 fs2 fc0 sc0 ls8 wseb">的跨域通信。XDR对象的安全机制部分实现了W3C的CORS规范。以下是XDR与XHR的一些不同之</div><div class="t m0 x0 h5 y3ec7 ff113 fs2 fc0 sc0 ls8">处。 </div><div class="t m0 x0 h5 y3ec8 ff112 fs1 fc0 sc0 ls2"> cookie不会随请求发送，也不会随响应返回。 </div><div class="t m0 x0 h5 y14ff ff112 fs1 fc0 sc0 ls2"> 只能设置请求头部信息中的Content-Type字段。 </div><div class="t m0 x0 h5 y3ec9 ff112 fs1 fc0 sc0 ls2"> 不能访问响应头部信息。 </div><div class="t m0 x0 h5 y3eca ff112 fs1 fc0 sc0 ls2"> 只支持GET和POST请求。 </div><div class="t m0 x0 h5 y3ecb ff113 fs2 fc0 sc0 ls8 wseb">这些变化使CSRF（Cross-Site Request Forgery，跨站点请求伪造）和XSS（Cross-Site Scripting，跨</div><div class="t m0 x0 h4 y3ecc ff113 fs2 fc0 sc0 ls8 wseb">站点脚本）的问题得到了缓解。被请求的资源可以根据它认为合适的任意数据（用户代理、来源页面等）</div><div class="t m0 x0 h1c y3ecd ff113 fs2 fc0 sc0 ls8 wseb">来决定是否设置Access-Control- Allow-Origin头部。作为请求的一部分，Origin头部的值表示</div><div class="t m0 x0 h5 y3ece ff113 fs2 fc0 sc0 ls8 wseb">请求的来源域，以便远程资源明确地识别XDR请求。 </div><div class="t m0 x0 h5 y3ecf ff10c fs2 fc0 sc0 ls81 ws76">XDR对象的使用方法与XHR对象非常相似。也是创建一个XDomainRequest的实例，调用open()</div><div class="t m0 x0 h5 y3ed0 ff113 fs2 fc0 sc0 ls8 wseb">方法，再调用send()方法。但与XHR对象的open()方法不同，XDR对象的 open()方法只接收两个</div><div class="t m0 x0 h5 y1a1e ff113 fs2 fc0 sc0 ls8 wseb">参数：请求的类型和URL。 </div><div class="t m0 x0 h5 y1a1f ff113 fs2 fc0 sc0 ls8 wseb">所有XDR请求都是异步执行的，不能用它来创建同步请求。请求返回之后，会触发load 事件，</div><div class="t m0 x0 hb9 y1a20 ff113 fs2 fc0 sc0 ls8 wseb">响应的数据也会保存在responseText属性中，如下所示。 </div></div></div>
<div id="pf259" class="pf w0 h0" data-page-no="259"><div class="pc pc259 w0 h0"><div class="t m0 x2 h2 y1 ff10c fs0 fc0 sc0 ls7 ws0">21.4 跨源资源共享    583 </div><div class="t m0 x0 h3 y2 ff10c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff10e fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff10e fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ff10e fs3 fc2 sc0 ls1d wsb">16 </div><div class="t m0 x3 h8 y20 ff10e fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff10e fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff10e fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff10e fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff10e fs3 fc2 sc0 ls1d wsb">20 </div><div class="t m0 x3 h8 y25 ff10e fs3 fc2 sc0 ls1d wsb">21 </div><div class="t m0 x3 h8 y26 ff10e fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff10e fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ff10e fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff10e fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y866 ff114 fs6 fc0 sc0 ls21 wsb">var xdr = new XDomainRequest();  </div><div class="t m0 x0 hb y867 ff114 fs6 fc0 sc0 ls21 wsb">xdr.onload = function(){ </div><div class="t m0 x0 hb y868 ff114 fs6 fc0 sc0 ls21 wsb">    alert(xdr.responseText); </div><div class="t m0 x0 hb y869 ff114 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y86a ff114 fs6 fc0 sc0 ls21 wsb">xdr.open(&quot;get&quot;, &quot;http://www.somewhere-else.com/page/&quot;); </div><div class="t m0 x0 hb y86b ff114 fs6 fc0 sc0 ls21 wsb">xdr.send(null); </div><div class="t m0 x0 hb y86c ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y86d ff119 fs2 fc0 sc0 ls1b wsb">XDomainRequestExample01.htm </div><div class="t m0 x0 h4 y86e ff113 fs2 fc0 sc0 ls8 wseb">在接收到响应后，你只能访问响应的原始文本；没有办法确定响应的状态代码。而且，只要响应有</div><div class="t m0 x0 h1e y86f ff113 fs2 fc0 sc0 ls8 wseb">效就会触发load事件，如果失败（包括响应中缺少Access-Control-Allow-Origin头部）就会触</div><div class="t m0 x0 h1e y870 ff113 fs2 fc0 sc0 ls45c">发error事件。遗憾的是，除了错误本身之外，没有其他信息可用，因此唯一能够确定的就只有请求</div><div class="t m0 x0 hc y2e1 ff113 fs2 fc0 sc0 ls8 wseb">未成功了。要检测错误，可以像下面这样指定一个onerror事件处理程序。 </div><div class="t m0 x0 hb y3ed1 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3ed2 ff114 fs6 fc0 sc0 ls21 wsb">var xdr = new XDomainRequest(); </div><div class="t m0 x0 hb y3ed3 ff114 fs6 fc0 sc0 ls21 wsb">xdr.onload = function(){ </div><div class="t m0 x0 hb y3ed4 ff114 fs6 fc0 sc0 ls21 wsb">    alert(xdr.responseText); </div><div class="t m0 x0 hb y3ed5 ff114 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 h15 y3ed6 ff115 fs6 fc0 sc0 ls21 wsb">xdr.onerror = function(){ </div><div class="t m0 x0 h15 y3ed7 ff115 fs6 fc0 sc0 ls21 wsb">    alert(&quot;An error occurred.&quot;); </div><div class="t m0 x0 h15 y3ed8 ff115 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y3ed9 ff114 fs6 fc0 sc0 ls21 wsb">xdr.open(&quot;get&quot;, &quot;http://www.somewhere-else.com/page/&quot;); </div><div class="t m0 x0 hb y3eda ff114 fs6 fc0 sc0 ls21 wsb">xdr.send(null); </div><div class="t m0 x0 hb y3edb ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y3edc ff119 fs2 fc0 sc0 ls1b wsb">XDomainRequestExample01.htm </div><div class="t m0 x5 h5 y38bc ff10d fs2 fc0 sc0 ls8 ws14">鉴于导致XDR请求失败的因素很多，因此建议你不要忘记通过onerror事件处</div><div class="t m0 x5 h5 y3edd ff10d fs2 fc0 sc0 ls8 ws14">理程序来捕获该事件；否则，即使请求失败也不会有任何提示。 </div><div class="t m0 x0 h44 y3ede ff113 fs2 fc0 sc0 ls8 wseb">在请求返回前调用abort()方法可以终止请求： </div><div class="t m0 x0 hb y3edf ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y3ee0 ff114 fs6 fc0 sc0 ls21 wsb">xdr.abort(); //终止请求 </div><div class="t m0 x0 hb y3ee1 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y835 ff113 fs2 fc0 sc0 ls3b">与XHR一样，XDR对象也支持timeout属性以及ontimeout 事件处理程序。下面是一个例子。 </div><div class="t m0 x0 hb y20fc ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3ee2 ff114 fs6 fc0 sc0 ls21 wsb">var xdr = new XDomainRequest(); </div><div class="t m0 x0 hb y3ee3 ff114 fs6 fc0 sc0 ls21 wsb">xdr.onload = function(){ </div><div class="t m0 x0 hb y3ee4 ff114 fs6 fc0 sc0 ls21 wsb">    alert(xdr.responseText); </div><div class="t m0 x0 hb y3ee5 ff114 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y3ee6 ff114 fs6 fc0 sc0 ls21 wsb">xdr.onerror = function(){ </div><div class="t m0 x0 hb y3ee7 ff114 fs6 fc0 sc0 ls21 wsb">    alert(&quot;An error occurred.&quot;); </div><div class="t m0 x0 hb y3ee8 ff114 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 h15 y3ee9 ff115 fs6 fc0 sc0 ls21 wsb">xdr.timeout = 1000; </div><div class="t m0 x0 h15 y3eea ff115 fs6 fc0 sc0 ls21 wsb">xdr.ontimeout = function(){ </div><div class="t m0 x0 h15 y3eeb ff115 fs6 fc0 sc0 ls21 wsb">    alert(&quot;Request took too long.&quot;); </div><div class="t m0 x0 h15 y3eec ff115 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y3eed ff114 fs6 fc0 sc0 ls21 wsb">xdr.open(&quot;get&quot;, &quot;http://www.somewhere-else.com/page/&quot;); </div><div class="t m0 x0 hb y3eee ff114 fs6 fc0 sc0 ls21 wsb">xdr.send(null); </div><div class="t m0 x0 hb y3eef ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3ef0 ff113 fs2 fc0 sc0 ls8 wseb">这个例子会在运行1秒钟后超时，并随即调用ontimeout事件处理程序。 </div><div class="t m0 x0 h5 y3ef1 ff113 fs2 fc0 sc0 ls8 wseb">为支持POST请求，XDR对象提供了contentType属性，用来表示发送数据的格式，如下面的例</div><div class="t m0 x0 h5 y3ef2 ff113 fs2 fc0 sc0 ls8">子所示。 </div></div></div>
<div id="pf25a" class="pf w0 h0" data-page-no="25a"><div class="pc pc25a w0 h0"><div class="t m0 x0 h2 y1 ff10c fs0 fc0 sc0 ls7 ws0">584  第21章 Ajax与Comet </div><div class="t m0 x0 h3 y2 ff10c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 ff114 fs6 fc0 sc0 ls21 wsb">var xdr = new XDomainRequest(); </div><div class="t m0 x0 hb y7a ff114 fs6 fc0 sc0 ls21 wsb">xdr.onload = function(){ </div><div class="t m0 x0 hb y7b ff114 fs6 fc0 sc0 ls21 wsb">    alert(xdr.responseText); </div><div class="t m0 x0 hb y7c ff114 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y7d ff114 fs6 fc0 sc0 ls21 wsb">xdr.onerror = function(){ </div><div class="t m0 x0 hb y7e ff114 fs6 fc0 sc0 ls21 wsb">    alert(&quot;An error occurred.&quot;); </div><div class="t m0 x0 hb y7f ff114 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y80 ff114 fs6 fc0 sc0 ls21 wsb">xdr.open(&quot;post&quot;, &quot;http://www.somewhere-else.com/page/&quot;); </div><div class="t m0 x0 hb y81 ff114 fs6 fc0 sc0 ls21 wsb">xdr.contentType = &quot;application/x-www-form-urlencoded&quot;; </div><div class="t m0 x0 hb y82 ff114 fs6 fc0 sc0 ls21 wsb">xdr.send(&quot;name1=value1&amp;name2=value2&quot;); </div><div class="t m0 x0 hb y310c ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y28ce ff113 fs2 fc0 sc0 ls8 wseb">这个属性是通过XDR对象影响头部信息的唯一方式。 </div><div class="t m0 x0 h20 y3ef3 ff111 fs3 fc0 sc0 ls248 ws214">21.4.2 其他浏览器对CORS的实现 </div><div class="t m0 x0 h5 y3ef4 ff10c fs2 fc0 sc0 ls45d ws2bf">Firefox 3.5+、Safari 4+、Chrome、iOS版Safari和Android平台中的WebKit都通过XMLHttpRequest</div><div class="t m0 x0 h5 y25d9 ff113 fs2 fc0 sc0 ls42 wsf0">对象实现了对CORS的原生支持。在尝试打开不同来源的资源时，无需额外编写代码就可以触发这个行</div><div class="t m0 x0 hc y3ef5 ff113 fs2 fc0 sc0 ls44 wsef">为。要请求位于另一个域中的资源，使用标准的XHR对象并在open()方法中传入绝对URL即可，例如： </div><div class="t m0 x0 hb y3ef6 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3ef7 ff114 fs6 fc0 sc0 ls21 wsb">var xhr = createXHR(); </div><div class="t m0 x0 hb y3ef8 ff114 fs6 fc0 sc0 ls21 wsb">xhr.onreadystatechange = function(){ </div><div class="t m0 x0 hb y3ef9 ff114 fs6 fc0 sc0 ls21 wsb">    if (xhr.readyState == 4){ </div><div class="t m0 x0 hb y3efa ff114 fs6 fc0 sc0 ls21 wsb">        if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304){ </div><div class="t m0 x0 hb y3efb ff114 fs6 fc0 sc0 ls21 wsb">            alert(xhr.responseText); </div><div class="t m0 x0 hb y3efc ff114 fs6 fc0 sc0 ls21 wsb">        } else { </div><div class="t m0 x0 hb y3efd ff114 fs6 fc0 sc0 ls21 wsb">            alert(&quot;Request was unsuccessful: &quot; + xhr.status); </div><div class="t m0 x0 hb y3efe ff114 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y3eff ff114 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y3f00 ff114 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 h15 y3f01 ff115 fs6 fc0 sc0 ls21 wsb">xhr.open(&quot;get&quot;, &quot;http://www.somewhere-else.com/page/&quot;, true); </div><div class="t m0 x0 hb y3f02 ff114 fs6 fc0 sc0 ls21 wsb">xhr.send(null); </div><div class="t m0 x0 hb y3f03 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3f04 ff113 fs2 fc0 sc0 ls8d">与IE中的XDR对象不同，通过跨域XHR对象可以访问 status和statusText属性，而且还支</div><div class="t m0 x0 h5 y3f05 ff113 fs2 fc0 sc0 ls8 wseb">持同步请求。跨域XHR对象也有一些限制，但为了安全这些限制是必需的。以下就是这些限制。 </div><div class="t m0 x0 h5 y3f06 ff112 fs1 fc0 sc0 ls2"> 不能使用setRequestHeader()设置自定义头部。 </div><div class="t m0 x0 h5 yddb ff112 fs1 fc0 sc0 ls2"> 不能发送和接收cookie。 </div><div class="t m0 x0 h5 y14d3 ff112 fs1 fc0 sc0 ls2"> 调用getAllResponseHeaders()方法总会返回空字符串。 </div><div class="t m0 x0 h5 y3f07 ff113 fs2 fc0 sc0 ls8 wseb">由于无论同源请求还是跨源请求都使用相同的接口，因此对于本地资源，最好使用相对URL，在访</div><div class="t m0 x0 h5 y3f08 ff113 fs2 fc0 sc0 ls8 wseb">问远程资源时再使用绝对URL。这样做能消除歧义，避免出现限制访问头部或本地cookie信息等问题。 </div><div class="t m0 x0 h20 y21d0 ff111 fs3 fc0 sc0 ls248 ws214">21.4.3 Preflighted Reqeusts </div><div class="t m0 x0 h5 y3f09 ff10c fs2 fc0 sc0 ls90 ws6b">CORS通过一种叫做Preflighted Requests的透明服务器验证机制支持开发人员使用自定义的头部、</div><div class="t m0 x0 h5 y3f0a ff10c fs2 fc0 sc0 ls4e ws42">GET或POST之外的方法，以及不同类型的主体内容。在使用下列高级选项来发送请求时，就会向服务</div><div class="t m0 x0 h5 y3f0b ff113 fs2 fc0 sc0 ls8 wseb">器发送一个Preflight请求。这种请求使用OPTIONS方法，发送下列头部。 </div><div class="t m0 x0 h5 y3f0c ff112 fs1 fc0 sc0 ls2"> Origin：与简单的请求相同。 </div><div class="t m0 x0 h5 y3f0d ff112 fs1 fc0 sc0 ls2"> Access-Control-Request-Method：请求自身使用的方法。 </div><div class="t m0 x0 h5 y3c92 ff112 fs1 fc0 sc0 ls2"> Access-Control-Request-Headers：（可选）自定义的头部信息，多个头部以逗号分隔。 </div><div class="t m0 x0 hc y3f0e ff113 fs2 fc0 sc0 ls8 wseb">以下是一个带有自定义头部NCZ的使用POST方法发送的请求。 </div><div class="t m0 x0 hb y1d8f ff114 fs6 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf25b" class="pf w0 h0" data-page-no="25b"><div class="pc pc25b w0 h0"><div class="t m0 x2 h2 y1 ff10c fs0 fc0 sc0 ls7 ws0">21.4 跨源资源共享    585 </div><div class="t m0 x0 h3 y2 ff10c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff10e fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff10e fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ff10e fs3 fc2 sc0 ls1d wsb">16 </div><div class="t m0 x3 h8 y20 ff10e fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff10e fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff10e fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff10e fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff10e fs3 fc2 sc0 ls1d wsb">20 </div><div class="t m0 x3 h8 y25 ff10e fs3 fc2 sc0 ls1d wsb">21 </div><div class="t m0 x3 h8 y26 ff10e fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff10e fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ff10e fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff10e fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y79 ff114 fs6 fc0 sc0 ls21 wsb">Origin: http://www.nczonline.net </div><div class="t m0 x0 hb y7a ff114 fs6 fc0 sc0 ls21 wsb">Access-Control-Request-Method: POST </div><div class="t m0 x0 hb y7b ff114 fs6 fc0 sc0 ls21 wsb">Access-Control-Request-Headers: NCZ </div><div class="t m0 x0 hb y105 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3066 ff113 fs2 fc0 sc0 ls8 wseb">发送这个请求后，服务器可以决定是否允许这种类型的请求。服务器通过在响应中发送如下头部与</div><div class="t m0 x0 h5 y3067 ff113 fs2 fc0 sc0 ls8 wseb">浏览器进行沟通。 </div><div class="t m0 x0 h5 y315f ff112 fs1 fc0 sc0 ls2"> Access-Control-Allow-Origin：与简单的请求相同。 </div><div class="t m0 x0 h5 y3069 ff112 fs1 fc0 sc0 ls2"> Access-Control-Allow-Methods：允许的方法，多个方法以逗号分隔。 </div><div class="t m0 x0 h5 y3cf9 ff112 fs1 fc0 sc0 ls2"> Access-Control-Allow-Headers：允许的头部，多个头部以逗号分隔。 </div><div class="t m0 x0 h5 y2690 ff112 fs1 fc0 sc0 ls2"> Access-Control-Max-Age：应该将这个Preflight请求缓存多长时间（以秒表示）。 </div><div class="t m0 x0 h5 y3f0f ff113 fs2 fc0 sc0 ls8">例如： </div><div class="t m0 x0 hb y33c9 ff114 fs6 fc0 sc0 ls21 wsb">Access-Control-Allow-Origin: http://www.nczonline.net </div><div class="t m0 x0 hb y3f10 ff114 fs6 fc0 sc0 ls21 wsb">Access-Control-Allow-Methods: POST, GET </div><div class="t m0 x0 hb y3f11 ff114 fs6 fc0 sc0 ls21 wsb">Access-Control-Allow-Headers: NCZ </div><div class="t m0 x0 hb y3f12 ff114 fs6 fc0 sc0 ls21 wsb">Access-Control-Max-Age: 1728000 </div><div class="t m0 x0 hb y3f13 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3f14 ff10c fs2 fc0 sc0 ls2e wsf4">Preflight请求结束后，结果将按照响应中指定的时间缓存起来。而为此付出的代价只是第一次发送</div><div class="t m0 x0 h5 y3f15 ff113 fs2 fc0 sc0 ls8 wseb">这种请求时会多一次HTTP请求。 </div><div class="t m0 x0 h5 y3f16 ff113 fs2 fc0 sc0 ls8 wseb">支持Preflight请求的浏览器包括Firefox 3.5+、Safari 4+和Chrome。IE 10及更早版本都不支持。 </div><div class="t m0 x0 h20 y3f17 ff111 fs3 fc0 sc0 ls248 ws214">21.4.4 带凭据的请求 </div><div class="t m0 x0 h5 y1c06 ff113 fs2 fc0 sc0 ls221 ws21e">默认情况下，跨源请求不提供凭据（cookie、HTTP认证及客户端SSL 证明等）。通过将</div><div class="t m0 x0 h4 y2164 ff114 fs1 fc0 sc0 ls9 ws2">withCredentials属性设置为true，可以指定某个请求应该发送凭据。如果服务器接受带凭据的请</div><div class="t m0 x0 h5 y3f18 ff113 fs2 fc0 sc0 ls8 wseb">求，会用下面的HTTP头部来响应。 </div><div class="t m0 x0 hb y3147 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3f19 ff114 fs6 fc0 sc0 ls21 wsb">Access-Control-Allow-Credentials: true </div><div class="t m0 x0 hb y3f1a ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y25fe ff113 fs2 fc0 sc0 ls8 wseb">如果发送的是带凭据的请求，但服务器的响应中没有包含这个头部，那么浏览器就不会把响应交给</div><div class="t m0 x0 hc yd85 ff10c fs2 fc0 sc0 lsb ws5">JavaScript（于是，responseText中将是空字符串，status的值为0，而且会调用onerror()事件处</div><div class="t m0 x0 h5 yd86 ff113 fs2 fc0 sc0 ls8 wseb">理程序）。另外，服务器还可以在Preflight响应中发送这个HTTP头部，表示允许源发送带凭据的请求。 </div><div class="t m0 x0 he y3f1b ff113 fs2 fc0 sc0 ls8 wseb">支持withCredentials属性的浏览器有Firefox 3.5+、Safari 4+和Chrome。IE 10及更早版本都不</div><div class="t m0 x0 h5 y3f1c ff113 fs2 fc0 sc0 ls8">支持。 </div><div class="t m0 x0 h20 y85e ff111 fs3 fc0 sc0 ls248 ws214">21.4.5 跨浏览器的CORS </div><div class="t m0 x0 h5 y3f1d ff113 fs2 fc0 sc0 ls8 wseb">即使浏览器对CORS的支持程度并不都一样，但所有浏览器都支持简单的（非Preflight和不带凭据</div><div class="t m0 x0 h5 y1ffb ff113 fs2 fc0 sc0 ls8 wseb">的）请求，因此有必要实现一个跨浏览器的方案。检测XHR是否支持CORS的最简单方式，就是检查</div><div class="t m0 x0 h1e y3f1e ff113 fs2 fc0 sc0 ls8 wseb">是否存在withCredentials属性。再结合检测XDomainRequest对象是否存在，就可以兼顾 所有浏</div><div class="t m0 x0 h5 y2dc4 ff113 fs2 fc0 sc0 ls8">览器了。 </div><div class="t m0 x0 hb y1002 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3f1f ff114 fs6 fc0 sc0 ls21 wsb">function createCORSRequest(method, url){  </div><div class="t m0 x0 hb y3f20 ff114 fs6 fc0 sc0 ls21 wsb">    var xhr = new XMLHttpRequest(); </div><div class="t m0 x0 hb y3f21 ff114 fs6 fc0 sc0 ls21 wsb">    if (&quot;withCredentials&quot; in xhr){ </div><div class="t m0 x0 hb y3f22 ff114 fs6 fc0 sc0 ls21 wsb">        xhr.open(method, url, true); </div><div class="t m0 x0 hb y3f23 ff114 fs6 fc0 sc0 ls21 wsb">    } else if (typeof XDomainRequest != &quot;undefined&quot;){ </div><div class="t m0 x0 hb y3f24 ff114 fs6 fc0 sc0 ls21 wsb">        vxhr = new XDomainRequest(); </div><div class="t m0 x0 hb y3f25 ff114 fs6 fc0 sc0 ls21 wsb">        xhr.open(method, url); </div></div></div>
<div id="pf25c" class="pf w0 h0" data-page-no="25c"><div class="pc pc25c w0 h0"><div class="t m0 x0 h2 y1 ff10c fs0 fc0 sc0 ls7 ws0">586  第21章 Ajax与Comet </div><div class="t m0 x0 h3 y2 ff10c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 ff114 fs6 fc0 sc0 ls21 wsb">    } else { </div><div class="t m0 x0 hb y7a ff114 fs6 fc0 sc0 ls21 wsb">        xhr = null; </div><div class="t m0 x0 hb y7b ff114 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y7c ff114 fs6 fc0 sc0 ls21 wsb">    return xhr; </div><div class="t m0 x0 hb y7d ff114 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y7e ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y7f ff114 fs6 fc0 sc0 ls21 wsb">var request = createCORSRequest(&quot;get&quot;, &quot;http://www.somewhere-else.com/page/&quot;); </div><div class="t m0 x0 hb y80 ff114 fs6 fc0 sc0 ls21 wsb">if (request){ </div><div class="t m0 x0 hb y81 ff114 fs6 fc0 sc0 ls21 wsb">    request.onload = function(){ </div><div class="t m0 x0 h147 y82 ff114 fs6 fc0 sc0 ls21 wsb">        //对request.responseText进行处理 </div><div class="t m0 x0 hb y3f26 ff114 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 hb y3f27 ff114 fs6 fc0 sc0 ls21 wsb">    request.send(); </div><div class="t m0 x0 hb y3f28 ff114 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y3f29 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf y1318 ff119 fs2 fc0 sc0 ls5e wsb">CrossBrowserCORSRequestExample01.htm </div><div class="t m0 x0 h5 y3f2a ff10c fs2 fc0 sc0 ls47 ws38">Firefox、Safari和Chrome中的XMLHttpRequest对象与IE 中的XDomainRequest对象类似，都</div><div class="t m0 x0 h5 y213d ff113 fs2 fc0 sc0 ls8 wseb">提供了够用的接口，因此以上模式还是相当有用的。这两个对象共同的属性/方法如下。 </div><div class="t m0 x0 h5 y1802 ff112 fs1 fc0 sc0 ls2"> abort()：用于停止正在进行的请求。 </div><div class="t m0 x0 h5 y213f ff112 fs1 fc0 sc0 ls2"> onerror：用于替代onreadystatechange检测错误。 </div><div class="t m0 x0 h5 y3f2b ff112 fs1 fc0 sc0 ls2"> onload：用于替代onreadystatechange检测成功。 </div><div class="t m0 x0 h5 y2141 ff112 fs1 fc0 sc0 ls2"> responseText：用于取得响应内容。 </div><div class="t m0 x0 h5 y3a5b ff112 fs1 fc0 sc0 ls2"> send()：用于发送请求。 </div><div class="t m0 x0 h5 y3f2c ff113 fs2 fc0 sc0 ls8 wseb">以上成员都包含在createCORSRequest()函数返回的对象中，在所有浏览器中都能正常使用。 </div><div class="t m0 x0 hd y3f2d ff111 fs7 fc0 sc0 ls245">21.5 其他跨域技术 </div><div class="t m0 x0 h5 y24de ff113 fs2 fc0 sc0 ls3b">在CORS出现以前，要实现跨域Ajax通信颇费一些周折。开发人员想出了一些办法，利用DOM中</div><div class="t m0 x0 h5 y24df ff113 fs2 fc0 sc0 ls8 wseb">能够执行跨域请求的功能，在不依赖XHR对象的情况下也能发送某种请求。虽然CORS技术已经无处</div><div class="t m0 x0 h5 y24e0 ff113 fs2 fc0 sc0 ls8 wseb">不在，但开发人员自己发明的这些技术仍然被广泛使用，毕竟这样不需要修改服务器端代码。 </div><div class="t m0 x0 h20 y3f2e ff111 fs3 fc0 sc0 ls248 ws214">21.5.1 图像Ping </div><div class="t m0 x0 h4 y300f ff113 fs2 fc0 sc0 ls8 wseb">上述第一种跨域请求技术是使用&lt;img&gt;标签。我们知道，一个网页可以从任何网页中加载图像，不</div><div class="t m0 x0 h5 y171 ff113 fs2 fc0 sc0 ls8 wseb">用担心跨域不跨域。这也是在线广告跟踪浏览量的主要方式。正如第13章讨论过的，也可以动态地创</div><div class="t m0 x0 hc y3f2f ff113 fs2 fc0 sc0 ls8 wseb">建图像，使用它们的onload和onerror事件处理程序来确定是否接收到了响应。 </div><div class="t m0 x0 h5 y3f30 ff113 fs2 fc0 sc0 ls8 wseb">动态创建图像经常用于图像Ping。图像Ping是与服务器进行简单、单向的跨域通信的一种方式。</div><div class="t m0 x0 h5 y3f31 ff113 fs2 fc0 sc0 ls8 wseb">请求的数据是通过查询字符串形式发送的，而响应可以是任意内容，但通常是像素图或204响应。通过</div><div class="t m0 x0 h5 y3f32 ff113 fs2 fc0 sc0 ls8 wseb">图像Ping，浏览器得不到任何具体的数据，但通过侦听load和error 事件，它能知道响应是什么时</div><div class="t m0 x0 h5 y3f33 ff113 fs2 fc0 sc0 ls8 wseb">候接收到的。来看下面的例子。 </div><div class="t m0 x0 hb y2d54 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3f34 ff114 fs6 fc0 sc0 ls21 wsb">var img = new Image();  </div><div class="t m0 x0 hb y3f35 ff114 fs6 fc0 sc0 ls21 wsb">img.onload = img.onerror = function(){ </div><div class="t m0 x0 hb y3f36 ff114 fs6 fc0 sc0 ls21 wsb">    alert(&quot;Done!&quot;); </div><div class="t m0 x0 hb y3f37 ff114 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y3f38 ff114 fs6 fc0 sc0 ls21 wsb">img.src = &quot;http://www.example.com/test?name=Nicholas&quot;; </div><div class="t m0 x0 hb y3f39 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y3f3a ff119 fs2 fc0 sc0 ls2b wsb">ImagePingExample01.htm </div></div></div>
<div id="pf25d" class="pf w0 h0" data-page-no="25d"><div class="pc pc25d w0 h0"><div class="t m0 x2 h2 y1 ff10c fs0 fc0 sc0 ls7 ws0">21.5 其他跨域技术    587 </div><div class="t m0 x0 h3 y2 ff10c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff10e fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff10e fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ff10e fs3 fc2 sc0 ls1d wsb">16 </div><div class="t m0 x3 h8 y20 ff10e fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff10e fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff10e fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff10e fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff10e fs3 fc2 sc0 ls1d wsb">20 </div><div class="t m0 x3 h8 y25 ff10e fs3 fc2 sc0 ls1d wsb">21 </div><div class="t m0 x3 h8 y26 ff10e fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff10e fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ff10e fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff10e fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h4 y3 ff113 fs2 fc0 sc0 ls8 wseb">这里创建了一个Image的实例，然后将onload和onerror 事件处理程序指定为同一个函数。这</div><div class="t m0 x0 h1e y4d ff113 fs2 fc0 sc0 ls8 wseb">样无论是什么响应，只要请求完成，就能得到通知。请求从设置src属性那一刻开始，而这个例子在请</div><div class="t m0 x0 hc y5 ff113 fs2 fc0 sc0 ls8 wseb">求中发送了一个name参数。 </div><div class="t m0 x0 h5 yd9 ff113 fs2 fc0 sc0 ls8 wseb">图像Ping最常用于跟踪用户点击页面或动态广告曝光次数。图像Ping有两个主要的缺点，一是只</div><div class="t m0 x0 hc y15d ff113 fs2 fc0 sc0 ls8 wseb">能发送GET请求，二是无法访问服务器的响应文本。因此，图像Ping只能用于浏览器与服务器间的单</div><div class="t m0 x0 h5 y21a ff113 fs2 fc0 sc0 ls8">向通信。 </div><div class="t m0 x0 h20 y3f3b ff111 fs3 fc0 sc0 ls248 ws214">21.5.2 JSONP </div><div class="t m0 x0 h5 y2292 ff10c fs2 fc0 sc0 ls14d ws11a">JSONP是JSON with padding（填充式JSON或参数式JSON）的简写，是应用JSON的一种新方法，</div><div class="t m0 x0 h5 y3f3c ff113 fs2 fc0 sc0 ls8 wseb">在后来的Web服务中非常流行。JSONP看起来与JSON差不多，只不过是被包含在函数调用中的JSON，</div><div class="t m0 x0 h4 y3f3d ff113 fs2 fc0 sc0 ls8 wseb">就像下面这样。 </div><div class="t m0 x0 hb y3f3e ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3f3f ff114 fs6 fc0 sc0 ls21 wsb">callback({ &quot;name&quot;: &quot;Nicholas&quot; }); </div><div class="t m0 x0 hb y3f40 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3f41 ff10c fs2 fc0 sc0 ls14d ws11a">JSONP由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数。回调</div><div class="t m0 x0 h5 y3f42 ff113 fs2 fc0 sc0 ls8 wseb">函数的名字一般是在请求中指定的。而数据就是传入回调函数中的JSON数据。下面是一个典型的JSONP</div><div class="t m0 x0 h5 y3f43 ff113 fs2 fc0 sc0 ls8">请求。 </div><div class="t m0 x0 hb y30e2 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3f44 ff114 fs6 fc0 sc0 ls21 wsb">http://freegeoip.net/json/?callback=handleResponse </div><div class="t m0 x0 hb y3f45 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3288 ff113 fs2 fc0 sc0 ls8 wseb">这个URL是在请求一个JSONP地理定位服务。通过查询字符串来指定JSONP服务的回调参数是很</div><div class="t m0 x0 h5 y3289 ff113 fs2 fc0 sc0 ls8 wseb">常见的，就像上面的URL所示，这里指定的回调函数的名字叫handleResponse()。 </div><div class="t m0 x0 hc y3f46 ff10c fs2 fc0 sc0 ls14d ws11a">JSONP是通过动态&lt;script&gt;元素（要了解详细信息，请参考第13章）来使用的，使用时可以为</div><div class="t m0 x0 h5 y3f47 ff114 fs1 fc0 sc0 ls9 ws2">src属性指定一个跨域URL。这里的&lt;script&gt;元素与&lt;img&gt;元素类似，都有能力不受限制地从其他域</div><div class="t m0 x0 h5 y3f48 ff113 fs2 fc0 sc0 ls8 wseb">加载资源。因为JSONP是有效的JavaScript代码，所以在请求完成后，即在 JSONP响应加载到页面中</div><div class="t m0 x0 h5 y3f49 ff113 fs2 fc0 sc0 ls8 wseb">以后，就会立即执行。来看一个例子。 </div><div class="t m0 x0 hb y3bda ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3f4a ff114 fs6 fc0 sc0 ls21 wsb">function handleResponse(response){ </div><div class="t m0 x0 h16 y3f4b ff114 fs6 fc0 sc0 ls21 wsb">    alert(&quot;You’re at IP address &quot; + response.ip + &quot;, which is in &quot; + </div><div class="t m0 x0 hb y3f4c ff114 fs6 fc0 sc0 ls21 wsb">          response.city + &quot;, &quot; + response.region_name); </div><div class="t m0 x0 hb y3f4d ff114 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y3f4e ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3f4f ff114 fs6 fc0 sc0 ls21 wsb">var script = document.createElement(&quot;script&quot;); </div><div class="t m0 x0 hb y3f50 ff114 fs6 fc0 sc0 ls21 wsb">script.src = &quot;http://freegeoip.net/json/?callback=handleResponse&quot;; </div><div class="t m0 x0 hb y3f51 ff114 fs6 fc0 sc0 ls21 wsb">document.body.insertBefore(script, document.body.firstChild); </div><div class="t m0 x0 hb y3f52 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y117f ff119 fs2 fc0 sc0 ls2b wsb">JSONPExample01.htm </div><div class="t m0 x0 h5 y3f53 ff113 fs2 fc0 sc0 ls8 wseb">这个例子通过查询地理定位服务来显示你的IP地址和位置信息。 </div><div class="t m0 x0 h5 y3f54 ff10c fs2 fc0 sc0 lsfa wsc9">JSONP之所以在开发人员中极为流行，主要原因是它非常简单易用。与图像Ping相比，它的优点</div><div class="t m0 x0 h5 y3f55 ff113 fs2 fc0 sc0 ls8 wseb">在于能够直接访问响应文本，支持在浏览器与服务器之间双向通信。不过，JSONP也有两点不足。 </div><div class="t m0 x0 h5 y3f56 ff113 fs2 fc0 sc0 ls8 wseb">首先，JSONP是从其他域中加载代码执行。如果其他域不安全，很可能会在响应中夹带一些恶意代</div><div class="t m0 x0 h5 y3f57 ff113 fs2 fc0 sc0 ls8 wseb">码，而此时除了完全放弃JSONP调用之外，没有办法追究。因此在使用不是你自己运维的Web服务时，</div><div class="t m0 x0 h5 y3f58 ff113 fs2 fc0 sc0 ls8 wseb">一定得保证它安全可靠。 </div><div class="t m0 x0 h5 y3f59 ff113 fs2 fc0 sc0 ls8 wseb">其次，要确定JSONP请求是否失败并不容易。虽然HTML5给&lt;script&gt;元素新增了一个onerror</div><div class="t m0 x0 h4 y846 ff113 fs2 fc0 sc0 ls8 wseb">事件处理程序，但目前还没有得到任何浏览器支持。为此，开发人员不得不使用计时器检测指定时间内</div></div></div>
<div id="pf25e" class="pf w0 h0" data-page-no="25e"><div class="pc pc25e w0 h0"><div class="t m0 x0 h2 y1 ff10c fs0 fc0 sc0 ls7 ws0">588  第21章 Ajax与Comet </div><div class="t m0 x0 h3 y2 ff10c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff113 fs2 fc0 sc0 ls8 wseb">是否接收到了响应。但就算这样也不能尽如人意，毕竟不是每个用户上网的速度和带宽都一样。 </div><div class="t m0 x0 h20 y3c9e ff111 fs3 fc0 sc0 ls248 ws214">21.5.3 Comet </div><div class="t m0 x0 h3b y13b6 ff10c fs2 fc0 sc0 ls465 ws3e5">Comet是Alex Russell①发明的一个词儿，指的是一种更高级的Ajax技术（经常也有人称为“服务器</div><div class="t m0 x0 h5 y3f5b ff113 fs2 fc0 sc0 ls8 wseb">推送”）。Ajax是一种从页面向服务器请求数据的技术，而Comet则是一种服务器向页面推送数据的技</div><div class="t m0 x0 h5 y3f5c ff113 fs2 fc0 sc0 ls8">术。Comet能够让信息近乎实时地被推送到页面上，非常适合处理体育比赛的分数和股票报价。 </div><div class="t m0 x0 h5 y3f5d ff113 fs2 fc0 sc0 ls8 wseb">有两种实现Comet的方式：长轮询和流。长轮询是传统轮询（也称为短轮询）的一个翻版，即浏览</div><div class="t m0 x0 h5 y3f5e ff113 fs2 fc0 sc0 ls8 wseb">器定时向服务器发送请求，看有没有更新的数据。图21-1展示的是短轮询的时间线。 </div><div class="t m0 x2 h5 y18ad ff10c fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x7 h3 y24c7 ff113 fs1 fc0 sc0 ls8 wsb">图 21-1 </div><div class="t m0 x0 h4 y15c2 ff113 fs2 fc0 sc0 ls8 wseb">长轮询把短轮询颠倒了一下。页面发起一个到服务器的请求，然后服务器一直保持连接打开，直到</div><div class="t m0 x0 h4 y3f5f ff113 fs2 fc0 sc0 ls8 wseb">有数据可发送。发送完数据之后，浏览器关闭连接，随即又发起一个到服务器的新请求。这一过程在页</div><div class="t m0 x0 h5 y3f60 ff113 fs2 fc0 sc0 ls8 wseb">面打开期间一直持续不断。图21-2展示了长轮询的时间线。 </div><div class="t m0 x2 h5 y3f61 ff10c fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x7 h3 ya51 ff113 fs1 fc0 sc0 ls8 wsb">图 21-2 </div><div class="t m0 x0 h4 y140e ff113 fs2 fc0 sc0 ls8 wseb">无论是短轮询还是长轮询，浏览器都要在接收数据之前，先发起对服务器的连接。两者最大的区别</div><div class="t m0 x0 h4 y3d0a ff113 fs2 fc0 sc0 ls8 wseb">在于服务器如何发送数据。短轮询是服务器立即发送响应，无论数据是否有效，而长轮询是等待发送响</div><div class="t m0 x0 h5 y3f62 ff113 fs2 fc0 sc0 ls8 wseb">应。轮询的优势是所有浏览器都支持，因为使用XHR对象和setTimeout()就能实现。而你要做的就</div><div class="t m0 x0 h5 y3f63 ff113 fs2 fc0 sc0 ls8 wseb">是决定什么时候发送请求。 </div><div class="t m0 x0 h5 y3f64 ff113 fs2 fc0 sc0 ls8 wseb">第二种流行的Comet实现是HTTP流。流不同于上述两种轮询，因为它在页面的整个生命周期内只</div><div class="t m0 x0 h5 y3f65 ff113 fs2 fc0 sc0 ls8 wseb">使用一个HTTP连接。具体来说，就是浏览器向服务器发送一个请求，而服务器保持连接打开，然后周</div><div class="t m0 x0 h5 y3f66 ff113 fs2 fc0 sc0 ls8 wseb">期性地向浏览器发送数据。比如，下面这段PHP脚本就是采用流实现的服务器中常见的形式。 </div><div class="t m0 x0 hb ya2 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3f67 ff114 fs6 fc0 sc0 ls21 wsb">&lt;?php </div><div class="t m0 x0 hb y3f68 ff114 fs6 fc0 sc0 ls21 wsb">    $i = 0; </div><div class="t m0 x0 hb y29c0 ff114 fs6 fc0 sc0 ls21 wsb">    while(true){ </div><div class="t m0 x0 hb y3f69 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h3c y2d6 ff110 fs2 fc0 sc0 ls7b wsb">—————————— </div><div class="t m0 x0 h36 ycc6 ff113 fs6 fc0 sc0 ls95">① Alex Russell是著名JavaScript框架Dojo的创始人。 </div></div></div>
<div id="pf25f" class="pf w0 h0" data-page-no="25f"><div class="pc pc25f w0 h0"><div class="t m0 x2 h2 y1 ff10c fs0 fc0 sc0 ls7 ws0">21.5 其他跨域技术    589 </div><div class="t m0 x0 h3 y2 ff10c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff10e fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff10e fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ff10e fs3 fc2 sc0 ls1d wsb">16 </div><div class="t m0 x3 h8 y20 ff10e fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff10e fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff10e fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff10e fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff10e fs3 fc2 sc0 ls1d wsb">20 </div><div class="t m0 x3 h8 y25 ff10e fs3 fc2 sc0 ls1d wsb">21 </div><div class="t m0 x3 h8 y26 ff10e fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff10e fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ff10e fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff10e fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h16 y79 ff114 fs6 fc0 sc0 ls21 wsb">        //输出一些数据，然后立即刷新输出缓存 </div><div class="t m0 x0 hb y7a ff114 fs6 fc0 sc0 ls21 wsb">        echo &quot;Number is $i&quot;; </div><div class="t m0 x0 hb y7b ff114 fs6 fc0 sc0 ls21 wsb">        flush(); </div><div class="t m0 x0 hb y7c ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y7d ff114 fs6 fc0 sc0 ls21 wsb">        //等几秒钟 </div><div class="t m0 x0 hb y7e ff114 fs6 fc0 sc0 ls21 wsb">        sleep(10); </div><div class="t m0 x0 hb y7f ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y80 ff114 fs6 fc0 sc0 ls21 wsb">        $i++; </div><div class="t m0 x0 hb y81 ff114 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y3f6a ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y218e ff113 fs2 fc0 sc0 ls24 wsf5">所有服务器端语言都支持打印到输出缓存然后刷新（将输出缓存中的内容一次性全部发送到客户</div><div class="t m0 x0 h5 y3f6b ff113 fs2 fc0 sc0 ls8 wseb">端）的功能。而这正是实现HTTP流的关键所在。 </div><div class="t m0 x0 h5 y3f6c ff113 fs2 fc0 sc0 ls98">在Firefox、Safari、Opera和Chrome中，通过侦听readystatechange事件及检测 readyState</div><div class="t m0 x0 h5 y20cb ff113 fs2 fc0 sc0 ls8 wseb">的值是否为3，就可以利用XHR对象实现 HTTP流。在上述这些浏览器中，随着不断从服务器接收数</div><div class="t m0 x0 hc y3f6d ff113 fs2 fc0 sc0 ls8 wseb">据，readyState的值会周期性地变为3。当readyState值变为 3时，responseText属性中就会保</div><div class="t m0 x0 h4 y3f6e ff113 fs2 fc0 sc0 ls8 wseb">存接收到的所有数据。此时，就需要比较此前接收到的数据，决定从什么位置开始取得最新的数据。使</div><div class="t m0 x0 h5 y3f6f ff113 fs2 fc0 sc0 ls3b">用XHR对象实现HTTP流的典型代码如下所示。 </div><div class="t m0 x0 hb y215f ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3f70 ff114 fs6 fc0 sc0 ls21 wsb">function createStreamingClient(url, progress, finished){ </div><div class="t m0 x0 hb y3f71 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3f72 ff114 fs6 fc0 sc0 ls21 wsb">    var xhr = new XMLHttpRequest(), </div><div class="t m0 x0 hb y3f73 ff114 fs6 fc0 sc0 ls21 wsb">        received = 0; </div><div class="t m0 x0 hb y3f74 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3f75 ff114 fs6 fc0 sc0 ls21 wsb">    xhr.open(&quot;get&quot;, url, true); </div><div class="t m0 x0 hb y3f76 ff114 fs6 fc0 sc0 ls21 wsb">    xhr.onreadystatechange = function(){ </div><div class="t m0 x0 hb y3f77 ff114 fs6 fc0 sc0 ls21 wsb">        var result; </div><div class="t m0 x0 hb y3f78 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3f79 ff114 fs6 fc0 sc0 ls21 wsb">        if (xhr.readyState == 3){ </div><div class="t m0 x0 hb y3f7a ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y3f7b ff114 fs6 fc0 sc0 ls21 wsb">            //只取得最新数据并调整计数器 </div><div class="t m0 x0 hb y3f7c ff114 fs6 fc0 sc0 ls21 wsb">            result = xhr.responseText.substring(received); </div><div class="t m0 x0 hb y3f7d ff114 fs6 fc0 sc0 ls21 wsb">            received += result.length; </div><div class="t m0 x0 hb y3f7e ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y3f7f ff114 fs6 fc0 sc0 ls21 wsb">            //调用progress回调函数 </div><div class="t m0 x0 hb y3f80 ff114 fs6 fc0 sc0 ls21 wsb">            progress(result); </div><div class="t m0 x0 hb y3f81 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3f82 ff114 fs6 fc0 sc0 ls21 wsb">        } else if (xhr.readyState == 4){ </div><div class="t m0 x0 hb y3f83 ff114 fs6 fc0 sc0 ls21 wsb">            finished(xhr.responseText); </div><div class="t m0 x0 hb y3f84 ff114 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y3f85 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3f86 ff114 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 hb y3f87 ff114 fs6 fc0 sc0 ls21 wsb">    xhr.send(null); </div><div class="t m0 x0 hb y3f88 ff114 fs6 fc0 sc0 ls21 wsb">    return xhr; </div><div class="t m0 x0 hb y3f89 ff114 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y3f8a ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3f8b ff114 fs6 fc0 sc0 ls21 wsb">var client = createStreamingClient(&quot;streaming.php&quot;, function(data){ </div><div class="t m0 x0 hb y3f8c ff114 fs6 fc0 sc0 ls21 wsb">                alert(&quot;Received: &quot; + data); </div><div class="t m0 x0 hb y3f8d ff114 fs6 fc0 sc0 ls21 wsb">             }, function(data){ </div><div class="t m0 x0 hb y3f8e ff114 fs6 fc0 sc0 ls21 wsb">                alert(&quot;Done!&quot;); </div><div class="t m0 x0 hb y3f8f ff114 fs6 fc0 sc0 ls21 wsb">             }); </div><div class="t m0 x0 hb y3f90 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y3f91 ff119 fs2 fc0 sc0 ls1b wsb">HTTPStreamingExample01.htm </div><div class="t m0 x0 h5 y3f92 ff113 fs2 fc0 sc0 ls8 wseb">这个createStreamingClient()函数接收三个参数：要连接的URL、在接收到数据时调用的函</div><div class="t m0 x0 h4 y3f93 ff113 fs2 fc0 sc0 ls8 wseb">数以及关闭连接时调用的函数。有时候，当连接关闭时，很可能还需要重新建立，所以关注连接什么时</div></div></div>
<div id="pf260" class="pf w0 h0" data-page-no="260"><div class="pc pc260 w0 h0"><div class="t m0 x0 h2 y1 ff10c fs0 fc0 sc0 ls7 ws0">590  第21章 Ajax与Comet </div><div class="t m0 x0 h3 y2 ff10c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff113 fs2 fc0 sc0 ls8 wseb">候关闭还是有必要的。 </div><div class="t m0 x0 hc y4d ff113 fs2 fc0 sc0 ls8 wseb">只要readystatechange事件发生，而且readyState值为3，就 对responseText进行分割以</div><div class="t m0 x0 hc y5 ff113 fs2 fc0 sc0 ls8 wseb">取得最新数据。这里的received变量用于记录已经处理了多少个字符，每次readyState值为3时都</div><div class="t m0 x0 h5 yd9 ff113 fs2 fc0 sc0 ls8 wseb">递增。然后，通过progress回调函数来处理传入的新数据。而当 readyState值为4时，则执行</div><div class="t m0 x0 h5 y219 ff114 fs1 fc0 sc0 ls9 ws2">finished回调函数，传入响应返回的全部内容。 </div><div class="t m0 x0 h5 y21a ff113 fs2 fc0 sc0 ls8 wseb">虽然这个例子比较简单，而且也能在大多数浏览器中正常运行（IE除外），但管理Comet的连接是</div><div class="t m0 x0 h5 y5c8 ff113 fs2 fc0 sc0 ls8 wseb">很容易出错的，需要时间不断改进才能达到完美。浏览器社区认为Comet是未来Web 的一个重要组成</div><div class="t m0 x0 h5 y2b96 ff113 fs2 fc0 sc0 ls8 wseb">部分，为了简化这一技术，又为Comet创建了两个新的接口。 </div><div class="t m0 x0 h20 y7fb ff111 fs3 fc0 sc0 ls248 ws214">21.5.4 服务器发送事件 </div><div class="t m0 x0 h5 yf28 ff10c fs2 fc0 sc0 ls94 ws77">SSE（Server-Sent Events，服务器发送事件）是围绕只读Comet交互推出的API或者模式。SSE API</div><div class="t m0 x0 h5 yf29 ff113 fs2 fc0 sc0 ls5 wsec">用于创建到服务器的单向连接，服务器通过这个连接可以发送任意数量的数据。服务器响应的MIME</div><div class="t m0 x0 he y3f94 ff113 fs2 fc0 sc0 ls8 wseb">类型必须是text/event-stream，而且是浏览器中的JavaScript API能解析格式输出。SSE支持短轮</div><div class="t m0 x0 h5 y1257 ff113 fs2 fc0 sc0 ls8 wseb">询、长轮询和HTTP流，而且能在断开连接时自动确定何时重新连接。有了这么简单实用的API，再实</div><div class="t m0 x0 h5 y3f95 ff113 fs2 fc0 sc0 ls3b">现Comet就容易多了。 </div><div class="t m0 x0 h5 y3f96 ff113 fs2 fc0 sc0 ls8 wseb">支持SSE的浏览器有Firefox 6+、Safari 5+、Opera 11+、Chrome和iOS 4+版Safari。 </div><div class="t m0 x0 h2f y3f97 ff111 fs2 fc0 sc0 lsf ws3ea">1. SSE API </div><div class="t m0 x0 h5 y3f98 ff10c fs2 fc0 sc0 ls94 ws77">SSE的JavaScript API与其他传递消息的JavaScript API很相似。要预订新的事件流，首先要创建一</div><div class="t m0 x0 h149 y3f99 ff113 fs2 fc0 sc0 ls8 wseb">个新的EventSource对象，并传进一个入口点： </div><div class="t m0 x0 hb y3f9a ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3f9b ff114 fs6 fc0 sc0 ls21 wsb">var source = new EventSource(&quot;myevents.php&quot;); </div><div class="t m0 x0 hb y3f9c ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3f9d ff113 fs2 fc0 sc0 ls8 wseb">注意，传入的URL必须与创建对象的页面同源（相同的URL模式、域及端口）。EventSource的</div><div class="t m0 x0 hc y3f9e ff113 fs2 fc0 sc0 ls8 wseb">实例有一个readyState属性，值为0表示正连接到服务器，值为1表示打开了连接，值为2表示关闭</div><div class="t m0 x0 h5 y796 ff113 fs2 fc0 sc0 ls8">了连接。 </div><div class="t m0 x0 h5 y3f9f ff113 fs2 fc0 sc0 ls8 wseb">另外，还有以下三个事件。 </div><div class="t m0 x0 h5 y2d4b ff112 fs1 fc0 sc0 ls2"> open：在建立连接时触发。 </div><div class="t m0 x0 h5 y132c ff112 fs1 fc0 sc0 ls2"> message：在从服务器接收到新事件时触发。 </div><div class="t m0 x0 h5 y1717 ff112 fs1 fc0 sc0 ls2"> error：在无法建立连接时触发。 </div><div class="t m0 x0 h5 y3fa0 ff113 fs2 fc0 sc0 ls8 wseb">就一般的用法而言，onmessage事件处理程序也没有什么特别的。 </div><div class="t m0 x0 hb y1611 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3fa1 ff114 fs6 fc0 sc0 ls21 wsb">source.onmessage = function(event){ </div><div class="t m0 x0 hb y3fa2 ff114 fs6 fc0 sc0 ls21 wsb">    var data = event.data; </div><div class="t m0 x0 h16 y3fa3 ff114 fs6 fc0 sc0 ls21 wsb">    //处理数据 </div><div class="t m0 x0 hb y3fa4 ff114 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y3fa5 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1422 ff113 fs2 fc0 sc0 ls8 wseb">服务器发回的数据以字符串形式保存在event.data中。 </div><div class="t m0 x0 h1e y1423 ff113 fs2 fc0 sc0 ls8 wseb">默认情况下，EventSource对象会保持与服务器的活动连接。如果连接断开，还会重新连接。这</div><div class="t m0 x0 h5 y3fa6 ff113 fs2 fc0 sc0 ls8 wseb">就意味着SSE适合长轮询和HTTP流。如果想强制立即断开连接并且不再重新连接，可以调用close()</div><div class="t m0 x0 h5 y2b72 ff113 fs2 fc0 sc0 ls8">方法。 </div><div class="t m0 x0 hb y6e1 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3fa7 ff114 fs6 fc0 sc0 ls21 wsb">source.close(); </div><div class="t m0 x0 hb y3fa8 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h3c y3fa9 ff111 fs2 fc0 sc0 ls2e wsb">2. 事件流 </div><div class="t m0 x0 h5 y3faa ff113 fs2 fc0 sc0 ls8 wseb">所谓的服务器事件会通过一个持久的HTTP响应发送，这个响应的 MIME类型为text/event- </div></div></div>
<div id="pf261" class="pf w0 h0" data-page-no="261"><div class="pc pc261 w0 h0"><div class="t m0 x2 h2 y1 ff10c fs0 fc0 sc0 ls7 ws0">21.5 其他跨域技术    591 </div><div class="t m0 x0 h3 y2 ff10c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff10e fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff10e fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ff10e fs3 fc2 sc0 ls1d wsb">16 </div><div class="t m0 x3 h8 y20 ff10e fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff10e fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff10e fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff10e fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff10e fs3 fc2 sc0 ls1d wsb">20 </div><div class="t m0 x3 h8 y25 ff10e fs3 fc2 sc0 ls1d wsb">21 </div><div class="t m0 x3 h8 y26 ff10e fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff10e fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ff10e fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff10e fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff114 fs1 fc0 sc0 ls9 ws2">stream。响应的格式是纯文本，最简单的情况是每个数据项都带有前缀data:，例如： </div><div class="t m0 x0 hb y121e ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3fab ff114 fs6 fc0 sc0 ls21 wsb">data: foo </div><div class="t m0 x0 hb y3fac ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3fad ff114 fs6 fc0 sc0 ls21 wsb">data: bar </div><div class="t m0 x0 hb y3fae ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3faf ff114 fs6 fc0 sc0 ls21 wsb">data: foo </div><div class="t m0 x0 hb y3fb0 ff114 fs6 fc0 sc0 ls21 wsb">data: bar </div><div class="t m0 x0 hb y3fb1 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3fb2 ff113 fs2 fc0 sc0 ls55 wsfc">对以上响应而言，事件流中的第一个message事件返回的 event.data值为&quot;foo&quot;，第二个</div><div class="t m0 x0 h4 y3fb3 ff114 fs1 fc0 sc0 ls9 ws2">message事件返回的event.data 值为&quot;bar&quot;，第三个message事件返回的 event.data值为</div><div class="t m0 x0 h4 y233c ff114 fs1 fc0 sc0 ls9 ws2">&quot;foo\nbar&quot;（注意中间的换行符）。对于多个连续的以data:开头的数据行，将作为多段数据解析，</div><div class="t m0 x0 h1e y3e1c ff113 fs2 fc0 sc0 ls8 wseb">每个值之间以一个换行符分隔。只有在包含data:的数据行后面有空行时，才会触发message事件，</div><div class="t m0 x0 h5 y3d7 ff113 fs2 fc0 sc0 ls8 wseb">因此在服务器上生成事件流时不能忘了多添加这一行。 </div><div class="t m0 x0 hc y3fb4 ff113 fs2 fc0 sc0 ls8 wseb">通过id:前缀可以给特定的事件指定一个关联的ID，这个ID行位于data:行前面或后面皆可： </div><div class="t m0 x0 hb y3fb5 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3fb6 ff114 fs6 fc0 sc0 ls21 wsb">data: foo </div><div class="t m0 x0 hb y3fb7 ff114 fs6 fc0 sc0 ls21 wsb">id: 1 </div><div class="t m0 x0 hb y3fb8 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1b1b ff113 fs2 fc0 sc0 ls8 wseb">设置了ID后，EventSource对象会跟踪上一次触发的事件。如果连接断开，会向服务器发送一个</div><div class="t m0 x0 h5 y3fb9 ff113 fs2 fc0 sc0 ls8 wseb">包含名为Last-Event-ID的特殊HTTP头部的请求，以便服务器知道下一次该触发哪个事件。在多次</div><div class="t m0 x0 h5 y3fba ff113 fs2 fc0 sc0 ls8 wseb">连接的事件流中，这种机制可以确保浏览器以正确的顺序收到连接的数据段。 </div><div class="t m0 x0 h20 y3375 ff111 fs3 fc0 sc0 ls248 ws214">21.5.5 Web Sockets </div><div class="t m0 x0 h5 y3fbb ff113 fs2 fc0 sc0 ls8 wseb">要说最令人津津乐道的新浏览器API，就得数Web Sockets了。Web Sockets的目标是在一个单独的</div><div class="t m0 x0 h5 y3fbc ff113 fs2 fc0 sc0 ls8 wseb">持久连接上提供全双工、双向通信。在JavaScript中创建了Web Socket之后，会有一个HTTP 请求发送</div><div class="t m0 x0 h5 y3fbd ff113 fs2 fc0 sc0 ls8 wseb">到浏览器以发起连接。在取得服务器响应后，建立的连接会使用HTTP升级从HTTP 协议交换为Web </div><div class="t m0 x0 h5 y3fbe ff10c fs2 fc0 sc0 ls138 ws133">Socket协议。也就是说，使用标准的HTTP服务器无法实现Web Sockets，只有支持这种协议的专门服</div><div class="t m0 x0 h5 y3fbf ff113 fs2 fc0 sc0 ls8 wseb">务器才能正常工作。 </div><div class="t m0 x0 h5 y3fc0 ff113 fs2 fc0 sc0 ls8 wseb">由于Web Sockets使用了自定义的协议，所以URL模式也略有不同。未加密的连接不再是http://，</div><div class="t m0 x0 h5 y26ed ff113 fs2 fc0 sc0 ls8 wseb">而是ws://；加密的连接也不是https://，而是wss://。在使用Web Socket URL时，必须带着这个</div><div class="t m0 x0 h5 y28e0 ff113 fs2 fc0 sc0 ls8 wseb">模式，因为将来还有可能支持其他模式。 </div><div class="t m0 x0 h5 y3fc1 ff113 fs2 fc0 sc0 ls8 wseb">使用自定义协议而非HTTP协议的好处是，能够在客户端和服务器之间发送非常少量的数据，而不</div><div class="t m0 x0 h5 y3fc2 ff113 fs2 fc0 sc0 ls8 wseb">必担心HTTP那样字节级的开销。由于传递的数据包很小，因此Web Sockets非常适合移动应用。毕竟</div><div class="t m0 x0 h4 y3fc3 ff113 fs2 fc0 sc0 ls8 wseb">对移动应用而言，带宽和网络延迟都是关键问题。使用自定义协议的缺点在于，制定协议的时间比制定</div><div class="t m0 x0 h5 y3fc4 ff10c fs2 fc0 sc0 ls5e ws392">JavaScript API的时间还要长。Web Sockets曾几度搁浅，就因为不断有人发现这个新协议存在一致性和</div><div class="t m0 x0 h5 y3fc5 ff113 fs2 fc0 sc0 ls8 wseb">安全性的问题。Firefox 4和Opera 11都曾默认启用Web Sockets，但在发布前夕又禁用了，因为又发现</div><div class="t m0 x0 h5 y3fc6 ff113 fs2 fc0 sc0 ls8 wseb">了安全隐患。目前支持Web Sockets的浏览器有Firefox 6+、Safari 5+、Chrome和iOS 4+版Safari。 </div><div class="t m0 x0 h2f y3fc7 ff111 fs2 fc0 sc0 lsb ws2ac">1. Web Sockets API </div><div class="t m0 x0 h14a y3fc8 ff113 fs2 fc0 sc0 ls8 wseb">要创建Web Socket，先实例一个WebSocket对象并传入要连接的URL： </div><div class="t m0 x0 hb ycc3 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3fc9 ff114 fs6 fc0 sc0 ls21 wsb">var socket = new WebSocket(&quot;ws://www.example.com/server.php&quot;); </div><div class="t m0 x0 hb y3fca ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y2fab ff113 fs2 fc0 sc0 ls8 wseb">注意，必须给WebSocket构造函数传入绝对URL。同源策略对Web Sockets 不适用，因此可以通</div><div class="t m0 x0 h4 y3fcb ff113 fs2 fc0 sc0 ls6 wsf7">过它打开到任何站点的连接。至于是否会与某个域中的页面通信，则完全取决于服务器。（通过握手信</div><div class="t m0 x0 h5 y3fcc ff113 fs2 fc0 sc0 ls8 wseb">息就可以知道请求来自何方。） </div></div></div>
<div id="pf262" class="pf w0 h0" data-page-no="262"><div class="pc pc262 w0 h0"><div class="t m0 x0 h2 y1 ff10c fs0 fc0 sc0 ls7 ws0">592  第21章 Ajax与Comet </div><div class="t m0 x0 h3 y2 ff10c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff113 fs2 fc0 sc0 ls8 wseb">实例化了WebSocket对象后，浏览器就会马上尝试创建连接。与XHR类似，WebSocket 也有一</div><div class="t m0 x0 hc y4d ff113 fs2 fc0 sc0 ls8 wseb">个表示当前状态的readyState属性。不过，这个属性的值与XHR并不相同，而是如下所示。 </div><div class="t m0 x0 h5 y4e ff112 fs1 fc0 sc0 ls2"> WebSocket.OPENING (0)：正在建立连接。 </div><div class="t m0 x0 h5 yd9 ff112 fs1 fc0 sc0 ls2"> WebSocket.OPEN (1)：已经建立连接。 </div><div class="t m0 x0 h5 y219 ff112 fs1 fc0 sc0 ls2"> WebSocket.CLOSING (2)：正在关闭连接。 </div><div class="t m0 x0 h5 y8 ff112 fs1 fc0 sc0 ls2"> WebSocket.CLOSE (3)：已经关闭连接。 </div><div class="t m0 x0 h4 y9 ff114 fs1 fc0 sc0 ls9 ws2">WebSocket没有readystatechange事件；不过，它有其他事件，对应着不同的状态。readyState</div><div class="t m0 x0 h5 ya ff113 fs2 fc0 sc0 ls8 wseb">的值永远从0开始。 </div><div class="t m0 x0 h5 yb ff113 fs2 fc0 sc0 ls8 wseb">要关闭Web Socket连接，可以在任何时候调用close()方法。 </div><div class="t m0 x0 hb y160 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y161 ff114 fs6 fc0 sc0 ls21 wsb">socket.close(); </div><div class="t m0 x0 hb y3fcd ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1f14 ff113 fs2 fc0 sc0 ls8 wseb">调用了close()之后，readyState的值立即变为2（正在关闭），而在关闭连接后就会变成3。 </div><div class="t m0 x0 h3c y3fce ff111 fs2 fc0 sc0 ls2e wsb">2. 发送和接收数据 </div><div class="t m0 x0 h5 y3fcf ff10c fs2 fc0 sc0 ls138 ws3ef">Web Socket打开之后，就可以通过连接发送和接收数据。要向服务器发送数据，使用send()方法</div><div class="t m0 x0 h5 y3fd0 ff113 fs2 fc0 sc0 ls8 wseb">并传入任意字符串，例如： </div><div class="t m0 x0 hb y3fd1 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3fd2 ff114 fs6 fc0 sc0 ls21 wsb">var socket = new WebSocket(&quot;ws://www.example.com/server.php&quot;); </div><div class="t m0 x0 hb y3fd3 ff115 fs6 fc0 sc0 ls21 wsb">socket.send(&quot;Hello world!&quot;); </div><div class="t m0 x0 hb y3fd4 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3fd5 ff113 fs2 fc0 sc0 ls8 wseb">因为Web Sockets只能通过连接发送纯文本数据，所以对于复杂的数据结构，在通过连接发送之前，</div><div class="t m0 x0 h5 y3fd6 ff113 fs2 fc0 sc0 ls8 wseb">必须进行序列化。下面的例子展示了先将数据序列化为一个JSON字符串，然后再发送到服务器： </div><div class="t m0 x0 hb y1ebf ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3fd7 ff114 fs6 fc0 sc0 ls21 wsb">var message = { </div><div class="t m0 x0 hb y3fd8 ff114 fs6 fc0 sc0 ls21 wsb">    time: new Date(), </div><div class="t m0 x0 hb y3fd9 ff114 fs6 fc0 sc0 ls21 wsb">    text: &quot;Hello world!&quot;, </div><div class="t m0 x0 hb y3fda ff114 fs6 fc0 sc0 ls21 wsb">    clientId: &quot;asdfp8734rew&quot; </div><div class="t m0 x0 hb y3fdb ff114 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y3fdc ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3fdd ff114 fs6 fc0 sc0 ls21 wsb">socket.send(JSON.stringify(message)); </div><div class="t m0 x0 hb y3fde ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y324b ff113 fs2 fc0 sc0 ls8 wseb">接下来，服务器要读取其中的数据，就要解析接收到的JSON字符串。 </div><div class="t m0 x0 h4 y3fdf ff113 fs2 fc0 sc0 ls8 wseb">当服务器向客户端发来消息时，WebSocket对象就会触发message事件。这个 message事件与</div><div class="t m0 x0 hc y3fe0 ff113 fs2 fc0 sc0 ls8 wseb">其他传递消息的协议类似，也是把返回的数据保存在event.data属性中。 </div><div class="t m0 x0 hb y13a9 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3fe1 ff114 fs6 fc0 sc0 ls21 wsb">socket.onmessage = function(event){ </div><div class="t m0 x0 hb y3fe2 ff114 fs6 fc0 sc0 ls21 wsb">    var data = event.data;  </div><div class="t m0 x0 hb y3fe3 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y3fe4 ff114 fs6 fc0 sc0 ls21 wsb">    //处理数据 </div><div class="t m0 x0 hb y3fe5 ff114 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y3fe6 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1d60 ff113 fs2 fc0 sc0 ls8 wseb">与通过send()发送到服务器的数据一样，event.data中返回的数据也是字符串。如果你想得到</div><div class="t m0 x0 h5 y1d61 ff113 fs2 fc0 sc0 ls8 wseb">其他格式的数据，必须手工解析这些数据。 </div><div class="t m0 x0 h3c y3fe7 ff111 fs2 fc0 sc0 ls2e wsb">3. 其他事件 </div><div class="t m0 x0 h5 y2a49 ff114 fs1 fc0 sc0 ls9 ws2">WebSocket对象还有其他三个事件，在连接生命周期的不同阶段触发。 </div><div class="t m0 x0 h5 ya30 ff112 fs1 fc0 sc0 ls2"> open：在成功建立连接时触发。 </div><div class="t m0 x0 h5 y3fe8 ff112 fs1 fc0 sc0 ls2"> error：在发生错误时触发，连接不能持续。 </div><div class="t m0 x0 h5 ya32 ff112 fs1 fc0 sc0 ls2"> close：在连接关闭时触发。 </div><div class="t m0 x0 h5 y846 ff114 fs1 fc0 sc0 ls9 ws2">WebSocket对象不支持DOM 2级事件侦听器，因此必须使用DOM 0级语法分 别定义每个事件处</div></div></div>
<div id="pf263" class="pf w0 h0" data-page-no="263"><div class="pc pc263 w0 h0"><div class="t m0 x2 h2 y1 ff10c fs0 fc0 sc0 ls7 ws0">21.6 安全  593 </div><div class="t m0 x0 h3 y2 ff10c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff10e fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff10e fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ff10e fs3 fc2 sc0 ls1d wsb">16 </div><div class="t m0 x3 h8 y20 ff10e fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff10e fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff10e fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff10e fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff10e fs3 fc2 sc0 ls1d wsb">20 </div><div class="t m0 x3 h8 y25 ff10e fs3 fc2 sc0 ls1d wsb">21 </div><div class="t m0 x3 h8 y26 ff10e fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff10e fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ff10e fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff10e fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff113 fs2 fc0 sc0 ls8">理程序。 </div><div class="t m0 x0 hb yfb2 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yfb3 ff114 fs6 fc0 sc0 ls21 wsb">var socket = new WebSocket(&quot;ws://www.example.com/server.php&quot;); </div><div class="t m0 x0 hb yfb4 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yfb5 ff114 fs6 fc0 sc0 ls21 wsb">socket.onopen = function(){  </div><div class="t m0 x0 hb yfb6 ff114 fs6 fc0 sc0 ls21 wsb">    alert(&quot;Connection established.&quot;); </div><div class="t m0 x0 hb yfb7 ff114 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb yfb8 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yfb9 ff114 fs6 fc0 sc0 ls21 wsb">socket.onerror = function(){ </div><div class="t m0 x0 hb yfba ff114 fs6 fc0 sc0 ls21 wsb">    alert(&quot;Connection error.&quot;); </div><div class="t m0 x0 hb yfbb ff114 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y2005 ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2006 ff114 fs6 fc0 sc0 ls21 wsb">socket.onclose = function(){ </div><div class="t m0 x0 hb y30db ff114 fs6 fc0 sc0 ls21 wsb">    alert(&quot;Connection closed.&quot;); </div><div class="t m0 x0 hb y3d2c ff114 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y293b ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y344b ff113 fs2 fc0 sc0 ls8 wseb">在这三个事件中，只有close事件的event对象有额外的信息。这个事件的事件对象有三个额外</div><div class="t m0 x0 h4 y3fe9 ff113 fs2 fc0 sc0 ls8 wseb">的属性：wasClean、code和reason。其中，wasClean是一个布尔值，表示连接是否已经明确地关</div><div class="t m0 x0 h1e y3fea ff113 fs2 fc0 sc0 ls8 wseb">闭；code是服务器返回的数值状态码；而reason是一个字符串，包含服务器发回的消息。可以把这</div><div class="t m0 x0 h5 y244e ff113 fs2 fc0 sc0 ls8 wseb">些信息显示给用户，也可以记录到日志中以便将来分析。 </div><div class="t m0 x0 hb y24ed ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3feb ff114 fs6 fc0 sc0 ls21 wsb">socket.onclose = function(event){  </div><div class="t m0 x0 hb y3fec ff114 fs6 fc0 sc0 ls21 wsb">    console.log(&quot;Was clean? &quot; + event.wasClean + &quot; Code=&quot; + event.code + &quot; Reason=&quot; </div><div class="t m0 x0 hb y3fed ff114 fs6 fc0 sc0 ls21 wsb">                + event.reason); </div><div class="t m0 x0 hb y3fee ff114 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 h20 y3fef ff111 fs3 fc0 sc0 ls248 ws214">21.5.6 SSE与Web Sockets </div><div class="t m0 x0 h5 y3cb0 ff113 fs2 fc0 sc0 ls8 wseb">面对某个具体的用例，在考虑是使用SSE还是使用Web Sockets时，可以考虑如下几个因素。首先，</div><div class="t m0 x0 h5 y3ff0 ff113 fs2 fc0 sc0 ls8 wseb">你是否有自由度建立和维护Web Sockets服务器？因为Web Socket协议不同于HTTP，所以现有服务器</div><div class="t m0 x0 h5 y3ff1 ff113 fs2 fc0 sc0 ls8 wseb">不能用于Web Socket通信。SSE倒是通过常规HTTP通信，因此现有服务器就可以满足需求。 </div><div class="t m0 x0 h4 y3ff2 ff113 fs2 fc0 sc0 ls6 wsf7">第二个要考虑的问题是到底需不需要双向通信。如果用例只需读取服务器数据（如比赛成绩），那</div><div class="t m0 x0 h5 y3ff3 ff113 fs2 fc0 sc0 ls2ab">么SSE比较容易实现。如果用例必须双向通信（如聊天室），那么Web Sockets显然更好。别忘了，在</div><div class="t m0 x0 h5 y3ff4 ff113 fs2 fc0 sc0 ls8 wseb">不能选择Web Sockets的情况下，组合XHR和SSE也是能实现双向通信的。 </div><div class="t m0 x0 hd y3ff5 ff111 fs7 fc0 sc0 ls245">21.6 安全 </div><div class="t m0 x0 h5 y3ff6 ff113 fs2 fc0 sc0 ls8 wseb">讨论Ajax和Comet安全的文章可谓连篇累牍，而相关主题的书也已经出了很多本了。大型Ajax应</div><div class="t m0 x0 h5 y3ff7 ff113 fs2 fc0 sc0 ls8 wseb">用程序的安全问题涉及面非常之广，但我们可以从普遍意义上探讨一些基本的问题。 </div><div class="t m0 x0 h5 y3ff8 ff113 fs2 fc0 sc0 ls8 wseb">首先，可以通过XHR访问的任何URL也可以通过浏览器或服务器来访问。下面的 URL就是一个</div><div class="t m0 x0 h5 y3ff9 ff113 fs2 fc0 sc0 ls8">例子。 </div><div class="t m0 x0 hb y3ffa ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3ffb ff114 fs6 fc0 sc0 ls21 wsb">/getuserinfo.php?id=23 </div><div class="t m0 x0 hb y3ffc ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3ffd ff113 fs2 fc0 sc0 ls8 wseb">如果是向这个URL发送请求，可以想象结果会返回ID为23 的用户的某些数据。谁也无法保证别</div><div class="t m0 x0 h5 y3ffe ff113 fs2 fc0 sc0 ls8 wseb">人不会将这个URL的用户ID修改为24、56或其他值。因此，getuserinfo.php文件必须知道请求者</div><div class="t m0 x0 h5 y3fff ff113 fs2 fc0 sc0 ls8 wseb">是否真的有权限访问要请求的数据；否则，你的服务器就会门户大开，任何人的数据都可能被泄漏出去。 </div><div class="t m0 x0 h5 y4000 ff113 fs2 fc0 sc0 ls8 wseb">对于未被授权系统有权访问某个资源的情况，我们称之为CSRF（Cross-Site Request Forgery，跨站</div><div class="t m0 x0 h5 y4001 ff113 fs2 fc0 sc0 ls8 wseb">点请求伪造）。未被授权系统会伪装自己，让处理请求的服务器认为它是合法的。受到CSRF攻击的Ajax</div></div></div>
<div id="pf264" class="pf w0 h0" data-page-no="264"><div class="pc pc264 w0 h0"><div class="t m0 x0 h2 y1 ff10c fs0 fc0 sc0 ls7 ws0">594  第21章 Ajax与Comet </div><div class="t m0 x0 h3 y2 ff10c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff113 fs2 fc0 sc0 ls8 wseb">程序有大有小，攻击行为既有旨在揭示系统漏洞的恶作剧，也有恶意的数据窃取或数据销毁。 </div><div class="t m0 x0 h5 y4d ff113 fs2 fc0 sc0 ls8 wseb">为确保通过XHR访问的URL安全，通行的做法就是验证发送请求者是否有权限访问相应的资源。</div><div class="t m0 x0 h5 yd8 ff113 fs2 fc0 sc0 ls8 wseb">有下列几种方式可供选择。 </div><div class="t m0 x0 h5 yd9 ff112 fs1 fc0 sc0 ls2"> 要求以SSL连接来访问可以通过XHR请求的资源。 </div><div class="t m0 x0 h5 y219 ff112 fs1 fc0 sc0 ls2"> 要求每一次请求都要附带经过相应算法计算得到的验证码。 </div><div class="t m0 x0 h5 y21a ff113 fs2 fc0 sc0 ls8 wseb">请注意，下列措施对防范CSRF攻击不起作用。 </div><div class="t m0 x0 h5 y9 ff112 fs1 fc0 sc0 ls2"> 要求发送POST而不是GET请求——很容易改变。 </div><div class="t m0 x0 h5 ya ff112 fs1 fc0 sc0 ls2"> 检查来源URL以确定是否可信——来源记录很容易伪造。 </div><div class="t m0 x0 h5 yb ff112 fs1 fc0 sc0 ls2"> 基于cookie信息进行验证——同样很容易伪造。 </div><div class="t m0 x0 h5 y78a ff10c fs2 fc0 sc0 ls81 ws76">XHR对象也提供了一些安全机制，虽然表面上看可以保证安全，但实际上却相当不可靠。实际上，</div><div class="t m0 x0 h1c y3048 ff113 fs2 fc0 sc0 ls8 wseb">前面介绍的open()方法还能再接收两个参数：要随请求一起发送的用户名和密码。带有这两个参数的</div><div class="t m0 x0 h5 ye ff113 fs2 fc0 sc0 ls8 wseb">请求可以通过SSL发送给服务器上的页面，如下面的例子所示。 </div><div class="t m0 x0 hb yccf ff114 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4003 ff114 fs6 fc0 sc0 ls21 wsb">xhr.open(&quot;get&quot;, &quot;example.php&quot;, true, &quot;username&quot;, &quot;password&quot;); //不要这样做！！ </div><div class="t m0 x0 h5 y4004 ff10c fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x5 ha y4005 ff10d fs2 fc0 sc0 ls30">即便可以考虑这种安全机制，但还是尽量不要这样做。把用户名和密码保存在</div><div class="t m0 x0 h5 y4006 ff10c fs2 fc0 sc0 lsb ws5">JavaScript代码中本身就是极为不安全的。任何人，只要他会使用JavaScript调试器，</div><div class="t m0 x0 h5 y52d ff10d fs2 fc0 sc0 ls8 ws14">就可以通过查看相应的变量发现纯文本形式的用户名和密码。 </div><div class="t m0 x0 hd y4007 ff111 fs7 fc0 sc0 ls245">21.7 小结 </div><div class="t m0 x0 h5 yf9c ff10c fs2 fc0 sc0 lsf wsa">Ajax是无需刷新页面就能够从服务器取得数据的一种方法。关于Ajax，可以从以下几方面来总结</div><div class="t m0 x0 h5 y4008 ff113 fs2 fc0 sc0 ls8">一下。 </div><div class="t m0 x0 h5 y4009 ff112 fs1 fc0 sc0 ls2"> 负责Ajax运作的核心对象是XMLHttpRequest（XHR）对象。 </div><div class="t m0 x0 h5 y400a ff112 fs1 fc0 sc0 ls2"> XHR对象由微软最早在IE5中引入，用于通过JavaScript从服务器取得 XML数据。 </div><div class="t m0 x0 h5 y400b ff112 fs1 fc0 sc0 ls2"> 在此之后，Firefox、Safari、Chrome和Opera都实现了相同的特性，使XHR成为了Web 的一个</div><div class="t m0 x0 h5 y2601 ff113 fs2 fc0 sc0 ls8 wseb">事实标准。 </div><div class="t m0 x0 h5 y1c0 ff112 fs1 fc0 sc0 ls2"> 虽然实现之间存在差异，但XHR对象的基本用法在不同浏览器间还是相对规范的，因此可以放</div><div class="t m0 x0 h5 y400c ff113 fs2 fc0 sc0 ls8 wseb">心地用在Web开发当中。 </div><div class="t m0 x0 h5 y400d ff113 fs2 fc0 sc0 ls8 wseb">同源策略是对XHR的一个主要约束，它为通信设置了“相同的域、相同的端口、相同的协议”这一</div><div class="t m0 x0 h4 y400e ff113 fs2 fc0 sc0 ls8 wseb">限制。试图访问上述限制之外的资源，都会引发安全错误，除非采用被认可的跨域解决方案。这个解决</div><div class="t m0 x0 h5 y400f ff113 fs2 fc0 sc0 ls8 wseb">方案叫做CORS（Cross-Origin Resource Sharing，跨源资源共享），IE8通过XDomainRequest对象支持</div><div class="t m0 x0 h5 y4010 ff10c fs2 fc0 sc0 ls90 ws6b">CORS，其他浏览器通过XHR对象原生支持CORS。图像Ping和JSONP 是另外两种跨域通信的技术，</div><div class="t m0 x0 h5 y4011 ff113 fs2 fc0 sc0 ls8 wseb">但不如CORS稳妥。 </div><div class="t m0 x0 h5 y4012 ff10c fs2 fc0 sc0 ls465 ws3e5">Comet是对Ajax的进一步扩展，让服务器几乎能够实时地向客户端推送数据。实现Comet 的手段</div><div class="t m0 x0 h5 y4013 ff113 fs2 fc0 sc0 ls8 wseb">主要有两个：长轮询和HTTP流。所有浏览器都支持长轮询，而只有部分浏览器原生支持HTTP流。SSE</div><div class="t m0 x0 h5 y4014 ff113 fs2 fc0 sc0 ls8">（Server-Sent Events，服务器发送事件）是一种实现Comet交互的浏览器API，既支持长轮询，也支持</div><div class="t m0 x0 h5 y4015 ff10c fs2 fc0 sc0 ls84 ws62">HTTP流。 </div></div></div>
<div id="pf265" class="pf w0 h0" data-page-no="265"><div class="pc pc265 w0 h0"><div class="t m0 x2 h2 y1 ff10c fs0 fc0 sc0 ls7 ws0">21.7 小结  595 </div><div class="t m0 x0 h3 y2 ff10c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff10e fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff10e fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ff10e fs3 fc2 sc0 ls1d wsb">16 </div><div class="t m0 x3 h8 y20 ff10e fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff10e fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff10e fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff10e fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff10e fs3 fc2 sc0 ls1d wsb">20 </div><div class="t m0 x3 h8 y25 ff10e fs3 fc2 sc0 ls1d wsb">21 </div><div class="t m0 x3 h8 y26 ff10e fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff10e fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ff10e fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff10e fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff10c fs2 fc0 sc0 ls8 ws3dd">Web Sockets是一种与服务器进行全双工、双向通信的信道。与其他方案不同，Web Sockets不使用</div><div class="t m0 x0 h5 y4d ff10c fs2 fc0 sc0 ls84 ws62">HTTP协议，而使用一种自定义的协议。这种协议专门为快速传输小数据设计。虽然要求使用不同的</div><div class="t m0 x0 h5 yd8 ff10c fs2 fc0 sc0 lsfd wscc">Web服务器，但却具有速度上的优势。 </div><div class="t m0 x0 h5 y28b ff113 fs2 fc0 sc0 ls8 wseb">各方面对Ajax和Comet的鼓吹吸引了越来越多的开发人员学习JavaScript，人们对Web开发的关注</div><div class="t m0 x0 h5 yfdb ff113 fs2 fc0 sc0 ls8 wseb">也再度升温。与Ajax有关的概念都还相对比较新，这些概念会随着时间推移继续发展。 </div><div class="t m0 x5 h5 y4016 ff10c fs2 fc0 sc0 lsf wsa">Ajax是一个非常庞大的主题，完整地讨论这个主题超出了本书的范围。要想了解</div><div class="t m0 x5 h5 y4017 ff10d fs2 fc0 sc0 ls8 ws14">有关Ajax的更多信息，请读者参考《Ajax高级程序设计（第2版）》。 </div><div class="t m0 x0 h5 y4018 ff10c fs2 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf266" class="pf w0 h0" data-page-no="266"><div class="pc pc266 w0 h0"><div class="t m0 x0 h2 y1 ff11c fs0 fc0 sc0 ls7 ws0">596  第22章 高级技巧 </div><div class="t m0 x0 h3 y2 ff11c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h9 y2a ff11e fs5 fc0 sc0 ls12 wsb">高 级 技 巧 </div><div class="t m0 x0 h3c y2b ff11f fs2 fc0 sc0 ls8">本章内容 </div><div class="t m0 x0 h5 y2c ff121 fs1 fc0 sc0 ls2"> 使用高级函数 </div><div class="t m0 x0 h5 y2d ff121 fs1 fc0 sc0 ls2"> 防篡改对象 </div><div class="t m0 x0 h5 y2871 ff121 fs1 fc0 sc0 ls2"> Yielding Timers </div><div class="t m0 x0 h5 y4019 ff11c fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y401a ff11c fs2 fc0 sc0 ls1b ws6e">avaScript是一种极其灵活的语言，具有多种使用风格。一般来说，编写JavaScript要么使用过</div><div class="t m0 x0 h4 y401b ff122 fs2 fc0 sc0 ls6 wsf7">程方式，要么使用面向对象方式。然而，由于它天生的动态属性，这种语言还能使用更为复杂</div><div class="t m0 x0 h5 y401c ff122 fs2 fc0 sc0 ls8 wseb">和有趣的模式。这些技巧要利用ECMAScript的语言特点、BOM扩展和DOM功能来获得强大的效果。 </div><div class="t m0 x0 hd y3333 ff120 fs7 fc0 sc0 ls245">22.1 高级函数 </div><div class="t m0 x0 h5 y2277 ff122 fs2 fc0 sc0 ls8 wseb">函数是JavaScript中最有趣的部分之一。它们本质上是十分简单和过程化的，但也可以是非常复杂</div><div class="t m0 x0 h4 y401d ff122 fs2 fc0 sc0 ls8 wseb">和动态的。一些额外的功能可以通过使用闭包来实现。此外，由于所有的函数都是对象，所以使用函数</div><div class="t m0 x0 h5 y401e ff122 fs2 fc0 sc0 ls8 wseb">指针非常简单。这些令JavaScript函数不仅有趣而且强大。以下几节描绘了几种在JavaScript中使用函数</div><div class="t m0 x0 h5 y401f ff122 fs2 fc0 sc0 ls8 wseb">的高级方法。 </div><div class="t m0 x0 h20 y1a78 ff120 fs3 fc0 sc0 ls248 ws214">22.1.1 安全的类型检测 </div><div class="t m0 x0 h5 y2e41 ff11c fs2 fc0 sc0 lsb ws5">JavaScript内置的类型检测机制并非完全可靠。事实上，发生错误否定及错误肯定的情况也不在少</div><div class="t m0 x0 h1e y2e42 ff122 fs2 fc0 sc0 ls8 wseb">数。比如说typeof操作符吧，由于它有一些无法预知的行为，经常会导致检测数据类型时得到不靠谱</div><div class="t m0 x0 h5 y4020 ff122 fs2 fc0 sc0 ls8 wseb">的结果。Safari（直至第4版）在对正则表达式应用typeof操作符时会返回&quot;function&quot;，因此很难确</div><div class="t m0 x0 h5 y2e44 ff122 fs2 fc0 sc0 ls8 wseb">定某个值到底是不是函数。 </div><div class="t m0 x0 he y4021 ff122 fs2 fc0 sc0 ls8 wseb">再比如，instanceof操作符在存在多个全局作用域（像一个页面包含多个frame）的情况下，也</div><div class="t m0 x0 h5 y26f1 ff122 fs2 fc0 sc0 ls8 wseb">是问题多多。一个经典的例子（第5章也提到过）就是像下面这样将对象标识为数组。 </div><div class="t m0 x0 hb y4022 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4023 ff123 fs6 fc0 sc0 ls21 wsb">var isArray = value instanceof Array; </div><div class="t m0 x0 hb y4024 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y4025 ff122 fs2 fc0 sc0 ls8 wseb">以上代码要返回true，value必须是一个数组，而且还必须与Array构造函数在同个全局作用域</div><div class="t m0 x0 h5 y4026 ff122 fs2 fc0 sc0 ls8 wseb">中。（别忘了，Array是window的属性。）如果value是在另个frame中定义的数组，那么以上代码</div><div class="t m0 x0 hc y4027 ff122 fs2 fc0 sc0 ls8 wseb">就会返回false。 </div><div class="t m0 x0 h4 y4028 ff122 fs2 fc0 sc0 ls8 wseb">在检测某个对象到底是原生对象还是开发人员自定义的对象的时候，也会有问题。出现这个问题的</div><div class="t m0 x0 he y4029 ff122 fs2 fc0 sc0 ls8 wseb">原因是浏览器开始原生支持JSON对象了。因为很多人一直在使用Douglas Crockford的JSON库，而该</div><div class="t m0 x0 h5 y402a ff122 fs2 fc0 sc0 ls8 wseb">库定义了一个全局JSON对象。于是开发人员很难确定页面中的JSON对象到底是不是原生的。 </div><div class="t m0 x0 h1e y402b ff122 fs2 fc0 sc0 ls8 wseb">解决上述问题的办法都一样。大家知道，在任何值上调用Object原生的toString()方法，都会</div><div class="t m0 x0 hf0 y402c ff124 fs14 fc0 sc0 ls392 wsb">J </div><div class="t m0 x0 h11 y4b ff125 fsa fc0 sc0 ls8">第</div><div class="t m1 x0 h12 y4b ff126 fsb fc3 sc0 ls247">22</div><div class="t m0 x5 h11 y4b ff125 fsa fc0 sc0 ls8 ws1d">章 </div></div></div>
<div id="pf267" class="pf w0 h0" data-page-no="267"><div class="pc pc267 w0 h0"><div class="t m0 x2 h2 y1 ff11c fs0 fc0 sc0 ls7 ws0">22.1 高级函数    597 </div><div class="t m0 x0 h3 y2 ff11c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff127 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff127 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff127 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff127 fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff127 fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff127 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff127 fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff127 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff127 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff127 fs3 fc2 sc0 ls1d wsb">22 </div><div class="t m0 x3 h8 y27 ff127 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff127 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff127 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h4 y3 ff122 fs2 fc0 sc0 ls30 wsf6">返回一个[object NativeConstructorName]格式的字符串。每个类在内部都有一个[[Class]]属</div><div class="t m0 x0 h5 y4d ff122 fs2 fc0 sc0 ls8 wseb">性，这个属性中就指定了上述字符串中的构造函数名。举个例子吧。 </div><div class="t m0 x0 hb y1701 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2984 ff123 fs6 fc0 sc0 ls21 wsb">alert(Object.prototype.toString.call(value));    //&quot;[object Array]&quot; </div><div class="t m0 x0 hb y3ad5 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3ad6 ff122 fs2 fc0 sc0 ls8 wseb">由于原生数组的构造函数名与全局作用域无关，因此使用toString()就能保证返回一致的值。利</div><div class="t m0 x0 h5 y3ad7 ff122 fs2 fc0 sc0 ls8 wseb">用这一点，可以创建如下函数： </div><div class="t m0 x0 hb y402d ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y402e ff123 fs6 fc0 sc0 ls21 wsb">function isArray(value){ </div><div class="t m0 x0 hb y402f ff123 fs6 fc0 sc0 ls21 wsb">    return Object.prototype.toString.call(value) == &quot;[object Array]&quot;; </div><div class="t m0 x0 hb y4030 ff123 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 hb y4031 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 yc36 ff122 fs2 fc0 sc0 ls8 wseb">同样，也可以基于这一思路来测试某个值是不是原生函数或正则表达式： </div><div class="t m0 x0 hb y347a ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4032 ff123 fs6 fc0 sc0 ls21 wsb">function isFunction(value){ </div><div class="t m0 x0 hb y4033 ff123 fs6 fc0 sc0 ls21 wsb">    return Object.prototype.toString.call(value) == &quot;[object Function]&quot;; </div><div class="t m0 x0 hb y4034 ff123 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y4035 ff123 fs6 fc0 sc0 ls21 wsb">function isRegExp(value){ </div><div class="t m0 x0 hb y4036 ff123 fs6 fc0 sc0 ls21 wsb">    return Object.prototype.toString.call(value) == &quot;[object RegExp]&quot;; </div><div class="t m0 x0 hb y4037 ff123 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y4038 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y4039 ff122 fs2 fc0 sc0 ls8 wseb">不过要注意，对于在IE中以COM对象形式实现的任何函数，isFunction()都将返回false（因</div><div class="t m0 x0 h5 y3caa ff122 fs2 fc0 sc0 ls8 wseb">为它们并非原生的JavaScript函数，请参考第10章中更详细的介绍）。 </div><div class="t m0 x0 h1e y403a ff122 fs2 fc0 sc0 ls8 wseb">这一技巧也广泛应用于检测原生JSON对象。Object的toString()方法不能检测非原生构造函</div><div class="t m0 x0 h5 y403b ff122 fs2 fc0 sc0 ls8 wseb">数的构造函数名。因此，开发人员定义的任何构造函数都将返回[object Object]。有些JavaScript库会包</div><div class="t m0 x0 h5 y403c ff122 fs2 fc0 sc0 ls8 wseb">含与下面类似的代码。 </div><div class="t m0 x0 hb y1fd0 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y403d ff123 fs6 fc0 sc0 ls21 wsb">var isNativeJSON = window.JSON &amp;&amp; Object.prototype.toString.call(JSON) == </div><div class="t m0 x0 hb y403e ff123 fs6 fc0 sc0 ls21 wsb">&quot;[object JSON]&quot;; </div><div class="t m0 x0 hb y403f ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y4040 ff122 fs2 fc0 sc0 lse7">在Web开发中能够区分原生与非原生JavaScript对象非常重要。只有这样才能确切知道某个对象到</div><div class="t m0 x0 h5 y4041 ff122 fs2 fc0 sc0 ls8 wseb">底有哪些功能。这个技巧可以对任何对象给出正确的结论。 </div><div class="t m0 x5 ha y4042 ff11d fs2 fc0 sc0 ls30 ws12c">请注意，Object.prototpye.toString()本身也可能会被修改。本节讨论的</div><div class="t m0 x5 h18 y4043 ff11d fs2 fc0 sc0 ls8 ws14">技巧假设Object.prototpye.toString()是未被修改过的原生版本。 </div><div class="t m0 x0 h20 y4044 ff120 fs3 fc0 sc0 ls248 ws214">22.1.2 作用域安全的构造函数 </div><div class="t m0 x0 h5 y19d3 ff122 fs2 fc0 sc0 ls3b">第6章讲述了用于自定义对象的构造函数的定义和用法。你应该还记得，构造函数其实就是一个使</div><div class="t m0 x0 h1e y19d4 ff122 fs2 fc0 sc0 ls469">用new操作符调用的函数。当使用new调用时，构造函数内用到的 this对象会指向新创建的对象实</div><div class="t m0 x0 h5 y4045 ff122 fs2 fc0 sc0 ls8 wseb">例，如下面的例子所示： </div><div class="t m0 x5 hb y4046 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4047 ff123 fs6 fc0 sc0 ls21 wsb">function Person(name, age, job){ </div><div class="t m0 x0 hb y4048 ff123 fs6 fc0 sc0 ls21 wsb">    this.name = name; </div><div class="t m0 x0 hb y4049 ff123 fs6 fc0 sc0 ls21 wsb">    this.age = age; </div><div class="t m0 x0 hb y404a ff123 fs6 fc0 sc0 ls21 wsb">    this.job = job; </div><div class="t m0 x0 hb y404b ff123 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y404c ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y404d ff123 fs6 fc0 sc0 ls21 wsb">var person = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;); </div><div class="t m0 x5 hb y404e ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1d8f ff128 fs2 fc0 sc0 lsc1 wsb">ScopeSafeConstructorsExample01.htm </div></div></div>
<div id="pf268" class="pf w0 h0" data-page-no="268"><div class="pc pc268 w0 h0"><div class="t m0 x0 h2 y1 ff11c fs0 fc0 sc0 ls7 ws0">598  第22章 高级技巧 </div><div class="t m0 x0 h3 y2 ff11c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ff122 fs2 fc0 sc0 ls8 wseb">上面这个例子中，Person构造函数使用this对象给三个属性赋值：name、age和job。当和new</div><div class="t m0 x0 h4 y4 ff122 fs2 fc0 sc0 ls8 wseb">操作符连用时，则会创建一个新的Person对象，同时会给它分配这些属性。问题出在当没有使用new</div><div class="t m0 x0 h4 y4e ff122 fs2 fc0 sc0 ls8 wseb">操作符来调用该构造函数的情况上。由于该this对象是在运行时绑定的，所以直接调用Person()，</div><div class="t m0 x0 h5 yd9 ff123 fs1 fc0 sc0 ls9 ws2">this会映射到全局对象window上，导致错误对象属性的意外增加。例如： </div><div class="t m0 x0 hb ya81 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ya82 ff123 fs6 fc0 sc0 ls21 wsb">var person = Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;); </div><div class="t m0 x0 hb ya83 ff123 fs6 fc0 sc0 ls21 wsb">alert(window.name);        //&quot;Nicholas&quot; </div><div class="t m0 x0 hb y1908 ff123 fs6 fc0 sc0 ls21 wsb">alert(window.age);         //29 </div><div class="t m0 x0 hb y1909 ff123 fs6 fc0 sc0 ls21 wsb">alert(window.job);         //&quot;Software Engineer&quot; </div><div class="t m0 x0 hb y4050 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf y147c ff128 fs2 fc0 sc0 lsc1 wsb">ScopeSafeConstructorsExample01.htm </div><div class="t m0 x0 h4 y4051 ff122 fs2 fc0 sc0 ls8 wseb">这里，原本针对Person实例的三个属性被加到window对象上，因为构造函数是作为普通函数调</div><div class="t m0 x0 h1e y4052 ff122 fs2 fc0 sc0 ls8 wseb">用的，忽略了new操作符。这个问题是由this对象的晚绑定造成的，在这里this被解析成了window</div><div class="t m0 x0 h5 y4053 ff122 fs2 fc0 sc0 ls8 wseb">对象。由于window的name属性是用于识别链接目标和frame 的，所以这里对该属性的偶然覆盖可能</div><div class="t m0 x0 h5 y4054 ff122 fs2 fc0 sc0 ls8 wseb">会导致该页面上出现其他错误。这个问题的解决方法就是创建一个。 </div><div class="t m0 x0 h1c y4055 ff122 fs2 fc0 sc0 ls8 wseb">作用域安全的构造函数在进行任何更改前，首先确认this对象是正确类型的实例。如果不是，那</div><div class="t m0 x0 h5 y4056 ff122 fs2 fc0 sc0 ls8 wseb">么会创建新的实例并返回。请看以下例子： </div><div class="t m0 x0 hb y4057 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4058 ff123 fs6 fc0 sc0 ls21 wsb">function Person(name, age, job){ </div><div class="t m0 x0 h15 y4059 ff129 fs6 fc0 sc0 ls21 wsb">    if (this instanceof Person){ </div><div class="t m0 x0 hb y405a ff123 fs6 fc0 sc0 ls21 wsb">        this.name = name; </div><div class="t m0 x0 hb y405b ff123 fs6 fc0 sc0 ls21 wsb">        this.age = age; </div><div class="t m0 x0 hb y405c ff123 fs6 fc0 sc0 ls21 wsb">        this.job = job; </div><div class="t m0 x0 hb y405d ff123 fs6 fc0 sc0 ls21 wsb">    } else { </div><div class="t m0 x0 h15 y405e ff129 fs6 fc0 sc0 ls21 wsb">        return new Person(name, age, job); </div><div class="t m0 x0 h15 y405f ff129 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y4060 ff123 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y4061 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y4062 ff129 fs6 fc0 sc0 ls21 wsb">var person1 = Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;); </div><div class="t m0 x0 h15 y4063 ff129 fs6 fc0 sc0 ls21 wsb">alert(window.name);      //&quot;&quot; </div><div class="t m0 x0 h15 y4064 ff129 fs6 fc0 sc0 ls21 wsb">alert(person1.name);     //&quot;Nicholas&quot; </div><div class="t m0 x0 h15 y4065 ff129 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y4066 ff129 fs6 fc0 sc0 ls21 wsb">var person2 = new Person(&quot;Shelby&quot;, 34, &quot;Ergonomist&quot;); </div><div class="t m0 x0 h15 y4067 ff129 fs6 fc0 sc0 ls21 wsb">alert(person2.name);     //&quot;Shelby&quot; </div><div class="t m0 x0 hb y4068 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf y38b7 ff128 fs2 fc0 sc0 lsc1 wsb">ScopeSafeConstructorsExample02.htm </div><div class="t m0 x0 h4 ycc ff122 fs2 fc0 sc0 ls8 wseb">这段代码中的Person构造函数添加了一个检查并确保this对象是 Person实例的if语句，它</div><div class="t m0 x0 h1e y4069 ff122 fs2 fc0 sc0 ls8 wseb">表示要么使用new操作符，要么在现有的Person实例环境中调用构造函数。任何一种情况下，对象初</div><div class="t m0 x0 h4 y2830 ff122 fs2 fc0 sc0 ls8 wseb">始化都能正常进行。如果this并非Person的实例，那么会再次使用new 操作符调用构造函数并返回</div><div class="t m0 x0 h1e y406a ff122 fs2 fc0 sc0 ls8 wseb">结果。最后的结果是，调用Person构造函数时无论是否使用new操作符，都会返回一个Person的新</div><div class="t m0 x0 h5 y406b ff122 fs2 fc0 sc0 ls8 wseb">实例，这就避免了在全局对象上意外设置属性。 </div><div class="t m0 x0 h4 y406c ff122 fs2 fc0 sc0 ls8 wseb">关于作用域安全的构造函数的贴心提示。实现这个模式后，你就锁定了可以调用构造函数的环境。</div><div class="t m0 x0 h5 y406d ff122 fs2 fc0 sc0 ls8 wseb">如果你使用构造函数窃取模式的继承且不使用原型链，那么这个继承很可能被破坏。这里有个例子： </div><div class="t m0 x0 hb y1334 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y406e ff123 fs6 fc0 sc0 ls21 wsb">function Polygon(sides){ </div><div class="t m0 x0 hb y406f ff123 fs6 fc0 sc0 ls21 wsb">    if (this instanceof Polygon) { </div><div class="t m0 x0 hb y4070 ff123 fs6 fc0 sc0 ls21 wsb">        this.sides = sides; </div><div class="t m0 x0 hb y4071 ff123 fs6 fc0 sc0 ls21 wsb">        this.getArea = function(){ </div></div></div>
<div id="pf269" class="pf w0 h0" data-page-no="269"><div class="pc pc269 w0 h0"><div class="t m0 x2 h2 y1 ff11c fs0 fc0 sc0 ls7 ws0">22.1 高级函数    599 </div><div class="t m0 x0 h3 y2 ff11c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff127 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff127 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff127 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff127 fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff127 fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff127 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff127 fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff127 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff127 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff127 fs3 fc2 sc0 ls1d wsb">22 </div><div class="t m0 x3 h8 y27 ff127 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff127 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff127 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y79 ff123 fs6 fc0 sc0 ls21 wsb">            return 0; </div><div class="t m0 x0 hb y7a ff123 fs6 fc0 sc0 ls21 wsb">        }; </div><div class="t m0 x0 hb y7b ff123 fs6 fc0 sc0 ls21 wsb">    } else { </div><div class="t m0 x0 hb y7c ff123 fs6 fc0 sc0 ls21 wsb">        return new Polygon(sides); </div><div class="t m0 x0 hb y7d ff123 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y7e ff123 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y7f ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y80 ff123 fs6 fc0 sc0 ls21 wsb">function Rectangle(width, height){ </div><div class="t m0 x0 hb y81 ff123 fs6 fc0 sc0 ls21 wsb">    Polygon.call(this, 2); </div><div class="t m0 x0 hb y82 ff123 fs6 fc0 sc0 ls21 wsb">    this.width = width; </div><div class="t m0 x0 hb y83 ff123 fs6 fc0 sc0 ls21 wsb">    this.height = height; </div><div class="t m0 x0 hb y84 ff123 fs6 fc0 sc0 ls21 wsb">    this.getArea = function(){ </div><div class="t m0 x0 hb y85 ff123 fs6 fc0 sc0 ls21 wsb">        return this.width * this.height; </div><div class="t m0 x0 hb y86 ff123 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 hb y87 ff123 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y88 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y89 ff123 fs6 fc0 sc0 ls21 wsb">var rect = new Rectangle(5, 10); </div><div class="t m0 x0 hb y8a ff123 fs6 fc0 sc0 ls21 wsb">alert(rect.sides);        //undefined </div><div class="t m0 x5 hb y4072 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y8b ff128 fs2 fc0 sc0 lsc1 wsb">ScopeSafeConstructorsExample03.htm </div><div class="t m0 x0 h4 y8c ff122 fs2 fc0 sc0 ls8 wseb">在这段代码中，Polygon构造函数是作用域安全的，然而Rectangle构造函数则不是。新创建一</div><div class="t m0 x0 h1e y4073 ff122 fs2 fc0 sc0 ls382">个Rectangle实例之后，这个实例应该通过Polygon.call()来继承Polygon的sides属性。但是，</div><div class="t m0 x0 h1e y8e ff122 fs2 fc0 sc0 ls8 wseb">由于Polygon构造函数是作用域安全的，this对象并非Polygon 的实例，所以会创建并返回一个新</div><div class="t m0 x0 h4 y4074 ff122 fs2 fc0 sc0 ls15a">的Polygon对象。Rectangle构造函数中的this对象并没有得到增长，同时Polygon.call()返回</div><div class="t m0 x0 hc y4075 ff122 fs2 fc0 sc0 ls8 wseb">的值也没有用到，所以Rectangle实例中就不会有sides属性。 </div><div class="t m0 x0 h5 y4076 ff122 fs2 fc0 sc0 ls8 wseb">如果构造函数窃取结合使用原型链或者寄生组合则可以解决这个问题。考虑以下例子： </div><div class="t m0 x5 hb y4077 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4078 ff123 fs6 fc0 sc0 ls21 wsb">function Polygon(sides){ </div><div class="t m0 x0 hb y4079 ff123 fs6 fc0 sc0 ls21 wsb">    if (this instanceof Polygon) { </div><div class="t m0 x0 hb y407a ff123 fs6 fc0 sc0 ls21 wsb">        this.sides = sides; </div><div class="t m0 x0 hb y407b ff123 fs6 fc0 sc0 ls21 wsb">        this.getArea = function(){ </div><div class="t m0 x0 hb y407c ff123 fs6 fc0 sc0 ls21 wsb">            return 0; </div><div class="t m0 x0 hb y407d ff123 fs6 fc0 sc0 ls21 wsb">        }; </div><div class="t m0 x0 hb y407e ff123 fs6 fc0 sc0 ls21 wsb">    } else { </div><div class="t m0 x0 hb y407f ff123 fs6 fc0 sc0 ls21 wsb">        return new Polygon(sides); </div><div class="t m0 x0 hb y4080 ff123 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y4081 ff123 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y4082 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4083 ff123 fs6 fc0 sc0 ls21 wsb">function Rectangle(width, height){ </div><div class="t m0 x0 hb y4084 ff123 fs6 fc0 sc0 ls21 wsb">    Polygon.call(this, 2); </div><div class="t m0 x0 hb y4085 ff123 fs6 fc0 sc0 ls21 wsb">    this.width = width; </div><div class="t m0 x0 hb y4086 ff123 fs6 fc0 sc0 ls21 wsb">    this.height = height; </div><div class="t m0 x0 hb y4087 ff123 fs6 fc0 sc0 ls21 wsb">    this.getArea = function(){ </div><div class="t m0 x0 hb y4088 ff123 fs6 fc0 sc0 ls21 wsb">        return this.width * this.height; </div><div class="t m0 x0 hb y4089 ff123 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 hb y408a ff123 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y408b ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y408c ff129 fs6 fc0 sc0 ls21 wsb">Rectangle.prototype = new Polygon(); </div><div class="t m0 x0 hb y408d ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y408e ff123 fs6 fc0 sc0 ls21 wsb">var rect = new Rectangle(5, 10); </div><div class="t m0 x0 hb y408f ff123 fs6 fc0 sc0 ls21 wsb">alert(rect.sides);        //2 </div><div class="t m0 x5 hb y4090 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf ye5a ff128 fs2 fc0 sc0 lsc1 wsb">ScopeSafeConstructorsExample04.htm </div></div></div>
<div id="pf26a" class="pf w0 h0" data-page-no="26a"><div class="pc pc26a w0 h0"><div class="t m0 x0 h2 y1 ff11c fs0 fc0 sc0 ls7 ws0">600  第22章 高级技巧 </div><div class="t m0 x0 h3 y2 ff11c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ff122 fs2 fc0 sc0 ls8 wseb">上面这段重写的代码中，一个Rectangle实例也同时是一个Polygon实例，所以Polygon.call()</div><div class="t m0 x0 h5 y4 ff122 fs2 fc0 sc0 ls8 wseb">会照原意执行，最终为Rectangle实例添加了sides属性。 </div><div class="t m0 x0 h5 y5 ff122 fs2 fc0 sc0 ls8 wseb">多个程序员在同一个页面上写JavaScript代码的环境中，作用域安全构造函数就很有用了。届时，</div><div class="t m0 x0 h4 y6 ff122 fs2 fc0 sc0 ls24 wsf5">对全局对象意外的更改可能会导致一些常常难以追踪的错误。除非你单纯基于构造函数窃取来实现继</div><div class="t m0 x0 h5 y7 ff122 fs2 fc0 sc0 ls8 wseb">承，推荐作用域安全的构造函数作为最佳实践。 </div><div class="t m0 x0 h20 y4091 ff120 fs3 fc0 sc0 ls248 ws214">22.1.3 惰性载入函数 </div><div class="t m0 x0 h5 y288a ff122 fs2 fc0 sc0 ls8 wseb">因为浏览器之间行为的差异，多数JavaScript代码包含了大量的if 语句，将执行引导到正确的代</div><div class="t m0 x0 hc y1f7 ff122 fs2 fc0 sc0 ls8 wseb">码中。看看下面来自上一章的createXHR()函数。 </div><div class="t m0 x0 hb y4092 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4093 ff123 fs6 fc0 sc0 ls21 wsb">function createXHR(){ </div><div class="t m0 x0 hb y4094 ff123 fs6 fc0 sc0 ls21 wsb">    if (typeof XMLHttpRequest != &quot;undefined&quot;){ </div><div class="t m0 x0 hb y4095 ff123 fs6 fc0 sc0 ls21 wsb">        return new XMLHttpRequest(); </div><div class="t m0 x0 hb y4096 ff123 fs6 fc0 sc0 ls21 wsb">    } else if (typeof ActiveXObject != &quot;undefined&quot;){ </div><div class="t m0 x0 hb y4097 ff123 fs6 fc0 sc0 ls21 wsb">        if (typeof arguments.callee.activeXString != &quot;string&quot;){ </div><div class="t m0 x0 hb y4098 ff123 fs6 fc0 sc0 ls21 wsb">            var versions = [&quot;MSXML2.XMLHttp.6.0&quot;, &quot;MSXML2.XMLHttp.3.0&quot;, </div><div class="t m0 x0 hb y4099 ff123 fs6 fc0 sc0 ls21 wsb">                            &quot;MSXML2.XMLHttp&quot;], </div><div class="t m0 x0 hb y409a ff123 fs6 fc0 sc0 ls21 wsb">                i,len; </div><div class="t m0 x0 hb y409b ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y409c ff123 fs6 fc0 sc0 ls21 wsb">            for (i=0,len=versions.length; i &lt; len; i++){ </div><div class="t m0 x0 hb y409d ff123 fs6 fc0 sc0 ls21 wsb">                 try { </div><div class="t m0 x0 hb y409e ff123 fs6 fc0 sc0 ls21 wsb">                     new ActiveXObject(versions[i]); </div><div class="t m0 x0 hb y409f ff123 fs6 fc0 sc0 ls21 wsb">                     arguments.callee.activeXString = versions[i]; </div><div class="t m0 x0 hb y40a0 ff123 fs6 fc0 sc0 ls21 wsb">                      break; </div><div class="t m0 x0 hb y40a1 ff123 fs6 fc0 sc0 ls21 wsb">                 } catch (ex){ </div><div class="t m0 x0 h16 y40a2 ff123 fs6 fc0 sc0 ls21 wsb">                      //跳过 </div><div class="t m0 x0 hb y40a3 ff123 fs6 fc0 sc0 ls21 wsb">                 } </div><div class="t m0 x0 hb y40a4 ff123 fs6 fc0 sc0 ls21 wsb">             } </div><div class="t m0 x0 hb y40a5 ff123 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y40a6 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y40a7 ff123 fs6 fc0 sc0 ls21 wsb">        return new ActiveXObject(arguments.callee.activeXString); </div><div class="t m0 x0 hb y40a8 ff123 fs6 fc0 sc0 ls21 wsb">    } else { </div><div class="t m0 x0 hb y40a9 ff123 fs6 fc0 sc0 ls21 wsb">        throw new Error(&quot;No XHR object available.&quot;); </div><div class="t m0 x0 hb y40aa ff123 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y40ab ff123 fs6 fc0 sc0 ls21 wsb">}   </div><div class="t m0 x0 h5 y40ac ff122 fs2 fc0 sc0 ls8 wseb">每次调用createXHR()的时候，它都要对浏览器所支持的能力仔细检查。首先检查内置的XHR，</div><div class="t m0 x0 h5 y40ad ff122 fs2 fc0 sc0 ls8 wseb">然后测试有没有基于ActiveX的XHR，最后如果都没有发现的话就抛出一个错误。每次调用该函数都是</div><div class="t m0 x0 h5 y40ae ff122 fs2 fc0 sc0 ls6 wsf7">这样，即使每次调用时分支的结果都不变：如果浏览器支持内置XHR，那么它就一直支持了，那么这</div><div class="t m0 x0 h1c y40af ff122 fs2 fc0 sc0 ls42 wsf0">种测试就变得没必要了。即使只有一个if语句的代码，也肯定要比没有if语句的慢，所以如果 if语</div><div class="t m0 x0 h5 y40b0 ff122 fs2 fc0 sc0 ls8 wseb">句不必每次执行，那么代码可以运行地更快一些。解决方案就是称之为惰性载入的技巧。 </div><div class="t m0 x0 h4 y40b1 ff122 fs2 fc0 sc0 ls8 wseb">惰性载入表示函数执行的分支仅会发生一次。有两种实现惰性载入的方式，第一种就是在函数被调</div><div class="t m0 x0 h4 y40b2 ff122 fs2 fc0 sc0 ls8 wseb">用时再处理函数。在第一次调用的过程中，该函数会被覆盖为另外一个按合适方式执行的函数，这样任</div><div class="t m0 x0 h4 y40b3 ff122 fs2 fc0 sc0 ls221 ws21e">何对原函数的调用都不用再经过执行的分支了。例如，可以用下面的方式使用惰性载入重写</div><div class="t m0 x0 h5 y40b4 ff123 fs1 fc0 sc0 ls9 ws2">createXHR()。 </div><div class="t m0 x0 hb y263b ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y40b5 ff123 fs6 fc0 sc0 ls21 wsb">function createXHR(){  </div><div class="t m0 x0 hb y40b6 ff123 fs6 fc0 sc0 ls21 wsb">    if (typeof XMLHttpRequest != &quot;undefined&quot;){ </div><div class="t m0 x0 hb y40b7 ff123 fs6 fc0 sc0 ls21 wsb">        createXHR = function(){ </div></div></div>
<div id="pf26b" class="pf w0 h0" data-page-no="26b"><div class="pc pc26b w0 h0"><div class="t m0 x2 h2 y1 ff11c fs0 fc0 sc0 ls7 ws0">22.1 高级函数    601 </div><div class="t m0 x0 h3 y2 ff11c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff127 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff127 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff127 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff127 fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff127 fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff127 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff127 fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff127 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff127 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff127 fs3 fc2 sc0 ls1d wsb">22 </div><div class="t m0 x3 h8 y27 ff127 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff127 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff127 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y12e1 ff123 fs6 fc0 sc0 ls21 wsb">            return new XMLHttpRequest(); </div><div class="t m0 x0 hb y40b8 ff123 fs6 fc0 sc0 ls21 wsb">        }; </div><div class="t m0 x0 hb y40b9 ff123 fs6 fc0 sc0 ls21 wsb">        } else if (typeof ActiveXObject != &quot;undefined&quot;){ </div><div class="t m0 x0 hb y40ba ff123 fs6 fc0 sc0 ls21 wsb">            createXHR = function(){ </div><div class="t m0 x0 hb y40bb ff123 fs6 fc0 sc0 ls21 wsb">                if (typeof arguments.callee.activeXString != &quot;string&quot;){ </div><div class="t m0 x0 hb y40bc ff123 fs6 fc0 sc0 ls21 wsb">                    var versions = [&quot;MSXML2.XMLHttp.6.0&quot;, &quot;MSXML2.XMLHttp.3.0&quot;, </div><div class="t m0 x0 hb y40bd ff123 fs6 fc0 sc0 ls21 wsb">                                     &quot;MSXML2.XMLHttp&quot;], </div><div class="t m0 x0 hb y40be ff123 fs6 fc0 sc0 ls21 wsb">                        i, len; </div><div class="t m0 x0 hb y40bf ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y40c0 ff123 fs6 fc0 sc0 ls21 wsb">                    for (i=0,len=versions.length; i &lt; len; i++){ </div><div class="t m0 x0 hb y40c1 ff123 fs6 fc0 sc0 ls21 wsb">                        try { </div><div class="t m0 x0 hb y40c2 ff123 fs6 fc0 sc0 ls21 wsb">                          new ActiveXObject(versions[i]); </div><div class="t m0 x0 hb y40c3 ff123 fs6 fc0 sc0 ls21 wsb">                          arguments.callee.activeXString = versions[i]; </div><div class="t m0 x0 hb y40c4 ff123 fs6 fc0 sc0 ls21 wsb">                             break; </div><div class="t m0 x0 hb y40c5 ff123 fs6 fc0 sc0 ls21 wsb">                        } catch (ex){ </div><div class="t m0 x0 hb y40c6 ff123 fs6 fc0 sc0 ls21 wsb">                            //skip </div><div class="t m0 x0 hb y40c7 ff123 fs6 fc0 sc0 ls21 wsb">                        } </div><div class="t m0 x0 hb y40c8 ff123 fs6 fc0 sc0 ls21 wsb">                    } </div><div class="t m0 x0 hb y40c9 ff123 fs6 fc0 sc0 ls21 wsb">                } </div><div class="t m0 x0 hb y40ca ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y40cb ff123 fs6 fc0 sc0 ls21 wsb">                return new ActiveXObject(arguments.callee.activeXString); </div><div class="t m0 x0 hb y40cc ff123 fs6 fc0 sc0 ls21 wsb">            }; </div><div class="t m0 x0 hb y40cd ff123 fs6 fc0 sc0 ls21 wsb">        } else { </div><div class="t m0 x0 hb y40ce ff123 fs6 fc0 sc0 ls21 wsb">            createXHR = function(){ </div><div class="t m0 x0 hb y40cf ff123 fs6 fc0 sc0 ls21 wsb">                throw new Error(&quot;No XHR object available.&quot;); </div><div class="t m0 x0 hb y40d0 ff123 fs6 fc0 sc0 ls21 wsb">            }; </div><div class="t m0 x0 hb y40d1 ff123 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y40d2 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y40d3 ff123 fs6 fc0 sc0 ls21 wsb">    return createXHR(); </div><div class="t m0 x0 hb y40d4 ff123 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x2 hf y40d5 ff128 fs2 fc0 sc0 ls1b wsb">LazyLoadingExample01.htm </div><div class="t m0 x0 h4 y271f ff122 fs2 fc0 sc0 ls8 wseb">在这个惰性载入的createXHR()中，if语句的每一个分支都会为createXHR变量赋值，有效覆</div><div class="t m0 x0 h1e y40d6 ff122 fs2 fc0 sc0 ls8 wseb">盖了原有的函数。最后一步便是调用新赋的函数。下一次调用createXHR()的时候，就会直接调用被</div><div class="t m0 x0 hc y40d7 ff122 fs2 fc0 sc0 ls8 wseb">分配的函数，这样就不用再次执行if语句了。 </div><div class="t m0 x0 h4 y119e ff122 fs2 fc0 sc0 ls8 wseb">第二种实现惰性载入的方式是在声明函数时就指定适当的函数。这样，第一次调用函数时就不会损</div><div class="t m0 x0 h5 y40d8 ff122 fs2 fc0 sc0 ls8 wseb">失性能了，而在代码首次加载时会损失一点性能。以下就是按照这一思路重写前面例子的结果。 </div><div class="t m0 x0 h15 y1888 ff129 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y40d9 ff129 fs6 fc0 sc0 ls21 wsb">var createXHR = (function(){  </div><div class="t m0 x0 hb y40da ff129 fs6 fc0 sc0 ls21 wsb">    if (typeof XMLHttpRequest != &quot;undefined&quot;){ </div><div class="t m0 x0 h15 y40db ff129 fs6 fc0 sc0 ls21 wsb">        return function(){ </div><div class="t m0 x0 hb y40dc ff129 fs6 fc0 sc0 ls21 wsb">            return new XMLHttpRequest(); </div><div class="t m0 x0 hb y40dd ff129 fs6 fc0 sc0 ls21 wsb">        }; </div><div class="t m0 x0 hb y40de ff129 fs6 fc0 sc0 ls21 wsb">    } else if (typeof ActiveXObject != &quot;undefined&quot;){ </div><div class="t m0 x0 h15 y40df ff129 fs6 fc0 sc0 ls21 wsb">        return function(){ </div><div class="t m0 x0 hb y40e0 ff129 fs6 fc0 sc0 ls21 wsb">            if (typeof arguments.callee.activeXString != &quot;string&quot;){ </div><div class="t m0 x0 hb y40e1 ff129 fs6 fc0 sc0 ls21 wsb">                var versions = [&quot;MSXML2.XMLHttp.6.0&quot;, &quot;MSXML2.XMLHttp.3.0&quot;, </div><div class="t m0 x0 hb y40e2 ff129 fs6 fc0 sc0 ls21 wsb">                                &quot;MSXML2.XMLHttp&quot;], </div><div class="t m0 x0 hb y40e3 ff129 fs6 fc0 sc0 ls21 wsb">                i, len; </div><div class="t m0 x0 hb y40e4 ff129 fs6 fc0 sc0 ls21 wsb">            for (i=0,len=versions.length; i &lt; len; i++){ </div><div class="t m0 x0 hb y40e5 ff129 fs6 fc0 sc0 ls21 wsb">                try { </div><div class="t m0 x0 hb y40e6 ff129 fs6 fc0 sc0 ls21 wsb">                    new ActiveXObject(versions[i]); </div><div class="t m0 x0 hb y40e7 ff129 fs6 fc0 sc0 ls21 wsb">                    arguments.callee.activeXString = versions[i]; </div><div class="t m0 x0 hb y40e8 ff129 fs6 fc0 sc0 ls21 wsb">                    break; </div><div class="t m0 x0 hb y40e9 ff129 fs6 fc0 sc0 ls21 wsb">                } catch (ex){ </div><div class="t m0 x0 hb y40ea ff129 fs6 fc0 sc0 ls21 wsb">                    //skip </div><div class="t m0 x0 hb y40eb ff129 fs6 fc0 sc0 ls21 wsb">                } </div><div class="t m0 x0 hb y40ec ff129 fs6 fc0 sc0 ls21 wsb">            } </div></div></div>
<div id="pf26c" class="pf w0 h0" data-page-no="26c"><div class="pc pc26c w0 h0"><div class="t m0 x0 h2 y1 ff11c fs0 fc0 sc0 ls7 ws0">602  第22章 高级技巧 </div><div class="t m0 x0 h3 y2 ff11c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y44f ff129 fs6 fc0 sc0 ls21 wsb">            } </div><div class="t m0 x0 hb y450 ff129 fs6 fc0 sc0 ls21 wsb">            return new ActiveXObject(arguments.callee.activeXString); </div><div class="t m0 x0 hb y451 ff129 fs6 fc0 sc0 ls21 wsb">        }; </div><div class="t m0 x0 hb y452 ff129 fs6 fc0 sc0 ls21 wsb">    } else { </div><div class="t m0 x0 h15 y453 ff129 fs6 fc0 sc0 ls21 wsb">        return function(){ </div><div class="t m0 x0 hb y454 ff129 fs6 fc0 sc0 ls21 wsb">            throw new Error(&quot;No XHR object available.&quot;); </div><div class="t m0 x0 hb y455 ff129 fs6 fc0 sc0 ls21 wsb">        }; </div><div class="t m0 x0 hb y456 ff129 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb ye88 ff123 fs6 fc0 sc0 ls21 wsb">})(); </div><div class="t m0 x0 hb y40ee ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y970 ff128 fs2 fc0 sc0 ls1b wsb">LazyLoadingExample02.htm </div><div class="t m0 x0 h4 y2b ff122 fs2 fc0 sc0 ls8 wseb">这个例子中使用的技巧是创建一个匿名、自执行的函数，用以确定应该使用哪一个函数实现。实际</div><div class="t m0 x0 h4 y40ef ff122 fs2 fc0 sc0 ls8 wseb">的逻辑都一样。不一样的地方就是第一行代码（使用var定义函数）、新增了自执行的匿名函数，另外</div><div class="t m0 x0 hc y40f0 ff122 fs2 fc0 sc0 ls8 wseb">每个分支都返回正确的函数定义，以便立即将其赋值给createXHR()。 </div><div class="t m0 x0 h4 y40f1 ff122 fs2 fc0 sc0 ls8 wseb">惰性载入函数的优点是只在执行分支代码时牺牲一点儿性能。至于哪种方式更合适，就要看你的具</div><div class="t m0 x0 h5 y40f2 ff122 fs2 fc0 sc0 ls8 wseb">体需求而定了。不过这两种方式都能避免执行不必要的代码。 </div><div class="t m0 x0 h20 y40f3 ff120 fs3 fc0 sc0 ls248 ws214">22.1.4 函数绑定 </div><div class="t m0 x0 h4 y3a5a ff122 fs2 fc0 sc0 ls8 wseb">另一个日益流行的高级技巧叫做函数绑定。函数绑定要创建一个函数，可以在特定的this环境中</div><div class="t m0 x0 h4 y40f4 ff122 fs2 fc0 sc0 ls8 wseb">以指定参数调用另一个函数。该技巧常常和回调函数与事件处理程序一起使用，以便在将函数作为变量</div><div class="t m0 x0 h5 y40f5 ff122 fs2 fc0 sc0 ls8 wseb">传递的同时保留代码执行环境。请看以下例子： </div><div class="t m0 x0 hb y40f6 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y40f7 ff123 fs6 fc0 sc0 ls21 wsb">var handler = {  </div><div class="t m0 x0 hb y40f8 ff123 fs6 fc0 sc0 ls21 wsb">    message: &quot;Event handled&quot;, </div><div class="t m0 x0 hb y40f9 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y40fa ff123 fs6 fc0 sc0 ls21 wsb">    handleClick: function(event){ </div><div class="t m0 x0 hb y40fb ff123 fs6 fc0 sc0 ls21 wsb">        alert(this.message); </div><div class="t m0 x0 hb y40fc ff123 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y40fd ff123 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y40fe ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y40ff ff123 fs6 fc0 sc0 ls21 wsb">var btn = document.getElementById(&quot;my-btn&quot;); </div><div class="t m0 x0 hb y4100 ff123 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(btn, &quot;click&quot;, handler.handleClick); </div><div class="t m0 x0 hb y4101 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y26ba ff122 fs2 fc0 sc0 ls8 wseb">在上面这个例子中，创建了一个叫做handler的对象。handler.handleClick()方法被分配为</div><div class="t m0 x0 h5 y345 ff122 fs2 fc0 sc0 ls8 wseb">一个DOM按钮的事件处理程序。当按下该按钮时，就调用该函数，显示一个警告框。虽然貌似警告框</div><div class="t m0 x0 h1e y2b20 ff122 fs2 fc0 sc0 ls38b ws2ff">应该显示Event handled，然而实际上显示的是undefiend 。这个问题在于没有保存</div><div class="t m0 x0 h5 y4102 ff123 fs1 fc0 sc0 ls9 ws2">handler.handleClick()的环境，所以this对象最后是指向了DOM按钮而非handler（在IE8 中，</div><div class="t m0 x0 h5 y4103 ff123 fs1 fc0 sc0 ls9 ws2">this指向window。）可以如下面例子所示，使用一个闭包来修正这个问题。 </div><div class="t m0 x0 hb y2b23 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4104 ff123 fs6 fc0 sc0 ls21 wsb">var handler = { </div><div class="t m0 x0 hb y4105 ff123 fs6 fc0 sc0 ls21 wsb">    message: &quot;Event handled&quot;, </div><div class="t m0 x0 hb y4106 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4107 ff123 fs6 fc0 sc0 ls21 wsb">    handleClick: function(event){ </div><div class="t m0 x0 hb y4108 ff123 fs6 fc0 sc0 ls21 wsb">        alert(this.message); </div><div class="t m0 x0 hb y4109 ff123 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y410a ff123 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y410b ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y410c ff123 fs6 fc0 sc0 ls21 wsb">var btn = document.getElementById(&quot;my-btn&quot;); </div><div class="t m0 x0 h15 y410d ff129 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(btn, &quot;click&quot;, function(event){ </div><div class="t m0 x0 h15 y410e ff129 fs6 fc0 sc0 ls21 wsb">    handler.handleClick(event); </div><div class="t m0 x0 h15 y410f ff129 fs6 fc0 sc0 ls21 wsb">}); </div></div></div>
<div id="pf26d" class="pf w0 h0" data-page-no="26d"><div class="pc pc26d w0 h0"><div class="t m0 x2 h2 y1 ff11c fs0 fc0 sc0 ls7 ws0">22.1 高级函数    603 </div><div class="t m0 x0 h3 y2 ff11c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff127 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff127 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff127 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff127 fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff127 fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff127 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff127 fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff127 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff127 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff127 fs3 fc2 sc0 ls1d wsb">22 </div><div class="t m0 x3 h8 y27 ff127 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff127 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff127 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h4 y3 ff122 fs2 fc0 sc0 ls8 wseb">这个解决方案在onclick事件处理程序内使用了一个闭包直接调用handler.handleClick()。</div><div class="t m0 x0 h4 y4d ff122 fs2 fc0 sc0 ls8 wseb">当然，这是特定于这段代码的解决方案。创建多个闭包可能会令代码变得难于理解和调试。因此，很多</div><div class="t m0 x0 he yd8 ff11c fs2 fc0 sc0 lsb ws5">JavaScript库实现了一个可以将函数绑定到指定环境的函数。这个函数一般都叫bind()。 </div><div class="t m0 x0 h4 yd9 ff122 fs2 fc0 sc0 ls8 wseb">一个简单的bind()函数接受一个函数和一个环境，并返回一个在给定环境中调用给定函数的函数，</div><div class="t m0 x0 h5 y15d ff122 fs2 fc0 sc0 ls8 wseb">并且将所有参数原封不动传递过去。语法如下： </div><div class="t m0 x5 hb y4ef ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yfdc ff123 fs6 fc0 sc0 ls21 wsb">function bind(fn, context){ </div><div class="t m0 x0 hb yfdd ff123 fs6 fc0 sc0 ls21 wsb">    return function(){ </div><div class="t m0 x0 hb yfde ff123 fs6 fc0 sc0 ls21 wsb">        return fn.apply(context, arguments); </div><div class="t m0 x0 hb yfdf ff123 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 hb yfe0 ff123 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x2 hf y1453 ff128 fs2 fc0 sc0 ls79 wsb">FunctionBindingExample01.htm </div><div class="t m0 x0 h4 y4110 ff122 fs2 fc0 sc0 ls8 wseb">这个函数似乎简单，但其功能是非常强大的。在bind()中创建了一个闭包，闭包使用apply()调</div><div class="t m0 x0 h1e y4111 ff122 fs2 fc0 sc0 ls8 wseb">用传入的函数，并给apply()传递context对象和参数。注意这里使用的 arguments对象是内部函</div><div class="t m0 x0 h1e y379e ff122 fs2 fc0 sc0 ls8 wseb">数的，而非bind()的。当调用返回的函数时，它会在给定环境中执行被传入的函数并给出所有参数。</div><div class="t m0 x0 h5 y4112 ff123 fs1 fc0 sc0 ls9 ws2">bind()函数按如下方式使用： </div><div class="t m0 x5 hb y4113 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4114 ff123 fs6 fc0 sc0 ls21 wsb">var handler = { </div><div class="t m0 x0 hb y4115 ff123 fs6 fc0 sc0 ls21 wsb">    message: &quot;Event handled&quot;, </div><div class="t m0 x0 hb y4116 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4117 ff123 fs6 fc0 sc0 ls21 wsb">    handleClick: function(event){ </div><div class="t m0 x0 hb y4118 ff123 fs6 fc0 sc0 ls21 wsb">        alert(this.message); </div><div class="t m0 x0 hb y4119 ff123 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y411a ff123 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y411b ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y411c ff123 fs6 fc0 sc0 ls21 wsb">var btn = document.getElementById(&quot;my-btn&quot;); </div><div class="t m0 x0 h15 y411d ff129 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(btn, &quot;click&quot;, bind(handler.handleClick, handler)); </div><div class="t m0 x5 hb y411e ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y30f6 ff128 fs2 fc0 sc0 ls79 wsb">FunctionBindingExample01.htm </div><div class="t m0 x0 h4 y3c0 ff122 fs2 fc0 sc0 ls8 wseb">在这个例子中，我们用bind()函数创建了一个保持了执行环境的函数，并将其传给EventUtil. </div><div class="t m0 x0 h21 y411f ff123 fs1 fc0 sc0 ls9 ws2">addHandler()。event对象也被传给了该函数，如下所示： </div><div class="t m0 x5 hb y3329 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4120 ff123 fs6 fc0 sc0 ls21 wsb">var handler = { </div><div class="t m0 x0 hb y4121 ff123 fs6 fc0 sc0 ls21 wsb">    message: &quot;Event handled&quot;, </div><div class="t m0 x0 hb y4122 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4123 ff123 fs6 fc0 sc0 ls21 wsb">    handleClick: function(event){ </div><div class="t m0 x0 h15 y4124 ff129 fs6 fc0 sc0 ls21 wsb">        alert(this.message + &quot;:&quot; + event.type); </div><div class="t m0 x0 hb y4125 ff123 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y4126 ff123 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y4127 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4128 ff123 fs6 fc0 sc0 ls21 wsb">var btn = document.getElementById(&quot;my-btn&quot;); </div><div class="t m0 x0 hb y4129 ff123 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(btn, &quot;click&quot;, bind(handler.handleClick, handler)); </div><div class="t m0 x5 hb y412a ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y11f4 ff128 fs2 fc0 sc0 ls79 wsb">FunctionBindingExample01.htm </div><div class="t m0 x0 h4 y11f5 ff123 fs1 fc0 sc0 ls9 ws2">handler.handleClick()方法和平时一样获得了event对象，因为所有的参数都通过被绑定的函</div><div class="t m0 x0 h5 y11f6 ff122 fs2 fc0 sc0 ls8 wseb">数直接传给了它。 </div><div class="t m0 x0 h5 y15fa ff11c fs2 fc0 sc0 ls25 ws57">ECMAScript 5为所有函数定义了一个原生的bind()方法，进一步简单了操作。换句话说，你不用</div><div class="t m0 x0 h5 y412b ff122 fs2 fc0 sc0 ls8 wseb">再自己定义bind()函数了，而是可以直接在函数上调用这个方法。例如： </div></div></div>
<div id="pf26e" class="pf w0 h0" data-page-no="26e"><div class="pc pc26e w0 h0"><div class="t m0 x0 h2 y1 ff11c fs0 fc0 sc0 ls7 ws0">604  第22章 高级技巧 </div><div class="t m0 x0 h3 y2 ff11c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 ff123 fs6 fc0 sc0 ls21 wsb">var handler = { </div><div class="t m0 x0 hb y7a ff123 fs6 fc0 sc0 ls21 wsb">    message: &quot;Event handled&quot;, </div><div class="t m0 x0 hb y7b ff123 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 hb y7c ff123 fs6 fc0 sc0 ls21 wsb">    handleClick: function(event){ </div><div class="t m0 x0 hb y7d ff123 fs6 fc0 sc0 ls21 wsb">         alert(this.message + &quot;:&quot; + event.type); </div><div class="t m0 x0 hb y7e ff123 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y7f ff123 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y80 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y81 ff123 fs6 fc0 sc0 ls21 wsb">var btn = document.getElementById(&quot;my-btn&quot;); </div><div class="t m0 x0 hb y82 ff123 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(btn, &quot;click&quot;, handler.handleClick.bind(handler)); </div><div class="t m0 x0 hb y412c ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1a03 ff128 fs2 fc0 sc0 ls79 wsb">FunctionBindingExample02.htm </div><div class="t m0 x0 h4 y412d ff122 fs2 fc0 sc0 ls8 wseb">原生的bind()方法与前面介绍的自定义bind()方法类似，都是要传入作为this值的对象。支持</div><div class="t m0 x0 hc y412e ff122 fs2 fc0 sc0 ls8 wseb">原生bind()方法的浏览器有IE9+、Firefox 4+和Chrome。 </div><div class="t m0 x0 h4 y412f ff122 fs2 fc0 sc0 ls8 wseb">只要是将某个函数指针以值的形式进行传递，同时该函数必须在特定环境中执行，被绑定函数的效</div><div class="t m0 x0 he y4130 ff122 fs2 fc0 sc0 ls8 wseb">用就突显出来了。它们主要用于事件处理程序以及 setTimeout() 和 setInterval()。然而，被绑</div><div class="t m0 x0 h4 y8b ff122 fs2 fc0 sc0 ls24 wsf5">定函数与普通函数相比有更多的开销，它们需要更多内存，同时也因为多重函数调用稍微慢一点，所</div><div class="t m0 x0 h5 y4131 ff122 fs2 fc0 sc0 ls8 wseb">以最好只在必要时使用。 </div><div class="t m0 x0 h20 y168 ff120 fs3 fc0 sc0 ls248 ws214">22.1.5 函数柯里化 </div><div class="t m0 x0 h5 ye70 ff122 fs2 fc0 sc0 ls6 wsf7">与函数绑定紧密相关的主题是函数柯里化（function currying），它用于创建已经设置好了一个或多</div><div class="t m0 x0 h4 y4132 ff122 fs2 fc0 sc0 ls8 wseb">个参数的函数。函数柯里化的基本方法和函数绑定是一样的：使用一个闭包返回一个函数。两者的区别</div><div class="t m0 x0 h5 y4133 ff122 fs2 fc0 sc0 ls8 wseb">在于，当函数被调用时，返回的函数还需要设置一些传入的参数。请看以下例子。 </div><div class="t m0 x0 hb y38bc ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4134 ff123 fs6 fc0 sc0 ls21 wsb">function add(num1, num2){ </div><div class="t m0 x0 hb y4135 ff123 fs6 fc0 sc0 ls21 wsb">    return num1 + num2; </div><div class="t m0 x0 hb y4136 ff123 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y4137 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4138 ff123 fs6 fc0 sc0 ls21 wsb">function curriedAdd(num2){ </div><div class="t m0 x0 hb y4139 ff123 fs6 fc0 sc0 ls21 wsb">    return add(5, num2); </div><div class="t m0 x0 hb y413a ff123 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y413b ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y413c ff123 fs6 fc0 sc0 ls21 wsb">alert(add(2, 3));     //5 </div><div class="t m0 x0 hb y413d ff123 fs6 fc0 sc0 ls21 wsb">alert(curriedAdd(3)); //8 </div><div class="t m0 x0 hb y413e ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y5de ff122 fs2 fc0 sc0 ls8 wseb">这段代码定义了两个函数：add()和curriedAdd()。后者本质上是在任何情况下第一个参数为5</div><div class="t m0 x0 hc y2b04 ff122 fs2 fc0 sc0 ls46c">的add()版本。尽管从技术上来说curriedAdd()并非柯里化的函数，但它很好地展示了其概念。 </div><div class="t m0 x0 h4 y211 ff122 fs2 fc0 sc0 ls8 wseb">柯里化函数通常由以下步骤动态创建：调用另一个函数并为它传入要柯里化的函数和必要参数。下</div><div class="t m0 x0 h5 y5e1 ff122 fs2 fc0 sc0 ls8 wseb">面是创建柯里化函数的通用方式。 </div><div class="t m0 x0 hb y5e2 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y5e3 ff123 fs6 fc0 sc0 ls21 wsb">function curry(fn){ </div><div class="t m0 x0 hb y5e4 ff123 fs6 fc0 sc0 ls21 wsb">    var args = Array.prototype.slice.call(arguments, 1); </div><div class="t m0 x0 hb y413f ff123 fs6 fc0 sc0 ls21 wsb">    return function(){ </div><div class="t m0 x0 hb y4140 ff123 fs6 fc0 sc0 ls21 wsb">        var innerArgs = Array.prototype.slice.call(arguments); </div><div class="t m0 x0 hb y4141 ff123 fs6 fc0 sc0 ls21 wsb">        var finalArgs = args.concat(innerArgs); </div><div class="t m0 x0 hb y4142 ff123 fs6 fc0 sc0 ls21 wsb">        return fn.apply(null, finalArgs); </div><div class="t m0 x0 hb y4143 ff123 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 hb y4144 ff123 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x2 hf y241c ff128 fs2 fc0 sc0 ls25 wsb">FunctionCurryingExample01.htm </div></div></div>
<div id="pf26f" class="pf w0 h0" data-page-no="26f"><div class="pc pc26f w0 h0"><div class="t m0 x2 h2 y1 ff11c fs0 fc0 sc0 ls7 ws0">22.1 高级函数    605 </div><div class="t m0 x0 h3 y2 ff11c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff127 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff127 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff127 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff127 fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff127 fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff127 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff127 fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff127 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff127 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff127 fs3 fc2 sc0 ls1d wsb">22 </div><div class="t m0 x3 h8 y27 ff127 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff127 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff127 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h4 y3 ff123 fs1 fc0 sc0 ls9 ws2">curry()函数的主要工作就是将被返回函数的参数进行排序。curry()的第一个参数是要进行柯里</div><div class="t m0 x0 h1e y4d ff122 fs2 fc0 sc0 ls8 wseb">化的函数，其他参数是要传入的值。为了获取第一个参数之后的所有参数，在arguments对象上调用</div><div class="t m0 x0 hc y5 ff122 fs2 fc0 sc0 ls2d8">了slice()方法，并传入参数1表示被返回的数组包含从第二个参数开始的所有参数。然后args数组</div><div class="t m0 x0 h4 yd9 ff122 fs2 fc0 sc0 ls8 wseb">包含了来自外部函数的参数。在内部函数中，创建了innerArgs数组用来存放所有传入的参数（又一</div><div class="t m0 x0 h1e y15d ff122 fs2 fc0 sc0 ls8 wseb">次用到了slice()）。有了存放来自外部函数和内部函数的参数数组后，就可以使用concat()方法将</div><div class="t m0 x0 h1e y21a ff122 fs2 fc0 sc0 ls8 wseb">它们组合为finalArgs，然后使用apply()将结果传递给该函数。注意这个函数并没有考虑到执行环</div><div class="t m0 x0 hc y15e ff122 fs2 fc0 sc0 ls8 wseb">境，所以调用apply()时第一个参数是null。curry()函数可以按以下方式应用。 </div><div class="t m0 x5 hb ycf5 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ycf6 ff123 fs6 fc0 sc0 ls21 wsb">function add(num1, num2){ </div><div class="t m0 x0 hb ycf7 ff123 fs6 fc0 sc0 ls21 wsb">    return num1 + num2; </div><div class="t m0 x0 hb ycf8 ff123 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb ycf9 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 ycfa ff129 fs6 fc0 sc0 ls21 wsb">var curriedAdd = curry(add, 5); </div><div class="t m0 x0 h15 ycfb ff129 fs6 fc0 sc0 ls21 wsb">alert(curriedAdd(3));   //8 </div><div class="t m0 x5 hb y4145 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y3715 ff128 fs2 fc0 sc0 ls25 wsb">FunctionCurryingExample01.htm </div><div class="t m0 x0 h4 y187a ff122 fs2 fc0 sc0 ls8 wseb">在这个例子中，创建了第一个参数绑定为5的add()的柯里化版本。当调用curriedAdd()并传</div><div class="t m0 x0 h1e y187b ff122 fs2 fc0 sc0 ls184">入3时，3会成为add()的第二个参数，同时第一个参数依然是5，最后结果便是和8。你也可以像下</div><div class="t m0 x0 h5 y4146 ff122 fs2 fc0 sc0 ls8 wseb">面例子这样给出所有的函数参数： </div><div class="t m0 x5 hb y4147 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4148 ff123 fs6 fc0 sc0 ls21 wsb">function add(num1, num2){ </div><div class="t m0 x0 hb y4149 ff123 fs6 fc0 sc0 ls21 wsb">    return num1 + num2; </div><div class="t m0 x0 hb y414a ff123 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y414b ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y414c ff129 fs6 fc0 sc0 ls21 wsb">var curriedAdd = curry(add, 5, 12); </div><div class="t m0 x0 h15 y414d ff129 fs6 fc0 sc0 ls21 wsb">alert(curriedAdd());   //17 </div><div class="t m0 x5 hb y414e ff123 fs6 fc0 sc0 ls8 wsb">  </div><div class="t m0 x2 hf y2ff2 ff128 fs2 fc0 sc0 ls25 wsb">FunctionCurryingExample01.htm </div><div class="t m0 x0 h5 y1fd1 ff122 fs2 fc0 sc0 ls8 wseb">在这里，柯里化的add()函数两个参数都提供了，所以以后就无需再传递它们了。 </div><div class="t m0 x0 h5 y1cd0 ff122 fs2 fc0 sc0 ls8 wseb">函数柯里化还常常作为函数绑定的一部分包含在其中，构造出更为复杂的bind()函数。例如： </div><div class="t m0 x5 hb y414f ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y4150 ff129 fs6 fc0 sc0 ls21 wsb">function bind(fn, context){ </div><div class="t m0 x0 h15 y4151 ff129 fs6 fc0 sc0 ls21 wsb">    var args = Array.prototype.slice.call(arguments, 2); </div><div class="t m0 x0 hb y4152 ff123 fs6 fc0 sc0 ls21 wsb">    return function(){ </div><div class="t m0 x0 hb y4153 ff123 fs6 fc0 sc0 ls21 wsb">        var innerArgs = Array.prototype.slice.call(arguments); </div><div class="t m0 x0 hb y4154 ff123 fs6 fc0 sc0 ls21 wsb">        var finalArgs = args.concat(innerArgs); </div><div class="t m0 x0 h15 y4155 ff129 fs6 fc0 sc0 ls21 wsb">        return fn.apply(context, finalArgs); </div><div class="t m0 x0 hb y4156 ff123 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 hb y4157 ff123 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x2 hf y4158 ff128 fs2 fc0 sc0 ls25 wsb">FunctionCurryingExample02.htm </div><div class="t m0 x0 h4 y4159 ff122 fs2 fc0 sc0 ls130">对curry()函数的主要更改在于传入的参数个数，以及它如何影响代码的结果。curry()仅仅接受</div><div class="t m0 x0 h1e y415a ff122 fs2 fc0 sc0 ls42 wsf0">一个要包裹的函数作为参数，而bind()同时接受函数和一个object对象。这表示给被绑定的函数的参</div><div class="t m0 x0 hc y415b ff122 fs2 fc0 sc0 ls8 wseb">数是从第三个开始而不是第二个，这就要更改slice()的第一处调用。另一处更改是在倒数第3行将</div><div class="t m0 x0 h4 y415c ff123 fs1 fc0 sc0 ls43 ws31">object对象传给apply()。当使用bind()时，它会返回绑定到给定环境的函数，并且可能它其中某些</div><div class="t m0 x0 h14e y415d ff122 fs2 fc0 sc0 ls42 wsf0">函数参数已经被设好。当你想除了event对象再额外给事件处理程序传递参数时，这非常有用，例如： </div></div></div>
<div id="pf270" class="pf w0 h0" data-page-no="270"><div class="pc pc270 w0 h0"><div class="t m0 x0 h2 y1 ff11c fs0 fc0 sc0 ls7 ws0">606  第22章 高级技巧 </div><div class="t m0 x0 h3 y2 ff11c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 ff123 fs6 fc0 sc0 ls21 wsb">var handler = { </div><div class="t m0 x0 hb y7a ff123 fs6 fc0 sc0 ls21 wsb">    message: &quot;Event handled&quot;, </div><div class="t m0 x0 hb y1d67 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1d68 ff123 fs6 fc0 sc0 ls21 wsb">    handleClick: function(name, event){ </div><div class="t m0 x0 h15 y1d69 ff129 fs6 fc0 sc0 ls21 wsb">        alert(this.message + &quot;:&quot;+ name + &quot;:&quot;+ event.type); </div><div class="t m0 x0 h15 y415f ff129 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y2b79 ff123 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y4160 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4161 ff123 fs6 fc0 sc0 ls21 wsb">var btn = document.getElementById(&quot;my-btn&quot;); </div><div class="t m0 x0 h15 y4162 ff129 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(btn, &quot;click&quot;, bind(handler.handleClick, handler, &quot;my-btn&quot;)); </div><div class="t m0 x0 hb y4163 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1993 ff128 fs2 fc0 sc0 ls25 wsb">FunctionCurryingExample02.htm </div><div class="t m0 x0 h4 y1aa9 ff122 fs2 fc0 sc0 ls8 wseb">在这个更新过的例子中，handler.handleClick()方法接受了两个参数：要处理的元素的名字和</div><div class="t m0 x0 h4 y4164 ff123 fs1 fc0 sc0 ls9 ws2">event对象。作为第三个参数传递给bind()函数的名字，又被传递给了handler.handleClick()，</div><div class="t m0 x0 hc y4165 ff122 fs2 fc0 sc0 ls46d">而handler.handleClick()也会同时接收到event对象。 </div><div class="t m0 x0 h5 y4166 ff11c fs2 fc0 sc0 ls79 ws73">ECMAScript 5的bind()方法也实现函数柯里化，只要在this的值之后再传入另一个参数即可。 </div><div class="t m0 x0 hb y4167 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4168 ff123 fs6 fc0 sc0 ls21 wsb">var handler = { </div><div class="t m0 x0 hb y4169 ff129 fs6 fc0 sc0 ls21 wsb">    message: &quot;Event handled&quot;, </div><div class="t m0 x0 h15 y416a ff129 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y416b ff129 fs6 fc0 sc0 ls21 wsb">    handleClick: function(name, event){ </div><div class="t m0 x0 h15 y416c ff129 fs6 fc0 sc0 ls21 wsb">        alert(this.message + &quot;:&quot; + name + &quot;:&quot; + event.type); </div><div class="t m0 x0 h15 y416d ff129 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y416e ff123 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y416f ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4170 ff123 fs6 fc0 sc0 ls21 wsb">var btn = document.getElementById(&quot;my-btn&quot;); </div><div class="t m0 x0 h15 y4171 ff129 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(btn, &quot;click&quot;, handler.handleClick.bind(handler, &quot;my-btn&quot;)); </div><div class="t m0 x0 hb y4172 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf yc3e ff128 fs2 fc0 sc0 ls25 wsb">FunctionCurryingExample03.htm </div><div class="t m0 x0 h5 y832 ff11c fs2 fc0 sc0 lsb ws5">JavaScript中的柯里化函数和绑定函数提供了强大的动态函数创建功能。使用bind()还是curry()</div><div class="t m0 x0 h4 y4173 ff122 fs2 fc0 sc0 ls8 wseb">要根据是否需要object对象响应来决定。它们都能用于创建复杂的算法和功能，当然两者都不应滥用，</div><div class="t m0 x0 h5 y4174 ff122 fs2 fc0 sc0 ls8 wseb">因为每个函数都会带来额外的开销。 </div><div class="t m0 x0 hd y4175 ff120 fs7 fc0 sc0 ls245">22.2 防篡改对象 </div><div class="t m0 x0 h5 y4176 ff11c fs2 fc0 sc0 lsb ws5">JavaScript共享的本质一直是开发人员心头的痛。因为任何对象都可以被在同一环境中运行的代码</div><div class="t m0 x0 h4 y4177 ff122 fs2 fc0 sc0 ls4">修改。开发人员很可能会意外地修改别人的代码，甚至更糟糕地，用不兼容的功能重写原生对象。</div><div class="t m0 x0 h5 y4178 ff11c fs2 fc0 sc0 ls79 ws73">ECMAScript 5致力于解决这个问题，可以让开发人员定义防篡改对象（tamper-proof object）。 </div><div class="t m0 x0 h5 y4179 ff122 fs2 fc0 sc0 ls8">第6章讨论了对象属性的问题，也讨论了如何手工设置每个属性的[[Configurable]]、</div><div class="t m0 x0 h4 y2d53 ff123 fs1 fc0 sc0 ls9 ws2">[[Writable]]、 [[Enumerable]]、[[Value]]、[[Get]]以及[[Set]]特性，以改变属性的行为。</div><div class="t m0 x0 h5 y417a ff122 fs2 fc0 sc0 ls8">类似地，ECMAScript 5也增加了几个方法，通过它们可以指定对象的行为。 </div><div class="t m0 x0 h5 y417b ff122 fs2 fc0 sc0 ls8 wseb">不过请注意：一旦把对象定义为防篡改，就无法撤销了。 </div><div class="t m0 x0 h20 y417c ff120 fs3 fc0 sc0 ls248 ws214">22.2.1 不可扩展对象 </div><div class="t m0 x0 h4 y2d57 ff122 fs2 fc0 sc0 ls8 wseb">默认情况下，所有对象都是可以扩展的。也就是说，任何时候都可以向对象中添加属性和方法。例</div><div class="t m0 x0 h5 y31ea ff122 fs2 fc0 sc0 ls8 wseb">如，可以像下面这样先定义一个对象，后来再给它添加一个属性。 </div></div></div>
<div id="pf271" class="pf w0 h0" data-page-no="271"><div class="pc pc271 w0 h0"><div class="t m0 x2 h2 y1 ff11c fs0 fc0 sc0 ls7 ws0">22.2 防篡改对象    607 </div><div class="t m0 x0 h3 y2 ff11c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff127 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff127 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff127 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff127 fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff127 fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff127 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff127 fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff127 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff127 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff127 fs3 fc2 sc0 ls1d wsb">22 </div><div class="t m0 x3 h8 y27 ff127 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff127 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff127 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y79 ff123 fs6 fc0 sc0 ls21 wsb">var person = { name: &quot;Nicholas&quot; }; </div><div class="t m0 x0 hb y7a ff123 fs6 fc0 sc0 ls21 wsb">person.age = 29; </div><div class="t m0 x0 h5 y417d ff11c fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y417e ff122 fs2 fc0 sc0 lsa ws10a">即使第一行代码已经完整定义person对象，但第二行代码仍然能给它添加属性。现在，使用</div><div class="t m0 x0 h5 y417f ff123 fs1 fc0 sc0 ls250 ws219">Object.preventExtensions()方法可以改变这个行为，让你不能再给对象添加属性和方法。 </div><div class="t m0 x0 h5 y4180 ff122 fs2 fc0 sc0 lsa">例如： </div><div class="t m0 x0 hb y899 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4181 ff123 fs6 fc0 sc0 ls21 wsb">var person = { name: &quot;Nicholas&quot; }; </div><div class="t m0 x0 h15 y4182 ff129 fs6 fc0 sc0 ls21 wsb">Object.preventExtensions(person); </div><div class="t m0 x0 hb y4183 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4184 ff123 fs6 fc0 sc0 ls21 wsb">person.age = 29; </div><div class="t m0 x0 hb y4185 ff123 fs6 fc0 sc0 ls21 wsb">alert(person.age); //undefined </div><div class="t m0 x0 hb y4186 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y4187 ff128 fs2 fc0 sc0 ls5e wsb">NonExtensibleObjectsExample01.htm </div><div class="t m0 x0 h4 yf6f ff122 fs2 fc0 sc0 ls8 wseb">在调用了Object.preventExtensions()方法后，就不能给person对象添加新属性和方法了。</div><div class="t m0 x0 h1e y4188 ff122 fs2 fc0 sc0 ls8 wseb">在非严格模式下，给对象添加新成员会导致静默失败，因此person.age将是undefined。而在严格</div><div class="t m0 x0 h5 y4189 ff122 fs2 fc0 sc0 ls8 wseb">模式下，尝试给不可扩展的对象添加新成员会导致抛出错误。 </div><div class="t m0 x0 h4 y418a ff122 fs2 fc0 sc0 ls8 wseb">虽然不能给对象添加新成员，但已有的成员则丝毫不受影响。你仍然还可以修改和删除已有的成员。</div><div class="t m0 x0 he y418b ff122 fs2 fc0 sc0 ls8 wseb">另外，使用Object.istExtensible()方法还可以确定对象是否可以扩展。 </div><div class="t m0 x0 hb y418c ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y418d ff123 fs6 fc0 sc0 ls21 wsb">var person = { name: &quot;Nicholas&quot; }; </div><div class="t m0 x0 h15 y418e ff129 fs6 fc0 sc0 ls21 wsb">alert(Object.isExtensible(person));   //true </div><div class="t m0 x0 hb y418f ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4190 ff123 fs6 fc0 sc0 ls21 wsb">Object.preventExtensions(person); </div><div class="t m0 x0 h15 y4191 ff129 fs6 fc0 sc0 ls21 wsb">alert(Object.isExtensible(person));  //false </div><div class="t m0 x0 h15 y4192 ff129 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y26e7 ff128 fs2 fc0 sc0 ls5e wsb">NonExtensibleObjectsExample02.htm </div><div class="t m0 x0 h20 y4040 ff120 fs3 fc0 sc0 ls248 ws214">22.2.2 密封的对象 </div><div class="t m0 x0 h5 y4193 ff11c fs2 fc0 sc0 ls25 ws61">ECMAScript 5为对象定义的第二个保护级别是密封对象（sealed object）。密封对象不可扩展，而</div><div class="t m0 x0 h1e y4194 ff122 fs2 fc0 sc0 ls8 wseb">且已有成员的[[Configurable]]特性将被设置为false。这就意味着不能删除属性和方法，因为不能</div><div class="t m0 x0 hc y4195 ff122 fs2 fc0 sc0 ls8 wseb">使用Object.defineProperty()把数据属性修改为访问器属性，或者相反。属性值是可以修改的。 </div><div class="t m0 x0 hc y4196 ff122 fs2 fc0 sc0 ls8 wseb">要密封对象，可以使用Object.seal()方法。 </div><div class="t m0 x0 hb y7e9 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4197 ff123 fs6 fc0 sc0 ls21 wsb">var person = { name: &quot;Nicholas&quot; }; </div><div class="t m0 x0 h15 y4198 ff129 fs6 fc0 sc0 ls21 wsb">Object.seal(person); </div><div class="t m0 x0 hb y4199 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y419a ff123 fs6 fc0 sc0 ls21 wsb">person.age = 29; </div><div class="t m0 x0 hb y419b ff123 fs6 fc0 sc0 ls21 wsb">alert(person.age);   //undefined </div><div class="t m0 x0 hb y419c ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y419d ff123 fs6 fc0 sc0 ls21 wsb">delete person.name; </div><div class="t m0 x0 hb y419e ff123 fs6 fc0 sc0 ls21 wsb">alert(person.name);  //&quot;Nicholas&quot; </div><div class="t m0 x2 hf y419f ff128 fs2 fc0 sc0 ls8 wsb">SealedObjectsExample01.htm </div><div class="t m0 x0 h4 y203e ff122 fs2 fc0 sc0 ls8 wseb">在这个例子中，添加age属性的行为被忽略了。而尝试删除name属性的操作也被忽略了，因此这</div><div class="t m0 x0 h4 y41a0 ff122 fs2 fc0 sc0 ls8 wseb">个属性没有受任何影响。这是在非严格模式下的行为。在严格模式下，尝试添加或删除对象成员都会导</div><div class="t m0 x0 h5 y41a1 ff122 fs2 fc0 sc0 ls8 wseb">致抛出错误。 </div></div></div>
<div id="pf272" class="pf w0 h0" data-page-no="272"><div class="pc pc272 w0 h0"><div class="t m0 x0 h2 y1 ff11c fs0 fc0 sc0 ls7 ws0">608  第22章 高级技巧 </div><div class="t m0 x0 h3 y2 ff11c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ff122 fs2 fc0 sc0 ls8 wseb">使用Object.isSealed()方法可以确定对象是否被密封了。因为被密封的对象不可扩展，所以用</div><div class="t m0 x0 h5 y4 ff123 fs1 fc0 sc0 ls9 ws2">Object.isExtensible()检测密封的对象也会返回false。 </div><div class="t m0 x0 hb y3850 ff123 fs6 fc0 sc0 ls21 wsb">var person = { name: &quot;Nicholas&quot; }; </div><div class="t m0 x0 h15 y3851 ff129 fs6 fc0 sc0 ls21 wsb">alert(Object.isExtensible(person)); //true </div><div class="t m0 x0 h15 y3852 ff129 fs6 fc0 sc0 ls21 wsb">alert(Object.isSealed(person));     //false </div><div class="t m0 x0 hb y3853 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3854 ff123 fs6 fc0 sc0 ls21 wsb">Object.seal(person); </div><div class="t m0 x0 h15 y3855 ff129 fs6 fc0 sc0 ls21 wsb">alert(Object.isExtensible(person)); //false </div><div class="t m0 x0 h15 y3856 ff129 fs6 fc0 sc0 ls21 wsb">alert(Object.isSealed(person));     //true </div><div class="t m0 x0 hb y3857 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y3cca ff128 fs2 fc0 sc0 ls8 wsb">SealedObjectsExample02.htm </div><div class="t m0 x0 h20 y2b9 ff120 fs3 fc0 sc0 ls248 ws214">22.2.3 冻结的对象 </div><div class="t m0 x0 h5 y41a3 ff122 fs2 fc0 sc0 ls8 wseb">最严格的防篡改级别是冻结对象（frozen object）。冻结的对象既不可扩展，又是密封的，而且对象</div><div class="t m0 x0 h1e y41a4 ff122 fs2 fc0 sc0 ls8 wseb">数据属性的[[Writable]]特性会被设置为false。如果定义[[Set]]函数，访问器属性仍然是可写的。</div><div class="t m0 x0 h5 y41a5 ff11c fs2 fc0 sc0 ls79 ws73">ECMAScript 5定义的Object.freeze()方法可以用来冻结对象。 </div><div class="t m0 x0 hb y2faf ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y41a6 ff123 fs6 fc0 sc0 ls21 wsb">var person = { name: &quot;Nicholas&quot; }; </div><div class="t m0 x0 h15 y41a7 ff129 fs6 fc0 sc0 ls21 wsb">Object.freeze(person); </div><div class="t m0 x0 hb y41a8 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y41a9 ff123 fs6 fc0 sc0 ls21 wsb">person.age = 29; </div><div class="t m0 x0 hb y41aa ff123 fs6 fc0 sc0 ls21 wsb">alert(person.age);     //undefined </div><div class="t m0 x0 hb y41ab ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y41ac ff123 fs6 fc0 sc0 ls21 wsb">delete person.name; </div><div class="t m0 x0 hb y41ad ff123 fs6 fc0 sc0 ls21 wsb">alert(person.name);   //&quot;Nicholas&quot; </div><div class="t m0 x0 hb y41ae ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y41af ff123 fs6 fc0 sc0 ls21 wsb">person.name = &quot;Greg&quot;; </div><div class="t m0 x0 hb y41b0 ff123 fs6 fc0 sc0 ls21 wsb">alert(person.name);   //&quot;Nicholas&quot; </div><div class="t m0 x0 hb y41b1 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y41b2 ff128 fs2 fc0 sc0 ls2b wsb">FrozenObjectsExample01.htm </div><div class="t m0 x0 h4 y41b3 ff122 fs2 fc0 sc0 ls8 wseb">与密封和不允许扩展一样，对冻结的对象执行非法操作在非严格模式下会被忽略，而在严格模式下</div><div class="t m0 x0 h5 y41b4 ff122 fs2 fc0 sc0 ls8 wseb">会抛出错误。 </div><div class="t m0 x0 h1c y41b5 ff122 fs2 fc0 sc0 ls8 wseb">当然，也有一个Object.isFrozen()方法用于检测冻结对象。因为冻结对象既是密封的又是不可</div><div class="t m0 x0 h4 y1c5f ff122 fs2 fc0 sc0 ls8 wseb">扩展的，所以用Object.isExtensible()和Object.isSealed()检测冻结对象将分别返回false</div><div class="t m0 x0 h5 y1dc4 ff122 fs2 fc0 sc0 ls2c">和true。 </div><div class="t m0 x0 hb y41b6 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y41b7 ff123 fs6 fc0 sc0 ls21 wsb">var person = { name: &quot;Nicholas&quot; }; </div><div class="t m0 x0 hb y41b8 ff123 fs6 fc0 sc0 ls21 wsb">alert(Object.isExtensible(person));   //true </div><div class="t m0 x0 hb y41b9 ff123 fs6 fc0 sc0 ls21 wsb">alert(Object.isSealed(person));    //false </div><div class="t m0 x0 hb y41ba ff123 fs6 fc0 sc0 ls21 ws3fa">alert(Object.isFrozen(person));  //false </div><div class="t m0 x0 hb y41bb ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y41bc ff123 fs6 fc0 sc0 ls21 wsb">Object.freeze(person); </div><div class="t m0 x0 hb y41bd ff123 fs6 fc0 sc0 ls21 wsb">alert(Object.isExtensible(person));   //false </div><div class="t m0 x0 hb y41be ff123 fs6 fc0 sc0 ls21 wsb">alert(Object.isSealed(person));    //true </div><div class="t m0 x0 hb y41bf ff123 fs6 fc0 sc0 ls21 wsb">alert(Object.isFrozen(person));    //true </div><div class="t m0 x2 hf y41c0 ff128 fs2 fc0 sc0 ls2b wsb">FrozenObjectsExample02.htm </div></div></div>
<div id="pf273" class="pf w0 h0" data-page-no="273"><div class="pc pc273 w0 h0"><div class="t m0 x2 h2 y1 ff11c fs0 fc0 sc0 ls7 ws0">22.3 高级定时器    609 </div><div class="t m0 x0 h3 y2 ff11c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff127 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff127 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff127 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff127 fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff127 fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff127 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff127 fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff127 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff127 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff127 fs3 fc2 sc0 ls1d wsb">22 </div><div class="t m0 x3 h8 y27 ff127 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff127 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff127 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff122 fs2 fc0 sc0 ls3b">对JavaScript库的作者而言，冻结对象是很有用的。因为JavaScript库最怕有人意外（或有意）地修</div><div class="t m0 x0 h5 y4d ff122 fs2 fc0 sc0 ls8 wseb">改了库中的核心对象。冻结（或密封）主要的库对象能够防止这些问题的发生。 </div><div class="t m0 x0 hd y8c6 ff120 fs7 fc0 sc0 ls245">22.3 高级定时器 </div><div class="t m0 x0 h4 y8c7 ff122 fs2 fc0 sc0 ls8 wseb">使用setTimeout()和setInterval()创建的定时器可以用于实现有趣且有用的功能。虽然人们</div><div class="t m0 x0 h5 y8c8 ff122 fs2 fc0 sc0 ls3b">对JavaScript的定时器存在普遍的误解，认为它们是线程，其实JavaScript是运行于单线程的环境中的，</div><div class="t m0 x0 h4 y3ebb ff122 fs2 fc0 sc0 ls8 wseb">而定时器仅仅只是计划代码在未来的某个时间执行。执行时机是不能保证的，因为在页面的生命周期中，</div><div class="t m0 x0 h5 y3ebc ff122 fs2 fc0 sc0 ls8 wseb">不同时间可能有其他代码在控制JavaScript进程。在页面下载完后的代码运行、事件处理程序、Ajax回</div><div class="t m0 x0 h4 y3ebd ff122 fs2 fc0 sc0 ls8 wseb">调函数都必须使用同样的线程来执行。实际上，浏览器负责进行排序，指派某段代码在某个时间点运行</div><div class="t m0 x0 h5 y3ebe ff122 fs2 fc0 sc0 ls8 wseb">的优先级。 </div><div class="t m0 x0 h5 y3ebf ff122 fs2 fc0 sc0 ls8 wseb">可以把JavaScript想象成在时间线上运行的。当页面载入时，首先执行是任何包含在&lt;script&gt;元素</div><div class="t m0 x0 h4 y8cd ff122 fs2 fc0 sc0 ls8 wseb">中的代码，通常是页面生命周期后面要用到的一些简单的函数和变量的声明，不过有时候也包含一些初</div><div class="t m0 x0 h5 y8ce ff122 fs2 fc0 sc0 ls6 wsf7">始数据的处理。在这之后，JavaScript进程将等待更多代码执行。当进程空闲的时候，下一个代码会被</div><div class="t m0 x0 he y2fae ff122 fs2 fc0 sc0 ls8 wseb">触发并立刻执行。例如，当点击某个按钮时，onclick事件处理程序会立刻执行，只要JavaScript进程</div><div class="t m0 x0 h5 y187b ff122 fs2 fc0 sc0 ls8 wseb">处于空闲状态。这样一个页面的时间线类似于图22-1。 </div><div class="t m0 x6 h5 y41c1 ff11c fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 h3 y41c2 ff122 fs1 fc0 sc0 ls8 wsb">图 22-1 </div><div class="t m0 x0 h5 y55e ff122 fs2 fc0 sc0 ls8 wseb">除了主JavaScript执行进程外，还有一个需要在进程下一次空闲时执行的代码队列。随着页面在其</div><div class="t m0 x0 h4 y21fd ff122 fs2 fc0 sc0 ls8 wseb">生命周期中的推移，代码会按照执行顺序添加入队列。例如，当某个按钮被按下时，它的事件处理程序</div><div class="t m0 x0 h5 y41c3 ff122 fs2 fc0 sc0 ls8 wseb">代码就会被添加到队列中，并在下一个可能的时间里执行。当接收到某个Ajax响应时，回调函数的代</div><div class="t m0 x0 h5 y41c4 ff122 fs2 fc0 sc0 ls8 wseb">码会被添加到队列。在JavaScript中没有任何代码是立刻执行的，但一旦进程空闲则尽快执行。 </div><div class="t m0 x0 h4 y41c5 ff122 fs2 fc0 sc0 ls8 wseb">定时器对队列的工作方式是，当特定时间过去后将代码插入。注意，给队列添加代码并不意味着对</div><div class="t m0 x0 h5 y41c6 ff122 fs2 fc0 sc0 ls8 wseb">它立刻执行，而只能表示它会尽快执行。设定一个150ms后执行的定时器不代表到了150ms代码就立刻</div><div class="t m0 x0 h5 y41c7 ff122 fs2 fc0 sc0 ls8 wseb">执行，它表示代码会在150ms后被加入到队列中。如果在这个时间点上，队列中没有其他东西，那么这</div><div class="t m0 x0 h4 y41c8 ff122 fs2 fc0 sc0 ls8 wseb">段代码就会被执行，表面上看上去好像代码就在精确指定的时间点上执行了。其他情况下，代码可能明</div><div class="t m0 x0 h5 y41c9 ff122 fs2 fc0 sc0 ls8 wseb">显地等待更长时间才执行。 </div><div class="t m0 x0 h5 y41ca ff122 fs2 fc0 sc0 ls8 wseb">请看以下代码： </div><div class="t m0 x5 hb yea4 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yea5 ff123 fs6 fc0 sc0 ls21 wsb">var btn = document.getElementById(&quot;my-btn&quot;); </div><div class="t m0 x0 hb y41cb ff123 fs6 fc0 sc0 ls21 wsb">btn.onclick = function(){ </div><div class="t m0 x0 hb y41cc ff123 fs6 fc0 sc0 ls21 wsb">    setTimeout(function(){  </div><div class="t m0 x0 hb yea8 ff123 fs6 fc0 sc0 ls21 wsb">        document.getElementById(&quot;message&quot;).style.visibility = &quot;visible&quot;; </div><div class="t m0 x0 hb y41cd ff123 fs6 fc0 sc0 ls21 wsb">    }, 250); </div><div class="t m0 x0 hb y41ce ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y41cf ff123 fs6 fc0 sc0 ls21 wsb">    //其他代码 </div><div class="t m0 x0 hb y41d0 ff123 fs6 fc0 sc0 ls21 wsb">};  </div></div></div>
<div id="pf274" class="pf w0 h0" data-page-no="274"><div class="pc pc274 w0 h0"><div class="t m0 x0 h2 y1 ff11c fs0 fc0 sc0 ls7 ws0">610  第22章 高级技巧 </div><div class="t m0 x0 h3 y2 ff11c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff122 fs2 fc0 sc0 ls5 wsec">在这里给一个按钮设置了一个事件处理程序。事件处理程序设置了一个250ms后调用的定时器。</div><div class="t m0 x0 hc y4d ff122 fs2 fc0 sc0 ls5 wsec">点击该按钮后，首先将onclick事件处理程序加入队列。该程序执行后才设置定时器，再有 250ms</div><div class="t m0 x0 h1e y5 ff122 fs2 fc0 sc0 ls5 wsec">后，指定的代码才被添加到队列中等待执行。实际上，对setTimeout()的调用表示要晚点执行某些</div><div class="t m0 x0 h5 yd9 ff122 fs2 fc0 sc0 ls5">代码。 </div><div class="t m0 x0 h4 y15d ff122 fs2 fc0 sc0 ls8 wseb">关于定时器要记住的最重要的事情是，指定的时间间隔表示何时将定时器的代码添加到队列，而不</div><div class="t m0 x0 he y2b3 ff122 fs2 fc0 sc0 ls8 wseb">是何时实际执行代码。如果前面例子中的onclick事件处理程序执行了300ms，那么定时器的代码至</div><div class="t m0 x0 h5 y15e ff122 fs2 fc0 sc0 ls8 wseb">少要在定时器设置之后的300ms后才会被执行。队列中所有的代码都要等到JavaScript进程空闲之后才</div><div class="t m0 x0 h5 y1561 ff122 fs2 fc0 sc0 ls8 wseb">能执行，而不管它们是如何添加到队列中的。见图22-2。 </div><div class="t m0 x0 h5 y41d2 ff11c fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 h5 y462 ff11c fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x7 h3 ye70 ff122 fs1 fc0 sc0 ls8 wsb">图 22-2 </div><div class="t m0 x0 h5 y6f6 ff122 fs2 fc0 sc0 ls8 wseb">如图22-2所示，尽管在255ms处添加了定时器代码，但这时候还不能执行，因为onclick 事件处</div><div class="t m0 x0 hc y41d3 ff122 fs2 fc0 sc0 ls42 wsf0">理程序仍在运行。定时器代码最早能执行的时机是在300ms处，即onclick事件处理程序结束之后。 </div><div class="t m0 x0 h5 y41d4 ff122 fs2 fc0 sc0 ls8 wseb">实际上Firefox中定时器的实现还能让你确定定时器过了多久才执行，这需传递一个实际执行的时</div><div class="t m0 x0 h5 y41d5 ff122 fs2 fc0 sc0 ls8 wseb">间与指定的间隔的差值。如下面的例子所示。 </div><div class="t m0 x0 hb y6fa ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y41d6 ff123 fs6 fc0 sc0 ls21">//仅Firefox中 </div><div class="t m0 x0 hb y41d7 ff123 fs6 fc0 sc0 ls21 wsb">setTimeout(function(diff){ </div><div class="t m0 x0 hb y41d8 ff123 fs6 fc0 sc0 ls21 wsb">    if (diff &gt; 0) { </div><div class="t m0 x0 h16 y41d9 ff123 fs6 fc0 sc0 ls21 wsb">        //晚调用 </div><div class="t m0 x0 hb y41da ff123 fs6 fc0 sc0 ls21 wsb">    } else if (diff &lt; 0){ </div><div class="t m0 x0 h16 y41db ff123 fs6 fc0 sc0 ls21 wsb">        //早调用 </div><div class="t m0 x0 hb y41dc ff123 fs6 fc0 sc0 ls21 wsb">    } else { </div><div class="t m0 x0 h16 y41dd ff123 fs6 fc0 sc0 ls21 wsb">        //调用及时 </div><div class="t m0 x0 hb y41de ff123 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y41df ff123 fs6 fc0 sc0 ls21 wsb">}, 250); </div><div class="t m0 x0 hb y41e0 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 yc28 ff122 fs2 fc0 sc0 ls6 wsf7">执行完一套代码后，JavaScript进程返回一段很短的时间，这样页面上的其他处理就可以进行了。</div><div class="t m0 x0 h5 yc29 ff122 fs2 fc0 sc0 ls8 wseb">由于JavaScript进程会阻塞其他页面处理，所以必须有这些小间隔来防止用户界面被锁定（代码长时间</div><div class="t m0 x0 h5 yc2a ff122 fs2 fc0 sc0 ls8 wseb">运行中还有可能出现）。这样设置一个定时器，可以确保在定时器代码执行前至少有一个进程间隔。 </div><div class="t m0 x0 h20 y3c25 ff120 fs3 fc0 sc0 ls248 ws214">22.3.1 重复的定时器 </div><div class="t m0 x0 h4 y41e1 ff122 fs2 fc0 sc0 ls8 wseb">使用setInterval()创建的定时器确保了定时器代码规则地插入队列中。这个方式的问题在于，</div><div class="t m0 x0 h4 y41e2 ff122 fs2 fc0 sc0 ls8 wseb">定时器代码可能在代码再次被添加到队列之前还没有完成执行，结果导致定时器代码连续运行好几次，</div><div class="t m0 x0 h5 y41e3 ff122 fs2 fc0 sc0 ls8 wseb">而之间没有任何停顿。幸好，JavaScript引擎够聪明，能避免这个问题。当使用setInterval()时，仅</div><div class="t m0 x0 h4 ya08 ff122 fs2 fc0 sc0 ls8 wseb">当没有该定时器的任何其他代码实例时，才将定时器代码添加到队列中。这确保了定时器代码加入到队</div><div class="t m0 x7 h36 y41e4 ff11c fs6 fc0 sc0 ls403 ws3e7">JavaScript进程时间线</div><div class="t m0 x4 h36 y41e5 ff122 fs6 fc0 sc0 ls31">空闲 </div><div class="t m0 x1 hb y41e6 ff123 fs6 fc0 sc0 ls21 wsb">onclick </div><div class="t m0 x7 h58 y41e7 ff122 fs6 fc0 sc0 ls8 ws124">定时器代码添加到队列中</div><div class="t m0 x7 h58 y41e8 ff122 fs6 fc0 sc0 ls211 ws3fb">定时器代码</div><div class="t m0 x5 h36 y41e9 ff122 fs6 fc0 sc0 ls8 ws124">创建了间隔为250的定时器 </div><div class="t m0 x7 h36 y41ea ff122 fs6 fc0 sc0 ls8 ws124">单位：毫秒 </div></div></div>
<div id="pf275" class="pf w0 h0" data-page-no="275"><div class="pc pc275 w0 h0"><div class="t m0 x2 h2 y1 ff11c fs0 fc0 sc0 ls7 ws0">22.3 高级定时器    611 </div><div class="t m0 x0 h3 y2 ff11c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff127 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff127 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff127 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff127 fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff127 fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff127 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff127 fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff127 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff127 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff127 fs3 fc2 sc0 ls1d wsb">22 </div><div class="t m0 x3 h8 y27 ff127 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff127 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff127 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff122 fs2 fc0 sc0 ls8 wseb">列中的最小时间间隔为指定间隔。 </div><div class="t m0 x0 h5 y4d ff122 fs2 fc0 sc0 ls8 wseb">这种重复定时器的规则有两个问题：(1) 某些间隔会被跳过；(2) 多个定时器的代码执行之间的间隔</div><div class="t m0 x0 he yd8 ff122 fs2 fc0 sc0 ls8 wseb">可能会比预期的小。假设，某个onclick事件处理程序使用setInterval()设置了一个 200ms间隔</div><div class="t m0 x0 h5 yd9 ff122 fs2 fc0 sc0 ls8 wseb">的重复定时器。如果事件处理程序花了300ms多一点的时间完成，同时定时器代码也花了差不多的时间，</div><div class="t m0 x0 h5 y15d ff122 fs2 fc0 sc0 ls8 wseb">就会同时出现跳过间隔且连续运行定时器代码的情况。参见图22-3。 </div><div class="t m0 x0 h5 y41eb ff11c fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 h5 y41ec ff11c fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 h3 y285d ff122 fs1 fc0 sc0 ls8 wsb">图 22-3 </div><div class="t m0 x0 h5 y41ed ff122 fs2 fc0 sc0 ls8 wseb">这个例子中的第1个定时器是在205ms处添加到队列中的，但是直到过了300ms处才能够执行。当</div><div class="t m0 x0 h5 y41ee ff122 fs2 fc0 sc0 ls8 wseb">执行这个定时器代码时，在405ms处又给队列添加了另外一个副本。在下一个间隔，即605ms处，第一</div><div class="t m0 x0 h4 y41ef ff122 fs2 fc0 sc0 ls8 wseb">个定时器代码仍在运行，同时在队列中已经有了一个定时器代码的实例。结果是，在这个时间点上的定</div><div class="t m0 x0 h5 y41f0 ff122 fs2 fc0 sc0 ls8 wseb">时器代码不会被添加到队列中。结果在5ms处添加的定时器代码结束之后，405ms处添加的定时器代码</div><div class="t m0 x0 h5 y41f1 ff122 fs2 fc0 sc0 ls8 wseb">就立刻执行。 </div><div class="t m0 x0 h1b y41f2 ff122 fs2 fc0 sc0 ls8 wseb">为了避免setInterval()的重复定时器的这2个缺点，你可以用如下模式使用链式setTimeout()</div><div class="t m0 x0 h5 y90d ff122 fs2 fc0 sc0 ls8">调用。 </div><div class="t m0 x5 hb y3a0e ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y41f3 ff123 fs6 fc0 sc0 ls21 wsb">setTimeout(function(){ </div><div class="t m0 x0 hb y41f4 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y41f5 ff123 fs6 fc0 sc0 ls21 wsb">    //处理中 </div><div class="t m0 x0 hb y41f6 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y41f7 ff123 fs6 fc0 sc0 ls21 wsb">    setTimeout(arguments.callee, interval); </div><div class="t m0 x0 hb y41f8 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y41f9 ff123 fs6 fc0 sc0 ls21 wsb">}, interval); </div><div class="t m0 x5 hb y41fa ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y2fc ff122 fs2 fc0 sc0 ls4 ws10d">这个模式链式调用了setTimeout()，每次函数执行的时候都会创建一个新的定时器。第二个</div><div class="t m0 x0 h4 y41fb ff123 fs1 fc0 sc0 ls9 ws2">setTimeout()调用使用了arguments.callee来获取对当前执行的函数的引用，并为其设置另外一</div><div class="t m0 x0 h4 y41fc ff122 fs2 fc0 sc0 ls8 wseb">个定时器。这样做的好处是，在前一个定时器代码执行完之前，不会向队列插入新的定时器代码，确保</div><div class="t m0 x0 h4 y41fd ff122 fs2 fc0 sc0 ls8 wseb">不会有任何缺失的间隔。而且，它可以保证在下一次定时器代码执行之前，至少要等待指定的间隔，避</div><div class="t m0 x0 h5 y41fe ff122 fs2 fc0 sc0 ls8 wseb">免了连续的运行。这个模式主要用于重复定时器，如下例所示。 </div><div class="t m0 x5 hb y41ff ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4200 ff123 fs6 fc0 sc0 ls21 wsb">setTimeout(function(){ </div><div class="t m0 x0 hb y4201 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4202 ff123 fs6 fc0 sc0 ls21 wsb">    var div = document.getElementById(&quot;myDiv&quot;); </div><div class="t m0 x0 hb y4203 ff123 fs6 fc0 sc0 ls21 wsb">    left = parseInt(div.style.left) + 5; </div><div class="t m0 x0 hb y4204 ff123 fs6 fc0 sc0 ls21 wsb">    div.style.left = left + &quot;px&quot;; </div><div class="t m0 x0 hb y4205 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4206 ff123 fs6 fc0 sc0 ls21 wsb">    if (left &lt; 200){ </div><div class="t m0 x4 h36 y4207 ff11c fs6 fc0 sc0 ls403 ws3e7">JavaScript进程时间线</div><div class="t m0 x2 h36 y4208 ff122 fs6 fc0 sc0 ls8 ws124">定时器代码 </div><div class="t m0 x1 hb y4209 ff123 fs6 fc0 sc0 ls21 wsb">onclick </div><div class="t m0 x1 h58 y420a ff122 fs6 fc0 sc0 ls8 ws124">定时器代码添加到队列中</div><div class="t m0 x4 h58 y420b ff122 fs6 fc0 sc0 ls211 ws3fb">定时器代码</div><div class="t m0 x5 h36 y420c ff122 fs6 fc0 sc0 ls8 ws124">创建了间隔为200的定时器 </div><div class="t m0 x2 h36 y420d ff122 fs6 fc0 sc0 ls8 ws124">定时器代码被跳过 </div><div class="t m0 x4 h58 y420e ff122 fs6 fc0 sc0 ls8 ws124">定时器代码添加到队列中</div><div class="t m0 x7 h36 y420f ff122 fs6 fc0 sc0 ls8 ws124">单位：毫秒 </div></div></div>
<div id="pf276" class="pf w0 h0" data-page-no="276"><div class="pc pc276 w0 h0"><div class="t m0 x0 h2 y1 ff11c fs0 fc0 sc0 ls7 ws0">612  第22章 高级技巧 </div><div class="t m0 x0 h3 y2 ff11c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 ff123 fs6 fc0 sc0 ls21 wsb">        setTimeout(arguments.callee, 50); </div><div class="t m0 x0 hb y7a ff123 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y7b ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y7c ff123 fs6 fc0 sc0 ls21 wsb">}, 50); </div><div class="t m0 x0 hb y1991 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y239b ff128 fs2 fc0 sc0 ls79 wsb">RepeatingTimersExample.htm </div><div class="t m0 x0 h5 y4cb ff122 fs2 fc0 sc0 ls5 wsec">这段定时器代码每次执行的时候将一个&lt;div&gt;元素向右移动，当左坐标在200像素的时候停止。</div><div class="t m0 x0 h5 y4cc ff11c fs2 fc0 sc0 lsb ws5">JavaScript动画中使用这个模式很常见。 </div><div class="t m0 x5 h5 y4211 ff11d fs2 fc0 sc0 ls8 ws14">每个浏览器窗口、标签页、或者frame都有其各自的代码执行队列。这意味着，</div><div class="t m0 x0 h5 y4212 ff11d fs2 fc0 sc0 ls8 ws14">进行跨frame或者跨窗口的定时调用，当代码同时执行的时候可能会导致竞争条件。</div><div class="t m0 x0 h5 y4213 ff11d fs2 fc0 sc0 ls8 ws14">无论何时需要使用这种通信类型，最好是在接收frame或者窗口中创建一个定时器来</div><div class="t m0 x0 h5 y4214 ff11d fs2 fc0 sc0 ls8 ws14">执行代码。 </div><div class="t m0 x0 h20 y1599 ff120 fs3 fc0 sc0 ls248 ws214">22.3.2 Yielding Processes </div><div class="t m0 x0 h5 y4215 ff122 fs2 fc0 sc0 ls8 wseb">运行在浏览器中的JavaScript都被分配了一个确定数量的资源。不同于桌面应用往往能够随意控制</div><div class="t m0 x0 h5 y4216 ff122 fs2 fc0 sc0 ls8 wseb">他们要的内存大小和处理器时间，JavaScript被严格限制了，以防止恶意的Web程序员把用户的计算机</div><div class="t m0 x0 h4 y4217 ff122 fs2 fc0 sc0 ls8 wseb">搞挂了。其中一个限制是长时间运行脚本的制约，如果代码运行超过特定的时间或者特定语句数量就不</div><div class="t m0 x0 h4 y4218 ff122 fs2 fc0 sc0 ls8 wseb">让它继续执行。如果代码达到了这个限制，会弹出一个浏览器错误的对话框，告诉用户某个脚本会用过</div><div class="t m0 x0 h5 y4219 ff122 fs2 fc0 sc0 ls8 wseb">长的时间执行，询问是允许其继续执行还是停止它。所有JavaScript开发人员的目标就是，确保用户永</div><div class="t m0 x0 h5 y421a ff122 fs2 fc0 sc0 ls8 wseb">远不会在浏览器中看到这个令人费解的对话框。定时器是绕开此限制的方法之一。 </div><div class="t m0 x0 h4 y421b ff122 fs2 fc0 sc0 ls8 wseb">脚本长时间运行的问题通常是由两个原因之一造成的：过长的、过深嵌套的函数调用或者是进行大</div><div class="t m0 x0 h5 y421c ff122 fs2 fc0 sc0 ls8 wseb">量处理的循环。这两者中，后者是较为容易解决的问题。长时间运行的循环通常遵循以下模式： </div><div class="t m0 x0 hb y25fe ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y421d ff123 fs6 fc0 sc0 ls21 wsb">for (var i=0, len=data.length; i &lt; len; i++){ </div><div class="t m0 x0 hb y421e ff123 fs6 fc0 sc0 ls21 wsb">    process(data[i]); </div><div class="t m0 x0 hb y421f ff123 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h5 y4220 ff122 fs2 fc0 sc0 ls8 wseb">这个模式的问题在于要处理的项目的数量在运行前是不可知的。如果完成process()要花100ms，</div><div class="t m0 x0 h5 y4221 ff122 fs2 fc0 sc0 ls8 wseb">只有2个项目的数组可能不会造成影响，但是10个的数组可能会导致脚本要运行一秒钟才能完成。数</div><div class="t m0 x0 h5 y4222 ff122 fs2 fc0 sc0 ls8 wseb">组中的项目数量直接关系到执行完该循环的时间长度。同时由于JavaScript的执行是一个阻塞操作，脚</div><div class="t m0 x0 h5 y4223 ff122 fs2 fc0 sc0 ls8 wseb">本运行所花时间越久，用户无法与页面交互的时间也越久。 </div><div class="t m0 x0 h5 y4224 ff122 fs2 fc0 sc0 ls8 wseb">在展开该循环之前，你需要回答以下两个重要的问题。 </div><div class="t m0 x0 h4 y75a ff121 fs1 fc0 sc0 ls2"> 该处理是否必须同步完成？如果这个数据的处理会造成其他运行的阻塞，那么最好不要改动它。</div><div class="t m0 x0 h5 y4225 ff122 fs2 fc0 sc0 ls8 wseb">不过，如果你对这个问题的回答确定为“否”，那么将某些处理推迟到以后是个不错的备选项。  </div><div class="t m0 x0 h4 y18a3 ff121 fs1 fc0 sc0 ls2"> 数据是否必须按顺序完成？通常，数组只是对项目的组合和迭代的一种简便的方法而无所谓顺</div><div class="t m0 x0 h5 y4226 ff122 fs2 fc0 sc0 ls8 wseb">序。如果项目的顺序不是非常重要，那么可能可以将某些处理推迟到以后。 </div><div class="t m0 x0 h4 y4227 ff122 fs2 fc0 sc0 ls8 wseb">当你发现某个循环占用了大量时间，同时对于上述两个问题，你的回答都是“否”，那么你就可以</div><div class="t m0 x0 h5 y4228 ff122 fs2 fc0 sc0 ls8 wseb">使用定时器分割这个循环。这是一种叫做数组分块（array chunking）的技术，小块小块地处理数组，通</div><div class="t m0 x0 h4 y2bc6 ff122 fs2 fc0 sc0 ls8 wseb">常每次一小块。基本的思路是为要处理的项目创建一个队列，然后使用定时器取出下一个要处理的项目</div><div class="t m0 x0 h5 y4229 ff122 fs2 fc0 sc0 ls8 wseb">进行处理，接着再设置另一个定时器。基本的模式如下。 </div><div class="t m0 x0 hb y422a ff123 fs6 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf277" class="pf w0 h0" data-page-no="277"><div class="pc pc277 w0 h0"><div class="t m0 x2 h2 y1 ff11c fs0 fc0 sc0 ls7 ws0">22.3 高级定时器    613 </div><div class="t m0 x0 h3 y2 ff11c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff127 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff127 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff127 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff127 fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff127 fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff127 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff127 fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff127 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff127 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff127 fs3 fc2 sc0 ls1d wsb">22 </div><div class="t m0 x3 h8 y27 ff127 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff127 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff127 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y79 ff123 fs6 fc0 sc0 ls21 wsb">setTimeout(function(){  </div><div class="t m0 x0 hb y7a ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y7b ff123 fs6 fc0 sc0 ls21 wsb">    //取出下一个条目并处理 </div><div class="t m0 x0 hb y7c ff123 fs6 fc0 sc0 ls21 wsb">    var item = array.shift(); </div><div class="t m0 x0 hb y7d ff123 fs6 fc0 sc0 ls21 wsb">    process(item); </div><div class="t m0 x0 hb y7e ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y7f ff123 fs6 fc0 sc0 ls21 wsb">    //若还有条目，再设置另一个定时器 </div><div class="t m0 x0 hb y80 ff123 fs6 fc0 sc0 ls21 wsb">    if(array.length &gt; 0){ </div><div class="t m0 x0 hb y81 ff123 fs6 fc0 sc0 ls21 wsb">        setTimeout(arguments.callee, 100); </div><div class="t m0 x0 hb y82 ff123 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y83 ff123 fs6 fc0 sc0 ls21 wsb">}, 100); </div><div class="t m0 x5 hb y3a3f ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y422b ff122 fs2 fc0 sc0 ls8 wseb">在数组分块模式中，array变量本质上就是一个“待办事宜”列表，它包含了要处理的项目。使用</div><div class="t m0 x0 h4 y1a23 ff123 fs1 fc0 sc0 ls9 ws2">shift()方法可以获取队列中下一个要处理的项目，然后将其传递给某个函数。如果在队列中还有其他</div><div class="t m0 x0 h1e y422c ff122 fs2 fc0 sc0 ls8 wseb">项目，则设置另一个定时器，并通过arguments.callee调用同一个匿名函数。要实现数组分块非常</div><div class="t m0 x0 h5 y422d ff122 fs2 fc0 sc0 ls8 wseb">简单，可以使用以下函数。 </div><div class="t m0 x5 hb y422e ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y422f ff123 fs6 fc0 sc0 ls21 wsb">function chunk(array, process, context){ </div><div class="t m0 x0 hb y4230 ff123 fs6 fc0 sc0 ls21 wsb">    setTimeout(function(){ </div><div class="t m0 x0 hb y4231 ff123 fs6 fc0 sc0 ls21 wsb">        var item = array.shift(); </div><div class="t m0 x0 hb y4232 ff123 fs6 fc0 sc0 ls21 wsb">        process.call(context, item); </div><div class="t m0 x0 hb y4233 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4234 ff123 fs6 fc0 sc0 ls21 wsb">        if (array.length &gt; 0){ </div><div class="t m0 x0 hb y4235 ff123 fs6 fc0 sc0 ls21 wsb">            setTimeout(arguments.callee, 100); </div><div class="t m0 x0 hb y4236 ff123 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y4237 ff123 fs6 fc0 sc0 ls21 wsb">    }, 100); </div><div class="t m0 x0 hb y4238 ff123 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x2 hf yef6 ff128 fs2 fc0 sc0 ls8 wsb">ArrayChunkingExample.htm </div><div class="t m0 x0 h4 y4239 ff123 fs1 fc0 sc0 ls9 ws2">chunk()方法接受三个参数：要处理的项目的数组，用于处理项目的函数，以及可选的运行该函数</div><div class="t m0 x0 h1e y1f8b ff122 fs2 fc0 sc0 ls8 wseb">的环境。函数内部用了之前描述过的基本模式，通过call()调用的process()函数，这样可以设置一</div><div class="t m0 x0 h5 y423a ff122 fs2 fc0 sc0 ls8 wseb">个合适的执行环境（如果必须）。定时器的时间间隔设置为了100ms，使得JavaScript进程有时间在处</div><div class="t m0 x0 h5 y1f8d ff122 fs2 fc0 sc0 ls8 wseb">理项目的事件之间转入空闲。你可以根据你的需要更改这个间隔大小，不过100ms在大多数情况下效果</div><div class="t m0 x0 h5 y423b ff122 fs2 fc0 sc0 ls8 wseb">不错。可以按如下所示使用该函数： </div><div class="t m0 x5 hb y3b2f ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y423c ff123 fs6 fc0 sc0 ls21 wsb">var data = [12,123,1234,453,436,23,23,5,4123,45,346,5634,2234,345,342]; </div><div class="t m0 x0 hb y423d ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y423e ff123 fs6 fc0 sc0 ls21 wsb">function printValue(item){ </div><div class="t m0 x0 hb y423f ff123 fs6 fc0 sc0 ls21 wsb">    var div = document.getElementById(&quot;myDiv&quot;); </div><div class="t m0 x0 hb y4240 ff123 fs6 fc0 sc0 ls21 wsb">    div.innerHTML += item + &quot;&lt;br&gt;&quot;; </div><div class="t m0 x0 hb y4241 ff123 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 h5 y4242 ff11c fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y511 ff123 fs6 fc0 sc0 ls21 wsb">chunk(data, printValue); </div><div class="t m0 x5 hb y4243 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y4244 ff128 fs2 fc0 sc0 ls8 wsb">ArrayChunkingExample.htm </div><div class="t m0 x0 h4 y4245 ff122 fs2 fc0 sc0 ls8 wseb">这个例子使用printValue()函数将data数组中的每个值输出到一个&lt;div&gt;元素。由于函数处在</div><div class="t m0 x0 hc y4246 ff122 fs2 fc0 sc0 ls8 wseb">全局作用域内，因此无需给chunk()传递一个context对象。 </div><div class="t m0 x0 h4 y4247 ff122 fs2 fc0 sc0 ls8 wseb">必须当心的地方是，传递给chunk()的数组是用作一个队列的，因此当处理数据的同时，数组中的</div><div class="t m0 x0 hc y4248 ff122 fs2 fc0 sc0 ls8 wseb">条目也在改变。如果你想保持原数组不变，则应该将该数组的克隆传递给chunk()，如下例所示： </div><div class="t m0 x5 hb y1a47 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h153 y4249 ff123 fs6 fc0 sc0 ls21 wsb">chunk(data.concat(), printValue); </div></div></div>
<div id="pf278" class="pf w0 h0" data-page-no="278"><div class="pc pc278 w0 h0"><div class="t m0 x0 h2 y1 ff11c fs0 fc0 sc0 ls7 ws0">614  第22章 高级技巧 </div><div class="t m0 x0 h3 y2 ff11c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ff122 fs2 fc0 sc0 ls8 wseb">当不传递任何参数调用某个数组的concat()方法时，将返回和原来数组中项目一样的数组。这样</div><div class="t m0 x0 h5 y4d ff122 fs2 fc0 sc0 ls8 wseb">你就可以保证原数组不会被该函数更改。 </div><div class="t m0 x0 h4 yd8 ff122 fs2 fc0 sc0 ls8 wseb">数组分块的重要性在于它可以将多个项目的处理在执行队列上分开，在每个项目处理之后，给予其</div><div class="t m0 x0 h5 y28b ff122 fs2 fc0 sc0 ls8 wseb">他的浏览器处理机会运行，这样就可能避免长时间运行脚本的错误。 </div><div class="t m0 x5 h5 y424b ff11d fs2 fc0 sc0 ls8 ws14">一旦某个函数需要花50ms以上的时间完成，那么最好看看能否将任务分割为一</div><div class="t m0 x0 h5 y424c ff11d fs2 fc0 sc0 ls8 ws14">系列可以使用定时器的小任务。 </div><div class="t m0 x0 h20 y30ee ff120 fs3 fc0 sc0 ls248 ws214">22.3.3 函数节流 </div><div class="t m0 x0 h5 y424d ff122 fs2 fc0 sc0 ls8 wseb">浏览器中某些计算和处理要比其他的昂贵很多。例如，DOM操作比起非DOM交互需要更多的内</div><div class="t m0 x0 h5 y424e ff122 fs2 fc0 sc0 ls8 wseb">存和CPU时间。连续尝试进行过多的DOM相关操作可能会导致浏览器挂起，有时候甚至会崩溃。尤其</div><div class="t m0 x0 h5 y424f ff122 fs2 fc0 sc0 ls3b">在IE中使用onresize事件处理程序的时候容易发生，当调整浏览器大小的时候，该事件会连续触发。</div><div class="t m0 x0 hc y4250 ff122 fs2 fc0 sc0 ls2c">在onresize事件处理程序内部如果尝试进行DOM操作，其高频率的更改可能会让浏览器崩溃。为了</div><div class="t m0 x0 h5 y1be6 ff122 fs2 fc0 sc0 ls8 wseb">绕开这个问题，你可以使用定时器对该函数进行节流。 </div><div class="t m0 x0 h4 y3218 ff122 fs2 fc0 sc0 ls8 wseb">函数节流背后的基本思想是指，某些代码不可以在没有间断的情况连续重复执行。第一次调用函数，</div><div class="t m0 x0 h4 y4251 ff122 fs2 fc0 sc0 ls8 wseb">创建一个定时器，在指定的时间间隔之后运行代码。当第二次调用该函数时，它会清除前一次的定时器</div><div class="t m0 x0 h4 y4252 ff122 fs2 fc0 sc0 ls8 wseb">并设置另一个。如果前一个定时器已经执行过了，这个操作就没有任何意义。然而，如果前一个定时器</div><div class="t m0 x0 h4 y4253 ff122 fs2 fc0 sc0 ls8 wseb">尚未执行，其实就是将其替换为一个新的定时器。目的是只有在执行函数的请求停止了一段时间之后才</div><div class="t m0 x0 h5 y4254 ff122 fs2 fc0 sc0 ls8 wseb">执行。以下是该模式的基本形式： </div><div class="t m0 x0 hb y4255 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4256 ff123 fs6 fc0 sc0 ls21 wsb">var processor = {  </div><div class="t m0 x0 hb y4257 ff123 fs6 fc0 sc0 ls21 wsb">    timeoutId: null, </div><div class="t m0 x0 hb y4258 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4259 ff123 fs6 fc0 sc0 ls21 wsb">    //实际进行处理的方法 </div><div class="t m0 x0 hb y425a ff123 fs6 fc0 sc0 ls21 wsb">    performProcessing: function(){ </div><div class="t m0 x0 h16 y425b ff123 fs6 fc0 sc0 ls21 wsb">        //实际执行的代码 </div><div class="t m0 x0 hb y425c ff123 fs6 fc0 sc0 ls21 wsb">    }, </div><div class="t m0 x0 hb y425d ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y425e ff123 fs6 fc0 sc0 ls21 wsb">    //初始处理调用的方法 </div><div class="t m0 x0 hb y425f ff123 fs6 fc0 sc0 ls21 wsb">    process: function(){ </div><div class="t m0 x0 hb y4260 ff123 fs6 fc0 sc0 ls21 wsb">        clearTimeout(this.timeoutId); </div><div class="t m0 x0 hb y4261 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4262 ff123 fs6 fc0 sc0 ls21 wsb">        var that = this; </div><div class="t m0 x0 hb y4263 ff123 fs6 fc0 sc0 ls21 wsb">        this.timeoutId = setTimeout(function(){ </div><div class="t m0 x0 hb y4264 ff123 fs6 fc0 sc0 ls21 wsb">            that.performProcessing(); </div><div class="t m0 x0 hb y4265 ff123 fs6 fc0 sc0 ls21 wsb">        }, 100); </div><div class="t m0 x0 hb y4266 ff123 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y4267 ff123 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y4268 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4269 ff123 fs6 fc0 sc0 ls21">//尝试开始执行  </div><div class="t m0 x0 hb y426a ff123 fs6 fc0 sc0 ls21 wsb">processor.process(); </div><div class="t m0 x0 hb y426b ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y2742 ff122 fs2 fc0 sc0 ls19 wsfb">在这段代码中，创建了一个叫做processor对象。这个对象还有 2个方法：process()和</div><div class="t m0 x0 h4 y2af ff123 fs1 fc0 sc0 ls9 ws2">performProcessing()。前者是初始化任何处理所必须调用的，后者则实际进行应完成的处理。当调</div><div class="t m0 x0 h4 y2b0 ff122 fs2 fc0 sc0 ls8 wseb">用了process()，第一步是清除存好的timeoutId，来阻止之前的调用被执行。然后，创建一个新的</div><div class="t m0 x0 h1e y2b1 ff122 fs2 fc0 sc0 ls8 wseb">定时器调用performProcessing()。由于setTimeout()中用到的函数的环境总是window，所以有</div><div class="t m0 x0 hc y2b2 ff122 fs2 fc0 sc0 ls8 wseb">必要保存this的引用以方便以后使用。 </div></div></div>
<div id="pf279" class="pf w0 h0" data-page-no="279"><div class="pc pc279 w0 h0"><div class="t m0 x2 h2 y1 ff11c fs0 fc0 sc0 ls7 ws0">22.3 高级定时器    615 </div><div class="t m0 x0 h3 y2 ff11c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff127 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff127 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff127 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff127 fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff127 fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff127 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff127 fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff127 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff127 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff127 fs3 fc2 sc0 ls1d wsb">22 </div><div class="t m0 x3 h8 y27 ff127 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff127 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff127 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff122 fs2 fc0 sc0 ls8 wseb">时间间隔设为了100ms，这表示最后一次调用process()之后至少100ms 后才会调用perform- </div><div class="t m0 x0 h21 ye26 ff123 fs1 fc0 sc0 ls9 ws2">Processing()。所以如果100ms之内调用了process()共20次，performanceProcessing()仍只</div><div class="t m0 x0 h5 y5 ff122 fs2 fc0 sc0 ls8 wseb">会被调用一次。 </div><div class="t m0 x0 h1e y6 ff122 fs2 fc0 sc0 ls8 wseb">这个模式可以使用throttle()函数来简化，这个函数可以自动进行定时器的设置和清除，如下例</div><div class="t m0 x0 h5 y15d ff122 fs2 fc0 sc0 ls8">所示： </div><div class="t m0 x5 hb y4ef ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yfdc ff123 fs6 fc0 sc0 ls21 wsb">function throttle(method, context) { </div><div class="t m0 x0 hb yfdd ff123 fs6 fc0 sc0 ls21 wsb">    clearTimeout(method.tId); </div><div class="t m0 x0 hb yfde ff123 fs6 fc0 sc0 ls21 wsb">    method.tId= setTimeout(function(){ </div><div class="t m0 x0 hb yfdf ff123 fs6 fc0 sc0 ls21 wsb">        method.call(context); </div><div class="t m0 x0 hb yfe0 ff123 fs6 fc0 sc0 ls21 wsb">    }, 100); </div><div class="t m0 x0 hb yfe1 ff123 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x2 hf y1aaa ff128 fs2 fc0 sc0 ls2f wsb">ThrottlingExample.htm </div><div class="t m0 x0 h4 y426c ff123 fs1 fc0 sc0 ls9 ws2">throttle()函数接受两个参数：要执行的函数以及在哪个作用域中执行。上面这个函数首先清除</div><div class="t m0 x0 h1e y426d ff122 fs2 fc0 sc0 ls8 wseb">之前设置的任何定时器。定时器ID是存储在函数的tId属性中的，第一次把方法传递给throttle()</div><div class="t m0 x0 h4 y187a ff122 fs2 fc0 sc0 ls8 wseb">的时候，这个属性可能并不存在。接下来，创建一个新的定时器，并将其ID储存在方法的tId属性中。</div><div class="t m0 x0 h1e y187b ff122 fs2 fc0 sc0 ls4 ws10d">如果这是第一次对这个方法调用throttle()的话，那么这段代码会创建该属性。定时器代码使用</div><div class="t m0 x0 h4 y2382 ff123 fs1 fc0 sc0 ls9 ws2">call()来确保方法在适当的环境中执行。如果没有给出第二个参数，那么就在全局作用域内执行该方</div><div class="t m0 x0 h5 y426e ff122 fs2 fc0 sc0 ls8">法。 </div><div class="t m0 x0 h1e y426f ff122 fs2 fc0 sc0 ls8 wseb">前面提到过，节流在resize事件中是最常用的。如果你基于该事件来改变页面布局的话，最好控</div><div class="t m0 x0 h1e y8d3 ff122 fs2 fc0 sc0 ls5 wsec">制处理的频率，以确保浏览器不会在极短的时间内进行过多的计算。例如，假设有一个&lt;div/&gt;元素需</div><div class="t m0 x0 h5 y4270 ff122 fs2 fc0 sc0 ls8 wseb">要保持它的高度始终等同于宽度。那么实现这一功能的JavaScript可以如下编写： </div><div class="t m0 x5 hb y4271 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4272 ff123 fs6 fc0 sc0 ls21 wsb">window.onresize = function(){ </div><div class="t m0 x0 hb y4273 ff123 fs6 fc0 sc0 ls21 wsb">    var div = document.getElementById(&quot;myDiv&quot;); </div><div class="t m0 x0 hb y4274 ff123 fs6 fc0 sc0 ls21 wsb">    div.style.height = div. offsetWidth + &quot;px&quot;; </div><div class="t m0 x0 hb y4275 ff123 fs6 fc0 sc0 ls21 wsb">};  </div><div class="t m0 x0 h4 y4276 ff122 fs2 fc0 sc0 ls8 wseb">这段非常简单的例子有两个问题可能会造成浏览器运行缓慢。首先，要计算offsetWidth属性，</div><div class="t m0 x0 h5 y4277 ff122 fs2 fc0 sc0 ls8 wseb">如果该元素或者页面上其他元素有非常复杂的CSS样式，那么这个过程将会很复杂。其次，设置某个元</div><div class="t m0 x0 h5 y4278 ff122 fs2 fc0 sc0 ls8 wseb">素的高度需要对页面进行回流来令改动生效。如果页面有很多元素同时应用了相当数量的CSS的话，这</div><div class="t m0 x0 h14 y4279 ff122 fs2 fc0 sc0 ls8 wseb">又需要很多计算。这就可以用到throttle()函数，如下例所示： </div><div class="t m0 x5 hb y3c1f ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y427a ff123 fs6 fc0 sc0 ls21 wsb">function resizeDiv(){ </div><div class="t m0 x0 hb y427b ff123 fs6 fc0 sc0 ls21 wsb">    var div = document.getElementById(&quot;myDiv&quot;); </div><div class="t m0 x0 hb y427c ff123 fs6 fc0 sc0 ls21 wsb">    div.style.height = div.offsetWidth + &quot;px&quot;; </div><div class="t m0 x0 hb y427d ff123 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y427e ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y427f ff123 fs6 fc0 sc0 ls21 wsb">window.onresize = function(){ </div><div class="t m0 x0 hb y4280 ff123 fs6 fc0 sc0 ls21 wsb">    throttle(resizeDiv); </div><div class="t m0 x0 hb y4281 ff123 fs6 fc0 sc0 ls21 wsb">};  </div><div class="t m0 x2 hf y3686 ff128 fs2 fc0 sc0 ls2f wsb">ThrottlingExample.htm </div><div class="t m0 x0 h4 y231d ff122 fs2 fc0 sc0 ls8 wseb">这里，调整大小的功能被放入了一个叫做resizeDiv()的单独函数中。然后onresize事件处理</div><div class="t m0 x0 h84 y231e ff122 fs2 fc0 sc0 ls8 wseb">程序调用throttle()并传入resizeDiv函数，而不是直接调用resizeDiv()。多数情况下，用户是</div><div class="t m0 x0 h5 y2983 ff122 fs2 fc0 sc0 ls8 wseb">感觉不到变化的，虽然给浏览器节省的计算可能会非常大。 </div></div></div>
<div id="pf27a" class="pf w0 h0" data-page-no="27a"><div class="pc pc27a w0 h0"><div class="t m0 x0 h2 y1 ff11c fs0 fc0 sc0 ls7 ws0">616  第22章 高级技巧 </div><div class="t m0 x0 h3 y2 ff11c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ff122 fs2 fc0 sc0 ls19 wsfb">只要代码是周期性执行的，都应该使用节流，但是你不能控制请求执行的速率。这里展示的</div><div class="t m0 x0 h5 y4 ff123 fs1 fc0 sc0 ls9 ws2">throttle()函数用了100ms作为间隔，你当然可以根据你的需要来修改它。 </div><div class="t m0 x0 hd y8c6 ff120 fs7 fc0 sc0 ls245">22.4 自定义事件 </div><div class="t m0 x0 h5 y8c7 ff122 fs2 fc0 sc0 ls8 wseb">在本书前面，你已经学到事件是JavaScript与浏览器交互的主要途径。事件是一种叫做观察者的设</div><div class="t m0 x0 h4 y8c8 ff122 fs2 fc0 sc0 ls8 wseb">计模式，这是一种创建松散耦合代码的技术。对象可以发布事件，用来表示在该对象生命周期中某个有</div><div class="t m0 x0 h5 y3ebb ff122 fs2 fc0 sc0 ls8 wseb">趣的时刻到了。然后其他对象可以观察该对象，等待这些有趣的时刻到来并通过运行代码来响应。 </div><div class="t m0 x0 h4 y3ebc ff122 fs2 fc0 sc0 ls8 wseb">观察者模式由两类对象组成：主体和观察者。主体负责发布事件，同时观察者通过订阅这些事件来</div><div class="t m0 x0 h4 y3ebd ff122 fs2 fc0 sc0 ls8 wseb">观察该主体。该模式的一个关键概念是主体并不知道观察者的任何事情，也就是说它可以独自存在并正</div><div class="t m0 x0 h4 y3ebe ff122 fs2 fc0 sc0 ls8 wseb">常运作即使观察者不存在。从另一方面来说，观察者知道主体并能注册事件的回调函数（事件处理程序）。</div><div class="t m0 x0 h5 y3ebf ff122 fs2 fc0 sc0 ls8 wseb">涉及DOM上时，DOM元素便是主体，你的事件处理代码便是观察者。 </div><div class="t m0 x0 h5 y4283 ff122 fs2 fc0 sc0 ls8 wseb">事件是与DOM交互的最常见的方式，但它们也可以用于非DOM代码中——通过实现自定义事件。</div><div class="t m0 x0 h4 y4284 ff122 fs2 fc0 sc0 ls8 wseb">自定义事件背后的概念是创建一个管理事件的对象，让其他对象监听那些事件。实现此功能的基本模式</div><div class="t m0 x0 h5 y4285 ff122 fs2 fc0 sc0 ls8 wseb">可以如下定义： </div><div class="t m0 x0 hb y2faf ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2fb0 ff123 fs6 fc0 sc0 ls21 wsb">function EventTarget(){ </div><div class="t m0 x0 hb y2fb1 ff123 fs6 fc0 sc0 ls21 wsb">    this.handlers = {}; </div><div class="t m0 x0 hb y2fb2 ff123 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y2fb3 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2fb4 ff123 fs6 fc0 sc0 ls21 wsb">EventTarget.prototype = { </div><div class="t m0 x0 hb y2fb5 ff123 fs6 fc0 sc0 ls21 wsb">    constructor: EventTarget, </div><div class="t m0 x0 hb y2fb6 ff123 fs6 fc0 sc0 ls21 wsb">    addHandler: function(type, handler){ </div><div class="t m0 x0 hb y2fb7 ff123 fs6 fc0 sc0 ls21 wsb">        if (typeof this.handlers[type] == &quot;undefined&quot;){ </div><div class="t m0 x0 hb y4286 ff123 fs6 fc0 sc0 ls21 wsb">            this.handlers[type] = []; </div><div class="t m0 x0 hb y4287 ff123 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y4288 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4289 ff123 fs6 fc0 sc0 ls21 wsb">        this.handlers[type].push(handler); </div><div class="t m0 x0 hb y428a ff123 fs6 fc0 sc0 ls21 wsb">    }, </div><div class="t m0 x0 hb y428b ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y428c ff123 fs6 fc0 sc0 ls21 wsb">    fire: function(event){ </div><div class="t m0 x0 hb y428d ff123 fs6 fc0 sc0 ls21 wsb">        if (!event.target){ </div><div class="t m0 x0 hb y428e ff123 fs6 fc0 sc0 ls21 wsb">            event.target = this; </div><div class="t m0 x0 hb y428f ff123 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y4290 ff123 fs6 fc0 sc0 ls21 wsb">        if (this.handlers[event.type] instanceof Array){ </div><div class="t m0 x0 hb y4291 ff123 fs6 fc0 sc0 ls21 wsb">            var handlers = this.handlers[event.type]; </div><div class="t m0 x0 hb y4292 ff123 fs6 fc0 sc0 ls21 wsb">            for (var i=0, len=handlers.length; i &lt; len; i++){ </div><div class="t m0 x0 hb y4293 ff123 fs6 fc0 sc0 ls21 wsb">                handlers[i](event); </div><div class="t m0 x0 hb y4294 ff123 fs6 fc0 sc0 ls21 wsb">            } </div><div class="t m0 x0 hb y4295 ff123 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y4296 ff123 fs6 fc0 sc0 ls21 wsb">    }, </div><div class="t m0 x0 hb y4297 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4298 ff123 fs6 fc0 sc0 ls21 wsb">    removeHandler: function(type, handler){ </div><div class="t m0 x0 hb y4299 ff123 fs6 fc0 sc0 ls21 wsb">        if (this.handlers[type] instanceof Array){ </div><div class="t m0 x0 hb y429a ff123 fs6 fc0 sc0 ls21 wsb">            var handlers = this.handlers[type]; </div><div class="t m0 x0 hb y429b ff123 fs6 fc0 sc0 ls21 wsb">            for (var i=0, len=handlers.length; i &lt; len; i++){ </div><div class="t m0 x0 hb y429c ff123 fs6 fc0 sc0 ls21 wsb">                if (handlers[i] === handler){ </div><div class="t m0 x0 hb y429d ff123 fs6 fc0 sc0 ls21 wsb">                    break; </div><div class="t m0 x0 hb y429e ff123 fs6 fc0 sc0 ls21 wsb">                } </div><div class="t m0 x0 hb y429f ff123 fs6 fc0 sc0 ls21 wsb">            } </div><div class="t m0 x0 hb y42a0 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y42a1 ff123 fs6 fc0 sc0 ls21 wsb">            handlers.splice(i, 1); </div></div></div>
<div id="pf27b" class="pf w0 h0" data-page-no="27b"><div class="pc pc27b w0 h0"><div class="t m0 x2 h2 y1 ff11c fs0 fc0 sc0 ls7 ws0">22.4 自定义事件    617 </div><div class="t m0 x0 h3 y2 ff11c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff127 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff127 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff127 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff127 fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff127 fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff127 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff127 fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff127 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff127 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff127 fs3 fc2 sc0 ls1d wsb">22 </div><div class="t m0 x3 h8 y27 ff127 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff127 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff127 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y79 ff123 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y7a ff123 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y7b ff123 fs6 fc0 sc0 ls21 wsb">};  </div><div class="t m0 x6 hf y106 ff128 fs2 fc0 sc0 ls2f wsb">EventTarget.js </div><div class="t m0 x0 h4 y107 ff123 fs1 fc0 sc0 ls9 ws2">EventTarget类型有一个单独的属性handlers，用于储存事件处理程序。还有三个方法：</div><div class="t m0 x0 h4 y2177 ff123 fs1 fc0 sc0 ls9 ws2">addHandler()，用于注册给定类型事件的事件处理程序；fire()，用于触发一个事件； </div><div class="t m0 x0 h21 y42a2 ff123 fs1 fc0 sc0 ls9 ws2">removeHandler()，用于注销某个事件类型的事件处理程序。 </div><div class="t m0 x0 h4 y10a ff123 fs1 fc0 sc0 ls9 ws2">addHandler()方法接受两个参数：事件类型和用于处理该事件的函数。当调用该方法时，会进行</div><div class="t m0 x0 h1e y10b ff122 fs2 fc0 sc0 ls8 wseb">一次检查，看看handlers属性中是否已经存在一个针对该事件类型的数组；如果没有，则创建一个新</div><div class="t m0 x0 hc y2178 ff122 fs2 fc0 sc0 ls8 wseb">的。然后使用push()将该处理程序添加到数组的末尾。 </div><div class="t m0 x0 h1e y1f5a ff122 fs2 fc0 sc0 ls6 wsf7">如果要触发一个事件，要调用fire()函数。该方法接受一个单独的参数，是一个至少包含type</div><div class="t m0 x0 h4 y1f5b ff122 fs2 fc0 sc0 ls8 wseb">属性的对象。fire()方法先给event对象设置一个target属性，如果它尚未被指定的话。然后它就</div><div class="t m0 x0 h1e y1f5c ff122 fs2 fc0 sc0 ls8 wseb">查找对应该事件类型的一组处理程序，调用各个函数，并给出event对象。因为这些都是自定义事件，</div><div class="t m0 x0 hc y164e ff122 fs2 fc0 sc0 ls8 wseb">所以event对象上还需要的额外信息由你自己决定。 </div><div class="t m0 x0 h4 y42a3 ff123 fs1 fc0 sc0 ls9 ws2">removeHandler()方法是addHandler()的辅助，它们接受的参数一样：事件的类型和事件处理</div><div class="t m0 x0 h4 y2649 ff122 fs2 fc0 sc0 ls5 wsec">程序。这个方法搜索事件处理程序的数组找到要删除的处理程序的位置。如果找到了，则使用break</div><div class="t m0 x0 h5 y42a4 ff122 fs2 fc0 sc0 ls8 wseb">操作符退出for循环。然后使用splice()方法将该项目从数组中删除。 </div><div class="t m0 x0 hc y42a5 ff122 fs2 fc0 sc0 ls8 wseb">然后，使用EventTarget类型的自定义事件可以如下使用： </div><div class="t m0 x5 hb y42a6 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y42a7 ff123 fs6 fc0 sc0 ls21 wsb">function handleMessage(event){ </div><div class="t m0 x0 hb y42a8 ff123 fs6 fc0 sc0 ls21 wsb">    alert(&quot;Message received: &quot; + event.message); </div><div class="t m0 x0 hb y42a9 ff123 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y42aa ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y42ab ff123 fs6 fc0 sc0 ls21">//创建一个新对象 </div><div class="t m0 x0 hb y42ac ff123 fs6 fc0 sc0 ls21 wsb">var target = new EventTarget(); </div><div class="t m0 x0 hb y42ad ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y42ae ff123 fs6 fc0 sc0 ls21">//添加一个事件处理程序 </div><div class="t m0 x0 hb y42af ff123 fs6 fc0 sc0 ls21 wsb">target.addHandler(&quot;message&quot;, handleMessage); </div><div class="t m0 x0 hb y42b0 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y42b1 ff123 fs6 fc0 sc0 ls21">//触发事件 </div><div class="t m0 x0 hb y42b2 ff123 fs6 fc0 sc0 ls21 wsb">target.fire({ type: &quot;message&quot;, message: &quot;Hello world!&quot;}); </div><div class="t m0 x0 hb y42b3 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y42b4 ff123 fs6 fc0 sc0 ls21">//删除事件处理程序 </div><div class="t m0 x0 hb y42b5 ff123 fs6 fc0 sc0 ls21 wsb">target.removeHandler(&quot;message&quot;, handleMessage); </div><div class="t m0 x0 hb y42b6 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y42b7 ff123 fs6 fc0 sc0 ls21">//再次，应没有处理程序 </div><div class="t m0 x0 hb y42b8 ff123 fs6 fc0 sc0 ls21 wsb">target.fire({ type: &quot;message&quot;, message: &quot;Hello world!&quot;}); </div><div class="t m0 x5 hb y42b9 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y42ba ff128 fs2 fc0 sc0 ls2b wsb">EventTargetExample01.htm </div><div class="t m0 x0 h4 y42bb ff122 fs2 fc0 sc0 ls8 wseb">在这段代码中，定义了handleMessage()函数用于处理message事件。它接受event 对象并输</div><div class="t m0 x0 h4 y4ea ff122 fs2 fc0 sc0 ls472">出message属性。调用target对象的addHandler()方法并传给&quot;message&quot;以及handleMessage()</div><div class="t m0 x0 h5 y42bc ff122 fs2 fc0 sc0 ls8 wseb">函数。在接下来的一行上，调用了fire()函数，并传递了包含2个属性，即type和message的对象</div><div class="t m0 x0 h1e y42bd ff122 fs2 fc0 sc0 ls8 wseb">直接量。它会调用message事件的事件处理程序，这样就会显示一个警告框（来自handleMessage()）。</div><div class="t m0 x0 h5 y42be ff122 fs2 fc0 sc0 ls8 wseb">然后删除了事件处理程序，这样即使事件再次触发，也不会显示任何警告框。 </div><div class="t m0 x0 h3f y42bf ff122 fs2 fc0 sc0 ls8 wseb">因为这种功能是封装在一种自定义类型中的，其他对象可以继承EventTarget并获得这个行为，</div></div></div>
<div id="pf27c" class="pf w0 h0" data-page-no="27c"><div class="pc pc27c w0 h0"><div class="t m0 x0 h2 y1 ff11c fs0 fc0 sc0 ls7 ws0">618  第22章 高级技巧 </div><div class="t m0 x0 h3 y2 ff11c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff122 fs2 fc0 sc0 ls8 wseb">如下例所示： </div><div class="t m0 x0 hb yfb2 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yfb3 ff123 fs6 fc0 sc0 ls21 wsb">function Person(name, age){ </div><div class="t m0 x0 hb yfb4 ff123 fs6 fc0 sc0 ls21 wsb">    EventTarget.call(this); </div><div class="t m0 x0 hb yfb5 ff123 fs6 fc0 sc0 ls21 wsb">    this.name = name; </div><div class="t m0 x0 hb yfb6 ff123 fs6 fc0 sc0 ls21 wsb">    this.age = age; </div><div class="t m0 x0 hb yfb7 ff123 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb yfb8 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yfb9 ff123 fs6 fc0 sc0 ls21 wsb">inheritPrototype(Person,EventTarget); </div><div class="t m0 x0 hb yfba ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yfbb ff123 fs6 fc0 sc0 ls21 wsb">Person.prototype.say = function(message){ </div><div class="t m0 x0 hb y2005 ff123 fs6 fc0 sc0 ls21 wsb">    this.fire({type: &quot;message&quot;, message: message}); </div><div class="t m0 x0 hb y2006 ff123 fs6 fc0 sc0 ls21 wsb">};  </div><div class="t m0 x2 hf y1542 ff128 fs2 fc0 sc0 ls2b wsb">EventTargetExample02.htm </div><div class="t m0 x0 h5 y1ce5 ff123 fs1 fc0 sc0 ls9 ws2">Person类型使用了寄生组合继承（参见第6章）方法来继承EventTarget。一旦调用了 say()</div><div class="t m0 x0 h4 y42c1 ff122 fs2 fc0 sc0 ls8 wseb">方法，便触发了事件，它包含了消息的细节。在某种类型的另外的方法中调用fire()方法是很常见的，</div><div class="t m0 x0 h5 y3032 ff122 fs2 fc0 sc0 ls8 wseb">同时它通常不是公开调用的。这段代码可以照如下方式使用： </div><div class="t m0 x0 hb y2380 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y42c2 ff123 fs6 fc0 sc0 ls21 wsb">function handleMessage(event){ </div><div class="t m0 x0 hb y42c3 ff123 fs6 fc0 sc0 ls21 wsb">    alert(event.target.name + &quot; says: &quot; + event.message); </div><div class="t m0 x0 hb y42c4 ff123 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y42c5 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y42c6 ff123 fs6 fc0 sc0 ls21">//创建新person </div><div class="t m0 x0 hb y42c7 ff123 fs6 fc0 sc0 ls21 wsb">var person = new Person(&quot;Nicholas&quot;, 29); </div><div class="t m0 x0 hb y42c8 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y42c9 ff123 fs6 fc0 sc0 ls21">//添加一个事件处理程序 </div><div class="t m0 x0 hb y42ca ff123 fs6 fc0 sc0 ls21 wsb">person.addHandler(&quot;message&quot;, handleMessage); </div><div class="t m0 x0 hb y42cb ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y42cc ff123 fs6 fc0 sc0 ls21">//在该对象上调用1个方法，它触发消息事件 </div><div class="t m0 x0 hb y42cd ff123 fs6 fc0 sc0 ls21 wsb">person.say(&quot;Hi there.&quot;); </div><div class="t m0 x0 hb y42ce ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y42cf ff128 fs2 fc0 sc0 ls2b wsb">EventTargetExample02.htm </div><div class="t m0 x0 h4 y42d0 ff122 fs2 fc0 sc0 ls8 wseb">这个例子中的handleMessage()函数显示了某人名字（通过event.target.name获得）的一个</div><div class="t m0 x0 h1e y42d1 ff122 fs2 fc0 sc0 ls8 wseb">警告框和消息正文。当调用say()方法并传递一个消息时，就会触发message事件。接下来，它又会</div><div class="t m0 x0 hc y42d2 ff122 fs2 fc0 sc0 ls8 wseb">调用handleMessage()函数并显示警告框。 </div><div class="t m0 x0 h4 y3a2f ff122 fs2 fc0 sc0 ls8 wseb">当代码中存在多个部分在特定时刻相互交互的情况下，自定义事件就非常有用了。这时，如果每个</div><div class="t m0 x0 h4 y3be1 ff122 fs2 fc0 sc0 ls8 wseb">对象都有对其他所有对象的引用，那么整个代码就会紧密耦合，同时维护也变得很困难，因为对某个对</div><div class="t m0 x0 h4 y42d3 ff122 fs2 fc0 sc0 ls8 wseb">象的修改也会影响到其他对象。使用自定义事件有助于解耦相关对象，保持功能的隔绝。在很多情况中，</div><div class="t m0 x0 h5 y42d4 ff122 fs2 fc0 sc0 ls8 wseb">触发事件的代码和监听事件的代码是完全分离的。 </div><div class="t m0 x0 hd y42d5 ff120 fs7 fc0 sc0 ls245">22.5 拖放 </div><div class="t m0 x0 h4 y2ee1 ff122 fs2 fc0 sc0 ls8 wseb">拖放是一种非常流行的用户界面模式。它的概念很简单：点击某个对象，并按住鼠标按钮不放，将</div><div class="t m0 x0 h5 y42d6 ff122 fs2 fc0 sc0 ls8 wseb">鼠标移动到另一个区域，然后释放鼠标按钮将对象“放”在这里。拖放功能也流行到了Web上，成为</div><div class="t m0 x0 h5 y42d7 ff122 fs2 fc0 sc0 ls8 wseb">了一些更传统的配置界面的一种候选方案。 </div><div class="t m0 x0 h4 y42d8 ff122 fs2 fc0 sc0 ls8 wseb">拖放的基本概念很简单：创建一个绝对定位的元素，使其可以用鼠标移动。这个技术源自一种叫做</div></div></div>
<div id="pf27d" class="pf w0 h0" data-page-no="27d"><div class="pc pc27d w0 h0"><div class="t m0 x2 h2 y1 ff11c fs0 fc0 sc0 ls7 ws0">22.5 拖放  619 </div><div class="t m0 x0 h3 y2 ff11c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff127 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff127 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff127 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff127 fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff127 fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff127 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff127 fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff127 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff127 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff127 fs3 fc2 sc0 ls1d wsb">22 </div><div class="t m0 x3 h8 y27 ff127 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff127 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff127 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff122 fs2 fc0 sc0 ls8 wseb">“鼠标拖尾”的经典网页技巧。鼠标拖尾是一个或者多个图片在页面上跟着鼠标指针移动。 单元素鼠标</div><div class="t m0 x0 h1e y4d ff122 fs2 fc0 sc0 ls8 wseb">拖尾的基本代码需要为文档设置一个onmousemove事件处理程序，它总是将指定元素移动到鼠标指针</div><div class="t m0 x0 h5 y5 ff122 fs2 fc0 sc0 ls8 wseb">的位置，如下面的例子所示。 </div><div class="t m0 x5 hb y6bd ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y6be ff123 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(document, &quot;mousemove&quot;, function(event){ </div><div class="t m0 x0 hb y6bf ff123 fs6 fc0 sc0 ls21 wsb">    var myDiv = document.getElementById(&quot;myDiv&quot;); </div><div class="t m0 x0 hb y6c0 ff123 fs6 fc0 sc0 ls21 wsb">    myDiv.style.left = event.clientX + &quot;px&quot;; </div><div class="t m0 x0 hb y6c1 ff123 fs6 fc0 sc0 ls21 wsb">    myDiv.style.top = event.clientY + &quot;px&quot;; </div><div class="t m0 x0 hb y6c2 ff123 fs6 fc0 sc0 ls21 wsb">});  </div><div class="t m0 x2 hf y1452 ff128 fs2 fc0 sc0 ls8 wsb">DragAndDropExample01.htm </div><div class="t m0 x0 h4 y42d9 ff122 fs2 fc0 sc0 ls8 wseb">在这个例子中，元素的left和top坐标设置为了event 对象的clientX和clientY属性，这</div><div class="t m0 x0 h4 y42da ff122 fs2 fc0 sc0 ls8 wseb">就将元素放到了视口中指针的位置上。它的效果是一个元素始终跟随指针在页面上的移动。只要正确的</div><div class="t m0 x0 h4 y2e3 ff122 fs2 fc0 sc0 ls6 wsf7">时刻（当鼠标按钮按下的时候）实现该功能，并在之后删除它（当释放鼠标按钮时），就可以实现拖放</div><div class="t m0 x0 h5 y42db ff122 fs2 fc0 sc0 ls8 wseb">了。最简单的拖放界面可用以下代码实现： </div><div class="t m0 x5 hb y42dc ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y42dd ff123 fs6 fc0 sc0 ls21 wsb">var DragDrop = function(){ </div><div class="t m0 x0 hb y42de ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y42df ff123 fs6 fc0 sc0 ls21 wsb">    var dragging = null; </div><div class="t m0 x0 hb y42e0 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y42e1 ff123 fs6 fc0 sc0 ls21 wsb">    function handleEvent(event){ </div><div class="t m0 x0 hb y42e2 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y42e3 ff123 fs6 fc0 sc0 ls21 wsb">        //获取事件和目标 </div><div class="t m0 x0 hb y42e4 ff123 fs6 fc0 sc0 ls21 wsb">        event = EventUtil.getEvent(event); </div><div class="t m0 x0 hb y42e5 ff123 fs6 fc0 sc0 ls21 wsb">        var target = EventUtil.getTarget(event); </div><div class="t m0 x0 hb y42e6 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y42e7 ff123 fs6 fc0 sc0 ls21 wsb">        //确定事件类型 </div><div class="t m0 x0 hb y42e8 ff123 fs6 fc0 sc0 ls21 wsb">        switch(event.type){ </div><div class="t m0 x0 hb y42e9 ff123 fs6 fc0 sc0 ls21 wsb">            case &quot;mousedown&quot;: </div><div class="t m0 x0 hb y42ea ff123 fs6 fc0 sc0 ls21 wsb">                if (target.className.indexOf(&quot;draggable&quot;) &gt; -1){ </div><div class="t m0 x0 hb y42eb ff123 fs6 fc0 sc0 ls21 wsb">                    dragging = target; </div><div class="t m0 x0 hb y42ec ff123 fs6 fc0 sc0 ls21 wsb">                } </div><div class="t m0 x0 hb y42ed ff123 fs6 fc0 sc0 ls21 wsb">                break; </div><div class="t m0 x0 hb y42ee ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y42ef ff123 fs6 fc0 sc0 ls21 wsb">            case &quot;mousemove&quot;: </div><div class="t m0 x0 hb y42f0 ff123 fs6 fc0 sc0 ls21 wsb">                if (dragging !== null){ </div><div class="t m0 x0 hb y42f1 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y42f2 ff123 fs6 fc0 sc0 ls21 wsb">                    //指定位置 </div><div class="t m0 x0 hb y42f3 ff123 fs6 fc0 sc0 ls21 wsb">                    dragging.style.left = event.clientX + &quot;px&quot;; </div><div class="t m0 x0 hb y42f4 ff123 fs6 fc0 sc0 ls21 wsb">                    dragging.style.top = event.clientY + &quot;px&quot;; </div><div class="t m0 x0 hb y42f5 ff123 fs6 fc0 sc0 ls21 wsb">                } </div><div class="t m0 x0 hb y42f6 ff123 fs6 fc0 sc0 ls21 wsb">                break; </div><div class="t m0 x0 hb y42f7 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y42f8 ff123 fs6 fc0 sc0 ls21 wsb">            case &quot;mouseup&quot;: </div><div class="t m0 x0 hb y42f9 ff123 fs6 fc0 sc0 ls21 wsb">                dragging = null; </div><div class="t m0 x0 hb y42fa ff123 fs6 fc0 sc0 ls21 wsb">                break; </div><div class="t m0 x0 hb y42fb ff123 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y42fc ff123 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 hb y42fd ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y42fe ff123 fs6 fc0 sc0 ls21 wsb">    //公共接口 </div><div class="t m0 x0 hb y42ff ff123 fs6 fc0 sc0 ls21 wsb">    return { </div><div class="t m0 x0 hb y4300 ff123 fs6 fc0 sc0 ls21 wsb">        enable: function(){ </div><div class="t m0 x0 hb y4301 ff123 fs6 fc0 sc0 ls21 wsb">            EventUtil.addHandler(document, &quot;mousedown&quot;, handleEvent); </div><div class="t m0 x0 hb y4302 ff123 fs6 fc0 sc0 ls21 wsb">            EventUtil.addHandler(document, &quot;mousemove&quot;, handleEvent); </div><div class="t m0 x0 hb y4303 ff123 fs6 fc0 sc0 ls21 wsb">            EventUtil.addHandler(document, &quot;mouseup&quot;, handleEvent); </div><div class="t m0 x0 hb y4304 ff123 fs6 fc0 sc0 ls21 wsb">        }, </div><div class="t m0 x0 hb y4305 ff123 fs6 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf27e" class="pf w0 h0" data-page-no="27e"><div class="pc pc27e w0 h0"><div class="t m0 x0 h2 y1 ff11c fs0 fc0 sc0 ls7 ws0">620  第22章 高级技巧 </div><div class="t m0 x0 h3 y2 ff11c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y12b2 ff123 fs6 fc0 sc0 ls21 wsb">        disable: function(){ </div><div class="t m0 x0 hb y1670 ff123 fs6 fc0 sc0 ls21 wsb">            EventUtil.removeHandler(document, &quot;mousedown&quot;, handleEvent); </div><div class="t m0 x0 hb y1671 ff123 fs6 fc0 sc0 ls21 wsb">            EventUtil.removeHandler(document, &quot;mousemove&quot;, handleEvent); </div><div class="t m0 x0 hb y1672 ff123 fs6 fc0 sc0 ls21 wsb">            EventUtil.removeHandler(document, &quot;mouseup&quot;, handleEvent); </div><div class="t m0 x0 hb y1673 ff123 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y1674 ff123 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y1675 ff123 fs6 fc0 sc0 ls21 wsb">}();  </div><div class="t m0 x2 hf y1932 ff128 fs2 fc0 sc0 ls8 wsb">DragAndDropExample02.htm </div><div class="t m0 x0 h4 y1f ff123 fs1 fc0 sc0 ls9 ws2">DragDrop对象封装了拖放的所有基本功能。这是一个单例对象，并使用了模块模式来隐藏某些实</div><div class="t m0 x0 h1e y4306 ff122 fs2 fc0 sc0 ls8 wseb">现细节。dragging变量起初是null，将会存放被拖动的元素，所以当该变量不为null时，就知道正</div><div class="t m0 x0 h1e y4307 ff122 fs2 fc0 sc0 ls8 wseb">在拖动某个东西。handleEvent()函数处理拖放功能中的所有的三个鼠标事件。它首先获取event对</div><div class="t m0 x0 h4 y8cb ff122 fs2 fc0 sc0 ls8 wseb">象和事件目标的引用。之后，用一个switch语句确定要触发哪个事件样式。当mousedown事件发生</div><div class="t m0 x0 h1e y128e ff122 fs2 fc0 sc0 ls8 wseb">时，会检查target的class是否包含&quot;draggable&quot;类，如果是，那么将 target存放到dragging</div><div class="t m0 x0 h5 y426c ff122 fs2 fc0 sc0 ls8 wseb">中。这个技巧可以很方便地通过标记语言而非JavaScript脚本来确定可拖动的元素。 </div><div class="t m0 x0 h4 y39d5 ff123 fs1 fc0 sc0 ls9 ws2">handleEvent()的mousemove情况和前面的代码一样，不过要检查dragging是否为null。当</div><div class="t m0 x0 h4 y187a ff122 fs2 fc0 sc0 ls8 wseb">它不是null，就知道dragging就是要拖动的元素，这样就会把它放到恰当的位置上。mouseup情况</div><div class="t m0 x0 hc y187b ff122 fs2 fc0 sc0 ls8 wseb">就仅仅是将dragging重置为null，让mousemove 事件中的判断失效。 </div><div class="t m0 x0 h4 y2382 ff123 fs1 fc0 sc0 ls9 ws2">DragDrop还有两个公共方法：enable()和disable()，它们只是相应添加和删除所有的事件处</div><div class="t m0 x0 h5 y426e ff122 fs2 fc0 sc0 ls8 wseb">理程序。这两个函数提供了额外的对拖放功能的控制手段。 </div><div class="t m0 x0 h1e y426f ff122 fs2 fc0 sc0 ls8 wseb">要使用DragDrop对象，只要在页面上包含这些代码并调用enable()。拖放会自动针对所有包含</div><div class="t m0 x0 h5 y4308 ff123 fs1 fc0 sc0 ls9 ws2">&quot;draggable&quot;类的元素启用，如下例所示： </div><div class="t m0 x0 hb y3a48 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4309 ff123 fs6 fc0 sc0 ls21 wsb">&lt;div class=&quot;draggable&quot; style=&quot;position:absolute; background:red&quot;&gt; &lt;/div&gt; </div><div class="t m0 x0 hb y430a ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y430b ff122 fs2 fc0 sc0 ls8 wseb">注意为了元素能被拖放，它必须是绝对定位的。 </div><div class="t m0 x0 h20 y430c ff120 fs3 fc0 sc0 ls248 ws214">22.5.1 修缮拖动功能 </div><div class="t m0 x0 h4 y14fb ff122 fs2 fc0 sc0 ls8 wseb">当你试了上面的例子之后，你会发现元素的左上角总是和指针在一起。这个结果对用户来说有一点</div><div class="t m0 x0 h4 y430d ff122 fs2 fc0 sc0 ls8 wseb">不爽，因为当鼠标开始移动的时候，元素好像是突然跳了一下。理想情况是，这个动作应该看上去好像</div><div class="t m0 x0 h4 y430e ff122 fs2 fc0 sc0 ls8 wseb">这个元素是被指针“拾起”的，也就是说当在拖动元素的时候，用户点击的那一点就是指针应该保持的</div><div class="t m0 x0 h5 y430f ff122 fs2 fc0 sc0 ls8 wseb">位置（见图22-4）。 </div><div class="t m0 x2 h5 y3a1a ff11c fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x7 h3 y21d3 ff122 fs1 fc0 sc0 ls8 wsb">图 22-4 </div><div class="t m0 x0 h4 y4310 ff122 fs2 fc0 sc0 ls8 wseb">要达到需要的效果，必须做一些额外的计算。你需要计算元素左上角和指针位置之间的差值。这个</div><div class="t m0 x0 h1e y4311 ff122 fs2 fc0 sc0 ls8 wseb">差值应该在mousedown事件发生的时候确定，并且一直保持，直到mouseup事件发生。通过将event</div><div class="t m0 x0 h4 y4312 ff122 fs2 fc0 sc0 ls2c">的clientX和clientY属性与该元素的offsetLeft和offsetTop 属性进行比较，就可以算出水平</div><div class="t m0 x1 h36 y1c26 ff122 fs6 fc0 sc0 ls8 ws124">用户首先点击的是这里 被拖动后，指针就跑到这里了</div></div></div>
<div id="pf27f" class="pf w0 h0" data-page-no="27f"><div class="pc pc27f w0 h0"><div class="t m0 x2 h2 y1 ff11c fs0 fc0 sc0 ls7 ws0">22.5 拖放  621 </div><div class="t m0 x0 h3 y2 ff11c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff127 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff127 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff127 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff127 fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff127 fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff127 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff127 fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff127 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff127 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff127 fs3 fc2 sc0 ls1d wsb">22 </div><div class="t m0 x3 h8 y27 ff127 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff127 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff127 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff122 fs2 fc0 sc0 ls8 wseb">方向和垂直方向上需要多少空间，见图22-5。 </div><div class="t m0 x2 h5 y4313 ff11c fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 h3 yf4f ff122 fs1 fc0 sc0 ls8 wsb">图 22-5 </div><div class="t m0 x0 h4 y4314 ff122 fs2 fc0 sc0 ls8 wseb">为了保存x和y坐标上的差值，还需要几个变量。diffX和diffY这些变量需要在onmousemove</div><div class="t m0 x0 h5 y23ba ff122 fs2 fc0 sc0 ls8 wseb">事件处理程序中用到，来对元素进行适当的定位，如下面的例子所示。 </div><div class="t m0 x0 hb y2ab6 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4315 ff123 fs6 fc0 sc0 ls21 wsb">var DragDrop = function(){  </div><div class="t m0 x0 hb y4316 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4317 ff123 fs6 fc0 sc0 ls21 wsb">    var dragging = null; </div><div class="t m0 x0 h15 y4318 ff129 fs6 fc0 sc0 ls21 wsb">        diffX = 0; </div><div class="t m0 x0 h15 y4319 ff129 fs6 fc0 sc0 ls21 wsb">        diffY = 0; </div><div class="t m0 x0 hb y431a ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y431b ff123 fs6 fc0 sc0 ls21 wsb">    function handleEvent(event){ </div><div class="t m0 x0 hb y431c ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y431d ff123 fs6 fc0 sc0 ls21 wsb">        //获取事件和目标 </div><div class="t m0 x0 hb y431e ff123 fs6 fc0 sc0 ls21 wsb">        event = EventUtil.getEvent(event); </div><div class="t m0 x0 hb y431f ff123 fs6 fc0 sc0 ls21 wsb">        var target = EventUtil.getTarget(event); </div><div class="t m0 x0 hb y4320 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4321 ff123 fs6 fc0 sc0 ls21 wsb">        //确定事件类型 </div><div class="t m0 x0 hb y4322 ff123 fs6 fc0 sc0 ls21 wsb">        switch(event.type){ </div><div class="t m0 x0 hb y4323 ff123 fs6 fc0 sc0 ls21 wsb">            case &quot;mousedown&quot;: </div><div class="t m0 x0 hb y4324 ff123 fs6 fc0 sc0 ls21 wsb">                if (target.className.indexOf(&quot;draggable&quot;) &gt; -1){ </div><div class="t m0 x0 hb y4325 ff123 fs6 fc0 sc0 ls21 wsb">                    dragging = target; </div><div class="t m0 x0 h15 y4326 ff129 fs6 fc0 sc0 ls21 wsb">                      diffX = event.clientX - target.offsetLeft; </div><div class="t m0 x0 h15 y4327 ff129 fs6 fc0 sc0 ls21 wsb">                      diffY = event.clientY - target.offsetTop; </div><div class="t m0 x0 hb y4328 ff123 fs6 fc0 sc0 ls21 wsb">                } </div><div class="t m0 x0 hb y4329 ff123 fs6 fc0 sc0 ls21 wsb">                break; </div><div class="t m0 x0 hb y432a ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y432b ff123 fs6 fc0 sc0 ls21 wsb">            case &quot;mousemove&quot;: </div><div class="t m0 x0 hb y432c ff123 fs6 fc0 sc0 ls21 wsb">                if (dragging !== null){ </div><div class="t m0 x0 hb y432d ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y432e ff123 fs6 fc0 sc0 ls21 wsb">                   //指定位置 </div><div class="t m0 x0 h15 y432f ff129 fs6 fc0 sc0 ls21 wsb">                   dragging.style.left = (event.clientX - diffX) + &quot;px&quot;; </div><div class="t m0 x0 h15 y4330 ff129 fs6 fc0 sc0 ls21 wsb">                   dragging.style.top = (event.clientY - diffY) + &quot;px&quot;; </div><div class="t m0 x0 hb y4331 ff123 fs6 fc0 sc0 ls21 wsb">                } </div><div class="t m0 x0 hb y4332 ff123 fs6 fc0 sc0 ls21 wsb">                break; </div><div class="t m0 x0 hb y4333 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4334 ff123 fs6 fc0 sc0 ls21 wsb">            case &quot;mouseup&quot;: </div></div></div>
<div id="pf280" class="pf w0 h0" data-page-no="280"><div class="pc pc280 w0 h0"><div class="t m0 x0 h2 y1 ff11c fs0 fc0 sc0 ls7 ws0">622  第22章 高级技巧 </div><div class="t m0 x0 h3 y2 ff11c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y8f5 ff123 fs6 fc0 sc0 ls21 wsb">                dragging = null; </div><div class="t m0 x0 hb y8f6 ff123 fs6 fc0 sc0 ls21 wsb">                break; </div><div class="t m0 x0 hb y8f7 ff123 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y8f8 ff123 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 hb y8f9 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y8fa ff123 fs6 fc0 sc0 ls21 wsb">    //公共接口 </div><div class="t m0 x0 hb y8fb ff123 fs6 fc0 sc0 ls21 wsb">    return { </div><div class="t m0 x0 hb y8fc ff123 fs6 fc0 sc0 ls21 wsb">        enable: function(){ </div><div class="t m0 x0 hb y8fd ff123 fs6 fc0 sc0 ls21 wsb">            EventUtil.addHandler(document, &quot;mousedown&quot;, handleEvent); </div><div class="t m0 x0 hb y1037 ff123 fs6 fc0 sc0 ls21 wsb">            EventUtil.addHandler(document, &quot;mousemove&quot;, handleEvent); </div><div class="t m0 x0 hb y1038 ff123 fs6 fc0 sc0 ls21 wsb">            EventUtil.addHandler(document, &quot;mouseup&quot;, handleEvent); </div><div class="t m0 x0 hb y1039 ff123 fs6 fc0 sc0 ls21 wsb">        }, </div><div class="t m0 x0 hb y16a9 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y16aa ff123 fs6 fc0 sc0 ls21 wsb">        disable: function(){ </div><div class="t m0 x0 hb y16ab ff123 fs6 fc0 sc0 ls21 wsb">            EventUtil.removeHandler(document, &quot;mousedown&quot;, handleEvent); </div><div class="t m0 x0 hb y16ac ff123 fs6 fc0 sc0 ls21 wsb">            EventUtil.removeHandler(document, &quot;mousemove&quot;, handleEvent); </div><div class="t m0 x0 hb y16ad ff123 fs6 fc0 sc0 ls21 wsb">            EventUtil.removeHandler(document, &quot;mouseup&quot;, handleEvent); </div><div class="t m0 x0 hb y16ae ff123 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y16af ff123 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y16b0 ff123 fs6 fc0 sc0 ls21 wsb">}(); </div><div class="t m0 x2 hf y4336 ff128 fs2 fc0 sc0 ls8 wsb">DragAndDropExample03.htm </div><div class="t m0 x0 h4 y4337 ff123 fs1 fc0 sc0 ls9 ws2">diffX和diffY变量是私有的，因为只有handleEvent()函数需要用到它们。当mousedown 事</div><div class="t m0 x0 h1e y4338 ff122 fs2 fc0 sc0 ls8 wseb">件发生时，通过clientX减去目标的offsetLeft，clientY减去目标的offsetTop，可以计算到这</div><div class="t m0 x0 h4 y20f3 ff122 fs2 fc0 sc0 ls8 wseb">两个变量的值。当触发了mousemove事件后，就可以使用这些变量从指针坐标中减去，得到最终的坐</div><div class="t m0 x0 h5 y20f4 ff122 fs2 fc0 sc0 ls8 wseb">标。最后得到一个更加平滑的拖动体验，更加符合用户所期望的方式。 </div><div class="t m0 x0 h20 y4339 ff120 fs3 fc0 sc0 ls248 ws214">22.5.2 添加自定义事件 </div><div class="t m0 x0 h4 y433a ff122 fs2 fc0 sc0 ls8 wseb">拖放功能还不能真正应用起来，除非能知道什么时候拖动开始了。从这点上看，前面的代码没有提</div><div class="t m0 x0 h4 y390b ff122 fs2 fc0 sc0 ls8 wseb">供任何方法表示拖动开始、正在拖动或者已经结束。这时，可以使用自定义事件来指示这几个事件的发</div><div class="t m0 x0 h5 y433b ff122 fs2 fc0 sc0 ls8 wseb">生，让应用的其他部分与拖动功能进行交互。 </div><div class="t m0 x0 h1c y433c ff122 fs2 fc0 sc0 ls8 wseb">由于DragDrop对象是一个使用了模块模式的单例，所以需要进行一些更改来使用EventTarget</div><div class="t m0 x0 h4 y229b ff122 fs2 fc0 sc0 ls8 wseb">类型。首先，创建一个新的EventTarget对象，然后添加enable()和disable()方法，最后返回这</div><div class="t m0 x0 h5 y16bf ff122 fs2 fc0 sc0 ls8 wseb">个对象。看以下内容。 </div><div class="t m0 x0 hb yac9 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y433d ff123 fs6 fc0 sc0 ls21 wsb">var DragDrop = function(){  </div><div class="t m0 x0 hb y433e ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y433f ff129 fs6 fc0 sc0 ls21 wsb">    var dragdrop = new EventTarget(), </div><div class="t m0 x0 hb y20a0 ff123 fs6 fc0 sc0 ls21 wsb">        dragging = null, </div><div class="t m0 x0 hb y4340 ff123 fs6 fc0 sc0 ls21 wsb">        diffX = 0, </div><div class="t m0 x0 hb y4341 ff123 fs6 fc0 sc0 ls21 wsb">        diffY = 0; </div><div class="t m0 x0 hb y4342 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4343 ff123 fs6 fc0 sc0 ls21 wsb">    function handleEvent(event){ </div><div class="t m0 x0 hb y4344 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4345 ff123 fs6 fc0 sc0 ls21 wsb">        //获取事件和对象 </div><div class="t m0 x0 hb y4346 ff123 fs6 fc0 sc0 ls21 wsb">        event = EventUtil.getEvent(event); </div><div class="t m0 x0 hb y4347 ff123 fs6 fc0 sc0 ls21 wsb">        var target = EventUtil.getTarget(event); </div><div class="t m0 x0 hb y4348 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4349 ff123 fs6 fc0 sc0 ls21 wsb">        //确定事件类型 </div></div></div>
<div id="pf281" class="pf w0 h0" data-page-no="281"><div class="pc pc281 w0 h0"><div class="t m0 x2 h2 y1 ff11c fs0 fc0 sc0 ls7 ws0">22.5 拖放  623 </div><div class="t m0 x0 h3 y2 ff11c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff127 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff127 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff127 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff127 fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff127 fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff127 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff127 fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff127 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff127 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff127 fs3 fc2 sc0 ls1d wsb">22 </div><div class="t m0 x3 h8 y27 ff127 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff127 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff127 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y1eb0 ff123 fs6 fc0 sc0 ls21 wsb">        switch(event.type){ </div><div class="t m0 x0 hb y434a ff123 fs6 fc0 sc0 ls21 wsb">            case &quot;mousedown&quot;: </div><div class="t m0 x0 hb y434b ff123 fs6 fc0 sc0 ls21 wsb">                if (target.className.indexOf(&quot;draggable&quot;) &gt; -1){ </div><div class="t m0 x0 hb y434c ff123 fs6 fc0 sc0 ls21 wsb">                    dragging = target; </div><div class="t m0 x0 hb y434d ff123 fs6 fc0 sc0 ls21 wsb">                    diffX = event.clientX - target.offsetLeft; </div><div class="t m0 x0 hb y434e ff123 fs6 fc0 sc0 ls21 wsb">                    diffY = event.clientY - target.offsetTop; </div><div class="t m0 x0 h15 y434f ff129 fs6 fc0 sc0 ls21 wsb">                      dragdrop.fire({type:&quot;dragstart&quot;, target: dragging, </div><div class="t m0 x0 h15 y4350 ff129 fs6 fc0 sc0 ls21 wsb">                                       x: event.clientX, y: event.clientY}); </div><div class="t m0 x0 hb y4351 ff129 fs6 fc0 sc0 ls21 wsb">                } </div><div class="t m0 x0 hb y4352 ff123 fs6 fc0 sc0 ls21 wsb">                break; </div><div class="t m0 x0 hb y4353 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4354 ff123 fs6 fc0 sc0 ls21 wsb">            case &quot;mousemove&quot;: </div><div class="t m0 x0 hb y4355 ff123 fs6 fc0 sc0 ls21 wsb">                if (dragging !== null){ </div><div class="t m0 x0 hb y4356 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4357 ff123 fs6 fc0 sc0 ls21 wsb">                    //指定位置 </div><div class="t m0 x0 hb y4358 ff123 fs6 fc0 sc0 ls21 wsb">                    dragging.style.left = (event.clientX - diffX) + &quot;px&quot;; </div><div class="t m0 x0 hb y4359 ff123 fs6 fc0 sc0 ls21 wsb">                    dragging.style.top = (event.clientY - diffY) + &quot;px&quot;; </div><div class="t m0 x0 hb y435a ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y435b ff129 fs6 fc0 sc0 ls21 wsb">                      //触发自定义事件 </div><div class="t m0 x0 h15 y435c ff129 fs6 fc0 sc0 ls21 wsb">                      dragdrop.fire({type:&quot;drag&quot;, target: dragging, </div><div class="t m0 x0 h15 y435d ff129 fs6 fc0 sc0 ls21 wsb">                                     x: event.clientX, y: event.clientY}); </div><div class="t m0 x0 h15 y435e ff129 fs6 fc0 sc0 ls21 wsb">                } </div><div class="t m0 x0 hb y435f ff123 fs6 fc0 sc0 ls21 wsb">                break; </div><div class="t m0 x0 hb y4360 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4361 ff123 fs6 fc0 sc0 ls21 wsb">            case &quot;mouseup&quot;: </div><div class="t m0 x0 h15 y4362 ff129 fs6 fc0 sc0 ls21 wsb">                dragdrop.fire({type:&quot;dragend&quot;, target: dragging, </div><div class="t m0 x0 h15 y4363 ff129 fs6 fc0 sc0 ls21 wsb">                               x: event.clientX, y: event.clientY}); </div><div class="t m0 x0 h15 y4364 ff129 fs6 fc0 sc0 ls21 wsb">                dragging = null; </div><div class="t m0 x0 hb y4365 ff123 fs6 fc0 sc0 ls21 wsb">                break; </div><div class="t m0 x0 hb y4366 ff123 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y4367 ff123 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 hb y4368 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4369 ff123 fs6 fc0 sc0 ls21 wsb">    //公共接口 </div><div class="t m0 x0 h15 y436a ff129 fs6 fc0 sc0 ls21 wsb">    dragdrop.enable = function(){ </div><div class="t m0 x0 h15 y436b ff129 fs6 fc0 sc0 ls21 wsb">        EventUtil.addHandler(document, &quot;mousedown&quot;, handleEvent); </div><div class="t m0 x0 h15 y436c ff129 fs6 fc0 sc0 ls21 wsb">        EventUtil.addHandler(document, &quot;mousemove&quot;, handleEvent); </div><div class="t m0 x0 h15 y436d ff129 fs6 fc0 sc0 ls21 wsb">        EventUtil.addHandler(document, &quot;mouseup&quot;, handleEvent); </div><div class="t m0 x0 h15 y436e ff129 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 h15 y436f ff129 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y4370 ff129 fs6 fc0 sc0 ls21 wsb">    dragdrop.disable = function(){ </div><div class="t m0 x0 h15 y4371 ff129 fs6 fc0 sc0 ls21 wsb">        EventUtil.removeHandler(document, &quot;mousedown&quot;, handleEvent); </div><div class="t m0 x0 h15 y4372 ff129 fs6 fc0 sc0 ls21 wsb">        EventUtil.removeHandler(document, &quot;mousemove&quot;, handleEvent); </div><div class="t m0 x0 h15 y4373 ff129 fs6 fc0 sc0 ls21 wsb">        EventUtil.removeHandler(document, &quot;mouseup&quot;, handleEvent); </div><div class="t m0 x0 h15 y4374 ff129 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 h15 y4375 ff129 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y4376 ff129 fs6 fc0 sc0 ls21 wsb">    return dragdrop; </div><div class="t m0 x0 hb y4377 ff123 fs6 fc0 sc0 ls21 wsb">}(); </div><div class="t m0 x5 hb y4378 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1617 ff128 fs2 fc0 sc0 ls8 wsb">DragAndDropExample04.htm </div><div class="t m0 x0 h4 y1d12 ff122 fs2 fc0 sc0 ls1f ws108">这段代码定义了三个事件：dragstart、drag和dragend。它们都将被拖动的元素设置为了target，</div><div class="t m0 x0 h1e y4379 ff122 fs2 fc0 sc0 ls8 wseb">并给出了x和y属性来表示当前的位置。它们触发于dragdrop对象上，之后在返回对象前给对象增</div><div class="t m0 x0 h5 y1d14 ff122 fs2 fc0 sc0 ls15a">加enable()和disable()方法。这些模块模式中的细小更改令DragDrop对象支持了事件，如下： </div><div class="t m0 x5 hb y437a ff123 fs6 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf282" class="pf w0 h0" data-page-no="282"><div class="pc pc282 w0 h0"><div class="t m0 x0 h2 y1 ff11c fs0 fc0 sc0 ls7 ws0">624  第22章 高级技巧 </div><div class="t m0 x0 h3 y2 ff11c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y8f5 ff123 fs6 fc0 sc0 ls21 wsb">DragDrop.addHandler(&quot;dragstart&quot;, function(event){ </div><div class="t m0 x0 hb y8f6 ff123 fs6 fc0 sc0 ls21 wsb">    var status = document.getElementById(&quot;status&quot;); </div><div class="t m0 x0 hb y8f7 ff123 fs6 fc0 sc0 ls21 wsb">    status.innerHTML = &quot;Started dragging &quot; + event.target.id; </div><div class="t m0 x0 hb y8f8 ff123 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 hb y8f9 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y8fa ff123 fs6 fc0 sc0 ls21 wsb">DragDrop.addHandler(&quot;drag&quot;, function(event){ </div><div class="t m0 x0 hb y8fb ff123 fs6 fc0 sc0 ls21 wsb">    var status = document.getElementById(&quot;status&quot;); </div><div class="t m0 x0 hb y8fc ff123 fs6 fc0 sc0 ls21 wsb">    status.innerHTML += &quot;&lt;br/&gt; Dragged &quot; + event.target.id + &quot; to (&quot; + event.x + </div><div class="t m0 x0 hb y8fd ff123 fs6 fc0 sc0 ls21 wsb">                         &quot;,&quot; + event.y + &quot;)&quot;; </div><div class="t m0 x0 hb y1037 ff123 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 hb y1038 ff123 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1039 ff123 fs6 fc0 sc0 ls21 wsb">DragDrop.addHandler(&quot;dragend&quot;, function(event){ </div><div class="t m0 x0 hb y16a9 ff123 fs6 fc0 sc0 ls21 wsb">    var status = document.getElementById(&quot;status&quot;); </div><div class="t m0 x0 hb y16aa ff123 fs6 fc0 sc0 ls21 wsb">    status.innerHTML += &quot;&lt;br/&gt; Dropped &quot; + event.target.id + &quot; at (&quot; + event.x + </div><div class="t m0 x0 hb y16ab ff123 fs6 fc0 sc0 ls21 wsb">                         &quot;,&quot; + event.y + &quot;)&quot;; </div><div class="t m0 x0 hb y16ac ff123 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x2 hf y437c ff128 fs2 fc0 sc0 ls8 wsb">DragAndDropExample04.htm </div><div class="t m0 x0 h4 y266c ff122 fs2 fc0 sc0 ls8 wseb">这里，为DragDrop对象的每个事件添加了事件处理程序。还使用了一个元素来实现被拖动的元素</div><div class="t m0 x0 h5 y437d ff122 fs2 fc0 sc0 ls8 wseb">当前的状态和位置。一旦元素被放下了，就可以看到从它一开始被拖动之后经过的所有的中间步骤。 </div><div class="t m0 x0 h1e y437e ff122 fs2 fc0 sc0 ls475">为DragDrop添加自定义事件可以使这个对象更健壮，它将可以在网络应用中处理复杂的拖放</div><div class="t m0 x0 h5 y3007 ff122 fs2 fc0 sc0 lsa">功能。 </div><div class="t m0 x0 hd y437f ff120 fs7 fc0 sc0 ls245">22.6 小结 </div><div class="t m0 x0 h5 y4380 ff11c fs2 fc0 sc0 lsb ws5">JavaScript中的函数非常强大，因为它们是第一类对象。使用闭包和函数环境切换，还可以有很多</div><div class="t m0 x0 h1e y4381 ff122 fs2 fc0 sc0 ls8 wseb">使用函数的强大方法。可以创建作用域安全的构造函数，确保在缺少new操作符时调用构造函数不会改</div><div class="t m0 x0 h5 y4382 ff122 fs2 fc0 sc0 ls8 wseb">变错误的环境对象。  </div><div class="t m0 x0 h5 y1e12 ff121 fs1 fc0 sc0 ls2"> 可以使用惰性载入函数，将任何代码分支推迟到第一次调用函数的时候。  </div><div class="t m0 x0 h4 y4383 ff121 fs1 fc0 sc0 ls2"> 函数绑定可以让你创建始终在指定环境中运行的函数，同时函数柯里化可以让你创建已经填了</div><div class="t m0 x0 h5 y4384 ff122 fs2 fc0 sc0 ls8 wseb">某些参数的函数。  </div><div class="t m0 x0 h5 y2c1e ff121 fs1 fc0 sc0 ls2"> 将绑定和柯里化组合起来，就能够给你一种在任意环境中以任意参数执行任意函数的方法。 </div><div class="t m0 x0 h5 y7c7 ff11c fs2 fc0 sc0 ls79 ws73">ECMAScript 5允许通过以下几种方式来创建防篡改对象。 </div><div class="t m0 x0 h5 y4385 ff121 fs1 fc0 sc0 ls2"> 不可扩展的对象，不允许给对象添加新的属性或方法。 </div><div class="t m0 x0 h5 y88c ff121 fs1 fc0 sc0 ls2"> 密封的对象，也是不可扩展的对象，不允许删除已有的属性和方法。 </div><div class="t m0 x0 h5 y2c21 ff121 fs1 fc0 sc0 ls2"> 冻结的对象，也是密封的对象，不允许重写对象的成员。 </div><div class="t m0 x0 h5 y4386 ff11c fs2 fc0 sc0 lsb ws5">JavaScript中可以使用setTimeout()和setInterval()如下创建定时器。 </div><div class="t m0 x0 h5 yb13 ff121 fs1 fc0 sc0 ls2"> 定时器代码是放在一个等待区域，直到时间间隔到了之后，此时将代码添加到JavaScript的处理</div><div class="t m0 x0 h5 y4387 ff122 fs2 fc0 sc0 ls8 wseb">队列中，等待下一次JavaScript进程空闲时被执行。  </div><div class="t m0 x0 h5 y4388 ff121 fs1 fc0 sc0 ls2"> 每次一段代码执行结束之后，都会有一小段空闲时间进行其他浏览器处理。  </div><div class="t m0 x0 h4 y4389 ff121 fs1 fc0 sc0 ls2"> 这种行为意味着，可以使用定时器将长时间运行的脚本切分为一小块一小块可以在以后运行的</div><div class="t m0 x0 h5 y2a7f ff122 fs2 fc0 sc0 ls8 wseb">代码段。这种做法有助于Web应用对用户交互有更积极的响应。 </div><div class="t m0 x0 h5 y438a ff11c fs2 fc0 sc0 lsb ws5">JavaScript中经常以事件的形式应用观察者模式。虽然事件常常和DOM一起使用，但是你也可以通</div></div></div>
<div id="pf283" class="pf w0 h0" data-page-no="283"><div class="pc pc283 w0 h0"><div class="t m0 x2 h2 y1 ff11c fs0 fc0 sc0 ls7 ws0">22.6 小结  625 </div><div class="t m0 x0 h3 y2 ff11c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff127 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff127 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff127 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff127 fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff127 fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff127 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff127 fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff127 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff127 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff127 fs3 fc2 sc0 ls1d wsb">22 </div><div class="t m0 x3 h8 y27 ff127 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff127 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff127 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h4 y3 ff122 fs2 fc0 sc0 ls8 wseb">过实现自定义事件在自己的代码中应用。使用自定义事件有助于将不同部分的代码相互之间解耦，让维</div><div class="t m0 x0 h5 y4d ff122 fs2 fc0 sc0 ls8 wseb">护更加容易，并减少引入错误的机会。 </div><div class="t m0 x0 h5 yd8 ff122 fs2 fc0 sc0 ls8 wseb">拖放对于桌面和Web应用都是一个非常流行的用户界面范例，它能够让用户非常方便地以一种直</div><div class="t m0 x0 h5 y28b ff122 fs2 fc0 sc0 ls5 wsec">观的方式重新排列或者配置东西。在JavaScrip中可以使用鼠标事件和一些简单的计算来实现这种功能</div><div class="t m0 x0 h4 yfdb ff122 fs2 fc0 sc0 ls24">类型。将拖放行为和自定义事件结合起来可以创建一个可重复使用的框架，它能应用于各种不同的情</div><div class="t m0 x0 h5 y14e1 ff122 fs2 fc0 sc0 ls5">况下。 </div></div></div>
<div id="pf284" class="pf w0 h0" data-page-no="284"><div class="pc pc284 w0 h0"><div class="t m0 x0 h2 y1 ff12b fs0 fc0 sc0 ls7 ws0">626  第23章 离线应用与客户端存储 </div><div class="t m0 x0 h3 y2 ff12b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h9 y2a ff12d fs5 fc0 sc0 ls8 wsb">离线应用与客户端存储 </div><div class="t m0 x0 h3c y2b ff12e fs2 fc0 sc0 ls8">本章内容 </div><div class="t m0 x0 h5 y2c ff130 fs1 fc0 sc0 ls2"> 进行离线检测 </div><div class="t m0 x0 h5 y2d ff130 fs1 fc0 sc0 ls2"> 使用离线缓存 </div><div class="t m0 x0 h5 y2e ff130 fs1 fc0 sc0 ls2"> 在浏览器中保存数据 </div><div class="t m0 x0 h5 y8d9 ff12b fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y8da ff131 fs2 fc0 sc0 ls4 ws3">持离线Web应用开发是HTML5 的另一个重点。所谓离线Web应用，就是在设备不能上</div><div class="t m0 x0 h5 y8db ff131 fs2 fc0 sc0 ls4">网的情况下仍然可以运行的应用。HTML5把离线应用作为重点，主要是基于开发人员的</div><div class="t m0 x0 h5 y8dc ff131 fs2 fc0 sc0 ls4 ws3">心愿。前端开发人员一直希望Web应用能够与传统的客户端应用同场竞技，起码做到只要设备有电</div><div class="t m0 x0 h5 y8dd ff131 fs2 fc0 sc0 ls4">就能使用。 </div><div class="t m0 x0 h5 y8de ff131 fs2 fc0 sc0 ls8 ws1">开发离线Web应用需要几个步骤。首先是确保应用知道设备是否能上网，以便下一步执行正确的</div><div class="t m0 x0 h5 y8df ff131 fs2 fc0 sc0 ls8 ws1">操作。然后，应用还必须能访问一定的资源（图像、JavaScript、CSS等），只有这样才能正常工作。最</div><div class="t m0 x0 h5 y8e0 ff131 fs2 fc0 sc0 ls8 ws1">后，必须有一块本地空间用于保存数据，无论能否上网都不妨碍读写。HTML5及其相关的API让开发</div><div class="t m0 x0 h5 y8e1 ff131 fs2 fc0 sc0 ls8 ws1">离线应用成为现实。 </div><div class="t m0 x0 hd y13e5 ff12f fs7 fc0 sc0 ls245">23.1 离线检测 </div><div class="t m0 x0 h5 y10cb ff131 fs2 fc0 sc0 ls42 ws30">开发离线应用的第一步是要知道设备是在线还是离线，HTML5为此定义了一个navigator.onLine</div><div class="t m0 x0 h4 y8e4 ff131 fs2 fc0 sc0 ls8 ws1">属性，这个属性值为true表示设备能上网，值为false表示设备离线。这个属性的关键是浏览器必须</div><div class="t m0 x0 h1e y8e5 ff131 fs2 fc0 sc0 ls6 ws6">知道设备能否访问网络，从而返回正确的值。实际应用中，navigator.onLine在不同浏览器间还有</div><div class="t m0 x0 h5 y3aac ff131 fs2 fc0 sc0 ls8 ws1">些小的差异。 </div><div class="t m0 x0 h5 y2c55 ff130 fs1 fc0 sc0 ls2"> IE6+和Safari 5+能够正确检测到网络已断开，并将navigator.onLine的值转换为false。 </div><div class="t m0 x0 h5 y2c56 ff130 fs1 fc0 sc0 ls2"> Firefox 3+和Opera 10.6+支持navigator.onLine属性，但你必须手工选中菜单项“文件 → Web</div><div class="t m0 x0 h5 y3c4b ff131 fs2 fc0 sc0 ls8 ws1">开发人员（设置）→ 脱机工作”才能让浏览器正常工作。 </div><div class="t m0 x0 h5 y1a7f ff130 fs1 fc0 sc0 ls2"> Chrome 11及之前版本始终将navigator.onLine 属性设置为true。这是一个有待修复的</div><div class="t m0 x0 h3b y1d60 ff12b fs2 fc0 sc0 ls8 ws20">bug①。 </div><div class="t m0 x0 h1e y1d61 ff131 fs2 fc0 sc0 ls8 ws1">由于存在上述兼容性问题，单独使用navigator.onLine属性不能确定网络是否连通。即便如此，</div><div class="t m0 x0 h5 y2c57 ff131 fs2 fc0 sc0 ls8 ws1">在请求发生错误的情况下，检测这个属性仍然是管用的。以下是检测该属性状态的示例。 </div><div class="t m0 x0 hb y23f3 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y23f4 ff132 fs6 fc0 sc0 ls21 wsb">if (navigator.onLine){ </div><div class="t m0 x0 h2d y438c ff132 fs6 fc0 sc0 ls21 wsb">    //正常工作 </div><div class="t m0 x0 hb y438d ff132 fs6 fc0 sc0 ls21 wsb">} else { </div><div class="t m0 x0 h16 y438e ff132 fs6 fc0 sc0 ls21 wsb">    //执行离线状态时的任务 </div><div class="t m0 x0 h3c y2d6 ff12e fs2 fc0 sc0 ls7b wsb">—————————— </div><div class="t m0 x0 h36 ycc6 ff131 fs6 fc0 sc0 ls95">① 这个bug在2011年10月已被修复（http://code.google.com/p/chromium/issues/detail?id=7469）。 </div><div class="t m0 x0 h129 y438f ff12e fs18 fc0 sc0 ls8 wsb">支 </div><div class="t m0 x0 h11 y4b ff135 fsa fc0 sc0 ls8">第</div><div class="t m1 x0 h12 y4b ff136 fsb fc3 sc0 ls247">23</div><div class="t m0 x5 h9 y4b ff135 fsa fc0 sc0 ls8 ws1d">章 </div></div></div>
<div id="pf285" class="pf w0 h0" data-page-no="285"><div class="pc pc285 w0 h0"><div class="t m0 x2 h2 y1 ff12b fs0 fc0 sc0 ls7 ws0">23.2 应用缓存    627 </div><div class="t m0 x0 h3 y2 ff12b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff137 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff137 fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ff137 fs3 fc2 sc0 ls1d wsb">16 </div><div class="t m0 x3 h8 y20 ff137 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff137 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff137 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff137 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff137 fs3 fc2 sc0 ls1d wsb">20 </div><div class="t m0 x3 h8 y25 ff137 fs3 fc2 sc0 ls1d wsb">21 </div><div class="t m0 x3 h8 y26 ff137 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff137 fs3 fc2 sc0 ls1d wsf">23 </div><div class="t m0 x3 h8 ya7a ff137 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff137 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y79 ff132 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y1b0b ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y318d ff138 fs2 fc0 sc0 ls1b wsb">OnLineExample01.htm </div><div class="t m0 x0 h5 y318e ff131 fs2 fc0 sc0 ls479">除navigator.onLine属性之外，为了更好地确定网络是否可用，HTML5还定义了两个事件：</div><div class="t m0 x0 h4 y4390 ff132 fs1 fc0 sc0 ls9 ws2">online和offline。当网络从离线变为在线或者从在线变为离线时，分别触发这两个事件。这两个事</div><div class="t m0 x0 h5 y22a9 ff131 fs2 fc0 sc0 ls8 ws1">件在window对象上触发。 </div><div class="t m0 x0 hb y32f2 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4391 ff132 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(window, &quot;online&quot;, function(){ </div><div class="t m0 x0 hb y4392 ff132 fs6 fc0 sc0 ls21 wsb">    alert(&quot;Online&quot;); </div><div class="t m0 x0 hb y4393 ff132 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 hb y4394 ff132 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(window, &quot;offline&quot;, function(){ </div><div class="t m0 x0 hb y4395 ff132 fs6 fc0 sc0 ls21 wsb">    alert(&quot;Offline&quot;); </div><div class="t m0 x0 hb y4396 ff132 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 hb y4397 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y4398 ff138 fs2 fc0 sc0 ls79 wsb">OnlineEventsExample01.htm </div><div class="t m0 x0 h4 y4399 ff131 fs2 fc0 sc0 ls8 ws1">为了检测应用是否离线，在页面加载后，最好先通过navigator.onLine取得初始的状态。然后，</div><div class="t m0 x0 h4 y439a ff131 fs2 fc0 sc0 ls6 ws6">就是通过上述两个事件来确定网络连接状态是否变化。当上述事件触发时，navigator.onLine属性</div><div class="t m0 x0 h5 y439b ff131 fs2 fc0 sc0 ls8 ws1">的值也会改变，不过必须要手工轮询这个属性才能检测到网络状态的变化。 </div><div class="t m0 x0 he y439c ff131 fs2 fc0 sc0 ls8 ws1">支持离线检测的浏览器有IE 6+（只支持navigator.onLine属性）、Firefox 3、Safari 4、Opera 10.6、</div><div class="t m0 x0 h5 y439d ff12b fs2 fc0 sc0 ls50 ws41">Chrome、iOS 3.2版Safari和Android版WebKit。 </div><div class="t m0 x0 hd y82f ff12f fs7 fc0 sc0 ls245">23.2 应用缓存 </div><div class="t m0 x0 h5 y439e ff12b fs2 fc0 sc0 ls2f ws8a">HTML5的应用缓存（application cache），或者简称为appcache，是专门为开发离线Web应用而设计</div><div class="t m0 x0 h5 y439f ff131 fs2 fc0 sc0 ls8 ws1">的。Appcache就是从浏览器的缓存中分出来的一块缓存区。要想在这个缓存中保存数据，可以使用一个</div><div class="t m0 x0 h5 y43a0 ff12e fs2 fc0 sc0 ls8 ws12">描述文件（manifest file），列出要下载和缓存的资源。下面是一个简单的描述文件示例。 </div><div class="t m0 x0 hb y25fe ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y43a1 ff132 fs6 fc0 sc0 ls21 wsb">CACHE MANIFEST </div><div class="t m0 x0 hb y43a2 ff132 fs6 fc0 sc0 ls21 wsb">#Comment </div><div class="t m0 x0 hb y43a3 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y43a4 ff132 fs6 fc0 sc0 ls21 wsb">file.js </div><div class="t m0 x0 hb y43a5 ff132 fs6 fc0 sc0 ls21 wsb">file.css </div><div class="t m0 x0 hb y43a6 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y43a7 ff131 fs2 fc0 sc0 ls8 ws1">在最简单的情况下，描述文件中列出的都是需要下载的资源，以备离线时使用。 </div><div class="t m0 x5 ha y43a8 ff12c fs2 fc0 sc0 ls8 ws14">设置描述文件的选项非常多，本书不打算详细解释每一个选项。要了解这些选项，</div><div class="t m0 x5 h5 y43a9 ff12c fs2 fc0 sc0 ls8 ws14">推荐读者阅读HTML5Doctor中的文章“Go offline with application cache”，网址为</div><div class="t m0 x5 h5 y43aa ff12b fs2 fc0 sc0 ls7a ws89">http://html5doctor.com/go-offline-with-application-cache。 </div><div class="t m0 x0 h15a y43ab ff131 fs2 fc0 sc0 ls8 ws1">要将描述文件与页面关联起来，可以在&lt;html&gt;中的manifest属性中指定这个文件的路径，例如： </div><div class="t m0 x0 hb y43ac ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y43ad ff132 fs6 fc0 sc0 ls21 wsb">&lt;html manifest=&quot;/offline.manifest&quot;&gt; </div><div class="t m0 x0 hb y43ae ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3bc6 ff131 fs2 fc0 sc0 lsa ws53">以上代码告诉页面，/offline.manifest中包含着描述文件。这个文件的MIME 类型必须是</div><div class="t m0 x0 h3b y8c1 ff132 fs1 fc0 sc0 ls9 ws2">text/cache-manifest①。 </div><div class="t m0 x0 h3c y43af ff12e fs2 fc0 sc0 ls7b wsb">—————————— </div><div class="t m0 x0 h36 ycc6 ff131 fs6 fc0 sc0 ls95">① 描述文件的扩展名以前推荐用manifest，但现在推荐的是appcache。 </div></div></div>
<div id="pf286" class="pf w0 h0" data-page-no="286"><div class="pc pc286 w0 h0"><div class="t m0 x0 h2 y1 ff12b fs0 fc0 sc0 ls7 ws0">628  第23章 离线应用与客户端存储 </div><div class="t m0 x0 h3 y2 ff12b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff131 fs2 fc0 sc0 ls8 ws1">虽然应用缓存的意图是确保离线时资源可用，但也有相应的JavaScript API让你知道它都在做什么。</div><div class="t m0 x0 h5 y4d ff131 fs2 fc0 sc0 ls8 ws1">这个API的核心是applicationCache对象，这个对象有一个 status属性，属性的值是常量，表示</div><div class="t m0 x0 h5 y5 ff131 fs2 fc0 sc0 ls8 ws1">应用缓存的如下当前状态。 </div><div class="t m0 x0 h5 yd9 ff130 fs1 fc0 sc0 ls2"> 0：无缓存，即没有与页面相关的应用缓存。 </div><div class="t m0 x0 h5 y219 ff130 fs1 fc0 sc0 ls2"> 1：闲置，即应用缓存未得到更新。 </div><div class="t m0 x0 h5 y8 ff130 fs1 fc0 sc0 ls2"> 2：检查中，即正在下载描述文件并检查更新。 </div><div class="t m0 x0 h5 y9 ff130 fs1 fc0 sc0 ls2"> 3：下载中，即应用缓存正在下载描述文件中指定的资源。 </div><div class="t m0 x0 h5 ya ff130 fs1 fc0 sc0 ls2"> 4：更新完成，即应用缓存已经更新了资源，而且所有资源都已下载完毕，可以通过 swapCache()</div><div class="t m0 x0 h5 yb ff131 fs2 fc0 sc0 ls8 ws1">来使用了。 </div><div class="t m0 x0 h5 yc ff130 fs1 fc0 sc0 ls2"> 5：废弃，即应用缓存的描述文件已经不存在了，因此页面无法再访问应用缓存。 </div><div class="t m0 x0 h5 y116b ff131 fs2 fc0 sc0 ls8 ws1">应用缓存还有很多相关的事件，表示其状态的改变。以下是这些事件。 </div><div class="t m0 x0 h5 y21b ff130 fs1 fc0 sc0 ls2"> checking：在浏览器为应用缓存查找更新时触发。 </div><div class="t m0 x0 h5 y21c ff130 fs1 fc0 sc0 ls2"> error：在检查更新或下载资源期间发生错误时触发。 </div><div class="t m0 x0 h5 y10 ff130 fs1 fc0 sc0 ls2"> noupdate：在检查描述文件发现文件无变化时触发。 </div><div class="t m0 x0 h5 y11 ff130 fs1 fc0 sc0 ls2"> downloading：在开始下载应用缓存资源时触发。 </div><div class="t m0 x0 h5 y1a57 ff130 fs1 fc0 sc0 ls2"> progress：在文件下载应用缓存的过程中持续不断地触发。 </div><div class="t m0 x0 h5 y13 ff130 fs1 fc0 sc0 ls2"> updateready：在页面新的应用缓存下载完毕且可以通过swapCache()使用时触发。 </div><div class="t m0 x0 h5 y24aa ff130 fs1 fc0 sc0 ls2"> cached：在应用缓存完整可用时触发。 </div><div class="t m0 x0 h1e y24ab ff131 fs2 fc0 sc0 ls8 ws1">一般来讲，这些事件会随着页面加载按上述顺序依次触发。不过，通过调用update()方法也可以</div><div class="t m0 x0 h5 y2df2 ff131 fs2 fc0 sc0 ls8 ws1">手工干预，让应用缓存为检查更新而触发上述事件。 </div><div class="t m0 x0 hb y43b0 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y43b1 ff132 fs6 fc0 sc0 ls21 wsb">applicationCache.update(); </div><div class="t m0 x0 hb y43b2 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y43b3 ff132 fs1 fc0 sc0 ls9 ws2">update()一经调用，应用缓存就会去检查描述文件是否更新（触发checking事件），然后就像页</div><div class="t m0 x0 h1e y43b4 ff131 fs2 fc0 sc0 ls8 ws1">面刚刚加载一样，继续执行后续操作。如果触发了cached事件，就说明应用缓存已经准备就绪，不会</div><div class="t m0 x0 h1e y43b5 ff131 fs2 fc0 sc0 ls8 ws1">再发生其他操作了。如果触发了updateready事件，则说明新版本的应用缓存已经可用，而此时你需</div><div class="t m0 x0 h5 y43b6 ff131 fs2 fc0 sc0 ls8 ws1">要调用swapCache()来启用新应用缓存。 </div><div class="t m0 x0 hb y43b7 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y43b8 ff132 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(applicationCache, &quot;updateready&quot;, function(){ </div><div class="t m0 x0 hb y43b9 ff132 fs6 fc0 sc0 ls21 wsb">    applicationCache.swapCache(); </div><div class="t m0 x0 hb y43ba ff132 fs6 fc0 sc0 ls21 wsb">});  </div><div class="t m0 x0 hb y43bb ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1944 ff131 fs2 fc0 sc0 ls8 ws1">支持HTML5应用缓存的浏览器有Firefox 3+、Safari 4+、Opera 10.6、Chrome、iOS 3.2+版Safari</div><div class="t m0 x0 hc y1945 ff131 fs2 fc0 sc0 ls3b">及Android版WebKit。在Firefox 4及之前版本中调用swapCache()会抛出错误。 </div><div class="t m0 x0 hd y43bc ff12f fs7 fc0 sc0 ls245">23.3 数据存储 </div><div class="t m0 x0 h5 y43bd ff131 fs2 fc0 sc0 ls8 ws1">随着Web应用程序的出现，也产生了对于能够直接在客户端上存储用户信息能力的要求。想法很</div><div class="t m0 x0 h4 y43be ff131 fs2 fc0 sc0 ls8 ws1">合乎逻辑，属于某个特定用户的信息应该存在该用户的机器上。无论是登录信息、偏好设定或其他数据，</div><div class="t m0 x0 h5 y43bf ff12b fs2 fc0 sc0 lsfd wscc">Web应用提供者发现他们在找各种方式将数据存在客户端上。这个问题的第一个方案是以cookie的形式</div><div class="t m0 x0 h5 y43c0 ff131 fs2 fc0 sc0 ls8 ws1">出现的，cookie是原来的网景公司创造的。一份题为“Persistent Client State: HTTP Cookes”（持久客户</div><div class="t m0 x0 h5 y43c1 ff131 fs2 fc0 sc0 ls28b ws273">端状态：HTTP Cookies）的标准中对cookie机制进行了阐述（该标准还可以在这里看到：</div><div class="t m0 x0 h5 y43c2 ff12b fs2 fc0 sc0 ls2b ws22">http://curl.haxx.se/rfc/cookie_spec.html）。今天，cookie只是在客户端存储数据的其中一种选项。  </div></div></div>
<div id="pf287" class="pf w0 h0" data-page-no="287"><div class="pc pc287 w0 h0"><div class="t m0 x2 h2 y1 ff12b fs0 fc0 sc0 ls7 ws0">23.3 数据存储    629 </div><div class="t m0 x0 h3 y2 ff12b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff137 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff137 fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ff137 fs3 fc2 sc0 ls1d wsb">16 </div><div class="t m0 x3 h8 y20 ff137 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff137 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff137 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff137 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff137 fs3 fc2 sc0 ls1d wsb">20 </div><div class="t m0 x3 h8 y25 ff137 fs3 fc2 sc0 ls1d wsb">21 </div><div class="t m0 x3 h8 y26 ff137 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff137 fs3 fc2 sc0 ls1d wsf">23 </div><div class="t m0 x3 h8 ya7a ff137 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff137 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h20 y43c3 ff12f fs3 fc0 sc0 ls248 ws214">23.3.1 Cookie </div><div class="t m0 x0 h5 y43c4 ff12b fs2 fc0 sc0 ls94 ws1e6">HTTP Cookie，通常直接叫做cookie，最初是在客户端用于存储会话信息的。该标准要求服务器对</div><div class="t m0 x0 h5 y43c5 ff131 fs2 fc0 sc0 ls8 ws1">任意HTTP请求发送Set-Cookie HTTP头作为响应的一部分，其中包含会话信息。例如，这种服务器响</div><div class="t m0 x0 h5 y43c6 ff131 fs2 fc0 sc0 ls8 ws1">应的头可能如下： </div><div class="t m0 x0 hb y43c7 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y43c8 ff132 fs6 fc0 sc0 ls21 wsb">HTTP/1.1 200 OK </div><div class="t m0 x0 hb y43c9 ff132 fs6 fc0 sc0 ls21 wsb">Content-type: text/html </div><div class="t m0 x0 hb y43ca ff132 fs6 fc0 sc0 ls21 wsb">Set-Cookie: name=value </div><div class="t m0 x0 hb y43cb ff132 fs6 fc0 sc0 ls21 wsb">Other-header: other-header-value </div><div class="t m0 x0 hb y43cc ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y43cd ff131 fs2 fc0 sc0 ls8 ws1">这个HTTP响应设置以name 为名称、以value为值的一个cookie，名称和值在传送时都必须是</div><div class="t m0 x0 h5 y43ce ff12b fs2 fc0 sc0 ls50 ws41">URL编码的。浏览器会存储这样的会话信息，并在这之后，通过为每个请求添加Cookie HTTP头将信</div><div class="t m0 x0 h5 y43cf ff131 fs2 fc0 sc0 ls8 ws1">息发送回服务器，如下所示： </div><div class="t m0 x0 hb y43d0 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y43d1 ff132 fs6 fc0 sc0 ls21 wsb">GET /index.html HTTP/1.1 </div><div class="t m0 x0 hb y43d2 ff132 fs6 fc0 sc0 ls21 wsb">Cookie: name=value </div><div class="t m0 x0 hb y43d3 ff132 fs6 fc0 sc0 ls21 wsb">Other-header: other-header-value </div><div class="t m0 x0 hb y43d4 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y43d5 ff131 fs2 fc0 sc0 ls8 ws1">发送回服务器的额外信息可以用于唯一验证客户来自于发送的哪个请求。  </div><div class="t m0 x0 h3c y43d6 ff12f fs2 fc0 sc0 ls2e wsb">1. 限制 </div><div class="t m0 x0 h5 y43d7 ff12b fs2 fc0 sc0 ls8 ws20">cookie在性质上是绑定在特定的域名下的。当设定了一个cookie后，再给创建它的域名发送请求时，</div><div class="t m0 x0 h5 y43d8 ff131 fs2 fc0 sc0 ls8 ws1">都会包含这个cookie。这个限制确保了储存在cookie中的信息只能让批准的接受者访问，而无法被其他</div><div class="t m0 x0 h5 y43d9 ff131 fs2 fc0 sc0 ls8">域访问。 </div><div class="t m0 x0 h5 y43da ff131 fs2 fc0 sc0 ls8 ws1">由于cookie是存在客户端计算机上的，还加入了一些限制确保cookie不会被恶意使用，同时不会占</div><div class="t m0 x0 h5 y43db ff131 fs2 fc0 sc0 ls8 ws1">据太多磁盘空间。每个域的cookie总数是有限的，不过浏览器之间各有不同。如下所示。 </div><div class="t m0 x0 h5 y43dc ff130 fs1 fc0 sc0 ls2"> IE6 以及更低版本限制每个域名最多20个cookie。 </div><div class="t m0 x0 h5 y2e7e ff130 fs1 fc0 sc0 ls2"> IE7和之后版本每个域名最多50个。IE7最初是支持每个域名最大20 个cookie，之后被微软的</div><div class="t m0 x5 h5 y43dd ff131 fs2 fc0 sc0 ls8 ws1">一个补丁所更新。  </div><div class="t m0 x0 h5 y43de ff130 fs1 fc0 sc0 ls2"> Firefox限制每个域最多50个cookie。 </div><div class="t m0 x0 h5 y41b3 ff130 fs1 fc0 sc0 ls2"> Opera限制每个域最多30个cookie。  </div><div class="t m0 x0 h5 y287e ff130 fs1 fc0 sc0 ls2"> Safari和Chrome对于每个域的cookie数量限制没有硬性规定。 </div><div class="t m0 x0 h5 y43df ff131 fs2 fc0 sc0 ls8 ws1">当超过单个域名限制之后还要再设置cookie，浏览器就会清除以前设置的cookie。IE和Opera会删</div><div class="t m0 x0 h5 y43e0 ff131 fs2 fc0 sc0 ls8 ws1">除最近最少使用过的（LRU，Least Recently Used）cookie，腾出空间给新设置的cookie。Firefox看上去</div><div class="t m0 x0 h5 y253e ff131 fs2 fc0 sc0 ls8 ws1">好像是随机决定要清除哪个cookie，所以考虑cookie限制非常重要，以免出现不可预期的后果。 </div><div class="t m0 x0 h5 y43e1 ff131 fs2 fc0 sc0 ls8 ws1">浏览器中对于cookie的尺寸也有限制。大多数浏览器都有大约4096B（加减1）的长度限制。为了</div><div class="t m0 x0 h5 y43e2 ff131 fs2 fc0 sc0 ls8 ws1">最佳的浏览器兼容性，最好将整个cookie长度限制在4095B（含 4095）以内。尺寸限制影响到一个域</div><div class="t m0 x0 h5 y43e3 ff131 fs2 fc0 sc0 ls8 ws1">下所有的cookie，而并非每个cookie单独限制。 </div><div class="t m0 x0 h5 y43e4 ff131 fs2 fc0 sc0 ls8 ws1">如果你尝试创建超过最大尺寸限制的cookie，那么该cookie会被悄无声息地丢掉。注意，虽然一个</div><div class="t m0 x0 h5 y43e5 ff131 fs2 fc0 sc0 ls8 ws1">字符通常占用一字节，但是多字节情况则有不同。  </div><div class="t m0 x0 h3c y43e6 ff12f fs2 fc0 sc0 ls1b ws409">2. cookie的构成 </div><div class="t m0 x0 h5 y43e7 ff12b fs2 fc0 sc0 ls8 ws20">cookie由浏览器保存的以下几块信息构成。 </div><div class="t m0 x0 h5 y1dcc ff130 fs1 fc0 sc0 ls2"> 名称：一个唯一确定cookie的名称。cookie名称是不区分大小写的，所以myCookie和MyCookie</div><div class="t m0 x5 h5 y43e8 ff131 fs2 fc0 sc0 ls8 ws1">被认为是同一个cookie。然而，实践中最好将cookie名称看作是区分大小写的，因为某些服务</div></div></div>
<div id="pf288" class="pf w0 h0" data-page-no="288"><div class="pc pc288 w0 h0"><div class="t m0 x0 h2 y1 ff12b fs0 fc0 sc0 ls7 ws0">630  第23章 离线应用与客户端存储 </div><div class="t m0 x0 h3 y2 ff12b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff131 fs2 fc0 sc0 ls8 ws1">器会这样处理cookie。cookie的名称必须是经过URL编码的。  </div><div class="t m0 x0 h5 y4 ff130 fs1 fc0 sc0 ls2"> 值：储存在cookie中的字符串值。值必须被URL编码。  </div><div class="t m0 x0 h5 y4e ff130 fs1 fc0 sc0 ls2"> 域：cookie对于哪个域是有效的。所有向该域发送的请求中都会包含这个cookie信息。这个值</div><div class="t m0 x0 h5 yd9 ff131 fs2 fc0 sc0 ls8 ws1">可以包含子域（subdomain，如www.wrox.com），也可以不包含它（如.wrox.com，则对于wrox.com</div><div class="t m0 x0 h5 y15d ff131 fs2 fc0 sc0 ls8 ws1">的所有子域都有效）。如果没有明确设定，那么这个域会被认作来自设置cookie的那个域。  </div><div class="t m0 x0 h5 y8 ff130 fs1 fc0 sc0 ls2"> 路径：对于指定域中的那个路径，应该向服务器发送cookie。例如，你可以指定cookie只有从 </div><div class="t m0 x0 h5 y9 ff132 fs1 fc0 sc0 ls9 ws2">http://www.wrox.com/books/ 中才能访问，那么http://www.wrox.com的页面就不会发</div><div class="t m0 x0 h5 y15f ff131 fs2 fc0 sc0 ls3b">送cookie信息，即使请求都是来自同一个域的。  </div><div class="t m0 x0 h5 yb ff130 fs1 fc0 sc0 ls2"> 失效时间：表示cookie何时应该被删除的时间戳（也就是，何时应该停止向服务器发送这个</div><div class="t m0 x0 h5 y78a ff12b fs2 fc0 sc0 ls8 ws20">cookie）。默认情况下，浏览器会话结束时即将所有cookie删除；不过也可以自己设置删除时间。</div><div class="t m0 x0 h5 y3048 ff131 fs2 fc0 sc0 ls24 ws1e">这个值是个GMT格式的日期（Wdy, DD-Mon-YYYY HH:MM:SS GMT），用于指定应该删除</div><div class="t m0 x0 h5 y3049 ff12b fs2 fc0 sc0 ls8 ws20">cookie的准确时间。因此，cookie可在浏览器关闭后依然保存在用户的机器上。如果你设置的失</div><div class="t m0 x0 h5 y304a ff131 fs2 fc0 sc0 ls8 ws1">效日期是个以前的时间，则cookie会被立刻删除。  </div><div class="t m0 x0 h5 y10 ff130 fs1 fc0 sc0 ls2"> 安全标志：指定后，cookie只有在使用SSL连接的时候才发送到服务器。例如，cookie 信息只</div><div class="t m0 x0 hc y1e96 ff131 fs2 fc0 sc0 ls8">能发送给 https://www.wrox.com，而http://www.wrox.com的请求则不能发送 cookie。  </div><div class="t m0 x0 hc y12 ff131 fs2 fc0 sc0 ls8 ws1">每一段信息都作为 Set-Cookie 头的一部分，使用分号加空格分隔每一段，如下例所示。 </div><div class="t m0 x0 hb y3870 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y43e9 ff132 fs6 fc0 sc0 ls21 wsb">HTTP/1.1 200 OK </div><div class="t m0 x0 hb y43ea ff132 fs6 fc0 sc0 ls21 wsb">Content-type: text/html </div><div class="t m0 x0 h15 y43eb ff139 fs6 fc0 sc0 ls21 wsb">Set-Cookie: name=value; expires=Mon, 22-Jan-07 07:10:24 GMT; domain=.wrox.com </div><div class="t m0 x0 hb y43ec ff132 fs6 fc0 sc0 ls21 wsb">Other-header: other-header-value </div><div class="t m0 x0 hb y43ed ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y43ee ff131 fs2 fc0 sc0 ls8 ws1">该头信息指定了一个叫做name的cookie，它会在格林威治时间2007年1月22日7:10:24失效，同</div><div class="t m0 x0 hc y43ef ff131 fs2 fc0 sc0 ls8">时对于 www.wrox.com 和 wrox.com 的任何子域（如 p2p.wrox.com）都有效。 </div><div class="t m0 x0 h5 y90c ff132 fs1 fc0 sc0 ls9 ws2">secure标志是cookie中唯一一个非名值对儿的部分，直接包含一个secure 单词。如下：  </div><div class="t m0 x0 hb y3309 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y43f0 ff132 fs6 fc0 sc0 ls21 wsb">HTTP/1.1 200 OK </div><div class="t m0 x0 hb y43f1 ff132 fs6 fc0 sc0 ls21 wsb">Content-type: text/html </div><div class="t m0 x0 h15 y43f2 ff139 fs6 fc0 sc0 ls21 wsb">Set-Cookie: name=value; domain=.wrox.com; path=/; secure </div><div class="t m0 x0 hb y43f3 ff132 fs6 fc0 sc0 ls21 wsb">Other-header: other-header-value </div><div class="t m0 x0 hb y43f4 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y43f5 ff131 fs2 fc0 sc0 ls8 ws1">这里，创建了一个对于所有wrox.com的子域和域名下（由path参数指定的）所有页面都有效的</div><div class="t m0 x0 h5 y43f6 ff12b fs2 fc0 sc0 ls8 ws20">cookie。因为设置了secure标志，这个cookie只能通过SSL 连接才能传输。 </div><div class="t m0 x0 h1e y43f7 ff131 fs2 fc0 sc0 ls8 ws1">尤其要注意，域、路径、失效时间和secure标志都是服务器给浏览器的指示，以指定何时应该发</div><div class="t m0 x0 h5 y43f8 ff131 fs2 fc0 sc0 ls3b">送cookie。这些参数并不会作为发送到服务器的cookie信息的一部分，只有名值对儿才会被发送。  </div><div class="t m0 x0 h3c y43f9 ff12f fs2 fc0 sc0 ls79 ws7e">3. JavaScript中的cookie  </div><div class="t m0 x0 h5 y43fa ff131 fs2 fc0 sc0 ls481">在JavaScript中处理cookie有些复杂，因为其众所周知的蹩脚的接口，即BOM的document. cookie</div><div class="t m0 x0 h4 y20a1 ff131 fs2 fc0 sc0 ls8 ws1">属性。这个属性的独特之处在于它会因为使用它的方式不同而表现出不同的行为。当用来获取属性值时，</div><div class="t m0 x0 h5 y1a2 ff132 fs1 fc0 sc0 ls9 ws2">document.cookie返回当前页面可用的（根据cookie的域、路径、失效时间和安全设置）所有cookie</div><div class="t m0 x0 h5 y1a3 ff131 fs2 fc0 sc0 ls8 ws1">的字符串，一系列由分号隔开的名值对儿，如下例所示。 </div><div class="t m0 x0 hb ye0f ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y43fb ff132 fs6 fc0 sc0 ls21 wsb">name1=value1;name2=value2;name3=value3 </div><div class="t m0 x0 hb y43fc ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y43fd ff131 fs2 fc0 sc0 ls8 ws1">所有名字和值都是经过URL编码的，所以必须使用decodeURIComponent()来解码。 </div><div class="t m0 x0 hc y43fe ff131 fs2 fc0 sc0 ls8 ws1">当用于设置值的时候，document.cookie属性可以设置为一个新的cookie字符串。这个cookie字</div><div class="t m0 x0 hc y43ff ff131 fs2 fc0 sc0 ls8 ws1">符串会被解释并添加到现有的cookie集合中。设置document.cookie并不会覆盖cookie，除非设置的</div></div></div>
<div id="pf289" class="pf w0 h0" data-page-no="289"><div class="pc pc289 w0 h0"><div class="t m0 x2 h2 y1 ff12b fs0 fc0 sc0 ls7 ws0">23.3 数据存储    631 </div><div class="t m0 x0 h3 y2 ff12b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff137 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff137 fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ff137 fs3 fc2 sc0 ls1d wsb">16 </div><div class="t m0 x3 h8 y20 ff137 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff137 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff137 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff137 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff137 fs3 fc2 sc0 ls1d wsb">20 </div><div class="t m0 x3 h8 y25 ff137 fs3 fc2 sc0 ls1d wsb">21 </div><div class="t m0 x3 h8 y26 ff137 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff137 fs3 fc2 sc0 ls1d wsf">23 </div><div class="t m0 x3 h8 ya7a ff137 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff137 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff12b fs2 fc0 sc0 ls8 ws20">cookie的名称已经存在。设置cookie的格式如下，和Set-Cookie头中使用的格式一样。 </div><div class="t m0 x0 hb yfb2 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yfb3 ff132 fs6 fc0 sc0 ls21 wsb">name=value; expires=expiration_time; path=domain_path; domain=domain_name; secure </div><div class="t m0 x0 hb y1510 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1511 ff131 fs2 fc0 sc0 ls8 ws1">这些参数中，只有cookie的名字和值是必需的。下面是一个简单的例子。 </div><div class="t m0 x0 hb y4400 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4401 ff132 fs6 fc0 sc0 ls21 wsb">document.cookie = &quot;name=Nicholas&quot;; </div><div class="t m0 x0 hb y4402 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y4403 ff131 fs2 fc0 sc0 ls8 ws1">这段代码创建了一个叫name的cookie，值为Nicholas。当客户端每次向服务器端发送请求的时</div><div class="t m0 x0 h5 y4404 ff131 fs2 fc0 sc0 ls8 ws1">候，都会发送这个cookie；当浏览器关闭的时候，它就会被删除。虽然这段代码没问题，但因为这里正</div><div class="t m0 x0 h5 y4405 ff131 fs2 fc0 sc0 ls4c ws3e">好名称和值都无需编码，所以最好每次设置cookie时都像下面这个例子中一样使用 encodeURI- </div><div class="t m0 x0 h5 y292 ff132 fs1 fc0 sc0 ls9 ws2">Component()。 </div><div class="t m0 x0 hb y4406 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4407 ff132 fs6 fc0 sc0 ls21 wsb">document.cookie = encodeURIComponent(&quot;name&quot;) + &quot;=&quot; + </div><div class="t m0 x0 hb y4408 ff132 fs6 fc0 sc0 ls21 wsb">                  encodeURIComponent(&quot;Nicholas&quot;);  </div><div class="t m0 x0 hb y4409 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y440a ff131 fs2 fc0 sc0 ls8 ws1">要给被创建的cookie指定额外的信息，只要将参数追加到该字符串，和Set-Cookie 头中的格式</div><div class="t m0 x0 h5 y440b ff131 fs2 fc0 sc0 ls8 ws1">一样，如下所示。 </div><div class="t m0 x0 hb y21 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y440c ff132 fs6 fc0 sc0 ls21 wsb">document.cookie = encodeURIComponent(&quot;name&quot;) + &quot;=&quot; + </div><div class="t m0 x0 h15 y440d ff139 fs6 fc0 sc0 ls21 wsb">                   encodeURIComponent(&quot;Nicholas&quot;) + &quot;; domain=.wrox.com; path=/&quot;; </div><div class="t m0 x0 hb y440e ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y440f ff131 fs2 fc0 sc0 ls8 ws1">由于JavaScript中读写cookie 不是非常直观，常常需要写一些函数来简化cookie的功能。基本的</div><div class="t m0 x0 hc y1fc7 ff12b fs2 fc0 sc0 ls8 ws20">cookie操作有三种：读取、写入和删除。它们在CookieUtil对象中如下表示。 </div><div class="t m0 x0 hb y2048 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4410 ff132 fs6 fc0 sc0 ls21 wsb">var CookieUtil = { </div><div class="t m0 x0 hb y4411 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4412 ff132 fs6 fc0 sc0 ls21 wsb">    get: function (name){ </div><div class="t m0 x0 hb y4413 ff132 fs6 fc0 sc0 ls21 wsb">        var cookieName = encodeURIComponent(name) + &quot;=&quot;, </div><div class="t m0 x0 hb y4414 ff132 fs6 fc0 sc0 ls21 wsb">            cookieStart = document.cookie.indexOf(cookieName), </div><div class="t m0 x0 hb y4415 ff132 fs6 fc0 sc0 ls21 wsb">            cookieValue = null; </div><div class="t m0 x0 hb y4416 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4417 ff132 fs6 fc0 sc0 ls21 wsb">        if (cookieStart &gt; -1){ </div><div class="t m0 x0 hb y4418 ff132 fs6 fc0 sc0 ls21 wsb">            var cookieEnd = document.cookie.indexOf(&quot;;&quot;, cookieStart); </div><div class="t m0 x0 hb y4419 ff132 fs6 fc0 sc0 ls21 wsb">            if (cookieEnd == -1){ </div><div class="t m0 x0 hb y441a ff132 fs6 fc0 sc0 ls21 wsb">                cookieEnd = document.cookie.length; </div><div class="t m0 x0 hb y441b ff132 fs6 fc0 sc0 ls21 wsb">            } </div><div class="t m0 x0 hb y441c ff132 fs6 fc0 sc0 ls21 wsb">            cookieValue = decodeURIComponent(document.cookie.substring(cookieStart </div><div class="t m0 x0 hb y441d ff132 fs6 fc0 sc0 ls21 wsb">                          + cookieName.length, cookieEnd)); </div><div class="t m0 x5 hb y441e ff132 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x5 hb y441f ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4420 ff132 fs6 fc0 sc0 ls21 wsb">        return cookieValue; </div><div class="t m0 x0 hb y4421 ff132 fs6 fc0 sc0 ls21 wsb">    }, </div><div class="t m0 x0 hb y4422 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4423 ff132 fs6 fc0 sc0 ls21 wsb">    set: function (name, value, expires, path, domain, secure) { </div><div class="t m0 x0 hb y4424 ff132 fs6 fc0 sc0 ls21 wsb">        var cookieText = encodeURIComponent(name) + &quot;=&quot; + </div><div class="t m0 x0 hb y4425 ff132 fs6 fc0 sc0 ls21 wsb">                         encodeURIComponent(value); </div><div class="t m0 x0 hb y4426 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4427 ff132 fs6 fc0 sc0 ls21 wsb">        if (expires instanceof Date) { </div><div class="t m0 x0 hb y4428 ff132 fs6 fc0 sc0 ls21 wsb">            cookieText += &quot;; expires=&quot; + expires.toGMTString(); </div><div class="t m0 x0 hb y4429 ff132 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y442a ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y442b ff132 fs6 fc0 sc0 ls21 wsb">        if (path) { </div><div class="t m0 x0 hb y442c ff132 fs6 fc0 sc0 ls21 wsb">            cookieText += &quot;; path=&quot; + path; </div><div class="t m0 x0 hb y442d ff132 fs6 fc0 sc0 ls21 wsb">        }   </div><div class="t m0 x0 hb y442e ff132 fs6 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf28a" class="pf w0 h0" data-page-no="28a"><div class="pc pc28a w0 h0"><div class="t m0 x0 h2 y1 ff12b fs0 fc0 sc0 ls7 ws0">632  第23章 离线应用与客户端存储 </div><div class="t m0 x0 h3 y2 ff12b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 ff132 fs6 fc0 sc0 ls21 wsb">        if (domain) { </div><div class="t m0 x0 hb y7a ff132 fs6 fc0 sc0 ls21 wsb">            cookieText += &quot;; domain=&quot; + domain; </div><div class="t m0 x0 hb y7b ff132 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y7c ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y7d ff132 fs6 fc0 sc0 ls21 wsb">        if (secure) { </div><div class="t m0 x0 hb y7e ff132 fs6 fc0 sc0 ls21 wsb">            cookieText += &quot;; secure&quot;; </div><div class="t m0 x0 hb y7f ff132 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y80 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y81 ff132 fs6 fc0 sc0 ls21 wsb">        document.cookie = cookieText; </div><div class="t m0 x0 hb y82 ff132 fs6 fc0 sc0 ls21 wsb">    }, </div><div class="t m0 x0 hb y83 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y84 ff132 fs6 fc0 sc0 ls21 wsb">    unset: function (name, path, domain, secure){ </div><div class="t m0 x0 hb y85 ff132 fs6 fc0 sc0 ls21 wsb">        this.set(name, &quot;&quot;, new Date(0), path, domain, secure); </div><div class="t m0 x0 hb y86 ff132 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y87 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y88 ff132 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y383 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1b34 ff138 fs2 fc0 sc0 ls5e wsb">CookieUtil.js </div><div class="t m0 x0 h5 y1b35 ff132 fs1 fc0 sc0 ls9 ws2">CookieUtil.get()方法根据cookie的名字获取相应的值。它会在document.cookie字符串中查</div><div class="t m0 x0 h5 y30c8 ff131 fs2 fc0 sc0 lsdc">找cookie名加上等于号的位置。如果找到了，那么使用indexOf()查找该位置之后的第一个分号（表</div><div class="t m0 x0 h5 yb53 ff131 fs2 fc0 sc0 ls8 ws1">示了该cookie的结束位置）。如果没有找到分号，则表示该cookie是字符串中的最后一个，则余下的字</div><div class="t m0 x0 hc yb54 ff131 fs2 fc0 sc0 ls8 ws1">符串都是cookie的值。该值使用decodeURIComponent()进行解码并最后返回。如果没有发现cookie，</div><div class="t m0 x0 hc y4430 ff131 fs2 fc0 sc0 ls8 ws1">则返回null。 </div><div class="t m0 x0 h5 y2d46 ff132 fs1 fc0 sc0 ls43 ws31">CookieUtil.set()方法在页面上设置一个cookie，接收如下几个参数：cookie的名称，cookie的值，</div><div class="t m0 x0 h5 yb57 ff131 fs2 fc0 sc0 ls42 ws30">可选的用于指定cookie何时应被删除的Date对象，cookie的可选的 URL路径，可选的域，以及可选的</div><div class="t m0 x0 h1e y4431 ff131 fs2 fc0 sc0 ls42 ws30">表示是否要添加secure标志的布尔值。参数是按照它们的使用频率排列的，只有头两个是必需的。在</div><div class="t m0 x0 hc y4432 ff131 fs2 fc0 sc0 ls42 ws30">这个方法中，名称和值都使用encodeURIComponent()进行了URL编码，并检查其他选项。如果expires</div><div class="t m0 x0 h4 y4433 ff131 fs2 fc0 sc0 ls44 ws32">参数是Date对象，那么会使用Date 对象的toGMTString()方法正确格式化Date对象，并添加到</div><div class="t m0 x0 h5 y3a63 ff132 fs1 fc0 sc0 ls43 ws31">expires选项上。方法的其他部分就是构造cookie字符串并将其设置到document.cookie中。 </div><div class="t m0 x0 h5 y4434 ff131 fs2 fc0 sc0 ls8 ws1">没有删除已有cookie的直接方法。所以，需要使用相同的路径、域和安全选项再次设置cookie，并</div><div class="t m0 x0 he y4435 ff131 fs2 fc0 sc0 ls8 ws1">将失效时间设置为过去的时间。CookieUtil.unset()方法可以处理这种事情。它接收4个参数：要删</div><div class="t m0 x0 h5 y4436 ff131 fs2 fc0 sc0 ls8 ws1">除的cookie的名称、可选的路径参数、可选的域参数和可选的安全参数。 </div><div class="t m0 x0 h5 y4437 ff131 fs2 fc0 sc0 ls8 ws1">这些参数加上空字符串并设置失效时间为1970年1月1日（初始化为0ms的Date对象的值），传</div><div class="t m0 x0 hc y4438 ff131 fs2 fc0 sc0 ls184">给CookieUtil.set()。这样就能确保删除cookie。 </div><div class="t m0 x0 h5 y4439 ff131 fs2 fc0 sc0 ls8 ws1">可以像下面这样使用上述方法。 </div><div class="t m0 x0 hb y282 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y443a ff132 fs6 fc0 sc0 ls21">//设置cookie </div><div class="t m0 x0 hb y443b ff132 fs6 fc0 sc0 ls21 wsb">CookieUtil.set(&quot;name&quot;, &quot;Nicholas&quot;); </div><div class="t m0 x0 hb y443c ff132 fs6 fc0 sc0 ls21 wsb">CookieUtil.set(&quot;book&quot;, &quot;Professional JavaScript&quot;); </div><div class="t m0 x0 hb y443d ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y443e ff132 fs6 fc0 sc0 ls21">//读取cookie的值 </div><div class="t m0 x0 hb y443f ff132 fs6 fc0 sc0 ls21 wsb">alert(CookieUtil.get(&quot;name&quot;)); //&quot;Nicholas&quot; </div><div class="t m0 x0 hb y4440 ff132 fs6 fc0 sc0 ls21 wsb">alert(CookieUtil.get(&quot;book&quot;)); //&quot;Professional JavaScript&quot; </div><div class="t m0 x0 hb y4441 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4442 ff132 fs6 fc0 sc0 ls21">//删除cookie </div><div class="t m0 x0 hb y4443 ff132 fs6 fc0 sc0 ls21 wsb">CookieUtil.unset(&quot;name&quot;); </div><div class="t m0 x0 hb y4444 ff132 fs6 fc0 sc0 ls21 wsb">CookieUtil.unset(&quot;book&quot;); </div><div class="t m0 x0 hb y4445 ff132 fs6 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf28b" class="pf w0 h0" data-page-no="28b"><div class="pc pc28b w0 h0"><div class="t m0 x2 h2 y1 ff12b fs0 fc0 sc0 ls7 ws0">23.3 数据存储    633 </div><div class="t m0 x0 h3 y2 ff12b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff137 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff137 fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ff137 fs3 fc2 sc0 ls1d wsb">16 </div><div class="t m0 x3 h8 y20 ff137 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff137 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff137 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff137 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff137 fs3 fc2 sc0 ls1d wsb">20 </div><div class="t m0 x3 h8 y25 ff137 fs3 fc2 sc0 ls1d wsb">21 </div><div class="t m0 x3 h8 y26 ff137 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff137 fs3 fc2 sc0 ls1d wsf">23 </div><div class="t m0 x3 h8 ya7a ff137 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff137 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h16 y8f5 ff132 fs6 fc0 sc0 ls21">//设置cookie，包括它的路径、域、失效日期 </div><div class="t m0 x0 hb y4446 ff132 fs6 fc0 sc0 ls21 wsb">CookieUtil.set(&quot;name&quot;, &quot;Nicholas&quot;, &quot;/books/projs/&quot;, &quot;www.wrox.com&quot;,  </div><div class="t m0 x0 hb y4447 ff132 fs6 fc0 sc0 ls21 wsb">               new Date(&quot;January 1, 2010&quot;)); </div><div class="t m0 x0 hb y4448 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4449 ff132 fs6 fc0 sc0 ls21">//删除刚刚设置的cookie </div><div class="t m0 x0 hb y444a ff132 fs6 fc0 sc0 ls21 wsb">CookieUtil.unset(&quot;name&quot;, &quot;/books/projs/&quot;, &quot;www.wrox.com&quot;); </div><div class="t m0 x0 hb y444b ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y444c ff132 fs6 fc0 sc0 ls21">//设置安全的cookie </div><div class="t m0 x0 hb y444d ff132 fs6 fc0 sc0 ls21 wsb">CookieUtil.set(&quot;name&quot;, &quot;Nicholas&quot;, null, null, null, true); </div><div class="t m0 x0 hb y444e ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y444f ff138 fs2 fc0 sc0 ls25 wsb">CookieExample01.htm </div><div class="t m0 x0 h5 y4450 ff131 fs2 fc0 sc0 ls8 ws1">这些方法通过处理解析、构造cookie字符串的任务令在客户端利用cookie存储数据更加简单。 </div><div class="t m0 x0 h3c y4451 ff12f fs2 fc0 sc0 ls2e wsb">4. 子cookie  </div><div class="t m0 x0 h5 y4452 ff131 fs2 fc0 sc0 ls8 ws1">为了绕开浏览器的单域名下的cookie数限制，一些开发人员使用了一种称为子cookie（subcookie）</div><div class="t m0 x0 h5 y4453 ff131 fs2 fc0 sc0 ls8 ws1">的概念。子cookie是存放在单个cookie中的更小段的数据。也就是使用 cookie值来存储多个名称值对</div><div class="t m0 x0 h5 y4454 ff131 fs2 fc0 sc0 ls8 ws1">儿。子cookie最常见的的格式如下所示。 </div><div class="t m0 x0 hb y4455 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4456 ff132 fs6 fc0 sc0 ls21 wsb">name=name1=value1&amp;name2=value2&amp;name3=value3&amp;name4=value4&amp;name5=value5 </div><div class="t m0 x0 hb y4457 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y4458 ff131 fs2 fc0 sc0 ls2fc">子cookie一般也以查询字符串的格式进行格式化。然后这些值可以使用单个cookie进行存储和访</div><div class="t m0 x0 h25 ya48 ff131 fs2 fc0 sc0 ls8 ws1">问，而非对每个名称值对儿使用不同的cookie存储。最后网站或者Web应用程序可以无需达到单域名</div><div class="t m0 x0 h5 ya49 ff12b fs2 fc0 sc0 ls8 ws20">cookie上限也可以存储更加结构化的数据。 </div><div class="t m0 x0 h5 y4459 ff131 fs2 fc0 sc0 ls8 ws1">为了更好地操作子cookie，必须建立一系列新方法。子cookie的解析和序列化会因子cookie的期望</div><div class="t m0 x0 h5 y445a ff131 fs2 fc0 sc0 ls8 ws1">用途而略有不同并更加复杂些。例如，要获得一个子cookie，首先要遵循与获得cookie一样的基本步骤，</div><div class="t m0 x0 h5 y445b ff131 fs2 fc0 sc0 ls8 ws1">但是在解码cookie值之前，需要按如下方法找出子cookie的信息。 </div><div class="t m0 x0 hb y2f1 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y445c ff132 fs6 fc0 sc0 ls21 wsb">var SubCookieUtil = { </div><div class="t m0 x0 hb y445d ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y445e ff132 fs6 fc0 sc0 ls21 wsb">    get: function (name, subName){ </div><div class="t m0 x0 hb y445f ff132 fs6 fc0 sc0 ls21 wsb">        var subCookies = this.getAll(name); </div><div class="t m0 x0 hb y4460 ff132 fs6 fc0 sc0 ls21 wsb">        if (subCookies){ </div><div class="t m0 x0 hb y4461 ff132 fs6 fc0 sc0 ls21 wsb">            return subCookies[subName]; </div><div class="t m0 x0 hb y4462 ff132 fs6 fc0 sc0 ls21 wsb">        } else { </div><div class="t m0 x0 hb y4463 ff132 fs6 fc0 sc0 ls21 wsb">            return null; </div><div class="t m0 x0 hb y4464 ff132 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y4465 ff132 fs6 fc0 sc0 ls21 wsb">    }, </div><div class="t m0 x0 hb y4466 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4467 ff132 fs6 fc0 sc0 ls21 wsb">    getAll: function(name){ </div><div class="t m0 x0 hb y4468 ff132 fs6 fc0 sc0 ls21 wsb">        var cookieName = encodeURIComponent(name) + &quot;=&quot;, </div><div class="t m0 x0 hb y4469 ff132 fs6 fc0 sc0 ls21 wsb">            cookieStart = document.cookie.indexOf(cookieName), </div><div class="t m0 x0 hb y446a ff132 fs6 fc0 sc0 ls21 wsb">            cookieValue = null, </div><div class="t m0 x0 hb y446b ff132 fs6 fc0 sc0 ls21 wsb">            cookieEnd, </div><div class="t m0 x0 hb y446c ff132 fs6 fc0 sc0 ls21 wsb">            subCookies, </div><div class="t m0 x0 hb y446d ff132 fs6 fc0 sc0 ls21 wsb">            i,       </div><div class="t m0 x0 hb y446e ff132 fs6 fc0 sc0 ls21 wsb">            parts, </div><div class="t m0 x0 hb y446f ff132 fs6 fc0 sc0 ls21 wsb">            result = {}; </div><div class="t m0 x0 hb y4470 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4471 ff132 fs6 fc0 sc0 ls21 wsb">        if (cookieStart &gt; -1){ </div><div class="t m0 x0 hb y4472 ff132 fs6 fc0 sc0 ls21 wsb">            cookieEnd = document.cookie.indexOf(&quot;;&quot;, cookieStart); </div><div class="t m0 x0 hb y4473 ff132 fs6 fc0 sc0 ls21 wsb">            if (cookieEnd == -1){ </div><div class="t m0 x0 hb y4474 ff132 fs6 fc0 sc0 ls21 wsb">                cookieEnd = document.cookie.length; </div><div class="t m0 x0 hb y4475 ff132 fs6 fc0 sc0 ls21 wsb">            } </div><div class="t m0 x0 hb y4476 ff132 fs6 fc0 sc0 ls21 wsb">            cookieValue = document.cookie.substring(cookieStart + </div></div></div>
<div id="pf28c" class="pf w0 h0" data-page-no="28c"><div class="pc pc28c w0 h0"><div class="t m0 x0 h2 y1 ff12b fs0 fc0 sc0 ls7 ws0">634  第23章 离线应用与客户端存储 </div><div class="t m0 x0 h3 y2 ff12b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 ff132 fs6 fc0 sc0 ls21 wsb">                          cookieName.length, cookieEnd); </div><div class="t m0 x0 hb y7a ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y7b ff132 fs6 fc0 sc0 ls21 wsb">            if (cookieValue.length &gt; 0){ </div><div class="t m0 x0 hb y7c ff132 fs6 fc0 sc0 ls21 wsb">                subCookies = cookieValue.split(&quot;&amp;&quot;); </div><div class="t m0 x0 hb y7d ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y7e ff132 fs6 fc0 sc0 ls21 wsb">                for (i=0, len=subCookies.length; i &lt; len; i++){ </div><div class="t m0 x0 hb y7f ff132 fs6 fc0 sc0 ls21 wsb">                    parts = subCookies[i].split(&quot;=&quot;); </div><div class="t m0 x0 hb y80 ff132 fs6 fc0 sc0 ls21 wsb">                    result[decodeURIComponent(parts[0])] = </div><div class="t m0 x0 hb y81 ff132 fs6 fc0 sc0 ls21 wsb">                         decodeURIComponent(parts[1]); </div><div class="t m0 x0 hb y82 ff132 fs6 fc0 sc0 ls21 wsb">                } </div><div class="t m0 x0 hb y83 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y84 ff132 fs6 fc0 sc0 ls21 wsb">                return result; </div><div class="t m0 x0 hb y85 ff132 fs6 fc0 sc0 ls21 wsb">            } </div><div class="t m0 x0 hb y86 ff132 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y87 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y88 ff132 fs6 fc0 sc0 ls21 wsb">        return null; </div><div class="t m0 x0 hb y89 ff132 fs6 fc0 sc0 ls21 wsb">    }, </div><div class="t m0 x0 hb y8a ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1823 ff132 fs6 fc0 sc0 ls21 wsb">    //省略了更多代码 </div><div class="t m0 x0 hb y1824 ff132 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y3db0 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y27fd ff138 fs2 fc0 sc0 ls25 wsb">SubCookieUtil.js </div><div class="t m0 x0 h5 y27fe ff131 fs2 fc0 sc0 ls8 ws1">获取子cookie的方法有两个：get()和getAll()。其中get()获取单个子cookie的值，getAll()</div><div class="t m0 x0 h5 y4477 ff131 fs2 fc0 sc0 ls8 ws1">获取所有子cookie并将它们放入一个对象中返回，对象的属性为子cookie 的名称，对应值为子cookie</div><div class="t m0 x0 hc y4478 ff131 fs2 fc0 sc0 ls8 ws1">对应的值。get()方法接收两个参数：cookie的名字和子cookie的名字。它其实就是调用getAll()获</div><div class="t m0 x0 hc y4479 ff131 fs2 fc0 sc0 ls8 ws1">取所有的子cookie，然后只返回所需的那一个（如果cookie不存在则返回null）。 </div><div class="t m0 x0 h5 y793 ff132 fs1 fc0 sc0 ls9 ws2">SubCookieUtil.getAll()方法和CookieUtil.get()在解析cookie值的方式上非常相似。区别</div><div class="t m0 x0 hc yb2a ff131 fs2 fc0 sc0 ls8 ws1">在于cookie的值并非立即解码，而是先根据&amp;字符将子cookie分割出来放在一个数组中，每一个子cookie</div><div class="t m0 x0 hc y795 ff131 fs2 fc0 sc0 ls8 ws1">再根据等于号分割，这样在parts数组中的前一部分便是子cookie名，后一部分则是子 cookie的值。</div><div class="t m0 x0 h1e y447a ff131 fs2 fc0 sc0 ls8 ws1">这两个项目都要使用decodeURIComponent()来解码，然后放入result对象中，最后作为方法的返</div><div class="t m0 x0 hc yc23 ff131 fs2 fc0 sc0 ls8 ws1">回值。如果cookie不存在，则返回null。 </div><div class="t m0 x0 h5 y447b ff131 fs2 fc0 sc0 ls8 ws1">可以像下面这样使用上述方法： </div><div class="t m0 x0 hb y35d1 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y447c ff132 fs6 fc0 sc0 ls21">//假设document.cookie=data=name=Nicholas&amp;book=Professional%20JavaScript </div><div class="t m0 x0 hb y447d ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y447e ff132 fs6 fc0 sc0 ls21">//取得全部子cookie </div><div class="t m0 x0 hb y447f ff132 fs6 fc0 sc0 ls21 wsb">var data = SubCookieUtil.getAll(&quot;data&quot;); </div><div class="t m0 x0 hb y4480 ff132 fs6 fc0 sc0 ls21 wsb">alert(data.name);  //&quot;Nicholas&quot; </div><div class="t m0 x0 hb y4481 ff132 fs6 fc0 sc0 ls21 wsb">alert(data.book);  //&quot;Professional JavaScript&quot; </div><div class="t m0 x0 hb y4482 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4483 ff132 fs6 fc0 sc0 ls21">//逐个获取子cookie </div><div class="t m0 x0 hb y4484 ff132 fs6 fc0 sc0 ls21 wsb">alert(SubCookieUtil.get(&quot;data&quot;, &quot;name&quot;)); //&quot;Nicholas&quot; </div><div class="t m0 x0 hb y4485 ff132 fs6 fc0 sc0 ls21 wsb">alert(SubCookieUtil.get(&quot;data&quot;, &quot;book&quot;)); //&quot;Professional JavaScript&quot; </div><div class="t m0 x0 hb y4486 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y7a3 ff138 fs2 fc0 sc0 ls25 wsb">SubCookiesExample01.htm </div><div class="t m0 x0 h5 y4487 ff131 fs2 fc0 sc0 ls8 ws1">要设置子cookie，也有两种方法：set()和setAll()。以下代码展示了它们的构造。 </div><div class="t m0 x0 hb y3538 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4488 ff132 fs6 fc0 sc0 ls21 wsb">var SubCookieUtil = {  </div><div class="t m0 x0 hb y4489 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y448a ff139 fs6 fc0 sc0 ls21 wsb">    set: function (name, subName, value, expires, path, domain, secure) { </div><div class="t m0 x0 h15 y448b ff139 fs6 fc0 sc0 ls21 wsb">        var subcookies = this.getAll(name) || {}; </div></div></div>
<div id="pf28d" class="pf w0 h0" data-page-no="28d"><div class="pc pc28d w0 h0"><div class="t m0 x2 h2 y1 ff12b fs0 fc0 sc0 ls7 ws0">23.3 数据存储    635 </div><div class="t m0 x0 h3 y2 ff12b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff137 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff137 fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ff137 fs3 fc2 sc0 ls1d wsb">16 </div><div class="t m0 x3 h8 y20 ff137 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff137 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff137 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff137 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff137 fs3 fc2 sc0 ls1d wsb">20 </div><div class="t m0 x3 h8 y25 ff137 fs3 fc2 sc0 ls1d wsb">21 </div><div class="t m0 x3 h8 y26 ff137 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff137 fs3 fc2 sc0 ls1d wsf">23 </div><div class="t m0 x3 h8 ya7a ff137 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff137 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h15 y8f5 ff139 fs6 fc0 sc0 ls21 wsb">        subcookies[subName] = value; </div><div class="t m0 x0 h15 y8f6 ff139 fs6 fc0 sc0 ls21 wsb">        this.setAll(name, subcookies, expires, path, domain, secure); </div><div class="t m0 x0 h15 y8f7 ff139 fs6 fc0 sc0 ls21 wsb">    }, </div><div class="t m0 x0 h15 y8f8 ff139 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y8f9 ff139 fs6 fc0 sc0 ls21 wsb">    setAll: function(name, subcookies, expires, path, domain, secure){ </div><div class="t m0 x0 h15 y8fa ff139 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y8fb ff139 fs6 fc0 sc0 ls21 wsb">        var cookieText = encodeURIComponent(name) + &quot;=&quot;, </div><div class="t m0 x0 h15 y8fc ff139 fs6 fc0 sc0 ls21 wsb">            subcookieParts = new Array(), </div><div class="t m0 x0 h15 y8fd ff139 fs6 fc0 sc0 ls21 wsb">            subName; </div><div class="t m0 x0 h15 y1037 ff139 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y1038 ff139 fs6 fc0 sc0 ls21 wsb">        for (subName in subcookies){ </div><div class="t m0 x0 h15 y1039 ff139 fs6 fc0 sc0 ls21 wsb">            if (subName.length &gt; 0 &amp;&amp; subcookies.hasOwnProperty(subName)){ </div><div class="t m0 x0 h15 y16a9 ff139 fs6 fc0 sc0 ls21 wsb">                subcookieParts.push(encodeURIComponent(subName) + &quot;=&quot; + </div><div class="t m0 x0 h15 y16aa ff139 fs6 fc0 sc0 ls21 wsb">                    encodeURIComponent(subcookies[subName])); </div><div class="t m0 x0 h15 y16ab ff139 fs6 fc0 sc0 ls21 wsb">            } </div><div class="t m0 x0 h15 y16ac ff139 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 h15 y16ad ff139 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y16ae ff139 fs6 fc0 sc0 ls21 wsb">        if (cookieParts.length &gt; 0){ </div><div class="t m0 x0 h15 y16af ff139 fs6 fc0 sc0 ls21 wsb">            cookieText += subcookieParts.join(&quot;&amp;&quot;); </div><div class="t m0 x0 h15 y16b0 ff139 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y16b1 ff139 fs6 fc0 sc0 ls21 wsb">            if (expires instanceof Date) { </div><div class="t m0 x0 h15 y16b2 ff139 fs6 fc0 sc0 ls21 wsb">                cookieText += &quot;; expires=&quot; + expires.toGMTString(); </div><div class="t m0 x0 h15 y16b3 ff139 fs6 fc0 sc0 ls21 wsb">            } </div><div class="t m0 x0 h15 y16b4 ff139 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y16b5 ff139 fs6 fc0 sc0 ls21 wsb">            if (path) { </div><div class="t m0 x0 h15 y16b6 ff139 fs6 fc0 sc0 ls21 wsb">                cookieText += &quot;; path=&quot; + path; </div><div class="t m0 x0 h15 y16b7 ff139 fs6 fc0 sc0 ls21 wsb">            } </div><div class="t m0 x0 h15 y16b8 ff139 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y448c ff139 fs6 fc0 sc0 ls21 wsb">            if (domain) { </div><div class="t m0 x0 h15 y448d ff139 fs6 fc0 sc0 ls21 wsb">               cookieText += &quot;; domain=&quot; + domain; </div><div class="t m0 x0 h15 y448e ff139 fs6 fc0 sc0 ls21 wsb">            } </div><div class="t m0 x0 h15 y448f ff139 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y4490 ff139 fs6 fc0 sc0 ls21 wsb">            if (secure) { </div><div class="t m0 x0 h15 y4491 ff139 fs6 fc0 sc0 ls21 wsb">               cookieText += &quot;; secure&quot;; </div><div class="t m0 x0 h15 y4492 ff139 fs6 fc0 sc0 ls21 wsb">            } </div><div class="t m0 x0 h15 y4493 ff139 fs6 fc0 sc0 ls21 wsb">        } else { </div><div class="t m0 x0 h15 y4494 ff139 fs6 fc0 sc0 ls21 wsb">            cookieText += &quot;; expires=&quot; + (new Date(0)).toGMTString(); </div><div class="t m0 x0 h15 y4495 ff139 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 h15 y4496 ff139 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y4497 ff139 fs6 fc0 sc0 ls21 wsb">        document.cookie = cookieText; </div><div class="t m0 x0 h15 y4498 ff139 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y4499 ff139 fs6 fc0 sc0 ls21 wsb">    }, </div><div class="t m0 x0 hb y449a ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y449b ff132 fs6 fc0 sc0 ls21 wsb">    //省略了更多代码 </div><div class="t m0 x0 hb y449c ff132 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y449d ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y449e ff138 fs2 fc0 sc0 ls25 wsb">SubCookieUtil.js </div><div class="t m0 x0 h5 ya2 ff131 fs2 fc0 sc0 ls8 ws1">这里的set()方法接收7个参数：cookie名称、子cookie 名称、子cookie值、可选的cookie失效</div><div class="t m0 x0 hc y449f ff131 fs2 fc0 sc0 ls8 ws1">日期或时间的Date对象、可选的cookie路径、可选的cookie 域和可选的布尔secure标志。所有的可</div><div class="t m0 x0 h5 y44a0 ff131 fs2 fc0 sc0 ls8 ws1">选参数都是作用于cookie本身而非子cookie。为了在同一个cookie中存储多个子cookie，路径、域和secure</div><div class="t m0 x0 h5 y44a1 ff131 fs2 fc0 sc0 ls8 ws1">标志必须一致；针对整个cookie的失效日期则可以在任何一个单独的子cookie写入的时候同时设置。在</div><div class="t m0 x0 h5 y44a2 ff131 fs2 fc0 sc0 ls8 ws1">这个方法中，第一步是获取指定cookie名称对应的所有子cookie。逻辑或操作符“||”用于当getAll()</div></div></div>
<div id="pf28e" class="pf w0 h0" data-page-no="28e"><div class="pc pc28e w0 h0"><div class="t m0 x0 h2 y1 ff12b fs0 fc0 sc0 ls7 ws0">636  第23章 离线应用与客户端存储 </div><div class="t m0 x0 h3 y2 ff12b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff131 fs2 fc0 sc0 ls8 ws1">返回null时将subcookies 设置为一个新对象。然后，在subcookies对象上设置好子cookie值并传给</div><div class="t m0 x0 h5 y4 ff132 fs1 fc0 sc0 ls9 ws2">setAll()。 </div><div class="t m0 x0 hc y5 ff131 fs2 fc0 sc0 ls487">而setAll()方法接收6个参数：cookie名称、包含所有子cookie的对象以及和 set()中一样的4</div><div class="t m0 x0 h4 yd9 ff131 fs2 fc0 sc0 ls8 ws1">个可选参数。这个方法使用for-in循环遍历第二个参数中的属性。为了确保确实是要保存的数据，使</div><div class="t m0 x0 hc y15d ff131 fs2 fc0 sc0 ls8 ws1">用了hasOwnProperty()方法，来确保只有实例属性被序列化到子cookie中。由于可能会存在属性名</div><div class="t m0 x0 h5 y21a ff131 fs2 fc0 sc0 ls24 ws1e">为空字符串的情况，所以在把属性名加入结果对象之前还要检查一下属性名的长度。将每个子cookie</div><div class="t m0 x0 h1c y5c8 ff131 fs2 fc0 sc0 ls8 ws1">的名值对儿都存入subcookieParts数组中，以便稍后可以使用join()方法以&amp;号组合起来。剩下的</div><div class="t m0 x0 hc y15f ff131 fs2 fc0 sc0 ls8 ws1">方法则和CookieUtil.set()一样。 </div><div class="t m0 x0 h5 yb ff131 fs2 fc0 sc0 ls8 ws1">可以按如下方式使用这些方法。 </div><div class="t m0 x0 hb y428 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y44a4 ff132 fs6 fc0 sc0 ls21">//假设document.cookie=data=name=Nicholas&amp;book=Professional%20JavaScript </div><div class="t m0 x0 hb y44a5 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y44a6 ff132 fs6 fc0 sc0 ls21">//设置两个cookie </div><div class="t m0 x0 hb y44a7 ff132 fs6 fc0 sc0 ls21 wsb">SubCookieUtil.set(&quot;data&quot;, &quot;name&quot;, &quot;Nicholas&quot;); </div><div class="t m0 x0 hb y44a8 ff132 fs6 fc0 sc0 ls21 wsb">SubCookieUtil.set(&quot;data&quot;, &quot;book&quot;, &quot;Professional JavaScript&quot;); </div><div class="t m0 x0 hb y44a9 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y44aa ff132 fs6 fc0 sc0 ls21">//设置全部子cookie和失效日期 </div><div class="t m0 x0 hb y44ab ff132 fs6 fc0 sc0 ls21 wsb">SubCookieUtil.setAll(&quot;data&quot;, { name: &quot;Nicholas&quot;, book: &quot;Professional JavaScript&quot; }, </div><div class="t m0 x0 hb y44ac ff132 fs6 fc0 sc0 ls21 wsb">    new Date(&quot;January 1, 2010&quot;)); </div><div class="t m0 x0 hb y44ad ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y44ae ff132 fs6 fc0 sc0 ls21">//修改名字的值，并修改cookie的失效日期 </div><div class="t m0 x0 hb y44af ff132 fs6 fc0 sc0 ls21 wsb">SubCookieUtil.set(&quot;data&quot;, &quot;name&quot;, &quot;Michael&quot;, new Date(&quot;February 1, 2010&quot;)); </div><div class="t m0 x0 hb y44b0 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y44b1 ff138 fs2 fc0 sc0 ls25 wsb">SubCookiesExample01.htm </div><div class="t m0 x0 h5 y44b2 ff131 fs2 fc0 sc0 ls61">子cookie的最后一组方法是用于删除子cookie的。普通cookie 可以通过将失效时间设置为过去的</div><div class="t m0 x0 h5 y44b3 ff131 fs2 fc0 sc0 ls8 ws1">时间的方法来删除，但是子cookie不能这样做。为了删除一个子cookie，首先必须获取包含在某个cookie</div><div class="t m0 x0 h5 y44b4 ff131 fs2 fc0 sc0 ls8 ws1">中的所有子cookie，然后仅删除需要删除的那个子cookie，然后再将余下的子cookie的值保存为cookie</div><div class="t m0 x0 h5 y44b5 ff131 fs2 fc0 sc0 ls8 ws1">的值。请看以下代码。 </div><div class="t m0 x0 hb y2e40 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y44b6 ff132 fs6 fc0 sc0 ls21 wsb">var SubCookieUtil = {  </div><div class="t m0 x0 hb y44b7 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y44b8 ff132 fs6 fc0 sc0 ls21 wsb">    //这里省略了更多代码 </div><div class="t m0 x0 hb y44b9 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y44ba ff139 fs6 fc0 sc0 ls21 wsb">    unset: function (name, subName, path, domain, secure){ </div><div class="t m0 x0 h15 y44bb ff139 fs6 fc0 sc0 ls21 wsb">        var subcookies = this.getAll(name); </div><div class="t m0 x0 h15 y44bc ff139 fs6 fc0 sc0 ls21 wsb">        if (subcookies){ </div><div class="t m0 x0 h15 y44bd ff139 fs6 fc0 sc0 ls21 wsb">            delete subcookies[subName]; </div><div class="t m0 x0 h15 y44be ff139 fs6 fc0 sc0 ls21 wsb">            this.setAll(name, subcookies, null, path, domain, secure); </div><div class="t m0 x0 h15 y44bf ff139 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 h15 y44c0 ff139 fs6 fc0 sc0 ls21 wsb">    }, </div><div class="t m0 x0 h15 y44c1 ff139 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y44c2 ff139 fs6 fc0 sc0 ls21 wsb">    unsetAll: function(name, path, domain, secure){ </div><div class="t m0 x0 h15 y44c3 ff139 fs6 fc0 sc0 ls21 wsb">        this.setAll(name, null, new Date(0), path, domain, secure); </div><div class="t m0 x0 h15 y44c4 ff139 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y44c5 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y44c6 ff132 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y44c7 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y44c8 ff138 fs2 fc0 sc0 ls25 wsb">SubCookieUtil.js </div><div class="t m0 x0 h5 y44c9 ff131 fs2 fc0 sc0 ls8 ws1">这里定义的两个方法用于两种不同的目的。unset()方法用于删除某个cookie中的单个子 cookie</div><div class="t m0 x0 hc y1930 ff131 fs2 fc0 sc0 ls8 ws1">而不影响其他的；而unsetAll()方法则等同于CookieUtil.unset()，用于删除整个cookie。和set()</div></div></div>
<div id="pf28f" class="pf w0 h0" data-page-no="28f"><div class="pc pc28f w0 h0"><div class="t m0 x2 h2 y1 ff12b fs0 fc0 sc0 ls7 ws0">23.3 数据存储    637 </div><div class="t m0 x0 h3 y2 ff12b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff137 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff137 fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ff137 fs3 fc2 sc0 ls1d wsb">16 </div><div class="t m0 x3 h8 y20 ff137 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff137 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff137 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff137 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff137 fs3 fc2 sc0 ls1d wsb">20 </div><div class="t m0 x3 h8 y25 ff137 fs3 fc2 sc0 ls1d wsb">21 </div><div class="t m0 x3 h8 y26 ff137 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff137 fs3 fc2 sc0 ls1d wsf">23 </div><div class="t m0 x3 h8 ya7a ff137 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff137 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff131 fs2 fc0 sc0 ls2c">及setAll()一样，路径、域和secure标志必须和之前创建的cookie包含的内容一致。这两个方法可</div><div class="t m0 x0 h5 y4d ff131 fs2 fc0 sc0 ls8 ws1">以像下面这样使用。 </div><div class="t m0 x0 hb y2d8 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2d9 ff132 fs6 fc0 sc0 ls21">//仅删除名为name的子cookie </div><div class="t m0 x0 hb y2da ff132 fs6 fc0 sc0 ls21 wsb">SubCookieUtil.unset(&quot;data&quot;, &quot;name&quot;); </div><div class="t m0 x0 hb y2db ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2dc ff132 fs6 fc0 sc0 ls21">//删除整个cookie </div><div class="t m0 x0 hb y2dd ff132 fs6 fc0 sc0 ls21 wsb">SubCookieUtil.unsetAll(&quot;data&quot;); </div><div class="t m0 x0 hb y2de ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y13fd ff131 fs2 fc0 sc0 ls8 ws1">如果你担心开发中可能会达到单域名的cookie上限，那么子cookie可是一个非常有吸引力的备选方</div><div class="t m0 x0 h5 y13fe ff131 fs2 fc0 sc0 ls8 ws1">案。不过，你需要更加密切关注cookie的长度，以防超过单个cookie的长度限制。 </div><div class="t m0 x0 h3c y44ca ff12f fs2 fc0 sc0 ls2e wsb">5. 关于cookie的思考  </div><div class="t m0 x0 h5 y44cb ff131 fs2 fc0 sc0 ls8 ws1">还有一类cookie被称为“HTTP专有cookie”。HTTP专有cookie可以从浏览器或者服务器设置，但</div><div class="t m0 x0 h5 y44cc ff131 fs2 fc0 sc0 ls8 ws1">是只能从服务器端读取，因为JavaScript无法获取HTTP专有cookie 的值。 </div><div class="t m0 x0 h5 y44cd ff131 fs2 fc0 sc0 ls8 ws1">由于所有的cookie都会由浏览器作为请求头发送，所以在cookie中存储大量信息会影响到特定域的</div><div class="t m0 x0 h5 y44ce ff131 fs2 fc0 sc0 ls8 ws1">请求性能。cookie信息越大，完成对服务器请求的时间也就越长。尽管浏览器对cookie进行了大小限制，</div><div class="t m0 x0 h5 y44cf ff131 fs2 fc0 sc0 ls8 ws1">不过最好还是尽可能在cookie中少存储信息，以避免影响性能。 </div><div class="t m0 x0 h5 y44d0 ff12b fs2 fc0 sc0 ls8 ws20">cookie的性质和它的局限使得其并不能作为存储大量信息的理想手段，所以又出现了其他方法。 </div><div class="t m0 x5 h5 y44d1 ff12c fs2 fc0 sc0 ls8 ws14">一定不要在cookie中存储重要和敏感的数据。cookie数据并非存储在一个安全环</div><div class="t m0 x5 h5 y44d2 ff12c fs2 fc0 sc0 ls8 ws14">境中，其中包含的任何数据都可以被他人访问。所以不要在cookie中存储诸如信用卡</div><div class="t m0 x5 h5 y44d3 ff12c fs2 fc0 sc0 ls8 ws14">号或者个人地址之类的数据。 </div><div class="t m0 x0 h20 y3f9d ff12f fs3 fc0 sc0 ls248 ws214">23.3.2 IE用户数据  </div><div class="t m0 x0 h5 y44d4 ff131 fs2 fc0 sc0 ls21d">在IE5.0中，微软通过一个自定义行为引入了持久化用户数据的概念。用户数据允许每个文档最多</div><div class="t m0 x0 h5 y44d5 ff12b fs2 fc0 sc0 lsb ws5">128KB数据，每个域名最多1MB数据。要使用持久化用户数据，首先必须如下所示，使用CSS在某个</div><div class="t m0 x0 he y44d6 ff131 fs2 fc0 sc0 ls8 ws1">元素上指定userData行为： </div><div class="t m0 x0 hb y44d7 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y44d8 ff132 fs6 fc0 sc0 ls21 wsb">&lt;div style=&quot;behavior:url(#default#userData)&quot; id=&quot;dataStore&quot;&gt;&lt;/div&gt; </div><div class="t m0 x0 hb y44d9 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1b2a ff131 fs2 fc0 sc0 ls8 ws1">一旦该元素使用了userData行为，那么就可以使用setAttribute()方法在上面保存数据了。</div><div class="t m0 x0 h1e y1b2b ff131 fs2 fc0 sc0 ls8 ws1">为了将数据提交到浏览器缓存中，还必须调用save()方法并告诉它要保存到的数据空间的名字。数据</div><div class="t m0 x0 h5 y1b2c ff131 fs2 fc0 sc0 ls8 ws1">空间名字可以完全任意，仅用于区分不同的数据集。请看以下例子。 </div><div class="t m0 x0 hb yaca ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y44da ff132 fs6 fc0 sc0 ls21 wsb">var dataStore = document.getElementById(&quot;dataStore&quot;); </div><div class="t m0 x0 hb y44db ff132 fs6 fc0 sc0 ls21 wsb">dataStore.setAttribute(&quot;name&quot;, &quot;Nicholas&quot;); </div><div class="t m0 x0 hb y41b8 ff132 fs6 fc0 sc0 ls21 wsb">dataStore.setAttribute(&quot;book&quot;, &quot;Professional JavaScript&quot;); </div><div class="t m0 x0 hb y44dc ff132 fs6 fc0 sc0 ls21 wsb">dataStore.save(&quot;BookInfo&quot;); </div><div class="t m0 x0 hb y44dd ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y44de ff138 fs2 fc0 sc0 ls1b wsb">UserDataExample01.htm </div><div class="t m0 x0 h4 y44df ff131 fs2 fc0 sc0 ls8 ws1">在这段代码中，&lt;div&gt;元素上存入了两部分信息。在用setAttribute()存储了数据之后，调用了</div><div class="t m0 x0 h4 y4247 ff132 fs1 fc0 sc0 ls9 ws2">save()方法，指定了数据空间的名称为BookInfo。下一次页面载入之后，可以使用load()方法指定</div><div class="t m0 x0 h5 y4248 ff131 fs2 fc0 sc0 ls8 ws1">同样的数据空间名称来获取数据，如下所示。 </div><div class="t m0 x0 hb y44e0 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y44e1 ff132 fs6 fc0 sc0 ls21 wsb">dataStore.load(&quot;BookInfo&quot;); </div></div></div>
<div id="pf290" class="pf w0 h0" data-page-no="290"><div class="pc pc290 w0 h0"><div class="t m0 x0 h2 y1 ff12b fs0 fc0 sc0 ls7 ws0">638  第23章 离线应用与客户端存储 </div><div class="t m0 x0 h3 y2 ff12b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 ff132 fs6 fc0 sc0 ls21 wsb">alert(dataStore.getAttribute(&quot;name&quot;)); //&quot;Nicholas&quot; </div><div class="t m0 x0 hb y7a ff132 fs6 fc0 sc0 ls21 wsb">alert(dataStore.getAttribute(&quot;book&quot;)); //&quot;Professional JavaScript&quot; </div><div class="t m0 x0 hb y1c6a ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y10b0 ff138 fs2 fc0 sc0 ls1b wsb">UserDataExample01.htm </div><div class="t m0 x0 h4 y10b1 ff131 fs2 fc0 sc0 ls2c">对load()的调用获取了BookInfo数据空间中的所有信息，并且使数据可以通过元素访问；只有</div><div class="t m0 x0 h1e y10b2 ff131 fs2 fc0 sc0 ls5 ws4">到载入确切完成之后数据方能使用。如果getAttribute()调用了不存在的名称或者是尚未载入的名</div><div class="t m0 x0 hc y10b3 ff131 fs2 fc0 sc0 ls8 ws1">程，则返回null。 </div><div class="t m0 x0 h1e y10b4 ff131 fs2 fc0 sc0 ls8 ws1">你可以通过removeAttribute()方法明确指定要删除某元素数据，只要指定属性名称。删除之后，</div><div class="t m0 x0 h5 y1452 ff131 fs2 fc0 sc0 ls8 ws1">必须像下面这样再次调用save()来提交更改。 </div><div class="t m0 x0 hb y44e2 ff132 fs6 fc0 sc0 ls21 wsb">dataStore.removeAttribute(&quot;name&quot;); </div><div class="t m0 x0 hb y44e3 ff132 fs6 fc0 sc0 ls21 wsb">dataStore.removeAttribute(&quot;book&quot;); </div><div class="t m0 x0 hb y44e4 ff132 fs6 fc0 sc0 ls21 wsb">dataStore.save(&quot;BookInfo&quot;); </div><div class="t m0 x2 hf y1347 ff138 fs2 fc0 sc0 ls1b wsb">UserDataExample01.htm </div><div class="t m0 x0 h5 y6c9 ff131 fs2 fc0 sc0 ls8 ws1">这段代码删除了两个数据属性，然后将更改保存到缓存中。 </div><div class="t m0 x0 h5 y44e5 ff131 fs2 fc0 sc0 lsc9">对IE用户数据的访问限制和对cookie的限制类似。要访问某个数据空间，脚本运行的页面必须来</div><div class="t m0 x0 h5 y44e6 ff131 fs2 fc0 sc0 ls8 ws1">自同一个域名，在同一个路径下，并使用与进行存储的脚本同样的协议。和cookie不同的是，你无法将</div><div class="t m0 x0 h4 y6cc ff131 fs2 fc0 sc0 ls8 ws1">用户数据访问限制扩展到更多的客户。还有一点不同，用户数据默认是可以跨越会话持久存在的，同时</div><div class="t m0 x0 h14 y44e7 ff131 fs2 fc0 sc0 ls8 ws1">也不会过期；数据需要通过removeAttribute()方法专门进行删除以释放空间。 </div><div class="t m0 x5 h5 y44e8 ff12c fs2 fc0 sc0 ls3b">和cookie一样，IE用户数据并非安全的，所以不能存放敏感信息。 </div><div class="t m0 x0 h20 y8ae ff12f fs3 fc0 sc0 ls248 ws214">23.3.3 Web存储机制  </div><div class="t m0 x0 h5 yf7e ff12b fs2 fc0 sc0 ls2b ws1d1">Web Storage最早是在Web超文本应用技术工作组（WHAT-WG）的Web应用 1.0规范中描述的。</div><div class="t m0 x0 h5 y44e9 ff131 fs2 fc0 sc0 ls8 ws1">这个规范的最初的工作最终成为了HTML5的一部分。Web Storage的目的是克服由cookie带来的一些限</div><div class="t m0 x0 h5 y44ea ff131 fs2 fc0 sc0 ls6 ws6">制，当数据需要被严格控制在客户端上时，无须持续地将数据发回服务器。Web Storage的两个主要目</div><div class="t m0 x0 h5 y2c1d ff131 fs2 fc0 sc0 ls8">标是：  </div><div class="t m0 x0 h5 y44eb ff130 fs1 fc0 sc0 ls2"> 提供一种在cookie之外存储会话数据的途径； </div><div class="t m0 x0 h5 y58d ff130 fs1 fc0 sc0 ls2"> 提供一种存储大量可以跨会话存在的数据的机制。 </div><div class="t m0 x0 h5 y2231 ff131 fs2 fc0 sc0 ls8 ws1">最初的Web Storage规范包含了两种对象的定义：sessionStorage和globalStorage。这两个</div><div class="t m0 x0 h5 y2232 ff131 fs2 fc0 sc0 ls8 ws1">对象在支持的浏览器中都是以windows对象属性的形式存在的，支持这两个属性的浏览器包括IE8+、</div><div class="t m0 x0 h5 y2233 ff12b fs2 fc0 sc0 ls2e ws67">Firefox 3.5+、Chrome 4+和Opera 10.5+。 </div><div class="t m0 x5 h5 y44ec ff12b fs2 fc0 sc0 ls96 ws103"> Firefox 2和3基于早期规范的内容部分实现了Web Storage，当时只实现了</div><div class="t m0 x0 h5 y44ed ff132 fs1 fc0 sc0 ls9 ws2">globalStorage，没有实现localStorage。 </div><div class="t m0 x0 h50 y44ee ff12f fs2 fc0 sc0 ls2e wsb">1. Storage类型  </div><div class="t m0 x0 h4 y384e ff132 fs1 fc0 sc0 ls9 ws2">Storage类型提供最大的存储空间（因浏览器而异）来存储名值对儿。Storage的实例与其他对</div><div class="t m0 x0 h5 y384f ff131 fs2 fc0 sc0 ls8 ws1">象类似，有如下方法。 </div><div class="t m0 x0 h5 y395c ff130 fs1 fc0 sc0 ls2"> clear()： 删除所有值；Firefox中没有实现 。 </div></div></div>
<div id="pf291" class="pf w0 h0" data-page-no="291"><div class="pc pc291 w0 h0"><div class="t m0 x2 h2 y1 ff12b fs0 fc0 sc0 ls7 ws0">23.3 数据存储    639 </div><div class="t m0 x0 h3 y2 ff12b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff137 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff137 fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ff137 fs3 fc2 sc0 ls1d wsb">16 </div><div class="t m0 x3 h8 y20 ff137 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff137 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff137 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff137 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff137 fs3 fc2 sc0 ls1d wsb">20 </div><div class="t m0 x3 h8 y25 ff137 fs3 fc2 sc0 ls1d wsb">21 </div><div class="t m0 x3 h8 y26 ff137 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff137 fs3 fc2 sc0 ls1d wsf">23 </div><div class="t m0 x3 h8 ya7a ff137 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff137 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff130 fs1 fc0 sc0 ls2"> getItem(name)：根据指定的名字name获取对应的值。 </div><div class="t m0 x0 h5 y4 ff130 fs1 fc0 sc0 ls2"> key(index)：获得index位置处的值的名字。 </div><div class="t m0 x0 h5 y4e ff130 fs1 fc0 sc0 ls2"> removeItem(name)：删除由name指定的名值对儿。 </div><div class="t m0 x0 h5 yd9 ff130 fs1 fc0 sc0 ls2"> setItem(name, value)：为指定的name设置一个对应的值。 </div><div class="t m0 x0 h1e y15d ff131 fs2 fc0 sc0 ls8 ws1">其中，getItem()、removeItem()和setItem()方法可以直接调用，也可通过Storage对象间</div><div class="t m0 x0 h4 y21a ff131 fs2 fc0 sc0 ls8 ws1">接调用。因为每个项目都是作为属性存储在该对象上的，所以可以通过点语法或者方括号语法访问属性</div><div class="t m0 x0 h1c y5c8 ff131 fs2 fc0 sc0 ls8 ws1">来读取值，设置也一样，或者通过delete操作符进行删除。不过，我们还建议读者使用方法而不是属</div><div class="t m0 x0 h5 y15f ff131 fs2 fc0 sc0 ls8 ws1">性来访问数据，以免某个键会意外重写该对象上已经存在的成员。 </div><div class="t m0 x0 h1e y2df1 ff131 fs2 fc0 sc0 ls8 ws1">还可以使用length属性来判断有多少名值对儿存放在Storage 对象中。但无法判断对象中所有</div><div class="t m0 x0 hc y78a ff131 fs2 fc0 sc0 ls8 ws1">数据的大小，不过IE8提供了一个remainingSpace属性，用于获取还可以使用的存储空间的字节数。 </div><div class="t m0 x5 h5 y44ef ff139 fs1 fc0 sc0 ls9 ws2">Storage类型只能存储字符串。非字符串的数据在存储之前会被转换成字符串。 </div><div class="t m0 x0 h5 y44f0 ff12b fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15d y44f1 ff12f fs2 fc0 sc0 ls2e wsb">2. sessionStorage对象  </div><div class="t m0 x0 h4 y44f2 ff132 fs1 fc0 sc0 ls9 ws2">sessionStorage对象存储特定于某个会话的数据，也就是该数据只保持到浏览器关闭。这个对象</div><div class="t m0 x0 h5 y44f3 ff131 fs2 fc0 sc0 ls8 ws1">就像会话cookie，也会在浏览器关闭后消失。存储在sessionStorage中的数据可以跨越页面刷新而</div><div class="t m0 x0 h5 y44f4 ff131 fs2 fc0 sc0 ls8 ws1">存在，同时如果浏览器支持，浏览器崩溃并重启之后依然可用（Firefox和WebKit都支持，IE则不行）。 </div><div class="t m0 x0 h1e y44f5 ff131 fs2 fc0 sc0 ls44 ws32">因为seesionStorage对象绑定于某个服务器会话，所以当文件在本地运行的时候是不可用的。存</div><div class="t m0 x0 hc y44f6 ff131 fs2 fc0 sc0 ls44 ws32">储在sessionStorage中的数据只能由最初给对象存储数据的页面访问到，所以对多页面应用有限制。 </div><div class="t m0 x0 h1e y44f7 ff131 fs2 fc0 sc0 ls8 ws1">由于sessionStorage对象其实是Storage 的一个实例，所以可以使用setItem()或者直接设</div><div class="t m0 x0 h5 y44f8 ff131 fs2 fc0 sc0 ls8 ws1">置新的属性来存储数据。下面是这两种方法的例子。 </div><div class="t m0 x0 hb y44f9 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y44fa ff132 fs6 fc0 sc0 ls21">//使用方法存储数据 </div><div class="t m0 x0 hb y44fb ff132 fs6 fc0 sc0 ls21 wsb">sessionStorage.setItem(&quot;name&quot;, &quot;Nicholas&quot;); </div><div class="t m0 x0 hb y44fc ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y44fd ff132 fs6 fc0 sc0 ls21">//使用属性存储数据 </div><div class="t m0 x0 hb y44fe ff132 fs6 fc0 sc0 ls21 wsb">sessionStorage.book = &quot;Professional JavaScript&quot;; </div><div class="t m0 x0 hb y44ff ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y85c ff138 fs2 fc0 sc0 ls25 wsb">SessionStorageExample01.htm </div><div class="t m0 x0 h5 y4500 ff131 fs2 fc0 sc0 ls8 ws1">不同浏览器写入数据方面略有不同。Firefox和WebKit实现了同步写入，所以添加到存储空间中的</div><div class="t m0 x0 h5 y4501 ff131 fs2 fc0 sc0 ls8 ws1">数据是立刻被提交的。而IE的实现则是异步写入数据，所以在设置数据和将数据实际写入磁盘之间可</div><div class="t m0 x0 h5 y4502 ff131 fs2 fc0 sc0 ls8 ws1">能有一些延迟。对于少量数据而言，这个差异是可以忽略的。对于大量数据，你会发现IE要比其他浏</div><div class="t m0 x0 h5 y4503 ff131 fs2 fc0 sc0 ls8 ws1">览器更快地恢复执行，因为它会跳过实际的磁盘写入过程。 </div><div class="t m0 x0 h5 y4504 ff131 fs2 fc0 sc0 ls3b">在IE8中可以强制把数据写入磁盘：在设置新数据之前使用begin()方法，并且在所有设置完成之</div><div class="t m0 x0 hc y4505 ff131 fs2 fc0 sc0 ls8 ws1">后调用commit()方法。看以下例子。 </div><div class="t m0 x0 hb y4506 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h36 y4507 ff132 fs6 fc0 sc0 ls21">//只适用于IE8 </div><div class="t m0 x0 hb y4508 ff132 fs6 fc0 sc0 ls21 wsb">sessionStorage.begin(); </div><div class="t m0 x0 hb y4509 ff132 fs6 fc0 sc0 ls21 wsb">sessionStorage.name = &quot;Nicholas&quot;; </div><div class="t m0 x0 hb y450a ff132 fs6 fc0 sc0 ls21 wsb">sessionStorage.book = &quot;Professional JavaScript&quot;; </div><div class="t m0 x0 hb y450b ff132 fs6 fc0 sc0 ls21 wsb">sessionStorage.commit(); </div><div class="t m0 x0 hb y450c ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1b0a ff131 fs2 fc0 sc0 ls8 ws1">这段代码确保了name和book的值在调用commit()之后立刻被写入磁盘。调用 begin()是为了</div><div class="t m0 x0 h4 yeac ff131 fs2 fc0 sc0 ls8 ws1">确保在这段代码执行的时候不会发生其他磁盘写入操作。对于少量数据而言，这个过程不是必需的；不</div></div></div>
<div id="pf292" class="pf w0 h0" data-page-no="292"><div class="pc pc292 w0 h0"><div class="t m0 x0 h2 y1 ff12b fs0 fc0 sc0 ls7 ws0">640  第23章 离线应用与客户端存储 </div><div class="t m0 x0 h3 y2 ff12b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff131 fs2 fc0 sc0 ls8 ws1">过，对于大量数据（如文档之类的）可能就要考虑这种事务形式的方法了。 </div><div class="t m0 x0 h4 y4 ff132 fs1 fc0 sc0 ls9 ws2">sessionStorage中有数据时，可以使用getItem()或者通过直接访问属性名来获取数据。两种</div><div class="t m0 x0 h5 y5 ff131 fs2 fc0 sc0 ls8 ws1">方法的例子如下。 </div><div class="t m0 x0 hb y6bd ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y6be ff132 fs6 fc0 sc0 ls21">//使用方法读取数据 </div><div class="t m0 x0 hb y6bf ff132 fs6 fc0 sc0 ls21 wsb">var name = sessionStorage.getItem(&quot;name&quot;); </div><div class="t m0 x0 hb y6c0 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y6c1 ff132 fs6 fc0 sc0 ls21">//使用属性读取数据 </div><div class="t m0 x0 hb y6c2 ff132 fs6 fc0 sc0 ls21 wsb">var book = sessionStorage.book; </div><div class="t m0 x0 hb y450e ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1452 ff138 fs2 fc0 sc0 ls25 wsb">SessionStorageExample01.htm </div><div class="t m0 x0 h5 y42d9 ff131 fs2 fc0 sc0 ls8 ws1">还可以通过结合length属性和key()方法来迭代sessionStorage 中的值，如下所示。 </div><div class="t m0 x0 hb y3ed1 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3ed2 ff132 fs6 fc0 sc0 ls21 wsb">for (var i=0, len = sessionStorage.length; i &lt; len; i++){ </div><div class="t m0 x0 hb y3ed3 ff132 fs6 fc0 sc0 ls21 wsb">    var key = sessionStorage.key(i); </div><div class="t m0 x0 hb y3ed4 ff132 fs6 fc0 sc0 ls21 wsb">    var value = sessionStorage.getItem(key); </div><div class="t m0 x0 hb y3ed5 ff132 fs6 fc0 sc0 ls21 wsb">    alert(key + &quot;=&quot; + value); </div><div class="t m0 x0 hb y3ed6 ff132 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y450f ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y7b9 ff138 fs2 fc0 sc0 ls25 wsb">SessionStorageExample01.htm </div><div class="t m0 x0 h4 y4510 ff131 fs2 fc0 sc0 ls8 ws1">它是这样遍历sessionStorage中的名值对儿的：首先通过key()方法获取指定位置上的名字，</div><div class="t m0 x0 h5 y4511 ff131 fs2 fc0 sc0 ls8 ws1">然后再通过getItem()找出对应该名字的值。 </div><div class="t m0 x0 hc y4512 ff131 fs2 fc0 sc0 ls8 ws1">还可以使用for-in循环来迭代sessionStorage中的值： </div><div class="t m0 x0 hb y24a ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4513 ff132 fs6 fc0 sc0 ls21 wsb">for (var key in sessionStorage){ </div><div class="t m0 x0 hb y4514 ff132 fs6 fc0 sc0 ls21 wsb">    var value = sessionStorage.getItem(key); </div><div class="t m0 x0 hb y4515 ff132 fs6 fc0 sc0 ls21 wsb">    alert(key + &quot;=&quot; + value); </div><div class="t m0 x0 hb y4516 ff132 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y4517 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y18b7 ff131 fs2 fc0 sc0 ls8 ws1">每次经过循环的时候，key被设置为sessionStorage中下一个名字，此时不会返回任何内置方</div><div class="t m0 x0 h5 y1c1f ff131 fs2 fc0 sc0 ls8 ws1">法或length属性。 </div><div class="t m0 x0 h1e y4518 ff131 fs2 fc0 sc0 ls386 ws310">要从sessionStorage中删除数据，可以使用 delete操作符删除对象属性，也可调用</div><div class="t m0 x0 h5 y4519 ff132 fs1 fc0 sc0 ls9 ws2">removeItem()方法。以下是这些方法的例子。 </div><div class="t m0 x0 hb y30d1 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y451a ff132 fs6 fc0 sc0 ls21">//使用delete删除一个值——在WebKit中无效 </div><div class="t m0 x0 hb y451b ff132 fs6 fc0 sc0 ls21 wsb">delete sessionStorage.name; </div><div class="t m0 x0 hb y451c ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y451d ff132 fs6 fc0 sc0 ls21">//使用方法删除一个值 </div><div class="t m0 x0 hb y451e ff132 fs6 fc0 sc0 ls21 wsb">sessionStorage.removeItem(&quot;book&quot;); </div><div class="t m0 x0 hb y451f ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y4520 ff138 fs2 fc0 sc0 ls25 wsb">SessionStorageExample01.htm </div><div class="t m0 x0 h5 y3440 ff131 fs2 fc0 sc0 ls8 ws1">在撰写本书时，delete操作符在WebKit中无法删除数据，removeItem()则可以在各种支持的浏</div><div class="t m0 x0 h5 y4521 ff131 fs2 fc0 sc0 ls8 ws1">览器中正确运行。 </div><div class="t m0 x0 h4 y2ee1 ff132 fs1 fc0 sc0 ls9 ws2">sessionStorage对象应该主要用于仅针对会话的小段数据的存储。如果需要跨越会话存储数据，</div><div class="t m0 x0 hc y42d6 ff131 fs2 fc0 sc0 ls8 ws1">那么globalStorage或者localStorage更为合适。 </div><div class="t m0 x0 hab y4522 ff12f fs2 fc0 sc0 ls2e wsb">3. globalStorage对象  </div><div class="t m0 x0 h5 y4523 ff12b fs2 fc0 sc0 ls2f ws92">Firefox 2中实现了globalStorage对象。作为最初的Web Storage规范的一部分，这个对象的目</div><div class="t m0 x0 h4 y113a ff131 fs2 fc0 sc0 ls8 ws1">的是跨越会话存储数据，但有特定的访问限制。要使用globalStorage，首先要指定哪些域可以访问</div></div></div>
<div id="pf293" class="pf w0 h0" data-page-no="293"><div class="pc pc293 w0 h0"><div class="t m0 x2 h2 y1 ff12b fs0 fc0 sc0 ls7 ws0">23.3 数据存储    641 </div><div class="t m0 x0 h3 y2 ff12b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff137 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff137 fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ff137 fs3 fc2 sc0 ls1d wsb">16 </div><div class="t m0 x3 h8 y20 ff137 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff137 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff137 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff137 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff137 fs3 fc2 sc0 ls1d wsb">20 </div><div class="t m0 x3 h8 y25 ff137 fs3 fc2 sc0 ls1d wsb">21 </div><div class="t m0 x3 h8 y26 ff137 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff137 fs3 fc2 sc0 ls1d wsf">23 </div><div class="t m0 x3 h8 ya7a ff137 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff137 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff131 fs2 fc0 sc0 ls8 ws1">该数据。可以通过方括号标记使用属性来实现，如以下例子所示。 </div><div class="t m0 x0 hb yfb2 ff132 fs6 fc0 sc0 ls8 wsb">  </div><div class="t m0 x0 h16 y4524 ff132 fs6 fc0 sc0 ls21">//保存数据 </div><div class="t m0 x0 hb y4525 ff132 fs6 fc0 sc0 ls21 wsb">globalStorage[&quot;wrox.com&quot;].name = &quot;Nicholas&quot;; </div><div class="t m0 x0 hb y4526 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4527 ff132 fs6 fc0 sc0 ls21">//获取数据 </div><div class="t m0 x0 hb y4528 ff132 fs6 fc0 sc0 ls21 wsb">var name = globalStorage[&quot;wrox.com&quot;].name; </div><div class="t m0 x0 hb y4529 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1009 ff138 fs2 fc0 sc0 ls2b wsb">GlobalStorageExample01.htm </div><div class="t m0 x0 h4 y23af ff131 fs2 fc0 sc0 ls8 ws1">在这里，访问的是针对域名wrox.com的存储空间。globalStorage对象不是Storage 的实例，</div><div class="t m0 x0 h1e y452a ff131 fs2 fc0 sc0 ls8 ws1">而具体的globalStorage[&quot;wrox.com&quot;]才是。这个存储空间对于wrox.com及其所有子域都是可以</div><div class="t m0 x0 h5 y452b ff131 fs2 fc0 sc0 ls8 ws1">访问的。可以像下面这样指定子域名。 </div><div class="t m0 x0 hb y452c ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y452d ff132 fs6 fc0 sc0 ls21">//保存数据 </div><div class="t m0 x0 hb y452e ff132 fs6 fc0 sc0 ls21 wsb">globalStorage[&quot;www.wrox.com&quot;].name = &quot;Nicholas&quot;; </div><div class="t m0 x0 hb y452f ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4530 ff132 fs6 fc0 sc0 ls21">//获取数据 </div><div class="t m0 x0 hb y4531 ff132 fs6 fc0 sc0 ls21 wsb">var name = globalStorage[&quot;www.wrox.com&quot;].name; </div><div class="t m0 x0 hb y4532 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf yb53 ff138 fs2 fc0 sc0 ls2b wsb">GlobalStorageExample01.htm </div><div class="t m0 x0 h5 y22b9 ff131 fs2 fc0 sc0 ls8 ws1">这里所指定的存储空间只能由来自www.wrox.com的页面访问，其他子域名都不行。 </div><div class="t m0 x0 h4 y1dbe ff131 fs2 fc0 sc0 ls8 ws1">某些浏览器允许更加宽泛的访问限制，比如只根据顶级域名进行限制或者允许全局访问，如下面例</div><div class="t m0 x0 h5 y4533 ff131 fs2 fc0 sc0 ls8">子所示。 </div><div class="t m0 x0 hb y29ed ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4534 ff132 fs6 fc0 sc0 ls21">//存储数据，任何人都可以访问——不要这样做！ </div><div class="t m0 x0 hb y4535 ff132 fs6 fc0 sc0 ls21 wsb">globalStorage[&quot;&quot;].name = &quot;Nicholas&quot;; </div><div class="t m0 x0 hb y4536 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4537 ff132 fs6 fc0 sc0 ls21">//存储数据，可以让任何以.net结尾的域名访问——不要这样做！ </div><div class="t m0 x0 hb y4538 ff132 fs6 fc0 sc0 ls21 wsb">globalStorage[&quot;net&quot;].name = &quot;Nicholas&quot;; </div><div class="t m0 x0 hb y4539 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y453a ff131 fs2 fc0 sc0 ls8 ws1">虽然这些也支持，但是还是要避免使用这种可宽泛访问的数据存储，以防止出现潜在的安全问题。</div><div class="t m0 x0 h4 y453b ff131 fs2 fc0 sc0 ls8 ws1">考虑到安全问题，这些功能在未来可能会被删除或者是被更严格地限制，所以不应依赖于这类功能。当</div><div class="t m0 x0 he y41c4 ff131 fs2 fc0 sc0 ls8 ws1">使用globalStorage的时候一定要指定一个域名。 </div><div class="t m0 x0 h1e y453c ff131 fs2 fc0 sc0 ls48a">对globalStorage空间的访问，是依据发起请求的页面的域名、协议和端口来限制的。例如，如</div><div class="t m0 x0 h5 y453d ff131 fs2 fc0 sc0 ls8 ws1">果使用HTTPS协议在wrox.com中存储了数据，那么通过 HTTP访问的wrox.com的页面就不能访问</div><div class="t m0 x0 h5 y453e ff131 fs2 fc0 sc0 ls8 ws1">该数据。同样，通过80端口访问的页面则无法与同一个域同样协议但通过8080端口访问的页面共享数</div><div class="t m0 x0 h5 y453f ff131 fs2 fc0 sc0 ls8 ws1">据。这类似于Ajax请求的同源策略。 </div><div class="t m0 x0 h5 y3558 ff132 fs1 fc0 sc0 ls9 ws2">globalStorage的每个属性都是Storage的实例。因此，可以像如下代码中这样使用。 </div><div class="t m0 x0 hb y3bc1 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3bc2 ff132 fs6 fc0 sc0 ls21 wsb">globalStorage[&quot;www.wrox.com&quot;].name = &quot;Nicholas&quot;; </div><div class="t m0 x0 hb y4540 ff132 fs6 fc0 sc0 ls21 wsb">globalStorage[&quot;www.wrox.com&quot;].book = &quot;Professional JavaScript&quot;; </div><div class="t m0 x0 hb y4541 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4542 ff132 fs6 fc0 sc0 ls21 wsb">globalStorage[&quot;www.wrox.com&quot;].removeItem(&quot;name&quot;); </div><div class="t m0 x0 hb y4543 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4544 ff132 fs6 fc0 sc0 ls21 wsb">var book = globalStorage[&quot;www.wrox.com&quot;].getItem(&quot;book&quot;); </div><div class="t m0 x0 hb y4545 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y4546 ff138 fs2 fc0 sc0 ls2b wsb">GlobalStorageExample01.htm </div><div class="t m0 x0 h5 y4547 ff131 fs2 fc0 sc0 ls8 ws1">如果你事先不能确定域名，那么使用location.host作为属性名比较安全。例如： </div></div></div>
<div id="pf294" class="pf w0 h0" data-page-no="294"><div class="pc pc294 w0 h0"><div class="t m0 x0 h2 y1 ff12b fs0 fc0 sc0 ls7 ws0">642  第23章 离线应用与客户端存储 </div><div class="t m0 x0 h3 y2 ff12b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 ff132 fs6 fc0 sc0 ls21 wsb">globalStorage[location.host].name = &quot;Nicholas&quot;; </div><div class="t m0 x0 hb y7a ff132 fs6 fc0 sc0 ls21 wsb">var book = globalStorage[location.host].getItem(&quot;book&quot;); </div><div class="t m0 x0 hb y1c6a ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y10b0 ff138 fs2 fc0 sc0 ls2b wsb">GlobalStorageExample01.htm </div><div class="t m0 x0 h4 y10b1 ff131 fs2 fc0 sc0 ls3f4 ws35f">如果不使用removeItem()或者delete 删除，或者用户未清除浏览器缓存，存储在</div><div class="t m0 x0 h4 y3523 ff132 fs1 fc0 sc0 ls9 ws2">globalStorage属性中的数据会一直保留在磁盘上。这让globalStorage非常适合在客户端存储文</div><div class="t m0 x0 h5 y10b3 ff131 fs2 fc0 sc0 ls8 ws1">档或者长期保存用户偏好设置。 </div><div class="t m0 x0 h4e y4548 ff12f fs2 fc0 sc0 ls2e wsb">4. localStorage对象  </div><div class="t m0 x0 h5 y522 ff132 fs1 fc0 sc0 ls9 ws2">localStorage对象在修订过的HTML 5 规范中作为持久保存客户端数据的方案取代了</div><div class="t m0 x0 h4 y28ae ff132 fs1 fc0 sc0 ls9 ws2">globalStorage。与globalStorage不同，不能给localStorage指定任何访问规则；规则事先就</div><div class="t m0 x0 h4 y24e9 ff131 fs2 fc0 sc0 ls8 ws1">设定好了。要访问同一个localStorage对象，页面必须来自同一个域名（子域名无效），使用同一种</div><div class="t m0 x0 hc y24ea ff131 fs2 fc0 sc0 ls8 ws1">协议，在同一个端口上。这相当于globalStorage[location.host]。 </div><div class="t m0 x0 h1e y28af ff131 fs2 fc0 sc0 ls8 ws1">由于localStorage是Storage的实例，所以可以像使用 sessionStorage一样来使用它。下</div><div class="t m0 x0 h5 y193a ff131 fs2 fc0 sc0 ls8 ws1">面是一些例子。 </div><div class="t m0 x0 hb y4549 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y454a ff132 fs6 fc0 sc0 ls21">//使用方法存储数据 </div><div class="t m0 x0 hb y454b ff132 fs6 fc0 sc0 ls21 wsb">localStorage.setItem(&quot;name&quot;, &quot;Nicholas&quot;); </div><div class="t m0 x0 hb y454c ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y454d ff132 fs6 fc0 sc0 ls21">//使用属性存储数据 </div><div class="t m0 x0 hb y454e ff132 fs6 fc0 sc0 ls21 wsb">localStorage.book = &quot;Professional JavaScript&quot;; </div><div class="t m0 x0 hb y454f ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4550 ff132 fs6 fc0 sc0 ls21">//使用方法读取数据 </div><div class="t m0 x0 hb y4551 ff132 fs6 fc0 sc0 ls21 wsb">var name = localStorage.getItem(&quot;name&quot;); </div><div class="t m0 x0 hb y4552 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4553 ff132 fs6 fc0 sc0 ls21">//使用属性读取数据 </div><div class="t m0 x0 hb y4554 ff132 fs6 fc0 sc0 ls21 wsb">var book = localStorage.book; </div><div class="t m0 x0 hb y4555 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1899 ff138 fs2 fc0 sc0 ls1b wsb">LocalStorageExample01.htm </div><div class="t m0 x0 h4 y797 ff131 fs2 fc0 sc0 ls8 ws1">存储在localStorage中的数据和存储在globalStorage 中的数据一样，都遵循相同的规则：</div><div class="t m0 x0 hc y4556 ff131 fs2 fc0 sc0 ls8 ws1">数据保留到通过JavaScript删除或者是用户清除浏览器缓存。 </div><div class="t m0 x0 hc y4557 ff131 fs2 fc0 sc0 ls8 ws1">为了兼容只支持globalStorage的浏览器，可以使用以下函数。 </div><div class="t m0 x0 hb y18f7 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4558 ff132 fs6 fc0 sc0 ls21 wsb">function getLocalStorage(){ </div><div class="t m0 x0 hb y4559 ff132 fs6 fc0 sc0 ls21 wsb">    if (typeof localStorage == &quot;object&quot;){ </div><div class="t m0 x0 hb y455a ff132 fs6 fc0 sc0 ls21 wsb">        return localStorage; </div><div class="t m0 x0 hb y455b ff132 fs6 fc0 sc0 ls21 wsb">    } else if (typeof globalStorage == &quot;object&quot;){ </div><div class="t m0 x0 hb y455c ff132 fs6 fc0 sc0 ls21 wsb">        return globalStorage[location.host]; </div><div class="t m0 x0 hb y455d ff132 fs6 fc0 sc0 ls21 wsb">    } else { </div><div class="t m0 x0 hb y455e ff132 fs6 fc0 sc0 ls21 wsb">        throw new Error(&quot;Local storage not available.&quot;); </div><div class="t m0 x0 hb y455f ff132 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y4560 ff132 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y4561 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf y3acf ff138 fs2 fc0 sc0 ls1b wsb">GlobalAndLocalStorageExample01.htm </div><div class="t m0 x0 h5 y8c0 ff131 fs2 fc0 sc0 ls8 ws1">然后，像下面这样调用一次这个函数，就可以正常地读写数据了。 </div><div class="t m0 x0 hb y1334 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4562 ff132 fs6 fc0 sc0 ls21 wsb">var storage = getLocalStorage(); </div><div class="t m0 x0 hb y4563 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 hf y1ae9 ff138 fs2 fc0 sc0 ls1b wsb">GlobalAndLocalStorageExample01.htm </div></div></div>
<div id="pf295" class="pf w0 h0" data-page-no="295"><div class="pc pc295 w0 h0"><div class="t m0 x2 h2 y1 ff12b fs0 fc0 sc0 ls7 ws0">23.3 数据存储    643 </div><div class="t m0 x0 h3 y2 ff12b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff137 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff137 fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ff137 fs3 fc2 sc0 ls1d wsb">16 </div><div class="t m0 x3 h8 y20 ff137 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff137 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff137 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff137 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff137 fs3 fc2 sc0 ls1d wsb">20 </div><div class="t m0 x3 h8 y25 ff137 fs3 fc2 sc0 ls1d wsb">21 </div><div class="t m0 x3 h8 y26 ff137 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff137 fs3 fc2 sc0 ls1d wsf">23 </div><div class="t m0 x3 h8 ya7a ff137 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff137 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff131 fs2 fc0 sc0 ls8 ws1">在确定了使用哪个Storage对象之后，就能在所有支持Web Storage的浏览器中使用相同的存取规</div><div class="t m0 x0 h5 y4d ff131 fs2 fc0 sc0 ls8 ws1">则操作数据了。 </div><div class="t m0 x0 h4e y2041 ff12f fs2 fc0 sc0 ls2e wsb">5. storage事件  </div><div class="t m0 x0 h4 y3607 ff131 fs2 fc0 sc0 ls48b">对Storage对象进行任何修改，都会在文档上触发storage事件。当通过属性或 setItem()方</div><div class="t m0 x0 h1e y6e4 ff131 fs2 fc0 sc0 ls8 ws1">法保存数据，使用delete操作符或removeItem()删除数据，或者调用clear()方法时，都会发生该</div><div class="t m0 x0 h5 y1ed2 ff131 fs2 fc0 sc0 ls8 ws1">事件。这个事件的event对象有以下属性。 </div><div class="t m0 x0 h5 y1ed3 ff130 fs1 fc0 sc0 ls2"> domain：发生变化的存储空间的域名。 </div><div class="t m0 x0 h5 y1aa7 ff130 fs1 fc0 sc0 ls2"> key：设置或者删除的键名。 </div><div class="t m0 x0 h5 yf6c ff130 fs1 fc0 sc0 ls2"> newValue：如果是设置值，则是新值；如果是删除键，则是null。 </div><div class="t m0 x0 h5 y2043 ff130 fs1 fc0 sc0 ls2"> oldValue：键被更改之前的值。 </div><div class="t m0 x0 hc ycbd ff131 fs2 fc0 sc0 ls6 ws6">在这四个属性中，IE8和Firefox只实现了domain 属性。在撰写本书的时候，WebKit尚不支持</div><div class="t m0 x0 h5 y20ef ff132 fs1 fc0 sc0 ls9 ws2">storage事件： </div><div class="t m0 x0 hc y21d5 ff131 fs2 fc0 sc0 ls8 ws1">以下代码展示了如何侦听storage事件： </div><div class="t m0 x0 hb y2493 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4564 ff132 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(document, &quot;storage&quot;, function(event){ </div><div class="t m0 x0 hb y4565 ff132 fs6 fc0 sc0 ls21 wsb">    alert(&quot;Storage changed for &quot; + event.domain); </div><div class="t m0 x0 hb y4566 ff132 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 hb y4567 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1ca2 ff138 fs2 fc0 sc0 ls1b wsb">StorageEventExample01.htm </div><div class="t m0 x0 h4 y82e ff131 fs2 fc0 sc0 ls8 ws1">无论对sessionStorage、globalStorage还是localStorage 进行操作，都会触发storage</div><div class="t m0 x0 h5 y3e98 ff131 fs2 fc0 sc0 ls8 ws1">事件，但不作区分。 </div><div class="t m0 x0 h3c y4568 ff12f fs2 fc0 sc0 ls2e wsb">6. 限制 </div><div class="t m0 x0 h5 y4569 ff131 fs2 fc0 sc0 ls8 ws1">与其他客户端数据存储方案类似，Web Storage同样也有限制。这些限制因浏览器而异。一般来说，</div><div class="t m0 x0 h4 y456a ff131 fs2 fc0 sc0 ls8 ws1">对存储空间大小的限制都是以每个来源（协议、域和端口）为单位的。换句话说，每个来源都有固定大</div><div class="t m0 x0 h4 y456b ff131 fs2 fc0 sc0 ls8 ws1">小的空间用于保存自己的数据。考虑到这个限制，就要注意分析和控制每个来源中有多少页面需要保存</div><div class="t m0 x0 h5 y456c ff131 fs2 fc0 sc0 ls8">数据。 </div><div class="t m0 x0 h67 y456d ff131 fs2 fc0 sc0 ls8 ws1">对于localStorage而言，大多数桌面浏览器会设置每个来源5MB的限制。Chrome和Safari对每</div><div class="t m0 x0 h5 y456e ff131 fs2 fc0 sc0 ls8 ws1">个来源的限制是2.5MB。而iOS版Safari和Android版WebK it的限制也是2.5MB。 </div><div class="t m0 x0 h1e y3618 ff131 fs2 fc0 sc0 ls48c">对sessionStorage的限制也是因浏览器而异。有的浏览器对sessionStorage的大小没有限制，</div><div class="t m0 x0 h5 y456f ff131 fs2 fc0 sc0 ls325">但Chrome、Safari、iOS版Safari和Android版WebKi t都有限制，也都是2.5MB。IE8+和Opera对</div><div class="t m0 x0 h5 y85e ff132 fs1 fc0 sc0 ls9 ws2">sessionStorage的限制是5MB。 </div><div class="t m0 x0 h5 y2524 ff131 fs2 fc0 sc0 ls8 ws1">有关Web Storage的限制，请参考http://dev-test.nemikor.com/web-storage/support-test/。 </div><div class="t m0 x0 h20 y4570 ff12f fs3 fc0 sc0 ls248 ws214">23.3.4 IndexedDB </div><div class="t m0 x0 h5 y4571 ff12b fs2 fc0 sc0 lsb ws419">Indexed Database API，或者简称为IndexedDB，是在浏览器中保存结构化数据的一种数据库。</div><div class="t m0 x0 h5 y286c ff12b fs2 fc0 sc0 ls25 wsb3">IndexedDB是为了替代目前已被废弃的Web SQL Database API（因为已废弃，所以本书未介绍）而出现</div><div class="t m0 x0 h5 y19d9 ff131 fs2 fc0 sc0 ls8">的。IndexedDB的思想是创建一套API，方便保存和读取JavaScript对象，同时还支持查询及搜索。 </div><div class="t m0 x0 h5 y4572 ff12b fs2 fc0 sc0 ls25 wsb3">IndexedDB设计的操作完全是异步进行的。因此，大多数操作会以请求方式进行，但这些操作会在</div><div class="t m0 x0 h5 y4573 ff131 fs2 fc0 sc0 ls8 ws1">后期执行，然后如果成功则返回结果，如果失败则返回错误。差不多每一次IndexedDB操作，都需要你</div><div class="t m0 x0 h1b y4574 ff131 fs2 fc0 sc0 ls8 ws1">注册onerror或onsuccess事件处理程序，以确保适当地处理结果。 </div><div class="t m0 x0 h14e y4575 ff131 fs2 fc0 sc0 ls8 ws1">在得到完整支持的情况下，IndexedDB将是一个作为API宿主的全局对象。由于API 仍然可能有</div></div></div>
<div id="pf296" class="pf w0 h0" data-page-no="296"><div class="pc pc296 w0 h0"><div class="t m0 x0 h2 y1 ff12b fs0 fc0 sc0 ls7 ws0">644  第23章 离线应用与客户端存储 </div><div class="t m0 x0 h3 y2 ff12b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff131 fs2 fc0 sc0 ls4 ws3">变化，浏览器也都使用提供商前缀，因此这个对象在IE10中叫 msIndexedDB，在Firefox 4中叫</div><div class="t m0 x0 h5 y4 ff132 fs1 fc0 sc0 ls9 ws2">mozIndexedDB，在Chrome中叫webkitIndexedDB。为了清楚起见，本节示例中将使用IndexedDB，</div><div class="t m0 x0 h5 y5 ff131 fs2 fc0 sc0 ls8 ws1">而实际上每个示例前面都应该加上下面这行代码： </div><div class="t m0 x0 hb y4f ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y50 ff132 fs6 fc0 sc0 ls21 wsb">var indexedDB = window.indexedDB || window.msIndexedDB || window.mozIndexedDB || </div><div class="t m0 x0 hb y51 ff132 fs6 fc0 sc0 ls21 wsb">window.webkitIndexedDB; </div><div class="t m0 x0 hb y4577 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y3a54 ff138 fs2 fc0 sc0 ls2b wsb">IndexedDBExample01.htm </div><div class="t m0 x0 h3c y2d3c ff12f fs2 fc0 sc0 ls2e wsb">1. 数据库 </div><div class="t m0 x0 h5 y4578 ff12b fs2 fc0 sc0 ls25 wsb3">IndexedDB就是一个数据库，与MySQL或Web SQL Database等这些你以前可能用过的数据库类似。</div><div class="t m0 x0 h5 y4579 ff12b fs2 fc0 sc0 ls25 wsb3">IndexedDB最大的特色是使用对象保存数据，而不是使用表来保存数据。一个IndexedDB数据库，就是</div><div class="t m0 x0 h5 y457a ff131 fs2 fc0 sc0 ls8 ws1">一组位于相同命名空间下的对象的集合。 </div><div class="t m0 x0 h5 y457b ff131 fs2 fc0 sc0 ls8 ws1">使用IndexedDB的第一步是打开它，即把要打开的数据库名传给indexDB.open()。如果传入的</div><div class="t m0 x0 h4 y3b5 ff131 fs2 fc0 sc0 ls8 ws1">数据库已经存在，就会发送一个打开它的请求；如果传入的数据库还不存在，就会发送一个创建并打开</div><div class="t m0 x0 h1e y457c ff131 fs2 fc0 sc0 ls8 ws1">它的请求。总之，调用indexDB.open()会返回一个IDBRequest对象，在这个对象上可以添加onerror</div><div class="t m0 x0 h5 y3b7 ff131 fs2 fc0 sc0 ls2c">和onsuccess事件处理程序。先来看一个例子。 </div><div class="t m0 x0 hb y1b2 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y457d ff132 fs6 fc0 sc0 ls21 wsb">var request, database; </div><div class="t m0 x0 hb y457e ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y457f ff132 fs6 fc0 sc0 ls21 wsb">request = indexedDB.open(&quot;admin&quot;); </div><div class="t m0 x0 hb y4580 ff132 fs6 fc0 sc0 ls21 wsb">request.onerror = function(event){ </div><div class="t m0 x0 hb y4581 ff132 fs6 fc0 sc0 ls21 wsb">    alert(&quot;Something bad happened while trying to open: &quot; + </div><div class="t m0 x0 hb y4582 ff132 fs6 fc0 sc0 ls21 wsb">           event.target.errorCode); </div><div class="t m0 x0 hb y4583 ff132 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y4584 ff132 fs6 fc0 sc0 ls21 wsb">request.onsuccess = function(event){ </div><div class="t m0 x0 hb y4585 ff132 fs6 fc0 sc0 ls21 wsb">    database = event.target.result; </div><div class="t m0 x0 hb y4586 ff132 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y4587 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y600 ff138 fs2 fc0 sc0 ls2b wsb">IndexedDBExample01.htm </div><div class="t m0 x0 h4 yfce ff131 fs2 fc0 sc0 ls42 ws30">在这两个事件处理程序中，event.target都指向request对象，因此它们可以互换使用。如果响</div><div class="t m0 x0 h1e y4588 ff131 fs2 fc0 sc0 ls44 ws32">应的是onsuccess事件处理程序，那么event.target.result中将有一个数据库实例对象（IDBData- </div><div class="t m0 x0 h4 y3e05 ff132 fs1 fc0 sc0 ls43 ws31">base），这个对象会保存在database变量中。如果发生了错误，那event.target.errorCode中将</div><div class="t m0 x0 h5 y3e06 ff131 fs2 fc0 sc0 ls42 ws30">保存一个错误码，表示问题的性质。以下就是可能的错误码（这个错误码适合所有操作）。 </div><div class="t m0 x0 h5 y1260 ff130 fs1 fc0 sc0 ls2"> IDBDatabaseException.UNKNOWN_ERR(1)：意外错误，无法归类。 </div><div class="t m0 x0 h5 y4589 ff130 fs1 fc0 sc0 ls2"> IDBDatabaseException.NON_TRANSIENT_ERR(2)：操作不合法。 </div><div class="t m0 x0 h5 y458a ff130 fs1 fc0 sc0 ls2"> IDBDatabaseException.NOT_FOUND_ERR(3)：未发现要操作的数据库。 </div><div class="t m0 x0 h5 y458b ff130 fs1 fc0 sc0 ls2"> IDBDatabaseException.CONSTRAINT_ERR(4)：违反了数据库约束。 </div><div class="t m0 x0 h5 y458c ff130 fs1 fc0 sc0 ls2"> IDBDatabaseException.DATA_ERR(5)：提供给事务的数据不能满足要求。 </div><div class="t m0 x0 h5 y458d ff130 fs1 fc0 sc0 ls2"> IDBDatabaseException.NOT_ALLOWED_ERR(6)：操作不合法。 </div><div class="t m0 x0 h5 y458e ff130 fs1 fc0 sc0 ls2"> IDBDatabaseException.TRANSACTION_INACTIVE_ERR(7)：试图重用已完成的事务。 </div><div class="t m0 x0 h5 y3b39 ff130 fs1 fc0 sc0 ls2"> IDBDatabaseException.ABORT_ERR(8)：请求中断，未成功。 </div><div class="t m0 x0 h5 y386c ff130 fs1 fc0 sc0 ls2"> IDBDatabaseException.READ_ONLY_ERR(9)：试图在只读模式下写入或修改数据。 </div><div class="t m0 x0 h5 y458f ff130 fs1 fc0 sc0 ls2"> IDBDatabaseException.TIMEOUT_ERR(10)：在有效时间内未完成操作。 </div><div class="t m0 x0 h5 y4590 ff130 fs1 fc0 sc0 ls2"> IDBDatabaseException.QUOTA_ERR(11)：磁盘空间不足。 </div></div></div>
<div id="pf297" class="pf w0 h0" data-page-no="297"><div class="pc pc297 w0 h0"><div class="t m0 x2 h2 y1 ff12b fs0 fc0 sc0 ls7 ws0">23.3 数据存储    645 </div><div class="t m0 x0 h3 y2 ff12b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff137 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff137 fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ff137 fs3 fc2 sc0 ls1d wsb">16 </div><div class="t m0 x3 h8 y20 ff137 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff137 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff137 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff137 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff137 fs3 fc2 sc0 ls1d wsb">20 </div><div class="t m0 x3 h8 y25 ff137 fs3 fc2 sc0 ls1d wsb">21 </div><div class="t m0 x3 h8 y26 ff137 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff137 fs3 fc2 sc0 ls1d wsf">23 </div><div class="t m0 x3 h8 ya7a ff137 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff137 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff131 fs2 fc0 sc0 ls8 ws1">默认情况下，IndexedDB数据库是没有版本号的，最好一开始就为数据库指定一个版本号。为此，</div><div class="t m0 x0 h1e y4d ff131 fs2 fc0 sc0 ls8 ws1">可以调用setVersion()方法，传入以字符串形式表示的版本号。同样，调用这个方法也会返回一个请</div><div class="t m0 x0 h5 y5 ff131 fs2 fc0 sc0 ls8 ws1">求对象，需要你再指定事件处理程序。 </div><div class="t m0 x0 hb y6bd ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4591 ff132 fs6 fc0 sc0 ls21 wsb">if (database.version != &quot;1.0&quot;){ </div><div class="t m0 x0 hb y4592 ff132 fs6 fc0 sc0 ls21 wsb">    request = database.setVersion(&quot;1.0&quot;); </div><div class="t m0 x0 hb y4593 ff132 fs6 fc0 sc0 ls21 wsb">    request.onerror = function(event){ </div><div class="t m0 x0 hb y4594 ff132 fs6 fc0 sc0 ls21 wsb">        alert(&quot;Something bad happened while trying to set version: &quot; + </div><div class="t m0 x0 hb y4595 ff132 fs6 fc0 sc0 ls21 wsb">              event.target.errorCode); </div><div class="t m0 x0 hb y4596 ff132 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 hb y4597 ff132 fs6 fc0 sc0 ls21 wsb">    request.onsuccess = function(event){ </div><div class="t m0 x0 hb y4598 ff132 fs6 fc0 sc0 ls21 wsb">        alert(&quot;Database initialization complete. Database name: &quot; + database.name + </div><div class="t m0 x0 hb y4599 ff132 fs6 fc0 sc0 ls21 wsb">              &quot;, Version: &quot; + database.version); </div><div class="t m0 x0 hb y459a ff132 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 hb y459b ff132 fs6 fc0 sc0 ls21 wsb">} else { </div><div class="t m0 x0 hb y459c ff132 fs6 fc0 sc0 ls21 wsb">    alert(&quot;Database already initialized. Database name: &quot; + database.name + </div><div class="t m0 x0 hb y459d ff132 fs6 fc0 sc0 ls21 wsb">          &quot;, Version: &quot; + database.version); </div><div class="t m0 x0 hb y459e ff132 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x2 hf y21d ff138 fs2 fc0 sc0 ls2b wsb">IndexedDBExample01.htm </div><div class="t m0 x0 h5 y1be6 ff131 fs2 fc0 sc0 ls8 ws1">这个例子尝试把数据库的版本号设置为1.0。第一行先检测version属性，看是否已经为数据库设</div><div class="t m0 x0 h1e y3218 ff131 fs2 fc0 sc0 ls8 ws1">置了相应的版本号。如果没有，就调用setVersion()创建修改版本的请求。如果请求成功，显示一条</div><div class="t m0 x0 h4 y285e ff131 fs2 fc0 sc0 ls6 ws6">消息，表示版本修改成功。（在真实的项目开发中，你应该在这里建立对象存储空间。详细内容请看下</div><div class="t m0 x0 h5 y285f ff131 fs2 fc0 sc0 ls8 ws1">一节。） </div><div class="t m0 x0 h5 y2860 ff131 fs2 fc0 sc0 ls8 ws1">如果数据库的版本号已经被设置为1.0，则显示一条消息，说明数据库已经初始化过了。总之，通</div><div class="t m0 x0 h5 y2861 ff131 fs2 fc0 sc0 ls8 ws1">过这种模式，就能知道你想使用的数据库是否已经设置了适当的对象存储空间。在整个Web应用中，</div><div class="t m0 x0 h5 y459f ff131 fs2 fc0 sc0 ls8 ws1">随着对数据库结构的更新和修改，可能会产生很多个不同版本的数据库。 </div><div class="t m0 x0 h3c y45a0 ff12f fs2 fc0 sc0 ls2e wsb">2. 对象存储空间 </div><div class="t m0 x0 h160 y45a1 ff131 fs2 fc0 sc0 ls6 ws6">在建立了与数据库的连接之后，下一步就是使用对象存储空间①。如果数据库的版本与你传入的版</div><div class="t m0 x0 h4 y3148 ff131 fs2 fc0 sc0 ls8 ws1">本不匹配，那可能就需要创建一个新的对象存储空间。在创建对象存储空间之前，必须要想清楚你想要</div><div class="t m0 x0 h5 y45a2 ff131 fs2 fc0 sc0 ls8 ws1">保存什么数据类型。 </div><div class="t m0 x0 h5 y45a3 ff131 fs2 fc0 sc0 ls8 ws1">假设你要保存的用户记录由用户名、密码等组成，那么保存一条记录的对象应该类似如下所示： </div><div class="t m0 x0 hb yc25 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y45a4 ff132 fs6 fc0 sc0 ls21 wsb">var user = { </div><div class="t m0 x0 hb y45a5 ff132 fs6 fc0 sc0 ls21 wsb">    username: &quot;007&quot;, </div><div class="t m0 x0 hb y45a6 ff132 fs6 fc0 sc0 ls21 wsb">    firstName: &quot;James&quot;, </div><div class="t m0 x0 hb y45a7 ff132 fs6 fc0 sc0 ls21 wsb">    lastName: &quot;Bond&quot;, </div><div class="t m0 x0 hb y45a8 ff132 fs6 fc0 sc0 ls21 wsb">    password: &quot;foo&quot; </div><div class="t m0 x0 hb y45a9 ff132 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y45aa ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3c69 ff131 fs2 fc0 sc0 ls8 ws1">有了这个对象，很容易想到username属性可以作为这个对象存储空间的键。这个username必须</div><div class="t m0 x0 h4 y2854 ff131 fs2 fc0 sc0 ls8 ws1">全局唯一，而且大多数时候都要通过这个键来访问数据。这一点非常重要，因为在创建对象存储空间时，</div><div class="t m0 x0 h5 y45ab ff131 fs2 fc0 sc0 ls8 ws1">必须指定这么一个键。以下是就是为保存上述用户记录而创建对象存储空间的示例。 </div><div class="t m0 x0 hb y45ac ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y45ad ff132 fs6 fc0 sc0 ls21 wsb">var store = db.createObjectStore(&quot;users&quot;, { keyPath: &quot;username&quot; }); </div><div class="t m0 x0 hb y45ae ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1101 ff138 fs2 fc0 sc0 ls2b wsb">IndexedDBExample02.htm </div><div class="t m0 x0 h3c y13d3 ff12e fs2 fc0 sc0 ls7b wsb">—————————— </div><div class="t m0 x0 h36 ycc5 ff131 fs6 fc0 sc0 ls95">① 有关系数据库经验的读者，可以把这里的对象存储空间（object storge）想象成表，而把其中保存的对象想象成表中</div><div class="t m0 x0 h36 y3086 ff131 fs6 fc0 sc0 ls8 ws33">的记录。 </div></div></div>
<div id="pf298" class="pf w0 h0" data-page-no="298"><div class="pc pc298 w0 h0"><div class="t m0 x0 h2 y1 ff12b fs0 fc0 sc0 ls7 ws0">646  第23章 离线应用与客户端存储 </div><div class="t m0 x0 h3 y2 ff12b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ff131 fs2 fc0 sc0 ls8 ws1">其中第二个参数中的keyPath属性，就是空间中将要保存的对象的一个属性，而这个属性将作为</div><div class="t m0 x0 h5 y4d ff131 fs2 fc0 sc0 ls8 ws1">存储空间的键来使用。 </div><div class="t m0 x0 h1c yd8 ff131 fs2 fc0 sc0 ls8 ws1">好，现在有了一个对存储空间的引用。接下来可以使用add()或put()方法来向其中添加数据。这</div><div class="t m0 x0 h4 yd9 ff131 fs2 fc0 sc0 ls8 ws1">两个方法都接收一个参数，即要保存的对象，然后这个对象就会被保存到存储空间中。这两个方法的区</div><div class="t m0 x0 h1e y15d ff131 fs2 fc0 sc0 ls8 ws1">别在空间中已经包含键值相同的对象时会体现出来。在这种情况下，add()会返回错误，而put()则会</div><div class="t m0 x0 h1e y21a ff131 fs2 fc0 sc0 ls8 ws1">重写原有对象。简单地说，可以把add()想象成插入新值，把put()想象成更新原有的值。在初始化对</div><div class="t m0 x0 h5 y15e ff131 fs2 fc0 sc0 ls8 ws1">象存储空间时，可以使用类似下面这样的代码。 </div><div class="t m0 x0 hb ycf5 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 ycf6 ff132 fs6 fc0 sc0 ls21 ws34">//users中保存着一批用户对象 </div><div class="t m0 x0 hb ycf7 ff132 fs6 fc0 sc0 ls21 wsb">var i=0, </div><div class="t m0 x0 hb ycf8 ff132 fs6 fc0 sc0 ls21 wsb">    len = users.length; </div><div class="t m0 x0 hb ycf9 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb ycfa ff132 fs6 fc0 sc0 ls21 wsb">while(i &lt; len){ </div><div class="t m0 x0 hb ycfb ff132 fs6 fc0 sc0 ls21 wsb">    store.add(users[i++]); </div><div class="t m0 x0 hb ycfc ff132 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y45b0 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y20f0 ff138 fs2 fc0 sc0 ls2b wsb">IndexedDBExample02.htm </div><div class="t m0 x0 h4 y45b1 ff131 fs2 fc0 sc0 ls8 ws1">每次调用add()或put()都会创建一个新的针对这个对象存储空间的更新请求。如果想验证请求是</div><div class="t m0 x0 h1e y45b2 ff131 fs2 fc0 sc0 ls8 ws1">否成功完成，可以把返回的请求对象保存在一个变量中，然后再指定onerror或onsuccess事件处理</div><div class="t m0 x0 h5 y6cd ff131 fs2 fc0 sc0 ls8">程序。 </div><div class="t m0 x0 hb y45b3 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y45b4 ff132 fs6 fc0 sc0 ls21 ws34">//users中保存着一批用户对象 </div><div class="t m0 x0 hb y45b5 ff132 fs6 fc0 sc0 ls21 wsb">var i=0, </div><div class="t m0 x0 h15 y45b6 ff139 fs6 fc0 sc0 ls21 wsb">    request, </div><div class="t m0 x0 h15 y45b7 ff139 fs6 fc0 sc0 ls21 wsb">    requests = [], </div><div class="t m0 x0 hb y45b8 ff132 fs6 fc0 sc0 ls21 wsb">    len = users.length; </div><div class="t m0 x0 hb y45b9 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y45ba ff132 fs6 fc0 sc0 ls21 wsb">while(i &lt; len){ </div><div class="t m0 x0 h15 y45bb ff139 fs6 fc0 sc0 ls21 wsb">    request = store.add(users[i++]); </div><div class="t m0 x0 h15 y45bc ff139 fs6 fc0 sc0 ls21 wsb">    request.onerror = function(){ </div><div class="t m0 x0 h16 y45bd ff139 fs6 fc0 sc0 ls21 wsb">        //处理错误 </div><div class="t m0 x0 h15 y45be ff139 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 h15 y45bf ff139 fs6 fc0 sc0 ls21 wsb">    request.onsuccess = function(){ </div><div class="t m0 x0 h16 y45c0 ff139 fs6 fc0 sc0 ls21 wsb">        //处理成功 </div><div class="t m0 x0 h15 y45c1 ff139 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 h15 y45c2 ff139 fs6 fc0 sc0 ls21 wsb">    requests.push(request); </div><div class="t m0 x0 hb y45c3 ff132 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y45c4 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y2b9f ff131 fs2 fc0 sc0 ls8 ws1">创建了对象存储空间并向其中添加了数据之后，就该查询数据了。 </div><div class="t m0 x0 h3c y45c5 ff12f fs2 fc0 sc0 ls2e wsb">3. 事务 </div><div class="t m0 x0 h4 y45c6 ff131 fs2 fc0 sc0 ls8 ws1">跨过创建对象存储空间这一步之后，接下来的所有操作都是通过事务来完成的。在数据库对象上调</div><div class="t m0 x0 h4 y45c7 ff131 fs2 fc0 sc0 ls48e">用transaction()方法可以创建事务。任何时候，只要想读取或修改数据，都要通过事务来组织所有</div><div class="t m0 x0 h69 y45c8 ff131 fs2 fc0 sc0 ls8 ws1">操作。在最简单的情况下，可以像下面这样创建事务①。 </div><div class="t m0 x0 hb y45c9 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y45ca ff132 fs6 fc0 sc0 ls21 wsb">var transaction = db.transaction(); </div><div class="t m0 x0 hb y45cb ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y45cc ff131 fs2 fc0 sc0 ls8 ws1">如果没有参数，就只能通过事务来读取数据库中保存的对象。最常见的方式是传入要访问的一或多</div><div class="t m0 x0 h5 y45cd ff131 fs2 fc0 sc0 ls8 ws1">个对象存储空间。 </div><div class="t m0 x0 h3c y45ce ff12e fs2 fc0 sc0 ls7b wsb">—————————— </div><div class="t m0 x0 h36 ycc6 ff131 fs6 fc0 sc0 ls95">① 以下示例代码中的db即前面示例代码中的database，正文中提到的“数据库对象”也是指它。 </div></div></div>
<div id="pf299" class="pf w0 h0" data-page-no="299"><div class="pc pc299 w0 h0"><div class="t m0 x2 h2 y1 ff12b fs0 fc0 sc0 ls7 ws0">23.3 数据存储    647 </div><div class="t m0 x0 h3 y2 ff12b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff137 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff137 fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ff137 fs3 fc2 sc0 ls1d wsb">16 </div><div class="t m0 x3 h8 y20 ff137 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff137 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff137 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff137 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff137 fs3 fc2 sc0 ls1d wsb">20 </div><div class="t m0 x3 h8 y25 ff137 fs3 fc2 sc0 ls1d wsb">21 </div><div class="t m0 x3 h8 y26 ff137 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff137 fs3 fc2 sc0 ls1d wsf">23 </div><div class="t m0 x3 h8 ya7a ff137 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff137 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y79 ff132 fs6 fc0 sc0 ls21 wsb">var transaction = db.transaction(&quot;users&quot;); </div><div class="t m0 x0 hb y1b0b ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1b0c ff131 fs2 fc0 sc0 ls8 ws1">这样就能保证只加载users存储空间中的数据，以便通过事务进行访问。如果要访问多个对象存</div><div class="t m0 x0 h5 y1b0d ff131 fs2 fc0 sc0 ls8 ws1">储空间，也可以在第一个参数的位置上传入字符串数组。 </div><div class="t m0 x0 hb y45cf ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y45d0 ff132 fs6 fc0 sc0 ls21 wsb">var transaction = db.transaction([&quot;users&quot;, &quot;anotherStore&quot;]); </div><div class="t m0 x0 hb y45d1 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y23c ff131 fs2 fc0 sc0 ls8 ws1">如前所述，这些事务都是以只读方式访问数据。要修改访问方式，必须在创建事务时传入第二个参</div><div class="t m0 x0 hc y45d2 ff131 fs2 fc0 sc0 ls8 ws1">数，这个参数表示访问模式，用IDBTransaction接口定义的如下常量表示：READ_ONLY（0）表示只</div><div class="t m0 x0 hc y1b13 ff131 fs2 fc0 sc0 ls4c ws3e">读，READ_WRITE（1）表示读写，VERSION_CHANGE（2）表示改变。IE10+和Firefox 4+实现的是</div><div class="t m0 x0 h5 y45d3 ff132 fs1 fc0 sc0 ls9 ws2">IDBTransaction，但在Chrome中则叫webkitIDBTransaction，所以使用下面的代码可以统一接口： </div><div class="t m0 x0 hb y45d4 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y45d5 ff132 fs6 fc0 sc0 ls21 wsb">var IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction; </div><div class="t m0 x0 hb y45d6 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y42b ff138 fs2 fc0 sc0 ls2b wsb">IndexedDBExample03.htm </div><div class="t m0 x0 h5 ycab ff131 fs2 fc0 sc0 ls8 ws1">有了这行代码，就可以更方便地为transaction()指定第二个参数了。 </div><div class="t m0 x0 hb y260e ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y45d7 ff132 fs6 fc0 sc0 ls21 wsb">var transaction = db.transaction(&quot;users&quot;, IDBTransaction.READ_WRITE); </div><div class="t m0 x0 hb y45d8 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y45d9 ff138 fs2 fc0 sc0 ls2b wsb">IndexedDBExample03.htm </div><div class="t m0 x0 h5 y45da ff131 fs2 fc0 sc0 ls8 ws1">这个事务能够读写users存储空间。 </div><div class="t m0 x0 h1e y45db ff131 fs2 fc0 sc0 ls8 ws1">取得了事务的索引后，使用objectStore()方法并传入存储空间的名称，就可以访问特定的存储</div><div class="t m0 x0 h1e y45dc ff131 fs2 fc0 sc0 ls8 ws1">空间。然后，可以像以前一样使用add()和put()方法，使用get()可以取得值，使用delete()可以</div><div class="t m0 x0 h4 y45dd ff131 fs2 fc0 sc0 ls8 ws1">删除对象，而使用clear()则可以删除所有对象。get()和delete()方法都接收一个对象键作为参数，</div><div class="t m0 x0 h5 y45de ff131 fs2 fc0 sc0 ls8 ws1">而所有这5个方法都会返回一个新的请求对象。例如： </div><div class="t m0 x0 hb y271f ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y45df ff132 fs6 fc0 sc0 ls21 wsb">var request = db.transaction(&quot;users&quot;).objectStore(&quot;users&quot;).get(&quot;007&quot;); </div><div class="t m0 x0 hb y45e0 ff132 fs6 fc0 sc0 ls21 wsb">request.onerror = function(event){ </div><div class="t m0 x0 hb y45e1 ff132 fs6 fc0 sc0 ls21 wsb">    alert(&quot;Did not get the object!&quot;); </div><div class="t m0 x0 hb y45e2 ff132 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y45e3 ff132 fs6 fc0 sc0 ls21 wsb">request.onsuccess = function(event){ </div><div class="t m0 x0 hb y45e4 ff132 fs6 fc0 sc0 ls21 wsb">    var result = event.target.result; </div><div class="t m0 x0 hb y45e5 ff132 fs6 fc0 sc0 ls21 wsb">    alert(result.firstName);    //&quot;James&quot; </div><div class="t m0 x0 hb y45e6 ff132 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y45e7 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y45e8 ff138 fs2 fc0 sc0 ls2b wsb">IndexedDBExample02.htm </div><div class="t m0 x0 h4 y45e9 ff131 fs2 fc0 sc0 ls6f ws54">因为一个事务可以完成任何多个请求，所以事务对象本身也有事件处理程序：onerror和</div><div class="t m0 x0 h5 y45ea ff132 fs1 fc0 sc0 ls9 ws2">oncomplete。这两个事件可以提供事务级的状态信息。 </div><div class="t m0 x0 hb y45eb ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y45ec ff132 fs6 fc0 sc0 ls21 wsb">transaction.onerror = function(event){ </div><div class="t m0 x0 h16 y45ed ff132 fs6 fc0 sc0 ls21 wsb">    //整个事务都被取消了 </div><div class="t m0 x0 hb y45ee ff132 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y45ef ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y45f0 ff132 fs6 fc0 sc0 ls21 wsb">transaction.oncomplete = function(event){ </div><div class="t m0 x0 h16 y45f1 ff132 fs6 fc0 sc0 ls21 wsb">    //整个事务都成功完成了 </div><div class="t m0 x0 hb y45f2 ff132 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y45f3 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 yf8b ff131 fs2 fc0 sc0 ls8 ws1">注意，通过oncomplete事件的事件对象（event）访问不到get()请求返回的任何数据。必须在</div><div class="t m0 x0 hc y45f4 ff131 fs2 fc0 sc0 ls8 ws1">相应请求的onsuccess事件处理程序中才能访问到数据。 </div></div></div>
<div id="pf29a" class="pf w0 h0" data-page-no="29a"><div class="pc pc29a w0 h0"><div class="t m0 x0 h2 y1 ff12b fs0 fc0 sc0 ls7 ws0">648  第23章 离线应用与客户端存储 </div><div class="t m0 x0 h3 y2 ff12b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h3c y68b ff12f fs2 fc0 sc0 ls2e wsb">4. 使用游标查询 </div><div class="t m0 x0 h4 y68c ff131 fs2 fc0 sc0 ls8 ws1">使用事务可以直接通过已知的键检索单个对象。而在需要检索多个对象的情况下，则需要在事务内</div><div class="t m0 x0 h4 y15dc ff131 fs2 fc0 sc0 ls8 ws1">部创建游标。游标就是一指向结果集的指针。与传统数据库查询不同，游标并不提前收集结果。游标指</div><div class="t m0 x0 h5 y15dd ff131 fs2 fc0 sc0 ls8 ws1">针会先指向结果中的第一项，在接到查找下一项的指令时，才会指向下一项。 </div><div class="t m0 x0 hfb y15de ff131 fs2 fc0 sc0 lsa ws53">在对象存储空间上调用openCursor()方法可以创建游标。与IndexedDB 中的其他操作一样，</div><div class="t m0 x0 h4 y1ed2 ff132 fs1 fc0 sc0 ls9 ws2">openCursor()方法返回的是一个请求对象，因此必须为该对象指定onsuccess和onerror事件处理</div><div class="t m0 x0 h5 y2088 ff131 fs2 fc0 sc0 ls8 ws1">程序。例如： </div><div class="t m0 x0 hb yd44 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yd45 ff132 fs6 fc0 sc0 ls21 wsb">var store = db.transaction(&quot;users&quot;).objectStore(&quot;users&quot;), </div><div class="t m0 x0 hb yd46 ff132 fs6 fc0 sc0 ls21 wsb">    request = store.openCursor(); </div><div class="t m0 x0 hb yd47 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yd48 ff132 fs6 fc0 sc0 ls21 wsb">request.onsuccess = function(event){ </div><div class="t m0 x0 h16 yd49 ff132 fs6 fc0 sc0 ls21 wsb">    //处理成功 </div><div class="t m0 x0 hb yd4a ff132 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb yd4b ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yd4c ff132 fs6 fc0 sc0 ls21 wsb">request.onerror = function(event){ </div><div class="t m0 x0 h16 yd4d ff132 fs6 fc0 sc0 ls21 wsb">    //处理失败 </div><div class="t m0 x0 hb yd4e ff132 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y45f6 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y3b8 ff138 fs2 fc0 sc0 ls2b wsb">IndexedDBExample04.htm </div><div class="t m0 x0 h4 y7db ff131 fs2 fc0 sc0 ls2c">在onsuccess事件处理程序执行时，可以通过event.target.result取得存储空间中的下一个</div><div class="t m0 x0 h4 y45f7 ff131 fs2 fc0 sc0 ls8 ws1">对象。在结果集中有下一项时，这个属性中保存一个IDBCursor的实例，在没有下一项时，这个属性</div><div class="t m0 x0 hc y45f8 ff131 fs2 fc0 sc0 ls8 ws1">的值为null。IDBCursor的实例有以下几个属性。 </div><div class="t m0 x0 h5 y1c5d ff130 fs1 fc0 sc0 ls2"> direction：数值，表示游标移动的方向。默认值为IDBCursor.NEXT（0），表示下一项。</div><div class="t m0 x0 h5 y831 ff132 fs1 fc0 sc0 ls9 ws2">IDBCursor.NEXT_NO_DUPLICATE（1）表示下一个不重复的项，DBCursor.PREV（2）表示前</div><div class="t m0 x0 h5 y45f9 ff131 fs2 fc0 sc0 ls8 ws1">一项，而IDBCursor.PREV_NO_DUPLICATE表示前一个不重复的项。 </div><div class="t m0 x0 h5 y2299 ff130 fs1 fc0 sc0 ls2"> key：对象的键。 </div><div class="t m0 x0 h5 y229a ff130 fs1 fc0 sc0 ls2"> value：实际的对象。 </div><div class="t m0 x0 h5 y15cd ff130 fs1 fc0 sc0 ls2"> primaryKey：游标使用的键。可能是对象键，也可能是索引键（稍后讨论索引键）。 </div><div class="t m0 x0 h5 y7c5 ff131 fs2 fc0 sc0 ls8 ws1">要检索某一个结果的信息，可以像下面这样： </div><div class="t m0 x0 hb y5dd ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y45fa ff132 fs6 fc0 sc0 ls21 wsb">request.onsuccess = function(event){ </div><div class="t m0 x0 hb y45fb ff132 fs6 fc0 sc0 ls21 wsb">    var cursor = event.target.result; </div><div class="t m0 x0 h16 y45fc ff132 fs6 fc0 sc0 ls21 wsb">    if (cursor){ //必须要检查 </div><div class="t m0 x0 hb y45fd ff132 fs6 fc0 sc0 ls21 wsb">        console.log(&quot;Key: &quot; + cursor.key + &quot;, Value: &quot; + </div><div class="t m0 x0 hb y45fe ff132 fs6 fc0 sc0 ls21 wsb">                    JSON.stringify(cursor.value)); </div><div class="t m0 x0 hb y45ff ff132 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y4600 ff132 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y4601 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3a18 ff131 fs2 fc0 sc0 ls8 ws1">请记住，这个例子中的cursor.value是一个对象，这也是为什么在显示它之前先将它转换成JSON</div><div class="t m0 x0 h5 y3a19 ff131 fs2 fc0 sc0 ls8 ws1">字符串的原因。 </div><div class="t m0 x0 h1e y4602 ff131 fs2 fc0 sc0 ls8 ws1">使用游标可以更新个别的记录。调用update()方法可以用指定的对象更新当前游标的value。与</div><div class="t m0 x0 h1e y24ce ff131 fs2 fc0 sc0 ls60 ws198">其他操作一样，调用update()方法也会创建一个新请求，因此如果你想知道结果，就要为它指定</div><div class="t m0 x0 h5 ya5 ff132 fs1 fc0 sc0 ls9 ws2">onsuccess和onerror事件处理程序。 </div><div class="t m0 x0 hb y4603 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4604 ff132 fs6 fc0 sc0 ls21 wsb">request.onsuccess = function(event){ </div><div class="t m0 x0 hb y4605 ff132 fs6 fc0 sc0 ls21 wsb">    var cursor = event.target.result, </div><div class="t m0 x0 hb y4606 ff132 fs6 fc0 sc0 ls21 wsb">        value, </div></div></div>
<div id="pf29b" class="pf w0 h0" data-page-no="29b"><div class="pc pc29b w0 h0"><div class="t m0 x2 h2 y1 ff12b fs0 fc0 sc0 ls7 ws0">23.3 数据存储    649 </div><div class="t m0 x0 h3 y2 ff12b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff137 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff137 fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ff137 fs3 fc2 sc0 ls1d wsb">16 </div><div class="t m0 x3 h8 y20 ff137 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff137 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff137 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff137 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff137 fs3 fc2 sc0 ls1d wsb">20 </div><div class="t m0 x3 h8 y25 ff137 fs3 fc2 sc0 ls1d wsb">21 </div><div class="t m0 x3 h8 y26 ff137 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff137 fs3 fc2 sc0 ls1d wsf">23 </div><div class="t m0 x3 h8 ya7a ff137 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff137 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h15 y79 ff139 fs6 fc0 sc0 ls21 wsb">        updateRequest; </div><div class="t m0 x0 hb y7a ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y7b ff132 fs6 fc0 sc0 ls21 wsb">    if (cursor){ //必须要检查 </div><div class="t m0 x0 hb y7c ff132 fs6 fc0 sc0 ls21 wsb">        if (cursor.key == &quot;foo&quot;){ </div><div class="t m0 x0 h16 y7d ff139 fs6 fc0 sc0 ls21 wsb">            value = cursor.value;                   //取得当前的值 </div><div class="t m0 x0 h16 y7e ff139 fs6 fc0 sc0 ls21 wsb">            value.password = &quot;magic!&quot;;              //更新密码 </div><div class="t m0 x0 h15 y7f ff139 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y80 ff139 fs6 fc0 sc0 ls21 wsb">            updateRequest = cursor.update(value);   //请求保存更新 </div><div class="t m0 x0 h15 y81 ff139 fs6 fc0 sc0 ls21 wsb">            updateRequest.onsuccess = function(){ </div><div class="t m0 x0 h16 y82 ff139 fs6 fc0 sc0 ls21 wsb">                //处理成功 </div><div class="t m0 x0 h15 y83 ff139 fs6 fc0 sc0 ls21 wsb">            }; </div><div class="t m0 x0 h15 y84 ff139 fs6 fc0 sc0 ls21 wsb">            updateReqeust.onerror = function(){ </div><div class="t m0 x0 h16 y85 ff139 fs6 fc0 sc0 ls21 wsb">                //处理失败 </div><div class="t m0 x0 h15 y86 ff139 fs6 fc0 sc0 ls21 wsb">            }; </div><div class="t m0 x0 h15 y87 ff139 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y88 ff132 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y89 ff132 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y4607 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y246f ff131 fs2 fc0 sc0 ls8 ws1">此时，如果调用delete()方法，就会删除相应的记录。与update()一样，调用delete()也返</div><div class="t m0 x0 h5 y4608 ff131 fs2 fc0 sc0 ls8 ws1">回一个请求。 </div><div class="t m0 x0 hb y4609 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y460a ff132 fs6 fc0 sc0 ls21 wsb">request.onsuccess = function(event){ </div><div class="t m0 x0 hb y460b ff132 fs6 fc0 sc0 ls21 wsb">    var cursor = event.target.result, </div><div class="t m0 x0 hb y460c ff132 fs6 fc0 sc0 ls21 wsb">        value, </div><div class="t m0 x0 h15 y460d ff139 fs6 fc0 sc0 ls21 wsb">        deleteRequest; </div><div class="t m0 x0 hb y460e ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y460f ff132 fs6 fc0 sc0 ls21 wsb">    if (cursor){  //必须要检查 </div><div class="t m0 x0 hb y4610 ff132 fs6 fc0 sc0 ls21 wsb">        if (cursor.key == &quot;foo&quot;){ </div><div class="t m0 x0 h16 y4611 ff139 fs6 fc0 sc0 ls21 wsb">            deleteRequest = cursor.delete();     //请求删除当前项 </div><div class="t m0 x0 h15 y4612 ff139 fs6 fc0 sc0 ls21 wsb">            deleteRequest.onsuccess = function(){ </div><div class="t m0 x0 h16 y4613 ff139 fs6 fc0 sc0 ls21 wsb">                //处理成功 </div><div class="t m0 x0 h15 y4614 ff139 fs6 fc0 sc0 ls21 wsb">            }; </div><div class="t m0 x0 h15 y4615 ff139 fs6 fc0 sc0 ls21 wsb">            deleteRequest.onerror = function(){ </div><div class="t m0 x0 h16 y4616 ff139 fs6 fc0 sc0 ls21 wsb">                //处理失败 </div><div class="t m0 x0 h15 y4617 ff139 fs6 fc0 sc0 ls21 wsb">            }; </div><div class="t m0 x0 h15 y4618 ff139 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y4619 ff132 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y461a ff132 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y461b ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y2e64 ff131 fs2 fc0 sc0 ls8 ws1">如果当前事务没有修改对象存储空间的权限，update()和delete()会抛出错误。 </div><div class="t m0 x0 h5 y2e65 ff131 fs2 fc0 sc0 ls8 ws1">默认情况下，每个游标只发起一次请求。要想发起另一次请求，必须调用下面的一个方法。 </div><div class="t m0 x0 h4 y461c ff130 fs1 fc0 sc0 ls2"> continue(key)：移动到结果集中的下一项。参数key是可选的，不指定这个参数，游标移动</div><div class="t m0 x5 h5 y2e67 ff131 fs2 fc0 sc0 ls8 ws1">到下一项；指定这个参数，游标会移动到指定键的位置。 </div><div class="t m0 x0 h5 y21d0 ff130 fs1 fc0 sc0 ls2"> advance(count)：向前移动count指定的项数。 </div><div class="t m0 x0 h1e y461d ff131 fs2 fc0 sc0 ls8 ws1">这两个方法都会导致游标使用相同的请求，因此相同的onsuccess和onerror事件处理程序也会</div><div class="t m0 x0 h5 y461e ff131 fs2 fc0 sc0 ls8 ws1">得到重用。例如，下面的例子遍历了对象存储空间中的所有项。 </div><div class="t m0 x0 hb y37ab ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y461f ff132 fs6 fc0 sc0 ls21 wsb">request.onsuccess = function(event){ </div><div class="t m0 x0 hb y4620 ff132 fs6 fc0 sc0 ls21 wsb">    var cursor = event.target.result; </div><div class="t m0 x0 h16 y4621 ff132 fs6 fc0 sc0 ls21 wsb">    if (cursor){ //必须要检查 </div><div class="t m0 x0 hb y4622 ff132 fs6 fc0 sc0 ls21 wsb">        console.log(&quot;Key: &quot; + cursor.key + &quot;, Value: &quot; + </div><div class="t m0 x0 hb y4623 ff132 fs6 fc0 sc0 ls21 wsb">                    JSON.stringify(cursor.value)); </div><div class="t m0 x0 h16 y4624 ff139 fs6 fc0 sc0 ls21 wsb">        cursor.continue(); //移动到下一项 </div><div class="t m0 x0 h15 y4625 ff139 fs6 fc0 sc0 ls21 wsb">    } else { </div><div class="t m0 x0 h15 y4626 ff139 fs6 fc0 sc0 ls21 wsb">        console.log(&quot;Done!&quot;); </div></div></div>
<div id="pf29c" class="pf w0 h0" data-page-no="29c"><div class="pc pc29c w0 h0"><div class="t m0 x0 h2 y1 ff12b fs0 fc0 sc0 ls7 ws0">650  第23章 离线应用与客户端存储 </div><div class="t m0 x0 h3 y2 ff12b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y79 ff139 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y7a ff132 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y1c6a ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1c6b ff131 fs2 fc0 sc0 ls8 ws1">调用continue()会触发另一次请求，进而再次调用onsuccess事件处理程序。在没有更多项可</div><div class="t m0 x0 hc y1e20 ff131 fs2 fc0 sc0 ls8 ws1">以迭代时，将最后一次调用onsuccess事件处理程序，此时event.target.result的值为 null。 </div><div class="t m0 x0 h3c y4627 ff12f fs2 fc0 sc0 ls2e wsb">5. 键范围 </div><div class="t m0 x0 h5 y4628 ff131 fs2 fc0 sc0 ls8 ws1">使用游标总让人觉得不那么理想，因为通过游标查找数据的方式太有限了。键范围（key range）为</div><div class="t m0 x0 h4 y4629 ff131 fs2 fc0 sc0 ls8 ws1">使用游标增添了一些灵活性。键范围由IDBKeyRange的实例表示。支持标准IDBKeyRange类型 的浏</div><div class="t m0 x0 hc y693 ff131 fs2 fc0 sc0 ls8 ws1">览器有IE10+和Firefox 4+，Chrome中的名字叫webkitIDBKeyRange。与使用IndexedDB中的其他类</div><div class="t m0 x0 h5 y37b6 ff131 fs2 fc0 sc0 ls8 ws1">型一样，你最好先声明一个本地的类型，同时要考虑到不同浏览器中的差异。 </div><div class="t m0 x0 hb y462a ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y462b ff132 fs6 fc0 sc0 ls21 wsb">var IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange; </div><div class="t m0 x0 hb y462c ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y462d ff131 fs2 fc0 sc0 ls8 ws1">有四种定义键范围的方式。第一种是使用only()方法，传入你想要取得的对象的键。 </div><div class="t m0 x0 hb y462e ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y462f ff132 fs6 fc0 sc0 ls21 wsb">var onlyRange = IDBKeyRange.only(&quot;007&quot;); </div><div class="t m0 x0 hb y4630 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y4631 ff131 fs2 fc0 sc0 ls8 ws1">这个范围可以保证只取得键为&quot;007&quot;的对象。使用这个范围创建的游标与直接访问存储空间并调用</div><div class="t m0 x0 h5 y4632 ff132 fs1 fc0 sc0 ls9 ws2">get(&quot;007&quot;)差不多。 </div><div class="t m0 x0 h4 y4633 ff131 fs2 fc0 sc0 ls8 ws1">第二种定义键范围的方式是指定结果集的下界。下界表示游标开始的位置。例如，以下键范围可以</div><div class="t m0 x0 he y4634 ff131 fs2 fc0 sc0 ls8 ws1">保证游标从键为&quot;007&quot;的对象开始，然后继续向前移动，直至最后一个对象。 </div><div class="t m0 x0 hb y2943 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4635 ff132 fs6 fc0 sc0 ls21">//从键为&quot;007&quot;的对象开始，然后可以移动到最后 </div><div class="t m0 x0 hb y4636 ff132 fs6 fc0 sc0 ls21 wsb">var lowerRange = IDBKeyRange.lowerBound(&quot;007&quot;); </div><div class="t m0 x0 hb y4637 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1117 ff131 fs2 fc0 sc0 ls8 ws1">如果你想忽略键为&quot;007&quot;的对象，从它的下一个对象开始，那么可以传入第二个参数true： </div><div class="t m0 x0 hb y1f02 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4638 ff132 fs6 fc0 sc0 ls21">//从键为&quot;007&quot;的对象的下一个对象开始，然后可以移动到最后 </div><div class="t m0 x0 hb y4639 ff132 fs6 fc0 sc0 ls21 wsb">var lowerRange = IDBKeyRange.lowerBound(&quot;007&quot;, true); </div><div class="t m0 x0 hb y463a ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y2346 ff131 fs2 fc0 sc0 ls24 ws1e">第三种定义键范围的方式是指定结果集的上界，也就是指定游标不能超越哪个键。指定上界使用</div><div class="t m0 x0 h5 y2bba ff132 fs1 fc0 sc0 ls9 ws2">upperRange()方法。下面这个键范围可以保证游标从头开始，到取得键为&quot;ace&quot;的对象终止。 </div><div class="t m0 x0 hb y463b ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y463c ff132 fs6 fc0 sc0 ls21">//从头开始，到键为&quot;ace&quot;的对象为止 </div><div class="t m0 x0 hb y463d ff132 fs6 fc0 sc0 ls21 wsb">var upperRange = IDBKeyRange.upperBound(&quot;ace&quot;); </div><div class="t m0 x0 hb y463e ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y463f ff131 fs2 fc0 sc0 ls8 ws1">如果你不想包含键为指定值的对象，同样，传入第二个参数true： </div><div class="t m0 x0 hb y345 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4640 ff132 fs6 fc0 sc0 ls21">//从头开始，到键为&quot;ace&quot;的对象的上一个对象为止 </div><div class="t m0 x0 hb y4641 ff132 fs6 fc0 sc0 ls21 wsb">var upperRange = IDBKeyRange.upperBound(&quot;ace&quot;, true); </div><div class="t m0 x0 hb y4642 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y4643 ff131 fs2 fc0 sc0 ls8 ws1">第四种定义键范围的方式——没错，就是同时指定上、下界，使用bound()方法。这个方法可以接</div><div class="t m0 x0 h5 y4644 ff131 fs2 fc0 sc0 ls3b">收4个参数：表示下界的键、表示上界的键、可选的表示是否跳过下界的布尔值和可选的表示是否跳过</div><div class="t m0 x0 h5 y4645 ff131 fs2 fc0 sc0 ls8 ws1">上界的布尔值。以下是几个例子。 </div><div class="t m0 x0 hb y4646 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4647 ff132 fs6 fc0 sc0 ls21">//从键为&quot;007&quot;的对象开始，到键为&quot;ace&quot;的对象为止 </div><div class="t m0 x0 hb y4648 ff132 fs6 fc0 sc0 ls21 wsb">var boundRange = IDBKeyRange.bound(&quot;007&quot;, &quot;ace&quot;); </div><div class="t m0 x0 hb y4649 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y464a ff132 fs6 fc0 sc0 ls21">//从键为&quot;007&quot;的对象的下一个对象开始，到键为&quot;ace&quot;的对象为止 </div><div class="t m0 x0 hb y464b ff132 fs6 fc0 sc0 ls21 wsb">var boundRange = IDBKeyRange.bound(&quot;007&quot;, &quot;ace&quot;, true); </div><div class="t m0 x0 hb y464c ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y464d ff132 fs6 fc0 sc0 ls21">//从键为&quot;007&quot;的对象的下一个对象开始，到键为&quot;ace&quot;的对象的上一个对象为止 </div><div class="t m0 x0 hb y464e ff132 fs6 fc0 sc0 ls21 wsb">var boundRange = IDBKeyRange.bound(&quot;007&quot;, &quot;ace&quot;, true, true); </div><div class="t m0 x0 hb y464f ff132 fs6 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf29d" class="pf w0 h0" data-page-no="29d"><div class="pc pc29d w0 h0"><div class="t m0 x2 h2 y1 ff12b fs0 fc0 sc0 ls7 ws0">23.3 数据存储    651 </div><div class="t m0 x0 h3 y2 ff12b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff137 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff137 fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ff137 fs3 fc2 sc0 ls1d wsb">16 </div><div class="t m0 x3 h8 y20 ff137 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff137 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff137 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff137 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff137 fs3 fc2 sc0 ls1d wsb">20 </div><div class="t m0 x3 h8 y25 ff137 fs3 fc2 sc0 ls1d wsb">21 </div><div class="t m0 x3 h8 y26 ff137 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff137 fs3 fc2 sc0 ls1d wsf">23 </div><div class="t m0 x3 h8 ya7a ff137 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff137 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h16 y79 ff132 fs6 fc0 sc0 ls21">//从键为&quot;007&quot;的对象开始，到键为&quot;ace&quot;的对象的上一个对象为止 </div><div class="t m0 x0 hb y7a ff132 fs6 fc0 sc0 ls21 wsb">var boundRange = IDBKeyRange.bound(&quot;007&quot;, &quot;ace&quot;, false, true); </div><div class="t m0 x0 hb y1c6a ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1c6b ff131 fs2 fc0 sc0 ls8 ws1">无论如何，在定义键范围之后，把它传给openCursor()方法，就能得到一个符合相应约束条件的</div><div class="t m0 x0 h5 y1e20 ff131 fs2 fc0 sc0 ls8">游标。 </div><div class="t m0 x0 hb y3ab2 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y3ab3 ff132 fs6 fc0 sc0 ls21 wsb">var store = db.transaction(&quot;users&quot;).objectStore(&quot;users&quot;), </div><div class="t m0 x0 hb y4650 ff132 fs6 fc0 sc0 ls21 wsb">    range = IDBKeyRange.bound(&quot;007&quot;, &quot;ace&quot;); </div><div class="t m0 x0 h15 y4651 ff139 fs6 fc0 sc0 ls21 wsb">    request = store.openCursor(range); </div><div class="t m0 x0 hb y4652 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4653 ff132 fs6 fc0 sc0 ls21 wsb">request.onsuccess = function(event){ </div><div class="t m0 x0 hb y4654 ff132 fs6 fc0 sc0 ls21 wsb">    var cursor = event.target.result; </div><div class="t m0 x0 h16 y4655 ff132 fs6 fc0 sc0 ls21 wsb">    if (cursor){ //必须要检查 </div><div class="t m0 x0 hb y4656 ff132 fs6 fc0 sc0 ls21 wsb">        console.log(&quot;Key: &quot; + cursor.key + &quot;, Value: &quot; + </div><div class="t m0 x0 hb y4657 ff132 fs6 fc0 sc0 ls21 wsb">                    JSON.stringify(cursor.value)); </div><div class="t m0 x0 h16 y4658 ff139 fs6 fc0 sc0 ls21 wsb">        cursor.continue(); //移动到下一项 </div><div class="t m0 x0 h15 y4659 ff139 fs6 fc0 sc0 ls21 wsb">    } else { </div><div class="t m0 x0 hb y465a ff139 fs6 fc0 sc0 ls21 wsb">        console.log(&quot;Done!&quot;); </div><div class="t m0 x0 h15 y465b ff139 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y465c ff132 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y465d ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y28d5 ff131 fs2 fc0 sc0 ls8 ws1">这个例子输出的对象的键为&quot;007&quot;到&quot;ace&quot;，比上一节最后那个例子输出的值少一些。 </div><div class="t m0 x0 h3c y465e ff12f fs2 fc0 sc0 ls2e wsb">6. 设定游标方向 </div><div class="t m0 x0 h4 y465f ff131 fs2 fc0 sc0 ls8 ws1">实际上，openCursor()可以接收两个参数。第一个参数就是刚刚看到的IDBKeyRange的实例，</div><div class="t m0 x0 h1e y4660 ff131 fs2 fc0 sc0 ls8 ws1">第二个是表示方向的数值常量。作为第二个参数的常量是前面讲查询时介绍的IDBCursor中的常量。</div><div class="t m0 x0 h5 y4661 ff12b fs2 fc0 sc0 ls47 ws60">Fire fox4 +和Chrome的实现又有不同，因此第一步还是在本地消除差异： </div><div class="t m0 x0 hb y365 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4662 ff132 fs6 fc0 sc0 ls21 wsb">var IDBCursor = window.IDBCursor || window.webkitIDBCursor; </div><div class="t m0 x0 hb y4663 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y4664 ff131 fs2 fc0 sc0 ls8 ws1">正常情况下，游标都是从存储空间的第一项开始，调用continue()或advance()前进到最后一</div><div class="t m0 x0 h1e y3e5 ff131 fs2 fc0 sc0 ls8 ws1">项。游标的默认方向值是IDBCursor.NEXT。如果对象存储空间中有重复的项，而你想让游标跳过那些</div><div class="t m0 x0 hc y4665 ff131 fs2 fc0 sc0 ls8 ws1">重复的项，可以为openCursor传入IDBCursor.NEXT_NO_DUPLICATE作为第二个参数： </div><div class="t m0 x0 hb y3762 ff132 fs6 fc0 sc0 ls21 wsb">var store = db.transaction(&quot;users&quot;).objectStore(&quot;users&quot;), </div><div class="t m0 x0 hb y4666 ff132 fs6 fc0 sc0 ls21 wsb">    request = store.openCursor(null, IDBCursor.NEXT_NO_DUPLICATE); </div><div class="t m0 x0 h4 y4667 ff131 fs2 fc0 sc0 ls6 ws6">注意，openCursor()的第一个参数是null，表示使用默认的键范围，即包含所有对象。这个游</div><div class="t m0 x0 h5 y4668 ff131 fs2 fc0 sc0 ls8 ws1">标可以从存储空间中的第一个对象开始，逐个迭代到最后一个对象——但会跳过重复的对象。 </div><div class="t m0 x0 h4 y4669 ff131 fs2 fc0 sc0 ls24 ws1e">当然，也可以创建一个游标，让它在对象存储空间中向后移动，即从最后一个对象开始，逐个迭</div><div class="t m0 x0 h4b y466a ff131 fs2 fc0 sc0 ls5 ws4">代，直至第一个对象。此时，要传入的常量是 IDBCursor.PREV和IDBCursor.PREV_NO_DUPLICATE。</div><div class="t m0 x0 h5 y466b ff131 fs2 fc0 sc0 ls5">例如： </div><div class="t m0 x0 hb y2cbd ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y466c ff132 fs6 fc0 sc0 ls21 wsb">var store = db.transaction(&quot;users&quot;).objectStore(&quot;users&quot;), </div><div class="t m0 x0 h15 y466d ff139 fs6 fc0 sc0 ls21 wsb">    request = store.openCursor(null, IDBCursor.PREV); </div><div class="t m0 x0 hb y466e ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf ycc2 ff138 fs2 fc0 sc0 ls2b wsb">IndexedDBExample05.htm </div><div class="t m0 x0 h4 y466f ff131 fs2 fc0 sc0 ls8 ws1">使用IDBCursor.PREV或IDBCursor.PREV_NO_DUPLICATE打开游标时，每次调用continue()</div><div class="t m0 x0 h5 y4670 ff131 fs2 fc0 sc0 ls2c">或advance()，都会在存储空间中向后而不是向前移动游标。 </div><div class="t m0 x0 h3c y4671 ff12f fs2 fc0 sc0 ls2e wsb">7. 索引 </div><div class="t m0 x0 h5 y4672 ff131 fs2 fc0 sc0 ls8 ws1">对于某些数据，可能需要为一个对象存储空间指定多个键。比如，若要通过用户ID和用户名两种</div><div class="t m0 x0 h5 y4673 ff131 fs2 fc0 sc0 ls8 ws1">方式来保存用户资料，就需要通过这两个键来存取记录。为此，可以考虑将用户ID作为主键，然后为</div></div></div>
<div id="pf29e" class="pf w0 h0" data-page-no="29e"><div class="pc pc29e w0 h0"><div class="t m0 x0 h2 y1 ff12b fs0 fc0 sc0 ls7 ws0">652  第23章 离线应用与客户端存储 </div><div class="t m0 x0 h3 y2 ff12b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff131 fs2 fc0 sc0 ls8 ws1">用户名创建索引。 </div><div class="t m0 x0 hc y4d ff131 fs2 fc0 sc0 ls8 ws1">要创建索引，首先引用对象存储空间，然后调用createIndex()方法，如下所示。 </div><div class="t m0 x0 hb y4674 ff132 fs6 fc0 sc0 ls21 wsb">var store = db.transaction(&quot;users&quot;).objectStore(&quot;users&quot;), </div><div class="t m0 x0 h163 y4675 ff139 fs6 fc0 sc0 ls21 wsb">    index = store.createIndex(&quot;username&quot;, &quot;username&quot;, { unique: false}); </div><div class="t m0 x0 h4 y4676 ff132 fs1 fc0 sc0 ls9 ws2">createIndex()的第一个参数是索引的名字，第二个参数是索引的属性的名字，第三个参数是一</div><div class="t m0 x0 h1e y4677 ff131 fs2 fc0 sc0 ls8 ws1">个包含unique属性的选项（options）对象。这个选项通常都必须指定，因为它表示键在所有记录中</div><div class="t m0 x0 h5 y4678 ff131 fs2 fc0 sc0 ls8 ws1">是否唯一。因为username有可能重复，所以这个索引不是唯一的。 </div><div class="t m0 x0 h4 y2e51 ff132 fs1 fc0 sc0 ls9 ws2">createIndex()的返回值是IDBIndex的实例。在对象存储空间上调用index()方法也能返回同</div><div class="t m0 x0 h5 y4679 ff131 fs2 fc0 sc0 ls8 ws1">一个实例。例如，要使用一个已经存在的名为&quot;username&quot;的索引，可以像下面这样取得该索引。 </div><div class="t m0 x0 hb y2966 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y467a ff132 fs6 fc0 sc0 ls21 wsb">var store = db.transaction(&quot;users&quot;).objectStore(&quot;users&quot;), </div><div class="t m0 x0 h15 y467b ff139 fs6 fc0 sc0 ls21 wsb">    index = store.index(&quot;username&quot;); </div><div class="t m0 x0 hb y467c ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y467d ff131 fs2 fc0 sc0 ls8 ws1">索引其实与对象存储空间很相似。在索引上调用openCursor()方法也可以创建新的游标，除了将</div><div class="t m0 x0 h4 y2ca6 ff131 fs2 fc0 sc0 ls24 ws1e">来会把索引键而非主键保存在event.result.key属性中之外，这个游标与在对象存储空间上调用</div><div class="t m0 x0 h5 y467e ff132 fs1 fc0 sc0 ls9 ws2">openCursor()返回的游标完全一样。来看下面的例子。 </div><div class="t m0 x0 hb y467f ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4680 ff132 fs6 fc0 sc0 ls21 wsb">var store = db.transaction(&quot;users&quot;).objectStore(&quot;users&quot;), </div><div class="t m0 x0 h15 y4681 ff139 fs6 fc0 sc0 ls21 wsb">    index = store.index(&quot;username&quot;), </div><div class="t m0 x0 h15 y4682 ff139 fs6 fc0 sc0 ls21 wsb">    request = index.openCursor(); </div><div class="t m0 x0 hb y4683 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4684 ff132 fs6 fc0 sc0 ls21 wsb">request.onsuccess = function(event){ </div><div class="t m0 x0 h16 y4685 ff132 fs6 fc0 sc0 ls21 wsb">    //处理成功 </div><div class="t m0 x0 hb y4686 ff132 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y4687 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y4688 ff131 fs2 fc0 sc0 ls8 ws1">在索引上也能创建一个特殊的只返回每条记录主键的游标，那就要调用openKeyCursor()方法。</div><div class="t m0 x0 h1e y4689 ff131 fs2 fc0 sc0 ls8 ws1">这个方法接收的参数与openCursor()相同。而最大的不同在于，这种情况下event.result.key中</div><div class="t m0 x0 hc y468a ff131 fs2 fc0 sc0 ls8 ws1">仍然保存着索引键，而event.result.value中保存的则是主键，而不再是整个对象。 </div><div class="t m0 x0 hb y2a1a ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y468b ff132 fs6 fc0 sc0 ls21 wsb">var store = db.transaction(&quot;users&quot;).objectStore(&quot;users&quot;), </div><div class="t m0 x0 h15 y468c ff139 fs6 fc0 sc0 ls21 wsb">    index = store.index(&quot;username&quot;), </div><div class="t m0 x0 h15 y468d ff139 fs6 fc0 sc0 ls21 wsb">    request = index.openKeyCursor(); </div><div class="t m0 x0 hb y468e ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y468f ff132 fs6 fc0 sc0 ls21 wsb">request.onsuccess = function(event){ </div><div class="t m0 x0 h16 y4690 ff132 fs6 fc0 sc0 ls21 wsb">    //处理成功 </div><div class="t m0 x0 h16 y4691 ff132 fs6 fc0 sc0 ls21 wsb">    // event.result.key中保存索引键，而event.result.value中保存主键 </div><div class="t m0 x0 hb y4692 ff132 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y4693 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y4694 ff131 fs2 fc0 sc0 ls8 ws1">同样，使用get()方法能够从索引中取得一个对象，只要传入相应的索引键即可；当然，这个方法</div><div class="t m0 x0 h5 y4695 ff131 fs2 fc0 sc0 ls8 ws1">也将返回一个请求。 </div><div class="t m0 x0 hb y4696 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4697 ff132 fs6 fc0 sc0 ls21 wsb">var store = db.transaction(&quot;users&quot;).objectStore(&quot;users&quot;), </div><div class="t m0 x0 h15 y4698 ff139 fs6 fc0 sc0 ls21 wsb">    index = store.index(&quot;username&quot;), </div><div class="t m0 x0 h15 y4699 ff139 fs6 fc0 sc0 ls21 wsb">    request = index.get(&quot;007&quot;); </div><div class="t m0 x0 hb y469a ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y469b ff132 fs6 fc0 sc0 ls21 wsb">request.onsuccess = function(event){ </div><div class="t m0 x0 h16 y469c ff132 fs6 fc0 sc0 ls21 wsb">    //处理成功 </div><div class="t m0 x0 hb y469d ff132 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y469e ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y469f ff132 fs6 fc0 sc0 ls21 wsb">request.onerror = function(event){ </div><div class="t m0 x0 h16 y46a0 ff132 fs6 fc0 sc0 ls21 wsb">    //处理失败 </div><div class="t m0 x0 hb y46a1 ff132 fs6 fc0 sc0 ls21 wsb">}; </div></div></div>
<div id="pf29f" class="pf w0 h0" data-page-no="29f"><div class="pc pc29f w0 h0"><div class="t m0 x2 h2 y1 ff12b fs0 fc0 sc0 ls7 ws0">23.3 数据存储    653 </div><div class="t m0 x0 h3 y2 ff12b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff137 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff137 fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ff137 fs3 fc2 sc0 ls1d wsb">16 </div><div class="t m0 x3 h8 y20 ff137 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff137 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff137 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff137 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff137 fs3 fc2 sc0 ls1d wsb">20 </div><div class="t m0 x3 h8 y25 ff137 fs3 fc2 sc0 ls1d wsb">21 </div><div class="t m0 x3 h8 y26 ff137 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff137 fs3 fc2 sc0 ls1d wsf">23 </div><div class="t m0 x3 h8 ya7a ff137 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff137 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y866 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y46a2 ff131 fs2 fc0 sc0 ls24 ws1e">要根据给定的索引键取得主键，可以使用getKey()方法。这个方法也会创建一个新的请求，但</div><div class="t m0 x0 h5 y318d ff132 fs1 fc0 sc0 ls9 ws2">event.result.value等于主键的值，而不是包含整个对象。 </div><div class="t m0 x0 hb y46a3 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y46a4 ff132 fs6 fc0 sc0 ls21 wsb">var store = db.transaction(&quot;users&quot;).objectStore(&quot;users&quot;), </div><div class="t m0 x0 h15 y46a5 ff139 fs6 fc0 sc0 ls21 wsb">    index = store.index(&quot;username&quot;), </div><div class="t m0 x0 h15 y46a6 ff139 fs6 fc0 sc0 ls21 wsb">    request = index.getKey(&quot;007&quot;); </div><div class="t m0 x0 hb y46a7 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y46a8 ff132 fs6 fc0 sc0 ls21 wsb">request.onsuccess = function(event){ </div><div class="t m0 x0 h16 y46a9 ff132 fs6 fc0 sc0 ls21 wsb">    //处理成功 </div><div class="t m0 x0 h16 y46aa ff132 fs6 fc0 sc0 ls21 wsb">    //event.result.key中保存索引键，而event.result.value中保存主键 </div><div class="t m0 x0 hb y46ab ff132 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y46ac ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y8ca ff131 fs2 fc0 sc0 ls8 ws1">在这个例子的onsuccess事件处理程序中，event.result.value中保存的是用户ID。 </div><div class="t m0 x0 hc y128d ff131 fs2 fc0 sc0 ls8 ws1">任何时候，通过IDBIndex对象的下列属性都可以取得有关索引的相关信息。 </div><div class="t m0 x0 h5 y8cc ff130 fs1 fc0 sc0 ls2"> name：索引的名字。 </div><div class="t m0 x0 h5 y8cd ff130 fs1 fc0 sc0 ls2"> keyPath：传入createIndex()中的属性路径。 </div><div class="t m0 x0 h5 y46ad ff130 fs1 fc0 sc0 ls2"> objectStore：索引的对象存储空间。 </div><div class="t m0 x0 h5 y187a ff130 fs1 fc0 sc0 ls2"> unique：表示索引键是否唯一的布尔值。 </div><div class="t m0 x0 h1e y187b ff131 fs2 fc0 sc0 ls8 ws1">另外，通过对象存储对象的indexName属性可以访问到为该空间建立的所有索引。通过以下代码</div><div class="t m0 x0 h5 y46ae ff131 fs2 fc0 sc0 ls8 ws1">就可以知道根据存储的对象建立了哪些索引。 </div><div class="t m0 x0 hb yeb9 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y46af ff132 fs6 fc0 sc0 ls21 wsb">var store = db.transaction(&quot;users&quot;).objectStore(&quot;users&quot;), </div><div class="t m0 x0 h15 y46b0 ff139 fs6 fc0 sc0 ls21 wsb">    indexNames = store.indexNames, </div><div class="t m0 x0 h15 y46b1 ff139 fs6 fc0 sc0 ls21 wsb">    index, </div><div class="t m0 x0 h15 y46b2 ff139 fs6 fc0 sc0 ls21 wsb">    i = 0, </div><div class="t m0 x0 h15 y46b3 ff139 fs6 fc0 sc0 ls21 wsb">    len = indexNames.length; </div><div class="t m0 x0 h15 y46b4 ff139 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y46b5 ff139 fs6 fc0 sc0 ls21 wsb">while(i &lt; len){ </div><div class="t m0 x0 h15 y46b6 ff139 fs6 fc0 sc0 ls21 wsb">    index = store.index(indexNames[i++]); </div><div class="t m0 x0 h15 y46b7 ff139 fs6 fc0 sc0 ls21 wsb">    console.log(&quot;Index name: &quot; + index.name + &quot;, KeyPath: &quot; + index.keyPath + </div><div class="t m0 x0 h15 y46b8 ff139 fs6 fc0 sc0 ls21 wsb">        &quot;, Unique: &quot; + index.unique); </div><div class="t m0 x0 h15 y46b9 ff139 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y46ba ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y46bb ff131 fs2 fc0 sc0 ls8 ws1">以上代码遍历了每个索引，在控制台中输出了它们的信息。 </div><div class="t m0 x0 hc y46bc ff131 fs2 fc0 sc0 ls8 ws1">在对象存储空间上调用deleteIndex()方法并传入索引的名字可以删除索引。 </div><div class="t m0 x0 hb y46bd ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y46be ff132 fs6 fc0 sc0 ls21 wsb">var store = db.transaction(&quot;users&quot;).objectStore(&quot;users&quot;); </div><div class="t m0 x0 h15 y46bf ff139 fs6 fc0 sc0 ls21 wsb">store.deleteIndex(&quot;username&quot;); </div><div class="t m0 x0 hb y46c0 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y23c8 ff131 fs2 fc0 sc0 ls8 ws1">因为删除索引不会影响对象存储空间中的数据，所以这个操作没有任何回调函数。 </div><div class="t m0 x0 h3c y46c1 ff12f fs2 fc0 sc0 ls2e wsb">8. 并发问题 </div><div class="t m0 x0 h5 y46c2 ff131 fs2 fc0 sc0 ls8 ws1">虽然网页中的IndexedDB提供的是异步API，但仍然存在并发操作的问题。如果浏览器的两个不同</div><div class="t m0 x0 h4 y46c3 ff131 fs2 fc0 sc0 ls8 ws1">的标签页打开了同一个页面，那么一个页面试图更新另一个页面尚未准备就绪的数据库的问题就有可能</div><div class="t m0 x0 h4 y46c4 ff131 fs2 fc0 sc0 ls8 ws1">发生。把数据库设置为新版本有可能导致这个问题。因此，只有当浏览器中仅有一个标签页使用数据库</div><div class="t m0 x0 h67 y46c5 ff131 fs2 fc0 sc0 ls8 ws1">的情况下，调用setVersion()才能完成操作。 </div><div class="t m0 x0 h4 y46c6 ff131 fs2 fc0 sc0 ls8 ws1">刚打开数据库时，要记着指定onversionchange事件处理程序。当同一个来源的另一个标签页调</div><div class="t m0 x0 h1e y46c7 ff131 fs2 fc0 sc0 ls2cf">用setVersion()时，就会执行这个回调函数。处理这个事件的最佳方式是立即关闭数据库，从而保证</div><div class="t m0 x0 h5 yd6 ff131 fs2 fc0 sc0 ls8 ws1">版本更新顺利完成。例如： </div><div class="t m0 x0 hb yaec ff132 fs6 fc0 sc0 ls8 wsb">  </div></div></div>
<div id="pf2a0" class="pf w0 h0" data-page-no="2a0"><div class="pc pc2a0 w0 h0"><div class="t m0 x0 h2 y1 ff12b fs0 fc0 sc0 ls7 ws0">654  第23章 离线应用与客户端存储 </div><div class="t m0 x0 h3 y2 ff12b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 ff132 fs6 fc0 sc0 ls21 wsb">var request, database; </div><div class="t m0 x0 hb y7a ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y7b ff132 fs6 fc0 sc0 ls21 wsb">request = indexedDB.open(&quot;admin&quot;); </div><div class="t m0 x0 hb y7c ff132 fs6 fc0 sc0 ls21 wsb">request.onsuccess = function(event){  </div><div class="t m0 x0 hb y7d ff132 fs6 fc0 sc0 ls21 wsb">    database = event.target.result; </div><div class="t m0 x0 hb y7e ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y7f ff139 fs6 fc0 sc0 ls21 wsb">    database.onversionchange = function(){ </div><div class="t m0 x0 h15 y80 ff139 fs6 fc0 sc0 ls21 wsb">        database.close(); </div><div class="t m0 x0 h15 y81 ff139 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 hb y82 ff132 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y310c ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y28ce ff131 fs2 fc0 sc0 ls8 ws1">每次成功打开数据库，都应该指定onversionchange事件处理程序。 </div><div class="t m0 x0 h1e y28cf ff131 fs2 fc0 sc0 ls8 ws1">调用setVersion()时，指定请求的onblocked事件处理程序也很重要。在你想要更新数据库的</div><div class="t m0 x0 h4 y1b17 ff131 fs2 fc0 sc0 ls8 ws1">版本但另一个标签页已经打开数据库的情况下，就会触发这个事件处理程序。此时，最好先通知用户关</div><div class="t m0 x0 hc y46c8 ff131 fs2 fc0 sc0 ls8 ws1">闭其他标签页，然后再重新调用setVersion()。例如： </div><div class="t m0 x0 hb y4398 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y46c9 ff132 fs6 fc0 sc0 ls21 wsb">var request = database.setVersion(&quot;2.0&quot;); </div><div class="t m0 x0 hb y46ca ff132 fs6 fc0 sc0 ls21 wsb">request.onblocked = function(){ </div><div class="t m0 x0 hb y46cb ff132 fs6 fc0 sc0 ls21 wsb">    alert(&quot;Please close all other tabs and try again.&quot;); </div><div class="t m0 x0 hb y46cc ff132 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y46cd ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y46ce ff132 fs6 fc0 sc0 ls21 wsb">request.onsuccess = function(){ </div><div class="t m0 x0 h16 y46cf ff132 fs6 fc0 sc0 ls21 wsb">    //处理成功，继续 </div><div class="t m0 x0 hb y46d0 ff132 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y46d1 ff132 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y7bd ff131 fs2 fc0 sc0 ls8 ws1">请记住，其他标签页中的onversionchange事件处理程序也会执行。 </div><div class="t m0 x0 h5 y46d2 ff131 fs2 fc0 sc0 ls8 ws1">通过指定这些事件处理程序，就能确保你的Web应用妥善地处理好IndexedDB的并发问题。 </div><div class="t m0 x0 h3c y46d3 ff12f fs2 fc0 sc0 ls2e wsb">9. 限制 </div><div class="t m0 x0 h5 y46d4 ff131 fs2 fc0 sc0 ls71">对IndexedDB的限制很多都与对Web Storage的类似。首先，IndexedDB数据库只能由同源（相同</div><div class="t m0 x0 ha4 y46d5 ff131 fs2 fc0 sc0 ls8 ws1">协议、域名和端口）页面操作，因此不能跨域共享信息。换句话说，www.wrox.com与p2p.wrox.com</div><div class="t m0 x0 h5 y2fd0 ff131 fs2 fc0 sc0 ls8 ws1">的数据库是完全独立的。 </div><div class="t m0 x0 h5 y46d6 ff131 fs2 fc0 sc0 lsa ws53">其次，每个来源的数据库占用的磁盘空间也有限制。Firefox 4+目前的上限是每个源50MB，而</div><div class="t m0 x0 h5 y46d7 ff12b fs2 fc0 sc0 ls496 ws421">Chrome的限制是5MB。移动设备上的Firefox最多允许保存 5MB，如果超过了这个配额，将会请求</div><div class="t m0 x0 h5 y46d8 ff131 fs2 fc0 sc0 ls30 ws2a">用户的许可。 </div><div class="t m0 x0 h5 y46d9 ff12b fs2 fc0 sc0 ls47 ws38">Firefox还有另外一个限制，即不允许本地文件访问IndexedDB。Chrome没有这个限制。如果你在</div><div class="t m0 x0 h5 y46da ff131 fs2 fc0 sc0 ls8 ws1">本地运行本书的示例，请使用Chrome。 </div><div class="t m0 x0 hd y46db ff12f fs7 fc0 sc0 ls245">23.4 小结  </div><div class="t m0 x0 h5 y46dc ff131 fs2 fc0 sc0 ls8 ws1">离线Web 应用和客户端存储数据的能力对未来的Web应用越来越重要。浏览器已 经能够检测到用</div><div class="t m0 x0 h5 y46dd ff131 fs2 fc0 sc0 ls8 ws1">户是否离线，并触发JavaScript事件以便应用做出处理。可以指定在应用缓存中保存哪些文件以便离线</div><div class="t m0 x0 h5 y46de ff131 fs2 fc0 sc0 ls8 ws1">时使用。对于应用缓存的状态及变化，也有相应的JavaScript API可以调用检测。  </div><div class="t m0 x0 h5 y46df ff131 fs2 fc0 sc0 ls8 ws1">本书还讨论了客户端存储的以下几方面内容。 </div><div class="t m0 x0 h5 y2b72 ff130 fs1 fc0 sc0 ls2"> 以前，这种存储只能使用cookie完成，cookie是一小块可以客户端设置也可以在服务器端设置</div><div class="t m0 x0 h5 y46e0 ff131 fs2 fc0 sc0 ls8 ws1">的信息，每次发起请求时都会传送它。  </div><div class="t m0 x0 h5 y46e1 ff130 fs1 fc0 sc0 ls2"> 在JavaScript中通过document.cookie可以访问cookie。  </div><div class="t m0 x0 h5 y2b2c ff130 fs1 fc0 sc0 ls2"> cookie的限制使其可以存储少量数据，然而对于大量数据效率很低。  </div></div></div>
<div id="pf2a1" class="pf w0 h0" data-page-no="2a1"><div class="pc pc2a1 w0 h0"><div class="t m0 x2 h2 y1 ff12b fs0 fc0 sc0 ls7 ws0">23.4 小结  655 </div><div class="t m0 x0 h3 y2 ff12b fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff137 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff137 fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ff137 fs3 fc2 sc0 ls1d wsb">16 </div><div class="t m0 x3 h8 y20 ff137 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff137 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff137 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff137 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff137 fs3 fc2 sc0 ls1d wsb">20 </div><div class="t m0 x3 h8 y25 ff137 fs3 fc2 sc0 ls1d wsb">21 </div><div class="t m0 x3 h8 y26 ff137 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff137 fs3 fc2 sc0 ls1d wsf">23 </div><div class="t m0 x3 h8 ya7a ff137 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff137 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff12b fs2 fc0 sc0 lse ws9">IE发明了一种叫做用户数据的行为，可以应用到页面的某个元素上，它有以下特点。  </div><div class="t m0 x0 h4 y4 ff130 fs1 fc0 sc0 ls2"> 一旦应用后，该元素便可以从一个命名数据空间中载入数据，然后可以通过getAttribute()、</div><div class="t m0 x5 h5 y4e ff132 fs1 fc0 sc0 ls9 ws2">setAttribute()和removeAttribute()方法访问。  </div><div class="t m0 x0 h5 yd9 ff130 fs1 fc0 sc0 ls2"> 数据必须明确使用save()方法保存到命名数据空间中，以便能在会话之间持久化数据。  </div><div class="t m0 x0 h5 y15d ff12b fs2 fc0 sc0 ls2b ws1d1">Web Storage定义了两种用于存储数据的对象：sessionStorage和localStorage。前者严格用</div><div class="t m0 x0 h4 y21a ff131 fs2 fc0 sc0 ls8 ws1">于在一个浏览器会话中存储数据，因为数据在浏览器关闭后会立即删除；后者用于跨会话持久化数据并</div><div class="t m0 x0 h5 y5c8 ff131 fs2 fc0 sc0 ls8 ws1">遵循跨域安全策略。  </div><div class="t m0 x0 h5 y2b96 ff12b fs2 fc0 sc0 ls25 wsb3">IndexedDB是一种类似SQL数据库的结构化数据存储机制。但它的数据不是保存在表中，而是保存</div><div class="t m0 x0 h4 y2b97 ff131 fs2 fc0 sc0 ls8 ws1">在对象存储空间中。创建对象存储空间时，需要定义一个键，然后就可以添加数据。可以使用游标在对</div><div class="t m0 x0 h5 y2b98 ff131 fs2 fc0 sc0 ls8 ws1">象存储空间中查询特定的对象。而索引则是为了提高查询速度而基于特定的属性创建的。 </div><div class="t m0 x0 h5 y46e2 ff131 fs2 fc0 sc0 ls8 ws1">有了以上这些选择，就可以在客户端机器上使用JavaScript存储大量数据了。但你必须小心，不要</div><div class="t m0 x0 h5 y46e3 ff131 fs2 fc0 sc0 ls8 ws1">在客户端存储敏感数据，因为数据缓存不会加密。 </div><div class="t m0 x0 h5 y46e4 ff12b fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y46e5 ff12b fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y46e6 ff12b fs2 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf2a2" class="pf w0 h0" data-page-no="2a2"><div class="pc pc2a2 w0 h0"><div class="t m0 x0 h2 y1 ff13c fs0 fc0 sc0 ls7 ws0">656  第24章 最佳实践 </div><div class="t m0 x0 h3 y2 ff13c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h9 y2a ff13e fs5 fc0 sc0 ls12 wsb">最 佳 实 践 </div><div class="t m0 x0 h3c y2b ff13f fs2 fc0 sc0 ls8">本章内容 </div><div class="t m0 x0 h5 y2c ff141 fs1 fc0 sc0 ls2"> 可维护的代码 </div><div class="t m0 x0 h5 y2d ff141 fs1 fc0 sc0 ls2"> 保证代码性能 </div><div class="t m0 x0 h5 y2e ff141 fs1 fc0 sc0 ls2"> 部署代码 </div><div class="t m0 x0 h5 y8d9 ff13c fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y8da ff142 fs2 fc0 sc0 ls3b">从2000以来，Web开发方面的种种规范、条例正在高速发展。Web开发过去曾是荒芜地带，</div><div class="t m0 x0 h4 y8db ff142 fs2 fc0 sc0 ls5 ws4">里面东西还都凑合，而现在已经演化成了完整的研究规范，并建立了种种最佳实践。随着简</div><div class="t m0 x0 h5 y8dc ff142 fs2 fc0 sc0 ls8 ws1">单的网站成长为更加复杂的Web应用，同时Web 爱好者成为了有收入的专业人士，Web开发的世界充</div><div class="t m0 x0 h5 y8dd ff142 fs2 fc0 sc0 ls8 ws1">满了各种关于最新技术和开发方法的信息。尤其是JavaScript，它从大量的研究和推断中获益。JavaScript</div><div class="t m0 x0 h5 y8de ff142 fs2 fc0 sc0 ls8 ws1">的最佳实践分成若干类，并在开发过程的不同点上进行处理。 </div><div class="t m0 x0 hd y13e2 ff140 fs7 fc0 sc0 ls245">24.1 可维护性  </div><div class="t m0 x0 h5 y1beb ff142 fs2 fc0 sc0 ls8 ws1">在早期的网站中，JavaScript主要是用于小特效或者是表单验证。而今天的Web应用则会有成千上</div><div class="t m0 x0 h5 y2c54 ff142 fs2 fc0 sc0 ls8 ws1">万行JavaScript代码，执行各种复杂的过程。这种演化让开发者必须得考虑到可维护性。除了秉承较传</div><div class="t m0 x0 h5 y46e8 ff142 fs2 fc0 sc0 ls8 ws1">统理念的软件工程师外，还要雇佣JavaScript开发人员为公司创造价值，而他们并非仅仅按时交付产品，</div><div class="t m0 x0 h5 yf12 ff142 fs2 fc0 sc0 ls8 ws1">同时还要开发智力成果在之后不断地增加价值。  </div><div class="t m0 x0 h4 y46e9 ff142 fs2 fc0 sc0 ls8 ws1">编写可维护的代码很重要，因为大部分开发人员都花费大量时间维护他人代码。很难从头开始开发</div><div class="t m0 x0 h4 y46ea ff142 fs2 fc0 sc0 ls8 ws1">新代码的，很多情况下是以他人的工作成果为基础的。确保自己代码的可维护性，以便其他开发人员在</div><div class="t m0 x0 h5 y46eb ff142 fs2 fc0 sc0 ls8 ws1">此基础上更好的开展工作。 </div><div class="t m0 x5 h5 y46ec ff13d fs2 fc0 sc0 ls8 ws14">注意可维护的代码的概念并不是JavaScript特有的。这里的很多概念都可以广泛</div><div class="t m0 x0 h5 y46ed ff13d fs2 fc0 sc0 ls8 ws14">应用于各种编程语言，当然也有某些特定于JavaScript的概念。 </div><div class="t m0 x0 h20 y12d8 ff140 fs3 fc0 sc0 ls248 ws214">24.1.1 什么是可维护的代码  </div><div class="t m0 x0 h5 y45c9 ff142 fs2 fc0 sc0 ls8 ws1">可维护的代码有一些特征。一般来说，如果说代码是可维护的，它需要遵循以下特点。 </div><div class="t m0 x0 h5 y46ee ff141 fs1 fc0 sc0 ls2"> 可理解性——其他人可以接手代码并理解它的意图和一般途径，而无需原开发人员的完整解释。 </div><div class="t m0 x0 h5 y46ef ff141 fs1 fc0 sc0 ls2"> 直观性——代码中的东西一看就能明白，不管其操作过程多么复杂。  </div><div class="t m0 x0 h5 y46f0 ff141 fs1 fc0 sc0 ls2"> 可适应性——代码以一种数据上的变化不要求完全重写的方法撰写。  </div><div class="t m0 x0 h5 y1e42 ff141 fs1 fc0 sc0 ls2"> 可扩展性——在代码架构上已考虑到在未来允许对核心功能进行扩展。  </div><div class="t m0 x0 h165 y8f4 ff13f fs1b fc0 sc0 ls8 wsb">自 </div><div class="t m0 x0 h11 y4b ff143 fsa fc0 sc0 ls8">第</div><div class="t m1 x0 h12 y4b ff144 fsb fc3 sc0 ls247">24</div><div class="t m0 x5 h11 y4b ff143 fsa fc0 sc0 ls8 ws1d">章 </div></div></div>
<div id="pf2a3" class="pf w0 h0" data-page-no="2a3"><div class="pc pc2a3 w0 h0"><div class="t m0 x2 h2 y1 ff13c fs0 fc0 sc0 ls7 ws0">24.1 可维护性    657 </div><div class="t m0 x0 h3 y2 ff13c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff145 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff145 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff145 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff145 fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff145 fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff145 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff145 fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff145 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff145 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff145 fs3 fc2 sc0 ls1d wsb">22 </div><div class="t m0 x3 h8 y27 ff145 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ff145 fs3 fc2 sc0 ls1d wsb">24 </div><div class="t m0 x3 h8 y1fce ff145 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff141 fs1 fc0 sc0 ls2"> 可调试性——当有地方出错时，代码可以给予你足够的信息来尽可能直接地确定问题所在。  </div><div class="t m0 x0 h5 y4d ff142 fs2 fc0 sc0 ls8 ws1">对于专业人士而言，能写出可维护的JavaScript代码是非常重要的技能。这正是周末改改网站的爱</div><div class="t m0 x0 h5 yd8 ff142 fs2 fc0 sc0 ls8 ws1">好者和真正理解自己作品的开发人员之间的区别。 </div><div class="t m0 x0 h20 y46f1 ff140 fs3 fc0 sc0 ls248 ws214">24.1.2 代码约定  </div><div class="t m0 x0 h5 y46f2 ff142 fs2 fc0 sc0 ls8 ws1">一种让代码变得可维护的简单途径是形成一套JavaScript代码的书写约定。绝大多数语言都开发出</div><div class="t m0 x0 h4 y46f3 ff142 fs2 fc0 sc0 ls8 ws1">了各自的代码约定，只要在网上一搜就能找到大量相关文档。专业的组织为开发人员制定了详尽的代码</div><div class="t m0 x0 h4 y46f4 ff142 fs2 fc0 sc0 ls8 ws1">约定试图让代码对任何人都可维护。杰出的开放源代码项目有着严格的代码约定要求，这让社区中的任</div><div class="t m0 x0 h5 y46f5 ff142 fs2 fc0 sc0 ls8 ws1">何人都可以轻松地理解代码是如何组织的。 </div><div class="t m0 x0 h5 y46f6 ff142 fs2 fc0 sc0 ls8 ws1">由于JavaScript的可适应性，代码约定对它也很重要。由于和大多数面向对象语言不同，JavaScript</div><div class="t m0 x0 h4 y46f7 ff142 fs2 fc0 sc0 ls8 ws1">并不强制开发人员将所有东西都定义为对象。语言可以支持各种编程风格，从传统面向对象式到声明式</div><div class="t m0 x0 h5 y46f8 ff142 fs2 fc0 sc0 ls8 ws1">到函数式。只要快速浏览一下一些开源JavaScript库，就能发现好几种创建对象、定义方法和管理环境</div><div class="t m0 x0 h5 y46f9 ff142 fs2 fc0 sc0 ls8">的途径。 </div><div class="t m0 x0 h4 y46fa ff142 fs2 fc0 sc0 ls8 ws1">以下小节将讨论代码约定的概论。对这些主题的解说非常重要，虽然可能的解说方式会有区别，这</div><div class="t m0 x0 h5 y46fb ff142 fs2 fc0 sc0 ls8 ws1">取决于个人需求。 </div><div class="t m0 x0 h3c y46fc ff140 fs2 fc0 sc0 ls2e wsb">1. 可读性  </div><div class="t m0 x0 h4 y46fd ff142 fs2 fc0 sc0 ls8 ws1">要让代码可维护，首先它必须可读。可读性与代码作为文本文件的格式化方式有关。可读性的大部</div><div class="t m0 x0 h4 y46fe ff142 fs2 fc0 sc0 ls8 ws1">分内容都是和代码的缩进相关的。当所有人都使用一样的缩进方式时，整个项目中的代码都会更加易于</div><div class="t m0 x0 h4 y46ff ff142 fs2 fc0 sc0 ls8 ws1">阅读。通常会使用若干空格而非制表符来进行缩进，这是因为制表符在不同的文本编辑器中显示效果不</div><div class="t m0 x0 h5 y4700 ff142 fs2 fc0 sc0 ls8 ws1">同。一种不错的、很常见的缩进大小为4个空格，当然你也可以使用其他数量。 </div><div class="t m0 x0 h4 y4701 ff142 fs2 fc0 sc0 ls8 ws1">可读性的另一方面是注释。在大多数编程语言中，对每个方法的注释都视为一个可行的实践。因为</div><div class="t m0 x0 h5 y4702 ff13c fs2 fc0 sc0 lsb ws5">JavaScript可以在代码的任何地方创建函数，所以这点常常被忽略了。然而正因如此，在JavaScript中为</div><div class="t m0 x0 h5 y4703 ff142 fs2 fc0 sc0 ls8 ws1">每个函数编写文档就更加重要了。一般而言，有如下一些地方需要进行注释。 </div><div class="t m0 x0 h4 y4704 ff141 fs1 fc0 sc0 ls2"> 函数和方法——每个函数或方法都应该包含一个注释，描述其目的和用于完成任务所可能使用</div><div class="t m0 x5 h4 y4705 ff142 fs2 fc0 sc0 ls5 ws4">的算法。陈述事先的假设也非常重要，如参数代表什么，函数是否有返回值（因为这不能从函</div><div class="t m0 x5 h5 y4706 ff142 fs2 fc0 sc0 ls8 ws1">数定义中推断出来）。  </div><div class="t m0 x0 h5 y1f46 ff141 fs1 fc0 sc0 ls2"> 大段代码——用于完成单个任务的多行代码应该在前面放一个描述任务的注释。  </div><div class="t m0 x0 h5 y4707 ff141 fs1 fc0 sc0 ls2"> 复杂的算法——如果使用了一种独特的方式解决某个问题，则要在注释中解释你是如何做的。</div><div class="t m0 x5 h5 y4708 ff142 fs2 fc0 sc0 ls8 ws1">这不仅仅可以帮助其他浏览你代码的人，也能在下次你自己查阅代码的时候帮助理解。  </div><div class="t m0 x0 h5 y4709 ff141 fs1 fc0 sc0 ls2"> Hack——因为存在浏览器差异，JavaScript代码一般会包含一些hack。不要假设其他人在看代</div><div class="t m0 x5 h5 y470a ff142 fs2 fc0 sc0 ls30 ws2a">码的时候能够理解hack所要应付的浏览器问题。如果因为某种浏览器无法使用普通的方法，</div><div class="t m0 x5 h4 y470b ff142 fs2 fc0 sc0 ls30 ws2a">所以你需要用一些不同的方法，那么请将这些信息放在注释中。这样可以减少出现这种情况的</div><div class="t m0 x5 h5 y470c ff142 fs2 fc0 sc0 ls30 ws2a">可能性：有人偶然看到你的hack，然后“修正”了它，最后重新引入了你本来修正了的错误。  </div><div class="t m0 x0 h5 y470d ff142 fs2 fc0 sc0 ls8 ws1">缩进和注释可以带来更可读的代码，在未来则更容易维护。  </div><div class="t m0 x0 h3c y470e ff140 fs2 fc0 sc0 ls2e wsb">2. 变量和函数命名  </div><div class="t m0 x0 h5 y470f ff142 fs2 fc0 sc0 ls8 ws1">适当给变量和函数起名字对于增加代码可理解性和可维护性是非常重要的。由于很多JavaScript开</div><div class="t m0 x0 h166 y4710 ff142 fs2 fc0 sc0 ls6 ws6">发人员最初都只是业余爱好者，所以有一种使用无意义名字的倾向，诸如给变量起&quot;foo&quot;、&quot;bar&quot;等名</div><div class="t m0 x0 h5 ya7f ff142 fs2 fc0 sc0 ls8 ws1">字，给函数起&quot;doSomething&quot;这样的名字。专业JavaScript开发人员必须克服这些恶习以创建可维护的</div><div class="t m0 x0 h5 y4711 ff142 fs2 fc0 sc0 ls8 ws1">代码。命名的一般规则如下所示。 </div></div></div>
<div id="pf2a4" class="pf w0 h0" data-page-no="2a4"><div class="pc pc2a4 w0 h0"><div class="t m0 x0 h2 y1 ff13c fs0 fc0 sc0 ls7 ws0">658  第24章 最佳实践 </div><div class="t m0 x0 h3 y2 ff13c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff141 fs1 fc0 sc0 ls2"> 变量名应为名词如car或person。  </div><div class="t m0 x0 h4 y4 ff141 fs1 fc0 sc0 ls2"> 函数名应该以动词开始，如getName()。返回布尔类型值的函数一般以is 开头，如</div><div class="t m0 x0 h5 y4e ff146 fs1 fc0 sc0 ls9 ws2">isEnable()。  </div><div class="t m0 x0 h4 yd9 ff141 fs1 fc0 sc0 ls2"> 变量和函数都应使用合乎逻辑的名字，不要担心长度。长度问题可以通过后处理和压缩（本章</div><div class="t m0 x0 h5 y15d ff142 fs2 fc0 sc0 ls8 ws1">后面会讲到）来缓解。  </div><div class="t m0 x0 h4 y2b3 ff142 fs2 fc0 sc0 ls8 ws1">必须避免出现无法表示所包含的数据类型的无用变量名。有了合适的命名，代码阅读起来就像讲述</div><div class="t m0 x0 h5 y765 ff142 fs2 fc0 sc0 ls8 ws1">故事一样，更容易理解。  </div><div class="t m0 x0 h3c y4712 ff140 fs2 fc0 sc0 ls2e wsb">3. 变量类型透明  </div><div class="t m0 x0 h5 y4713 ff142 fs2 fc0 sc0 ls8 ws1">由于在JavaScript中变量是松散类型的，很容易就忘记变量所应包含的数据类型。合适的命名方式</div><div class="t m0 x0 h5 y11d7 ff142 fs2 fc0 sc0 ls8 ws1">可以一定程度上缓解这个问题，但放到所有的情况下看，还不够。有三种表示变量数据类型的方式。 </div><div class="t m0 x0 h4 y4714 ff142 fs2 fc0 sc0 ls8 ws1">第一种方式是初始化。当定义了一个变量后，它应该被初始化为一个值，来暗示它将来应该如何应</div><div class="t m0 x0 h7d y4715 ff142 fs2 fc0 sc0 ls8 ws1">用。例如，将来保存布尔类型值的变量应该初始化为true或者false，将来保存数字的变量就应该初</div><div class="t m0 x0 h5 y21d5 ff142 fs2 fc0 sc0 ls8 ws1">始化为一个数字，如以下例子所示： </div><div class="t m0 x0 hb y1290 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y2cc6 ff146 fs6 fc0 sc0 ls21">//通过初始化指定变量类型 </div><div class="t m0 x0 h16 y2cc7 ff146 fs6 fc0 sc0 ls21 wsb">var found = false;        //布尔型 </div><div class="t m0 x0 h16 y2cc8 ff146 fs6 fc0 sc0 ls21 wsb">var count = -1;          //数字 </div><div class="t m0 x0 h16 y2cc9 ff146 fs6 fc0 sc0 ls21 wsb">var name = &quot;&quot;;          //字符串 </div><div class="t m0 x0 h16 y2cca ff146 fs6 fc0 sc0 ls21 wsb">var person = null;        //对象 </div><div class="t m0 x0 hb y4716 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y154a ff142 fs2 fc0 sc0 ls8 ws1">初始化为一个特定的数据类型可以很好的指明变量的类型。但缺点是它无法用于函数声明中的函数</div><div class="t m0 x0 h5 y154b ff142 fs2 fc0 sc0 ls8">参数。 </div><div class="t m0 x0 h4 y4717 ff142 fs2 fc0 sc0 ls8 ws1">第二种方法是使用匈牙利标记法来指定变量类型。匈牙利标记法在变量名之前加上一个或多个字符</div><div class="t m0 x0 h5 y4718 ff142 fs2 fc0 sc0 ls4 ws3">来表示数据类型。这个标记法在脚本语言中很流行，曾经很长时间也是JavaScript所推崇的方式。</div><div class="t m0 x0 h5 y4719 ff13c fs2 fc0 sc0 lsb ws5">JavaScript中最传统的匈牙利标记法是用单个字符表示基本类型：&quot;o&quot;代表对象，&quot;s&quot;代表字符串，&quot;i&quot;</div><div class="t m0 x0 h5 y471a ff142 fs2 fc0 sc0 ls8 ws1">代表整数，&quot;f&quot;代表浮点数，&quot;b&quot;代表布尔型。如下所示： </div><div class="t m0 x0 hb y471b ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y471c ff146 fs6 fc0 sc0 ls21">//用于指定数据类型的匈牙利标记法 </div><div class="t m0 x0 h16 y471d ff146 fs6 fc0 sc0 ls21 wsb">var bFound;     //布尔型 </div><div class="t m0 x0 h16 y471e ff146 fs6 fc0 sc0 ls21 wsb">var iCount;     //整数 </div><div class="t m0 x0 h16 y471f ff146 fs6 fc0 sc0 ls21 wsb">var sName;      //字符串 </div><div class="t m0 x0 h16 y4720 ff146 fs6 fc0 sc0 ls21 wsb">var oPerson;    //对象 </div><div class="t m0 x0 hb y4721 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3dee ff13c fs2 fc0 sc0 ls1a7 ws160">JavaScript中用匈牙利标记法的好处是函数参数一样可以使用。但它的缺点是让代码某种程度上难</div><div class="t m0 x0 h4 y4722 ff142 fs2 fc0 sc0 ls24">以阅读，阻碍了没有用它时代码的直观性和句子式的特质。因此，匈牙利标记法失去了一些开发者的</div><div class="t m0 x0 h5 y4723 ff142 fs2 fc0 sc0 ls5">宠爱。 </div><div class="t m0 x0 h4 y4724 ff142 fs2 fc0 sc0 ls8 ws1">最后一种指定变量类型的方式是使用类型注释。类型注释放在变量名右边，但是在初始化前面。这</div><div class="t m0 x0 h5 y4725 ff142 fs2 fc0 sc0 ls8 ws1">种方式是在变量旁边放一段指定类型的注释，如下所示： </div><div class="t m0 x0 hb ye53 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4726 ff146 fs6 fc0 sc0 ls21">//用于指定类型的类型注释 </div><div class="t m0 x0 hb y4727 ff146 fs6 fc0 sc0 ls21 wsb">var found  /*:Boolean*/  = false; </div><div class="t m0 x0 hb y4728 ff146 fs6 fc0 sc0 ls21 wsb">var count  /*:int*/       = 10; </div><div class="t m0 x0 hb y4729 ff146 fs6 fc0 sc0 ls21 wsb">var name   /*:String*/    = &quot;Nicholas&quot;; </div><div class="t m0 x0 hb y472a ff146 fs6 fc0 sc0 ls21 wsb">var person /*:Object*/    = null; </div><div class="t m0 x0 hb y472b ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y2908 ff142 fs2 fc0 sc0 ls8 ws1">类型注释维持了代码的整体可读性，同时注入了类型信息。类型注释的缺点是你不能用多行注释一</div><div class="t m0 x0 h5 y472c ff142 fs2 fc0 sc0 ls8 ws1">次注释大块的代码，因为类型注释也是多行注释，两者会冲突，如下例所示所示： </div><div class="t m0 x0 hb y472d ff146 fs6 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf2a5" class="pf w0 h0" data-page-no="2a5"><div class="pc pc2a5 w0 h0"><div class="t m0 x2 h2 y1 ff13c fs0 fc0 sc0 ls7 ws0">24.1 可维护性    659 </div><div class="t m0 x0 h3 y2 ff13c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff145 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff145 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff145 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff145 fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff145 fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff145 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff145 fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff145 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff145 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff145 fs3 fc2 sc0 ls1d wsb">22 </div><div class="t m0 x3 h8 y27 ff145 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ff145 fs3 fc2 sc0 ls1d wsb">24 </div><div class="t m0 x3 h8 y1fce ff145 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h16 y79 ff148 fs6 fc0 sc0 ls21">//以下代码不能正确运行 </div><div class="t m0 x0 hb y7a ff148 fs6 fc0 sc0 ls21">/* </div><div class="t m0 x0 hb y7b ff148 fs6 fc0 sc0 ls21 wsb">var found   /*:Boolean*/ = false; </div><div class="t m0 x0 hb y7c ff148 fs6 fc0 sc0 ls21 wsb">var count   /*:int*/     = 10; </div><div class="t m0 x0 h167 y7d ff148 fs6 fc0 sc0 ls21 wsb">var name    /*:String*/  = &quot;Nicholas&quot;; </div><div class="t m0 x0 hb y472e ff148 fs6 fc0 sc0 ls21 wsb">var person   /*:Object*/ = null; </div><div class="t m0 x0 hb y472f ff148 fs6 fc0 sc0 ls21">*/  </div><div class="t m0 x0 h5 y4730 ff142 fs2 fc0 sc0 ls8 ws1">这里，试图通过多行注释注释所有变量。类型注释与其相冲突，因为第一次出现的 /* （第二行）</div><div class="t m0 x0 hc y4731 ff142 fs2 fc0 sc0 ls8 ws1">匹配了第一次出现的*/（第3行），这会造成一个语法错误。如果你想注释掉这些使用类型注释的代码</div><div class="t m0 x0 h5 y4732 ff142 fs2 fc0 sc0 ls8 ws1">行，最好在每一行上使用单行注释（很多编辑器可以帮你完成）。 </div><div class="t m0 x0 h4 y4733 ff142 fs2 fc0 sc0 ls8 ws1">这就是最常见的三种指定变量数据类型的方法。每种都有各自的优势和劣势，要自己在使用之前进</div><div class="t m0 x0 h5 y4734 ff142 fs2 fc0 sc0 ls8 ws1">行评估。最重要的是要确定哪种最适合你的项目并一致使用。 </div><div class="t m0 x0 h20 y35c8 ff140 fs3 fc0 sc0 ls248 ws214">24.1.3 松散耦合  </div><div class="t m0 x0 h4 y4735 ff142 fs2 fc0 sc0 ls8 ws1">只要应用的某个部分过分依赖于另一部分，代码就是耦合过紧，难于维护。典型的问题如：对象直</div><div class="t m0 x0 h4 y4736 ff142 fs2 fc0 sc0 ls8 ws1">接引用另一个对象，并且当修改其中一个的同时需要修改另外一个。紧密耦合的软件难于维护并且需要</div><div class="t m0 x0 h5 y4737 ff142 fs2 fc0 sc0 ls8 ws1">经常重写。 </div><div class="t m0 x0 h5 y4738 ff142 fs2 fc0 sc0 ls8 ws1">因为Web应用所涉及的技术，有多种情况会使它变得耦合过紧。必须小心这些情况，并尽可能维</div><div class="t m0 x0 h5 y4739 ff142 fs2 fc0 sc0 ls8 ws1">护弱耦合的代码。 </div><div class="t m0 x0 h3c y473a ff140 fs2 fc0 sc0 ls2e wsb">1. 解耦HTML/JavaScript  </div><div class="t m0 x0 h5 y473b ff142 fs2 fc0 sc0 ls8 ws1">一种最常见的耦合类型是HTML/JavaScript耦合。在Web上，HTML 和JavaScript各自代表了解决</div><div class="t m0 x0 h5 y473c ff142 fs2 fc0 sc0 ls8 ws1">方案中的不同层次：HTML是数据，JavaScript是行为。因为它们天生就需要交互，所以有多种不同的</div><div class="t m0 x0 h5 y473d ff142 fs2 fc0 sc0 ls8 ws1">方法将这两个技术关联起来。但是，有一些方法会将HTML和JavaScript过于紧密地耦合在一起。 </div><div class="t m0 x0 h168 y473e ff142 fs2 fc0 sc0 ls8 ws1">直接写在HTML中的JavaScript，使用包含内联代码的&lt;script&gt;元素或者是使用HTML 属性来分</div><div class="t m0 x0 h5 y33f5 ff142 fs2 fc0 sc0 ls8 ws1">配事件处理程序，都是过于紧密的耦合。请看以下代码。 </div><div class="t m0 x5 hb y473f ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4740 ff146 fs6 fc0 sc0 ls21 wsb">&lt;!-- 使用了 &lt;script&gt; 的紧密耦合的 HTML/JavaScript --&gt; </div><div class="t m0 x0 hb y4741 ff146 fs6 fc0 sc0 ls21 wsb">&lt;script type=&quot;text/javascript&quot;&gt; </div><div class="t m0 x0 hb y4742 ff146 fs6 fc0 sc0 ls21 wsb">  document.write(&quot;Hello world!&quot;); </div><div class="t m0 x0 hb y4743 ff146 fs6 fc0 sc0 ls21 wsb">&lt;/script&gt; </div><div class="t m0 x0 hb y4744 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4745 ff146 fs6 fc0 sc0 ls21 wsb">&lt;!-- 使用事件处理程序属性值的紧密耦合的 HTML/JavaScript --&gt; </div><div class="t m0 x0 hb y4746 ff146 fs6 fc0 sc0 ls21 wsb">&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;doSomething()&quot; /&gt; </div><div class="t m0 x5 hb y4747 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y15d1 ff142 fs2 fc0 sc0 ls8 ws1">虽然这些从技术上来说都是正确的，但是实践中，它们将表示数据的HTML和定义行为的JavaScript</div><div class="t m0 x0 h5 y4723 ff142 fs2 fc0 sc0 ls8 ws1">紧密耦合在了一起。理想情况是，HTML和JavaScript应该完全分离，并通过外部文件和使用DOM附</div><div class="t m0 x0 h5 y4724 ff142 fs2 fc0 sc0 ls8 ws1">加行为来包含JavaScript。 </div><div class="t m0 x0 h5 y4725 ff142 fs2 fc0 sc0 ls8d">当HTML和JavaScript过于紧密的耦合在一起时，出现JavaScript错误时就要先判断错误是出现在</div><div class="t m0 x0 h5 y4748 ff13c fs2 fc0 sc0 ls3b9 ws332">HTML部分还是在JavaScript文件中。它还会引入和代码是否可用的相关新问题。在这个例子中，可能</div><div class="t m0 x0 h1b y4749 ff142 fs2 fc0 sc0 ls49c">在doSomething()函数可用之前，就已经按下了按钮，引发了一个JavaScript错误。因为任何对按钮</div><div class="t m0 x0 h5 y474a ff142 fs2 fc0 sc0 ls5 ws4">行为的更改要同时触及HTML和JavaScript，因此影响了可维护性。而这些更改本该只在JavaScript中</div><div class="t m0 x0 h5 y474b ff142 fs2 fc0 sc0 ls5">进行。 </div><div class="t m0 x0 h5 y474c ff13c fs2 fc0 sc0 lsfa wsc9">HTML和JavaScript的紧密耦合也可以在相反的关系上成立：JavaScript包含了HTML。这通常会出</div><div class="t m0 x0 h5 y474d ff142 fs2 fc0 sc0 ls8 ws1">现在使用innerHTML来插入一段HTML文本到页面上这种情况中，如下面的例子所示： </div><div class="t m0 x5 hb y26fb ff146 fs6 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf2a6" class="pf w0 h0" data-page-no="2a6"><div class="pc pc2a6 w0 h0"><div class="t m0 x0 h2 y1 ff13c fs0 fc0 sc0 ls7 ws0">660  第24章 最佳实践 </div><div class="t m0 x0 h3 y2 ff13c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y79 ff146 fs6 fc0 sc0 ls21">//将HTML紧密耦合到JavaScript </div><div class="t m0 x0 hb y7a ff146 fs6 fc0 sc0 ls21 wsb">function insertMessage(msg){ </div><div class="t m0 x0 hb y7b ff146 fs6 fc0 sc0 ls21 wsb">    var container = document.getElementById(&quot;container&quot;); </div><div class="t m0 x0 hb y7c ff146 fs6 fc0 sc0 ls21 wsb">    container.innerHTML = &quot;&lt;div class=\&quot;msg\&quot;&gt;&lt;p class=\&quot;post\&quot;&gt;&quot; + msg + &quot;&lt;/p&gt;&quot; + </div><div class="t m0 x0 hb y7d ff146 fs6 fc0 sc0 ls21 wsb">        &quot;&lt;p&gt;&lt;em&gt;Latest message above.&lt;/em&gt;&lt;/p&gt;&lt;/div&gt;&quot;; </div><div class="t m0 x0 hb y7e ff146 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h5 ya38 ff142 fs2 fc0 sc0 ls8 ws1">一般来说，你应该避免在JavaScript中创建大量HTML。再一次重申要保持层次的分离，这样可以</div><div class="t m0 x0 h5 y474e ff142 fs2 fc0 sc0 ls8 ws1">很容易的确定错误来源。当使用上面这个例子的时候，有一个页面布局的问题，可能和动态创建的HTML</div><div class="t m0 x0 h4 y474f ff142 fs2 fc0 sc0 ls8 ws1">没有被正确格式化有关。不过，要定位这个错误可能非常困难，因为你可能一般先看页面的源代码来查</div><div class="t m0 x0 h5 y4750 ff142 fs2 fc0 sc0 ls5 ws4">找那段烦人的HTML，但是却没能找到，因为它是动态生成的。对数据或者布局的更改也会要求更改</div><div class="t m0 x0 h5 y4751 ff13c fs2 fc0 sc0 lsb ws5">JavaScript，这也表明了这两个层次过于紧密地耦合了。 </div><div class="t m0 x0 h5 y4752 ff13c fs2 fc0 sc0 lsfa wsc9">HTML呈现应该尽可能与JavaScript保持分离。当 JavaScript用于插入数据时，尽量不要直接插入</div><div class="t m0 x0 h5 y4753 ff142 fs2 fc0 sc0 ls8 ws1">标记。一般可以在页面中直接包含并隐藏标记，然后等到整个页面渲染好之后，就可以用JavaScript显</div><div class="t m0 x0 h5 y4754 ff142 fs2 fc0 sc0 ls8 ws1">示该标记，而非生成它。另一种方法是进行Ajax请求并获取更多要显示的HTML，这个方法可以让同</div><div class="t m0 x0 h5 y4755 ff142 fs2 fc0 sc0 ls8 ws1">样的渲染层（PHP、JSP、Ruby等等）来输出标记，而不是直接嵌在JavaScript中。 </div><div class="t m0 x0 h5 y4756 ff142 fs2 fc0 sc0 ls3b">将HTML和JavaScript解耦可以在调试过程中节省时间，更加容易确定错误的来源，也减轻维护的</div><div class="t m0 x0 h5 y4757 ff142 fs2 fc0 sc0 ls8 ws1">难度：更改行为只需要在JavaScript文件中进行，而更改标记则只要在渲染文件中。 </div><div class="t m0 x0 h3c y4758 ff140 fs2 fc0 sc0 ls2e wsb">2. 解耦CSS/JavaScript  </div><div class="t m0 x0 h5 y4759 ff142 fs2 fc0 sc0 ls44 ws32">另一个Web层则是CSS，它主要负责页面的显示。JavaScript 和CSS也是非常紧密相关的：他们都</div><div class="t m0 x0 h5 y475a ff142 fs2 fc0 sc0 lsee">是HTML之上的层次，因此常常一起使用。但是，和HTML与JavaScript的情况一样，CSS和JavaScript</div><div class="t m0 x0 h5 y475b ff142 fs2 fc0 sc0 ls42 ws30">也可能会过于紧密地耦合在一起。最常见的紧密耦合的例子是使用JavaScript来更改某些样式，如下所示： </div><div class="t m0 x0 hb y13e2 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y1f1d ff146 fs6 fc0 sc0 ls21 ws34">//CSS对JavaScript的紧密耦合 </div><div class="t m0 x0 hb y475c ff146 fs6 fc0 sc0 ls21 wsb">element.style.color = &quot;red&quot;; </div><div class="t m0 x0 hb y475d ff146 fs6 fc0 sc0 ls21 wsb">element.style.backgroundColor = &quot;blue&quot;; </div><div class="t m0 x0 hb y475e ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y807 ff142 fs2 fc0 sc0 ls8 ws1">由于CSS负责页面的显示，当显示出现任何问题时都应该只是查看CSS文件来解决。然而，当使</div><div class="t m0 x0 h5 y180b ff142 fs2 fc0 sc0 ls8 ws1">用了JavaScript来更改某些样式的时候，比如颜色，就出现了第二个可能已更改和必须检查的地方。结</div><div class="t m0 x0 h5 y475f ff142 fs2 fc0 sc0 ls8 ws1">果是JavaScript也在某种程度上负责了页面的显示，并与CSS紧密耦合了。如果未来需要更改样式表，</div><div class="t m0 x0 h5 y4760 ff13c fs2 fc0 sc0 ls14d ws11a">CSS和JavaScript文件可能都需要修改。这就给开发人员造成了维护上的噩梦。所以在这两个层次之间</div><div class="t m0 x0 h5 y4761 ff142 fs2 fc0 sc0 ls8 ws1">必须有清晰的划分。 </div><div class="t m0 x0 h5 y4762 ff142 fs2 fc0 sc0 ls8 ws1">现代Web应用常常要使用JavaScript来更改样式，所以虽然不可能完全将 CSS和JavaScript解耦，</div><div class="t m0 x0 h5 y4763 ff142 fs2 fc0 sc0 ls8 ws1">但是还是能让耦合更松散的。这是通过动态更改样式类而非特定样式来实现的，如下例所示： </div><div class="t m0 x0 hb yea0 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4764 ff146 fs6 fc0 sc0 ls21 wsb">//CSS 对 JavaScript 的松散耦合 </div><div class="t m0 x0 hb y4765 ff146 fs6 fc0 sc0 ls21 wsb">element.className = &quot;edit&quot;; </div><div class="t m0 x0 hb y4766 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y34ea ff142 fs2 fc0 sc0 ls8 ws1">通过只修改某个元素的CSS类，就可以让大部分样式信息严格保留在CSS中。JavaScript可以更改</div><div class="t m0 x0 h4 y4767 ff142 fs2 fc0 sc0 ls8 ws1">样式类，但并不会直接影响到元素的样式。只要应用了正确的类，那么任何显示问题都可以直接追溯到</div><div class="t m0 x0 h5 y4768 ff13c fs2 fc0 sc0 ls14d ws11a">CSS而非JavaScript。 </div><div class="t m0 x0 h5 y4769 ff142 fs2 fc0 sc0 ls8 ws1">第二类紧密耦合仅会在IE中出现（但运行于标准模式下的IE8不会出现），它可以在CSS中通过表</div><div class="t m0 x0 h5 y476a ff142 fs2 fc0 sc0 ls8 ws1">达式嵌入JavaScript，如下例所示： </div><div class="t m0 x0 hb y476b ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y476c ff146 fs6 fc0 sc0 ls21 wsb">/* JavaScript对CSS的紧密耦合 */ </div><div class="t m0 x0 hb y476d ff146 fs6 fc0 sc0 ls21 wsb">div { </div><div class="t m0 x0 hb y476e ff146 fs6 fc0 sc0 ls21 wsb">    width: expression(document.body.offsetWidth - 10 + &quot;px&quot;); </div><div class="t m0 x0 hb y476f ff146 fs6 fc0 sc0 ls21 wsb">} </div></div></div>
<div id="pf2a7" class="pf w0 h0" data-page-no="2a7"><div class="pc pc2a7 w0 h0"><div class="t m0 x2 h2 y1 ff13c fs0 fc0 sc0 ls7 ws0">24.1 可维护性    661 </div><div class="t m0 x0 h3 y2 ff13c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff145 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff145 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff145 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff145 fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff145 fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff145 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff145 fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff145 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff145 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff145 fs3 fc2 sc0 ls1d wsb">22 </div><div class="t m0 x3 h8 y27 ff145 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ff145 fs3 fc2 sc0 ls1d wsb">24 </div><div class="t m0 x3 h8 y1fce ff145 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff142 fs2 fc0 sc0 ls8 ws1">通常要避免使用表达式，因为它们不能跨浏览器兼容，还因为它们所引入的JavaScript和CSS之间</div><div class="t m0 x0 h5 y4d ff142 fs2 fc0 sc0 ls8 ws1">的紧密耦合。如果使用了表达式，那么可能会在CSS中出现JavaScript错误。由于CSS表达式而追踪过</div><div class="t m0 x0 h5 yd8 ff13c fs2 fc0 sc0 ls5e wsb">JavaScript 错误的开发人员，会告诉你在他们决定看一下CSS之前花了多长时间来查找错误。 </div><div class="t m0 x0 h5 y28b ff142 fs2 fc0 sc0 ls8 ws1">再次提醒，好的层次划分是非常重要的。显示问题的唯一来源应该是CSS，行为问题的唯一来源应</div><div class="t m0 x0 h5 yfdb ff142 fs2 fc0 sc0 ls8 ws1">该是JavaScript。在这些层次之间保持松散耦合可以让你的整个应用更加易于维护。 </div><div class="t m0 x0 h3c y4770 ff140 fs2 fc0 sc0 ls2e wsb">3. 解耦应用逻辑／事件处理程序  </div><div class="t m0 x0 h5 y334c ff142 fs2 fc0 sc0 ls8 ws1">每个Web应用一般都有相当多的事件处理程序，监听着无数不同的事件。然而，很少有能仔细得</div><div class="t m0 x0 h5 y4771 ff142 fs2 fc0 sc0 ls8 ws1">将应用逻辑从事件处理程序中分离的。请看以下例子： </div><div class="t m0 x5 hb y4772 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4773 ff146 fs6 fc0 sc0 ls21 wsb">function handleKeyPress(event){ </div><div class="t m0 x0 hb y4774 ff146 fs6 fc0 sc0 ls21 wsb">    event = EventUtil.getEvent(event); </div><div class="t m0 x0 hb y4775 ff146 fs6 fc0 sc0 ls21 wsb">    if (event.keyCode == 13){ </div><div class="t m0 x0 hb y4776 ff146 fs6 fc0 sc0 ls21 wsb">        var target = EventUtil.getTarget(event); </div><div class="t m0 x0 hb y4777 ff146 fs6 fc0 sc0 ls21 wsb">        var value = 5 * parseInt(target.value); </div><div class="t m0 x0 hb y4778 ff146 fs6 fc0 sc0 ls21 wsb">        if (value &gt; 10){ </div><div class="t m0 x0 hb y4779 ff146 fs6 fc0 sc0 ls21 wsb">            document.getElementById(&quot;error-msg&quot;).style.display = &quot;block&quot;; </div><div class="t m0 x0 hb y477a ff146 fs6 fc0 sc0 ls21 wsb">       } </div><div class="t m0 x0 hb y477b ff146 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y477c ff146 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 h4 y23ba ff142 fs2 fc0 sc0 ls8 ws1">这个事件处理程序除了包含了应用逻辑，还进行了事件的处理。这种方式的问题有其双重性。首先，</div><div class="t m0 x0 h4 y477d ff142 fs2 fc0 sc0 ls8 ws1">除了通过事件之外就再没有方法执行应用逻辑，这让调试变得困难。如果没有发生预想的结果怎么办？</div><div class="t m0 x0 h4 y477e ff142 fs2 fc0 sc0 ls8 ws1">是不是表示事件处理程序没有被调用还是指应用逻辑失败？其次，如果一个后续的事件引发同样的应用</div><div class="t m0 x0 h4 y477f ff142 fs2 fc0 sc0 ls8 ws1">逻辑，那就必须复制功能代码或者将代码抽取到一个单独的函数中。无论何种方式，都要作比实际所需</div><div class="t m0 x0 h5 y4780 ff142 fs2 fc0 sc0 ls8 ws1">更多的改动。 </div><div class="t m0 x0 h4 y4781 ff142 fs2 fc0 sc0 ls8 ws1">较好的方法是将应用逻辑和事件处理程序相分离，这样两者分别处理各自的东西。一个事件处理程</div><div class="t m0 x0 h4 y4782 ff142 fs2 fc0 sc0 ls8 ws1">序应该从事件对象中提取相关信息，并将这些信息传送到处理应用逻辑的某个方法中。例如，前面的代</div><div class="t m0 x0 h5 y4783 ff142 fs2 fc0 sc0 ls8 ws1">码可以被重写为： </div><div class="t m0 x5 hb y4784 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4785 ff146 fs6 fc0 sc0 ls21 wsb">function validateValue(value){ </div><div class="t m0 x0 hb y4786 ff146 fs6 fc0 sc0 ls21 wsb">    value = 5 * parseInt(value); </div><div class="t m0 x0 hb y4787 ff146 fs6 fc0 sc0 ls21 wsb">    if (value &gt; 10){ </div><div class="t m0 x0 hb y4788 ff146 fs6 fc0 sc0 ls21 wsb">        document.getElementById(&quot;error-msg&quot;).style.display = &quot;block&quot;; </div><div class="t m0 x0 hb y4789 ff146 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y478a ff146 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 hb y478b ff146 fs6 fc0 sc0 ls21 wsb">function handleKeyPress(event){ </div><div class="t m0 x0 hb y478c ff146 fs6 fc0 sc0 ls21 wsb">    event = EventUtil.getEvent(event); </div><div class="t m0 x0 hb y478d ff146 fs6 fc0 sc0 ls21 wsb">    if (event.keyCode == 13){ </div><div class="t m0 x0 hb y478e ff146 fs6 fc0 sc0 ls21 wsb">        var target = EventUtil.getTarget(event); </div><div class="t m0 x0 hb y478f ff146 fs6 fc0 sc0 ls21 wsb">        validateValue(target.value); </div><div class="t m0 x0 hb y4790 ff146 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y4791 ff146 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h5 y633 ff142 fs2 fc0 sc0 ls5 ws4">改动过的代码合理将应用逻辑从事件处理程序中分离了出来。handleKeyPress() 函数确认是按</div><div class="t m0 x0 hc y3fa6 ff142 fs2 fc0 sc0 ls8 ws1">下了Enter键（event.keyCode为13），取得了事件的目标并将value属性传递给validateValue()</div><div class="t m0 x0 h4 y2b72 ff142 fs2 fc0 sc0 ls8 ws1">函数，这个函数包含了应用逻辑。注意validateValue()中没有任何东西会依赖于任何事件处理程序</div><div class="t m0 x0 h5 y46e0 ff142 fs2 fc0 sc0 ls8 ws1">逻辑，它只是接收一个值，并根据该值进行其他处理。 </div><div class="t m0 x0 h4 y4792 ff142 fs2 fc0 sc0 ls8 ws1">从事件处理程序中分离应用逻辑有几个好处。首先，可以让你更容易更改触发特定过程的事件。如</div><div class="t m0 x0 h4 y4793 ff142 fs2 fc0 sc0 ls8 ws1">果最开始由鼠标点击事件触发过程，但现在按键也要进行同样处理，这种更改就很容易。其次，可以在</div></div></div>
<div id="pf2a8" class="pf w0 h0" data-page-no="2a8"><div class="pc pc2a8 w0 h0"><div class="t m0 x0 h2 y1 ff13c fs0 fc0 sc0 ls7 ws0">662  第24章 最佳实践 </div><div class="t m0 x0 h3 y2 ff13c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff142 fs2 fc0 sc0 ls8 ws1">不附加到事件的情况下测试代码，使其更易创建单元测试或者是自动化应用流程。 </div><div class="t m0 x0 h5 y4d ff142 fs2 fc0 sc0 ls8 ws1">以下是要牢记的应用和业务逻辑之间松散耦合的几条原则： </div><div class="t m0 x0 h5 y4e ff141 fs1 fc0 sc0 ls2"> 勿将event对象传给其他方法；只传来自event对象中所需的数据； </div><div class="t m0 x0 h5 yd9 ff141 fs1 fc0 sc0 ls2"> 任何可以在应用层面的动作都应该可以在不执行任何事件处理程序的情况下进行； </div><div class="t m0 x0 h5 y219 ff141 fs1 fc0 sc0 ls2"> 任何事件处理程序都应该处理事件，然后将处理转交给应用逻辑。 </div><div class="t m0 x0 h4 y21a ff142 fs2 fc0 sc0 ls8 ws1">牢记这几条可以在任何代码中都获得极大的可维护性的改进，并且为进一步的测试和开发制造了很</div><div class="t m0 x0 h5 y5c8 ff142 fs2 fc0 sc0 ls8">多可能。 </div><div class="t m0 x0 h20 y2422 ff140 fs3 fc0 sc0 ls248 ws214">24.1.4 编程实践  </div><div class="t m0 x0 h5 y7d4 ff142 fs2 fc0 sc0 ls8 ws1">书写可维护的JavaScript并不仅仅是关于如何格式化代码；它还关系到代码做什么的问题。在企业</div><div class="t m0 x0 h5 yf28 ff142 fs2 fc0 sc0 ls8 ws1">环境中创建的Web应用往往同时由大量人员一同创作。这种情况下的目标是确保每个人所使用的浏览</div><div class="t m0 x0 h5 yf29 ff142 fs2 fc0 sc0 ls8 ws1">器环境都有一致和不变的规则。因此，最好坚持以下一些编程实践。  </div><div class="t m0 x0 h3c y4794 ff140 fs2 fc0 sc0 ls2e wsb">1. 尊重对象所有权  </div><div class="t m0 x0 h5 y4795 ff13c fs2 fc0 sc0 lsb ws5">JavaScript的动态性质使得几乎任何东西在任何时间都可以修改。有人说在JavaScript没有什么神圣</div><div class="t m0 x0 h5 y4796 ff142 fs2 fc0 sc0 ls8 ws1">的东西，因为无法将某些东西标记为最终或恒定状态。这种状况在ECMAScript 5中通过引入防篡改对</div><div class="t m0 x0 h5 y4797 ff142 fs2 fc0 sc0 ls8 ws1">象（第22章讨论过）得以改变；不过，默认情况下所有对象都是可以修改的。在其他语言中，当没有</div><div class="t m0 x0 h5 y4798 ff142 fs2 fc0 sc0 ls6 ws6">实际的源代码的时候，对象和类是不可变的。JavaScript可以在任何时候修改任意对象，这样就可以以</div><div class="t m0 x0 h4 y4799 ff142 fs2 fc0 sc0 ls8 ws1">不可预计的方式覆写默认的行为。因为这门语言没有强行的限制，所以对于开发者来说，这是很重要的，</div><div class="t m0 x0 h5 y479a ff142 fs2 fc0 sc0 ls8 ws1">也是必要的。 </div><div class="t m0 x0 h4 y479b ff142 fs2 fc0 sc0 ls24 ws1e">也许在企业环境中最重要的编程实践就是尊重对象所有权，它的意思是你不能修改不属于你的对</div><div class="t m0 x0 h4 y479c ff142 fs2 fc0 sc0 ls8 ws1">象。简单地说，如果你不负责创建或维护某个对象、它的对象或者它的方法，那么你就不能对它们进行</div><div class="t m0 x0 h5 y479d ff142 fs2 fc0 sc0 ls8 ws1">修改。更具体地说： </div><div class="t m0 x0 h5 y433a ff141 fs1 fc0 sc0 ls2"> 不要为实例或原型添加属性； </div><div class="t m0 x0 h5 y2216 ff141 fs1 fc0 sc0 ls2"> 不要为实例或原型添加方法； </div><div class="t m0 x0 h5 y15cd ff141 fs1 fc0 sc0 ls2"> 不要重定义已存在的方法。 </div><div class="t m0 x0 h4 y479e ff142 fs2 fc0 sc0 ls8 ws1">问题在于开发人员会假设浏览器环境按照某个特定方式运行，而对于多个人都用到的对象进行改动</div><div class="t m0 x0 h1c y479f ff142 fs2 fc0 sc0 ls8 ws1">就会产生错误。如果某人期望叫做stopEvent()的函数能取消某个事件的默认行为，但是你对其进行</div><div class="t m0 x0 h4 y16bf ff142 fs2 fc0 sc0 ls8 ws1">了更改，然后它完成了本来的任务，后来还追加了另外的事件处理程序，那肯定会出现问题了。其他开</div><div class="t m0 x0 h4 y229d ff142 fs2 fc0 sc0 ls8 ws1">发人员会认为函数还是按照原来的方式执行，所以他们的用法会出错并有可能造成危害，因为他们并不</div><div class="t m0 x0 h5 y47a0 ff142 fs2 fc0 sc0 ls8 ws1">知道有副作用。 </div><div class="t m0 x0 h4b y47a1 ff142 fs2 fc0 sc0 ls8 ws1">这些规则不仅仅适用于自定义类型和对象，对于诸如Object、String、document、window等</div><div class="t m0 x0 h4 y47a2 ff142 fs2 fc0 sc0 ls8 ws1">原生类型和对象也适用。此处潜在的问题可能更加危险，因为浏览器提供者可能会在不做宣布或者是不</div><div class="t m0 x0 h5 y47a3 ff142 fs2 fc0 sc0 ls8 ws1">可预期的情况下更改这些对象。 </div><div class="t m0 x0 h5 y47a4 ff142 fs2 fc0 sc0 ls24 ws1e">著名的Prototype JavaScript库就出现过这种例子：它为 document对象实现了getElements- </div><div class="t m0 x0 h21 y47a5 ff146 fs1 fc0 sc0 ls43 ws31">ByClassName()方法，返回一个Array的实例并增加了一个each()方法。John Resig在他的博客上叙</div><div class="t m0 x0 h5 y26c2 ff142 fs2 fc0 sc0 ls42 ws30">述了产生这个问题的一系列事件。他在帖子（http://ejohn.org/blog/getelementsbyclassname-pre-prototype-16/）</div><div class="t m0 x0 h1c y47a6 ff142 fs2 fc0 sc0 ls8 ws1">中说，他发现当浏览器开始内部实现getElementsByClassName()的时候就出现问题了，这个方法并</div><div class="t m0 x0 h5 y26c3 ff142 fs2 fc0 sc0 ls42 ws30">不返回一个Array而是返回一个并不包含each()方法的NodeList。使用 Prototype库的开发人员习惯</div><div class="t m0 x0 h5 y26c4 ff142 fs2 fc0 sc0 ls42 ws30">于写这样的代码： </div></div></div>
<div id="pf2a9" class="pf w0 h0" data-page-no="2a9"><div class="pc pc2a9 w0 h0"><div class="t m0 x2 h2 y1 ff13c fs0 fc0 sc0 ls7 ws0">24.1 可维护性    663 </div><div class="t m0 x0 h3 y2 ff13c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff145 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff145 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff145 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff145 fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff145 fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff145 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff145 fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff145 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff145 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff145 fs3 fc2 sc0 ls1d wsb">22 </div><div class="t m0 x3 h8 y27 ff145 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ff145 fs3 fc2 sc0 ls1d wsb">24 </div><div class="t m0 x3 h8 y1fce ff145 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y79 ff146 fs6 fc0 sc0 ls21 wsb">document.getElementsByClassName(&quot;selected&quot;).each(Element.hide); </div><div class="t m0 x5 hb y1b0b ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1b0c ff142 fs2 fc0 sc0 ls8 ws1">虽然在没有原生实现getElementsByClassName()的浏览器中可以正常运行，但对于支持的了浏</div><div class="t m0 x0 h4 y1b0d ff142 fs2 fc0 sc0 ls8 ws1">览器就会产生错误，因为返回的值不同。你不能预测浏览器提供者在未来会怎样更改原生对象，所以不</div><div class="t m0 x0 h5 y47a7 ff142 fs2 fc0 sc0 ls8 ws1">管用任何方式修改他们，都可能会导致将来你的实现和他们的实现之间的冲突。 </div><div class="t m0 x0 h4 y47a8 ff142 fs2 fc0 sc0 ls8 ws1">所以，最佳的方法便是永远不修改不是由你所有的对象。所谓拥有对象，就是说这个对象是你创建</div><div class="t m0 x0 h4b y47a9 ff142 fs2 fc0 sc0 ls8 ws1">的，比如你自己创建的自定义类型或对象字面量。而Array、document这些显然不是你的，它们在你</div><div class="t m0 x0 h5 y47aa ff142 fs2 fc0 sc0 ls8 ws1">的代码执行前就存在了。你依然可以通过以下方式为对象创建新的功能： </div><div class="t m0 x0 h5 y47ab ff141 fs1 fc0 sc0 ls2"> 创建包含所需功能的新对象，并用它与相关对象进行交互； </div><div class="t m0 x0 h5 y2f15 ff141 fs1 fc0 sc0 ls2"> 创建自定义类型，继承需要进行修改的类型。然后可以为自定义类型添加额外功能。 </div><div class="t m0 x0 h5 y47ac ff142 fs2 fc0 sc0 ls8 ws1">现在很多JavaScript库都赞同并遵守这条开发原理，这样即使浏览器频繁更改，库本身也能继续成</div><div class="t m0 x0 h5 y47ad ff142 fs2 fc0 sc0 ls8 ws1">长和适应。 </div><div class="t m0 x0 h3c y47ae ff140 fs2 fc0 sc0 ls2e wsb">2. 避免全局量  </div><div class="t m0 x0 h4 y47af ff142 fs2 fc0 sc0 ls8 ws1">与尊重对象所有权密切相关的是尽可能避免全局变量和函数。这也关系到创建一个脚本执行的一致</div><div class="t m0 x0 h5 y47b0 ff142 fs2 fc0 sc0 ls8 ws1">的和可维护的环境。最多创建一个全局变量，让其他对象和函数存在其中。请看以下例子： </div><div class="t m0 x5 hb y47b1 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h2d y47b2 ff146 fs6 fc0 sc0 ls21">//两个全局量——避免！！ </div><div class="t m0 x0 hb y47b3 ff146 fs6 fc0 sc0 ls21 wsb">var name = &quot;Nicholas&quot;; </div><div class="t m0 x0 hb y47b4 ff146 fs6 fc0 sc0 ls21 wsb">function sayName(){ </div><div class="t m0 x0 hb y47b5 ff146 fs6 fc0 sc0 ls21 wsb">    alert(name); </div><div class="t m0 x0 hb y3f98 ff146 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h4 y47b6 ff142 fs2 fc0 sc0 ls8 ws1">这段代码包含了两个全局量：变量name和函数sayName()。其实可以创建一个包含两者的对象，</div><div class="t m0 x0 h5 y22bc ff142 fs2 fc0 sc0 ls8 ws1">如下例所示： </div><div class="t m0 x5 hb y47b7 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h2d y47b8 ff146 fs6 fc0 sc0 ls21">//一个全局量——推荐 </div><div class="t m0 x0 hb y47b9 ff146 fs6 fc0 sc0 ls21 wsb">var MyApplication = { </div><div class="t m0 x0 hb y47ba ff146 fs6 fc0 sc0 ls21 wsb">    name: &quot;Nicholas&quot;, </div><div class="t m0 x0 hb y47bb ff146 fs6 fc0 sc0 ls21 wsb">    sayName: function(){ </div><div class="t m0 x0 hb y47bc ff146 fs6 fc0 sc0 ls21 wsb">        alert(this.name); </div><div class="t m0 x0 hb y47bd ff146 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y47be ff146 fs6 fc0 sc0 ls21 wsb">};  </div><div class="t m0 x0 h4 y160f ff142 fs2 fc0 sc0 ls8 ws1">这段重写的代码引入了一个单一的全局对象MyApplication，name和sayName()都附加到其上。</div><div class="t m0 x0 h4 y47bf ff142 fs2 fc0 sc0 ls8 ws1">这样做消除了一些存在于前一段代码中的一些问题。首先，变量name覆盖了window.name属性，可</div><div class="t m0 x0 h4 y47c0 ff142 fs2 fc0 sc0 ls8 ws1">能会与其他功能产生冲突；其次，它有助消除功能作用域之间的混淆。调用 MyApplication.sayName()</div><div class="t m0 x0 h5 y47c1 ff142 fs2 fc0 sc0 ls8 ws1">在逻辑上暗示了代码的任何问题都可以通过检查定义MyApplication的代码来确定。 </div><div class="t m0 x0 h5 y47c2 ff142 fs2 fc0 sc0 ls8 ws1">单一的全局量的延伸便是命名空间的概念，由YUI（Yahoo! User Interface）库普及。命名空间包括</div><div class="t m0 x0 h5 y47c3 ff142 fs2 fc0 sc0 ls8 ws1">创建一个用于放置功能的对象。在YUI的2.x版本中，有若干用于追加功能的命名空间。比如： </div><div class="t m0 x0 h5 y47c4 ff141 fs1 fc0 sc0 ls2"> YAHOO.util.Dom —— 处理DOM的方法； </div><div class="t m0 x0 h5 y47c5 ff141 fs1 fc0 sc0 ls2"> YAHOO.util.Event —— 与事件交互的方法； </div><div class="t m0 x0 h5 y1c63 ff141 fs1 fc0 sc0 ls2"> YAHOO.lang —— 用于底层语言特性的方法。 </div><div class="t m0 x0 h5 y47c6 ff142 fs2 fc0 sc0 ls8 ws1">对于YUI，单一的全局对象YAHOO作为一个容器，其中定义了其他对象。用这种方式将功能组合</div><div class="t m0 x0 h5 y47c7 ff142 fs2 fc0 sc0 ls8 ws1">在一起的对象，叫做命名空间。整个YUI库便是构建在这个概念上的，让它能够在同一个页面上与其他</div><div class="t m0 x0 h5 y47c8 ff142 fs2 fc0 sc0 ls3b">的JavaScript库共存。  </div><div class="t m0 x0 h4 y47c9 ff142 fs2 fc0 sc0 ls8 ws1">命名空间很重要的一部分是确定每个人都同意使用的全局对象的名字，并且尽可能唯一，让其他人</div></div></div>
<div id="pf2aa" class="pf w0 h0" data-page-no="2aa"><div class="pc pc2aa w0 h0"><div class="t m0 x0 h2 y1 ff13c fs0 fc0 sc0 ls7 ws0">664  第24章 最佳实践 </div><div class="t m0 x0 h3 y2 ff13c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff142 fs2 fc0 sc0 ls8 ws1">不太可能也使用这个名字。在大多数情况下，可以是开发代码的公司的名字，例如YAHOO或者Wrox。</div><div class="t m0 x0 h5 y4d ff142 fs2 fc0 sc0 ls8 ws1">你可以如下例所示开始创建命名空间来组合功能。 </div><div class="t m0 x0 hb y2d8 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y639 ff146 fs6 fc0 sc0 ls21">//创建全局对象 </div><div class="t m0 x0 hb y63a ff146 fs6 fc0 sc0 ls21 wsb">var Wrox = {}; </div><div class="t m0 x0 hb y63b ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y63c ff146 fs6 fc0 sc0 ls21">//为 Professional JavaScript创建命名空间 </div><div class="t m0 x0 hb y63d ff146 fs6 fc0 sc0 ls21 wsb">Wrox.ProJS = {}; </div><div class="t m0 x0 hb y63e ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y47ca ff146 fs6 fc0 sc0 ls21">//将书中用到的对象附加上去 </div><div class="t m0 x0 hb y47cb ff146 fs6 fc0 sc0 ls21 wsb">Wrox.ProJS.EventUtil = { ... }; </div><div class="t m0 x0 hb y47cc ff146 fs6 fc0 sc0 ls21 wsb">Wrox.ProJS.CookieUtil = { ... }; </div><div class="t m0 x0 hb y47cd ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1f59 ff142 fs2 fc0 sc0 ls8 ws1">在这个例子中，Wrox是全局量，其他命名空间在此之上创建。如果本书所有代码都放在Wrox.ProJS</div><div class="t m0 x0 h4 y1aaa ff142 fs2 fc0 sc0 ls8 ws1">命名空间，那么其他作者也应把自己的代码添加到Wrox对象中。只要所有人都遵循这个规则，那么就</div><div class="t m0 x0 h1e y3714 ff142 fs2 fc0 sc0 ls8 ws1">不用担心其他人也创建叫做EventUtil或者CookieUtil的对象，因为它会存在于不同的命名空间中。</div><div class="t m0 x0 h5 y1f5c ff142 fs2 fc0 sc0 ls8 ws1">请看以下例子： </div><div class="t m0 x0 hb y47ce ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y47cf ff146 fs6 fc0 sc0 ls21">//为Professional Ajax创建命名空间 </div><div class="t m0 x0 hb y47d0 ff146 fs6 fc0 sc0 ls21 wsb">Wrox.ProAjax = {}; </div><div class="t m0 x0 hb y47d1 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y47d2 ff146 fs6 fc0 sc0 ls21">//附加该书中所使用的其他对象 </div><div class="t m0 x0 hb y47d3 ff146 fs6 fc0 sc0 ls21 wsb">Wrox.ProAjax.EventUtil = { ... }; </div><div class="t m0 x0 hb y47d4 ff146 fs6 fc0 sc0 ls21 wsb">Wrox.ProAjax.CookieUtil = { ... }; </div><div class="t m0 x0 hb y47d5 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y47d6 ff146 fs6 fc0 sc0 ls21 ws34">//ProJS还可以继续分别访问 </div><div class="t m0 x0 hb y47d7 ff146 fs6 fc0 sc0 ls21 wsb">Wrox.ProJS.EventUtil.addHandler( ... ); </div><div class="t m0 x0 hb y47d8 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y47d9 ff146 fs6 fc0 sc0 ls21">//以及ProAjax  </div><div class="t m0 x0 hb y47da ff146 fs6 fc0 sc0 ls21 wsb">Wrox.ProAjax.EventUtil.addHandler( ... ); </div><div class="t m0 x0 hb y47db ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y47dc ff142 fs2 fc0 sc0 ls8 ws1">虽然命名空间会需要多写一些代码，但是对于可维护的目的而言是值得的。命名空间有助于确保代</div><div class="t m0 x0 h5 y47dd ff142 fs2 fc0 sc0 ls8 ws1">码可以在同一个页面上与其他代码以无害的方式一起工作。  </div><div class="t m0 x0 h3c y47de ff140 fs2 fc0 sc0 ls94">3.避免与null进行比较  </div><div class="t m0 x0 h5 y47df ff142 fs2 fc0 sc0 ls8 ws1">由于JavaScript不做任何自动的类型检查，所有它就成了开发人员的责任。因此，在JavaScript代码</div><div class="t m0 x0 h4 y47e0 ff142 fs2 fc0 sc0 ls6 ws6">中其实很少进行类型检测。最常见的类型检测就是查看某个值是否为null。但是，直接将值与null</div><div class="t m0 x0 h5 y47e1 ff142 fs2 fc0 sc0 ls8 ws1">比较是使用过度的，并且常常由于不充分的类型检查导致错误。看以下例子： </div><div class="t m0 x0 hb y47e2 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y47e3 ff146 fs6 fc0 sc0 ls21 wsb">function sortArray(values){ </div><div class="t m0 x0 h16 y47e4 ff146 fs6 fc0 sc0 ls21 wsb">    if (values != null){           //避免！ </div><div class="t m0 x0 hb y47e5 ff146 fs6 fc0 sc0 ls21 wsb">        values.sort(comparator); </div><div class="t m0 x0 hb y47e6 ff146 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y47e7 ff146 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h4 y2aa5 ff142 fs2 fc0 sc0 ls8 ws1">该函数的目的是根据给定的比较子对一个数组进行排序。为了函数能正确执行，values参数必需</div><div class="t m0 x0 h1e y2aa6 ff142 fs2 fc0 sc0 ls8 ws1">是数组，但这里的if语句仅仅检查该values是否为 null。还有其他的值可以通过if语句，包括字</div><div class="t m0 x0 h5 y4227 ff142 fs2 fc0 sc0 ls8 ws1">符串、数字，它们会导致函数抛出错误。 </div><div class="t m0 x0 h1e y47e8 ff142 fs2 fc0 sc0 ls8 ws1">现实中，与null比较很少适合情况而被使用。必须按照所期望的对值进行检查，而非按照不被期</div><div class="t m0 x0 h1e y47e9 ff142 fs2 fc0 sc0 ls8 ws1">望的那些。例如，在前面的范例中，values参数应该是一个数组，那么就要检查它是不是一个数组，</div><div class="t m0 x0 hc y2aaa ff142 fs2 fc0 sc0 ls8 ws1">而不是检查它是否非null。函数按照下面的方式修改会更加合适： </div><div class="t m0 x0 hb y422a ff146 fs6 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf2ab" class="pf w0 h0" data-page-no="2ab"><div class="pc pc2ab w0 h0"><div class="t m0 x2 h2 y1 ff13c fs0 fc0 sc0 ls7 ws0">24.1 可维护性    665 </div><div class="t m0 x0 h3 y2 ff13c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff145 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff145 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff145 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff145 fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff145 fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff145 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff145 fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff145 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff145 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff145 fs3 fc2 sc0 ls1d wsb">22 </div><div class="t m0 x3 h8 y27 ff145 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ff145 fs3 fc2 sc0 ls1d wsb">24 </div><div class="t m0 x3 h8 y1fce ff145 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y8f5 ff146 fs6 fc0 sc0 ls21 wsb">function sortArray(values){ </div><div class="t m0 x0 h16 y8f6 ff14a fs6 fc0 sc0 ls21 wsb">    if (values instanceof Array){     //推荐 </div><div class="t m0 x0 hb y8f7 ff146 fs6 fc0 sc0 ls21 wsb">        values.sort(comparator); </div><div class="t m0 x0 hb y8f8 ff146 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y8f9 ff146 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h5 y47ea ff142 fs2 fc0 sc0 ls8 ws1">该函数的这个版本可以阻止所有非法值，而且完全用不着null。 </div><div class="t m0 x5 ha y47eb ff13d fs2 fc0 sc0 ls8 ws14">这种验证数组的技术在多框架的网页中不一定正确工作，因为每个框架都有其自</div><div class="t m0 x5 ha y47ec ff13d fs2 fc0 sc0 ls8 ws14">己的全局对象，因此，也有自己的Array构造函数。如果你是从一个框架将数组传</div><div class="t m0 x5 h18 y47ed ff13d fs2 fc0 sc0 ls8 ws14">送到另一个框架，那么就要另外检查是否存在sort()方法。 </div><div class="t m0 x0 h54 y47ee ff142 fs2 fc0 sc0 ls8 ws1">如果看到了与null比较的代码，尝试使用以下技术替换： </div><div class="t m0 x0 h5 y47ef ff141 fs1 fc0 sc0 ls2"> 如果值应为一个引用类型，使用instanceof操作符检查其构造函数； </div><div class="t m0 x0 h5 y47f0 ff141 fs1 fc0 sc0 ls2"> 如果值应为一个基本类型，使用typeof检查其类型； </div><div class="t m0 x0 h4 y4631 ff141 fs1 fc0 sc0 ls2"> 如果是希望对象包含某个特定的方法名，则使用typeof操作符确保指定名字的方法存在于对</div><div class="t m0 x5 h5 y47f1 ff142 fs2 fc0 sc0 ls8">象上。 </div><div class="t m0 x0 hc y114d ff142 fs2 fc0 sc0 ls8 ws1">代码中的null比较越少，就越容易确定代码的目的，并消除不必要的错误。  </div><div class="t m0 x0 h3c y47f2 ff140 fs2 fc0 sc0 ls2e wsb">4. 使用常量  </div><div class="t m0 x0 h5 y47f3 ff142 fs2 fc0 sc0 ls8 ws1">尽管JavaScript没有常量的正式概念，但它还是很有用的。这种将数据从应用逻辑分离出来的思想，</div><div class="t m0 x0 h5 y47f4 ff142 fs2 fc0 sc0 ls8 ws1">可以在不冒引入错误的风险的同时，就改变数据。请看以下例子： </div><div class="t m0 x5 hb y47f5 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y47f6 ff146 fs6 fc0 sc0 ls21 wsb">function validate(value){ </div><div class="t m0 x0 hb y47f7 ff146 fs6 fc0 sc0 ls21 wsb">    if (!value){ </div><div class="t m0 x0 hb y47f8 ff146 fs6 fc0 sc0 ls21 wsb">        alert(&quot;Invalid value!&quot;); </div><div class="t m0 x0 hb y47f9 ff146 fs6 fc0 sc0 ls21 wsb">        location.href = &quot;/errors/invalid.php&quot;; </div><div class="t m0 x0 hb y47fa ff146 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y47fb ff146 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h5 y47fc ff142 fs2 fc0 sc0 ls8 ws1">在这个函数中有两段数据：要显示给用户的信息以及URL。显示在用户界面上的字符串应该以允许</div><div class="t m0 x0 h5 y47fd ff142 fs2 fc0 sc0 ls8 ws1">进行语言国际化的方式抽取出来。URL也应被抽取出来，因为它们有随着应用成长而改变的倾向。基本</div><div class="t m0 x0 h5 y47fe ff142 fs2 fc0 sc0 ls8 ws1">上，有着可能由于这样那样原因会变化的这些数据，那么都会需要找到函数并在其中修改代码 。而每次</div><div class="t m0 x0 h4 y47ff ff142 fs2 fc0 sc0 ls8 ws1">修改应用逻辑的代码，都可能会引入错误。可以通过将数据抽取出来变成单独定义的常量的方式，将应</div><div class="t m0 x0 h5 y4800 ff142 fs2 fc0 sc0 ls8 ws1">用逻辑与数据修改隔离开来。请看以下例子： </div><div class="t m0 x5 hb yd5b ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y4801 ff14a fs6 fc0 sc0 ls21 wsb">var Constants = { </div><div class="t m0 x0 h15 y4802 ff14a fs6 fc0 sc0 ls21 wsb">    INVALID_VALUE_MSG: &quot;Invalid value!&quot;, </div><div class="t m0 x0 h15 y4803 ff14a fs6 fc0 sc0 ls21 wsb">    INVALID_VALUE_URL: &quot;/errors/invalid.php&quot; </div><div class="t m0 x0 h15 y4804 ff14a fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y4805 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4806 ff146 fs6 fc0 sc0 ls21 wsb">function validate(value){ </div><div class="t m0 x0 hb y4807 ff146 fs6 fc0 sc0 ls21 wsb">    if (!value){ </div><div class="t m0 x0 h15 y4808 ff14a fs6 fc0 sc0 ls21 wsb">        alert(Constants.INVALID_VALUE_MSG); </div><div class="t m0 x0 h15 y4809 ff14a fs6 fc0 sc0 ls21 wsb">        location.href = Constants.INVALID_VALUE_URL; </div><div class="t m0 x0 hb y480a ff146 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y480b ff146 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h5 y3f92 ff142 fs2 fc0 sc0 ls8 ws1">在这段重写过的代码中，消息和URL 都被定义于Constants对象中，然后函数引用这些值。这些</div><div class="t m0 x0 h1e y3f93 ff142 fs2 fc0 sc0 ls6 ws6">设置允许数据在无须接触使用它的函数的情况下进行变更。Constants对象甚至可以完全在单独的文</div><div class="t m0 x2 h2 y480c ff13c fs0 fc0 sc0 ls7 ws0">24.1 可维护性</div></div></div>
<div id="pf2ac" class="pf w0 h0" data-page-no="2ac"><div class="pc pc2ac w0 h0"><div class="t m0 x0 h2 y1 ff13c fs0 fc0 sc0 ls7 ws0">666  第24章 最佳实践 </div><div class="t m0 x0 h3 y2 ff13c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff142 fs2 fc0 sc0 ls8 ws1">件中进行定义，同时该文件可以由包含正确值的其他过程根据国际化设置来生成。 </div><div class="t m0 x0 h5 y4d ff142 fs2 fc0 sc0 ls8 ws1">关键在于将数据和使用它的逻辑进行分离。要注意的值的类型如下所示。 </div><div class="t m0 x0 h4 y4e ff141 fs1 fc0 sc0 ls2"> 重复值——任何在多处用到的值都应抽取为一个常量。这就限制了当一个值变了而另一个没变</div><div class="t m0 x0 h5 yd9 ff142 fs2 fc0 sc0 ls8 ws1">的时候会造成的错误。这也包含了CSS类名。 </div><div class="t m0 x0 h5 y219 ff141 fs1 fc0 sc0 ls2"> 用户界面字符串 —— 任何用于显示给用户的字符串，都应被抽取出来以方便国际化。 </div><div class="t m0 x0 h5 y8 ff141 fs1 fc0 sc0 ls2"> URLs —— 在Web应用中，资源位置很容易变更，所以推荐用一个公共地方存放所有的URL。 </div><div class="t m0 x0 h5 y9 ff141 fs1 fc0 sc0 ls2"> 任意可能会更改的值 —— 每当你在用到字面量值的时候，你都要问一下自己这个值在未来是不</div><div class="t m0 x0 h5 y15f ff142 fs2 fc0 sc0 ls8 ws1">是会变化。如果答案是“是”，那么这个值就应该被提取出来作为一个常量。 </div><div class="t m0 x0 h5 y2df1 ff142 fs2 fc0 sc0 ls8 ws1">对于企业级的JavaScript开发而言，使用常量是非常重要的技巧，因为它能让代码更容易维护，并</div><div class="t m0 x0 h5 y3729 ff142 fs2 fc0 sc0 ls8 ws1">且在数据更改的同时保护代码。  </div><div class="t m0 x0 hd y480d ff140 fs7 fc0 sc0 ls245">24.2 性能  </div><div class="t m0 x0 h5 y21 ff142 fs2 fc0 sc0 ls8 ws1">自从JavaScript诞生以来，用这门语言编写网页的开发人员有了极大的增长。与此同时，JavaScript</div><div class="t m0 x0 h5 y480e ff142 fs2 fc0 sc0 ls8 ws1">代码的执行效率也越来越受到关注。因为JavaScript最初是一个解释型语言，执行速度要比编译型语言</div><div class="t m0 x0 h5 y480f ff142 fs2 fc0 sc0 ls8 ws1">慢得多。Chrome是第一款内置优化引擎，将JavaScript编译成本地代码的浏览器。此后，主流浏览器纷</div><div class="t m0 x0 h5 y4810 ff142 fs2 fc0 sc0 ls8 ws1">纷效仿，陆续实现了JavaScript的编译执行。 </div><div class="t m0 x0 h5 y4811 ff142 fs2 fc0 sc0 ls8 ws1">即使到了编译执行JavaScript的新阶段，仍然会存在低效率的代码。不过，还是有一些方式可以改</div><div class="t m0 x0 h5 y4812 ff142 fs2 fc0 sc0 ls8 ws1">进代码的整体性能的。  </div><div class="t m0 x0 h20 y38bc ff140 fs3 fc0 sc0 ls248 ws214">24.2.1 注意作用域 </div><div class="t m0 x0 h5 y1d0a ff142 fs2 fc0 sc0 lsea">第4章讨论了JavaScript中“作用域”的概念以及作用域链是如何运作的。随着作用域链中的作用</div><div class="t m0 x0 h4 y5b3 ff142 fs2 fc0 sc0 ls8 ws1">域数量的增加，访问当前作用域以外的变量的时间也在增加。访问全局变量总是要比访问局部变量慢，</div><div class="t m0 x0 h5 y5b4 ff142 fs2 fc0 sc0 ls8 ws1">因为需要遍历作用域链。只要能减少花费在作用域链上的时间，就能增加脚本的整体性能。  </div><div class="t m0 x0 h3c y4813 ff140 fs2 fc0 sc0 ls94">1.避免全局查找  </div><div class="t m0 x0 h4 y4814 ff142 fs2 fc0 sc0 ls8 ws1">可能优化脚本性能最重要的就是注意全局查找。使用全局变量和函数肯定要比局部的开销更大，因</div><div class="t m0 x0 h5 y4815 ff142 fs2 fc0 sc0 ls8 ws1">为要涉及作用域链上的查找。请看以下函数： </div><div class="t m0 x0 hb yd13 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4816 ff146 fs6 fc0 sc0 ls21 wsb">function updateUI(){ </div><div class="t m0 x0 hb y4817 ff146 fs6 fc0 sc0 ls21 wsb">    var imgs = document.getElementsByTagName(&quot;img&quot;); </div><div class="t m0 x0 hb y4818 ff146 fs6 fc0 sc0 ls21 wsb">    for (var i=0, len=imgs.length; i &lt; len; i++){ </div><div class="t m0 x0 hb y4819 ff146 fs6 fc0 sc0 ls21 wsb">         imgs[i].title = document.title + &quot; image &quot; + i; </div><div class="t m0 x0 hb y481a ff146 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y481b ff146 fs6 fc0 sc0 ls21 wsb">    var msg = document.getElementById(&quot;msg&quot;); </div><div class="t m0 x0 hb y481c ff146 fs6 fc0 sc0 ls21 wsb">    msg.innerHTML = &quot;Update complete.&quot;; </div><div class="t m0 x0 hb y481d ff146 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h4 y481e ff142 fs2 fc0 sc0 ls8 ws1">该函数可能看上去完全正常，但是它包含了三个对于全局document对象的引用。如果在页面上有</div><div class="t m0 x0 h4 y481f ff142 fs2 fc0 sc0 ls8 ws1">多个图片，那么for循环中的document 引用就会被执行多次甚至上百次，每次都会要进行作用域链</div><div class="t m0 x0 h1e y4820 ff142 fs2 fc0 sc0 ls8 ws1">查找。通过创建一个指向document对象的局部变量，就可以通过限制一次全局查找来改进这个函数的</div><div class="t m0 x0 h5 y4821 ff142 fs2 fc0 sc0 ls8">性能： </div><div class="t m0 x0 h5 y4822 ff13c fs2 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf2ad" class="pf w0 h0" data-page-no="2ad"><div class="pc pc2ad w0 h0"><div class="t m0 x2 h2 y1 ff13c fs0 fc0 sc0 ls7 ws0">24.2 性能  667 </div><div class="t m0 x0 h3 y2 ff13c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff145 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff145 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff145 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff145 fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff145 fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff145 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff145 fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff145 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff145 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff145 fs3 fc2 sc0 ls1d wsb">22 </div><div class="t m0 x3 h8 y27 ff145 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ff145 fs3 fc2 sc0 ls1d wsb">24 </div><div class="t m0 x3 h8 y1fce ff145 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y8f5 ff146 fs6 fc0 sc0 ls21 wsb">function updateUI(){ </div><div class="t m0 x0 h15 y8f6 ff14a fs6 fc0 sc0 ls21 wsb">    var doc = document; </div><div class="t m0 x0 h15 y8f7 ff14a fs6 fc0 sc0 ls21 wsb">    var imgs = doc.getElementsByTagName(&quot;img&quot;); </div><div class="t m0 x0 hb y8f8 ff146 fs6 fc0 sc0 ls21 wsb">    for (var i=0, len=imgs.length; i &lt; len; i++){ </div><div class="t m0 x0 h15 y8f9 ff14a fs6 fc0 sc0 ls21 wsb">        imgs[i].title = doc.title + &quot; image &quot; + i; </div><div class="t m0 x0 hb y8fa ff146 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y8fb ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y8fc ff14a fs6 fc0 sc0 ls21 wsb">    var msg = doc.getElementById(&quot;msg&quot;); </div><div class="t m0 x0 hb y8fd ff146 fs6 fc0 sc0 ls21 wsb">    msg.innerHTML = &quot;Update complete.&quot;; </div><div class="t m0 x0 hb y1037 ff146 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h4 y4823 ff142 fs2 fc0 sc0 ls8 ws1">这里，首先将document对象存在本地的doc变量中；然后在余下的代码中替换原来的document。</div><div class="t m0 x0 h5 y4824 ff142 fs2 fc0 sc0 ls8 ws1">与原来的的版本相比，现在的函数只有一次全局查找，肯定更快。 </div><div class="t m0 x0 h5 y4825 ff142 fs2 fc0 sc0 ls8 ws1">将在一个函数中会用到多次的全局对象存储为局部变量总是没错的。  </div><div class="t m0 x0 hac y4826 ff140 fs2 fc0 sc0 ls2e wsb">2. 避免with语句  </div><div class="t m0 x0 h4 y4827 ff142 fs2 fc0 sc0 ls8 ws1">在性能非常重要的地方必须避免使用with语句。和函数类似，with语句会创建自己的作用域，</div><div class="t m0 x0 h1e y4828 ff142 fs2 fc0 sc0 ls8 ws1">因此会增加其中执行的代码的作用域链的长度。由于额外的作用域链查找，在with语句中执行的代码</div><div class="t m0 x0 h5 y4829 ff142 fs2 fc0 sc0 ls8 ws1">肯定会比外面执行的代码要慢。 </div><div class="t m0 x0 h1e y482a ff142 fs2 fc0 sc0 ls8 ws1">必须使用with语句的情况很少，因为它主要用于消除额外的字符。在大多数情况下，可以用局部</div><div class="t m0 x0 h5 ye2d ff142 fs2 fc0 sc0 ls8 ws1">变量完成相同的事情而不引入新的作用域。下面是一个例子： </div><div class="t m0 x5 hb y3ea2 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y482b ff146 fs6 fc0 sc0 ls21 wsb">function updateBody(){ </div><div class="t m0 x0 hb y482c ff146 fs6 fc0 sc0 ls21 wsb">    with(document.body){ </div><div class="t m0 x0 hb y482d ff146 fs6 fc0 sc0 ls21 wsb">       alert(tagName); </div><div class="t m0 x0 hb y482e ff146 fs6 fc0 sc0 ls21 wsb">       innerHTML = &quot;Hello world!&quot;; </div><div class="t m0 x0 hb y482f ff146 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y4830 ff146 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h4 y4831 ff142 fs2 fc0 sc0 ls8 ws1">这段代码中的with语句让document.body变得更容易使用。其实可以使用局部变量达到相同的</div><div class="t m0 x0 h5 y4832 ff142 fs2 fc0 sc0 ls8 ws1">效果，如下所示：  </div><div class="t m0 x5 hb y2863 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4833 ff146 fs6 fc0 sc0 ls21 wsb">function updateBody(){ </div><div class="t m0 x0 hb y4834 ff146 fs6 fc0 sc0 ls21 wsb">    var body = document.body </div><div class="t m0 x0 hb y4835 ff146 fs6 fc0 sc0 ls21 wsb">    alert(body.tagName); </div><div class="t m0 x0 hb y4836 ff146 fs6 fc0 sc0 ls21 wsb">    body.innerHTML = &quot;Hello world!&quot;; </div><div class="t m0 x0 hb y4837 ff146 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h4 y1969 ff142 fs2 fc0 sc0 ls3ba ws330">虽然代码稍微长了点，但是阅读起来比with语句版本更好，它确保让你知道 tagName和</div><div class="t m0 x0 h4 y4838 ff146 fs1 fc0 sc0 ls9 ws2">innerHTML是属于哪个对象的。同时，这段代码通过将document.body存储在局部变量中省去了额</div><div class="t m0 x0 h5 y4839 ff142 fs2 fc0 sc0 ls8 ws1">外的全局查找。 </div><div class="t m0 x0 h20 y1989 ff140 fs3 fc0 sc0 ls248 ws214">24.2.2 选择正确方法 </div><div class="t m0 x0 h4 y3229 ff142 fs2 fc0 sc0 ls8 ws1">和其他语言一样，性能问题的一部分是和用于解决问题的算法或者方法有关的。老练的开发人员根</div><div class="t m0 x0 h4 y2b53 ff142 fs2 fc0 sc0 ls4">据经验可以得知哪种方法可能获得更好的性能。很多应用在其他编程语言中的技术和方法也可以在</div><div class="t m0 x0 h5 y483a ff13c fs2 fc0 sc0 lsb ws5">JavaScript中使用。  </div><div class="t m0 x0 h3c y483b ff140 fs2 fc0 sc0 ls2e wsb">1. 避免不必要的属性查找  </div><div class="t m0 x0 h5 y483c ff142 fs2 fc0 sc0 ls8 ws1">在计算机科学中，算法的复杂度是使用O符号来表示的。最简单、最快捷的算法是常数值即O(1)。</div><div class="t m0 x0 h5 y483d ff142 fs2 fc0 sc0 ls8 ws1">之后，算法变得越来越复杂并花更长时间执行。下面的表格列出了JavaScript中常见的算法类型。 </div></div></div>
<div id="pf2ae" class="pf w0 h0" data-page-no="2ae"><div class="pc pc2ae w0 h0"><div class="t m0 x0 h2 y1 ff13c fs0 fc0 sc0 ls7 ws0">668  第24章 最佳实践 </div><div class="t m0 x0 h3 y2 ff13c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h31 y483f ff13f fs6 fc0 sc0 lsa7 wsb">标  记  名  称   描  述  </div><div class="t m0 x0 h16b y4840 ff13c fs6 fc0 sc0 ls14e ws11c">O(1)   常数 不管有多少值，执行的时间都是恒定的。一般表示简单值和存储在变量中的值 </div><div class="t m0 x0 h16b y2aab ff13c fs6 fc0 sc0 ls267 wsb">O(log n)   对数 总的执行时间和值的数量相关，但是要完成算法并不一定要获取每个值。例如：二分查找 </div><div class="t m0 x0 h16b y4841 ff13c fs6 fc0 sc0 ls1ca ws227">O(n)   线性 总执行时间和值的数量直接相关。例如：遍历某个数组中的所有元素 </div><div class="t m0 x0 h16c y4842 ff13c fs6 fc0 sc0 ls1ca ws227">O(n2)   平方 总执行时间和值的数量有关，每个值至少要获取n次。例如：插入排序 </div><div class="t m0 x0 h5 y2a98 ff13c fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y4843 ff142 fs2 fc0 sc0 ls8 ws1">常数值，即O(1)，指代字面值和存储在变量中的值。符号O(1)表示无论有多少个值，需要获取常</div><div class="t m0 x0 h5 y4844 ff142 fs2 fc0 sc0 ls8 ws1">量值的时间都一样。获取常量值是非常高效的过程。请看下面代码：  </div><div class="t m0 x0 hb y4845 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4846 ff146 fs6 fc0 sc0 ls21 wsb">var value = 5;  </div><div class="t m0 x0 hb y4847 ff146 fs6 fc0 sc0 ls21 wsb">var sum = 10 + value;  </div><div class="t m0 x0 hb y4848 ff146 fs6 fc0 sc0 ls21 wsb">alert(sum);  </div><div class="t m0 x0 hb y4849 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y484a ff142 fs2 fc0 sc0 ls8 ws1">该代码进行了四次常量值查找：数字5，变量value，数字10和变量 sum。这段代码的整体复杂</div><div class="t m0 x0 h5 y484b ff142 fs2 fc0 sc0 ls8 ws1">度被认为是O(1)。 </div><div class="t m0 x0 h5 y484c ff142 fs2 fc0 sc0 ls8d">在JavaScript中访问数组元素也是一个O(1)操作，和简单的变量查找效率一样。所以以下代码和前</div><div class="t m0 x0 h5 y484d ff142 fs2 fc0 sc0 ls8 ws1">面的例子效率一样：  </div><div class="t m0 x0 hb y2e9a ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y484e ff146 fs6 fc0 sc0 ls21 wsb">var values = [5, 10];  </div><div class="t m0 x0 hb y484f ff146 fs6 fc0 sc0 ls21 wsb">var sum = values[0] + values[1];  </div><div class="t m0 x0 hb y4850 ff146 fs6 fc0 sc0 ls21 wsb">alert(sum);  </div><div class="t m0 x0 hb y4851 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3bd6 ff142 fs2 fc0 sc0 ls8 ws1">使用变量和数组要比访问对象上的属性更有效率，后者是一个O(n)操作。对象上的任何属性查找都</div><div class="t m0 x0 h4 y3bd7 ff142 fs2 fc0 sc0 ls8 ws1">要比访问变量或者数组花费更长时间，因为必须在原型链中对拥有该名称的属性进行一次搜索。简而言</div><div class="t m0 x0 h5 y3bd8 ff142 fs2 fc0 sc0 ls8 ws1">之，属性查找越多，执行时间就越长。请看以下内容：  </div><div class="t m0 x0 hb y4852 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4853 ff146 fs6 fc0 sc0 ls21 wsb">var values = { first: 5, second: 10};  </div><div class="t m0 x0 hb y4854 ff146 fs6 fc0 sc0 ls21 wsb">var sum = values.first + values.second;  </div><div class="t m0 x0 hb y4855 ff146 fs6 fc0 sc0 ls21 wsb">alert(sum);  </div><div class="t m0 x0 hb y4856 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y160e ff142 fs2 fc0 sc0 ls8 ws1">这段代码使用两次属性查找来计算sum的值。进行一两次属性查找并不会导致显著的性能问题，但</div><div class="t m0 x0 h5 y1a97 ff142 fs2 fc0 sc0 ls8 ws1">是进行成百上千次则肯定会减慢执行速度。 </div><div class="t m0 x0 h5 y4857 ff142 fs2 fc0 sc0 ls8 ws1">注意获取单个值的多重属性查找。例如，请看以下代码：  </div><div class="t m0 x0 hb y4858 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4859 ff146 fs6 fc0 sc0 ls21 wsb">var query = window.location.href.substring(window.location.href.indexOf(&quot;?&quot;));  </div><div class="t m0 x0 hb y485a ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y811 ff142 fs2 fc0 sc0 ls55 ws49">在这段代码中，有6次属性查找：window.location.href.substring()有3次，window. </div><div class="t m0 x0 h5 ya9e ff146 fs1 fc0 sc0 ls9 ws2">location.href.indexOf()又有3次。只要数一数代码中的点的数量，就可以确定属性查找的次数了。</div><div class="t m0 x0 hc y485b ff142 fs2 fc0 sc0 ls8 ws1">这段代码由于两次用到了window.location.href，同样的查找进行了两次，因此效率特别不好。  </div><div class="t m0 x0 h5 y20a2 ff142 fs2 fc0 sc0 ls8 ws1">一旦多次用到对象属性，应该将其存储在局部变量中。第一次访问该值会是O(n)，然而后续的访问</div><div class="t m0 x0 h5 y20a3 ff142 fs2 fc0 sc0 ls8 ws1">都会是O(1)，就会节省很多。例如，之前的代码可以如下重写：  </div><div class="t m0 x0 hb y2cfb ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y485c ff146 fs6 fc0 sc0 ls21 wsb">var url = window.location.href;  </div><div class="t m0 x0 hb y485d ff146 fs6 fc0 sc0 ls21 wsb">var query = url.substring(url.indexOf(&quot;?&quot;));  </div><div class="t m0 x0 hb y485e ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1365 ff142 fs2 fc0 sc0 ls8 ws1">这个版本的代码只有4次属性查找，相对于原始版本节省了33%。在更大的脚本中进行这种优化，</div><div class="t m0 x0 h5 y485f ff142 fs2 fc0 sc0 ls8 ws1">倾向于获得更多改进。 </div></div></div>
<div id="pf2af" class="pf w0 h0" data-page-no="2af"><div class="pc pc2af w0 h0"><div class="t m0 x2 h2 y1 ff13c fs0 fc0 sc0 ls7 ws0">24.2 性能  669 </div><div class="t m0 x0 h3 y2 ff13c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff145 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff145 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff145 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff145 fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff145 fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff145 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff145 fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff145 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff145 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff145 fs3 fc2 sc0 ls1d wsb">22 </div><div class="t m0 x3 h8 y27 ff145 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ff145 fs3 fc2 sc0 ls1d wsb">24 </div><div class="t m0 x3 h8 y1fce ff145 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h4 y3 ff142 fs2 fc0 sc0 ls8 ws1">一般来讲，只要能减少算法的复杂度，就要尽可能减少。尽可能多地使用局部变量将属性查找替换</div><div class="t m0 x0 h4 y4d ff142 fs2 fc0 sc0 ls8 ws1">为值查找。进一步讲，如果即可以用数字化的数组位置进行访问，也可以使用命名属性（诸如NodeList</div><div class="t m0 x0 h5 y4e ff142 fs2 fc0 sc0 ls8 ws1">对象），那么使用数字位置。  </div><div class="t m0 x0 h3c y4860 ff140 fs2 fc0 sc0 ls2e wsb">2. 优化循环  </div><div class="t m0 x0 h5 y4861 ff142 fs2 fc0 sc0 ls8 ws1">循环是编程中最常见的结构，在JavaScript程序中同样随处可见。优化循环是性能优化过程中很重</div><div class="t m0 x0 h4 yd42 ff142 fs2 fc0 sc0 ls8 ws1">要的一个部分，由于它们会反复运行同一段代码，从而自动地增加执行时间。在其他语言中对于循环优</div><div class="t m0 x0 h5 yd43 ff142 fs2 fc0 sc0 ls8 ws1">化有大量研究，这些技术也可以应用于JavaScript。一个循环的基本优化步骤如下所示。  </div><div class="t m0 x0 h5 y280e ff13c fs2 fc0 sc0 ls13 wsb">(1) 减值迭代——大多数循环使用一个从0开始、增加到某个特定值的迭代器。在很多情况下，从</div><div class="t m0 x0 h5 y4713 ff142 fs2 fc0 sc0 ls8 ws1">最大值开始，在循环中不断减值的迭代器更加高效。  </div><div class="t m0 x0 h5 y11d7 ff13c fs2 fc0 sc0 ls13 wsb">(2) 简化终止条件——由于每次循环过程都会计算终止条件，所以必须保证它尽可能快。也就是说</div><div class="t m0 x0 h5 y4714 ff142 fs2 fc0 sc0 ls8 ws1">避免属性查找或其他O(n)的操作。  </div><div class="t m0 x0 h5 y4715 ff13c fs2 fc0 sc0 ls13 wsb">(3) 简化循环体——循环体是执行最多的，所以要确保其被最大限度地优化。确保没有某些可以被</div><div class="t m0 x0 h5 y4862 ff142 fs2 fc0 sc0 ls8 ws1">很容易移出循环的密集计算。  </div><div class="t m0 x0 h5 y4863 ff13c fs2 fc0 sc0 ls13 wsb">(4) 使用后测试循环——最常用for循环和while循环都是前测试循环。而如do-while 这种后测</div><div class="t m0 x0 h5 y1349 ff142 fs2 fc0 sc0 ls8 ws1">试循环，可以避免最初终止条件的计算，因此运行更快。  </div><div class="t m0 x0 hc y20f1 ff142 fs2 fc0 sc0 ls8 ws1">用一个例子来描述这种改动。以下是一个基本的for循环：  </div><div class="t m0 x5 hb y1204 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4864 ff146 fs6 fc0 sc0 ls21 wsb">for (var i=0; i &lt; values.length; i++){  </div><div class="t m0 x0 hb y4865 ff146 fs6 fc0 sc0 ls21 wsb">    process(values[i]);  </div><div class="t m0 x0 hb y4866 ff146 fs6 fc0 sc0 ls21 wsb">}   </div><div class="t m0 x0 h4 y4867 ff142 fs2 fc0 sc0 ls8 ws1">这段代码中变量i从0递增到values数组中的元素总数。假设值的处理顺序无关紧要，那么循环</div><div class="t m0 x0 hc y4868 ff142 fs2 fc0 sc0 ls8 ws1">可以改为i减值，如下所示：  </div><div class="t m0 x5 hb y134f ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y4869 ff14a fs6 fc0 sc0 ls21 wsb">for (var i=values.length -1; i &gt;= 0; i--){  </div><div class="t m0 x0 hb y486a ff146 fs6 fc0 sc0 ls21 wsb">    process(values[i]);  </div><div class="t m0 x0 hb y486b ff146 fs6 fc0 sc0 ls21 wsb">}   </div><div class="t m0 x0 h5 y486c ff142 fs2 fc0 sc0 ls8 ws1">这里，变量i每次循环之后都会减1。在这个过程中，将终止条件从value.length 的O(n)调用</div><div class="t m0 x0 hc yc24 ff142 fs2 fc0 sc0 ls8 ws1">简化成了0的O(1)调用。由于循环体只有一个语句，无法进一步优化。不过循环还能改成后测试循环，</div><div class="t m0 x0 h5 y486d ff142 fs2 fc0 sc0 ls8">如下： </div><div class="t m0 x5 hb y463f ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y486e ff14a fs6 fc0 sc0 ls21 wsb">var i=values.length -1;  </div><div class="t m0 x0 h15 y486f ff14a fs6 fc0 sc0 ls21 wsb">if (i &gt; -1){ </div><div class="t m0 x0 h15 y4870 ff14a fs6 fc0 sc0 ls21 wsb">    do {  </div><div class="t m0 x0 hb y4871 ff146 fs6 fc0 sc0 ls21 wsb">        process(values[i]);  </div><div class="t m0 x0 hb y4872 ff146 fs6 fc0 sc0 ls21 wsb">    }while(--i &gt;= 0);  </div><div class="t m0 x0 h15 y4873 ff14a fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h4 y4874 ff142 fs2 fc0 sc0 ls24 ws1e">此处主要的优化是将终止条件和自减操作符组合成了单个语句。这时，任何进一步的优化只能在</div><div class="t m0 x0 h5 y3c6a ff146 fs1 fc0 sc0 ls9 ws2">process()函数中进行了，因为循环部分已经优化完全了。  </div><div class="t m0 x0 h4 y4875 ff142 fs2 fc0 sc0 ls8 ws1">记住使用“后测试”循环时必须确保要处理的值至少有一个。空数组会导致多余的一次循环而“前</div><div class="t m0 x0 h5 y4876 ff142 fs2 fc0 sc0 ls8 ws1">测试”循环则可以避免。  </div><div class="t m0 x0 h3c y4877 ff140 fs2 fc0 sc0 ls2e wsb">3. 展开循环  </div><div class="t m0 x0 h5 y4878 ff142 fs2 fc0 sc0 ls8 ws1">当循环的次数是确定的，消除循环并使用多次函数调用往往更快 。请看一下前面的例子。如果数组</div><div class="t m0 x0 h67 y4879 ff142 fs2 fc0 sc0 ls8 ws1">的长度总是一样的，对每个元素都调用process()可能更优，如以下代码所示： </div><div class="t m0 x5 hb y3dcf ff146 fs6 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf2b0" class="pf w0 h0" data-page-no="2b0"><div class="pc pc2b0 w0 h0"><div class="t m0 x0 h2 y1 ff13c fs0 fc0 sc0 ls7 ws0">670  第24章 最佳实践 </div><div class="t m0 x0 h3 y2 ff13c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y79 ff146 fs6 fc0 sc0 ls21">//消除循环  </div><div class="t m0 x0 hb y7a ff146 fs6 fc0 sc0 ls21 wsb">process(values[0]);  </div><div class="t m0 x0 hb y7b ff146 fs6 fc0 sc0 ls21 wsb">process(values[1]);  </div><div class="t m0 x0 hb y7c ff146 fs6 fc0 sc0 ls21 wsb">process(values[2]);  </div><div class="t m0 x0 hb y2d01 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y487a ff142 fs2 fc0 sc0 ls8 ws1">这个例子假设values数组里面只有3个元素，直接对每个元素调用 process()。这样展开循环</div><div class="t m0 x0 h5 y487b ff142 fs2 fc0 sc0 ls8 ws1">可以消除建立循环和处理终止条件的额外开销，使代码运行得更快。 </div><div class="t m0 x0 h5 y487c ff142 fs2 fc0 sc0 ls8 ws1">如果循环中的迭代次数不能事先确定，那可以考虑使用一种叫做Duff装置的技术。这个技术是以</div><div class="t m0 x0 h5 y487d ff142 fs2 fc0 sc0 ls8 ws1">其创建者Tom Duff命名的，他最早在C语言中使用这项技术。正是 Jeff Greenberg用JavaScript实现了</div><div class="t m0 x0 h5 y487e ff13c fs2 fc0 sc0 ls138 ws133">Duff装置。Duff装置的基本概念是通过计算迭代的次数是否为8的倍数将一个循环展开为一系列语句。</div><div class="t m0 x0 h5 y487f ff142 fs2 fc0 sc0 ls8 ws1">请看以下代码：   </div><div class="t m0 x0 hb y4406 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4407 ff146 fs6 fc0 sc0 ls21 wsb">//credit: Jeff Greenberg for JS implementation of Duff’s Device  </div><div class="t m0 x0 h16 y4408 ff146 fs6 fc0 sc0 ls21">//假设 values.length &gt; 0 </div><div class="t m0 x0 hb y4880 ff146 fs6 fc0 sc0 ls21 wsb">var iterations = Math.ceil(values.length / 8);  </div><div class="t m0 x0 hb y4881 ff146 fs6 fc0 sc0 ls21 wsb">var startAt = values.length % 8;  </div><div class="t m0 x0 hb y4882 ff146 fs6 fc0 sc0 ls21 wsb">var i = 0;  </div><div class="t m0 x0 hb y4883 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4884 ff146 fs6 fc0 sc0 ls21 wsb">do {  </div><div class="t m0 x0 hb y4885 ff146 fs6 fc0 sc0 ls21 wsb">    switch(startAt){  </div><div class="t m0 x0 hb y4886 ff146 fs6 fc0 sc0 ls21 wsb">        case 0: process(values[i++]);  </div><div class="t m0 x0 hb y4887 ff146 fs6 fc0 sc0 ls21 wsb">        case 7: process(values[i++]);  </div><div class="t m0 x0 hb y4888 ff146 fs6 fc0 sc0 ls21 wsb">        case 6: process(values[i++]);  </div><div class="t m0 x0 hb y4889 ff146 fs6 fc0 sc0 ls21 wsb">        case 5: process(values[i++]);  </div><div class="t m0 x0 hb y488a ff146 fs6 fc0 sc0 ls21 wsb">        case 4: process(values[i++]);  </div><div class="t m0 x0 hb y488b ff146 fs6 fc0 sc0 ls21 wsb">        case 3: process(values[i++]);  </div><div class="t m0 x0 hb y488c ff146 fs6 fc0 sc0 ls21 wsb">        case 2: process(values[i++]);  </div><div class="t m0 x0 hb y488d ff146 fs6 fc0 sc0 ls21 wsb">        case 1: process(values[i++]);  </div><div class="t m0 x0 hb y488e ff146 fs6 fc0 sc0 ls21 wsb">    }  </div><div class="t m0 x0 hb y488f ff146 fs6 fc0 sc0 ls21 wsb">    startAt = 0;  </div><div class="t m0 x0 hb y4890 ff146 fs6 fc0 sc0 ls21 wsb">} while (--iterations &gt; 0);  </div><div class="t m0 x0 hb y4891 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y4892 ff13c fs2 fc0 sc0 ls138 ws133">Duff装置的实现是通过将values数组中元素个数除以8来计算出循环需要进行多少次迭代的。然</div><div class="t m0 x0 h5 y4893 ff142 fs2 fc0 sc0 ls8 ws1">后使用取整的上限函数确保结果是整数。如果完全根据除8来进行迭代，可能会有一些不能被处理到的</div><div class="t m0 x0 h1c y4894 ff142 fs2 fc0 sc0 ls8 ws1">元素，这个数量保存在startAt变量中。首次执行该循环时，会检查StartAt变量看有需要多少额外</div><div class="t m0 x0 h1e y4895 ff142 fs2 fc0 sc0 ls8 ws1">调用。例如，如果数组中有10个值，startAt则等于2，那么最开始的时候process()则只会被调用</div><div class="t m0 x0 h5 y282f ff13c fs2 fc0 sc0 ls38">2次。在接下来的循环中，startAt被重置为0，这样之后的每次循环都会调用8次process()。展开</div><div class="t m0 x0 h5 y4896 ff142 fs2 fc0 sc0 ls8 ws1">循环可以提升大数据集的处理速度。  </div><div class="t m0 x0 h5 y4897 ff142 fs2 fc0 sc0 ls3b">由Andrew B. King 所著的Speed Up Your Site（New Riders，2003）提出了一个更快的Duff装置技术，</div><div class="t m0 x0 h14 y4898 ff142 fs2 fc0 sc0 ls4a7">将do-while循环分成2个单独的循环。以下是例子：   </div><div class="t m0 x0 hb y9db ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4899 ff146 fs6 fc0 sc0 ls21 wsb">//credit: Speed Up Your Site (New Riders, 2003)  </div><div class="t m0 x0 hb y489a ff146 fs6 fc0 sc0 ls21 wsb">var iterations = Math.floor(values.length / 8);  </div><div class="t m0 x0 hb y489b ff146 fs6 fc0 sc0 ls21 wsb">var leftover = values.length % 8;  </div><div class="t m0 x0 hb y489c ff146 fs6 fc0 sc0 ls21 wsb">var i = 0;  </div><div class="t m0 x0 hb y489d ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y489e ff146 fs6 fc0 sc0 ls21 wsb">if (leftover &gt; 0){  </div><div class="t m0 x0 hb y489f ff146 fs6 fc0 sc0 ls21 wsb">    do {  </div><div class="t m0 x0 hb y48a0 ff146 fs6 fc0 sc0 ls21 wsb">        process(values[i++]);  </div><div class="t m0 x0 hb y48a1 ff146 fs6 fc0 sc0 ls21 wsb">    } while (--leftover &gt; 0);  </div><div class="t m0 x0 hb y48a2 ff146 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 hb y48a3 ff146 fs6 fc0 sc0 ls21 wsb">do { </div><div class="t m0 x0 hb y48a4 ff146 fs6 fc0 sc0 ls21 wsb">    process(values[i++]); </div></div></div>
<div id="pf2b1" class="pf w0 h0" data-page-no="2b1"><div class="pc pc2b1 w0 h0"><div class="t m0 x2 h2 y1 ff13c fs0 fc0 sc0 ls7 ws0">24.2 性能  671 </div><div class="t m0 x0 h3 y2 ff13c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff145 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff145 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff145 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff145 fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff145 fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff145 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff145 fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff145 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff145 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff145 fs3 fc2 sc0 ls1d wsb">22 </div><div class="t m0 x3 h8 y27 ff145 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ff145 fs3 fc2 sc0 ls1d wsb">24 </div><div class="t m0 x3 h8 y1fce ff145 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y79 ff146 fs6 fc0 sc0 ls21 wsb">    process(values[i++]); </div><div class="t m0 x0 hb y7a ff146 fs6 fc0 sc0 ls21 wsb">    process(values[i++]); </div><div class="t m0 x0 hb y7b ff146 fs6 fc0 sc0 ls21 wsb">    process(values[i++]); </div><div class="t m0 x0 hb y7c ff146 fs6 fc0 sc0 ls21 wsb">    process(values[i++]); </div><div class="t m0 x0 hb y7d ff146 fs6 fc0 sc0 ls21 wsb">    process(values[i++]); </div><div class="t m0 x0 hb y7e ff146 fs6 fc0 sc0 ls21 wsb">    process(values[i++]); </div><div class="t m0 x0 hb y7f ff146 fs6 fc0 sc0 ls21 wsb">    process(values[i++]); </div><div class="t m0 x0 hb y80 ff146 fs6 fc0 sc0 ls21 wsb">} while (--iterations &gt; 0); </div><div class="t m0 x5 hb ydc6 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y89a ff142 fs2 fc0 sc0 ls8 ws1">在这个实现中，剩余的计算部分不会在实际循环中处理，而是在一个初始化循环中进行除以8的操</div><div class="t m0 x0 hc y89b ff142 fs2 fc0 sc0 ls8 ws1">作。当处理掉了额外的元素，继续执行每次调用8次process()的主循环。这个方法几乎比原始的Duff</div><div class="t m0 x0 h5 y48a5 ff142 fs2 fc0 sc0 ls8 ws1">装置实现快上40%。 </div><div class="t m0 x0 h4 y48a6 ff142 fs2 fc0 sc0 ls8 ws1">针对大数据集使用展开循环可以节省很多时间，但对于小数据集，额外的开销则可能得不偿失。它</div><div class="t m0 x0 h5 y48a7 ff142 fs2 fc0 sc0 ls8 ws1">是要花更多的代码来完成同样的任务，如果处理的不是大数据集，一般来说并不值得。  </div><div class="t m0 x0 h3c y48a8 ff140 fs2 fc0 sc0 ls2e wsb">4. 避免双重解释  </div><div class="t m0 x0 h5 y48a9 ff142 fs2 fc0 sc0 ls197">当JavaScript代码想解析JavaScript 的时候就会存在双重解释惩罚。当使用eval()函数或者是</div><div class="t m0 x0 h5 y48aa ff146 fs1 fc0 sc0 ls20 ws16">Function构造函数以及使用setTimeout()传一个字符串参数时都会发生这种情况。下面有一些例子： </div><div class="t m0 x5 hb y1a27 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h2d y48ab ff146 fs6 fc0 sc0 ls21">//某些代码求值——避免!! </div><div class="t m0 x0 hb y48ac ff146 fs6 fc0 sc0 ls21 wsb">eval(&quot;alert(&apos;Hello world!&apos;)&quot;); </div><div class="t m0 x0 hb y48ad ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h2d y48ae ff146 fs6 fc0 sc0 ls21">//创建新函数——避免!! </div><div class="t m0 x0 hb y48af ff146 fs6 fc0 sc0 ls21 wsb">var sayHi = new Function(&quot;alert(&apos;Hello world!&apos;)&quot;); </div><div class="t m0 x0 hb y48b0 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h2d y48b1 ff146 fs6 fc0 sc0 ls21">//设置超时——避免!! </div><div class="t m0 x0 hb y48b2 ff146 fs6 fc0 sc0 ls21 wsb">setTimeout(&quot;alert(&apos;Hello world!&apos;)&quot;, 500); </div><div class="t m0 x5 hb y48b3 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y36c6 ff142 fs2 fc0 sc0 ls8 ws1">在以上这些例子中，都要解析包含了JavaScript代码的字符串。这个操作是不能在初始的解析过程</div><div class="t m0 x0 h5 y33f ff142 fs2 fc0 sc0 ls30 ws2a">中完成的，因为代码是包含在字符串中的，也就是说在JavaScript代码运行的同时必须新启动一个解</div><div class="t m0 x0 h5 y48b4 ff142 fs2 fc0 sc0 ls8 ws1">析器来解析新的代码。实例化一个新的解析器有不容忽视的开销，所以这种代码要比直接解析慢得多。 </div><div class="t m0 x0 h1c y48b5 ff142 fs2 fc0 sc0 ls8 ws1">对于这几个例子都有另外的办法。只有极少的情况下eval()是绝对必须的，所以尽可能避免使用。</div><div class="t m0 x0 h1e y48b6 ff142 fs2 fc0 sc0 ls8 ws1">在这个例子中，代码其实可以直接内嵌在原代码中。对于Function构造函数，完全可以直接写成一般</div><div class="t m0 x0 hc y48b7 ff142 fs2 fc0 sc0 ls8 ws1">的函数，调用setTimeout()可以传入函数作为第一个参数。以下是一些例子： </div><div class="t m0 x5 hb y1048 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y48b8 ff146 fs6 fc0 sc0 ls21">//已修正 </div><div class="t m0 x0 hb y48b9 ff146 fs6 fc0 sc0 ls21 wsb">alert(&apos;Hello world!&apos;); </div><div class="t m0 x0 hb y48ba ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h2d y48bb ff146 fs6 fc0 sc0 ls21">//创建新函数——已修正 </div><div class="t m0 x0 hb y48bc ff146 fs6 fc0 sc0 ls21 wsb">var sayHi = function(){ </div><div class="t m0 x0 hb y48bd ff146 fs6 fc0 sc0 ls21 wsb">    alert(&apos;Hello world!&apos;);  </div><div class="t m0 x0 hb y48be ff146 fs6 fc0 sc0 ls21 wsb">};  </div><div class="t m0 x0 hb y48bf ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h2d y48c0 ff146 fs6 fc0 sc0 ls21">//设置一个超时——已修正  </div><div class="t m0 x0 hb y48c1 ff146 fs6 fc0 sc0 ls21 wsb">setTimeout(function(){  </div><div class="t m0 x0 hb y48c2 ff146 fs6 fc0 sc0 ls21 wsb">    alert(&apos;Hello world!&apos;);  </div><div class="t m0 x0 hb y48c3 ff146 fs6 fc0 sc0 ls21 wsb">}, 500);  </div><div class="t m0 x5 hb y48c4 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y48c5 ff142 fs2 fc0 sc0 ls8 ws1">如果要提高代码性能，尽可能避免出现需要按照JavaScript解释的字符串。  </div><div class="t m0 x0 h3c y48c6 ff140 fs2 fc0 sc0 ls2e wsb">5. 性能的其他注意事项  </div><div class="t m0 x0 h4 y48c7 ff142 fs2 fc0 sc0 ls8 ws1">当评估脚本性能的时候，还有其他一些可以考虑的东西。下面并非主要的问题，不过如果使用得当</div><div class="t m0 x0 h5 y48c8 ff142 fs2 fc0 sc0 ls8 ws1">也会有相当大的提升。  </div></div></div>
<div id="pf2b2" class="pf w0 h0" data-page-no="2b2"><div class="pc pc2b2 w0 h0"><div class="t m0 x0 h2 y1 ff13c fs0 fc0 sc0 ls7 ws0">672  第24章 最佳实践 </div><div class="t m0 x0 h3 y2 ff13c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff141 fs1 fc0 sc0 ls2"> 原生方法较快——只要有可能，使用原生方法而不是自己用JavaScript重写一个。原生方法是用</div><div class="t m0 x0 h5 y4d ff142 fs2 fc0 sc0 ls8 ws1">诸如C/C++之类的编译型语言写出来的，所以要比JavaScript的快很多很多。JavaScript 中最容</div><div class="t m0 x0 he yd8 ff142 fs2 fc0 sc0 ls8 ws1">易被忘记的就是可以在Math对象中找到的复杂的数学运算；这些方法要比任何用JavaScript写</div><div class="t m0 x0 h5 yd9 ff142 fs2 fc0 sc0 ls8 ws1">的同样方法如正弦、余弦快的多。  </div><div class="t m0 x0 h5 y219 ff141 fs1 fc0 sc0 ls2"> Switch语句较快 —— 如果有一系列复杂的if-else语句，可以转换成单个switch 语句则可</div><div class="t m0 x0 h1e y21a ff142 fs2 fc0 sc0 ls8 ws1">以得到更快的代码。还可以通过将case语句按照最可能的到最不可能的顺序进行组织，来进一</div><div class="t m0 x0 hc y15e ff142 fs2 fc0 sc0 ls8 ws1">步优化switch语句。  </div><div class="t m0 x0 h5 ya ff141 fs1 fc0 sc0 ls2"> 位运算符较快 —— 当进行数学运算的时候，位运算操作要比任何布尔运算或者算数运算快。选</div><div class="t m0 x0 h4 yb ff142 fs2 fc0 sc0 ls5 ws4">择性地用位运算替换算数运算可以极大提升复杂计算的性能。诸如取模，逻辑与和逻辑或都可</div><div class="t m0 x0 h5 y78a ff142 fs2 fc0 sc0 ls8 ws1">以考虑用位运算来替换。  </div><div class="t m0 x0 h20 y48c9 ff140 fs3 fc0 sc0 ls248 ws214">24.2.3 最小化语句数  </div><div class="t m0 x0 h5 y48ca ff13c fs2 fc0 sc0 lsb ws5">JavaScript代码中的语句数量也影响所执行的操作的速度。完成多个操作的单个语句要比完成单个</div><div class="t m0 x0 h4 y1257 ff142 fs2 fc0 sc0 ls8 ws1">操作的多个语句快。所以，就要找出可以组合在一起的语句，以减少脚本整体的执行时间。这里有几个</div><div class="t m0 x0 h5 y3f95 ff142 fs2 fc0 sc0 ls8 ws1">可以参考的模式。  </div><div class="t m0 x0 h3c y48cb ff140 fs2 fc0 sc0 ls2e wsb">1. 多个变量声明  </div><div class="t m0 x0 h4 y48cc ff142 fs2 fc0 sc0 ls24 ws1e">有个地方很多开发人员都容易创建很多语句，那就是多个变量的声明。很容易看到代码中由多个</div><div class="t m0 x0 h5 y2297 ff146 fs1 fc0 sc0 ls9 ws2">var语句来声明多个变量，如下所示：  </div><div class="t m0 x0 hb y48cd ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y48ce ff146 fs6 fc0 sc0 ls21 ws34">//4个语句</div><div class="t m5 x5 h16d y3543 ff14c fs6 fc0 sc0 ls4ad">——</div><div class="t m0 x5 h16 y3543 ff147 fs6 fc0 sc0 ls31 ws24">很浪费  </div><div class="t m0 x0 hb y48cf ff146 fs6 fc0 sc0 ls21 wsb">var count = 5;  </div><div class="t m0 x0 hb y48d0 ff146 fs6 fc0 sc0 ls21 wsb">var color = &quot;blue&quot;;  </div><div class="t m0 x0 hb y48d1 ff146 fs6 fc0 sc0 ls21 wsb">var values = [1,2,3];  </div><div class="t m0 x0 hb y48d2 ff146 fs6 fc0 sc0 ls21 wsb">var now = new Date();  </div><div class="t m0 x0 hb y48d3 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1351 ff142 fs2 fc0 sc0 ls8 ws1">在强类型语言中，不同的数据类型的变量必须在不同的语句中声明。然而，在JavaScript中所有的</div><div class="t m0 x0 hc y48d4 ff142 fs2 fc0 sc0 ls8 ws1">变量都可以使用单个var语句来声明。前面的代码可以如下重写： </div><div class="t m0 x0 hb y48d5 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y48d6 ff146 fs6 fc0 sc0 ls21">//一个语句  </div><div class="t m0 x0 hb y48d7 ff146 fs6 fc0 sc0 ls21 wsb">var count = 5,  </div><div class="t m0 x0 hb y48d8 ff146 fs6 fc0 sc0 ls21 wsb">    color = &quot;blue&quot;,  </div><div class="t m0 x0 hb y48d9 ff146 fs6 fc0 sc0 ls21 wsb">    values = [1,2,3],  </div><div class="t m0 x0 hb y48da ff146 fs6 fc0 sc0 ls21 wsb">    now = new Date();  </div><div class="t m0 x0 hb y48db ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y48dc ff142 fs2 fc0 sc0 ls8 ws1">此处，变量声明只用了一个var语句，之间由逗号隔开。在大多数情况下这种优化都非常容易做，</div><div class="t m0 x0 h5 y48dd ff142 fs2 fc0 sc0 ls8 ws1">并且要比单个变量分别声明快很多。  </div><div class="t m0 x0 h3c y48de ff140 fs2 fc0 sc0 ls2e wsb">2. 插入迭代值  </div><div class="t m0 x0 h4 y48df ff142 fs2 fc0 sc0 ls24 ws1e">当使用迭代值（也就是在不同的位置进行增加或减少的值）的时候，尽可能合并语句。请看以下</div><div class="t m0 x0 h5 y48e0 ff142 fs2 fc0 sc0 ls5">代码： </div><div class="t m0 x0 hb y48e1 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y48e2 ff146 fs6 fc0 sc0 ls21 wsb">var name = values[i];  </div><div class="t m0 x0 hb y48e3 ff146 fs6 fc0 sc0 ls21 wsb">i++;  </div><div class="t m0 x0 hb y48e4 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y48e5 ff142 fs2 fc0 sc0 ls8 ws1">前面这2句语句各只有一个目的：第一个从values数组中获取值，然后存储在 name中；第二个</div><div class="t m0 x0 hb9 y48e6 ff142 fs2 fc0 sc0 ls8 ws1">给变量i增加1。这两句可以通过迭代值插入第一个语句组合成一个语句，如下所示：  </div><div class="t m0 x0 hb y30fd ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y48e7 ff146 fs6 fc0 sc0 ls21 wsb">var name = values[i++];  </div><div class="t m0 x0 hb y48e8 ff146 fs6 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf2b3" class="pf w0 h0" data-page-no="2b3"><div class="pc pc2b3 w0 h0"><div class="t m0 x2 h2 y1 ff13c fs0 fc0 sc0 ls7 ws0">24.2 性能  673 </div><div class="t m0 x0 h3 y2 ff13c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff145 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff145 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff145 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff145 fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff145 fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff145 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff145 fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff145 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff145 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff145 fs3 fc2 sc0 ls1d wsb">22 </div><div class="t m0 x3 h8 y27 ff145 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ff145 fs3 fc2 sc0 ls1d wsb">24 </div><div class="t m0 x3 h8 y1fce ff145 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h4 y3 ff142 fs2 fc0 sc0 ls8 ws1">这一个语句可以完成和前面两个语句一样的事情。因为自增操作符是后缀操作符，i的值只有在语</div><div class="t m0 x0 h5 y4d ff142 fs2 fc0 sc0 ls8 ws1">句其他部分结束之后才会增加。一旦出现类似情况，都要尝试将迭代值插入到最后使用它的语句中去。  </div><div class="t m0 x0 h3c y2041 ff140 fs2 fc0 sc0 ls2e wsb">3. 使用数组和对象字面量  </div><div class="t m0 x0 h4 y20ed ff142 fs2 fc0 sc0 ls8 ws1">本书中，你可能看过两种创建数组和对象的方法：使用构造函数或者是使用字面量。使用构造函数</div><div class="t m0 x0 h4 y334a ff142 fs2 fc0 sc0 ls8 ws1">总是要用到更多的语句来插入元素或者定义属性，而字面量可以将这些操作在一个语句中完成。请看以</div><div class="t m0 x0 h5 y334b ff142 fs2 fc0 sc0 ls8">下例子：  </div><div class="t m0 x5 hb y19b8 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h2d y1a01 ff146 fs6 fc0 sc0 ls21">//用4个语句创建和初始化数组——浪费  </div><div class="t m0 x0 hb y48e9 ff146 fs6 fc0 sc0 ls21 wsb">var values = new Array();  </div><div class="t m0 x0 hb y48ea ff146 fs6 fc0 sc0 ls21 wsb">values[0] = 123;  </div><div class="t m0 x0 hb y48eb ff146 fs6 fc0 sc0 ls21 wsb">values[1] = 456;  </div><div class="t m0 x0 hb y48ec ff146 fs6 fc0 sc0 ls21 wsb">values[2] = 789;  </div><div class="t m0 x0 hb y48ed ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h2d y48ee ff146 fs6 fc0 sc0 ls21">//用4个语句创建和初始化对象——浪费  </div><div class="t m0 x0 hb y48ef ff146 fs6 fc0 sc0 ls21 wsb">var person = new Object();  </div><div class="t m0 x0 hb y48f0 ff146 fs6 fc0 sc0 ls21 wsb">person.name = &quot;Nicholas&quot;;  </div><div class="t m0 x0 hb y48f1 ff146 fs6 fc0 sc0 ls21 wsb">person.age = 29;  </div><div class="t m0 x0 hb y48f2 ff146 fs6 fc0 sc0 ls21 wsb">person.sayName = function(){  </div><div class="t m0 x0 hb y48f3 ff146 fs6 fc0 sc0 ls21 wsb">    alert(this.name);  </div><div class="t m0 x0 hb y48f4 ff146 fs6 fc0 sc0 ls21 wsb">};   </div><div class="t m0 x0 h5 y625 ff142 fs2 fc0 sc0 ls8 ws1">这段代码中，只创建和初始化了一个数组和一个对象。各用了4个语句：一个调用构造函数，其他</div><div class="t m0 x0 h5 y48f5 ff13c fs2 fc0 sc0 ls38">3个分配数据。其实可以很容易地转换成使用字面量的形式，如下所示：  </div><div class="t m0 x5 hb y2c6a ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y48f6 ff146 fs6 fc0 sc0 ls21">//只用一条语句创建和初始化数组  </div><div class="t m0 x0 hb y48f7 ff146 fs6 fc0 sc0 ls21 wsb">var values = [123, 456, 789];  </div><div class="t m0 x0 hb y48f8 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y48f9 ff146 fs6 fc0 sc0 ls21">//只用一条语句创建和初始化对象  </div><div class="t m0 x0 hb y48fa ff146 fs6 fc0 sc0 ls21 wsb">var person = {  </div><div class="t m0 x0 hb y48fb ff146 fs6 fc0 sc0 ls21 wsb">    name : &quot;Nicholas&quot;,  </div><div class="t m0 x0 hb y48fc ff146 fs6 fc0 sc0 ls21 wsb">    age : 29,  </div><div class="t m0 x0 hb y48fd ff146 fs6 fc0 sc0 ls21 wsb">    sayName : function(){  </div><div class="t m0 x0 hb y48fe ff146 fs6 fc0 sc0 ls21 wsb">        alert(this.name);  </div><div class="t m0 x0 hb y48ff ff146 fs6 fc0 sc0 ls21 wsb">    }  </div><div class="t m0 x0 hb y4900 ff146 fs6 fc0 sc0 ls21 wsb">};   </div><div class="t m0 x0 h4 y4901 ff142 fs2 fc0 sc0 ls8 ws1">重写后的代码只包含两条语句，一条创建和初始化数组，另一条创建和初始化对象。之前用了八条</div><div class="t m0 x0 h5 y4902 ff142 fs2 fc0 sc0 ls8 ws1">语句的东西现在只用了两条，减少了75%的语句量。在包含成千上万行JavaScript的代码库中，这些优</div><div class="t m0 x0 h5 y4903 ff142 fs2 fc0 sc0 ls8 ws1">化的价值更大。  </div><div class="t m0 x0 h5 y4904 ff142 fs2 fc0 sc0 ls8 ws1">只要有可能，尽量使用数组和对象的字面量表达方式来消除不必要的语句。  </div><div class="t m0 x5 h5 y4905 ff13d fs2 fc0 sc0 ls3b">在IE6和更早版本中使用字面量有微小的性能惩罚。不过这些问题在IE7中已经</div><div class="t m0 x5 h5 y4906 ff13d fs2 fc0 sc0 ls8">解决。  </div><div class="t m0 x0 h20 y4907 ff140 fs3 fc0 sc0 ls248 ws214">24.2.4 优化DOM交互  </div><div class="t m0 x0 h5 y3a0 ff142 fs2 fc0 sc0 ls71">在JavaScript各个方面中，DOM毫无疑问是最慢的一部分。DOM操作与交互要消耗大量时间，</div><div class="t m0 x0 h4 y4908 ff142 fs2 fc0 sc0 ls30 ws2a">因为它们往往需要重新渲染整个页面或者某一部分。进一步说，看似细微的操作也可能要花很久来执</div><div class="t m0 x0 h5 y4909 ff142 fs2 fc0 sc0 ls24 ws1e">行，因为DOM要处理非常多的信息。理解如何优化与DOM的交互可以极大得提高脚本完成的速度。  </div></div></div>
<div id="pf2b4" class="pf w0 h0" data-page-no="2b4"><div class="pc pc2b4 w0 h0"><div class="t m0 x0 h2 y1 ff13c fs0 fc0 sc0 ls7 ws0">674  第24章 最佳实践 </div><div class="t m0 x0 h3 y2 ff13c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h3c y68b ff140 fs2 fc0 sc0 ls2e wsb">1. 最小化现场更新  </div><div class="t m0 x0 h5 y68c ff142 fs2 fc0 sc0 ls8 ws1">一旦你需要访问的DOM部分是已经显示的页面的一部分，那么你就是在进行一个现场更新。之所</div><div class="t m0 x0 h4 y15dc ff142 fs2 fc0 sc0 ls8 ws1">以叫现场更新，是因为需要立即（现场）对页面对用户的显示进行更新。每一个更改，不管是插入单个</div><div class="t m0 x0 h4 y15dd ff142 fs2 fc0 sc0 ls8 ws1">字符，还是移除整个片段，都有一个性能惩罚，因为浏览器要重新计算无数尺寸以进行更新。现场更新</div><div class="t m0 x0 h4 y15de ff142 fs2 fc0 sc0 ls8 ws1">进行得越多，代码完成执行所花的时间就越长；完成一个操作所需的现场更新越少，代码就越快。请看</div><div class="t m0 x0 h5 y15df ff142 fs2 fc0 sc0 ls8 ws1">以下例子：  </div><div class="t m0 x0 hb y19b8 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y1a01 ff146 fs6 fc0 sc0 ls21 wsb">var list = document.getElementById(&quot;myList&quot;), </div><div class="t m0 x5 hb y48e9 ff146 fs6 fc0 sc0 ls21 wsb">item, </div><div class="t m0 x5 hb y48ea ff146 fs6 fc0 sc0 ls21 wsb">i;  </div><div class="t m0 x0 hb y48eb ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y48ec ff146 fs6 fc0 sc0 ls21 wsb">for (i=0; i &lt; 10; i++) {  </div><div class="t m0 x0 hb y48ed ff146 fs6 fc0 sc0 ls21 wsb">    item = document.createElement(&quot;li&quot;);  </div><div class="t m0 x0 hb y48ee ff146 fs6 fc0 sc0 ls21 wsb">    list.appendChild(item);  </div><div class="t m0 x0 hb y48ef ff146 fs6 fc0 sc0 ls21 wsb">    item.appendChild(document.createTextNode(&quot;Item &quot; + i));  </div><div class="t m0 x0 hb y48f0 ff146 fs6 fc0 sc0 ls21 wsb">}   </div><div class="t m0 x0 h5 y490a ff142 fs2 fc0 sc0 ls8 ws1">这段代码为列表添加了10个项目。添加每个项目时，都有2个现场更新：一个添加&lt;li&gt;元素，另</div><div class="t m0 x0 h5 y490b ff142 fs2 fc0 sc0 ls8 ws1">一个给它添加文本节点。这样添加10个项目，这个操作总共要完成20个现场更新。  </div><div class="t m0 x0 h5 y490c ff142 fs2 fc0 sc0 ls8 ws1">要修正这个性能瓶颈，需要减少现场更新的数量。一般有2种方法。第一种是将列表从页面上移除，</div><div class="t m0 x0 h4 y490d ff142 fs2 fc0 sc0 ls8 ws1">最后进行更新，最后再将列表插回到同样的位置。这个方法不是非常理想，因为在每次页面更新的时候</div><div class="t m0 x0 h5 y490e ff142 fs2 fc0 sc0 ls8 ws1">它会不必要的闪烁。第二个方法是使用文档片段来构建DOM结构，接着将其添加到List元素中。这</div><div class="t m0 x0 h5 y490f ff142 fs2 fc0 sc0 ls8 ws1">个方式避免了现场更新和页面闪烁问题。请看下面内容：  </div><div class="t m0 x0 hb y3439 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4910 ff146 fs6 fc0 sc0 ls21 wsb">var list = document.getElementById(&quot;myList&quot;),  </div><div class="t m0 x0 hb y4911 ff146 fs6 fc0 sc0 ls21 wsb">    fragment = document.createDocumentFragment(), </div><div class="t m0 x0 hb y4912 ff146 fs6 fc0 sc0 ls21 wsb">    item, </div><div class="t m0 x0 hb y4913 ff146 fs6 fc0 sc0 ls21 wsb">    i; </div><div class="t m0 x0 hb y4914 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4915 ff146 fs6 fc0 sc0 ls21 wsb">for (i=0; i &lt; 10; i++) {  </div><div class="t m0 x0 hb y4916 ff146 fs6 fc0 sc0 ls21 wsb">    item = document.createElement(&quot;li&quot;);  </div><div class="t m0 x0 h15 y4917 ff14a fs6 fc0 sc0 ls21 wsb">    fragment.appendChild(item);  </div><div class="t m0 x0 hb y4918 ff146 fs6 fc0 sc0 ls21 wsb">    item.appendChild(document.createTextNode(&quot;Item &quot; + i));  </div><div class="t m0 x0 hb y4919 ff146 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 hb y491a ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y491b ff14a fs6 fc0 sc0 ls21 wsb">list.appendChild(fragment);  </div><div class="t m0 x0 hb y491c ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y6d ff142 fs2 fc0 sc0 ls8 ws1">在这个例子中只有一次现场更新，它发生在所有项目都创建好之后。文档片段用作一个临时的占位</div><div class="t m0 x0 h1e y6e ff142 fs2 fc0 sc0 ls8 ws1">符，放置新创建的项目。然后使用appendChild()将所有项目添加到列表中。记住，当给appendChild()</div><div class="t m0 x0 h5 y811 ff142 fs2 fc0 sc0 ls8 ws1">传入文档片段时，只有片段中的子节点被添加到目标，片段本身不会被添加的。  </div><div class="t m0 x0 h5 y491d ff142 fs2 fc0 sc0 ls8 ws1">一旦需要更新DOM，请考虑使用文档片段来构建DOM结构，然后再将其添加到现存的文档中。  </div><div class="t m0 x0 h3c y491e ff140 fs2 fc0 sc0 ls2e wsb">2. 使用 innerHTML  </div><div class="t m0 x0 h5 y491f ff142 fs2 fc0 sc0 ls8 ws1">有两种在页面上创建DOM节点的方法：使用诸如createElement()和appendChild()之类的</div><div class="t m0 x0 hc y3029 ff13c fs2 fc0 sc0 ls81 ws76">DOM方法，以及使用innerHTML。对于小的DOM更改而言，两种方法效率都差不多。然而，对于大</div><div class="t m0 x0 hc y302a ff142 fs2 fc0 sc0 ls3b">的DOM更改，使用innerHTML要比使用标准DOM方法创建同样的 DOM结构快得多。 </div><div class="t m0 x0 h5 y25ab ff142 fs2 fc0 sc0 ls8 ws1">当把innerHTML设置为某个值时，后台会创建一个HTML解析器，然后使用内部的 DOM调用来</div><div class="t m0 x0 h5 y2e49 ff142 fs2 fc0 sc0 ls8 ws1">创建DOM结构，而非基于JavaScript的DOM调用。由于内部方法是编译好的而非解释执行的，所以执</div><div class="t m0 x0 he y2e4a ff142 fs2 fc0 sc0 ls8 ws1">行快得多。前面的例子还可以用innerHTML改写如下：  </div><div class="t m0 x0 hb y33c7 ff146 fs6 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf2b5" class="pf w0 h0" data-page-no="2b5"><div class="pc pc2b5 w0 h0"><div class="t m0 x2 h2 y1 ff13c fs0 fc0 sc0 ls7 ws0">24.2 性能  675 </div><div class="t m0 x0 h3 y2 ff13c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff145 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff145 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff145 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff145 fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff145 fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff145 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff145 fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff145 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff145 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff145 fs3 fc2 sc0 ls1d wsb">22 </div><div class="t m0 x3 h8 y27 ff145 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ff145 fs3 fc2 sc0 ls1d wsb">24 </div><div class="t m0 x3 h8 y1fce ff145 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 hb y8f5 ff146 fs6 fc0 sc0 ls21 wsb">var list = document.getElementById(&quot;myList&quot;), </div><div class="t m0 x0 hb y8f6 ff146 fs6 fc0 sc0 ls21 wsb">    html = &quot;&quot;, </div><div class="t m0 x0 hb y8f7 ff146 fs6 fc0 sc0 ls21 wsb">    i; </div><div class="t m0 x0 hb y8f8 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y8f9 ff146 fs6 fc0 sc0 ls21 wsb">for (i=0; i &lt; 10; i++) {  </div><div class="t m0 x0 h15 y8fa ff14a fs6 fc0 sc0 ls21 wsb">    html += &quot;&lt;li&gt;Item &quot; + i + &quot;&lt;/li&gt;&quot;;  </div><div class="t m0 x0 hb y8fb ff146 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h15 y8fc ff14a fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y8fd ff14a fs6 fc0 sc0 ls21 wsb">list.innerHTML = html;  </div><div class="t m0 x5 hb y4920 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3c51 ff142 fs2 fc0 sc0 ls8 ws1">这段代码构建了一个HTML字符串，然后将其指定到list.innerHTML，便创建了需要的DOM结</div><div class="t m0 x0 h5 y4921 ff142 fs2 fc0 sc0 ls8 ws1">构。虽然字符串连接上总是有点性能损失，但这种方式还是要比进行多个DOM操作更快。 </div><div class="t m0 x0 he y4922 ff142 fs2 fc0 sc0 ls8 ws1">使用innerHTML的关键在于（和其他DOM 操作一样）最小化调用它的次数。例如，下面的代码</div><div class="t m0 x0 h5 ya89 ff142 fs2 fc0 sc0 ls8 ws1">在这个操作中用到innerHTML的次数太多了：  </div><div class="t m0 x5 hb y3c53 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4923 ff146 fs6 fc0 sc0 ls21 wsb">var list = document.getElementById(&quot;myList&quot;), </div><div class="t m0 x0 hb y4924 ff146 fs6 fc0 sc0 ls21 wsb">    i; </div><div class="t m0 x0 hb y4925 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4926 ff146 fs6 fc0 sc0 ls21 wsb">for (i=0; i &lt; 10; i++) {  </div><div class="t m0 x0 h16 y4927 ff14a fs6 fc0 sc0 ls21 wsb">    list.innerHTML += &quot;&lt;li&gt;Item &quot; + i + &quot;&lt;/li&gt;&quot;;         //避免!!!  </div><div class="t m0 x0 hb y4928 ff146 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 hb y4929 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y492a ff142 fs2 fc0 sc0 ls8 ws1">这段代码的问题在于每次循环都要调用innerHTML，这是极其低效的。调用innerHTML实际上就</div><div class="t m0 x0 h1e y492b ff142 fs2 fc0 sc0 ls3ba ws330">是一次现场更新，所以也要如此对待。构建好一个字符串然后一次性调用innerHTML要比调用</div><div class="t m0 x0 h5 y10e3 ff146 fs1 fc0 sc0 ls9 ws2">innerHTML多次快得多。  </div><div class="t m0 x0 h3c y492c ff140 fs2 fc0 sc0 ls2e wsb">3. 使用事件代理  </div><div class="t m0 x0 h5 y492d ff142 fs2 fc0 sc0 ls8 ws1">大多数Web应用在用户交互上大量用到事件处理程序。页面上的事件处理程序的数量和页面响应</div><div class="t m0 x0 h5 y492e ff142 fs2 fc0 sc0 ls8 ws1">用户交互的速度之间有个负相关。为了减轻这种惩罚，最好使用事件代理。 </div><div class="t m0 x0 h5 y492f ff142 fs2 fc0 sc0 ls8 ws1">事件代理，如第13章中所讨论的那样，用到了事件冒泡。任何可以冒泡的事件都不仅仅可以在事</div><div class="t m0 x0 h4 y4930 ff142 fs2 fc0 sc0 ls8 ws1">件目标上进行处理，目标的任何祖先节点上也能处理。使用这个知识，就可以将事件处理程序附加到更</div><div class="t m0 x0 h4 y4931 ff142 fs2 fc0 sc0 ls8 ws1">高层的地方负责多个目标的事件处理。如果可能，在文档级别附加事件处理程序，这样可以处理整个页</div><div class="t m0 x0 h5 y4932 ff142 fs2 fc0 sc0 ls8 ws1">面的事件。  </div><div class="t m0 x0 h3c y4933 ff140 fs2 fc0 sc0 ls2e wsb">4. 注意HTMLCollection  </div><div class="t m0 x0 h5 y4934 ff146 fs1 fc0 sc0 ls9 ws2">HTMLCollection对象的陷阱已经在本书中讨论过了，因为它们对于Web应用的性能而言是巨大</div><div class="t m0 x0 h1e y18bb ff142 fs2 fc0 sc0 ls8 ws1">的损害。记住，任何时候要访问HTMLCollection，不管它是一个属性还是一个方法，都是在文档上进</div><div class="t m0 x0 hc y305a ff142 fs2 fc0 sc0 ls8 ws1">行一个查询，这个查询开销很昂贵。最小化访问HTMLCollection的次数可以极大地改进脚本的性能。  </div><div class="t m0 x0 h4 y4935 ff142 fs2 fc0 sc0 ls8 ws1">也许优化HTMLCollection访问最重要的地方就是循环了。前面提到过将长度计算移入for循环</div><div class="t m0 x0 h5 y4936 ff142 fs2 fc0 sc0 ls8 ws1">的初始化部分。现在看一下这个例子：  </div><div class="t m0 x5 hb y232 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4937 ff146 fs6 fc0 sc0 ls21 wsb">var images = document.getElementsByTagName(&quot;img&quot;), </div><div class="t m0 x0 hb y4938 ff146 fs6 fc0 sc0 ls21 wsb">    i, len; </div><div class="t m0 x0 hb y4939 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y493a ff146 fs6 fc0 sc0 ls21 wsb">for (i=0, len=images.length; i &lt; len; i++){  </div><div class="t m0 x0 h16 y493b ff146 fs6 fc0 sc0 ls21 wsb">    //处理  </div><div class="t m0 x0 hb y493c ff146 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 hb y493d ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3ef0 ff142 fs2 fc0 sc0 ls8 ws1">这里的关键在于长度length存入了len变量，而不是每次都去访问HTMLCollection的length</div><div class="t m0 x0 h4 y493e ff142 fs2 fc0 sc0 ls8 ws1">属性。当在循环中使用HTMLCollection的时候，下一步应该是获取要使用的项目的引用，如下所示，</div><div class="t m0 x0 hc y493f ff142 fs2 fc0 sc0 ls8 ws1">以便避免在循环体内多次调用HTMLCollection。  </div></div></div>
<div id="pf2b6" class="pf w0 h0" data-page-no="2b6"><div class="pc pc2b6 w0 h0"><div class="t m0 x0 h2 y1 ff13c fs0 fc0 sc0 ls7 ws0">676  第24章 最佳实践 </div><div class="t m0 x0 h3 y2 ff13c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 ff146 fs6 fc0 sc0 ls21 wsb">var images = document.getElementsByTagName(&quot;img&quot;), </div><div class="t m0 x0 h15 y7a ff14a fs6 fc0 sc0 ls21 wsb">    image, </div><div class="t m0 x0 hb y7b ff146 fs6 fc0 sc0 ls21 wsb">    i, len; </div><div class="t m0 x0 hb y7c ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y7d ff146 fs6 fc0 sc0 ls21 wsb">for (i=0, len=images.length; i &lt; len; i++){  </div><div class="t m0 x0 h15 y7e ff14a fs6 fc0 sc0 ls21 wsb">    image = images[i];  </div><div class="t m0 x0 h16 y7f ff146 fs6 fc0 sc0 ls21 wsb">    //处理 </div><div class="t m0 x0 hb y80 ff146 fs6 fc0 sc0 ls21 wsb">}   </div><div class="t m0 x0 h5 y11ad ff142 fs2 fc0 sc0 ls8 ws1">这段代码添加了image变量，保存了当前的图像。这之后，在循环内就没有理由再访问images 的</div><div class="t m0 x0 h5 y1108 ff146 fs1 fc0 sc0 ls9 ws2">HTMLCollection了 。  </div><div class="t m0 x0 h5 y4940 ff142 fs2 fc0 sc0 ls8 ws1">编写JavaScript的时候，一定要知道何时返回HTMLCollection对象，这样你就可以最小化对他们</div><div class="t m0 x0 hc y9c4 ff142 fs2 fc0 sc0 ls8 ws1">的访问。发生以下情况时会返回HTMLCollection对象：  </div><div class="t m0 x0 h5 y4941 ff141 fs1 fc0 sc0 ls2"> 进行了对 getElementsByTagName() 的调用；  </div><div class="t m0 x0 h5 y4942 ff141 fs1 fc0 sc0 ls2"> 获取了元素的 childNodes 属性；  </div><div class="t m0 x0 h5 y4943 ff141 fs1 fc0 sc0 ls2"> 获取了元素的 attributes 属性； </div><div class="t m0 x0 h5 y2343 ff141 fs1 fc0 sc0 ls2"> 访问了特殊的集合，如document.forms、document.images等。  </div><div class="t m0 x0 hc y4944 ff142 fs2 fc0 sc0 ls8 ws1">要了解当使用HTMLCollection对象时，合理使用会极大提升代码执行速度。  </div><div class="t m0 x0 hd y4945 ff140 fs7 fc0 sc0 ls245">24.3 部署  </div><div class="t m0 x0 h5 y3edc ff142 fs2 fc0 sc0 ls8 ws1">也许所有JavaScript解决方案最重要的部分，便是最后部署到运营中的网站或者是Web应用的过程。</div><div class="t m0 x0 h4 yf7a ff142 fs2 fc0 sc0 ls8 ws1">在这之前可能你已经做了相当多的工作，为普通的使用进行架构并优化一个解决方案。现在是时候从开</div><div class="t m0 x0 h5 yf7b ff142 fs2 fc0 sc0 ls8 ws1">发环境中走出来并进入Web阶段了，在此将会和真正的用户交互。然而，在这之前还有一系列需要解</div><div class="t m0 x0 h5 yf7c ff142 fs2 fc0 sc0 ls8 ws1">决的问题。  </div><div class="t m0 x0 h20 y22b ff140 fs3 fc0 sc0 ls248 ws214">24.3.1 构建过程  </div><div class="t m0 x0 h5 y2073 ff142 fs2 fc0 sc0 ls8 ws1">完备JavaScript代码可以用于部署的一件很重要的事情，就是给它开发某些类型的构建过程。软件</div><div class="t m0 x0 h4 y48b7 ff142 fs2 fc0 sc0 ls8 ws1">开发的典型模式是写代码</div><div class="t m6 x1 h4 y1ca9 ff142 fs2 fc0 sc0 ls8">—</div><div class="t m0 x1 h4 y1ca9 ff142 fs2 fc0 sc0 ls8">编译</div><div class="t m6 x1 h4 y1ca9 ff142 fs2 fc0 sc0 ls8">—</div><div class="t m0 x1 h4 y1ca9 ff142 fs2 fc0 sc0 ls8 ws1">测试，即首先书写好代码，将其编译通过，然后运行并确保其正常工作。</div><div class="t m0 x0 h5 y4946 ff142 fs2 fc0 sc0 ls8 ws1">由于JavaScript并非一个编译型语言，模式变成了写代码</div><div class="t m6 x4 h4 y4946 ff142 fs2 fc0 sc0 ls8">—</div><div class="t m0 x4 h4 y4946 ff142 fs2 fc0 sc0 ls8 ws1">测试，这里你写的代码就是你要在浏览器中测</div><div class="t m0 x0 h4 y4947 ff142 fs2 fc0 sc0 ls8 ws1">试的代码。这个方法的问题在于它不是最优的，你写的代码不应该原封不动地放入浏览器中，理由如下</div><div class="t m0 x0 h5 y4948 ff142 fs2 fc0 sc0 ls8">所示。 </div><div class="t m0 x0 h5 y4949 ff141 fs1 fc0 sc0 ls2"> 知识产权问题 —— 如果把带有完整注释的代码放到线上，那别人就更容易知道你的意图，对它</div><div class="t m0 x0 h5 y494a ff142 fs2 fc0 sc0 ls8 ws1">再利用，并且可能找到安全漏洞。  </div><div class="t m0 x0 h5 y4696 ff141 fs1 fc0 sc0 ls2"> 文件大小 —— 书写代码要保证容易阅读，才能更好地维护，但是这对于性能是不利的。浏览器</div><div class="t m0 x0 h5 y494b ff142 fs2 fc0 sc0 ls8 ws1">并不能从额外的空白字符或者是冗长的函数名和变量名中获得什么好处。  </div><div class="t m0 x0 h5 y494c ff141 fs1 fc0 sc0 ls2"> 代码组织 —— 组织代码要考虑到可维护性并不一定是传送给浏览器的最好方式。  </div><div class="t m0 x0 h5 y11f4 ff142 fs2 fc0 sc0 ls8 ws1">基于这些原因，最好给JavaScript文件定义一个构建过程。 </div><div class="t m0 x0 h4 y494d ff142 fs2 fc0 sc0 ls19 ws1b">构建过程始于在源控制中定义用于存储文件的逻辑结构。最好避免使用一个文件存放所有的</div><div class="t m0 x0 h5 y494e ff13c fs2 fc0 sc0 lsb ws5">JavaScript，遵循以下面向对象语言中的典型模式：将每个对象或自定义类型分别放入其单独的文件中。</div><div class="t m0 x0 h4 y494f ff142 fs2 fc0 sc0 ls24 ws1e">这样可以确保每个文件包含最少量的代码，使其在不引入错误的情况下更容易修改。另外，在使用像</div><div class="t m0 x0 h5 y4950 ff13c fs2 fc0 sc0 ls50 ws41">CVS或Subversion这类并发源控制系统的时候，这样做也减少了在合并操作中产生冲突的风险。  </div></div></div>
<div id="pf2b7" class="pf w0 h0" data-page-no="2b7"><div class="pc pc2b7 w0 h0"><div class="t m0 x2 h2 y1 ff13c fs0 fc0 sc0 ls7 ws0">24.3 部署  677 </div><div class="t m0 x0 h3 y2 ff13c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff145 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff145 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff145 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff145 fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff145 fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff145 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff145 fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff145 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff145 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff145 fs3 fc2 sc0 ls1d wsb">22 </div><div class="t m0 x3 h8 y27 ff145 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ff145 fs3 fc2 sc0 ls1d wsb">24 </div><div class="t m0 x3 h8 y1fce ff145 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h4 y3 ff142 fs2 fc0 sc0 ls8 ws1">记住将代码分离成多个文件只是为了提高可维护性，并非为了部署。要进行部署的时候，需要将这</div><div class="t m0 x0 h5 y4d ff142 fs2 fc0 sc0 ls8 ws1">些源代码合并为一个或几个归并文件。推荐Web应用中尽可能使用最少的JavaScript文件，是因为HTTP</div><div class="t m0 x0 he yd8 ff142 fs2 fc0 sc0 ls8 ws1">请求是Web中的主要性能瓶颈之一。记住通过&lt;script&gt;标记引用JavaScript 文件是一个阻塞操作，当</div><div class="t m0 x0 h5 yd9 ff142 fs2 fc0 sc0 ls8 ws1">代码下载并运行的时候会停止其他所有的下载。因此，尽量从逻辑上将JavaScript代码分组成部署文件。 </div><div class="t m0 x0 h5 y15d ff142 fs2 fc0 sc0 ls8 ws1">一旦组织好文件和目录结构，并确定哪些要出现在部署文件中，就可以创建构建系统了。Ant构建</div><div class="t m0 x0 h5 y2b3 ff142 fs2 fc0 sc0 ls8">工具（http://ant.apache.org）是为了自动化Java构建过程而诞生的，不过因为其易用性和应用广泛，而</div><div class="t m0 x0 h5 y765 ff142 fs2 fc0 sc0 ls6d">在Web应用开发人员中也颇流行，诸如Julien Lecomte的软件工程师，已经写了教程指导如何使用Ant</div><div class="t m0 x0 h5 y15fc ff142 fs2 fc0 sc0 ls8 ws1">进行JavaScript和CSS的构建自动化（Lecomte的文章在 www.julienlecomte.net/blog/2007/09/16/ ）。 </div><div class="t m0 x0 h5 y36fb ff13c fs2 fc0 sc0 ls138 ws133">Ant由于其简便的文件处理能力而非常适合JavaScript编译系统。例如，可以很方便地获得目录中</div><div class="t m0 x0 h5 y36fc ff142 fs2 fc0 sc0 ls8 ws1">的所有文件的列表，然后将其合并为一个文件，如下所示：  </div><div class="t m0 x5 hb yeb5 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4951 ff146 fs6 fc0 sc0 ls21 wsb">&lt;project name=&quot;JavaScript Project&quot; default=&quot;js.concatenate&quot;&gt;  </div><div class="t m0 x0 hb y4952 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4953 ff146 fs6 fc0 sc0 ls21 wsb">    &lt;!-- 输出的目录 --&gt;  </div><div class="t m0 x0 hb y4954 ff146 fs6 fc0 sc0 ls21 wsb">    &lt;property name=&quot;build.dir&quot; value=&quot;./js&quot; /&gt;  </div><div class="t m0 x0 hb y4955 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4956 ff146 fs6 fc0 sc0 ls21 wsb">    &lt;!-- 包含源文件的目录 --&gt;  </div><div class="t m0 x0 hb y4957 ff146 fs6 fc0 sc0 ls21 wsb">    &lt;property name=&quot;src.dir&quot; value=&quot;./dev/src&quot; /&gt;  </div><div class="t m0 x0 hb y4958 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4959 ff146 fs6 fc0 sc0 ls21 wsb">    &lt;!-- 合并所有JS文件的目标 --&gt;  </div><div class="t m0 x0 hb y495a ff146 fs6 fc0 sc0 ls21 wsb">    &lt;!-- Credit: Julien Lecomte, http://www.julienlecomte.net/blog/2007/09/16/ --&gt;  </div><div class="t m0 x0 hb y495b ff146 fs6 fc0 sc0 ls21 wsb">    &lt;target name=&quot;js.concatenate&quot;&gt;  </div><div class="t m0 x0 hb y495c ff146 fs6 fc0 sc0 ls21 wsb">        &lt;concat destfile=&quot;${build.dir}/output.js&quot;&gt;  </div><div class="t m0 x0 hb y495d ff146 fs6 fc0 sc0 ls21 wsb">            &lt;filelist dir=&quot;${src.dir}/js&quot; files=&quot;a.js, b.js&quot;/&gt;  </div><div class="t m0 x0 hb y495e ff146 fs6 fc0 sc0 ls21 wsb">            &lt;fileset dir=&quot;${src.dir}/js&quot; includes=&quot;*.js&quot; excludes=&quot;a.js, b.js&quot;/&gt;  </div><div class="t m0 x0 hb y495f ff146 fs6 fc0 sc0 ls21 wsb">        &lt;/concat&gt;  </div><div class="t m0 x0 hb y4960 ff146 fs6 fc0 sc0 ls21 wsb">    &lt;/target&gt;  </div><div class="t m0 x0 hb y4961 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4962 ff146 fs6 fc0 sc0 ls21 wsb">&lt;/project&gt;  </div><div class="t m0 x5 hb y4963 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y3be ff14b fs2 fc0 sc0 ls8 wsb">SampleAntDir/build.xml </div><div class="t m0 x0 h5 y4964 ff142 fs2 fc0 sc0 ls8">该 build.xml 文件定义了两个属性：输出最终文件的构建目录，以及JavaScript源文件所在的源目录。</div><div class="t m0 x0 h4 y33b1 ff142 fs2 fc0 sc0 ls6 ws6">目标js.concatenate使用了&lt;concat&gt;元素来指定需要进行合并的文件的列表以及结果文件所要输</div><div class="t m0 x0 hc y4965 ff142 fs2 fc0 sc0 ls8 ws1">出的位置。&lt;filelist&gt;元素用于指定a.js和b.js要首先出现在合并的文件中，&lt;fileset&gt;元素指定了</div><div class="t m0 x0 h5 y4966 ff142 fs2 fc0 sc0 ls8 ws1">之后要添加到目录中的其他所有文件，a.js和b.js除外。结果文件最后输出到/js/output.js。 </div><div class="t m0 x0 h5 y4967 ff142 fs2 fc0 sc0 ls8 ws1">如果安装了Ant，就可以进入build.xml文件所在的目录，并运行以下命令： </div><div class="t m0 x5 hb y3103 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4968 ff146 fs6 fc0 sc0 ls21 wsb">ant  </div><div class="t m0 x0 h4 y4969 ff142 fs2 fc0 sc0 ls8 ws1">然后构建过程就开始了，最后生成合并了的文件。如果在文件中还有其他目标，可以使用以下代码</div><div class="t m0 x0 hc y3b9e ff142 fs2 fc0 sc0 ls8 ws1">仅执行js.concatenate目标： </div><div class="t m0 x5 hb y1a1 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y496a ff146 fs6 fc0 sc0 ls21 wsb">ant js.concatenate </div><div class="t m0 x5 hb y496b ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y376e ff142 fs2 fc0 sc0 ls8 ws1">可以根据需求，修改构建过程以包含其他步骤。在开发周期中引入构建这一步能让你在部署之前对</div><div class="t m0 x0 h5 y130c ff13c fs2 fc0 sc0 lsb ws5">JavaScript文件进行更多的处理。 </div><div class="t m0 x0 h20 y21ff ff140 fs3 fc0 sc0 ls248 ws214">24.3.2 验证  </div><div class="t m0 x0 h5 y496c ff142 fs2 fc0 sc0 ls8 ws1">尽管现在出现了一些可以理解并支持JavaScript的IDE，大多数开发人员还是要在浏览器中运行代</div></div></div>
<div id="pf2b8" class="pf w0 h0" data-page-no="2b8"><div class="pc pc2b8 w0 h0"><div class="t m0 x0 h2 y1 ff13c fs0 fc0 sc0 ls7 ws0">678  第24章 最佳实践 </div><div class="t m0 x0 h3 y2 ff13c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ff142 fs2 fc0 sc0 ls8 ws1">码以检查其语法。这种方法有一些问题。首先，验证过程难以自动化或者在不同系统间直接移植。其次，</div><div class="t m0 x0 h4 y4d ff142 fs2 fc0 sc0 ls8 ws1">除了语法错误外，很多问题只有在执行代码的时候才会遇到，这给错误留下了空间；有些工具可以帮助</div><div class="t m0 x0 h5 yd8 ff142 fs2 fc0 sc0 ls8 ws1">确定JavaScript代码中潜在的问题，其中最著名的就是Douglas Crockford的JSLint (www.jslint.com)。 </div><div class="t m0 x0 h5 y28b ff13c fs2 fc0 sc0 ls81 ws76">JSLint可以查找JavaScript 代码中的语法错误以及常见的编码错误。它可以发掘的一些潜在问题 </div><div class="t m0 x0 h5 yfdb ff142 fs2 fc0 sc0 ls8">如下： </div><div class="t m0 x0 h5 y8 ff141 fs1 fc0 sc0 ls2"> eval()的使用； </div><div class="t m0 x0 h5 y9 ff141 fs1 fc0 sc0 ls2"> 未声明变量的使用； </div><div class="t m0 x0 h5 ya ff141 fs1 fc0 sc0 ls2"> 遗漏的分号； </div><div class="t m0 x0 h5 yb ff141 fs1 fc0 sc0 ls2"> 不恰当的换行； </div><div class="t m0 x0 h5 yc ff141 fs1 fc0 sc0 ls2"> 错误的逗号使用； </div><div class="t m0 x0 h5 yd ff141 fs1 fc0 sc0 ls2"> 语句周围遗漏的括号； </div><div class="t m0 x0 h5 y21b ff141 fs1 fc0 sc0 ls2"> switch分支语句中遗漏的break； </div><div class="t m0 x0 h5 y21c ff141 fs1 fc0 sc0 ls2"> 重复声明的变量； </div><div class="t m0 x0 h5 y10 ff141 fs1 fc0 sc0 ls2"> with的使用； </div><div class="t m0 x0 h5 y11 ff141 fs1 fc0 sc0 ls2"> 错误使用的等号（替代了双等号或三等号）； </div><div class="t m0 x0 h5 y1a57 ff141 fs1 fc0 sc0 ls2"> 无法到达的代码。 </div><div class="t m0 x0 h5 y13 ff142 fs2 fc0 sc0 ls42 ws30">为了方便访问，它有一个在线版本，不过它也可以使用基于Java的Rhino JavaScript引擎（www.mozilla. </div><div class="t m0 x0 h5 y14 ff13c fs2 fc0 sc0 ls17c ws13d">org/rhino/）运行于命令行模式下。要在命令行中运行JSLint，首先要下载Rhino，并从 www.jslint.com/下</div><div class="t m0 x0 h5 y15 ff142 fs2 fc0 sc0 ls295">载Rhino版本的JSLint。一旦安装完成，便可以使用下面的语法从命令行运行JSLint了： </div><div class="t m0 x0 hb y496d ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y496e ff146 fs6 fc0 sc0 ls21 wsb">java -jar rhino-1.6R7.jar jslint.js [input files] </div><div class="t m0 x0 hb y496f ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y134f ff142 fs2 fc0 sc0 ls8 ws1">如这个例子： </div><div class="t m0 x0 hb y4970 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4971 ff146 fs6 fc0 sc0 ls21 wsb">java -jar rhino-1.6R7.jar jslint.js a.js b.js c.js </div><div class="t m0 x0 hb y4972 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y4973 ff142 fs2 fc0 sc0 ls8 ws1">如果给定文件中有任何语法问题或者是潜在的错误，则会输出有关错误和警告的报告。如果没有问</div><div class="t m0 x0 h5 y4974 ff142 fs2 fc0 sc0 ls8 ws1">题，代码会直接结束而不显示任何信息。 </div><div class="t m0 x0 h5 y4975 ff142 fs2 fc0 sc0 ls8 ws1">可以使用Ant将JSLint作为构建过程的一部分运行，添加如下一个目标： </div><div class="t m0 x0 hb y4667 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4976 ff146 fs6 fc0 sc0 ls21 wsb">&lt;target name=&quot;js.verify&quot;&gt; </div><div class="t m0 x0 hb y4977 ff146 fs6 fc0 sc0 ls21 wsb">    &lt;apply executable=&quot;java&quot; parallel=&quot;false&quot;&gt; </div><div class="t m0 x0 hb y4978 ff146 fs6 fc0 sc0 ls21 wsb">        &lt;fileset dir=&quot;${build.dir}&quot; includes=&quot;output.js&quot;/&gt; </div><div class="t m0 x0 hb y4979 ff146 fs6 fc0 sc0 ls21 wsb">        &lt;arg line=&quot;-jar&quot;/&gt; </div><div class="t m0 x0 hb y497a ff146 fs6 fc0 sc0 ls21 wsb">        &lt;arg path=&quot;${rhino.jar}&quot;/&gt; </div><div class="t m0 x0 hb y497b ff146 fs6 fc0 sc0 ls21 wsb">        &lt;arg path=&quot;${jslint.js}&quot; /&gt; </div><div class="t m0 x0 hb y497c ff146 fs6 fc0 sc0 ls21 wsb">        &lt;srcfile/&gt; </div><div class="t m0 x0 hb y497d ff146 fs6 fc0 sc0 ls21 wsb">     &lt;/apply&gt; </div><div class="t m0 x0 hb y497e ff146 fs6 fc0 sc0 ls21 wsb">&lt;/target&gt; </div><div class="t m0 x0 hb y497f ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y155b ff14b fs2 fc0 sc0 ls5e wsb">SampleAntDir/build.xml </div><div class="t m0 x0 h5 y26c1 ff142 fs2 fc0 sc0 ls8 ws1">这个目标假设Rhino jar文件的位置已经由叫做rhino.jar的属性指定了，同时JSLint Rhino 文件</div><div class="t m0 x0 h5 ya30 ff142 fs2 fc0 sc0 ls8 ws1">的位置由叫做jslint.js的属性指定了。output.js文件被传递给JSLint进行校验，然后显示找到的</div><div class="t m0 x0 h5 ya31 ff142 fs2 fc0 sc0 ls8 ws1">任何问题。 </div><div class="t m0 x0 h4 y4980 ff142 fs2 fc0 sc0 ls8 ws1">给开发周期添加代码验证这个环节有助于避免将来可能出现的一些错误。建议开发人员给构建过程</div><div class="t m0 x0 h5 y4981 ff142 fs2 fc0 sc0 ls8 ws1">加入某种类型的代码验证作为确定潜在问题的一个方法，防患于未然。  </div></div></div>
<div id="pf2b9" class="pf w0 h0" data-page-no="2b9"><div class="pc pc2b9 w0 h0"><div class="t m0 x2 h2 y1 ff13c fs0 fc0 sc0 ls7 ws0">24.3 部署  679 </div><div class="t m0 x0 h3 y2 ff13c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff145 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff145 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff145 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff145 fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff145 fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff145 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff145 fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff145 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff145 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff145 fs3 fc2 sc0 ls1d wsb">22 </div><div class="t m0 x3 h8 y27 ff145 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ff145 fs3 fc2 sc0 ls1d wsb">24 </div><div class="t m0 x3 h8 y1fce ff145 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y4982 ff13c fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x5 h5 y4983 ff13c fs2 fc0 sc0 lsb ws5">JavaScript代码校验工具的列表可以在附录D中找到。  </div><div class="t m0 x0 h20 y30c6 ff140 fs3 fc0 sc0 ls248 ws214">24.3.3 压缩  </div><div class="t m0 x0 h5 y2e50 ff142 fs2 fc0 sc0 ls8 ws1">当谈及JavaScript文件压缩，其实在讨论两个东西：代码长度和配重（Wire weight）。代码长度指的</div><div class="t m0 x0 h5 y4984 ff142 fs2 fc0 sc0 ls8 ws1">是浏览器所需解析的字节数，配重指的是实际从服务器传送到浏览器的字节数。在Web开发的早期，</div><div class="t m0 x0 h5 y4985 ff142 fs2 fc0 sc0 ls8 ws1">这两个数字几乎是一样的，因为从服务器端到客户端原封不动地传递了源文件。而在今天的Web上，</div><div class="t m0 x0 h5 y4986 ff142 fs2 fc0 sc0 ls8 ws1">这两者很少相等，实际上也不应相等。  </div><div class="t m0 x0 h3c y4987 ff140 fs2 fc0 sc0 ls2e wsb">1. 文件压缩  </div><div class="t m0 x0 h5 y4988 ff142 fs2 fc0 sc0 ls8 ws1">因为JavaScript并非编译为字节码，而是按照源代码传送的，代码文件通常包含浏览器执行所不需</div><div class="t m0 x0 h4 y4989 ff142 fs2 fc0 sc0 ls8 ws1">要的额外的信息和格式。注释，额外的空白，以及长长的变量名和函数名虽然提高了可读性，但却是传</div><div class="t m0 x0 h5 y498a ff142 fs2 fc0 sc0 ls8 ws1">送给浏览器时不必要的字节。不过，我们可以使用压缩工具减少文件的大小。 </div><div class="t m0 x0 h5 y498b ff142 fs2 fc0 sc0 ls8 ws1">压缩器一般进行如下一些步骤： </div><div class="t m0 x0 h5 y3a9c ff141 fs1 fc0 sc0 ls2"> 删除额外的空白（包括换行）； </div><div class="t m0 x0 h5 y2ab6 ff141 fs1 fc0 sc0 ls2"> 删除所有注释； </div><div class="t m0 x0 h5 y498c ff141 fs1 fc0 sc0 ls2"> 缩短变量名。 </div><div class="t m0 x0 h5 y498d ff13c fs2 fc0 sc0 lsb ws5">JavaScript有不少压缩工具可用（附录D中有一个完整列表），其中最优秀的（有争议的）是YUI 压</div><div class="t m0 x0 h5 y498e ff142 fs2 fc0 sc0 ls8 ws1">缩器，http://yuilibrary.com /projects/yuicompressor。YUI压缩器使用了Rhino JavaScript解析器将JavaScript</div><div class="t m0 x0 h4 y498f ff142 fs2 fc0 sc0 ls8 ws1">代码令牌化。然后使用这个令牌流创建代码不包含空白和注释的优化版本。与一般的基于表达式的压缩</div><div class="t m0 x0 h5 y4990 ff142 fs2 fc0 sc0 ls8 ws1">器不同的地方在于，YUI 压缩可以确保不引入任何语法错误，并可以安全地缩短局部变量名。 </div><div class="t m0 x0 h5 y4991 ff13c fs2 fc0 sc0 ls79 wsb">YUI 压缩器是作为Java的一个jar文件发布的，名字叫yuicompressor-x.y.z.jar，其中x.y.z</div><div class="t m0 x0 h5 y4992 ff142 fs2 fc0 sc0 ls8 ws1">是版本号。在写本书的时候，2.3.5是最新的版本。可以使用以下命令行格式来使用YUI 压缩器： </div><div class="t m0 x5 hb y1279 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4993 ff146 fs6 fc0 sc0 ls21 wsb">java -jar yuicompressor-x.y.z.jar [options] [input files] </div><div class="t m0 x5 hb y4994 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3808 ff13c fs2 fc0 sc0 ls79 wsb">YUI 压缩器的选项列在了下面的表格内。 </div><div class="t m0 x5 hb y7c6 ff146 fs6 fc0 sc0 ls8 wsb">  </div><div class="t m0 x5 h31 y4995 ff13f fs6 fc0 sc0 lsa7 wsb">选  项 描  述 </div><div class="t m0 x0 h32 yb10 ff146 fsc fc0 sc0 lsa8 wsb">-h   显示帮助信息  </div><div class="t m0 x0 h32 y1ea6 ff146 fsc fc0 sc0 lsa8 wsb">-o outputFile   指定输出文件的文件名。如果没有该选项，那么输出文件名是输入文件名加上-min。例</div><div class="t m0 x1 h36 y4996 ff142 fs6 fc0 sc0 ls31 ws24">如，叫做input.js的输入文件，那么会产生input-min.js  </div><div class="t m0 x0 h32 y511 ff146 fsc fc0 sc0 lsa8 wsb">--line-break column   指定每行多少个字符之后添加换行。默认情况下，压缩过的文件只输出为一行，可能在</div><div class="t m0 x1 h36 y4997 ff142 fs6 fc0 sc0 ls8 ws33">某些版本控制系统中会出错  </div><div class="t m0 x0 h32 y4998 ff146 fsc fc0 sc0 lsa8 wsb">-v, --verbose   详细模式，输出可以进行更好压缩的提示和警告  </div><div class="t m0 x0 h32 y25ed ff146 fsc fc0 sc0 lsa8 wsb">--charset charset   指定输入文件所使用的字符集。输出文件会使用同样的字 符集  </div><div class="t m0 x0 h32 y4999 ff146 fsc fc0 sc0 lsa8 wsb">--nomunge   关闭局部变量替换  </div><div class="t m0 x0 h32 y2b93 ff146 fsc fc0 sc0 lsa8">--disable-optimizations</div><div class="c x5 y499a w20 h35"><div class="t m0 x0 h32 y353 ff146 fsc fc0 sc0 ls8 wsb"> </div></div><div class="t m0 x1 h36 y1a1e ff142 fs6 fc0 sc0 ls31 ws24">关闭YUI 压缩器的细节优化  </div><div class="t m0 x0 h32 y2d76 ff146 fsc fc0 sc0 lsa8 wsb">--preserve-semi   保留本来要被删除的无用的分号 </div><div class="t m0 x5 hb y1f9e ff146 fs6 fc0 sc0 ls8 wsb">  </div></div></div>
<div id="pf2ba" class="pf w0 h0" data-page-no="2ba"><div class="pc pc2ba w0 h0"><div class="t m0 x0 h2 y1 ff13c fs0 fc0 sc0 ls7 ws0">680  第24章 最佳实践 </div><div class="t m0 x0 h3 y2 ff13c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff142 fs2 fc0 sc0 ls8 ws1">例如，以下命令行可以用来将CookieUtil.js压缩成一个叫做cookie.js的文件： </div><div class="t m0 x0 hb yfb2 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yfb3 ff146 fs6 fc0 sc0 ls21 wsb">java -jar yuicompressor-2.3.5.jar -o cookie.js CookieUtil.js </div><div class="t m0 x0 hb y1510 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1511 ff13c fs2 fc0 sc0 ls79 wsb">YUI 压缩器也可以通过直接调用java可执行文件在Ant中使用，如下面的例子所示： </div><div class="t m0 x0 hb y4400 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4401 ff146 fs6 fc0 sc0 ls21 wsb">&lt;!-- Credit: Julien Lecomte, http://www.julienlecomte.net/blog/2007/09/16/ --&gt; </div><div class="t m0 x0 hb y499c ff146 fs6 fc0 sc0 ls21 wsb">&lt;target name=&quot;js.compress&quot;&gt; </div><div class="t m0 x0 hb y499d ff146 fs6 fc0 sc0 ls21 wsb">    &lt;apply executable=&quot;java&quot; parallel=&quot;false&quot;&gt; </div><div class="t m0 x0 hb y499e ff146 fs6 fc0 sc0 ls21 wsb">        &lt;fileset dir=&quot;${build.dir}&quot; includes=&quot;output.js&quot;/&gt; </div><div class="t m0 x0 hb y499f ff146 fs6 fc0 sc0 ls21 wsb">        &lt;arg line=&quot;-jar&quot;/&gt; </div><div class="t m0 x0 hb y49a0 ff146 fs6 fc0 sc0 ls21 wsb">        &lt;arg path=&quot;${yuicompressor.jar}&quot;/&gt; </div><div class="t m0 x0 hb y49a1 ff146 fs6 fc0 sc0 ls21 wsb">        &lt;arg line=&quot;-o ${build.dir}/output-min.js&quot;/&gt; </div><div class="t m0 x0 hb y49a2 ff146 fs6 fc0 sc0 ls21 wsb">        &lt;srcfile/&gt; </div><div class="t m0 x0 hb y49a3 ff146 fs6 fc0 sc0 ls21 wsb">    &lt;/apply&gt; </div><div class="t m0 x0 hb y49a4 ff146 fs6 fc0 sc0 ls21 wsb">&lt;/target&gt; </div><div class="t m0 x2 hf y49a5 ff14b fs2 fc0 sc0 ls5e wsb">SampleAntDir/build.xml </div><div class="t m0 x0 h5 y49a6 ff142 fs2 fc0 sc0 ls8 ws1">该目标包含了一个文件output.js，由构建过程生成的，并传递给YUI压缩器。输出文件指定为</div><div class="t m0 x0 hc y49a7 ff142 fs2 fc0 sc0 ls8 ws1">同一目录下的output-min.js。这里假设yuicompressor.jar属性包含了YUI  压缩器的 jar文件</div><div class="t m0 x0 h5 y1fc5 ff142 fs2 fc0 sc0 ls8 ws1">的位置。然后可以使用以下命令运行这个目标： </div><div class="t m0 x0 hb y49a8 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y49a9 ff146 fs6 fc0 sc0 ls21 wsb">ant js.compress </div><div class="t m0 x0 hb y49aa ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y4511 ff142 fs2 fc0 sc0 ls8 ws1">所有的JavaScript文件在部署到生产环境之前，都应该使用YUI压缩器或者类似的工具进行压缩。</div><div class="t m0 x0 h5 y4512 ff142 fs2 fc0 sc0 ls8 ws1">给构建过程添加一个压缩JavaScript文件的环节以确保每次都进行这个操作。  </div><div class="t m0 x0 h3c y49ab ff140 fs2 fc0 sc0 ls15 ws28c">2. HTTP压缩  </div><div class="t m0 x0 h4 y49ac ff142 fs2 fc0 sc0 ls8 ws1">配重指的是实际从服务器传送到浏览器的字节数。因为现在的服务器和浏览器都有压缩功能，这个</div><div class="t m0 x0 h5 y49ad ff142 fs2 fc0 sc0 ls8 ws1">字节数不一定和代码长度一样。所有的五大Web浏览器（IE、Firefox、Safari、Chrome和Opera）都支</div><div class="t m0 x0 h5 y49ae ff142 fs2 fc0 sc0 ls8 ws1">持对所接收的资源进行客户端解压缩。这样服务器端就可以使用服务器端相关功能来压缩JavaScript文</div><div class="t m0 x0 h5 y49af ff142 fs2 fc0 sc0 ls8 ws1">件。一个指定了文件使用了给定格式进行了压缩的HTTP头包含在了服务器响应中。接着浏览器会查看</div><div class="t m0 x0 h5 y49b0 ff142 fs2 fc0 sc0 ls3b">该HTTP头确定文件是否已被压缩，然后使用合适的格式进行解压缩。结果是和原来的代码量相比在网</div><div class="t m0 x0 h5 y49b1 ff142 fs2 fc0 sc0 ls8 ws1">络中传递的字节数量大大减少了。  </div><div class="t m0 x0 h16f y49b2 ff142 fs2 fc0 sc0 ls44 ws32">对于Apache Web服务器，有两个模块可以进行HTTP压缩：mod_gzip（Apache1.3.x）和mod_deflate</div><div class="t m0 x0 h5 y49b3 ff142 fs2 fc0 sc0 ls8 ws1">（Apache 2.0.x）。对于mod_gzip，可以给httpd.conf文件或者是.htaccess文件添加以下代码启用对</div><div class="t m0 x0 h5 y49b4 ff13c fs2 fc0 sc0 ls16b wsf0">JavaScript的自动压缩： </div><div class="t m0 x0 hb y49b5 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y49b6 ff146 fs6 fc0 sc0 ls16f">#告诉mod_zip要包含任何以.js结尾的文件 </div><div class="t m0 x0 hb y49b7 ff146 fs6 fc0 sc0 ls21 wsb">mod_gzip_item_include         file     \.js$ </div><div class="t m0 x0 hb y49b8 ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y348 ff142 fs2 fc0 sc0 ls8 ws1">该行代码告诉mod_zip要包含来自浏览器请求的任何以.js结尾的文件。假设你所有的JavaScript</div><div class="t m0 x0 hc y49b9 ff142 fs2 fc0 sc0 ls8 ws1">文件都以.js结尾，就可以压缩所有请求并应用合适的HTTP头以表示内容已被压缩。关于 mod_zip</div><div class="t m0 x0 h5 y49ba ff142 fs2 fc0 sc0 ls8 ws1">的更多信息，请访问项目网站http://www.sourceforge.net/projects/mod-gzip/。 </div><div class="t m0 x0 hc y340b ff142 fs2 fc0 sc0 ls8 ws1">对于mod_deflate，可以类似添加一行代码以保证JavaScript文件在被发送之前已被压缩。将以下</div><div class="t m0 x0 hc y49bb ff142 fs2 fc0 sc0 ls8 ws1">这一行代码添加到httpd.conf文件或者是.htaccess文件中： </div><div class="t m0 x0 hb y49bc ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y49bd ff146 fs6 fc0 sc0 ls16f">#告诉mod_deflate要包含所有的JavaScript文件 </div><div class="t m0 x0 hb y49be ff146 fs6 fc0 sc0 ls21 wsb">AddOutputFilterByType DEFLATE application/x-javascript </div><div class="t m0 x0 hb y49bf ff146 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 yc52 ff142 fs2 fc0 sc0 ls8 ws1">注意这一行代码用到了响应的MIME类型来确定是否对其进行压缩。记住虽然&lt;script&gt;的type</div></div></div>
<div id="pf2bb" class="pf w0 h0" data-page-no="2bb"><div class="pc pc2bb w0 h0"><div class="t m0 x2 h2 y1 ff13c fs0 fc0 sc0 ls7 ws0">24.4 小结  681 </div><div class="t m0 x0 h3 y2 ff13c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff145 fs3 fc2 sc0 ls1d wsb">14 </div><div class="t m0 x3 h8 y1e ff145 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff145 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff145 fs3 fc2 sc0 ls1d wsf">17 </div><div class="t m0 x3 h8 y21 ff145 fs3 fc2 sc0 ls1d wsb">18 </div><div class="t m0 x3 h8 y22 ff145 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff145 fs3 fc2 sc0 ls1d wsf">19 </div><div class="t m0 x3 h8 y24 ff145 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff145 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff145 fs3 fc2 sc0 ls1d wsb">22 </div><div class="t m0 x3 h8 y27 ff145 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 ya7a ff145 fs3 fc2 sc0 ls1d wsb">24 </div><div class="t m0 x3 h8 y1fce ff145 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff142 fs2 fc0 sc0 ls8 ws1">属性用的是text/javascript，但是JavaScript文件一般还是用application/x-javascript 作为</div><div class="t m0 x0 hc y4d ff142 fs2 fc0 sc0 ls5 ws4">其服务的MIME类型。关于 mod_deflate的更多信息，请访问http://httpd.apache.org/docs/2.0/mod/ </div><div class="t m0 x0 h5 y5 ff13c fs2 fc0 sc0 ls2b ws22">mod_deflate.html。 </div><div class="t m0 x0 h5 yd9 ff146 fs1 fc0 sc0 ls9 ws2">mod_gzip和mod_deflate都可以节省大约 70%的JavaScript文件大小。这很大程度上是因为</div><div class="t m0 x0 h5 y15d ff13c fs2 fc0 sc0 lsb ws5">JavaScript都是文本文件，因此可以非常有效地进行压缩。减少文件的配重可以减少需要传输到浏览器</div><div class="t m0 x0 h4 y2b3 ff142 fs2 fc0 sc0 ls8 ws1">的时间。记住有一点点细微的代价，因为服务器必须花时间对每个请求压缩文件，当浏览器接收到这些</div><div class="t m0 x0 h5 y765 ff142 fs2 fc0 sc0 ls8 ws1">文件后也需要花一些时间解压缩。不过，一般来说，这个代价还是值得的。 </div><div class="t m0 x5 h5 y11d6 ff13d fs2 fc0 sc0 ls8 ws14">大部分Web服务器，开源的或是商业的，都有一些HTTP 压缩功能。请查看服</div><div class="t m0 x5 h5 y11d7 ff13d fs2 fc0 sc0 ls8 ws14">务器的文档说明以确定如何合适地配置压缩。  </div><div class="t m0 x0 hd y49c0 ff140 fs7 fc0 sc0 ls245">24.4 小结  </div><div class="t m0 x0 h5 y1803 ff142 fs2 fc0 sc0 ls8 ws1">随着JavaScript开发的成熟，也出现了很多最佳实践。过去一度认为只是一种爱好的东西现在变成</div><div class="t m0 x0 h5 y1c76 ff142 fs2 fc0 sc0 ls8 ws1">了正当的职业，同时还需要经历过去其他编程语言要做的一些研究，如可维护性、性能和部署。 </div><div class="t m0 x0 h5 y49c1 ff13c fs2 fc0 sc0 lsb ws5">JavaScript中的可维护性部分涉及到下面的代码约定。 </div><div class="t m0 x0 h5 y49c2 ff141 fs1 fc0 sc0 ls2"> 来自其他语言中的代码约定可以用于决定何时进行注释，以及如何进行缩进，不过JavaScript</div><div class="t m0 x5 h5 y49c3 ff142 fs2 fc0 sc0 ls8 ws1">需要针对其松散类型的性质创造一些特殊的约定。 </div><div class="t m0 x0 h5 y145e ff141 fs1 fc0 sc0 ls2"> 由于JavaScript必须与 HTML和CSS共存，所以让各自完全定义其自己的目的非常重要：</div><div class="t m0 x5 h5 y49c4 ff13c fs2 fc0 sc0 lsb ws5">JavaScript应该定义行为，HTML应该定义内容，CSS应该定义外观。 </div><div class="t m0 x0 h5 y20f6 ff141 fs1 fc0 sc0 ls2"> 这些职责的混淆会导致难以调试的错误和维护上的问题。 </div><div class="t m0 x0 h5 y49c5 ff142 fs2 fc0 sc0 ls8 ws1">随着Web应用中的JavaScript数量的增加，性能变得更加重要，因此，你需要牢记以下事项。 </div><div class="t m0 x0 h5 y49c6 ff141 fs1 fc0 sc0 ls2"> JavaScript执行所花费的时间直接影响到整个Web页面的性能，所以其重要性是不能忽略的。 </div><div class="t m0 x0 h5 y3589 ff141 fs1 fc0 sc0 ls2"> 针对基于C的语言的很多性能的建议也适用于JavaScript，如有关循环性能和使用switch语句</div><div class="t m0 x5 h5 y358a ff142 fs2 fc0 sc0 ls8 ws1">替代if语句。 </div><div class="t m0 x0 h5 y1888 ff141 fs1 fc0 sc0 ls2"> 还有一个要记住的重要事情，即DOM交互开销很大，所以需要限制DOM操作的次数。 </div><div class="t m0 x0 h5 y49c7 ff142 fs2 fc0 sc0 ls8 ws1">流程的最后一步是部署。本章讨论了以下一些关键点。 </div><div class="t m0 x0 h5 y49c8 ff141 fs1 fc0 sc0 ls2"> 为了协助部署，推荐设置一个可以将JavaScript合并为较少文件（理想情况是一个）的构建过程。 </div><div class="t m0 x0 h5 y49c9 ff141 fs1 fc0 sc0 ls2"> 有了构建过程也可以对源代码自动运行额外的处理和过滤。例如，你可以运行JavaScript验证器</div><div class="t m0 x5 h5 y49ca ff142 fs2 fc0 sc0 ls8 ws1">来确保没有语法错误或者是代码没有潜在的问题。 </div><div class="t m0 x0 h5 y49cb ff141 fs1 fc0 sc0 ls2"> 在部署前推荐使用压缩器将文件尽可能变小。 </div><div class="t m0 x0 h5 y15d5 ff141 fs1 fc0 sc0 ls2"> 和HTTP压缩一起使用可以让JavaScript文件尽可能小，因此对整体页面性能的影响也会最小。 </div><div class="t m0 x0 h5 y49cc ff13c fs2 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf2bc" class="pf w0 h0" data-page-no="2bc"><div class="pc pc2bc w0 h0"><div class="t m0 x0 h2 y1 ff14e fs0 fc0 sc0 ls7 ws0">682  第25章 新兴的API </div><div class="t m0 x0 h3 y2 ff14e fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h9 y2a ff150 fs5 fc0 sc0 ls3a4 wsb">新兴的API </div><div class="t m0 x0 h3c y2b ff151 fs2 fc0 sc0 ls8">本章内容 </div><div class="t m0 x0 h5 y2c ff153 fs1 fc0 sc0 ls2"> 创建平滑的动画 </div><div class="t m0 x0 h5 y2d ff153 fs1 fc0 sc0 ls2"> 操作文件 </div><div class="t m0 x0 h5 y2e ff153 fs1 fc0 sc0 ls2"> 使用Web Workers在后台执行JavaScript </div><div class="t m0 x0 h5 y8d9 ff14e fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y8da ff154 fs2 fc0 sc0 ls3b">着HTML5的出现，面向未来Web应用的JavaScript API也得到了极大的发展。这些API 没有</div><div class="t m0 x0 h5 y8db ff154 fs2 fc0 sc0 ls8 wseb">包含在HTML5规范中，而是各自有各自的规范。但是，它们都属于“HTML5相关的API”。</div><div class="t m0 x0 h5 y8dc ff154 fs2 fc0 sc0 ls8 wseb">本章介绍的所有API都在持续制定中，还没有完全固定下来。 </div><div class="t m0 x0 h5 y8dd ff154 fs2 fc0 sc0 ls8 wseb">无论如何，浏览器已经着手实现这些API，而Web应用开发人员也都开始使用它们了。读者应该能</div><div class="t m0 x0 h5 y8de ff154 fs2 fc0 sc0 ls8 wseb">够注意到，其中很多API都带有特定于浏览器的前缀，比如微软是ms，而Chrome和Safari 是webkit。</div><div class="t m0 x0 h5 y8df ff154 fs2 fc0 sc0 ls8 wseb">通过添加这些前缀，不同的浏览器可以测试还在开发中的新API，不过请记住，去掉前缀之后的部分在</div><div class="t m0 x0 h5 y8e0 ff154 fs2 fc0 sc0 ls8 wseb">所有浏览器中都是一致的。 </div><div class="t m0 x0 hd y346e ff152 fs7 fc0 sc0 ls245">25.1 requestAnimationFrame() </div><div class="t m0 x0 h5 y832 ff154 fs2 fc0 sc0 ls8 wseb">很长时间以来，计时器和循环间隔一直都是JavaScript动画的最核心技术。虽然CSS变换及动画为</div><div class="t m0 x0 h5 y4173 ff14e fs2 fc0 sc0 lsfd wscc">Web开发人员提供了实现动画的简单手段，但JavaScript动画开发领域的状况这些年来并没有大的变化。</div><div class="t m0 x0 h5 y4174 ff14e fs2 fc0 sc0 ls2e ws92">Firefox 4最早为JavaScript动画添加了一个新API，即 mozRequestAnimationFrame()。这个方法会</div><div class="t m0 x0 h5 y1024 ff154 fs2 fc0 sc0 ls8 wseb">告诉浏览器：有一个动画开始了。进而浏览器就可以确定重绘的最佳方式。 </div><div class="t m0 x0 h20 y3e ff152 fs3 fc0 sc0 ls248 ws214">25.1.1 早期动画循环 </div><div class="t m0 x0 h5 y49cd ff154 fs2 fc0 sc0 ls3b">在JavaScript中创建动画的典型方式，就是使用setInterval()方法来控制所有动画。以下是一个</div><div class="t m0 x0 h5 y21cf ff154 fs2 fc0 sc0 ls8 wseb">使用setInterval()的基本动画循环： </div><div class="t m0 x0 hb y283 ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y49ce ff156 fs6 fc0 sc0 ls21 wsb">(function(){ </div><div class="t m0 x0 hb y49cf ff156 fs6 fc0 sc0 ls21 wsb">    function updateAnimations(){ </div><div class="t m0 x0 hb y49d0 ff156 fs6 fc0 sc0 ls21 wsb">        doAnimation1(); </div><div class="t m0 x0 hb y49d1 ff156 fs6 fc0 sc0 ls21 wsb">        doAnimation2(); </div><div class="t m0 x0 h16 y49d2 ff156 fs6 fc0 sc0 ls21 wsb">        //其他动画 </div><div class="t m0 x0 hb y49d3 ff156 fs6 fc0 sc0 ls21 wsb">    }  </div><div class="t m0 x0 hb y49d4 ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y49d5 ff156 fs6 fc0 sc0 ls21 wsb">    setInterval(updateAnimations, 100); </div><div class="t m0 x0 hb y49d6 ff156 fs6 fc0 sc0 ls21 wsb">})(); </div><div class="t m0 x0 h5 y49d7 ff14e fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h139 y338 ff151 fs19 fc0 sc0 ls8 wsb">随 </div><div class="t m0 x0 h11 y4b ff158 fsa fc0 sc0 ls8">第</div><div class="t m1 x0 h12 y4b ff159 fsb fc3 sc0 ls247">25</div><div class="t m0 x5 h9 y4b ff158 fsa fc0 sc0 ls8 ws1d">章 </div></div></div>
<div id="pf2bd" class="pf w0 h0" data-page-no="2bd"><div class="pc pc2bd w0 h0"><div class="t m0 x4 h2 y1db2 ff14e fs0 fc0 sc0 ls7 ws0">25.1 requestAnimationFrame()  683 </div><div class="t m0 x0 h3 y2 ff14e fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff15a fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff15a fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ff15a fs3 fc2 sc0 ls1d wsb">16 </div><div class="t m0 x3 h8 y20 ff15a fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff15a fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff15a fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff15a fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff15a fs3 fc2 sc0 ls1d wsb">20 </div><div class="t m0 x3 h8 y25 ff15a fs3 fc2 sc0 ls1d wsb">21 </div><div class="t m0 x3 h8 y26 ff15a fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff15a fs3 fc2 sc0 ls1d wsf">23 </div><div class="t m0 x3 h8 ya7a ff15a fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff15a fs3 fc2 sc0 ls1d wsf">25 </div><div class="t m0 x0 h4 y3 ff154 fs2 fc0 sc0 ls8 wseb">为了创建一个小型动画库，updateAnimations()方法就得不断循环地运行每个动画，并相应地改</div><div class="t m0 x0 h4 y4d ff154 fs2 fc0 sc0 ls8 wseb">变不同元素的状态（例如，同时显示一个新闻跑马灯和一个进度条）。如果没有动画需要更新，这个方</div><div class="t m0 x0 h5 yd8 ff154 fs2 fc0 sc0 ls8 wseb">法可以退出，什么也不用做，甚至可以把动画循环停下来，等待下一次需要更新的动画。 </div><div class="t m0 x0 h4 y28b ff154 fs2 fc0 sc0 ls8 wseb">编写这种动画循环的关键是要知道延迟时间多长合适。一方面，循环间隔必须足够短，这样才能让</div><div class="t m0 x0 h4 yfdb ff154 fs2 fc0 sc0 ls8 wseb">不同的动画效果显得更平滑流畅；另一方面，循环间隔还要足够长，这样才能确保浏览器有能力渲染产</div><div class="t m0 x0 h5 y14e1 ff154 fs2 fc0 sc0 ls8 wseb">生的变化。大多数电脑显示器的刷新频率是60Hz，大概相当于每秒钟重绘60次。大多数浏览器都会对</div><div class="t m0 x0 h5 y49d8 ff154 fs2 fc0 sc0 ls8 wseb">重绘操作加以限制，不超过显示器的重绘频率，因为即使超过那个频率用户体验也不会有提升。 </div><div class="t m0 x0 h5 y49d9 ff154 fs2 fc0 sc0 ls8 wseb">因此，最平滑动画的最佳循环间隔是1000ms/60，约等于17ms。以这个循环间隔重绘的动画是最平</div><div class="t m0 x0 h5 y49da ff154 fs2 fc0 sc0 ls8 wseb">滑的，因为这个速度最接近浏览器的最高限速。为了适应17ms的循环间隔，多重动画可能需要加以节</div><div class="t m0 x0 h5 y49db ff154 fs2 fc0 sc0 ls8 wseb">制，以便不会完成得太快。 </div><div class="t m0 x0 h170 y49dc ff154 fs2 fc0 sc0 ls8 wseb">虽然与使用多组setTimeout()的循环方式相比，使用setInterval()的动画循环效率更高，但</div><div class="t m0 x0 h1e ye ff154 fs2 fc0 sc0 ls8 wseb">后者也不是没有问题。无论是setInterval()还是setTimeout()都不十分精确。为它们传入的第二</div><div class="t m0 x0 h5 y21c ff154 fs2 fc0 sc0 ls8 wseb">个参数，实际上只是指定了把动画代码添加到浏览器UI线程队列中以等待执行的时间。如果队列前面</div><div class="t m0 x0 h4 y116c ff154 fs2 fc0 sc0 ls8 wseb">已经加入了其他任务，那动画代码就要等前面的任务完成后再执行。简言之，以毫秒表示的延迟时间并</div><div class="t m0 x0 h5 y26c5 ff154 fs2 fc0 sc0 ls8 wseb">不代表到时候一定会执行动画代码，而仅代表到时候会把代码添加到任务队列中。如果UI线程繁忙，</div><div class="t m0 x0 h5 y49dd ff154 fs2 fc0 sc0 ls8 wseb">比如忙于处理用户操作，那么即使把代码加入队列也不会立即执行。 </div><div class="t m0 x0 h20 y3391 ff152 fs3 fc0 sc0 ls248 ws214">25.1.2 循环间隔的问题 </div><div class="t m0 x0 h4 y125c ff154 fs2 fc0 sc0 ls8 wseb">知道什么时候绘制下一帧是保证动画平滑的关键。然而，直至最近，开发人员都没有办法确保浏览</div><div class="t m0 x0 h1e y2b5e ff154 fs2 fc0 sc0 ls6 wsf7">器按时绘制下一帧。随着&lt;canvas&gt;元素越来越流行，新的基于浏览器的游戏也开始崭露头脚，面对不</div><div class="t m0 x0 hc y49de ff154 fs2 fc0 sc0 ls8 wseb">十分精确的setInterval()和setTimeout()，开发人员一筹莫展。 </div><div class="t m0 x0 h4 y49df ff154 fs2 fc0 sc0 ls8 wseb">浏览器使用的计时器的精度进一步恶化了问题。具体地说，浏览器使用的计时器并非精确到毫秒级</div><div class="t m0 x0 h5 y49e0 ff154 fs2 fc0 sc0 ls8 wseb">别。以下是几个浏览器的计时器精度。 </div><div class="t m0 x0 h5 y49e1 ff153 fs1 fc0 sc0 ls2"> IE8及更早版本的计时器精度为15.625ms。 </div><div class="t m0 x0 h5 y49e2 ff153 fs1 fc0 sc0 ls2"> IE9及更晚版本的计时器精度为4ms。 </div><div class="t m0 x0 h5 y49e3 ff153 fs1 fc0 sc0 ls2"> Firefox和Safari的计时器精度大约为10ms。 </div><div class="t m0 x0 h5 y20fd ff153 fs1 fc0 sc0 ls2"> Chrome的计时器精度为4ms。 </div><div class="t m0 x0 h5 y49e4 ff14e fs2 fc0 sc0 ls2a ws21">IE9之前版本的计时器精度为15.625ms，因此介于0和15之间的任何值只能是0和15。IE9把计时</div><div class="t m0 x0 h5 y49e5 ff154 fs2 fc0 sc0 ls8 wseb">器精度提高到了4ms，但这个精度对于动画来说仍然不够明确。Chrome的计时器精度为4ms，而Firefox</div><div class="t m0 x0 h5 y49e6 ff154 fs2 fc0 sc0 ls3b">和Safari的精度是10ms。更为复杂的是，浏览器都开始限制后台标签页或不活动标签页的计时器。因此，</div><div class="t m0 x0 h5 y49e7 ff154 fs2 fc0 sc0 ls8 wseb">即使你优化了循环间隔，结果仍然只能接近你想要的效果。 </div><div class="t m0 x0 h20 y1266 ff152 fs3 fc0 sc0 ls248 ws214">25.1.3 mozRequestAnimationFrame </div><div class="t m0 x0 h5 y2dc5 ff14e fs2 fc0 sc0 lsd ws8">Mozilla的Robert O’Callahan认识到了这个问题，提出了一个非常独特的方案。他指出，CSS变换</div><div class="t m0 x0 h4 y49e8 ff154 fs2 fc0 sc0 ls24 wsf5">和动画的优势在于浏览器知道动画什么时候开始，因此会计算出正确的循环间隔，在恰当的时候刷新</div><div class="t m0 x0 h5 y49e9 ff14e fs2 fc0 sc0 ls81 ws76">UI。而对于JavaScript动画，浏览器无从知晓什么时候开始。因此他的方案就是创造一个新方法</div><div class="t m0 x0 h5 y49ea ff156 fs1 fc0 sc0 ls9 ws2">mozRequestAnimationFrame()，通过它告诉浏览器某些JavaScript代码将要执行动画。这样浏览器</div><div class="t m0 x0 h5 y49eb ff154 fs2 fc0 sc0 ls8 wseb">可以在运行某些代码后进行适当的优化。 </div></div></div>
<div id="pf2be" class="pf w0 h0" data-page-no="2be"><div class="pc pc2be w0 h0"><div class="t m0 x0 h2 y1 ff14e fs0 fc0 sc0 ls7 ws0">684  第25章 新兴的API </div><div class="t m0 x0 h3 y2 ff14e fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ff156 fs1 fc0 sc0 ls9 ws2">mozRequestAnimationFrame()方法接收一个参数，即在重绘屏幕前调用的一个函数。这个函数</div><div class="t m0 x0 h5 y4d ff154 fs2 fc0 sc0 ls8 wseb">负责改变下一次重绘时的DOM样式。为了创建动画循环，可以像以前使用setTimeout()一样，把多</div><div class="t m0 x0 hc y5 ff154 fs2 fc0 sc0 ls8 wseb">个对mozRequestAnimationFrame()的调用连缀起来。比如： </div><div class="t m0 x0 hb y2aab ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2aac ff156 fs6 fc0 sc0 ls21 wsb">function updateProgress(){  </div><div class="t m0 x0 hb y2aad ff156 fs6 fc0 sc0 ls21 wsb">    var div = document.getElementById(&quot;status&quot;); </div><div class="t m0 x0 hb y2aae ff156 fs6 fc0 sc0 ls21 wsb">    div.style.width = (parseInt(div.style.width, 10) + 5) + &quot;%&quot;; </div><div class="t m0 x0 hb y2aaf ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2ab0 ff156 fs6 fc0 sc0 ls21 wsb">    if (div.style.left != &quot;100%&quot;){ </div><div class="t m0 x0 hb y2ab1 ff156 fs6 fc0 sc0 ls21 wsb">        mozRequestAnimationFrame(updateProgress); </div><div class="t m0 x0 hb y2ab2 ff156 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y2ab3 ff156 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y2ab4 ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y49ec ff156 fs6 fc0 sc0 ls21 wsb">mozRequestAnimationFrame(updateProgress); </div><div class="t m0 x0 hb y49ed ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y49ee ff154 fs2 fc0 sc0 ls8 wseb">因为mozRequestAnimationFrame()只运行一次传入的函数，因此在需要再次修改UI从而生成</div><div class="t m0 x0 h4 y49ef ff154 fs2 fc0 sc0 ls8 wseb">动画时，需要再次手工调用它。同样，也需要同时考虑什么时候停止动画。这样就能得到非常平滑流畅</div><div class="t m0 x0 h5 y49f0 ff154 fs2 fc0 sc0 ls8">的动画。 </div><div class="t m0 x0 h14 y49f1 ff154 fs2 fc0 sc0 ls8 wseb">目前来看，mozRequestAnimationFrame()解决了浏览器不知道JavaScript动画什么时候开始、</div><div class="t m0 x0 h4 y49f2 ff154 fs2 fc0 sc0 ls8 wseb">不知道最佳循环间隔时间的问题，但不知道代码到底什么时候执行的问题呢？同样的方案也可以解决这</div><div class="t m0 x0 h5 y49f3 ff154 fs2 fc0 sc0 ls8">个问题。 </div><div class="t m0 x0 he y49f4 ff154 fs2 fc0 sc0 ls24 wsf5">我们传递的mozRequestAnimationFrame()函数也会接收一个参数，它是一个时间码（从1970</div><div class="t m0 x0 h5 y190 ff154 fs2 fc0 sc0 ls33">年1月1日起至今的毫秒数），表示下一次重绘的实际发生时间。注意，这一点很重要：</div><div class="t m0 x0 h4 y2f1d ff156 fs1 fc0 sc0 ls9 ws2">mozRequestAnimationFrame()会根据这个时间码设定将来的某个时刻进行重绘，而根据这个时间</div><div class="t m0 x0 h5 y192 ff154 fs2 fc0 sc0 ls8 wseb">码，你也能知道那个时刻是什么时间。然后，再优化动画效果就有了依据。 </div><div class="t m0 x0 h1e y193 ff154 fs2 fc0 sc0 ls8 wseb">要知道距离上一次重绘已经过去了多长时间，可以查询mozAnimationStartTime，其中包含上一</div><div class="t m0 x0 h4 y1f04 ff154 fs2 fc0 sc0 ls8 wseb">次重绘的时间码。用传入回调函数的时间码减去这个时间码，就能计算出在屏幕上重绘下一组变化之前</div><div class="t m0 x0 h5 y1f05 ff154 fs2 fc0 sc0 ls8 wseb">要经过多长时间。使用这个值的典型方式如下： </div><div class="t m0 x0 hb y1a79 ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y29d1 ff156 fs6 fc0 sc0 ls21 wsb">function draw(timestamp){ </div><div class="t m0 x0 h5 y49f5 ff14e fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y49f6 ff156 fs6 fc0 sc0 ls21 wsb">    //计算两次重绘的时间间隔 </div><div class="t m0 x0 hb y49f7 ff156 fs6 fc0 sc0 ls21 wsb">    var diff = timestamp - startTime; </div><div class="t m0 x0 hb y49f8 ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y49f9 ff156 fs6 fc0 sc0 ls21 wsb">    //使用diff确定下一步的绘制时间 </div><div class="t m0 x0 hb y49fa ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y49fb ff156 fs6 fc0 sc0 ls21 wsb">    //把startTime重写为这一次的绘制时间 </div><div class="t m0 x0 hb y49fc ff156 fs6 fc0 sc0 ls21 wsb">    startTime = timestamp; </div><div class="t m0 x0 hb y49fd ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y49fe ff156 fs6 fc0 sc0 ls21 wsb">    //重绘UI </div><div class="t m0 x0 hb y49ff ff156 fs6 fc0 sc0 ls21 wsb">    mozRequestAnimationFrame(draw); </div><div class="t m0 x0 hb y4a00 ff156 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y4a01 ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4a02 ff156 fs6 fc0 sc0 ls21 wsb">    var startTime = mozAnimationStartTime; </div><div class="t m0 x0 hb y4a03 ff156 fs6 fc0 sc0 ls21 wsb">    mozRequestAnimationFrame(draw); </div><div class="t m0 x0 h5 ya30 ff14e fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h171 y4a04 ff154 fs2 fc0 sc0 ls8 wseb">这里的关键是第一次读取mozAnimationStartTime的值，必须在传递给mozRequestAnimation </div><div class="t m0 x0 h42 y4a05 ff156 fs1 fc0 sc0 ls9 ws2">Frame()的回调函数外面进行。如果是在回调函数内部读取mozAnimationStartTime，得到的值与传</div><div class="t m0 x0 h5 y4711 ff154 fs2 fc0 sc0 ls8 wseb">入的时间码是相等的。 </div></div></div>
<div id="pf2bf" class="pf w0 h0" data-page-no="2bf"><div class="pc pc2bf w0 h0"><div class="t m0 x4 h2 y1db2 ff14e fs0 fc0 sc0 ls7 ws0">25.1 requestAnimationFrame()  685 </div><div class="t m0 x0 h3 y2 ff14e fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff15a fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff15a fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ff15a fs3 fc2 sc0 ls1d wsb">16 </div><div class="t m0 x3 h8 y20 ff15a fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff15a fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff15a fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff15a fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff15a fs3 fc2 sc0 ls1d wsb">20 </div><div class="t m0 x3 h8 y25 ff15a fs3 fc2 sc0 ls1d wsb">21 </div><div class="t m0 x3 h8 y26 ff15a fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff15a fs3 fc2 sc0 ls1d wsf">23 </div><div class="t m0 x3 h8 ya7a ff15a fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff15a fs3 fc2 sc0 ls1d wsf">25 </div><div class="t m0 x0 h20 y12d ff152 fs3 fc0 sc0 ls248 ws214">25.1.4 webkitRequestAnimationFrame与msRequestAnimationFrame </div><div class="t m0 x0 h5 y12e ff154 fs2 fc0 sc0 ls8 wseb">基于mozRequestAnimationFrame()，Chrome和IE10+也都给出了自己的实现，分别叫webkit- </div><div class="t m0 x0 h5 y12f ff156 fs1 fc0 sc0 ls9 ws2">RequestAnimationFrame()和msRequestAnimationFrame()。这两个版本与Mozilla的版本有两个</div><div class="t m0 x0 h4 y130 ff154 fs2 fc0 sc0 ls8 wseb">方面的微小差异。首先，不会给回调函数传递时间码，因此你无法知道下一次重绘将发生在什么时间。</div><div class="t m0 x0 h5 yc0a ff154 fs2 fc0 sc0 ls8 wseb">其次，Chrome又增加了第二个可选的参数，即将要发生变化的DOM元素。知道了重绘将发生在页面中</div><div class="t m0 x0 h5 y14bc ff154 fs2 fc0 sc0 ls8 wseb">哪个特定元素的区域内，就可以将重绘限定在该区域中。 </div><div class="t m0 x0 h5 y4a06 ff154 fs2 fc0 sc0 ls8 wseb">既然没有下一次重绘的时间码，那Chrome和IE没有提供mozAnimationStartTime 的实现也就</div><div class="t m0 x0 h5 y4a07 ff154 fs2 fc0 sc0 ls6 wsf7">很容易理解了——没有那个时间码，实现这个属性也没有什么用。不过，Chrome倒是又提供了另一个</div><div class="t m0 x0 he y4a08 ff154 fs2 fc0 sc0 ls8 wseb">方法webkitCancelAnimationFrame()，用于取消之前计划执行的重绘操作。 </div><div class="t m0 x0 h5 y4a09 ff154 fs2 fc0 sc0 ls8 wseb">假如你不需要知道精确的时间差，那么可以在Firefox 4+、IE10+和Chrome中可以参考以下模式创</div><div class="t m0 x0 h5 y4a0a ff154 fs2 fc0 sc0 ls8 wseb">建动画循环。 </div><div class="t m0 x0 hb y4a0b ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4a0c ff156 fs6 fc0 sc0 ls21 wsb">(function(){ </div><div class="t m0 x0 hb y4a0d ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4a0e ff156 fs6 fc0 sc0 ls21 wsb">    function draw(timestamp){ </div><div class="t m0 x0 hb y4a0f ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4a10 ff156 fs6 fc0 sc0 ls21 wsb">        //计算两次重绘的时间间隔 </div><div class="t m0 x0 hb y4a11 ff156 fs6 fc0 sc0 ls21 wsb">        var drawStart = (timestamp || Date.now()), </div><div class="t m0 x0 hb y4a12 ff156 fs6 fc0 sc0 ls21 wsb">            diff = drawStart - startTime; </div><div class="t m0 x0 hb y4a13 ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4a14 ff156 fs6 fc0 sc0 ls21 wsb">        //使用diff确定下一步的绘制时间 </div><div class="t m0 x0 hb y4a15 ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4a16 ff156 fs6 fc0 sc0 ls21 wsb">        //把startTime重写为这一次的绘制时间 </div><div class="t m0 x0 hb y4a17 ff156 fs6 fc0 sc0 ls21 wsb">        startTime = drawStart; </div><div class="t m0 x0 hb y4a18 ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4a19 ff156 fs6 fc0 sc0 ls21 wsb">        //重绘UI </div><div class="t m0 x0 hb y4a1a ff156 fs6 fc0 sc0 ls21 wsb">        requestAnimationFrame(draw); </div><div class="t m0 x0 hb y4a1b ff156 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y4a1c ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4a1d ff156 fs6 fc0 sc0 ls21 wsb">    var requestAnimationFrame = window.requestAnimationFrame || </div><div class="t m0 x0 hb y4a1e ff156 fs6 fc0 sc0 ls21 wsb">                                window.mozRequestAnimationFrame || </div><div class="t m0 x0 hb y4a1f ff156 fs6 fc0 sc0 ls21 wsb">                                window.webkitRequestAnimationFrame || </div><div class="t m0 x0 hb y4a20 ff156 fs6 fc0 sc0 ls21 wsb">                                window.msRequestAnimationFrame, </div><div class="t m0 x0 hb y4a21 ff156 fs6 fc0 sc0 ls21 wsb">        startTime = window.mozAnimationStartTime || Date.now(); </div><div class="t m0 x0 hb y4a22 ff156 fs6 fc0 sc0 ls21 wsb">    requestAnimationFrame(draw); </div><div class="t m0 x0 hb y4a23 ff156 fs6 fc0 sc0 ls21 wsb">})(); </div><div class="t m0 x0 h5 y3c68 ff14e fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y4a24 ff154 fs2 fc0 sc0 ls8 wseb">以上模式利用已有的功能创建了一个动画循环，大致计算出了两次重绘的时间间隔。在Firefox中，</div><div class="t m0 x0 h5 y4a25 ff154 fs2 fc0 sc0 ls8 wseb">计算时间间隔使用的是既有的时间码，而在Chrome和IE中，则使用不十分精确的Date对象。这个模</div><div class="t m0 x0 h5 y196d ff154 fs2 fc0 sc0 ls8 wseb">式可以大致体现出两次重绘的时间间隔，但不会告诉你在Chrome和IE中的时间间隔到底是多少。不过，</div><div class="t m0 x0 h5 y4a26 ff154 fs2 fc0 sc0 ls8 wseb">大致知道时间间隔总比一点儿概念也没有好些。 </div><div class="t m0 x0 h4 y4a27 ff154 fs2 fc0 sc0 ls24 wsf5">因为首先检测的是标准函数名，其次才是特定于浏览器的版本，所以这个动画循环在将来也能够</div><div class="t m0 x0 h5 y4a28 ff154 fs2 fc0 sc0 ls5">使用。 </div><div class="t m0 x0 h14 y4a29 ff154 fs2 fc0 sc0 ls8 wseb">目前，W3C已经着手起草requestAnimationFrame() API，而且作为Web Performance Group的</div><div class="t m0 x0 h5 y30d7 ff154 fs2 fc0 sc0 ls8 wseb">一部分，Mozilla和Google正共同参与该标准草案的制定工作。 </div></div></div>
<div id="pf2c0" class="pf w0 h0" data-page-no="2c0"><div class="pc pc2c0 w0 h0"><div class="t m0 x0 h2 y1 ff14e fs0 fc0 sc0 ls7 ws0">686  第25章 新兴的API </div><div class="t m0 x0 h3 y2 ff14e fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hd y4a2b ff152 fs7 fc0 sc0 ls245">25.2 Page Visibility API </div><div class="t m0 x0 h5 y4a2c ff154 fs2 fc0 sc0 ls8 wseb">不知道用户是不是正在与页面交互，这是困扰广大Web开发人员的一个主要问题。如果页面最小</div><div class="t m0 x0 h4 y4a2d ff154 fs2 fc0 sc0 ls8 wseb">化了或者隐藏在了其他标签页后面，那么有些功能是可以停下来的，比如轮询服务器或者某些动画效果。</div><div class="t m0 x0 h5 y4a2e ff154 fs2 fc0 sc0 ls3b">而Page Visibility API（页面可见性API）就是为了让开发人员知道页面是否对用户可见而推出的。 </div><div class="t m0 x0 h5 y4a2f ff154 fs2 fc0 sc0 ls8 wseb">这个API本身非常简单，由以下三部分组成。 </div><div class="t m0 x0 h4 y9c1 ff153 fs1 fc0 sc0 ls2"> document.hidden：表示页面是否隐藏的布尔值。页面隐藏包括页面在后台标签页中或者浏览</div><div class="t m0 x0 h5 y1108 ff154 fs2 fc0 sc0 ls8 wseb">器最小化。 </div><div class="t m0 x0 h5 y4a30 ff153 fs1 fc0 sc0 ls2"> document.visibilityState：表示下列4个可能状态的值。 </div><div class="t m0 x0 h5 y4a31 ff153 fsc fc0 sc0 ls8 ws393"> 页面在后台标签页中或浏览器最小化。 </div><div class="t m0 x0 h5 y4941 ff153 fsc fc0 sc0 ls8 ws393"> 页面在前台标签页中。 </div><div class="t m0 x0 h5 y4942 ff153 fsc fc0 sc0 ls8 ws393"> 实际的页面已经隐藏，但用户可以看到页面的预览（就像在Windows 7中，用户把鼠标移动到</div><div class="t m0 x0 h5 y4a32 ff154 fs2 fc0 sc0 ls8 wseb">任务栏的图标上，就可以显示浏览器中当前页面的预览）。 </div><div class="t m0 x0 h5 y2343 ff153 fsc fc0 sc0 ls8 ws393"> 页面在屏幕外执行预渲染处理。 </div><div class="t m0 x0 h5 ydcd ff153 fs1 fc0 sc0 ls2"> visibilitychange事件：当文档从可见变为不可见或从不可见变为可见时，触发该事件。 </div><div class="t m0 x0 h5 y4a33 ff154 fs2 fc0 sc0 ls8 wseb">在编写本书时，只有IE10和Chrome支持Page Visibility API。IE的版本是在每个属性或事件前面加</div><div class="t m0 x0 hc y4a34 ff154 fs2 fc0 sc0 ls4c0">上ms前缀，而Chrome 则是加上webkit前缀。因此document.hidden 在IE的实现中就是</div><div class="t m0 x0 h5 y4a35 ff156 fs1 fc0 sc0 ls9 ws2">document.msHidden，而在Chrome的实现中则是document.webkitHidden。检查浏览器是否支持</div><div class="t m0 x0 h5 y4a36 ff154 fs2 fc0 sc0 ls8 wseb">这个API的最佳方式如下： </div><div class="t m0 x0 hb y21c1 ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4a37 ff156 fs6 fc0 sc0 ls21 wsb">function isHiddenSupported(){ </div><div class="t m0 x0 hb y4a38 ff156 fs6 fc0 sc0 ls21 wsb">    return typeof (document.hidden || document.msHidden || </div><div class="t m0 x0 hb y4a39 ff156 fs6 fc0 sc0 ls21 wsb">                   document.webkitHidden) != &quot;undefined&quot;; </div><div class="t m0 x0 hb y4a3a ff156 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y4a3b ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y1c42 ff15b fs2 fc0 sc0 ls7a wsb">PageVisibilityAPIExample01.htm </div><div class="t m0 x0 h5 y4a3c ff154 fs2 fc0 sc0 ls8 wseb">类似地，使用同样的模式可以检测页面是否隐藏： </div><div class="t m0 x0 hb y4a3d ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4a3e ff156 fs6 fc0 sc0 ls21 wsb">if (document.hidden || document.msHidden || document.webKitHidden){ </div><div class="t m0 x0 h16 y4a3f ff156 fs6 fc0 sc0 ls21 wsb">    //页面隐藏了 </div><div class="t m0 x0 hb y4a40 ff156 fs6 fc0 sc0 ls21 wsb">} else { </div><div class="t m0 x0 h16 y4a41 ff156 fs6 fc0 sc0 ls21 wsb">    //页面未隐藏 </div><div class="t m0 x0 hb y4a42 ff156 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h5 y3427 ff14e fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y4a43 ff15b fs2 fc0 sc0 ls7a wsb">PageVisibilityAPIExample01.htm </div><div class="t m0 x0 h5 y1c8d ff154 fs2 fc0 sc0 ls8 wseb">注意，以上代码在不支持该API的浏览器中会提示页面未隐藏。这是Page Visibility API有意设计的</div><div class="t m0 x0 h5 y4a44 ff154 fs2 fc0 sc0 ls8 wseb">结果，目的是为了向后兼容。 </div><div class="t m0 x0 h1c y4a45 ff154 fs2 fc0 sc0 ls8 wseb">为了在页面从可见变为不可见或从不可见变为可见时收到通知，可以侦听visibilitychange事</div><div class="t m0 x0 h5 y4a46 ff154 fs2 fc0 sc0 ls8 wseb">件。在IE中，这个事件叫msvisibilitychange，而在Chrome 中这个事件叫webkitvisibility- </div><div class="t m0 x0 h173 y4a47 ff156 fs1 fc0 sc0 ls9 ws2">change。为了在两个浏览器中都能侦听到该事件，可以像下面的例子一样，为每个事件都指定相同的</div><div class="t m0 x0 h5 y4a48 ff154 fs2 fc0 sc0 ls8 wseb">事件处理程序： </div><div class="t m0 x0 hb ya80 ff156 fs6 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf2c1" class="pf w0 h0" data-page-no="2c1"><div class="pc pc2c1 w0 h0"><div class="t m0 x2 h2 y1db2 ff14e fs0 fc0 sc0 ls7 ws0">25.3 Geolocation API  687 </div><div class="t m0 x0 h3 y2 ff14e fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff15a fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff15a fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ff15a fs3 fc2 sc0 ls1d wsb">16 </div><div class="t m0 x3 h8 y20 ff15a fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff15a fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff15a fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff15a fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff15a fs3 fc2 sc0 ls1d wsb">20 </div><div class="t m0 x3 h8 y25 ff15a fs3 fc2 sc0 ls1d wsb">21 </div><div class="t m0 x3 h8 y26 ff15a fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff15a fs3 fc2 sc0 ls1d wsf">23 </div><div class="t m0 x3 h8 ya7a ff15a fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff15a fs3 fc2 sc0 ls1d wsf">25 </div><div class="t m0 x0 hb y12b2 ff156 fs6 fc0 sc0 ls21 wsb">function handleVisibilityChange(){ </div><div class="t m0 x0 hb y1670 ff156 fs6 fc0 sc0 ls21 wsb">    var output = document.getElementById(&quot;output&quot;), </div><div class="t m0 x0 hb y1671 ff156 fs6 fc0 sc0 ls21 wsb">        msg;  </div><div class="t m0 x0 hb y4a49 ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4a4a ff156 fs6 fc0 sc0 ls21 wsb">    if (document.hidden || document.msHidden || document.webkitHidden){ </div><div class="t m0 x0 hb y4a4b ff156 fs6 fc0 sc0 ls21 wsb">        msg = &quot;Page is now hidden. &quot; + (new Date()) + &quot;&lt;br&gt;&quot;; </div><div class="t m0 x0 hb y4a4c ff156 fs6 fc0 sc0 ls21 wsb">    } else { </div><div class="t m0 x0 hb y4a4d ff156 fs6 fc0 sc0 ls21 wsb">        msg = &quot;Page is now visible. &quot; + (new Date()) + &quot;&lt;br&gt;&quot;; </div><div class="t m0 x0 hb y4a4e ff156 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y4a4f ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4a50 ff156 fs6 fc0 sc0 ls21 wsb">    output.innerHTML += msg; </div><div class="t m0 x0 hb y4a51 ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4a52 ff156 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y4a53 ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4a54 ff156 fs6 fc0 sc0 ls21">//要为两个事件都指定事件处理程序 </div><div class="t m0 x0 hb y4a55 ff156 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(document, &quot;msvisibilitychange&quot;, handleVisibilityChange); </div><div class="t m0 x0 hb y4a56 ff156 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(document, &quot;webkitvisibilitychange&quot;, handleVisibilityChange); </div><div class="t m0 x0 hb y4a57 ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y29c1 ff15b fs2 fc0 sc0 ls79 wsb">PageVisibilityAPIExample01.htm </div><div class="t m0 x0 h5 y131a ff154 fs2 fc0 sc0 ls8 wseb">以上代码同时适用于IE和Chrome。而且，API的这一部分已经相对稳定，因此在实际的Web开发</div><div class="t m0 x0 h5 y4a58 ff154 fs2 fc0 sc0 ls8 wseb">中也可以使用以上代码。 </div><div class="t m0 x0 hc y159a ff154 fs2 fc0 sc0 ls386 ws2fd">关于这一API的实现，差异最大的是 document.visibilityState属性。IE10 PR 2的</div><div class="t m0 x0 h5 yeb8 ff156 fs1 fc0 sc0 ls9 ws2">document.msVisibilityState是一个表示如下4种状态的数字值。 </div><div class="t m0 x0 h5 y4a59 ff14e fs2 fc0 sc0 ls13 wsb">(1) document.MS_PAGE_HIDDEN (0) </div><div class="t m0 x0 h5 y4a5a ff14e fs2 fc0 sc0 ls13 wsb">(2) document.MS_PAGE_VISIBLE (1) </div><div class="t m0 x0 h5 y4a5b ff14e fs2 fc0 sc0 ls13 wsb">(3) document.MS_PAGE_PREVIEW (2) </div><div class="t m0 x0 h5 y4a5c ff14e fs2 fc0 sc0 ls13 wsb">(4) document.MS_PAGE_PRERENDER (3) </div><div class="t m0 x0 h53 y3516 ff154 fs2 fc0 sc0 ls3b">在Chrome中，document.webkitVisibilityState可能是下列3个字符串值： </div><div class="t m0 x0 h5 y4a5d ff14e fs2 fc0 sc0 ls13 wsb">(1) &quot;hidden&quot; </div><div class="t m0 x0 h5 y4a5e ff14e fs2 fc0 sc0 ls13 wsb">(2) &quot;visible&quot; </div><div class="t m0 x0 h5 y4a5f ff14e fs2 fc0 sc0 ls13 wsb">(3) &quot;prerender&quot; </div><div class="t m0 x0 h5 y4a60 ff14e fs2 fc0 sc0 ls50 ws41">Chrome并没有给每个状态定义对应的常量，但最终的实现很可能会使用常量。 </div><div class="t m0 x0 hd8 y4a61 ff154 fs2 fc0 sc0 ls8 wseb">由于存在以上差异，所以建议大家先不要完全依赖带前缀的document.visibilityState，最好</div><div class="t m0 x0 hc y4a62 ff154 fs2 fc0 sc0 ls8 wseb">只使用document.hidden属性。 </div><div class="t m0 x0 hd y4a63 ff152 fs7 fc0 sc0 ls245">25.3 Geolocation API </div><div class="t m0 x0 h5 y4a64 ff154 fs2 fc0 sc0 ls8 wseb">地理定位（geolocation）是最令人兴奋，而且得到了广泛支持的一个新API。通过这套API，JavaScript</div><div class="t m0 x0 h4 y4a65 ff154 fs2 fc0 sc0 ls8 wseb">代码能够访问到用户的当前位置信息。当然，访问之前必须得到用户的明确许可，即同意在页面中共享</div><div class="t m0 x0 h4 y4a66 ff154 fs2 fc0 sc0 ls8 wseb">其位置信息。如果页面尝试访问地理定位信息，浏览器就会显示一个对话框，请求用户许可共享其位置</div><div class="t m0 x0 h5 y4a67 ff154 fs2 fc0 sc0 ls8 wseb">信息。图25-1展示了Chrome中的这样一个对话框。 </div><div class="t m0 x2 h5 y4a68 ff14e fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x4 h3 y4a69 ff154 fs1 fc0 sc0 ls8 wsb">图 25-1 </div><div class="t m0 x0 h5 y2c7e ff14e fs2 fc0 sc0 ls8 ws11f">Geolocation API在浏览器中的实现是navigator.geolocation对象，这个对象包含3个方法。</div><div class="t m0 x0 h1e y2c7f ff154 fs2 fc0 sc0 ls8 wseb">第一个方法是getCurrentPosition()，调用这个方法就会触发请求用户共享地理定位信息的对话框。</div></div></div>
<div id="pf2c2" class="pf w0 h0" data-page-no="2c2"><div class="pc pc2c2 w0 h0"><div class="t m0 x0 h2 y1 ff14e fs0 fc0 sc0 ls7 ws0">688  第25章 新兴的API </div><div class="t m0 x0 h3 y2 ff14e fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff154 fs2 fc0 sc0 ls8 wseb">这个方法接收3个参数：成功回调函数、可选的失败回调函数和可选的选项对象。 </div><div class="t m0 x0 h1e y4d ff154 fs2 fc0 sc0 ls8 wseb">其中，成功回调函数会接收到一个Position对象参数，该对象有两个属性：coords和timestamp。</div><div class="t m0 x0 hc y5 ff154 fs2 fc0 sc0 ls184">而coords对象中将包含下列与位置相关的信息。 </div><div class="t m0 x0 h5 yd9 ff153 fs1 fc0 sc0 ls2"> latitude：以十进制度数表示的纬度。 </div><div class="t m0 x0 h5 y219 ff153 fs1 fc0 sc0 ls2"> longitude：以十进制度数表示的经度。 </div><div class="t m0 x0 h5 y8 ff153 fs1 fc0 sc0 ls2"> accuracy：经、纬度坐标的精度，以米为单位。 </div><div class="t m0 x0 hc y15e ff154 fs2 fc0 sc0 ls8 wseb">有些浏览器还可能会在coords对象中提供如下属性。 </div><div class="t m0 x0 h5 ya ff153 fs1 fc0 sc0 ls2"> altitude：以米为单位的海拔高度，如果没有相关数据则值为null。 </div><div class="t m0 x0 h5 yb ff153 fs1 fc0 sc0 ls2"> altitudeAccuracy：海拔高度的精度，以米为单位，数值越大越不精确。 </div><div class="t m0 x0 h5 yc ff153 fs1 fc0 sc0 ls2"> heading：指南针的方向，0°表示正北，值为NaN表示没有检测到数据。 </div><div class="t m0 x0 h5 yd ff153 fs1 fc0 sc0 ls2"> speed：速度，即每秒移动多少米，如果没有相关数据则值为null。 </div><div class="t m0 x0 hc ye ff154 fs2 fc0 sc0 ls8 wseb">在实际开发中，latitude和longitude是大多数Web应用最常用到的属性。例如，以下代码将</div><div class="t m0 x0 h5 y21c ff154 fs2 fc0 sc0 ls8 wseb">在地图上绘制用户的位置： </div><div class="t m0 x0 hb y215f ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4a6a ff156 fs6 fc0 sc0 ls21 wsb">navigator.geolocation.getCurrentPosition(function(position){ </div><div class="t m0 x0 hb y4a6b ff156 fs6 fc0 sc0 ls21 wsb">    drawMapCenteredAt(position.coords.latitude, positions.coords.longitude); </div><div class="t m0 x0 hb y4a6c ff156 fs6 fc0 sc0 ls21 wsb">});  </div><div class="t m0 x0 hb y4a6d ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y1b7e ff154 fs2 fc0 sc0 ls5 wsec">以上介绍的是成功回调函数。getCurrentPosition()的第二个参数，即失败回调函数，在被调</div><div class="t m0 x0 h1e y1e50 ff154 fs2 fc0 sc0 ls8 wseb">用的时候也会接收到一个参数。这个参数是一个对象，包含两个属性：message和code。其中，message</div><div class="t m0 x0 h4 y1b7f ff154 fs2 fc0 sc0 ls8 wseb">属性中保存着给人看的文本消息，解释为什么会出错，而code属性中保存着一个数值，表示错误的类</div><div class="t m0 x0 h5 y4a6e ff154 fs2 fc0 sc0 ls8 wseb">型：用户拒绝共享（1）、位置无效（2）或者超时（3）。实际开发中，大多数Web应用只会将错误消息</div><div class="t m0 x0 h5 y4a6f ff154 fs2 fc0 sc0 ls8 wseb">保存到日志文件中，而不一定会因此修改用户界面。例如： </div><div class="t m0 x0 hb y264e ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4a70 ff156 fs6 fc0 sc0 ls21 wsb">navigator.geolocation.getCurrentPosition(function(position){ </div><div class="t m0 x0 hb y4a71 ff156 fs6 fc0 sc0 ls21 wsb">    drawMapCenteredAt(position.coords.latitude, positions.coords.longitude); </div><div class="t m0 x0 hb y4a72 ff156 fs6 fc0 sc0 ls21">}, function(error){ </div><div class="t m0 x0 hb y4a73 ff156 fs6 fc0 sc0 ls21 wsb">    console.log(&quot;Error code: &quot; + error.code); </div><div class="t m0 x0 hb y4a74 ff156 fs6 fc0 sc0 ls21 wsb">    console.log(&quot;Error message: &quot; + error.message); </div><div class="t m0 x0 hb y4a75 ff155 fs6 fc0 sc0 ls16f">});  </div><div class="t m0 x0 hb y4a76 ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y4a77 ff156 fs1 fc0 sc0 ls9 ws2">getCurrentPosition()的第三个参数是一个选项对象，用于设定信息的类型。可以设置的选项</div><div class="t m0 x0 h4 y4a78 ff154 fs2 fc0 sc0 ls8 wseb">有三个：enableHighAccuracy是一个布尔值，表示必须尽可能使用最准确的位置信息；timeout是</div><div class="t m0 x0 h1e y4a79 ff154 fs2 fc0 sc0 ls8 wseb">以毫秒数表示的等待位置信息的最长时间；maximumAge表示上一次取得的坐标信息的有效时间，以毫</div><div class="t m0 x0 h5 y4a7a ff154 fs2 fc0 sc0 ls8 wseb">秒表示，如果时间到则重新取得新坐标信息。例如： </div><div class="t m0 x0 hb y2d72 ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4a7b ff156 fs6 fc0 sc0 ls21 wsb">navigator.geolocation.getCurrentPosition(function(position){ </div><div class="t m0 x0 hb y4a7c ff155 fs6 fc0 sc0 ls21 wsb">    drawMapCenteredAt(position.coords.latitude, positions.coords.longitude); </div><div class="t m0 x0 hb y4a7d ff156 fs6 fc0 sc0 ls21 wsb">}, function(error){ </div><div class="t m0 x0 hf6 y4a7e ff155 fs6 fc0 sc0 ls21 wsb">    console.log(&quot;Error code: &quot; + error.code); </div><div class="t m0 x0 hf6 y4a7f ff155 fs6 fc0 sc0 ls21 wsb">    console.log(&quot;Error message: &quot; + error.message); </div><div class="t m0 x0 hf6 y4a80 ff155 fs6 fc0 sc0 ls21 wsb">}, { </div><div class="t m0 x0 hf6 y4a81 ff155 fs6 fc0 sc0 ls21 wsb">    enableHighAccuracy: true, </div><div class="t m0 x0 hf6 y4a82 ff155 fs6 fc0 sc0 ls21 wsb">    timeout: 5000, </div><div class="t m0 x0 hf6 y4a83 ff155 fs6 fc0 sc0 ls21 wsb">    maximumAge: 25000 </div><div class="t m0 x0 hf6 y4a84 ff155 fs6 fc0 sc0 ls21 wsb">});  </div><div class="t m0 x0 hf6 y4a85 ff155 fs6 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf2c3" class="pf w0 h0" data-page-no="2c3"><div class="pc pc2c3 w0 h0"><div class="t m0 x2 h2 y1db2 ff14e fs0 fc0 sc0 ls7 ws0">25.4 File API  689 </div><div class="t m0 x0 h3 y2 ff14e fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff15a fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff15a fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ff15a fs3 fc2 sc0 ls1d wsb">16 </div><div class="t m0 x3 h8 y20 ff15a fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff15a fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff15a fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff15a fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff15a fs3 fc2 sc0 ls1d wsb">20 </div><div class="t m0 x3 h8 y25 ff15a fs3 fc2 sc0 ls1d wsb">21 </div><div class="t m0 x3 h8 y26 ff15a fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff15a fs3 fc2 sc0 ls1d wsf">23 </div><div class="t m0 x3 h8 ya7a ff15a fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff15a fs3 fc2 sc0 ls1d wsf">25 </div><div class="t m0 x0 h4 y3 ff154 fs2 fc0 sc0 ls8 wseb">这三个选项都是可选的，可以单独设置，也可以与其他选项一起设置。除非确实需要非常精确的信</div><div class="t m0 x0 h1e y4d ff154 fs2 fc0 sc0 ls8 wseb">息，否则建议保持enableHighAccuracy的false值（默认值）。将这个选项设置为true需要更长</div><div class="t m0 x0 h4 y5 ff154 fs2 fc0 sc0 ls8 wseb">的时候，而且在移动设备上还会导致消耗更多电量。类似地，如果不需要频繁更新用户的位置信息，那</div><div class="t m0 x0 hc y6 ff154 fs2 fc0 sc0 ls8 wseb">么可以将maximumAge设置为Infinity，从而始终都使用上一次的坐标信息。 </div><div class="t m0 x0 h1e y15d ff154 fs2 fc0 sc0 ls8 wseb">如果你希望跟踪用户的位置，那么可以使用另一个方法watchPosition()。这个方法接收的参数</div><div class="t m0 x0 h1e y21a ff154 fs2 fc0 sc0 ls4c4">与getCurrentPosition()方法完全相同。实际上，watchPosition()与定时调用</div><div class="t m0 x0 h4 y9 ff156 fs1 fc0 sc0 ls9 ws2">getCurrentPosition()的效果相同。在第一次调用watchPosition()方法后，会取得当前位置，执</div><div class="t m0 x0 h1e y15f ff154 fs2 fc0 sc0 ls6 wsf7">行成功回调或者错误回调。然后，watchPosition()就地等待系统发出位置已改变的信号（它不会自</div><div class="t m0 x0 h5 yb ff154 fs2 fc0 sc0 ls8 wseb">己轮询位置）。 </div><div class="t m0 x0 h1e y78a ff154 fs2 fc0 sc0 ls8 wseb">调用watchPosition()会返回一个数值标识符，用于跟踪监控的操作。基于这个返回值可以取消</div><div class="t m0 x0 h1e y116b ff154 fs2 fc0 sc0 ls8 wseb">监控操作，只要将其传递给clearWatch()方法即可（与使用setTimeout()和clearTimeout()类</div><div class="t m0 x0 h5 ye ff154 fs2 fc0 sc0 ls8 wseb">似）。例如： </div><div class="t m0 x0 hb y84f ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4a86 ff156 fs6 fc0 sc0 ls21 wsb">var watchId = navigator.geolocation.watchPosition(function(position){ </div><div class="t m0 x0 hb y4a87 ff155 fs6 fc0 sc0 ls21 wsb">    drawMapCenteredAt(position.coords.latitude, positions.coords.longitude); </div><div class="t m0 x0 hb y4a88 ff156 fs6 fc0 sc0 ls21">}, function(error){ </div><div class="t m0 x0 hf6 y4a89 ff155 fs6 fc0 sc0 ls21 wsb">    console.log(&quot;Error code: &quot; + error.code); </div><div class="t m0 x0 hf6 y4a8a ff155 fs6 fc0 sc0 ls21 wsb">    console.log(&quot;Error message: &quot; + error.message); </div><div class="t m0 x0 hf6 y4a8b ff155 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 hf6 y4a8c ff155 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hf6 y4a8d ff155 fs6 fc0 sc0 ls21 wsb">clearWatch(watchId); </div><div class="t m0 x0 hb y4a8e ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y4a8f ff154 fs2 fc0 sc0 ls30 wsf6">以上例子调用了watchPosition()方法，将返回的标识符保存在了watchId 中。然后，又将</div><div class="t m0 x0 h5 y3e3 ff156 fs1 fc0 sc0 ls9 ws2">watchId传给了clearWatch()，取消了监控操作。 </div><div class="t m0 x0 h5 y3e4 ff154 fs2 fc0 sc0 ls8 wseb">支持地理定位的浏览器有IE9+、Firefox 3.5+、Opera 10.6+、Safari 5+、Chrome、iOS 版Safari、Android</div><div class="t m0 x0 h5 y2cb1 ff154 fs2 fc0 sc0 ls3b">版WebKit。要了解使用地理定位的更多精彩范例，请访问http://html5demos.com/geo。 </div><div class="t m0 x0 hd y10cb ff152 fs7 fc0 sc0 ls245">25.4 File API </div><div class="t m0 x0 h5 y26b9 ff154 fs2 fc0 sc0 ls8 wseb">不能直接访问用户计算机中的文件，一直都是Web应用开发中的一大障碍。2000年以前，处理文</div><div class="t m0 x0 hc y4a90 ff154 fs2 fc0 sc0 ls8 wseb">件的唯一方式就是在表单中加入&lt;input type=&quot;file&quot;&gt;字段，仅此而已。File API（文件API）的宗旨</div><div class="t m0 x0 h5 y4a91 ff154 fs2 fc0 sc0 ls8 wseb">是为Web开发人员提供一种安全的方式，以便在客户端访问用户计算机中的文件，并更好地对这些文</div><div class="t m0 x0 h5 y4a92 ff154 fs2 fc0 sc0 ls8 wseb">件执行操作。支持File API的浏览器有IE10+、Firefox 4+、Safari 5.0.5+、Opera 11.1+和Chrome。 </div><div class="t m0 x0 h5 y4a93 ff14e fs2 fc0 sc0 ls1b ws79">File API在表单中的文件输入字段的基础上，又添加了一些直接访问文件信息的接口。HTML5在</div><div class="t m0 x0 h5 y4a94 ff14e fs2 fc0 sc0 ls81 ws76">DOM中为文件输入元素添加了一个files集合。在通过文件输入字段选择了一或多个文件时，files</div><div class="t m0 x0 h5 y179a ff154 fs2 fc0 sc0 ls8 wseb">集合中将包含一组File对象，每个File对象对应着一个文件。每个 File对象都有下列只读属性。 </div><div class="t m0 x0 h5 y4a95 ff153 fs1 fc0 sc0 ls2"> name：本地文件系统中的文件名。 </div><div class="t m0 x0 h5 y1d38 ff153 fs1 fc0 sc0 ls2"> size：文件的字节大小。 </div><div class="t m0 x0 h5 y2ba3 ff153 fs1 fc0 sc0 ls2"> type：字符串，文件的MIME类型。 </div><div class="t m0 x0 h5 yc70 ff153 fs1 fc0 sc0 ls2"> lastModifiedDate：字符串，文件上一次被修改的时间（只有Chrome实现了这个属性）。 </div><div class="t m0 x0 hc y4a96 ff154 fs2 fc0 sc0 ls8 wseb">举个例子，通过侦听change事件并读取files集合就可以知道选择的每个文件的信息： </div><div class="t m0 x0 hb y4a97 ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4a98 ff156 fs6 fc0 sc0 ls21 wsb">var filesList = document.getElementById(&quot;files-list&quot;); </div><div class="t m0 x0 hb y4a99 ff156 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(filesList, &quot;change&quot;, function(event){  </div></div></div>
<div id="pf2c4" class="pf w0 h0" data-page-no="2c4"><div class="pc pc2c4 w0 h0"><div class="t m0 x0 h2 y1 ff14e fs0 fc0 sc0 ls7 ws0">690  第25章 新兴的API </div><div class="t m0 x0 h3 y2 ff14e fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 ff156 fs6 fc0 sc0 ls21 wsb">    var files = EventUtil.getTarget(event).files, </div><div class="t m0 x0 hb y7a ff156 fs6 fc0 sc0 ls21 wsb">        i = 0, </div><div class="t m0 x0 hb y7b ff156 fs6 fc0 sc0 ls21 wsb">        len = files.length; </div><div class="t m0 x0 hb y7c ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y7d ff156 fs6 fc0 sc0 ls21 wsb">    while (i &lt; len){ </div><div class="t m0 x0 hb y7e ff156 fs6 fc0 sc0 ls21 wsb">        console.log(files[i].name + &quot; (&quot; + files[i].type + &quot;, &quot; + files[i].size + </div><div class="t m0 x0 hb y7f ff156 fs6 fc0 sc0 ls21 wsb">                   &quot; bytes) &quot;); </div><div class="t m0 x0 hb y80 ff156 fs6 fc0 sc0 ls21 wsb">        i++; </div><div class="t m0 x0 hb y81 ff156 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y82 ff156 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 hb y83 ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y998 ff15b fs2 fc0 sc0 ls94 wsb">FileAPIExample01.htm </div><div class="t m0 x0 h5 y999 ff154 fs2 fc0 sc0 ls8 wseb">这个例子把每个文件的信息输出到了控制台中。仅仅这一项功能，对Web应用开发来说就已经是</div><div class="t m0 x0 h5 y99a ff154 fs2 fc0 sc0 ls8 wseb">非常大的进步了。不过，File API的功能还不止于此，通过它提供的FileReader类型甚至还可以读取</div><div class="t m0 x0 h5 y4a9b ff154 fs2 fc0 sc0 ls8 wseb">文件中的数据。 </div><div class="t m0 x0 h20 y1f38 ff152 fs3 fc0 sc0 ls248 ws214">25.4.1 FileReader类型 </div><div class="t m0 x0 h4 y4336 ff156 fs1 fc0 sc0 ls9 ws2">FileReader类型实现的是一种异步文件读取机制。可以把FileReader想象成XMLHttpRequest，</div><div class="t m0 x0 h4 y99e ff154 fs2 fc0 sc0 ls8 wseb">区别只是它读取的是文件系统，而不是远程服务器。为了读取文件中的数据，FileReader提供了如下</div><div class="t m0 x0 h5 y99f ff154 fs2 fc0 sc0 ls8 wseb">几个方法。 </div><div class="t m0 x0 h4 y4a9c ff153 fs1 fc0 sc0 ls2"> readAsText(file,encoding)：以纯文本形式读取文件，将读取到的文本保存在result属</div><div class="t m0 x0 h5 y9a1 ff154 fs2 fc0 sc0 ls8 wseb">性中。第二个参数用于指定编码类型，是可选的。 </div><div class="t m0 x0 h5 y2fcf ff153 fs1 fc0 sc0 ls2"> readAsDataURL(file)：读取文件并将文件以数据URI的形式保存在result属性中。 </div><div class="t m0 x0 h4 y4a9d ff153 fs1 fc0 sc0 ls2"> readAsBinaryString(file)：读取文件并将一个字符串保存在result属性中，字符串中的</div><div class="t m0 x0 h5 y4a9e ff154 fs2 fc0 sc0 ls8 wseb">每个字符表示一字节。 </div><div class="t m0 x0 h4 y4db ff153 fs1 fc0 sc0 ls2"> readAsArrayBuffer(file)：读取文件并将一个包含文件内容的ArrayBuffer保存在</div><div class="t m0 x0 h5 y228d ff156 fs1 fc0 sc0 ls9 ws2">result属性中。 </div><div class="t m0 x0 h4 y4a9f ff154 fs2 fc0 sc0 ls8 wseb">这些读取文件的方法为灵活地处理文件数据提供了极大便利。例如，可以读取图像文件并将其保存</div><div class="t m0 x0 h5 y4aa0 ff154 fs2 fc0 sc0 ls8 wseb">为数据URI，以便将其显示给用户，或者为了解析方便，可以将文件读取为文本形式。 </div><div class="t m0 x0 h1c y4aa1 ff154 fs2 fc0 sc0 ls6f ws113">由于读取过程是异步的，因此FileReader也提供了几个事件。其中最有用的三个事件是</div><div class="t m0 x0 h4 y1c45 ff156 fs1 fc0 sc0 ls9 ws2">progress、error和load，分别表示是否又读取了新数据、是否发生了错误以及是否已经读完了整个</div><div class="t m0 x0 h5 y4aa2 ff154 fs2 fc0 sc0 ls8">文件。 </div><div class="t m0 x0 hc y4aa3 ff154 fs2 fc0 sc0 ls8 wseb">每过50ms左右，就会触发一次progress事件，通过事件对象可以获得与 XHR的progress事</div><div class="t m0 x0 h1e y4aa4 ff154 fs2 fc0 sc0 ls8 wseb">件相同的信息（属性）：lengthComputable、loaded和total。另外，尽管可能没有包含全部数据，</div><div class="t m0 x0 hc y4aa5 ff154 fs2 fc0 sc0 ls8 wseb">但每次progress事件中都可以通过FileReader的result 属性读取到文件内容。 </div><div class="t m0 x0 h4 y4aa6 ff154 fs2 fc0 sc0 ls8 wseb">由于种种原因无法读取文件，就会触发error事件。触发 error事件时，相关的信息将保存到</div><div class="t m0 x0 h4 y3b14 ff156 fs1 fc0 sc0 ls9 ws2">FileReader的error属性中。这个属性中将保存一个对象，该对象只有一个属性code，即错误码。</div><div class="t m0 x0 h5 y4aa7 ff154 fs2 fc0 sc0 ls8 wseb">这个错误码是1表示未找到文件，是2表示安全性错误，是3表示读取中断，是4表示文件不可读，是</div><div class="t m0 x0 h5 y4aa8 ff14e fs2 fc0 sc0 ls38">5表示编码错误。 </div><div class="t m0 x0 h4b y4aa9 ff154 fs2 fc0 sc0 ls8 wseb">文件成功加载后会触发load事件；如果发生了error事件，就不会发生load 事件。以下是一个</div><div class="t m0 x0 h5 y4aaa ff154 fs2 fc0 sc0 ls8 wseb">使用上述三个事件的例子。 </div><div class="t m0 x0 hb y4aab ff156 fs6 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf2c5" class="pf w0 h0" data-page-no="2c5"><div class="pc pc2c5 w0 h0"><div class="t m0 x2 h2 y1db2 ff14e fs0 fc0 sc0 ls7 ws0">25.4 File API  691 </div><div class="t m0 x0 h3 y2 ff14e fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff15a fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff15a fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ff15a fs3 fc2 sc0 ls1d wsb">16 </div><div class="t m0 x3 h8 y20 ff15a fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff15a fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff15a fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff15a fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff15a fs3 fc2 sc0 ls1d wsb">20 </div><div class="t m0 x3 h8 y25 ff15a fs3 fc2 sc0 ls1d wsb">21 </div><div class="t m0 x3 h8 y26 ff15a fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff15a fs3 fc2 sc0 ls1d wsf">23 </div><div class="t m0 x3 h8 ya7a ff15a fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff15a fs3 fc2 sc0 ls1d wsf">25 </div><div class="t m0 x0 hb y79 ff156 fs6 fc0 sc0 ls21 wsb">var filesList = document.getElementById(&quot;files-list&quot;); </div><div class="t m0 x0 hb y7a ff156 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(filesList, &quot;change&quot;, function(event){ </div><div class="t m0 x0 hb y7b ff156 fs6 fc0 sc0 ls21 wsb">    var info = &quot;&quot;,  </div><div class="t m0 x0 hb y7c ff156 fs6 fc0 sc0 ls21 wsb">        output = document.getElementById(&quot;output&quot;), </div><div class="t m0 x0 hb y7d ff156 fs6 fc0 sc0 ls21 wsb">        progress = document.getElementById(&quot;progress&quot;), </div><div class="t m0 x0 hb y7e ff156 fs6 fc0 sc0 ls21 wsb">        files = EventUtil.getTarget(event).files, </div><div class="t m0 x0 hb y7f ff156 fs6 fc0 sc0 ls21 wsb">        type = &quot;default&quot;, </div><div class="t m0 x0 hb y80 ff156 fs6 fc0 sc0 ls21 wsb">        reader = new FileReader(); </div><div class="t m0 x0 hb y4aac ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4aad ff156 fs6 fc0 sc0 ls21 wsb">    if (/image/.test(files[0].type)){ </div><div class="t m0 x0 hb y4aae ff156 fs6 fc0 sc0 ls21 wsb">        reader.readAsDataURL(files[0]); </div><div class="t m0 x0 hb y4aaf ff156 fs6 fc0 sc0 ls21 wsb">        type = &quot;image&quot;; </div><div class="t m0 x0 hb y4ab0 ff156 fs6 fc0 sc0 ls21 wsb">    } else { </div><div class="t m0 x0 hb y4ab1 ff156 fs6 fc0 sc0 ls21 wsb">        reader.readAsText(files[0]); </div><div class="t m0 x0 hb y4ab2 ff156 fs6 fc0 sc0 ls21 wsb">        type = &quot;text&quot;; </div><div class="t m0 x0 hb y4ab3 ff156 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y4ab4 ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4ab5 ff156 fs6 fc0 sc0 ls21 wsb">    reader.onerror = function(){ </div><div class="t m0 x0 hb y4ab6 ff156 fs6 fc0 sc0 ls21 wsb">        output.innerHTML = &quot;Could not read file, error code is &quot; + </div><div class="t m0 x0 hb y4ab7 ff156 fs6 fc0 sc0 ls21 wsb">                            reader.error.code; </div><div class="t m0 x0 hb y4ab8 ff156 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 hb y4ab9 ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4aba ff156 fs6 fc0 sc0 ls21 wsb">    reader.onprogress = function(event){ </div><div class="t m0 x0 hb y4abb ff156 fs6 fc0 sc0 ls21 wsb">        if (event.lengthComputable){ </div><div class="t m0 x0 hb y4abc ff156 fs6 fc0 sc0 ls21 wsb">            progress.innerHTML = event.loaded + &quot;/&quot; + event.total; </div><div class="t m0 x0 hb y4abd ff156 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y4abe ff156 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 hb y4abf ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4ac0 ff156 fs6 fc0 sc0 ls21 wsb">    reader.onload = function(){ </div><div class="t m0 x0 hb y4ac1 ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4ac2 ff156 fs6 fc0 sc0 ls21 wsb">        var html = &quot;&quot;; </div><div class="t m0 x0 hb y4ac3 ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4ac4 ff156 fs6 fc0 sc0 ls21 wsb">        switch(type){ </div><div class="t m0 x0 hb y4ac5 ff156 fs6 fc0 sc0 ls21 wsb">            case &quot;image&quot;: </div><div class="t m0 x0 hb y4ac6 ff156 fs6 fc0 sc0 ls21 wsb">                html = &quot;&lt;img src=\&quot;&quot; + reader.result + &quot;\&quot;&gt;&quot;; </div><div class="t m0 x0 hb y4ac7 ff156 fs6 fc0 sc0 ls21 wsb">                break; </div><div class="t m0 x0 hb y4ac8 ff156 fs6 fc0 sc0 ls21 wsb">            case &quot;text&quot;: </div><div class="t m0 x0 hb y4ac9 ff156 fs6 fc0 sc0 ls21 wsb">                html = reader.result; </div><div class="t m0 x0 hb y4aca ff156 fs6 fc0 sc0 ls21 wsb">                break; </div><div class="t m0 x0 hb y4acb ff156 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y4acc ff156 fs6 fc0 sc0 ls21 wsb">        output.innerHTML = html; </div><div class="t m0 x0 hb y4acd ff156 fs6 fc0 sc0 ls21 wsb">    }; </div><div class="t m0 x0 hb y4ace ff156 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 hb y4acf ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y4ad0 ff15b fs2 fc0 sc0 ls94 wsb">FileAPIExample02.htm </div><div class="t m0 x0 h5 y4ad1 ff154 fs2 fc0 sc0 ls8 wseb">这个例子读取了表单字段中选择的文件，并将其内容显示在了页面中。如果文件有MIMI类型，表</div><div class="t m0 x0 hc y207d ff154 fs2 fc0 sc0 ls8 wseb">示文件是图像，因此在load事件中就把它保存为数据URI，并在页面中将这幅图像显示出来。如果文</div><div class="t m0 x0 h4 y207e ff154 fs2 fc0 sc0 ls19">件不是图像，则以字符串形式读取文件内容，然后如实在页面中显示读取到的内容。这里使用了</div><div class="t m0 x0 h5 y207f ff156 fs1 fc0 sc0 ls9 ws2">progress事件来跟踪读取了多少字节的数据，而error事件则用于监控发生的错误。 </div><div class="t m0 x0 h1e y2080 ff154 fs2 fc0 sc0 ls8 wseb">如果想中断读取过程，可以调用abort()方法，这样就会触发abort事件。在触发load、error</div><div class="t m0 x0 h4 y4ad2 ff154 fs2 fc0 sc0 ls2c">或abort事件后，会触发另一个事件loadend。loadend事件发生就意味着已经读取完整个文件，或</div><div class="t m0 x0 h5 y3a1 ff154 fs2 fc0 sc0 ls8 wseb">者读取时发生了错误，或者读取过程被中断。 </div><div class="t m0 x0 hc y4ad3 ff154 fs2 fc0 sc0 ls8 wseb">实现File API的所有浏览器都支持readAsText()和readAsDataURL()方法。但IE10 PR 2并未</div><div class="t m0 x0 hc y13b5 ff154 fs2 fc0 sc0 ls8 wseb">实现readAsBinaryString()和readAsArrayBuffer()方法。 </div></div></div>
<div id="pf2c6" class="pf w0 h0" data-page-no="2c6"><div class="pc pc2c6 w0 h0"><div class="t m0 x0 h2 y1 ff14e fs0 fc0 sc0 ls7 ws0">692  第25章 新兴的API </div><div class="t m0 x0 h3 y2 ff14e fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h20 y12d ff152 fs3 fc0 sc0 ls248 ws214">25.4.2 读取部分内容 </div><div class="t m0 x0 h4 y12e ff154 fs2 fc0 sc0 ls8 wseb">有时候，我们只想读取文件的一部分而不是全部内容。为此，File对象还支持一个slice()方法，</div><div class="t m0 x0 h5 y12f ff154 fs2 fc0 sc0 ls8 wseb">这个方法在Firefox中的实现叫mozSlice()，在Chrome中的实现叫 webkitSlice()，Safari的5.1及</div><div class="t m0 x0 h1e y130 ff154 fs2 fc0 sc0 ls8 wseb">之前版本不支持这个方法。slice()方法接收两个参数：起始字节及要读取的字节数。这个方法返回一</div><div class="t m0 x0 h1e y131 ff154 fs2 fc0 sc0 ls4c9">个Blob的实例，Blob是File类型的父类型。下面是一个通用的函数，可以在不同实现中使用slice()</div><div class="t m0 x0 h5 y4ad4 ff154 fs2 fc0 sc0 ls8">方法： </div><div class="t m0 x0 h5 y4ad5 ff14e fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4ad6 ff156 fs6 fc0 sc0 ls21 wsb">function blobSlice(blob, startByte, length){ </div><div class="t m0 x0 hb y4ad7 ff156 fs6 fc0 sc0 ls21 wsb">    if (blob.slice){ </div><div class="t m0 x0 hb y4ad8 ff156 fs6 fc0 sc0 ls21 wsb">        return blob.slice(startByte, length); </div><div class="t m0 x0 hb y4ad9 ff156 fs6 fc0 sc0 ls21 wsb">    } else if (blob.webkitSlice){ </div><div class="t m0 x0 hb y4ada ff156 fs6 fc0 sc0 ls21 wsb">        return blob.webkitSlice(startByte, length); </div><div class="t m0 x0 hb y4adb ff156 fs6 fc0 sc0 ls21 wsb">    } else if (blob.mozSlice){ </div><div class="t m0 x0 hb y4adc ff156 fs6 fc0 sc0 ls21 wsb">        return blob.mozSlice(startByte, length); </div><div class="t m0 x0 hb y4add ff156 fs6 fc0 sc0 ls21 wsb">    } else { </div><div class="t m0 x0 hb y4ade ff156 fs6 fc0 sc0 ls21 wsb">        return null; </div><div class="t m0 x0 hb y4adf ff156 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y4ae0 ff156 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 hb y4ae1 ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y2750 ff15b fs2 fc0 sc0 ls94 wsb">FileAPIExample03.htm </div><div class="t m0 x0 h4 y1f85 ff156 fs1 fc0 sc0 ls9 ws2">Blob类型有一个size属性和一个 type属性，而且它也支持slice()方法，以便进一步切割数</div><div class="t m0 x0 hc y4ae2 ff154 fs2 fc0 sc0 ls8 wseb">据。通过FileReader也可以从Blob中读取数据。下面这个例子只读取文件的 32B内容。 </div><div class="t m0 x0 hb y3515 ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4ae3 ff156 fs6 fc0 sc0 ls21 wsb">var filesList = document.getElementById(&quot;files-list&quot;); </div><div class="t m0 x0 hb y4ae4 ff156 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(filesList, &quot;change&quot;, function(event){ </div><div class="t m0 x0 hb y4ae5 ff156 fs6 fc0 sc0 ls21 wsb">    var info = &quot;&quot;, </div><div class="t m0 x0 hb y4ae6 ff156 fs6 fc0 sc0 ls21 wsb">        output = document.getElementById(&quot;output&quot;), </div><div class="t m0 x0 hb y4ae7 ff156 fs6 fc0 sc0 ls21 wsb">        progress = document.getElementById(&quot;progress&quot;), </div><div class="t m0 x0 hb y4ae8 ff156 fs6 fc0 sc0 ls21 wsb">        files = EventUtil.getTarget(event).files, </div><div class="t m0 x0 hb y4ae9 ff156 fs6 fc0 sc0 ls21 wsb">        reader = new FileReader(), </div><div class="t m0 x0 hb y4aea ff156 fs6 fc0 sc0 ls21 wsb">        blob = blobSlice(files[0], 0, 32); </div><div class="t m0 x0 hb y4aeb ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4aec ff156 fs6 fc0 sc0 ls21 wsb">    if (blob){ </div><div class="t m0 x0 hb y4aed ff156 fs6 fc0 sc0 ls21 wsb">        reader.readAsText(blob); </div><div class="t m0 x0 hb y4aee ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4aef ff156 fs6 fc0 sc0 ls21 wsb">        reader.onerror = function(){ </div><div class="t m0 x0 hb y4af0 ff156 fs6 fc0 sc0 ls21 wsb">            output.innerHTML = &quot;Could not read file, error code is &quot; + </div><div class="t m0 x0 hb y4af1 ff156 fs6 fc0 sc0 ls21 wsb">                                reader.error.code; </div><div class="t m0 x0 hb y4af2 ff156 fs6 fc0 sc0 ls21 wsb">        }; </div><div class="t m0 x0 hb y4af3 ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4af4 ff156 fs6 fc0 sc0 ls21 wsb">        reader.onload = function(){ </div><div class="t m0 x0 hb y4af5 ff156 fs6 fc0 sc0 ls21 wsb">            output.innerHTML = reader.result; </div><div class="t m0 x0 hb y4af6 ff156 fs6 fc0 sc0 ls21 wsb">        }; </div><div class="t m0 x0 hb y4af7 ff156 fs6 fc0 sc0 ls21 wsb">    } else { </div><div class="t m0 x0 hb y4af8 ff156 fs6 fc0 sc0 ls21 wsb">        alert(&quot;Your browser doesn&apos; t support slice().&quot;); </div><div class="t m0 x0 hb y4af9 ff156 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y4afa ff156 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 hb y4afb ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y4afc ff15b fs2 fc0 sc0 ls94 wsb">FileAPIExample03.htm </div><div class="t m0 x0 h5 ya80 ff154 fs2 fc0 sc0 ls8 wseb">只读取文件的一部分可以节省时间，非常适合只关注数据中某个特定部分（如文件头部）的情况。 </div></div></div>
<div id="pf2c7" class="pf w0 h0" data-page-no="2c7"><div class="pc pc2c7 w0 h0"><div class="t m0 x2 h2 y1db2 ff14e fs0 fc0 sc0 ls7 ws0">25.4 File API  693 </div><div class="t m0 x0 h3 y2 ff14e fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff15a fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff15a fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ff15a fs3 fc2 sc0 ls1d wsb">16 </div><div class="t m0 x3 h8 y20 ff15a fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff15a fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff15a fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff15a fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff15a fs3 fc2 sc0 ls1d wsb">20 </div><div class="t m0 x3 h8 y25 ff15a fs3 fc2 sc0 ls1d wsb">21 </div><div class="t m0 x3 h8 y26 ff15a fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff15a fs3 fc2 sc0 ls1d wsf">23 </div><div class="t m0 x3 h8 ya7a ff15a fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff15a fs3 fc2 sc0 ls1d wsf">25 </div><div class="t m0 x0 h20 y12d ff152 fs3 fc0 sc0 ls248 ws214">25.4.3 对象URL </div><div class="t m0 x0 h5 y12e ff154 fs2 fc0 sc0 ls8 wseb">对象URL也被称为blob URL，指的是引用保存在File或Blob 中数据的URL。使用对象URL的</div><div class="t m0 x0 h5 y12f ff154 fs2 fc0 sc0 ls8 wseb">好处是可以不必把文件内容读取到JavaScript中而直接使用文件内容。为此，只要在需要文件内容的地</div><div class="t m0 x0 h5 y130 ff154 fs2 fc0 sc0 ls8 wseb">方提供对象URL即可。要创建对象URL，可以使用window.URL.createObjectURL()方法，并传入</div><div class="t m0 x0 h5 y1c95 ff156 fs1 fc0 sc0 ls9 ws2">File或Blob对象。这个方法在Chrome中的实现叫 window.webkitURL.createObjectURL()，因</div><div class="t m0 x0 h5 y1c96 ff154 fs2 fc0 sc0 ls8 wseb">此可以通过如下函数来消除命名的差异： </div><div class="t m0 x0 hb y4afd ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4afe ff156 fs6 fc0 sc0 ls21 wsb">function createObjectURL(blob){ </div><div class="t m0 x0 hb y4aff ff156 fs6 fc0 sc0 ls21 wsb">    if (window.URL){ </div><div class="t m0 x0 hb y4b00 ff156 fs6 fc0 sc0 ls21 wsb">        return window.URL.createObjectURL(blob); </div><div class="t m0 x0 hb y4b01 ff156 fs6 fc0 sc0 ls21 wsb">    } else if (window.webkitURL){ </div><div class="t m0 x0 hb y4b02 ff156 fs6 fc0 sc0 ls21 wsb">        return window.webkitURL.createObjectURL(blob); </div><div class="t m0 x0 hb y4b03 ff156 fs6 fc0 sc0 ls21 wsb">    } else { </div><div class="t m0 x0 hb y4b04 ff156 fs6 fc0 sc0 ls21 wsb">        return null; </div><div class="t m0 x0 hb y4b05 ff156 fs6 fc0 sc0 ls21 wsb">    }  </div><div class="t m0 x0 hb y4b06 ff156 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y4b07 ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y2ebd ff15b fs2 fc0 sc0 ls94 wsb">FileAPIExample04.htm </div><div class="t m0 x0 h5 y4b08 ff154 fs2 fc0 sc0 ls8 wseb">这个函数的返回值是一个字符串，指向一块内存的地址。因为这个字符串是URL，所以在DOM中</div><div class="t m0 x0 h5 y3ec1 ff154 fs2 fc0 sc0 ls8 wseb">也能使用。例如，以下代码可以在页面中显示一个图像文件： </div><div class="t m0 x0 hb y4b09 ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4b0a ff156 fs6 fc0 sc0 ls21 wsb">var filesList = document.getElementById(&quot;files-list&quot;); </div><div class="t m0 x0 hb y4b0b ff156 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(filesList, &quot;change&quot;, function(event){ </div><div class="t m0 x0 hb y4b0c ff156 fs6 fc0 sc0 ls21 wsb">    var info = &quot;&quot;,  </div><div class="t m0 x0 hb y4b0d ff156 fs6 fc0 sc0 ls21 wsb">        output = document.getElementById(&quot;output&quot;), </div><div class="t m0 x0 hb y4b0e ff156 fs6 fc0 sc0 ls21 wsb">        progress = document.getElementById(&quot;progress&quot;), </div><div class="t m0 x0 hb y4b0f ff156 fs6 fc0 sc0 ls21 wsb">        files = EventUtil.getTarget(event).files, </div><div class="t m0 x0 hb y4b10 ff156 fs6 fc0 sc0 ls21 wsb">        reader = new FileReader(), </div><div class="t m0 x0 hb y4b11 ff156 fs6 fc0 sc0 ls21 wsb">        url = createObjectURL(files[0]); </div><div class="t m0 x0 hb y4b12 ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4b13 ff156 fs6 fc0 sc0 ls21 wsb">    if (url){ </div><div class="t m0 x0 hb y4b14 ff156 fs6 fc0 sc0 ls21 wsb">        if (/image/.test(files[0].type)){ </div><div class="t m0 x0 hb y4b15 ff156 fs6 fc0 sc0 ls21 wsb">            output.innerHTML = &quot;&lt;img src=\&quot;&quot; + url + &quot;\&quot;&gt;&quot;; </div><div class="t m0 x0 hb y4b16 ff156 fs6 fc0 sc0 ls21 wsb">        } else { </div><div class="t m0 x0 hb y4b17 ff156 fs6 fc0 sc0 ls21 wsb">            output.innerHTML = &quot;Not an image.&quot;; </div><div class="t m0 x0 hb y4b18 ff156 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y4b19 ff156 fs6 fc0 sc0 ls21 wsb">    } else { </div><div class="t m0 x0 hb y4b1a ff156 fs6 fc0 sc0 ls21 wsb">        output.innerHTML = &quot;Your browser doesn&apos;t support object URLs.&quot;; </div><div class="t m0 x0 hb y4b1b ff156 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y4b1c ff156 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x2 hf y3847 ff15b fs2 fc0 sc0 ls94 wsb">FileAPIExample04.htm </div><div class="t m0 x0 h5 y234 ff154 fs2 fc0 sc0 ls8 wseb">直接把对象URL放在&lt;img&gt;标签中，就省去了把数据先读到JavaScript中的麻烦。另一方面，&lt;img&gt;</div><div class="t m0 x0 h5 y2c4e ff154 fs2 fc0 sc0 ls8 wseb">标签则会找到相应的内存地址，直接读取数据并将图像显示在页面中。 </div><div class="t m0 x0 h5 y2c4f ff154 fs2 fc0 sc0 ls8 wseb">如果不再需要相应的数据，最好释放它占用的内容。但只要有代码在引用对象URL，内存就不会释</div><div class="t m0 x0 he y4b1d ff154 fs2 fc0 sc0 ls5 wsec">放。要手工释放内存，可以把对象URL传给 window.URL.revokeOjbectURL()（在Chrome中是</div><div class="t m0 x0 h5 ya7f ff156 fs1 fc0 sc0 ls9 ws2">window.webkitURL.revokeObjectURL()）。要兼容这两种方法的实现，可以使用以下函数： </div><div class="t m0 x0 hb y4b1e ff156 fs6 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf2c8" class="pf w0 h0" data-page-no="2c8"><div class="pc pc2c8 w0 h0"><div class="t m0 x0 h2 y1 ff14e fs0 fc0 sc0 ls7 ws0">694  第25章 新兴的API </div><div class="t m0 x0 h3 y2 ff14e fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 ff156 fs6 fc0 sc0 ls21 wsb">function revokeObjectURL(url){ </div><div class="t m0 x0 hb y7a ff156 fs6 fc0 sc0 ls21 wsb">    if (window.URL){  </div><div class="t m0 x0 hb y7b ff156 fs6 fc0 sc0 ls21 wsb">        window.URL.revokeObjectURL(url); </div><div class="t m0 x0 hb y7c ff156 fs6 fc0 sc0 ls21 wsb">    } else if (window.webkitURL){ </div><div class="t m0 x0 hb y7d ff156 fs6 fc0 sc0 ls21 wsb">        window.webkitURL.revokeObjectURL(url); </div><div class="t m0 x0 hb y7e ff156 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y7f ff156 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y80 ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1d3d ff154 fs2 fc0 sc0 ls8 wseb">页面卸载时会自动释放对象URL占用的内存。不过，为了确保尽可能少地占用内存，最好在不需</div><div class="t m0 x0 h5 y1d3e ff154 fs2 fc0 sc0 ls8 wseb">要某个对象URL时，就马上手工释放其占用的内存。 </div><div class="t m0 x0 h5 y4b20 ff154 fs2 fc0 sc0 ls8 wseb">支持对象URL的浏览器有IE10+、Firefox 4和Chrome。 </div><div class="t m0 x0 h20 y4b21 ff152 fs3 fc0 sc0 ls248 ws214">25.4.4 读取拖放的文件 </div><div class="t m0 x0 h5 y20cd ff154 fs2 fc0 sc0 ls1f ws108">围绕读取文件信息，结合使用HTML5拖放API和文件API，能够创造出令人瞩目的用户界面：在页</div><div class="t m0 x0 h4 y4b22 ff154 fs2 fc0 sc0 ls4cb ws2aa">面上创建了自定义的放置目标之后，你可以从桌面上把文件拖放到该目标。与拖放一张图片或者一个链接</div><div class="t m0 x0 h1e y136d ff154 fs2 fc0 sc0 ls4cb ws2aa">类似，从桌面上把文件拖放到浏览器中也会触发drop事件。而且可以在event.dataTransfer. files</div><div class="t m0 x0 h5 y4632 ff154 fs2 fc0 sc0 ls1f ws108">中读取到被放置的文件，当然此时它是一个File对象，与通过文件输入字段取得的File对象一样。 </div><div class="t m0 x0 h5 y4633 ff154 fs2 fc0 sc0 ls8 wseb">下面这个例子会将放置到页面中自定义的放置目标中的文件信息显示出来： </div><div class="t m0 x0 hb y4b23 ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4b24 ff156 fs6 fc0 sc0 ls21 wsb">var droptarget = document.getElementById( &quot;droptarget&quot;); </div><div class="t m0 x0 hb y4b25 ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4b26 ff156 fs6 fc0 sc0 ls21 wsb">function handleEvent(event){ </div><div class="t m0 x0 hb y4b27 ff156 fs6 fc0 sc0 ls21 wsb">    var info = &quot;&quot;, </div><div class="t m0 x0 hb y4b28 ff156 fs6 fc0 sc0 ls21 wsb">        output = document.getElementById(&quot;output&quot;), </div><div class="t m0 x0 hb y4b29 ff156 fs6 fc0 sc0 ls21 wsb">        files, i, len; </div><div class="t m0 x0 hb y4b2a ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4b2b ff156 fs6 fc0 sc0 ls21 wsb">    EventUtil.preventDefault(event); </div><div class="t m0 x0 hb y4b2c ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4b2d ff156 fs6 fc0 sc0 ls21 wsb">    if (event.type == &quot;drop&quot;){ </div><div class="t m0 x0 hb y4b2e ff156 fs6 fc0 sc0 ls21 wsb">        files = event.dataTransfer.files; </div><div class="t m0 x0 hb y4b2f ff156 fs6 fc0 sc0 ls21 wsb">        i = 0; </div><div class="t m0 x0 hb y4b30 ff156 fs6 fc0 sc0 ls21 wsb">        len = files.length; </div><div class="t m0 x0 hb y4b31 ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4b32 ff156 fs6 fc0 sc0 ls21 wsb">        while (i &lt; len){ </div><div class="t m0 x0 hb y4b33 ff156 fs6 fc0 sc0 ls21 wsb">            info += files[i].name + &quot; (&quot; + files[i].type + &quot;, &quot; + files[i].size + </div><div class="t m0 x0 hb y4b34 ff156 fs6 fc0 sc0 ls21 wsb">                   &quot; bytes)&lt;br&gt;&quot;; </div><div class="t m0 x0 hb y4b35 ff156 fs6 fc0 sc0 ls21 wsb">            i++; </div><div class="t m0 x0 hb y4b36 ff156 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y4b37 ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4b38 ff156 fs6 fc0 sc0 ls21 wsb">        output.innerHTML = info; </div><div class="t m0 x0 hb y4b39 ff156 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y4b3a ff156 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y4b3b ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4b3c ff156 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(droptarget, &quot;dragenter&quot;, handleEvent); </div><div class="t m0 x0 hb y4b3d ff156 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(droptarget, &quot;dragover&quot;, handleEvent); </div><div class="t m0 x0 hb y4b3e ff156 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(droptarget, &quot;drop&quot;, handleEvent); </div><div class="t m0 x2 hf y4b3f ff15b fs2 fc0 sc0 ls94 wsb">FileAPIExample05.htm </div><div class="t m0 x0 h4 y7f0 ff154 fs2 fc0 sc0 ls8 wseb">与之前展示的拖放示例一样，这里也必须取消dragenter、dragover和drop 的默认行为。在</div><div class="t m0 x0 h4 y15b ff156 fs1 fc0 sc0 ls9 ws2">drop事件中，可以通过event.dataTransfer.files读取文件信息。还有一种利用这个功能的流行</div><div class="t m0 x0 hc y2762 ff154 fs2 fc0 sc0 ls8 wseb">做法，即结合XMLHttpRequest和拖放文件来实现上传。 </div></div></div>
<div id="pf2c9" class="pf w0 h0" data-page-no="2c9"><div class="pc pc2c9 w0 h0"><div class="t m0 x2 h2 y1db2 ff14e fs0 fc0 sc0 ls7 ws0">25.4 File API  695 </div><div class="t m0 x0 h3 y2 ff14e fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff15a fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff15a fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ff15a fs3 fc2 sc0 ls1d wsb">16 </div><div class="t m0 x3 h8 y20 ff15a fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff15a fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff15a fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff15a fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff15a fs3 fc2 sc0 ls1d wsb">20 </div><div class="t m0 x3 h8 y25 ff15a fs3 fc2 sc0 ls1d wsb">21 </div><div class="t m0 x3 h8 y26 ff15a fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff15a fs3 fc2 sc0 ls1d wsf">23 </div><div class="t m0 x3 h8 ya7a ff15a fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff15a fs3 fc2 sc0 ls1d wsf">25 </div><div class="t m0 x0 h20 y12d ff152 fs3 fc0 sc0 ls248 ws214">25.4.5 使用XHR上传文件 </div><div class="t m0 x0 h5 y12e ff154 fs2 fc0 sc0 ls8 wseb">通过File API能够访问到文件内容，利用这一点就可以通过XHR直接把文件上传到服务器。当然</div><div class="t m0 x0 h5 y12f ff154 fs2 fc0 sc0 ls8 wseb">啦，把文件内容放到send()方法中，再通过POST请求，的确很容易就能实现上传。但这样做传递的</div><div class="t m0 x0 h4 y130 ff154 fs2 fc0 sc0 ls8 wseb">是文件内容，因而服务器端必须收集提交的内容，然后再把它们保存到另一个文件中。其实，更好的做</div><div class="t m0 x0 h5 yc0a ff154 fs2 fc0 sc0 ls8 wseb">法是以表单提交的方式来上传文件。 </div><div class="t m0 x0 h14 y14bc ff154 fs2 fc0 sc0 ls8 wseb">这样使用FormData类型就很容易做到了（第21章介绍过FormData）。首先，要创建一个FormData</div><div class="t m0 x0 h4 y11f9 ff154 fs2 fc0 sc0 ls8 wseb">对象，通过它调用append()方法并传入相应的File对象作为参数。然后，再把FormData 对象传递</div><div class="t m0 x0 hc y4a07 ff154 fs2 fc0 sc0 ls3b">给XHR的send()方法，结果与通过表单上传一模一样。 </div><div class="t m0 x0 hb y4b40 ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4b41 ff156 fs6 fc0 sc0 ls21 wsb">var droptarget = document.getElementById(&quot;droptarget&quot;); </div><div class="t m0 x0 hb y4b42 ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4b43 ff156 fs6 fc0 sc0 ls21 wsb">function handleEvent(event){ </div><div class="t m0 x0 hb y4b44 ff156 fs6 fc0 sc0 ls21 wsb">    var info = &quot;&quot;, </div><div class="t m0 x0 hb y4b45 ff156 fs6 fc0 sc0 ls21 wsb">        output = document.getElementById(&quot;output&quot;), </div><div class="t m0 x0 hb y4b46 ff156 fs6 fc0 sc0 ls21 wsb">        data, xhr, </div><div class="t m0 x0 hb y4b47 ff156 fs6 fc0 sc0 ls21 wsb">        files, i, len; </div><div class="t m0 x0 hb y4b48 ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4b49 ff156 fs6 fc0 sc0 ls21 wsb">    EventUtil.preventDefault(event); </div><div class="t m0 x0 hb y4b4a ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4b4b ff156 fs6 fc0 sc0 ls21 wsb">    if (event.type == &quot;drop&quot;){ </div><div class="t m0 x0 hb y4b4c ff156 fs6 fc0 sc0 ls21 wsb">        data = new FormData(); </div><div class="t m0 x0 hb y4b4d ff156 fs6 fc0 sc0 ls21 wsb">        files = event.dataTransfer.files; </div><div class="t m0 x0 hb y4b4e ff156 fs6 fc0 sc0 ls21 wsb">        i = 0; </div><div class="t m0 x0 hb y4b4f ff156 fs6 fc0 sc0 ls21 wsb">        len = files.length; </div><div class="t m0 x0 hb y4b50 ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4b51 ff156 fs6 fc0 sc0 ls21 wsb">        while (i &lt; len){ </div><div class="t m0 x0 hb y4b52 ff156 fs6 fc0 sc0 ls21 wsb">            data.append(&quot;file&quot; + i, files[i]); </div><div class="t m0 x0 hb y4b53 ff156 fs6 fc0 sc0 ls21 wsb">            i++; </div><div class="t m0 x0 hb y4b54 ff156 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y4b55 ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4b56 ff156 fs6 fc0 sc0 ls21 wsb">        xhr = new XMLHttpRequest(); </div><div class="t m0 x0 hb y4b57 ff156 fs6 fc0 sc0 ls21 wsb">        xhr.open(&quot;post&quot;, &quot;FileAPIExample06Upload.php&quot;, true); </div><div class="t m0 x0 hb y4b58 ff156 fs6 fc0 sc0 ls21 wsb">        xhr.onreadystatechange = function(){ </div><div class="t m0 x0 hb y4b59 ff156 fs6 fc0 sc0 ls21 wsb">            if (xhr.readyState == 4){ </div><div class="t m0 x0 hb y4b5a ff156 fs6 fc0 sc0 ls21 wsb">                alert(xhr.responseText); </div><div class="t m0 x0 hb y4b5b ff156 fs6 fc0 sc0 ls21 wsb">            } </div><div class="t m0 x0 hb y4b5c ff156 fs6 fc0 sc0 ls21 wsb">        }; </div><div class="t m0 x0 hb y4b5d ff156 fs6 fc0 sc0 ls21 wsb">        xhr.send(data); </div><div class="t m0 x0 hb y4b5e ff156 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y4b5f ff156 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y4b60 ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4b61 ff156 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(droptarget, &quot;dragenter&quot;, handleEvent); </div><div class="t m0 x0 hb y4b62 ff156 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(droptarget, &quot;dragover&quot;, handleEvent); </div><div class="t m0 x0 hb y4b63 ff156 fs6 fc0 sc0 ls21 wsb">EventUtil.addHandler(droptarget, &quot;drop&quot;, handleEvent); </div><div class="t m0 x0 hb y4b64 ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y8ef ff15b fs2 fc0 sc0 ls94 wsb">FileAPIExample06.htm </div><div class="t m0 x0 h4 y3a91 ff154 fs2 fc0 sc0 ls8 wseb">这个例子创建一个FormData对象，与每个文件对应的键分别是file0、file1、file2这样的格</div><div class="t m0 x0 h1e y4b65 ff154 fs2 fc0 sc0 ls8 wseb">式。注意，不用额外写任何代码，这些文件就可以作为表单的值提交。而且，也不必使用FileReader，</div><div class="t m0 x0 hc y4b66 ff154 fs2 fc0 sc0 ls8 wseb">只要传入File对象即可。 </div></div></div>
<div id="pf2ca" class="pf w0 h0" data-page-no="2ca"><div class="pc pc2ca w0 h0"><div class="t m0 x0 h2 y1 ff14e fs0 fc0 sc0 ls7 ws0">696  第25章 新兴的API </div><div class="t m0 x0 h3 y2 ff14e fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ff154 fs2 fc0 sc0 ls8 wseb">使用FormData上传文件，在服务器端就好像是接收到了常规的表单数据一样，一切按部就班地处</div><div class="t m0 x0 h5 y4d ff154 fs2 fc0 sc0 ls8 wseb">理即可。换句话说，如果服务器端使用的是PHP，那么$_FILES数组中就会保存着上传的文件。支持</div><div class="t m0 x0 h5 y5 ff154 fs2 fc0 sc0 ls8 wseb">以这种方式上传文件的浏览器有Firefox 4+、Safari 5+和Chrome。 </div><div class="t m0 x0 hd y219 ff152 fs7 fc0 sc0 ls245">25.5 Web计时 </div><div class="t m0 x0 h5 y128b ff154 fs2 fc0 sc0 ls8 wseb">页面性能一直都是Web开发人员最关注的领域。但直到最近，度量页面性能指标的唯一方式，就</div><div class="t m0 x0 hc y128c ff154 fs2 fc0 sc0 ls8 wseb">是提高代码复杂程度和巧妙地使用JavaScript的Date对象。Web Timing API改变了这个局面，让开发</div><div class="t m0 x0 h5 y8c9 ff154 fs2 fc0 sc0 ls8 wseb">人员通过JavaScript就能使用浏览器内部的度量结果，通过直接读取这些信息可以做任何想做的分析。</div><div class="t m0 x0 h5 y25d7 ff154 fs2 fc0 sc0 ls8 wseb">与本章介绍过的其他API不同，Web Timing API实际上已经成为了W3C的建议标准，只不过目前支持</div><div class="t m0 x0 h5 y25d8 ff154 fs2 fc0 sc0 ls8 wseb">它的浏览器还不够多。 </div><div class="t m0 x0 h5 y4b67 ff14e fs2 fc0 sc0 lsfd wscc">Web计时机制的核心是window.performance对象。对页面的所有度量信息，包括那些规范中已</div><div class="t m0 x0 h5 y8cd ff154 fs2 fc0 sc0 ls8 wseb">经定义的和将来才能确定的，都包含在这个对象里面。Web Timing规范一开始就为performance对象</div><div class="t m0 x0 h5 y8ce ff154 fs2 fc0 sc0 ls8 wseb">定义了两个属性。 </div><div class="t m0 x0 he y2fae ff154 fs2 fc0 sc0 ls5f ws10b">其中，performance.navigation属性也是一个对象，包含着与页面导航有关的多个属性，如下所示。 </div><div class="t m0 x0 h5 y3c7c ff153 fs1 fc0 sc0 ls2"> redirectCount：页面加载前的重定向次数。 </div><div class="t m0 x0 h5 y46ae ff153 fs1 fc0 sc0 ls2"> type：数值常量，表示刚刚发生的导航类型。 </div><div class="t m0 x0 h5 y74c ff153 fsc fc0 sc0 ls8 ws393"> performance.navigation.TYPE_NAVIGATE (0)：页面第一次加载。 </div><div class="t m0 x0 h5 y8d2 ff153 fsc fc0 sc0 ls8 ws393"> performance.navigation.TYPE_RELOAD (1)：页面重载过。 </div><div class="t m0 x0 h4 y4308 ff153 fsc fc0 sc0 ls8 ws393"> performance.navigation.TYPE_BACK_FORWARD (2)：页面是通过“后退”或“前进”按</div><div class="t m0 x0 h5 y4270 ff154 fs2 fc0 sc0 ls42 wsf0">钮打开的。 </div><div class="t m0 x0 h1e y4b68 ff154 fs2 fc0 sc0 ls8 wseb">另外，performance.timing属性也是一个对象，但这个对象的属性都是时间戳（从软件纪元开</div><div class="t m0 x0 h5 y8d5 ff154 fs2 fc0 sc0 ls8 wseb">始经过的毫秒数），不同的事件会产生不同的时间值。这些属性如下所示。 </div><div class="t m0 x0 h5 y4b69 ff153 fs1 fc0 sc0 ls2"> navigationStart：开始导航到当前页面的时间。 </div><div class="t m0 x0 h4 yf3a ff153 fs1 fc0 sc0 ls2"> unloadEventStart：前一个页面的unload事件开始的时间。但只有在前一个页面与当前页</div><div class="t m0 x0 h5 y42d0 ff154 fs2 fc0 sc0 ls8 wseb">面来自同一个域时这个属性才会有值；否则，值为0。 </div><div class="t m0 x0 h4 y4b6a ff153 fs1 fc0 sc0 ls2"> unloadEventEnd：前一个页面的unload事件结束的时间。但只有在前一个页面与当前页面</div><div class="t m0 x0 h5 y42d2 ff154 fs2 fc0 sc0 ls8 wseb">来自同一个域时这个属性才会有值；否则，值为0。 </div><div class="t m0 x0 h4 yf3e ff153 fs1 fc0 sc0 ls2"> redirectStart：到当前页面的重定向开始的时间。但只有在重定向的页面来自同一个域时这</div><div class="t m0 x0 h5 y3a30 ff154 fs2 fc0 sc0 ls8 wseb">个属性才会有值；否则，值为0。 </div><div class="t m0 x0 h4 y4b6b ff153 fs1 fc0 sc0 ls2"> redirectEnd：到当前页面的重定向结束的时间。但只有在重定向的页面来自同一个域时这个</div><div class="t m0 x0 h5 y4b6c ff154 fs2 fc0 sc0 ls8 wseb">属性才会有值；否则，值为0。 </div><div class="t m0 x0 h5 y4b6d ff153 fs1 fc0 sc0 ls2"> fetchStart：开始通过HTTP GET取得页面的时间。 </div><div class="t m0 x0 h5 y3b7f ff153 fs1 fc0 sc0 ls2"> domainLookupStart：开始查询当前页面DNS的时间。 </div><div class="t m0 x0 h5 y4b6e ff153 fs1 fc0 sc0 ls2"> domainLookupEnd：查询当前页面DNS结束的时间。 </div><div class="t m0 x0 h5 y4b6f ff153 fs1 fc0 sc0 ls2"> connectStart：浏览器尝试连接服务器的时间。 </div><div class="t m0 x0 h5 y4b70 ff153 fs1 fc0 sc0 ls2"> connectEnd：浏览器成功连接到服务器的时间。 </div><div class="t m0 x0 h5 y4b71 ff153 fs1 fc0 sc0 ls2"> secureConnectionStart：浏览器尝试以SSL方式连接服务器的时间。不使用SSL方式连接</div><div class="t m0 x0 h5 y2c12 ff154 fs2 fc0 sc0 ls8 wseb">时，这个属性的值为0。 </div></div></div>
<div id="pf2cb" class="pf w0 h0" data-page-no="2cb"><div class="pc pc2cb w0 h0"><div class="t m0 x2 h2 y1db2 ff14e fs0 fc0 sc0 ls7 ws0">25.6 Web Workers  697 </div><div class="t m0 x0 h3 y2 ff14e fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff15a fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff15a fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ff15a fs3 fc2 sc0 ls1d wsb">16 </div><div class="t m0 x3 h8 y20 ff15a fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff15a fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff15a fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff15a fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff15a fs3 fc2 sc0 ls1d wsb">20 </div><div class="t m0 x3 h8 y25 ff15a fs3 fc2 sc0 ls1d wsb">21 </div><div class="t m0 x3 h8 y26 ff15a fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff15a fs3 fc2 sc0 ls1d wsf">23 </div><div class="t m0 x3 h8 ya7a ff15a fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff15a fs3 fc2 sc0 ls1d wsf">25 </div><div class="t m0 x0 h5 y3 ff153 fs1 fc0 sc0 ls2"> requestStart：浏览器开始请求页面的时间。 </div><div class="t m0 x0 h5 y4 ff153 fs1 fc0 sc0 ls2"> responseStart：浏览器接收到页面第一字节的时间。 </div><div class="t m0 x0 h5 y4e ff153 fs1 fc0 sc0 ls2"> responseEnd：浏览器接收到页面所有内容的时间。 </div><div class="t m0 x0 h5 yd9 ff153 fs1 fc0 sc0 ls2"> domLoading：document.readyState变为&quot;loading&quot;的时间。 </div><div class="t m0 x0 h5 y219 ff153 fs1 fc0 sc0 ls2"> domInteractive：document.readyState变为&quot;interactive&quot;的时间。 </div><div class="t m0 x0 h5 y8 ff153 fs1 fc0 sc0 ls2"> domContentLoadedEventStart：发生DOMContentLoaded事件的时间。 </div><div class="t m0 x0 h4 y9 ff153 fs1 fc0 sc0 ls2"> domContentLoadedEventEnd：DOMContentLoaded事件已经发生且执行完所有事件处理程</div><div class="t m0 x5 h5 y15f ff154 fs2 fc0 sc0 ls8 wseb">序的时间。 </div><div class="t m0 x0 h5 yb ff153 fs1 fc0 sc0 ls2"> domComplete：document.readyState变为&quot;complete&quot;的时间。 </div><div class="t m0 x0 h5 yc ff153 fs1 fc0 sc0 ls2"> loadEventStart：发生load事件的时间。 </div><div class="t m0 x0 h5 yd ff153 fs1 fc0 sc0 ls2"> loadEventEnd：load事件已经发生且执行完所有事件处理程序的时间。 </div><div class="t m0 x0 h4 ye ff154 fs2 fc0 sc0 ls8 wseb">通过这些时间值，就可以全面了解页面在被加载到浏览器的过程中都经历了哪些阶段，而哪些阶段</div><div class="t m0 x0 h5 yf ff154 fs2 fc0 sc0 ls370 ws456">可能是影响性能的瓶颈。给大家推荐一个使用Web Timing API的绝好示例，地址是</div><div class="t m0 x0 h5 y4b72 ff14e fs2 fc0 sc0 ls79 ws6c">http://webtimingdemo.appspot.com/。 </div><div class="t m0 x0 h5 y4b73 ff154 fs2 fc0 sc0 ls8 wseb">支持Web Timing API的浏览器有IE10+和Chrome。 </div><div class="t m0 x0 hd y4b74 ff152 fs7 fc0 sc0 ls245">25.6 Web Workers </div><div class="t m0 x0 h5 y8ab ff154 fs2 fc0 sc0 ls8 wseb">随着Web应用复杂性的与日俱增，越来越复杂的计算在所难免。长时间运行的JavaScript进程会导</div><div class="t m0 x0 h5 y4b75 ff154 fs2 fc0 sc0 ls8 wseb">致浏览器冻结用户界面，让人感觉屏幕“冻结”了。Web Workers规范通过让JavaScript在后台运行解决</div><div class="t m0 x0 h5 y4b76 ff154 fs2 fc0 sc0 ls8 wseb">了这个问题。浏览器实现Web Workers规范的方式有很多种，可以使用线程、后台进程或者运行在其他</div><div class="t m0 x0 h4 y4b77 ff154 fs2 fc0 sc0 ls8 wseb">处理器核心上的进程，等等。具体的实现细节其实没有那么重要，重要的是开发人员现在可以放心地运</div><div class="t m0 x0 h5 y4b78 ff154 fs2 fc0 sc0 ls3b">行JavaScript，而不必担心会影响用户体验了。 </div><div class="t m0 x0 h5 y4b79 ff154 fs2 fc0 sc0 ls8 wseb">目前支持Web Workers的浏览器有IE10+、Firefox 3.5+、Safari 4+、Opera 10.6+、Chrome 和iOS版</div><div class="t m0 x0 h5 y4b7a ff154 fs2 fc0 sc0 ls3b">的Safari。 </div><div class="t m0 x0 h20 y4b7b ff152 fs3 fc0 sc0 ls248 ws214">25.6.1 使用Worker </div><div class="t m0 x0 h5 y49b3 ff154 fs2 fc0 sc0 ls8 wseb">实例化Worker对象并传入要执行的JavaScript文件名就可以创建一个新的 Web Worker。例如： </div><div class="t m0 x0 hb y47e1 ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4b7c ff156 fs6 fc0 sc0 ls21 wsb">var worker = new Worker(&quot;stufftodo.js&quot;); </div><div class="t m0 x0 hb y4b7d ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1f0a ff154 fs2 fc0 sc0 ls8 wseb">这行代码会导致浏览器下载stufftodo.js，但只有Worker 接收到消息才会实际执行文件中的代</div><div class="t m0 x0 hc y1f0b ff154 fs2 fc0 sc0 ls8 wseb">码。要给Worker传递消息，可以使用postMessage()方法（与XDM中的postMessage()方法类似）： </div><div class="t m0 x0 hb yfa ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4b7e ff156 fs6 fc0 sc0 ls21 ws34">worker.postMessage(“start! &quot;); </div><div class="t m0 x0 hb y4b7f ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y4b80 ff154 fs2 fc0 sc0 ls19 wsfb">消息内容可以是任何能够被序列化的值，不过与XDM不同的是，在所有支持的浏览器中，</div><div class="t m0 x0 h5 y4b81 ff156 fs1 fc0 sc0 ls9 ws2">postMessage()都能接收对象参数（Safari 4是支持Web Workers的浏览器中最后一个只支持字符串参</div><div class="t m0 x0 h5 y3537 ff154 fs2 fc0 sc0 ls8 wseb">数的）。因此，可以随便传递任何形式的对象数据，如下面的例子所示： </div><div class="t m0 x0 hb y3109 ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4b82 ff156 fs6 fc0 sc0 ls21 wsb">worker.postMessage({ </div><div class="t m0 x0 hb y4b83 ff156 fs6 fc0 sc0 ls21 wsb">    type: &quot;command&quot;,  </div><div class="t m0 x0 hb y4b84 ff156 fs6 fc0 sc0 ls21 wsb">    message: &quot;start! &quot; </div><div class="t m0 x0 hb y4b85 ff156 fs6 fc0 sc0 ls21 wsb">}); </div></div></div>
<div id="pf2cc" class="pf w0 h0" data-page-no="2cc"><div class="pc pc2cc w0 h0"><div class="t m0 x0 h2 y1 ff14e fs0 fc0 sc0 ls7 ws0">698  第25章 新兴的API </div><div class="t m0 x0 h3 y2 ff14e fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff154 fs2 fc0 sc0 ls8 wseb">一般来说，可以序列化为JSON结构的任何值都可以作为参数传递给postMessage()。换句话说，</div><div class="t m0 x0 h5 y4d ff154 fs2 fc0 sc0 ls8 wseb">这就意味着传入的值是被复制到Worker中，而非直接传过去的（与XDM类似）。 </div><div class="t m0 x0 he yd8 ff14e fs2 fc0 sc0 lsfd wscc">Worker是通过message和error事件与页面通信的。这里的message事件与 XDM中的message</div><div class="t m0 x0 h5 yd9 ff154 fs2 fc0 sc0 ls8 wseb">事件行为相同，来自Worker的数据保存在event.data 中。Worker返回的数据也可以是任何能够被序</div><div class="t m0 x0 h5 y15d ff154 fs2 fc0 sc0 ls8 wseb">列化的值： </div><div class="t m0 x0 hb y4b86 ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4b87 ff156 fs6 fc0 sc0 ls21 wsb">worker.onmessage = function(event){ </div><div class="t m0 x0 hb y4b88 ff156 fs6 fc0 sc0 ls21 wsb">    var data = event.data; </div><div class="t m0 x0 h5 y4b89 ff14e fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y288a ff156 fs6 fc0 sc0 ls21 wsb">    //对数据进行处理 </div><div class="t m0 x0 hb y4b8a ff156 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y4b8b ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y4b8c ff14e fs2 fc0 sc0 lsfd wscc">Worker不能完成给定的任务时会触发error 事件。具体来说，Worker内部的JavaScript在执行过</div><div class="t m0 x0 h1e y4b8d ff154 fs2 fc0 sc0 ls8 wseb">程中只要遇到错误，就会触发error事件。发生error事件时，事件对象中包含三个属性：filename、</div><div class="t m0 x0 h5 y2b81 ff156 fs1 fc0 sc0 ls9 ws2">lineno和message，分别表示发生错误的文件名、代码行号和完整的错误消息。 </div><div class="t m0 x0 hb y1434 ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4b8e ff156 fs6 fc0 sc0 ls21 wsb">worker.onerror = function(event){ </div><div class="t m0 x0 hb y4b8f ff156 fs6 fc0 sc0 ls21 wsb">    console.log(&quot;ERROR: &quot; + event.filename + &quot; (&quot; + event.lineno + &quot;): &quot; + </div><div class="t m0 x0 hb y4b90 ff156 fs6 fc0 sc0 ls21 wsb">                event.message); </div><div class="t m0 x0 hb y4b91 ff156 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y4b92 ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y20b7 ff154 fs2 fc0 sc0 ls8 wseb">建议大家在使用Web Workers时，始终都要使用 onerror事件处理程序，即使这个函数（像上面</div><div class="t m0 x0 h5 y20b8 ff154 fs2 fc0 sc0 ls8 wseb">例子所示的）除了把错误记录到日志中什么也不做都可以。否则，Worker就会在发生错误时，悄无声息</div><div class="t m0 x0 h5 y20b9 ff154 fs2 fc0 sc0 ls8 wseb">地失败了。 </div><div class="t m0 x0 h14 y4b93 ff154 fs2 fc0 sc0 ls8 wseb">任何时候，只要调用terminate()方法就可以停止Worker的工作。而且，Worker中的代码会立即</div><div class="t m0 x0 h5 y4b94 ff154 fs2 fc0 sc0 ls8 wseb">停止执行，后续的所有过程都不会再发生（包括error和message事件也不会再触发）。 </div><div class="t m0 x0 hb y1c3f ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4b95 ff156 fs6 fc0 sc0 ls21 wsb">worker.terminate();    //立即停止Worker的工作 </div><div class="t m0 x0 h5 y1d7b ff14e fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h20 y1045 ff152 fs3 fc0 sc0 ls248 ws214">25.6.2 Worker全局作用域 </div><div class="t m0 x0 h5 y4b96 ff154 fs2 fc0 sc0 ls8 wseb">关于Web Worker，最重要的是要知道它所执行的JavaScript代码完全在另一个作用域中，与当前网</div><div class="t m0 x0 h5 y4b97 ff154 fs2 fc0 sc0 ls8 wseb">页中的代码不共享作用域。在Web Worker中，同样有一个全局对象和其他对象以及方法。 但是，Web </div><div class="t m0 x0 h5 y4b98 ff14e fs2 fc0 sc0 lsfd wscc">Worker中的代码不能访问DOM，也无法通过任何方式影响页面的外观。 </div><div class="t m0 x0 h5 y4b99 ff14e fs2 fc0 sc0 lsfd ws1ba">Web Worker中的全局对象是worker对象本身。也就是说，在这个特殊的全局作用域中，this 和</div><div class="t m0 x0 h5 y4b9a ff156 fs1 fc0 sc0 ls9 ws2">self引用的都是worker对象。为便于处理数据，Web Worker 本身也是一个最小化的运行 环境。 </div><div class="t m0 x0 h4 yc6a ff153 fs1 fc0 sc0 ls2"> 最小化的navigator对象，包括onLine、appName、appVersion、userAgent和platform</div><div class="t m0 x0 h5 y4b9b ff154 fs2 fc0 sc0 ls8">属性； </div><div class="t m0 x0 h5 y4b9c ff153 fs1 fc0 sc0 ls2"> 只读的location对象； </div><div class="t m0 x0 h5 y4b9d ff153 fs1 fc0 sc0 ls2"> setTimeout()、setInterval()、clearTimeout()和clearInterval()方法； </div><div class="t m0 x0 h5 y2d54 ff153 fs1 fc0 sc0 ls2"> XMLHttpRequest构造函数。 </div><div class="t m0 x0 h5 yc6f ff154 fs2 fc0 sc0 ls8">显然，Web Worker的运行环境与页面环境相比，功能是相当有限的。 </div><div class="t m0 x0 h1c y4b9e ff154 fs2 fc0 sc0 ls8 wseb">当页面在worker对象上调用postMessage()时，数据会以异步方式被传递给worker，进而 触发</div><div class="t m0 x0 h5 y4b9f ff156 fs1 fc0 sc0 ls9 ws2">worker中的message 事件。为了处理来自页面的数据，同样也需要创建一个onmessage事件处理 </div><div class="t m0 x0 h5 y4ba0 ff154 fs2 fc0 sc0 ls8">程序。 </div><div class="t m0 x0 hb y12e0 ff156 fs6 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf2cd" class="pf w0 h0" data-page-no="2cd"><div class="pc pc2cd w0 h0"><div class="t m0 x2 h2 y1db2 ff14e fs0 fc0 sc0 ls7 ws0">25.6 Web Workers  699 </div><div class="t m0 x0 h3 y2 ff14e fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff15a fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff15a fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ff15a fs3 fc2 sc0 ls1d wsb">16 </div><div class="t m0 x3 h8 y20 ff15a fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff15a fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff15a fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff15a fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff15a fs3 fc2 sc0 ls1d wsb">20 </div><div class="t m0 x3 h8 y25 ff15a fs3 fc2 sc0 ls1d wsb">21 </div><div class="t m0 x3 h8 y26 ff15a fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff15a fs3 fc2 sc0 ls1d wsf">23 </div><div class="t m0 x3 h8 ya7a ff15a fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff15a fs3 fc2 sc0 ls1d wsf">25 </div><div class="t m0 x0 h16 y79 ff156 fs6 fc0 sc0 ls21 wsb">//Web Worker内部的代码 </div><div class="t m0 x0 hb y7a ff156 fs6 fc0 sc0 ls21 wsb">self.onmessage = function(event){ </div><div class="t m0 x0 hb y7b ff156 fs6 fc0 sc0 ls21 wsb">    var data = event.data; </div><div class="t m0 x0 hb y7c ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y7d ff156 fs6 fc0 sc0 ls21 wsb">    //处理数据 </div><div class="t m0 x0 hb y7e ff156 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y7f ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1314 ff154 fs2 fc0 sc0 ls8 wseb">大家看清楚，这里的self引用的是Worker全局作用域中的 worker对象（与页面中的Worker对</div><div class="t m0 x0 h5 y4ba1 ff154 fs2 fc0 sc0 ls8 wseb">象不同一个对象）。Worker完成工作后，通过调用postMessage()可以把数据再发回页面。例如，下</div><div class="t m0 x0 h5 y4ba2 ff154 fs2 fc0 sc0 ls8 wseb">面的例子假设需要Worker对传入的数组进行排序，而Worke r在排序之后又将数组发回了页面： </div><div class="t m0 x0 hb y694 ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4ba3 ff156 fs6 fc0 sc0 ls21 wsb">//Web Worker内部的代码 </div><div class="t m0 x0 hb y4ba4 ff156 fs6 fc0 sc0 ls21 wsb">self.onmessage = function(event){ </div><div class="t m0 x0 hb y4ba5 ff156 fs6 fc0 sc0 ls21 wsb">    var data = event.data; </div><div class="t m0 x0 hb y4ba6 ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4ba7 ff156 fs6 fc0 sc0 ls21 wsb">    //别忘了，默认的sort()方法只比较字符串 </div><div class="t m0 x0 hb y4ba8 ff156 fs6 fc0 sc0 ls21 wsb">    data.sort(function(a, b){ </div><div class="t m0 x0 hb y4ba9 ff156 fs6 fc0 sc0 ls21 wsb">       return a – b; </div><div class="t m0 x0 hb y4baa ff156 fs6 fc0 sc0 ls21 wsb">    }); </div><div class="t m0 x0 hb y4bab ff156 fs6 fc0 sc0 ls21 wsb">    self.postMessage(data); </div><div class="t m0 x0 hb y4bac ff156 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 h5 y4bad ff14e fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y4bae ff15b fs2 fc0 sc0 ls8 wsb">WebWorkerExample01.js </div><div class="t m0 x0 h5 y3374 ff154 fs2 fc0 sc0 ls8 wseb">传递消息就是页面与Worker相互之间通信的方式。在Wo rker中调用postMessage()会以异步方</div><div class="t m0 x0 hc y4baf ff154 fs2 fc0 sc0 ls8 wseb">式触发页面中Worker实例的message 事件。如果页面想要使用这个Worker，可以这样： </div><div class="t m0 x0 hb y4bb0 ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4bb1 ff156 fs6 fc0 sc0 ls21">//在页面中 </div><div class="t m0 x0 hb y4bb2 ff156 fs6 fc0 sc0 ls21 wsb">var data = [23,4,7,9,2,14,6,651,87,41,7798,24], </div><div class="t m0 x0 hb y4bb3 ff156 fs6 fc0 sc0 ls21 wsb">    worker = new Worker(&quot;WebWorkerExample01.js&quot;); </div><div class="t m0 x0 hb y4bb4 ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4bb5 ff156 fs6 fc0 sc0 ls21 wsb">worker.onmessage = function(event){ </div><div class="t m0 x0 hb y4bb6 ff156 fs6 fc0 sc0 ls21 wsb">    var data = event.data; </div><div class="t m0 x0 hb y4bb7 ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4bb8 ff156 fs6 fc0 sc0 ls21 wsb">    //对排序后的数组进行操作 </div><div class="t m0 x0 hb y4bb9 ff156 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y4bba ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4bbb ff156 fs6 fc0 sc0 ls21">//将数组发送给worker排序 </div><div class="t m0 x0 hb y4bbc ff156 fs6 fc0 sc0 ls21 wsb">worker.postMessage(data); </div><div class="t m0 x0 h5 y216a ff14e fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x2 hf y4bbd ff15b fs2 fc0 sc0 ls25 wsb">WebWorkerExample01.htm </div><div class="t m0 x0 h5 y4bbe ff154 fs2 fc0 sc0 ls8 wseb">排序的确是比较消耗时间的操作，因此转交给Worker做就不会阻塞用户界面了。另外，把彩色图</div><div class="t m0 x0 h5 y4bbf ff154 fs2 fc0 sc0 ls8 wseb">像转换成灰阶图像以及加密解密之类的操作也是相当费时的。 </div><div class="t m0 x0 h5 y19ae ff154 fs2 fc0 sc0 ls3b">在Worker内部，调用close()方法也可以停止工作。就像在页面中调用terminate()方法一样，</div><div class="t m0 x0 h5 y19af ff14e fs2 fc0 sc0 lsfd wscc">Worker停止工作后就不会再有事件发生了。 </div><div class="t m0 x0 hb y234 ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4bc0 ff156 fs6 fc0 sc0 ls21 wsb">//Web Worker内部的代码 </div><div class="t m0 x0 hb y4bc1 ff156 fs6 fc0 sc0 ls21 wsb">self.close(); </div><div class="t m0 x0 h5 y21d3 ff14e fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h20 y4bc2 ff152 fs3 fc0 sc0 ls248 ws214">25.6.3 包含其他脚本 </div><div class="t m0 x0 h5 y4bc3 ff154 fs2 fc0 sc0 ls8 wseb">既然无法在Worker中动态创建新的&lt;script&gt;元素，那是不是就不能向 Worker中添加其他脚本了</div></div></div>
<div id="pf2ce" class="pf w0 h0" data-page-no="2ce"><div class="pc pc2ce w0 h0"><div class="t m0 x0 h2 y1 ff14e fs0 fc0 sc0 ls7 ws0">700  第25章 新兴的API </div><div class="t m0 x0 h3 y2 ff14e fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff154 fs2 fc0 sc0 ls8 wseb">呢？不是，Worker的全局作用域提供这个功能，即我们可以调用importScripts()方法。这个方法接</div><div class="t m0 x0 h5 y4d ff154 fs2 fc0 sc0 ls8 wseb">收一个或多个指向JavaScript文件的URL。每个加载过程都是异步进行的，因此所有脚本加载并执行之</div><div class="t m0 x0 he yd8 ff154 fs2 fc0 sc0 ls8 wseb">后，importScripts()才会执行。例如： </div><div class="t m0 x0 hb y4f ff156 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y50 ff156 fs6 fc0 sc0 ls21 wsb">//Web Worker内部的代码 </div><div class="t m0 x0 hb y51 ff156 fs6 fc0 sc0 ls21 wsb">importScripts(&quot;file1.js&quot;, &quot;file2.js&quot;); </div><div class="t m0 x0 h5 y899 ff14e fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y4bc4 ff154 fs2 fc0 sc0 ls8 wseb">即使file2.js先于file1.js下载完，执行的时候仍然会按照先后顺序执行。而且，这些脚本是</div><div class="t m0 x0 h5 y4bc5 ff154 fs2 fc0 sc0 ls3b">在Worker的全局作用域中执行，如果脚本中包含与页面有关的JavaScript代码，那么脚本可能无法正确</div><div class="t m0 x0 h5 y4bc6 ff154 fs2 fc0 sc0 ls8 wseb">运行。请记住，Worker中的脚本一般都具有特殊的用途，不会像页面中的脚本那么功能宽泛。 </div><div class="t m0 x0 h20 y4bc7 ff152 fs3 fc0 sc0 ls248 ws214">25.6.4 Web Workers的未来 </div><div class="t m0 x0 h5 y4bc8 ff14e fs2 fc0 sc0 lsfd ws460">Web Workers规范还在继续制定和改进之中。本节所讨论的 Worker目前被称为“专用Worker ”</div><div class="t m0 x0 h5 y4bc9 ff154 fs2 fc0 sc0 ls8">（dedicated worker），因为它们是专门为某个特定的页面服务的，不能在页面间共享。该规范的另外一个</div><div class="t m0 x0 h5 y4bca ff154 fs2 fc0 sc0 ls8 wseb">概念是“共享Worker”（shared worker），这种Worker可以在浏览器的多个标签中打开的同一个页面间</div><div class="t m0 x0 h5 y4bcb ff154 fs2 fc0 sc0 ls8 wseb">共享。虽然Safari 5、Chrome和Opera 10.6都实现了共享Worker，但由于该规范尚未完稿，因此很可能</div><div class="t m0 x0 h5 y4bcc ff154 fs2 fc0 sc0 ls8 wseb">还会有变动。 </div><div class="t m0 x0 h5 y4bcd ff154 fs2 fc0 sc0 ls8 wseb">另外，关于在Worker内部能访问什么不能访问什么，到如今仍然争论不休。有人认为Worker 应该</div><div class="t m0 x0 h146 y4bce ff154 fs2 fc0 sc0 ls8 wseb">像页面一样能够访问任意数据，不光是XHR，还有localStorage、sessionStorage、Indexed DB、</div><div class="t m0 x0 h5 y1e50 ff14e fs2 fc0 sc0 ls8 ws461">Web Sockets、Server-Send Events等。好像支持这个观点的人更多一些，因此未来的Worker全局作用域</div><div class="t m0 x0 h5 y4bcf ff154 fs2 fc0 sc0 ls8 wseb">很可能会有更大的空间。 </div><div class="t m0 x0 hd y4bd0 ff152 fs7 fc0 sc0 ls245">25.7 小结 </div><div class="t m0 x0 h5 y4bd1 ff154 fs2 fc0 sc0 ls3b">与HTML5同时兴起的是另外一批JavaScript API。从技术规范角度讲，这批API不属于HTML5，</div><div class="t m0 x0 h5 y4bd2 ff154 fs2 fc0 sc0 ls8 wseb">但从整体上可以称它们为HTML5 JavaScript API。这些API的标准有不少虽然还在制定当中，但已经得</div><div class="t m0 x0 h5 y4bd3 ff154 fs2 fc0 sc0 ls8 wseb">到了浏览器的广泛支持，因此本章重点讨论了它们。 </div><div class="t m0 x0 h5 y4bd4 ff153 fs1 fc0 sc0 ls2"> requestAnimationFrame()：是一个着眼于优化JavaScript动画的API，能够在动画运行期间</div><div class="t m0 x0 h5 y4bd5 ff154 fs2 fc0 sc0 ls8 wseb">发出信号。通过这种机制，浏览器就能够自动优化屏幕重绘操作。 </div><div class="t m0 x0 h5 y4bd6 ff153 fs1 fc0 sc0 ls2"> Page Visibility API：让开发人员知道用户什么时候正在看着页面，而什么时候页面是隐藏的。 </div><div class="t m0 x0 h5 y4bd7 ff153 fs1 fc0 sc0 ls2"> Geolocation API：在得到许可的情况下，可以确定用户所在的位置。在移动Web应用中，这个</div><div class="t m0 x0 h5 y4bd8 ff14e fs2 fc0 sc0 ls25 wsb3">API非常重要而且常用。 </div><div class="t m0 x0 h5 y4bd9 ff153 fs1 fc0 sc0 ls2"> File API：可以读取文件内容，用于显示、处理和上传。与HTML5的拖放功能结合，很容易就</div><div class="t m0 x0 h5 y4bda ff154 fs2 fc0 sc0 ls8 wseb">能创造出拖放上传功能。 </div><div class="t m0 x0 h5 y969 ff153 fs1 fc0 sc0 ls2"> Web Timing：给出了页面加载和渲染过程的很多信息，对性能优化非常有价值。 </div><div class="t m0 x0 h5 y3a6c ff153 fs1 fc0 sc0 ls2"> Web Workers：可以运行异步JavaScript代码，避免阻塞用户界面。在执行复杂计算和数据处理</div><div class="t m0 x0 h5 y4bdb ff154 fs2 fc0 sc0 ls8 wseb">的时候，这个API非常有用；要不然，这些任务轻则会占用很长时间，重则会导致用户无法与</div><div class="t m0 x0 h5 y4bdc ff154 fs2 fc0 sc0 ls8 wseb">页面交互。 </div></div></div>
<div id="pf2cf" class="pf w0 h0" data-page-no="2cf"><div class="pc pc2cf w0 h0"><div class="t m0 x4 h2 y1 ff15d fs0 fc0 sc0 ls8 ws256">附录A ECMAScript Harmony  701 </div><div class="t m0 x0 h3 y2 ff15e fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff15f fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff15f fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ff15f fs3 fc2 sc0 ls1d wsb">16 </div><div class="t m0 x3 h8 y20 ff15f fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff15f fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff15f fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff15f fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff15f fs3 fc2 sc0 ls1d wsb">20 </div><div class="t m0 x3 h8 y25 ff15f fs3 fc2 sc0 ls1d wsb">21 </div><div class="t m0 x3 h8 y26 ff15f fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff15f fs3 fc2 sc0 ls1d wsf">23 </div><div class="t m0 x3 h8 ya7a ff15f fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff15f fs3 fc2 sc0 ls1d wsf">25 </div><div class="t m0 x0 h9 y2a ff160 fs5 fc0 sc0 ls248 wsb">ECMAScript Harmony </div><div class="t m0 x0 h5 y2e0 ff15e fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x5 h5 y4bdd ff15e fs2 fc0 sc0 ls8 ws20">2004年Web开发重新焕发生机的大背景下，浏览器开发商和其他相关组织之间进行了一系列</div><div class="t m0 x5 h5 y4bde ff161 fs2 fc0 sc0 ls8 ws1">会谈，讨论应该如何改进JavaScript。ECMA-262第四版的制定工作就建立在两大相互竞争的</div><div class="t m0 x0 h5 y4bdf ff161 fs2 fc0 sc0 ls8 ws1">提案基础上：一个是Netscape的JavaScript 2.0，另一个是Microsoft的JScript.NET。各方抛开在浏览器</div><div class="t m0 x0 h5 y4be0 ff161 fs2 fc0 sc0 ls8 ws1">领域的竞争，聚集在ECMA麾下，提出了希望能以JavaScript为蓝本设计出一门新语言的建议方案。最</div><div class="t m0 x0 h5 y4be1 ff161 fs2 fc0 sc0 ls8 ws1">初的工作草案叫做ECMAScript 4，而且很长时间以来，它好像就是JavaScript的下一个版本。后来，一</div><div class="t m0 x0 h5 y4be2 ff161 fs2 fc0 sc0 ls8 ws1">个叫ECMAScript 3.1反提案的加入，令JavaScript的未来再次充满了疑问。在反复争论之后，ECMAScript </div><div class="t m0 x0 h5 y4be3 ff15e fs2 fc0 sc0 lsd2 ws19b">3.1成为了JavaScript 的下一个版本，而且未来的工作成果——代号Harmony（和谐），将力争让</div><div class="t m0 x0 h5 y4be4 ff15e fs2 fc0 sc0 ls79 ws73">ECMAScript 4向ECMAScript 3.1靠拢。 </div><div class="t m0 x0 h5 y4be5 ff15e fs2 fc0 sc0 ls79 ws469">ECMAScript 3.1最终改名为ECMAScript 5，很快就完成了标准化。ECMAScript 5的详细内容本书</div><div class="t m0 x0 h5 y4be6 ff161 fs2 fc0 sc0 ls8 ws1">已经介绍过了。ECMAScript 5的标准化工作一完成，Harmony立即被提上日程。Harmony与ECMAScript </div><div class="t m0 x0 h5 y4be7 ff15e fs2 fc0 sc0 ls38">5的指导思想比较一致，就是只进行增量调整，不彻底改造语言。虽然到2011年的时候，Harmony，也</div><div class="t m0 x0 h5 y4be8 ff161 fs2 fc0 sc0 ls6 ws6">就是未来的ECMAScript 6，还没有全部制定完成，但其中的几个部分已经尘埃落定。本附录所要介绍</div><div class="t m0 x0 h4 y4be9 ff161 fs2 fc0 sc0 ls8 ws1">的就是那些将来肯定能进入最终规范的部分。不过也提醒一下大家，在将来的实现中，这些内容的细节</div><div class="t m0 x0 h5 y4bea ff161 fs2 fc0 sc0 ls8 ws1">有可能与你在这里看到的不一样。 </div><div class="t m0 x0 hd y4beb ff162 fs7 fc0 sc0 ls4d3 ws467">A.1 一般性变化 </div><div class="t m0 x0 h5 y4bec ff15e fs2 fc0 sc0 ls138 ws133">Harmony为ECMAScript引入了一些基本的变化。对这门语言来说，这些虽然不算是大的变化，但</div><div class="t m0 x0 h5 y4bed ff161 fs2 fc0 sc0 ls8 ws1">的确也弥补了它功能上的一些缺憾。 </div><div class="t m0 x0 h20 y3639 ff162 fs3 fc0 sc0 ls283 ws34b">A.1.1 常量 </div><div class="t m0 x0 h5 y2748 ff161 fs2 fc0 sc0 ls8 ws1">没有正式的常量是JavaScript的一个明显缺陷。为了弥补这个缺陷，标准制定者为Harmony增加了</div><div class="t m0 x0 h1e y4bee ff161 fs2 fc0 sc0 ls32b">用const关键字声明常量的语法。使用方式与var类似，但const声明的变量在初始赋值后，就不能</div><div class="t m0 x0 h5 y4bef ff161 fs2 fc0 sc0 ls8 ws1">再重新赋值了。来看一个例子。 </div><div class="t m0 x0 hb y30bd ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4bf0 ff164 fs6 fc0 sc0 ls21 wsb">const MAX_SIZE = 25; </div><div class="t m0 x0 hb y4bf1 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y2ee1 ff161 fs2 fc0 sc0 ls8 ws1">可以像声明变量一样在任何地方声明常量。但在同一作用域中，常量名不能与其他变量或函数名重</div><div class="t m0 x0 h5 y42d6 ff161 fs2 fc0 sc0 ls8 ws1">名，因此下列声明会导致错误： </div><div class="t m0 x0 hb y4bf2 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4bf3 ff164 fs6 fc0 sc0 ls21 wsb">const FLAG = true; </div><div class="t m0 x0 h16 y4bf4 ff164 fs6 fc0 sc0 ls21 wsb">var FLAG = false; //错误！ </div><div class="t m0 x0 hb y4bf5 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5a yfbd ff163 fs5 fc0 sc0 ls8 wsb">在 </div><div class="t m0 x0 h11 y4b ff166 fsa fc0 sc0 ls8">附录</div><div class="t m1 x5 h12 y4b ff167 fsb fc3 sc0 ls8">A</div><div class="t m0 x5 h9 y4b ff160 fs5 fc3 sc0 ls8 wsb"> </div></div></div>
<div id="pf2d0" class="pf w0 h0" data-page-no="2d0"><div class="pc pc2d0 w0 h0"><div class="t m0 x0 h2 y1 ff15e fs0 fc0 sc0 ls7 ws0">702  附录A ECMAScript Harmony </div><div class="t m0 x0 h3 y2 ff15e fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ff161 fs2 fc0 sc0 ls8 ws1">除了值不能修改之外，可以像使用任何变量一样使用常量。修改常量的值，不会有任何效果，如下</div><div class="t m0 x0 h5 y4d ff161 fs2 fc0 sc0 ls8">所示： </div><div class="t m0 x0 hb y2d8 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2d9 ff164 fs6 fc0 sc0 ls21 wsb">const FLAG = true; </div><div class="t m0 x0 hb y2da ff164 fs6 fc0 sc0 ls21 wsb">FLAG = false; </div><div class="t m0 x0 hb y2db ff164 fs6 fc0 sc0 ls21 wsb">alert(FLAG); //true </div><div class="t m0 x0 h5 y4bf6 ff15e fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y4bf7 ff161 fs2 fc0 sc0 ls8 ws1">支持常量的浏览器有Firefox、Safari 3+、Opera 9+和Chrome。在Safari和Opera中，const与var</div><div class="t m0 x0 h5 y2321 ff161 fs2 fc0 sc0 ls8 ws1">的作用一样，因为前者定义的常量的值是可以修改的。 </div><div class="t m0 x0 h20 y4bf8 ff162 fs3 fc0 sc0 ls283 ws34b">A.1.2 块级作用域及其他作用域 </div><div class="t m0 x0 h5 y4b21 ff161 fs2 fc0 sc0 ls6 ws6">本书时不时就会提醒读者一句：JavaScript没有块级作用域。换句话说，在语句块中定义的变量与</div><div class="t m0 x0 hc y4bf9 ff161 fs2 fc0 sc0 ls8 ws1">在包含函数中定义的变量共享相同的作用域。Harmony新增了定义块级作用域的语法：使用let关键字。 </div><div class="t m0 x0 h1e y4bfa ff161 fs2 fc0 sc0 ls43d">与const和var类似，可以使用let在任何地方定义变量并为变量赋值。区别在于，使用let 定</div><div class="t m0 x0 h5 y4bfb ff161 fs2 fc0 sc0 ls8 ws1">义的变量在定义它的代码块之外没有定义。比如说吧，下面是一个非常常见的代码块： </div><div class="t m0 x0 hb y4bfc ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4bfd ff164 fs6 fc0 sc0 ls21 wsb">for (var i=0; i &lt; 10; i++) { </div><div class="t m0 x0 h16 y4bfe ff164 fs6 fc0 sc0 ls21 wsb">    //执行某些操作 </div><div class="t m0 x0 hb y4bff ff164 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 hb y4c00 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4c01 ff164 fs6 fc0 sc0 ls21 wsb">alert(i); //10 </div><div class="t m0 x0 h5 y33ff ff15e fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h171 y4c02 ff161 fs2 fc0 sc0 ls8 ws1">在上面的代码块中，变量i是作为代码块所在函数的局部变量来声明的。也就是说，在for循环</div><div class="t m0 x0 h4 y4c03 ff161 fs2 fc0 sc0 ls8 ws1">执行完毕后，仍然能够读取i的值。如果在这里使用let代替var，则循环之后，变量i将不复存在。</div><div class="t m0 x0 h5 y4c04 ff161 fs2 fc0 sc0 ls8 ws1">看下面的例子。 </div><div class="t m0 x0 hb y3b98 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y4c05 ff168 fs6 fc0 sc0 ls21 wsb">for (let i=0; i &lt; 10; i++) { </div><div class="t m0 x0 h16 y4c06 ff164 fs6 fc0 sc0 ls21 wsb">    //执行某些操作 </div><div class="t m0 x0 hb y4c07 ff164 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 h15 y4c08 ff168 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4c09 ff168 fs6 fc0 sc0 ls21 wsb">alert(i); //错误！变量i没有定义 </div><div class="t m0 x0 h5 y4c0a ff15e fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h171 y4c0b ff161 fs2 fc0 sc0 ls8 ws1">以上代码执行到最后一行的时候，就会出现错误，因为for循环一结束，变量i就已经没有定义</div><div class="t m0 x0 h5 y4c0c ff161 fs2 fc0 sc0 ls8 ws1">了。因为不能对没有定义的变量执行操作，所以发生错误是自然的。 </div><div class="t m0 x0 h1c y4c0d ff161 fs2 fc0 sc0 ls8 ws1">还有另外一种使用let的方式，即创建let 语句，在其中定义只能在后续代码块中使用的变量，</div><div class="t m0 x0 h5 y4c0e ff161 fs2 fc0 sc0 ls8 ws1">像下面的例子这样： </div><div class="t m0 x0 hb y4c0f ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4c10 ff164 fs6 fc0 sc0 ls21 wsb">var num = 5; </div><div class="t m0 x0 hb y4c11 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4c12 ff164 fs6 fc0 sc0 ls21 wsb">let (num=10, multiplier=2){ </div><div class="t m0 x0 hb y4c13 ff164 fs6 fc0 sc0 ls21 wsb">    alert(num * multiplier); //20 </div><div class="t m0 x0 hb y4c14 ff164 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 hb y4c15 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4c16 ff164 fs6 fc0 sc0 ls21 wsb">alert(num); //5 </div><div class="t m0 x0 hb y4c17 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y817 ff161 fs2 fc0 sc0 ls8 ws1">以上代码通过let语句定义了一个区域，这个区域中的变量num等于 10，multiplier等于2。</div><div class="t m0 x0 hc y3463 ff161 fs2 fc0 sc0 ls8 ws1">此时的num覆盖了前面用var声明的同名变量，因此在let语句块中，num乘以multiplier 等于20。</div><div class="t m0 x0 hc y4c18 ff161 fs2 fc0 sc0 ls8 ws1">而出了let语句块之后，num变量的值仍然是5。这是因 为let语句创建了自己的作用域，这个作用域</div><div class="t m0 x0 h5 y2d57 ff161 fs2 fc0 sc0 ls8 ws1">里的变量与外面的变量无关。 </div><div class="t m0 x0 h5 y4c19 ff15e fs2 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf2d1" class="pf w0 h0" data-page-no="2d1"><div class="pc pc2d1 w0 h0"><div class="t m0 x4 h2 y1 ff15d fs0 fc0 sc0 ls8 ws256">附录A ECMAScript Harmony  703 </div><div class="t m0 x0 h3 y2 ff15e fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff15f fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff15f fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ff15f fs3 fc2 sc0 ls1d wsb">16 </div><div class="t m0 x3 h8 y20 ff15f fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff15f fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff15f fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff15f fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff15f fs3 fc2 sc0 ls1d wsb">20 </div><div class="t m0 x3 h8 y25 ff15f fs3 fc2 sc0 ls1d wsb">21 </div><div class="t m0 x3 h8 y26 ff15f fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff15f fs3 fc2 sc0 ls1d wsf">23 </div><div class="t m0 x3 h8 ya7a ff15f fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff15f fs3 fc2 sc0 ls1d wsf">25 </div><div class="t m0 x0 h5 y3 ff161 fs2 fc0 sc0 ls8 ws1">使用同样的语法还可以创建let表达式，其中的变量只在表达式中有定义。再看一个例子。 </div><div class="t m0 x0 hb yfb2 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb yfb3 ff164 fs6 fc0 sc0 ls21 wsb">var result = let(num=10, multiplier=2) num * multiplier; </div><div class="t m0 x0 hb yfb4 ff164 fs6 fc0 sc0 ls21 wsb">alert(result); //20 </div><div class="t m0 x0 hb y4c1a ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y118a ff161 fs2 fc0 sc0 ls8 ws1">这里的let表达式使用两个变量计算后得到一个值，保存在变量result中。执行表达式之后，num</div><div class="t m0 x0 h5 y2062 ff161 fs2 fc0 sc0 ls2c">和multiplier变量就不存在了。 </div><div class="t m0 x0 h5 y118c ff161 fs2 fc0 sc0 ls3b">在JavaScript中使用块级作用域，可以更精细地控制代码执行过程中变量的存废。 </div><div class="t m0 x0 hd y4c1b ff162 fs7 fc0 sc0 ls4d3 ws467">A.2 函数 </div><div class="t m0 x0 h5 y412d ff161 fs2 fc0 sc0 ls6 ws6">大多数代码都是以函数方式编写的，因此Harmony从几个方面改进了函数，使其更便于使用。与</div><div class="t m0 x0 h5 y412e ff15e fs2 fc0 sc0 ls138 ws133">Harmony中其他部分类似，对函数的改进也集中在开发人员和实现人员共同面临的难题上。 </div><div class="t m0 x0 h20 y336 ff162 fs3 fc0 sc0 ls283 ws34b">A.2.1 剩余参数与分布参数 </div><div class="t m0 x0 h5 y4c1c ff15e fs2 fc0 sc0 ls138 ws133">Harmony中不再有arguments对象，因此也就无法通过它来读取到未声明的参数。不过，使用剩</div><div class="t m0 x0 h5 y4c1d ff161 fs2 fc0 sc0 ls8 ws1">余参数（rest arguments）语法，也能表示你期待给函数传入可变数量的参数。剩余参数的语法形式是三</div><div class="t m0 x0 h4 y4c1e ff161 fs2 fc0 sc0 ls8 ws1">个点后跟一个标识符。使用这种语法可以定义可能会传进来的更多参数，然后把它们收集到一个数组中。</div><div class="t m0 x0 h5 y4c1f ff161 fs2 fc0 sc0 ls8 ws1">来看一个例子。 </div><div class="t m0 x0 hb y2ab7 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4c20 ff164 fs6 fc0 sc0 ls21 wsb">function sum(num1, num2, ...nums){ </div><div class="t m0 x0 hb y4c21 ff164 fs6 fc0 sc0 ls21 wsb">    var result = num1 + num2; </div><div class="t m0 x0 hb y4c22 ff164 fs6 fc0 sc0 ls21 wsb">    for (let i=0, len=nums.length; i &lt; len; i++){ </div><div class="t m0 x0 hb y4c23 ff164 fs6 fc0 sc0 ls21 wsb">        result += nums[i]; </div><div class="t m0 x0 hb y4c24 ff164 fs6 fc0 sc0 ls21 wsb">    }  </div><div class="t m0 x0 hb y4c25 ff164 fs6 fc0 sc0 ls21 wsb">    return result; </div><div class="t m0 x0 hb y4c26 ff164 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y4c27 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4c28 ff164 fs6 fc0 sc0 ls21 wsb">var result = sum(1, 2, 3, 4, 5, 6); </div><div class="t m0 x0 hb y4c29 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y4c2a ff161 fs2 fc0 sc0 ls8 ws1">以上代码定义了一个sum()函数，接收至少两个参数。这个函数还能接收更多参数，而其余参数都</div><div class="t m0 x0 h1e y4c2b ff161 fs2 fc0 sc0 ls8 ws1">将保存在nums数组中。与原来的arguments对象不同，剩余参数都保存在 Array的一个实例中，因</div><div class="t m0 x0 h4 y3b9b ff161 fs2 fc0 sc0 ls8 ws1">此可以使用任何数组方法来操作它们。另外，即使并没有多余的参数传入函数，剩余参数对象也是Array</div><div class="t m0 x0 h5 y77d ff161 fs2 fc0 sc0 ls8">的实例。 </div><div class="t m0 x0 h5 y77e ff161 fs2 fc0 sc0 ls6 ws6">与剩余参数紧密相关的另一种参数语法是分布参数（spread arguments）。通过分布参数，可以向函</div><div class="t m0 x0 h4 y4c2c ff161 fs2 fc0 sc0 ls8 ws1">数中传入一个数组，然后数组中的元素会映射到函数的每个参数上。分布参数的语法形式与剩余参数的</div><div class="t m0 x0 h4 y4c2d ff161 fs2 fc0 sc0 ls8 ws1">语法相同，就是在值的前面加三个点。唯一的区别是分布参数在调用函数的时候使用，而剩余参数在定</div><div class="t m0 x0 h14 y4c2e ff161 fs2 fc0 sc0 ls8 ws1">义函数的时候使用。比如，我们可以不给sum()函数一个一个地传入参数，而是传入分布参数： </div><div class="t m0 x0 hb y1a1 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y496a ff164 fs6 fc0 sc0 ls21 wsb">var result = sum(...[1, 2, 3, 4, 5, 6]); </div><div class="t m0 x0 hb y4c2f ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y4c30 ff161 fs2 fc0 sc0 ls8 ws1">在这里，我们将一个数组作为分布参数传给了sum()函数。以上代码在功能上与下面这行代码等价： </div><div class="t m0 x0 hb y4c31 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4c32 ff164 fs6 fc0 sc0 ls21 wsb">var result = sum.apply(this, [1, 2, 3, 4, 5, 6]); </div><div class="t m0 x0 h20 y4c33 ff162 fs3 fc0 sc0 ls283 ws34b">A.2.2 默认参数值 </div><div class="t m0 x0 h5 y4547 ff15e fs2 fc0 sc0 ls1a ws1c">ECMAScript函数中的所有参数都是可选的，因为实现不会检查传入的参数数量。不过，除了手工</div></div></div>
<div id="pf2d2" class="pf w0 h0" data-page-no="2d2"><div class="pc pc2d2 w0 h0"><div class="t m0 x0 h2 y1 ff15e fs0 fc0 sc0 ls7 ws0">704  附录A ECMAScript Harmony </div><div class="t m0 x0 h3 y2 ff15e fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ff161 fs2 fc0 sc0 ls8 ws1">检查传入了哪个参数之外，你还可以为参数指定默认值。如果调用函数时没有传入该参数，那么该参数</div><div class="t m0 x0 h5 y4d ff161 fs2 fc0 sc0 ls8 ws1">就会使用默认值。 </div><div class="t m0 x0 h5 yd8 ff161 fs2 fc0 sc0 ls8 ws1">要为参数指定默认值，可以在参数名后面直接加上等于号和默认值，就像下面这样： </div><div class="t m0 x0 hb y6bd ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y6be ff164 fs6 fc0 sc0 ls21 wsb">function sum(num1, num2=0){ </div><div class="t m0 x0 hb y6bf ff164 fs6 fc0 sc0 ls21 wsb">    return num1 + num2;  </div><div class="t m0 x0 hb y6c0 ff164 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y6c1 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y6c2 ff164 fs6 fc0 sc0 ls21 wsb">var result1 = sum(5); </div><div class="t m0 x0 hb y6c3 ff164 fs6 fc0 sc0 ls21 wsb">var result2 = sum(5, 5); </div><div class="t m0 x0 hb y4c34 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 yf6c ff161 fs2 fc0 sc0 ls8 ws1">这个sum()函数接收两个参数，但第二个参数是可选的，因为它的默认值为0。使用可选参数的好</div><div class="t m0 x0 h4 yf6d ff161 fs2 fc0 sc0 ls8 ws1">处是开发人员不用再去检查是否给某个参数传入了值，如果没有的话就使用某个特定的值。默认参数值</div><div class="t m0 x0 h5 y32a4 ff161 fs2 fc0 sc0 ls8 ws1">帮你解除了这个困扰。 </div><div class="t m0 x0 h20 y47f0 ff162 fs3 fc0 sc0 ls283 ws34b">A.2.3 生成器 </div><div class="t m0 x0 h5 y4c35 ff161 fs2 fc0 sc0 ls8">所谓生成器，其实就是一个对象，它每次能生成一系列值中的一个。对Harmony而言，要创建生成</div><div class="t m0 x0 h1e y4c36 ff161 fs2 fc0 sc0 ls8 ws1">器，可以让函数通过yield操作符返回某个特殊的值。对于使用yield操作符返回值的函数，调用它</div><div class="t m0 x0 h4 y4c37 ff161 fs2 fc0 sc0 ls8 ws1">时就会创建并返回一个新的Generator实例。然后，在这个实例上调用next()方法就能取得生成器</div><div class="t m0 x0 h1e y4c38 ff161 fs2 fc0 sc0 ls8 ws1">的第一个值。此时，执行的是原来的函数，但执行流到yield语句就会停止，只返回特定的值。从这</div><div class="t m0 x0 h1e y4c39 ff161 fs2 fc0 sc0 ls8 ws1">个角度看，yield与return很相似。如果再次调用next()方法，原来函数中位于yield语句后的代</div><div class="t m0 x0 hc y4c3a ff161 fs2 fc0 sc0 ls8 ws1">码会继续执行，直到再次遇见yield语句时停止执行，此时再返回一个新值。来看下面的例子。 </div><div class="t m0 x0 hb y7de ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y7df ff164 fs6 fc0 sc0 ls21 wsb">function myNumbers(){ </div><div class="t m0 x0 hb y4c3b ff164 fs6 fc0 sc0 ls21 wsb">    for (var i=0; i &lt; 10; i++){ </div><div class="t m0 x0 hb y4c3c ff164 fs6 fc0 sc0 ls21 wsb">        yield i * 2; </div><div class="t m0 x0 hb y7e2 ff164 fs6 fc0 sc0 ls21 wsb">    }  </div><div class="t m0 x0 hb y4c3d ff164 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y4c3e ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4c3f ff164 fs6 fc0 sc0 ls21 wsb">var generator = myNumbers(); </div><div class="t m0 x0 hb y4c40 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4c41 ff164 fs6 fc0 sc0 ls21 wsb">try { </div><div class="t m0 x0 hb y4c42 ff164 fs6 fc0 sc0 ls21 wsb">    while(true){ </div><div class="t m0 x0 hb y4c43 ff164 fs6 fc0 sc0 ls21 wsb">        document.write(generator.next() + &quot;&lt;br /&gt;&quot;); </div><div class="t m0 x0 hb y4c44 ff164 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y4c45 ff164 fs6 fc0 sc0 ls21 wsb">} catch(ex){ </div><div class="t m0 x0 h16 y4c46 ff164 fs6 fc0 sc0 ls21 wsb">    //有意没有写代码 </div><div class="t m0 x0 hb y4c47 ff164 fs6 fc0 sc0 ls21 wsb">} finally { </div><div class="t m0 x0 hb y4c48 ff164 fs6 fc0 sc0 ls21 wsb">    generator.close(); </div><div class="t m0 x0 hb y4c49 ff164 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 h5 y4c4a ff15e fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h171 y4c4b ff161 fs2 fc0 sc0 ls8 ws1">调用myNumbers()函数后，会得到一个生成器。myNumbers()函数本身非常简单，包含一个每次</div><div class="t m0 x0 h1e y4c4c ff161 fs2 fc0 sc0 ls8 ws1">循环都产生一个值的for循环。每次调用next()方法都会执行一次for循环，然后返回下一个值。第</div><div class="t m0 x0 h5 y4c4d ff161 fs2 fc0 sc0 ls8 ws1">一个值是0，第二个值是2，第三个值是4，依此类推。在myNumbers()函数完成退出而没有执行yield</div><div class="t m0 x0 h5 y4c4e ff161 fs2 fc0 sc0 ls8 ws1">语句时（最后一次循环判断i不小于10的时候），生成器会抛出StopIteration错误。因此，为了输</div><div class="t m0 x0 h1e y4c4f ff161 fs2 fc0 sc0 ls8 ws1">出生成器能产生的所有数值，这里用一个try-catch结构包装了一个while循环，以避免出错时中断</div><div class="t m0 x0 h5 y4c50 ff161 fs2 fc0 sc0 ls8 ws1">代码执行。 </div><div class="t m0 x0 h1c y4c51 ff161 fs2 fc0 sc0 ls8 ws1">如果不再需要某个生成器，最好是调用它的close()方法。这样会执行原始函数的其他部分，包括</div><div class="t m0 x0 h5 y10f7 ff164 fs1 fc0 sc0 ls9 ws2">try-catch相关的finally语句块。 </div></div></div>
<div id="pf2d3" class="pf w0 h0" data-page-no="2d3"><div class="pc pc2d3 w0 h0"><div class="t m0 x4 h2 y1 ff15d fs0 fc0 sc0 ls8 ws256">附录A ECMAScript Harmony  705 </div><div class="t m0 x0 h3 y2 ff15e fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff15f fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff15f fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ff15f fs3 fc2 sc0 ls1d wsb">16 </div><div class="t m0 x3 h8 y20 ff15f fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff15f fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff15f fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff15f fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff15f fs3 fc2 sc0 ls1d wsb">20 </div><div class="t m0 x3 h8 y25 ff15f fs3 fc2 sc0 ls1d wsb">21 </div><div class="t m0 x3 h8 y26 ff15f fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff15f fs3 fc2 sc0 ls1d wsf">23 </div><div class="t m0 x3 h8 ya7a ff15f fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff15f fs3 fc2 sc0 ls1d wsf">25 </div><div class="t m0 x0 h5 y3 ff161 fs2 fc0 sc0 ls8 ws1">在需要一系列值，而每一个值又与前一个值存在某种关系的情况下，可以使用生成器。 </div><div class="t m0 x0 hd y4e ff162 fs7 fc0 sc0 ls4d3 ws467">A.3 数组及其他结构 </div><div class="t m0 x0 h5 y1876 ff15e fs2 fc0 sc0 ls138 ws133">Harmony的另一个重点是数组。数组是JavaScript使用最频繁的一种数据结构，因此定义一些更直</div><div class="t m0 x0 h5 y1877 ff161 fs2 fc0 sc0 ls8 ws1">观更方便地使用数组的方式，绝对是改进这门语言时最优先考虑的事。 </div><div class="t m0 x0 h20 y3cf9 ff162 fs3 fc0 sc0 ls283 ws34b">A.3.1 迭代器 </div><div class="t m0 x0 h4 y4c52 ff161 fs2 fc0 sc0 ls8 ws1">迭代器也是一个对象，它能迭代一系列值并每次返回其中一个值。想象一下使用for或for-in循</div><div class="t m0 x0 h4 y4c53 ff161 fs2 fc0 sc0 ls8 ws1">环，这时候就是在迭代一批值，而且每次操作其中的一个值。迭代器的作用相同，只不过用不着使用循</div><div class="t m0 x0 h5 y4c54 ff161 fs2 fc0 sc0 ls8">环了。Harmony为各种类型的对象都定义了迭代器。 </div><div class="t m0 x0 h1c y4c55 ff161 fs2 fc0 sc0 ls8 ws1">要为对象创建迭代器，可以调用Iterator构造函数，传入想要迭代其值的对象。要取得对象中的</div><div class="t m0 x0 h1e y4c56 ff161 fs2 fc0 sc0 ls8 ws1">下一个值，可以调用迭代器的next()方法。默认情况下，这个方法会返回一个数组。如果迭代的是数</div><div class="t m0 x0 h4 y4c57 ff161 fs2 fc0 sc0 ls8 ws1">组，那么返回数组的第一个元素是值的索引，如果迭代的是对象，那么返回数组的第一个元素是值的属</div><div class="t m0 x0 h1e y1e2a ff161 fs2 fc0 sc0 ls60 ws198">性名；返回数组的第二个元素是值本身。如果所有值都已经迭代了一遍，则再调用next()会抛出</div><div class="t m0 x0 h5 y4d2 ff164 fs1 fc0 sc0 ls9 ws2">StopIteration错误。看下面这个例子。 </div><div class="t m0 x0 hb y4c58 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4c59 ff164 fs6 fc0 sc0 ls21 wsb">var person = { </div><div class="t m0 x0 hb y4c5a ff164 fs6 fc0 sc0 ls21 wsb">    name: &quot;Nicholas&quot;, </div><div class="t m0 x0 hb y4c5b ff164 fs6 fc0 sc0 ls21 wsb">    age: 29  </div><div class="t m0 x0 hb y4c5c ff164 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y4c5d ff164 fs6 fc0 sc0 ls21 wsb">var iterator = new Iterator(person); </div><div class="t m0 x0 hb y4c5e ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4c5f ff164 fs6 fc0 sc0 ls21 wsb">try { </div><div class="t m0 x0 hb y4c60 ff164 fs6 fc0 sc0 ls21 wsb">    while(true){ </div><div class="t m0 x0 hb y4c61 ff164 fs6 fc0 sc0 ls21 wsb">        let value = iterator.next(); </div><div class="t m0 x0 hb y4c62 ff164 fs6 fc0 sc0 ls21 wsb">        document.write(value.join(&quot;:&quot;) + &quot;&lt;br&gt;&quot;); </div><div class="t m0 x0 hb y4c63 ff164 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y4c64 ff164 fs6 fc0 sc0 ls21 wsb">} catch(ex){ </div><div class="t m0 x0 h16 y4c65 ff164 fs6 fc0 sc0 ls21 wsb">    //有意没有写代码 </div><div class="t m0 x0 hb y4c66 ff164 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 h5 y755 ff15e fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y4c67 ff161 fs2 fc0 sc0 ls4c ws3e">以上代码为person对象创建了一个迭代器。第一次调用 next()方法，返回数组[&quot;name&quot;, </div><div class="t m0 x0 h5 y1889 ff164 fs1 fc0 sc0 ls9 ws2">&quot;Nicholas&quot;]，第二次调用返回数组[&quot;age&quot;, 29]。以上代码的输入结果为： </div><div class="t m0 x0 hb y2b9e ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4c68 ff164 fs6 fc0 sc0 ls21 wsb">name:Nicholas </div><div class="t m0 x0 hb y4c69 ff164 fs6 fc0 sc0 ls21 wsb">age:29 </div><div class="t m0 x0 hb y4c6a ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y4c6b ff161 fs2 fc0 sc0 ls8 ws1">如果为非数组对象创建迭代器，则迭代器会按照与使用for-in循环一样的顺序，返回对象的每个</div><div class="t m0 x0 h4 y4c6c ff161 fs2 fc0 sc0 ls8 ws1">属性。这就意味着迭代器也只能返回对象的实例属性，而且返回属性的顺序也会因实现而异。为数组创</div><div class="t m0 x0 h5 y4c6d ff161 fs2 fc0 sc0 ls8 ws1">建的迭代器也类似，即按数组元素顺序依次返回值，下面是一个例子。 </div><div class="t m0 x0 hb y4c6e ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h15 y4c6f ff168 fs6 fc0 sc0 ls21 wsb">var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]; </div><div class="t m0 x0 h15 y4c70 ff168 fs6 fc0 sc0 ls21 wsb">var iterator = new Iterator(colors); </div><div class="t m0 x0 hb y4c71 ff164 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 hb y4c72 ff164 fs6 fc0 sc0 ls21 wsb">try { </div><div class="t m0 x0 hb y4c73 ff164 fs6 fc0 sc0 ls21 wsb">    while(true){ </div><div class="t m0 x0 hb y4c74 ff164 fs6 fc0 sc0 ls21 wsb">        let value = iterator.next(); </div><div class="t m0 x0 hb y4c75 ff164 fs6 fc0 sc0 ls21 wsb">        document.write(value.join(&quot;:&quot;) + &quot;&lt;br&gt;&quot;); </div></div></div>
<div id="pf2d4" class="pf w0 h0" data-page-no="2d4"><div class="pc pc2d4 w0 h0"><div class="t m0 x0 h2 y1 ff15e fs0 fc0 sc0 ls7 ws0">706  附录A ECMAScript Harmony </div><div class="t m0 x0 h3 y2 ff15e fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 ff164 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y7a ff164 fs6 fc0 sc0 ls21 wsb">} catch(ex){ </div><div class="t m0 x0 hb y7b ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y7c ff164 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y2d01 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y487a ff161 fs2 fc0 sc0 ls8 ws1">以上代码的输出结果如下： </div><div class="t m0 x0 hb y4c77 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4c78 ff164 fs6 fc0 sc0 ls21 wsb">0:red </div><div class="t m0 x0 hb y4c79 ff164 fs6 fc0 sc0 ls21 wsb">1:green </div><div class="t m0 x0 hb y4c7a ff164 fs6 fc0 sc0 ls21 wsb">2:blue </div><div class="t m0 x0 hb y4c7b ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y263f ff161 fs2 fc0 sc0 ls8 ws1">如果你只想让next()方法返回对象的属性名或者数组的索引值，可以在创建迭代器时为Iterator</div><div class="t m0 x0 h5 y4c7c ff161 fs2 fc0 sc0 ls8 ws1">构造函数传入第二个参数true，如下所示： </div><div class="t m0 x0 hb y3add ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4c7d ff164 fs6 fc0 sc0 ls21 wsb">var iterator = new Iterator(colors, true); </div><div class="t m0 x0 hb y4c7e ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y9e8 ff161 fs2 fc0 sc0 ls8 ws1">在这样创建的迭代器上每次调用next()方法，只会返回数组中每个值的索引，而不会返回包含索</div><div class="t m0 x0 h5 y1b18 ff161 fs2 fc0 sc0 ls8 ws1">引和值数组。 </div><div class="t m0 x5 ha y4c7f ff15d fs2 fc0 sc0 ls8 ws14">如果想为自定义类型创建迭代器，需要定义一个特殊的方法__iterator__()，</div><div class="t m0 x0 ha y4c80 ff15d fs2 fc0 sc0 ls8 ws14">这个方法应该返回一个包含next()方法的对象。当把自定义类型传给Iterator构</div><div class="t m0 x0 h5 y4c81 ff15d fs2 fc0 sc0 ls8 ws14">造函数时，就会调用那个特殊的方法。 </div><div class="t m0 x0 h20 y33c ff162 fs3 fc0 sc0 ls283 ws34b">A.3.2 数组领悟 </div><div class="t m0 x0 h5 y4c82 ff161 fs2 fc0 sc0 ls24">所谓数组领悟（array comprehensions），指的是用一组符合某个条件的值来初始化数组。Harmony</div><div class="t m0 x0 h5 y1e51 ff161 fs2 fc0 sc0 ls8 ws1">定义的这项功能借鉴了Python中流行的一个语言结构。JavaScript中数组领悟的基本形式如下： </div><div class="t m0 x0 hb y4c83 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4c84 ff169 fs6 fc0 sc0 ls21">array = [ value for each (variable in values) condition ]; </div><div class="t m0 x0 hb y4c85 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y90d ff161 fs2 fc0 sc0 ls8 ws1">其中，value是实际会包含在数组中的值，它源自values数组。for each 结构会循环values</div><div class="t m0 x0 h4 y90e ff161 fs2 fc0 sc0 ls8 ws1">中的每一个值，并将每个值保存在变量variable中。如果保存在variable中的值符合 condition</div><div class="t m0 x0 h5 y4c86 ff161 fs2 fc0 sc0 ls8 ws1">条件，就会将这个值添加到结果数组中。下面是一个例子。 </div><div class="t m0 x0 hb y3fdf ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4c87 ff164 fs6 fc0 sc0 ls21">//原始数组 </div><div class="t m0 x0 hb y4c88 ff164 fs6 fc0 sc0 ls21 wsb">var numbers = [0,1,2,3,4,5,6,7,8,9,10]; </div><div class="t m0 x0 hb y4c89 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4c8a ff164 fs6 fc0 sc0 ls21">//把所有元素复制到新数组 </div><div class="t m0 x0 hb y4c8b ff164 fs6 fc0 sc0 ls21 wsb">var duplicate = [i for each (i in numbers)]; </div><div class="t m0 x0 hb y4c8c ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4c8d ff164 fs6 fc0 sc0 ls21">//只把偶数复制到新数组 </div><div class="t m0 x0 hb y4c8e ff164 fs6 fc0 sc0 ls21 wsb">var evens = [i for each (i in numbers) if (i % 2 == 0)]; </div><div class="t m0 x0 hb y4c8f ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4c90 ff164 fs6 fc0 sc0 ls21">//把每个数乘以2后的结果放到新数组中 </div><div class="t m0 x0 hb y4c91 ff164 fs6 fc0 sc0 ls21 wsb">var doubled = [i*2 for each (i in numbers)]; </div><div class="t m0 x0 hb y4c92 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4c93 ff164 fs6 fc0 sc0 ls21">//把每个奇数乘以3后的结果放到新数组中 </div><div class="t m0 x0 hb y4c94 ff164 fs6 fc0 sc0 ls21 wsb">var tripledOdds = [i*3 for each (i in numbers) if (i % 2 &gt; 0)]; </div><div class="t m0 x0 h5 ya30 ff15e fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y4c95 ff161 fs2 fc0 sc0 ls42 ws30">在以上代码的数组领悟部分，我们使用变量i迭代了numbers中的所有值，而其中一些语句给出了</div><div class="t m0 x0 h4 y4c96 ff161 fs2 fc0 sc0 ls42 ws30">条件，以筛选最终包含在数组中的结果。本质上讲，只要条件求值为true，该值就会添加到数组中。与</div><div class="t m0 x0 hc y4c97 ff161 fs2 fc0 sc0 ls42 ws30">自己编写同样功能的for循环相比，数组领悟的语法稍有不同，但却更加简洁。Firefox 2+是唯一支持数</div></div></div>
<div id="pf2d5" class="pf w0 h0" data-page-no="2d5"><div class="pc pc2d5 w0 h0"><div class="t m0 x4 h2 y1 ff15d fs0 fc0 sc0 ls8 ws256">附录A ECMAScript Harmony  707 </div><div class="t m0 x0 h3 y2 ff15e fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff15f fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff15f fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ff15f fs3 fc2 sc0 ls1d wsb">16 </div><div class="t m0 x3 h8 y20 ff15f fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff15f fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff15f fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff15f fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff15f fs3 fc2 sc0 ls1d wsb">20 </div><div class="t m0 x3 h8 y25 ff15f fs3 fc2 sc0 ls1d wsb">21 </div><div class="t m0 x3 h8 y26 ff15f fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff15f fs3 fc2 sc0 ls1d wsf">23 </div><div class="t m0 x3 h8 ya7a ff15f fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff15f fs3 fc2 sc0 ls1d wsf">25 </div><div class="t m0 x0 h4 y3 ff161 fs2 fc0 sc0 ls57 wsa9">组领悟的浏览器，而且要使用这个功能，必须将&lt;script&gt;的type属性值指定为&quot;application/ </div><div class="t m0 x0 h21 ye26 ff164 fs1 fc0 sc0 ls43 ws31">javascript;version=1.7&quot;。 </div><div class="t m0 x5 h1d y4c98 ff15d fs2 fc0 sc0 ls8 ws14">数组领悟语法的values也可以是一个生成器或者一个迭代器。 </div><div class="t m0 x0 h20 y4c99 ff162 fs3 fc0 sc0 ls283 ws34b">A.3.3 解构赋值 </div><div class="t m0 x0 h4 y4c9a ff161 fs2 fc0 sc0 ls8 ws1">从一组值中挑出一或多个值，然后把它们分别赋给独立的变量，这也是一个很常见的需求。就拿迭</div><div class="t m0 x0 h4 y4c9b ff161 fs2 fc0 sc0 ls8 ws1">代器的next()方法返回的数组来说，假设这个数组包含着对象中一个属性的名称和值。为了把这个属</div><div class="t m0 x0 h5 y2e08 ff161 fs2 fc0 sc0 ls8 ws1">性和值分别保存在各自的变量中，需要写两个语句，如下所示。 </div><div class="t m0 x0 hb y4c9c ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4c9d ff164 fs6 fc0 sc0 ls21 wsb">var nextValue = [&quot;color&quot;, &quot;red&quot;]; </div><div class="t m0 x0 hb y4c9e ff164 fs6 fc0 sc0 ls21 wsb">var name = nextValue[0]; </div><div class="t m0 x0 hb y4c9f ff164 fs6 fc0 sc0 ls21 wsb">var value = nextValue[1]; </div><div class="t m0 x0 hb y4ca0 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y47ce ff161 fs2 fc0 sc0 ls8 ws1">而使用解构赋值（destructuring assignments）语法，用一条语句即可解决问题： </div><div class="t m0 x0 hb y646 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4ca1 ff164 fs6 fc0 sc0 ls21 wsb">var [name, value] = [&quot;color&quot;, &quot;red&quot;]; </div><div class="t m0 x0 hb y4ca2 ff164 fs6 fc0 sc0 ls21 wsb">alert(name);     //&quot;color&quot; </div><div class="t m0 x0 hb y4ca3 ff164 fs6 fc0 sc0 ls21 wsb">alert(value);    //&quot;red&quot; </div><div class="t m0 x0 hb y4ca4 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y4ca5 ff161 fs2 fc0 sc0 ls8 ws1">在传统的JavaScript中，数组字面量是不能出现在等于号（赋值操作符）左边的。解构赋值的这种</div><div class="t m0 x0 h4 y9ef ff161 fs2 fc0 sc0 ls8 ws1">语法表示的是把等于号右边数组中包含的值，分别赋给等于号左边数组中的变量。结果就是变量name</div><div class="t m0 x0 h5 y3bb ff161 fs2 fc0 sc0 ls8 ws1">的值为&quot;color&quot;，变量value的值为&quot;red&quot;。 </div><div class="t m0 x0 h5 y4ca6 ff161 fs2 fc0 sc0 ls8 ws1">如果你不想取得数组中所有的值，可以只在数组字面量中给出对应的变量，比如： </div><div class="t m0 x0 hb y3824 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4ca7 ff164 fs6 fc0 sc0 ls21 wsb">var [, value] = [&quot;color&quot;, &quot;red&quot;]; </div><div class="t m0 x0 hb y4ca8 ff164 fs6 fc0 sc0 ls21 wsb">alert(value);   //&quot;red&quot; </div><div class="t m0 x0 hb y4ca9 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y4caa ff161 fs2 fc0 sc0 ls8 ws1">这样就只会给变量value赋值，值为&quot;red&quot;。 </div><div class="t m0 x0 h5 y4cab ff161 fs2 fc0 sc0 ls8 ws1">有了解构赋值，还可做点有创意的事儿，比如交换变量的值。在ECMAScript 3中，要交换两个变</div><div class="t m0 x0 h5 y4cac ff161 fs2 fc0 sc0 ls8 ws1">量的值，一般是要这样写代码的： </div><div class="t m0 x0 hb y3f2e ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4cad ff164 fs6 fc0 sc0 ls21 wsb">var value1 = 5; </div><div class="t m0 x0 hb y4cae ff164 fs6 fc0 sc0 ls21 wsb">var value2 = 10; </div><div class="t m0 x0 hb y4caf ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4cb0 ff164 fs6 fc0 sc0 ls21 wsb">var temp = value1; </div><div class="t m0 x0 hb y4cb1 ff164 fs6 fc0 sc0 ls21 wsb">value1 = value2; </div><div class="t m0 x0 hb y4cb2 ff164 fs6 fc0 sc0 ls21 wsb">value2 = temp; </div><div class="t m0 x0 hb y4cb3 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y224f ff161 fs2 fc0 sc0 ls8 ws1">利用解构后的数组赋值，可以省掉那个临时变量temp，比如： </div><div class="t m0 x0 hb y4cb4 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4cb5 ff164 fs6 fc0 sc0 ls21 wsb">var value1 = 5; </div><div class="t m0 x0 hb y4cb6 ff164 fs6 fc0 sc0 ls21 wsb">var value2 = 10; </div><div class="t m0 x0 hb y4cb7 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4cb8 ff164 fs6 fc0 sc0 ls21 wsb">[value2, value1] = [value1, value2]; </div><div class="t m0 x0 hb y4cb9 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y4cba ff161 fs2 fc0 sc0 ls8 ws1">解构赋值同样适用于对象，看下面这个例子： </div><div class="t m0 x0 hb y4cbb ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4cbc ff164 fs6 fc0 sc0 ls21 wsb">var person = { </div><div class="t m0 x0 hb y4cbd ff164 fs6 fc0 sc0 ls21 wsb">    name: &quot;Nicholas&quot;, </div><div class="t m0 x0 hb y4cbe ff164 fs6 fc0 sc0 ls21 wsb">    age: 29 </div><div class="t m0 x0 hb y4cbf ff164 fs6 fc0 sc0 ls21 wsb">};  </div></div></div>
<div id="pf2d6" class="pf w0 h0" data-page-no="2d6"><div class="pc pc2d6 w0 h0"><div class="t m0 x0 h2 y1 ff15e fs0 fc0 sc0 ls7 ws0">708  附录A ECMAScript Harmony </div><div class="t m0 x0 h3 y2 ff15e fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y7a ff164 fs6 fc0 sc0 ls21 wsb">var { name: personName, age: personAge } = person; </div><div class="t m0 x0 hb y7b ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y7c ff164 fs6 fc0 sc0 ls21 wsb">alert(personName); //&quot;Nicholas&quot; </div><div class="t m0 x0 hb y7d ff164 fs6 fc0 sc0 ls21 wsb">alert(personAge);  //29 </div><div class="t m0 x0 hb yaab ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y715 ff161 fs2 fc0 sc0 ls8 ws1">与使用数组字面量一样，看到等于号左边出现了对象字面量，那就是解构赋值表达式。这条语句实</div><div class="t m0 x0 h1e y716 ff161 fs2 fc0 sc0 ls8 ws1">际上定义了两个变量，personName和personAge，它们分别得到了person对象中对应的值。与数</div><div class="t m0 x0 h5 y4cc0 ff161 fs2 fc0 sc0 ls8 ws1">组解构赋值一样，在对象解构赋值中也可以选择要取得的值，比如： </div><div class="t m0 x0 hb y237d ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4cc1 ff164 fs6 fc0 sc0 ls21 wsb">var { age: personAge } = person; </div><div class="t m0 x0 hb y4cc2 ff164 fs6 fc0 sc0 ls21 wsb">alert(personAge); //29 </div><div class="t m0 x0 hb y4cc3 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y1995 ff161 fs2 fc0 sc0 ls8 ws1">以上代码只取得了person对象中age属性的值，将它赋给了变量 personAge。 </div><div class="t m0 x0 hd y4cc4 ff162 fs7 fc0 sc0 ls4d3 ws467">A.4 新对象类型 </div><div class="t m0 x0 h5 y112 ff15e fs2 fc0 sc0 ls138 ws133">Harmony为JavaScript定义了几个新的对象类型。这几个新类型提供了以前只有JavaScript引擎才能</div><div class="t m0 x0 h5 y4cc5 ff161 fs2 fc0 sc0 ls8 ws1">使用的功能。 </div><div class="t m0 x0 h20 y4cc6 ff162 fs3 fc0 sc0 ls283 ws34b">A.4.1 代理对象 </div><div class="t m0 x0 h5 y2917 ff15e fs2 fc0 sc0 ls138 ws133">Harmony为JavaScript引入了代理的概念。所谓代理（proxy），就是一个表示接口的对象，对它的</div><div class="t m0 x0 h4 y12ca ff161 fs2 fc0 sc0 ls8 ws1">操作不一定作用在代理对象本身。举个例子，设置代理对象的一个属性，实际上可能会在另一个对象上</div><div class="t m0 x0 h5 y29cb ff161 fs2 fc0 sc0 ls8 ws1">调用一个函数。代理是一种非常有用的抽象机制，能够通过API只公开部分信息，同时还能对数据源进</div><div class="t m0 x0 h5 y4cc7 ff161 fs2 fc0 sc0 ls8 ws1">行全面控制。 </div><div class="t m0 x0 h4b y4cc8 ff161 fs2 fc0 sc0 ls8 ws1">要创建代理对象，可以使用Proxy.create()方法，传入一个handler（处理程序）对象和一个</div><div class="t m0 x0 hc y291b ff161 fs2 fc0 sc0 ls8 ws1">可选的prototype（原型）对象： </div><div class="t m0 x0 hb y1fef ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4cc9 ff164 fs6 fc0 sc0 ls21 wsb">var proxy = Proxy.create(handler); </div><div class="t m0 x0 hb y4cca ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4ccb ff164 fs6 fc0 sc0 ls21">//创建一个以myObject为原型的代理对象 </div><div class="t m0 x0 hb y4ccc ff164 fs6 fc0 sc0 ls21 wsb">var proxy = Proxy.create(handler, myObject); </div><div class="t m0 x0 h5 y10cd ff15e fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h2e y4ccd ff161 fs2 fc0 sc0 ls8 ws1">其中，handler对象包含用于定义捕捉器（trap）的属性。捕捉器本身是函数，用于处理（捕捉）</div><div class="t m0 x0 h4 y2867 ff161 fs2 fc0 sc0 ls8 ws1">原生功能，以便该功能能够以另一种方式来处理。要确保代理对象能够按照预期工作，至少要实现以下</div><div class="t m0 x0 h5 y4cce ff15e fs2 fc0 sc0 ls38">7种基本的捕捉器。 </div><div class="t m0 x0 h4 y4ccf ff16a fs1 fc0 sc0 ls8 ws134"> getOwnPropertyDescriptor：当在代理对象上调用Object.getOwnPropertyDescriptor()</div><div class="t m0 x0 h4 y3a8c ff161 fs2 fc0 sc0 ls42 ws30">时调用的函数。这个函数以接收到的属性名作为参数，返回属性描述符，或者在属性不存在时返</div><div class="t m0 x0 hc y4cd0 ff161 fs2 fc0 sc0 ls160">回null。 </div><div class="t m0 x0 h4 y4571 ff16a fs1 fc0 sc0 ls2"> getPropertyDescriptor：当在代理对象上调用Object.getPropertyDescriptor()时调</div><div class="t m0 x0 h5 y286c ff161 fs2 fc0 sc0 ls8 ws1">用的函数。（这是Harmony中的新方法。）这个函数以接收到的属性名作为参数，返回属性描述</div><div class="t m0 x0 hc y19d9 ff161 fs2 fc0 sc0 ls8 ws1">符，或者在属性不存在时返回null。 </div><div class="t m0 x0 h4 y1eab ff16a fs1 fc0 sc0 ls2"> getOwnPropertyNames：当在代理对象上调用Object.getOwnPropertyNames ()时调用的</div><div class="t m0 x0 h5 y19db ff161 fs2 fc0 sc0 ls8 ws1">函数。这个函数以接收到的属性名作为参数，应该返回一个字符串数组。 </div><div class="t m0 x0 h4 y1338 ff16a fs1 fc0 sc0 ls2"> getPropertyNames：当在代理对象上调用Object.getPropertyNames ()时调用的函数。</div><div class="t m0 x0 h5 y4cd1 ff161 fs2 fc0 sc0 ls8 ws1">（这是Harmony中的新方法。）这个函数以接收到的属性名作为参数，应该返回一个字符串数组。 </div></div></div>
<div id="pf2d7" class="pf w0 h0" data-page-no="2d7"><div class="pc pc2d7 w0 h0"><div class="t m0 x4 h2 y1 ff15d fs0 fc0 sc0 ls8 ws256">附录A ECMAScript Harmony  709 </div><div class="t m0 x0 h3 y2 ff15e fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff15f fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff15f fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ff15f fs3 fc2 sc0 ls1d wsb">16 </div><div class="t m0 x3 h8 y20 ff15f fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff15f fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff15f fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff15f fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff15f fs3 fc2 sc0 ls1d wsb">20 </div><div class="t m0 x3 h8 y25 ff15f fs3 fc2 sc0 ls1d wsb">21 </div><div class="t m0 x3 h8 y26 ff15f fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff15f fs3 fc2 sc0 ls1d wsf">23 </div><div class="t m0 x3 h8 ya7a ff15f fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff15f fs3 fc2 sc0 ls1d wsf">25 </div><div class="t m0 x0 h4 y3 ff16a fs1 fc0 sc0 ls2"> defineProperty：当在代理对象上调用Object.defineProperty()时调用的函数。这个函</div><div class="t m0 x5 h5 y4d ff161 fs2 fc0 sc0 ls8 ws1">数以接收到的属性名和属性描述符作为参数。 </div><div class="t m0 x0 h4 y4e ff16a fs1 fc0 sc0 ls2"> delete：定义在对象属性上使用delete操作符时调用的函数。属性名以参数形式传进来，如</div><div class="t m0 x5 h5 yd9 ff161 fs2 fc0 sc0 ls8 ws1">果删除成功则返回true，删除失败返回false。 </div><div class="t m0 x0 h4 y219 ff16a fs1 fc0 sc0 ls2"> fix：当调用Object.freeze()、Object.seal()或Object.preventExtensions()时调</div><div class="t m0 x5 hc y21a ff161 fs2 fc0 sc0 ls8 ws1">用的函数。当在代理对象上调用这几个方法时，返回undefined以抛出错误。 </div><div class="t m0 x0 h5 y15e ff161 fs2 fc0 sc0 ls8 ws1">除了这7个基本的捕捉器，还有6个派生的捕捉器（derived trap）。与基本捕捉器不同，少定义一个</div><div class="t m0 x0 h5 y1561 ff161 fs2 fc0 sc0 ls8 ws1">或几个派生捕捉器不会导致错误。每个派生的捕捉器都会覆盖一种默认的JavaScript行为。 </div><div class="t m0 x0 h4 yb ff16a fs1 fc0 sc0 ls2"> has在对象上使用in操作符（例如&quot;name&quot; in object）时调用的函数。以接收到的属性名作</div><div class="t m0 x5 hc y78a ff161 fs2 fc0 sc0 ls8 ws1">为参数，返回true表示对象包含该属性，否则返回false。 </div><div class="t m0 x0 h4 yd ff16a fs1 fc0 sc0 ls2"> hasOwn：在代理对象上调用hasOwnProperty()方法时调用的函数。以接收到的属性名作为参</div><div class="t m0 x5 hc ye ff161 fs2 fc0 sc0 ls8 ws1">数，返回true表示对象包含该属性，否则返回false。 </div><div class="t m0 x0 h4 y21c ff16a fs1 fc0 sc0 ls2"> get：在读取属性时调用的函数。这个函数接收两个参数，即包含被读属性的对象的引用及属性</div><div class="t m0 x5 h5 y116c ff161 fs2 fc0 sc0 ls8 ws1">名。这个对象引用可能是代理对象本身，也可能是继承了代理对象的对象。 </div><div class="t m0 x0 h4 y11 ff16a fs1 fc0 sc0 ls8 ws134"> set：在写入属性时调用的函数。这个函数接收三个参数，即包含被写属性的对象的引用、属性名</div><div class="t m0 x5 hc y12 ff161 fs2 fc0 sc0 ls1f ws15">和属性值。与get类似，这个对象引用可能是代理对象本身，也可能是继承了代理对象的对象。 </div><div class="t m0 x0 h4 y13 ff16a fs1 fc0 sc0 ls2"> enumerate：当代理对象被放在for-in循环中时调用的函数。这个函数必须返回一个字符串</div><div class="t m0 x5 hc y14 ff161 fs2 fc0 sc0 ls8 ws1">数组，其中包含在for-in循环中使用的相应属性名。 </div><div class="t m0 x0 h4 y38f3 ff16a fs1 fc0 sc0 ls2"> keys：当在代理对象上调用Object.keys()时调用的函数。与enumerate类似，这个函数也</div><div class="t m0 x5 h5 y2df2 ff161 fs2 fc0 sc0 ls8 ws1">必须返回一个字符串数组。 </div><div class="t m0 x0 h5 y2df3 ff161 fs2 fc0 sc0 ls8 ws1">在需要公开API，而同时又要避免使用者直接操作底层数据的时候，可以使用代理。例如，假设你</div><div class="t m0 x0 h1c y4cd2 ff161 fs2 fc0 sc0 ls8 ws1">想实现一个传统的栈数据类型。虽然数组可以作为栈来使用，但你想保证人们只使用push()、pop()</div><div class="t m0 x0 h5 yc4 ff161 fs2 fc0 sc0 ls2c">和length。在这种情况下，就可以基于数组创建一个代理对象，只对外公开这三个对象成员。 </div><div class="t m0 x0 hb y119 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4cd3 ff164 fs6 fc0 sc0 ls21 wsb">/* </div><div class="t m0 x0 h16 y4cd4 ff164 fs6 fc0 sc0 ls16f">*实验ES 6代理对象。这个实验在数组的基础上创建一个栈数据结构。 </div><div class="t m0 x0 h16 y4cd5 ff164 fs6 fc0 sc0 ls16f">*代理在此用于从接口过滤&quot;push&quot;、&quot;pop&quot;和&quot;length&quot;之外的成员，让数组成为一个纯粹的栈， </div><div class="t m0 x0 h16 y4cd6 ff164 fs6 fc0 sc0 ls16f">*任何人不能直接操作其内容。 </div><div class="t m0 x0 hb y4cd7 ff164 fs6 fc0 sc0 ls21 wsb">*/ </div><div class="t m0 x0 hb y4cd8 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4cd9 ff164 fs6 fc0 sc0 ls21 wsb">var Stack = (function(){ </div><div class="t m0 x0 hb y4cda ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4cdb ff164 fs6 fc0 sc0 ls21 wsb">    var stack = [], </div><div class="t m0 x0 hb y4cdc ff164 fs6 fc0 sc0 ls21 wsb">        allowed = [&quot;push&quot;, &quot;pop&quot;, &quot;length&quot; ]; </div><div class="t m0 x0 hb y4cdd ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4cde ff164 fs6 fc0 sc0 ls21 wsb">    return Proxy.create({ </div><div class="t m0 x0 hb y4cdf ff164 fs6 fc0 sc0 ls21 wsb">        get: function(receiver, name){; </div><div class="t m0 x0 hb y4ce0 ff164 fs6 fc0 sc0 ls21 wsb">            if (allowed.indexOf(name) &gt; -1){ </div><div class="t m0 x0 hb y4ce1 ff164 fs6 fc0 sc0 ls21 wsb">                if(typeof stack[name] == &quot;function&quot;){ </div><div class="t m0 x0 hb y4ce2 ff164 fs6 fc0 sc0 ls21 wsb">                    return stack[name].bind(stack); </div><div class="t m0 x0 hb y4ce3 ff164 fs6 fc0 sc0 ls21 wsb">                } else { </div><div class="t m0 x0 hb y4ce4 ff164 fs6 fc0 sc0 ls21 wsb">                    return stack[name]; </div><div class="t m0 x0 hb y4ce5 ff164 fs6 fc0 sc0 ls21 wsb">                } </div><div class="t m0 x0 hb y4ce6 ff164 fs6 fc0 sc0 ls21 wsb">            } else { </div><div class="t m0 x0 hb y4ce7 ff164 fs6 fc0 sc0 ls21 wsb">                return undefined; </div><div class="t m0 x0 hb y4ce8 ff164 fs6 fc0 sc0 ls21 wsb">            } </div><div class="t m0 x0 hb y4ce9 ff164 fs6 fc0 sc0 ls21 wsb">        } </div></div></div>
<div id="pf2d8" class="pf w0 h0" data-page-no="2d8"><div class="pc pc2d8 w0 h0"><div class="t m0 x0 h2 y1 ff15e fs0 fc0 sc0 ls7 ws0">710  附录A ECMAScript Harmony </div><div class="t m0 x0 h3 y2 ff15e fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 ff164 fs6 fc0 sc0 ls21 wsb">    }); </div><div class="t m0 x0 hb y7a ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y7b ff164 fs6 fc0 sc0 ls21 wsb">}); </div><div class="t m0 x0 hb y7c ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y7d ff164 fs6 fc0 sc0 ls21 wsb">var mystack = new Stack(); </div><div class="t m0 x0 hb y7e ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y7f ff164 fs6 fc0 sc0 ls21 wsb">mystack.push(&quot;hi&quot;); </div><div class="t m0 x0 hb y80 ff164 fs6 fc0 sc0 ls21 wsb">mystack.push(&quot;goodbye&quot;); </div><div class="t m0 x0 hb y81 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y82 ff164 fs6 fc0 sc0 ls21 wsb">console.log(mystack.length);  //1 </div><div class="t m0 x0 hb y83 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y84 ff164 fs6 fc0 sc0 ls21 wsb">console.log(mystack[0]);      //未定义 </div><div class="t m0 x0 hb y85 ff164 fs6 fc0 sc0 ls21 wsb">console.log(mystack.pop());   //&quot;goodbye&quot; </div><div class="t m0 x0 h5 y11b1 ff15e fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h177 y4cea ff161 fs2 fc0 sc0 ls8 ws1">以上代码创建了一个构造函数Stack。但它没有使用this，而是返回了一个对数组操作进行包装</div><div class="t m0 x0 h1e y3cfc ff161 fs2 fc0 sc0 ls8 ws1">的代理对象。这个代理对象只定义了一个get捕捉器，该函数检测了一组允许的属性，然后才返回相应</div><div class="t m0 x0 h1e y4ceb ff161 fs2 fc0 sc0 ls8 ws1">的值。如果引用的是不被允许的属性，那么捕捉器就返回undefined；如果引用的是push()、pop()</div><div class="t m0 x0 h4 y2e57 ff161 fs2 fc0 sc0 ls2c">和length，则一切正常。这里的关键是get捕捉器，它根据允许的成员过滤了对象的成员。如果该成</div><div class="t m0 x0 h5 y4cec ff161 fs2 fc0 sc0 ls8 ws1">员是函数，就返回一个与底层数组对象绑定的函数，这样操作针对的就是数组而非代理对象。 </div><div class="t m0 x0 h20 y26b3 ff162 fs3 fc0 sc0 ls283 ws34b">A.4.2 代理函数 </div><div class="t m0 x0 h5 y134b ff161 fs2 fc0 sc0 ls8 ws1">除了创建代理对象之外，Harmony还支持创建代理函数（proxy function）。代理函数与代理对象的</div><div class="t m0 x0 h1e y4ced ff161 fs2 fc0 sc0 ls8 ws1">区别是它可以执行。要创建代理函数，可以调用Proxy.createFunction()方法，传入一个handler</div><div class="t m0 x0 h5 y4cee ff161 fs2 fc0 sc0 ls8 ws1">（处理程序）对象、一个调用捕捉器函数和一个可选的构造函数捕捉器函数。例如： </div><div class="t m0 x0 hb y4cef ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4cf0 ff164 fs6 fc0 sc0 ls21 wsb">var proxy = Proxy.createFunction(handler, function(){}, function(){}); </div><div class="t m0 x0 hb y4cf1 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y2614 ff161 fs2 fc0 sc0 lsa ws53">与代理对象一样，handler对象也有同样多的捕捉器。调用捕捉器函数是在代理函数执行（如</div><div class="t m0 x0 h4 y340 ff164 fs1 fc0 sc0 ls9 ws2">proxy()）时运行的代码。构造函数捕捉器是在用new操作符调用代理函数（如new proxy()）时运</div><div class="t m0 x0 h5 y4cf2 ff161 fs2 fc0 sc0 ls8 ws1">行的代码。如果没有指定构造函数捕捉器，则使用调用捕捉器作为构造函数。 </div><div class="t m0 x0 h20 y4cf3 ff162 fs3 fc0 sc0 ls283 ws34b">A.4.3 映射与集合 </div><div class="t m0 x0 h4 y1981 ff164 fs1 fc0 sc0 ls9 ws2">Map类型，也称为简单映射，只有一个目的：保存一组键值对儿。开发人员通常都使用普通对象来</div><div class="t m0 x0 h4 y4cf4 ff161 fs2 fc0 sc0 ls8 ws1">保存键值对儿，但问题是那样做会导致键容易与原生属性混淆。简单映射能做到键和值与对象属性分离，</div><div class="t m0 x0 h5 y2e66 ff161 fs2 fc0 sc0 ls8 ws1">从而保证对象属性的安全存储。以下是使用简单映射的几个例子。 </div><div class="t m0 x0 hb y77f ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4cf5 ff164 fs6 fc0 sc0 ls21 wsb">var map = new Map(); </div><div class="t m0 x0 hb y4cf6 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4cf7 ff164 fs6 fc0 sc0 ls21 wsb">map.set(&quot;name&quot;, &quot;Nicholas&quot;); </div><div class="t m0 x0 hb y4cf8 ff164 fs6 fc0 sc0 ls21 wsb">map.set(&quot;book&quot;, &quot;Professional JavaScript&quot;); </div><div class="t m0 x0 hb y4cf9 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4cfa ff164 fs6 fc0 sc0 ls21 wsb">console.log(map.has(&quot;name&quot;)); //true </div><div class="t m0 x0 hb y4cfb ff164 fs6 fc0 sc0 ls21 wsb">console.log(map.get(&quot;name&quot;)); //&quot;Nicholas&quot; </div><div class="t m0 x0 hb y4cfc ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4cfd ff164 fs6 fc0 sc0 ls21 wsb">map.delete(&quot;name&quot;); </div><div class="t m0 x0 hb y4cfe ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y4cff ff161 fs2 fc0 sc0 ls8 ws1">简单映射的基本API包括get()、set()和delete()，每个方法的作用看名字就知道了。键可以</div><div class="t m0 x0 h5 y4d00 ff161 fs2 fc0 sc0 ls8 ws1">是原始值，也可是引用值。 </div><div class="t m0 x0 h1e y4d01 ff161 fs2 fc0 sc0 ls8 ws1">与简单映射相关的是Set类型。集合就是一组不重复的元素。与简单映射不同的是，集合中只有键，</div></div></div>
<div id="pf2d9" class="pf w0 h0" data-page-no="2d9"><div class="pc pc2d9 w0 h0"><div class="t m0 x4 h2 y1 ff15d fs0 fc0 sc0 ls8 ws256">附录A ECMAScript Harmony  711 </div><div class="t m0 x0 h3 y2 ff15e fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff15f fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff15f fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ff15f fs3 fc2 sc0 ls1d wsb">16 </div><div class="t m0 x3 h8 y20 ff15f fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff15f fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff15f fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff15f fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff15f fs3 fc2 sc0 ls1d wsb">20 </div><div class="t m0 x3 h8 y25 ff15f fs3 fc2 sc0 ls1d wsb">21 </div><div class="t m0 x3 h8 y26 ff15f fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff15f fs3 fc2 sc0 ls1d wsf">23 </div><div class="t m0 x3 h8 ya7a ff15f fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff15f fs3 fc2 sc0 ls1d wsf">25 </div><div class="t m0 x0 h4 y3 ff161 fs2 fc0 sc0 ls8 ws1">没有与键关联的值。在集合中，添加元素要使用add()方法，检查元素是否存在要使用has()方法，而</div><div class="t m0 x0 hc y4d ff161 fs2 fc0 sc0 ls8 ws1">删除元素要使用delete()方法。以下是基本的使用示例。 </div><div class="t m0 x0 hb y1701 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2984 ff164 fs6 fc0 sc0 ls21 wsb">var set = new Set(); </div><div class="t m0 x0 hb y2985 ff164 fs6 fc0 sc0 ls21 wsb">set.add(&quot;name&quot;); </div><div class="t m0 x0 hb y2986 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y2987 ff164 fs6 fc0 sc0 ls21 wsb">console.log(set.has(&quot;name&quot;)); //true </div><div class="t m0 x0 hb y2988 ff164 fs6 fc0 sc0 ls21 wsb">set.delete(&quot;name&quot;); </div><div class="t m0 x0 hb y2989 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y298a ff164 fs6 fc0 sc0 ls21 wsb">console.log(set.has(&quot;name&quot;)); //false </div><div class="t m0 x0 hb y4d02 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y522 ff161 fs2 fc0 sc0 ls8 ws1">截止到2011年10月，规范中关于Map和Set 的内容还没有最后定稿。因此，在JavaScript引擎实</div><div class="t m0 x0 h5 y4d03 ff161 fs2 fc0 sc0 ls8 ws1">现该规范时，有些细节可能会发生变化。 </div><div class="t m0 x0 h20 y4d04 ff162 fs3 fc0 sc0 ls283 ws34b">A.4.4 WeakMap </div><div class="t m0 x0 h5 y4d05 ff164 fs1 fc0 sc0 ls9 ws2">WeakMap是ECMAScript中唯一一个能让你知道什么时候对象已经完全解除引用的类型。WeakMap</div><div class="t m0 x0 h4 y71e ff161 fs2 fc0 sc0 ls6 ws6">与简单映射很相似，也是用来保存键值对儿的。它们的主要区别在于，WeakMap的键必须是对象，而</div><div class="t m0 x0 hc y71f ff161 fs2 fc0 sc0 ls8 ws1">在对象已经不存在时，相关的键值对儿就会从WeakMap中被删除。例如： </div><div class="t m0 x0 hb y4d06 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4d07 ff164 fs6 fc0 sc0 ls21 wsb">var key = {}, </div><div class="t m0 x0 hb y4d08 ff164 fs6 fc0 sc0 ls21 wsb">    map = new WeakMap(); </div><div class="t m0 x0 hb y4d09 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4d0a ff164 fs6 fc0 sc0 ls21 wsb">map.set(key, &quot;Hello!&quot;); </div><div class="t m0 x0 hb y4d0b ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4d0c ff164 fs6 fc0 sc0 ls21">//解除对键的引用，从而删除该值 </div><div class="t m0 x0 hb y4d0d ff164 fs6 fc0 sc0 ls21 wsb">key = null; </div><div class="t m0 x0 h5 y4d0e ff15e fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h2a y4d0f ff161 fs2 fc0 sc0 ls6 ws6">至于什么情况下适合使用WeakMap，目前还不清楚。不过，Java中倒是有一个相同的数据结构叫</div><div class="t m0 x0 h5 y43dc ff164 fs1 fc0 sc0 ls9 ws2">WeakHashMap；于是，JavaScript又多了一种数据类型。 </div><div class="t m0 x0 h20 y4d10 ff162 fs3 fc0 sc0 ls283 ws34b">A.4.5 StructType </div><div class="t m0 x0 h5 y2a3 ff15e fs2 fc0 sc0 lsb ws5">JavaScript一个最大的不足是使用一种数据类型表示所有数值。WebGL为解决这个问题引入了类型</div><div class="t m0 x0 h5 y4d11 ff161 fs2 fc0 sc0 ls24 ws1e">化数组，而ECMAScript 6则引入了类型化结构，为这门语言带来了更多的数值数据类型。结构类型</div><div class="t m0 x0 he y4d12 ff161 fs2 fc0 sc0 ls8 ws1">（StructType）与C语言中的结构类似；在C语言中，可以把多个属性组合成一条记录。对于JavaScript</div><div class="t m0 x0 h4 y4d13 ff161 fs2 fc0 sc0 ls8 ws1">的结构类型，通过指定属性及其保存的数据类型，也可以创建类似的数据结构。早期的实现定义了以下</div><div class="t m0 x0 h5 y2a7 ff161 fs2 fc0 sc0 ls8 ws1">几种块类型。 </div><div class="t m0 x0 h5 y4d14 ff16a fs1 fc0 sc0 ls2"> uint8：无符号8位整数。 </div><div class="t m0 x0 h5 y4d15 ff16a fs1 fc0 sc0 ls2"> int8：有符号8位整数。 </div><div class="t m0 x0 h5 y8bb ff16a fs1 fc0 sc0 ls2"> uint16：无符号16位整数。 </div><div class="t m0 x0 h5 y11a7 ff16a fs1 fc0 sc0 ls2"> int16：有符号16位整数。 </div><div class="t m0 x0 h5 y205c ff16a fs1 fc0 sc0 ls2"> uint32：无符号32位整数。 </div><div class="t m0 x0 h5 y2c58 ff16a fs1 fc0 sc0 ls2"> int32：有符号32位整数。 </div><div class="t m0 x0 h5 y11f5 ff16a fs1 fc0 sc0 ls2"> float32：32位浮点数。 </div><div class="t m0 x0 h5 y192f ff16a fs1 fc0 sc0 ls2"> float64：64位浮点数。 </div><div class="t m0 x0 h5 y11ac ff161 fs2 fc0 sc0 ls8 ws1">这些块类型都只能包含一个值。将来还有望在这8种类型基础上进一步扩展。 </div><div class="t m0 x0 he y21d4 ff161 fs2 fc0 sc0 ls8 ws1">要创建结构类型的对象，可以使用new操作符调用StructType，传入对象字面量形式的属性定义。 </div></div></div>
<div id="pf2da" class="pf w0 h0" data-page-no="2da"><div class="pc pc2da w0 h0"><div class="t m0 x0 h2 y1 ff15e fs0 fc0 sc0 ls7 ws0">712  附录A ECMAScript Harmony </div><div class="t m0 x0 h3 y2 ff15e fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 ff164 fs6 fc0 sc0 ls21 wsb">var Size = new StructType({ width: uint32, height: uint32 }); </div><div class="t m0 x0 h4 y4d16 ff161 fs2 fc0 sc0 ls8 ws1">以上代码创建了一个名为Size的新结构类型，该类型带有两个属性：width和height。这两个</div><div class="t m0 x0 h5 y4d17 ff161 fs2 fc0 sc0 ls8 ws1">属性都应该保存无符号32位整数。而变量Size 实际上是一个构造函数，可以像使用对象的构造函数</div><div class="t m0 x0 h5 y4d18 ff161 fs2 fc0 sc0 ls8 ws1">一样使用它。要实例化这个结构类型，需要向构造函数中传入一个带属性值的对象字面量。 </div><div class="t m0 x0 hb y1aa3 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4d19 ff164 fs6 fc0 sc0 ls21 wsb">var boxSize = new Size({ width: 80, height: 60 }); </div><div class="t m0 x0 hb y4d1a ff164 fs6 fc0 sc0 ls21 wsb">console.log(boxSize.width);  //80 </div><div class="t m0 x0 hb y4d1b ff164 fs6 fc0 sc0 ls21 wsb">console.log(boxSize.height); //60 </div><div class="t m0 x0 hb y4d1c ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y4d1d ff161 fs2 fc0 sc0 ls8 ws1">这样，就创建了Size的一个宽为80、高为60 的实例。实例的属性可以被读写，但始终都必须包</div><div class="t m0 x0 h5 y4d1e ff161 fs2 fc0 sc0 ls3b">含32位无符号整数。 </div><div class="t m0 x0 h5 y4d1f ff161 fs2 fc0 sc0 ls8 ws1">将属性定义为另一个结构类型，可以得到更复杂的结构类型。例如： </div><div class="t m0 x0 hb y1a05 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4d20 ff164 fs6 fc0 sc0 ls21 wsb">var Location = new StructType({ x: int32, y: int32 }); </div><div class="t m0 x0 hb y4d21 ff164 fs6 fc0 sc0 ls21 wsb">var Box = new StructType({ size: Size, location: Location }); </div><div class="t m0 x0 hb y4d22 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4d23 ff164 fs6 fc0 sc0 ls21 wsb">var boxInfo = new Box({ size: { width:80, height:60 }, location: { x: 0, y: 0 }}); </div><div class="t m0 x0 hb y4d24 ff164 fs6 fc0 sc0 ls21 wsb">console.log(boxInfo.size.width); //80 </div><div class="t m0 x0 hb y4d25 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y4d26 ff161 fs2 fc0 sc0 ls8 ws1">这个例子创建了一个简单的结构类型Location，又创建了一个复杂的结构类型Box。Box的属性</div><div class="t m0 x0 h4 y4d27 ff161 fs2 fc0 sc0 ls8 ws1">本身也是结构类型。Box构造函数仍然接收对象字面量参数，以便为每个属性定义值，但它会检查传入</div><div class="t m0 x0 h5 y4d28 ff161 fs2 fc0 sc0 ls8 ws1">值的数据类型，以确保作为属性值的数据类型正确。 </div><div class="t m0 x0 h20 y4d29 ff162 fs3 fc0 sc0 ls283 ws34b">A.4.6 ArrayType </div><div class="t m0 x0 h4 yfee ff161 fs2 fc0 sc0 ls8 ws1">与结构类型密切相关的是数组类型。通过数组类型（ArrayType）可以创建一个数组，并限制数组</div><div class="t m0 x0 h5 yfef ff161 fs2 fc0 sc0 lsa ws53">的值必须是某种特定的类型（与WebGL中的类型化数组很相似）。要创建新的数组类型，可以调用</div><div class="t m0 x0 h5 y4963 ff164 fs1 fc0 sc0 ls9 ws2">ArrayType构造函数，并传入它应该保存的数据类型以及应该保存的元素数目。例如： </div><div class="t m0 x0 hb yef ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4d2a ff164 fs6 fc0 sc0 ls21 wsb">var SizeArray = new ArrayType(Size, 2); </div><div class="t m0 x0 hb y4d2b ff164 fs6 fc0 sc0 ls21 wsb">var boxes = new BoxArray([ { width: 80, height: 60 }, { width: 50, height: 50 } ]); </div><div class="t m0 x0 hb y4d2c ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y80b ff161 fs2 fc0 sc0 ls8 ws1">以上代码创建了一个名为SizeArray的数组类型，这个数组类型只能保存Size 的实例，同时也</div><div class="t m0 x0 h4 y4d2d ff161 fs2 fc0 sc0 ls8 ws1">给数组分配了两个该实例的位置。要实例化数组类型，可以传入一个数组，其中包含应该转换的数据。</div><div class="t m0 x0 h4 y2a1e ff161 fs2 fc0 sc0 ls8 ws1">数据可以是字面量，只要该字面量能提升为正确的数据类型即可（比如在这个例子中，传入的字面量可</div><div class="t m0 x0 h5 y4d2e ff161 fs2 fc0 sc0 ls8 ws1">以提升为结构类型）。 </div><div class="t m0 x0 hd ycd ff162 fs7 fc0 sc0 ls4d3 ws467">A.5 类 </div><div class="t m0 x0 h5 y568 ff161 fs2 fc0 sc0 ls8 ws1">开发人员一直吵着要在JavaScript中增加一种语法，用于定义类似于Java的类。ECMAScript 6最终</div><div class="t m0 x0 h5 y4d2f ff161 fs2 fc0 sc0 ls8 ws1">确实定义了这种语法。但JavaScript中的类只是一种语法糖，覆盖在目前基于构造函数和基于原型的方</div><div class="t m0 x0 h5 yc2b ff161 fs2 fc0 sc0 ls8 ws1">式和类型之上。先看看下面的类型定义。 </div><div class="t m0 x0 hb y4d30 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4d31 ff164 fs6 fc0 sc0 ls21 wsb">function Person(name, age){ </div><div class="t m0 x0 hb y4d32 ff164 fs6 fc0 sc0 ls21 wsb">    this.name = name; </div><div class="t m0 x0 hb y4d33 ff164 fs6 fc0 sc0 ls21 wsb">    this.age = age; </div><div class="t m0 x0 hb y4d34 ff164 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y4d35 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4d36 ff164 fs6 fc0 sc0 ls21 wsb">Person.prototype.sayName = function(){ </div><div class="t m0 x0 hb y4d37 ff164 fs6 fc0 sc0 ls21 wsb">    alert(this.name); </div></div></div>
<div id="pf2db" class="pf w0 h0" data-page-no="2db"><div class="pc pc2db w0 h0"><div class="t m0 x4 h2 y1 ff15d fs0 fc0 sc0 ls8 ws256">附录A ECMAScript Harmony  713 </div><div class="t m0 x0 h3 y2 ff15e fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff15f fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff15f fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ff15f fs3 fc2 sc0 ls1d wsb">16 </div><div class="t m0 x3 h8 y20 ff15f fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff15f fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff15f fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff15f fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff15f fs3 fc2 sc0 ls1d wsb">20 </div><div class="t m0 x3 h8 y25 ff15f fs3 fc2 sc0 ls1d wsb">21 </div><div class="t m0 x3 h8 y26 ff15f fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff15f fs3 fc2 sc0 ls1d wsf">23 </div><div class="t m0 x3 h8 ya7a ff15f fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff15f fs3 fc2 sc0 ls1d wsf">25 </div><div class="t m0 x0 hb y79 ff164 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y7a ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y7b ff164 fs6 fc0 sc0 ls21 wsb">Person.prototype.getOlder = function(years){ </div><div class="t m0 x0 hb y7c ff164 fs6 fc0 sc0 ls21 wsb">    this.age += years; </div><div class="t m0 x0 hb y7d ff164 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb yaab ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y715 ff161 fs2 fc0 sc0 ls8 ws1">再看看使用新语法定义的类： </div><div class="t m0 x0 hb y4d38 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4d39 ff164 fs6 fc0 sc0 ls21 wsb">class Person { </div><div class="t m0 x0 hb y4d3a ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4d3b ff164 fs6 fc0 sc0 ls21 wsb">    constructor(name, age){ </div><div class="t m0 x0 hb y4d3c ff164 fs6 fc0 sc0 ls21 wsb">        public name = name; </div><div class="t m0 x0 hb y4d3d ff164 fs6 fc0 sc0 ls21 wsb">        public age = age; </div><div class="t m0 x0 hb y4d3e ff164 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y4d3f ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4d40 ff164 fs6 fc0 sc0 ls21 wsb">    sayName(){ </div><div class="t m0 x0 hb y4d41 ff164 fs6 fc0 sc0 ls21 wsb">        alert(this.name); </div><div class="t m0 x0 hb y4d42 ff164 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y4d43 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4d44 ff164 fs6 fc0 sc0 ls21 wsb">    getOlder(years){ </div><div class="t m0 x0 hb y4d45 ff164 fs6 fc0 sc0 ls21 wsb">        this.age += years; </div><div class="t m0 x5 hb y4d46 ff164 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x5 hb y4d47 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4d48 ff164 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y4d49 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y11ba ff161 fs2 fc0 sc0 ls8 ws1">新语法以关键字class开头，然后就是类型名，而花括号中定义的是属性和方法。定义方法不必</div><div class="t m0 x0 h1e y4d4a ff161 fs2 fc0 sc0 ls8 ws1">再使用function关键字，有方法名和圆括号就可以。如果把方法命名为constructor，那它就是这</div><div class="t m0 x0 h4 y4d4b ff161 fs2 fc0 sc0 ls8 ws1">个类的构造函数（与前一个例子中的Person函数一样）。在这个类中定义的方法和属性都会添加到原</div><div class="t m0 x0 hc y4d4c ff161 fs2 fc0 sc0 ls8 ws1">型上，具体来说，sayName()和getOlder()都是在Person.prototype上定义的。 </div><div class="t m0 x0 h1e y4d4d ff161 fs2 fc0 sc0 ls8 ws1">在构造函数中，public和private关键字用于创建对象的实例属性。这个例子中的name和age</div><div class="t m0 x0 h5 y4d4e ff161 fs2 fc0 sc0 ls8 ws1">都是公有属性。 </div><div class="t m0 x0 h20 y4d4f ff162 fs3 fc0 sc0 ls283 ws34b">A.5.1 私有成员 </div><div class="t m0 x0 h4 y4d50 ff161 fs2 fc0 sc0 ls8 ws1">关于类语法的建议是默认支持私有成员的，包括实例中的私有成员和原型中的私有成员。private</div><div class="t m0 x0 h4 y4bec ff161 fs2 fc0 sc0 ls8 ws1">关键字表示成员是私有的，不能在类方法之外访问。要访问私有成员，可以使用一种特殊的语法，即调</div><div class="t m0 x0 h1e y4bed ff161 fs2 fc0 sc0 ls2c">用private()函数并传入this对象，然后再访问私有成员。例如，下面这个例子把Person类的age</div><div class="t m0 x0 h5 y1c45 ff161 fs2 fc0 sc0 ls8 ws1">改成为私有属性： </div><div class="t m0 x0 hb y4d51 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4d52 ff164 fs6 fc0 sc0 ls21 wsb">class Person { </div><div class="t m0 x0 hb y4d53 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4d54 ff164 fs6 fc0 sc0 ls21 wsb">    constructor(name, age){ </div><div class="t m0 x0 hb y4d55 ff164 fs6 fc0 sc0 ls21 wsb">        public name = name; </div><div class="t m0 x0 hb y4d56 ff164 fs6 fc0 sc0 ls21 wsb">        private age = age; </div><div class="t m0 x0 hb y4d57 ff164 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y4d58 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4d59 ff164 fs6 fc0 sc0 ls21 wsb">    sayName(){ </div><div class="t m0 x0 hb y4d5a ff164 fs6 fc0 sc0 ls21 wsb">        alert(this.name); </div><div class="t m0 x0 hb y4d5b ff164 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y4d5c ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4d5d ff164 fs6 fc0 sc0 ls21 wsb">    getOlder(years){ </div><div class="t m0 x0 hb y4d5e ff164 fs6 fc0 sc0 ls21 wsb">        private(this).age += years; </div><div class="t m0 x5 hb y4d5f ff164 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x5 hb y4d60 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4d61 ff164 fs6 fc0 sc0 ls21 wsb">} </div></div></div>
<div id="pf2dc" class="pf w0 h0" data-page-no="2dc"><div class="pc pc2dc w0 h0"><div class="t m0 x0 h2 y1 ff15e fs0 fc0 sc0 ls7 ws0">714  附录A ECMAScript Harmony </div><div class="t m0 x0 h3 y2 ff15e fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff161 fs2 fc0 sc0 ls8 ws1">这种用于访问私有成员的语法还没有定论，将来很可能会改变。 </div><div class="t m0 x0 h20 y4d62 ff162 fs3 fc0 sc0 ls283 ws34b">A.5.2 getter和setter </div><div class="t m0 x0 h4 y4d63 ff161 fs2 fc0 sc0 ls42 ws30">新的类语法支持直接为属性定义getter和setter，从而避免了调用Object.defineProperty()</div><div class="t m0 x0 h4 y1f3 ff161 fs2 fc0 sc0 ls8 ws1">的麻烦。为属性定义getter和setter与定义方法类似，只不过要在方法名前加上 get和set关键</div><div class="t m0 x0 h5 y1f4 ff161 fs2 fc0 sc0 ls8 ws1">字。例如： </div><div class="t m0 x0 hb y2e50 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4d64 ff164 fs6 fc0 sc0 ls21 wsb">class Person { </div><div class="t m0 x0 hb y4d65 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4d66 ff164 fs6 fc0 sc0 ls21 wsb">    constructor(name, age){ </div><div class="t m0 x0 hb y4d67 ff164 fs6 fc0 sc0 ls21 wsb">        public name = name; </div><div class="t m0 x0 hb y4d68 ff164 fs6 fc0 sc0 ls21 wsb">        public age = age; </div><div class="t m0 x0 hb y4d69 ff164 fs6 fc0 sc0 ls21 wsb">        private innerTitle = &quot;&quot;; </div><div class="t m0 x0 h15 y4d6a ff168 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4d6b ff164 fs6 fc0 sc0 ls21 wsb">        get title(){ </div><div class="t m0 x0 hb y4d6c ff164 fs6 fc0 sc0 ls21 wsb">            return innerTitle; </div><div class="t m0 x0 hb y4d6d ff164 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 h15 y4d6e ff168 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4d6f ff164 fs6 fc0 sc0 ls21 wsb">        set title(value){ </div><div class="t m0 x0 hb y4d70 ff164 fs6 fc0 sc0 ls21 wsb">            innerTitle = value; </div><div class="t m0 x0 hb y4d71 ff164 fs6 fc0 sc0 ls21 wsb">        } </div><div class="t m0 x0 hb y4d72 ff164 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y4d73 ff164 fs6 fc0 sc0 ls21 wsb">    sayName(){ </div><div class="t m0 x0 hb y4d74 ff164 fs6 fc0 sc0 ls21 wsb">        alert(this.name); </div><div class="t m0 x0 hb y4d75 ff164 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y4d76 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4d77 ff164 fs6 fc0 sc0 ls21 wsb">    getOlder(years){ </div><div class="t m0 x0 hb y4d78 ff164 fs6 fc0 sc0 ls21 wsb">        this.age += years; </div><div class="t m0 x0 hb y4d79 ff164 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y4d7a ff164 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y4d7b ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y23e7 ff161 fs2 fc0 sc0 ls8 ws1">这个Person类为title属性定义了一个 getter和一个setter。这两个操作innerTitle变量</div><div class="t m0 x0 h1e y4d7c ff161 fs2 fc0 sc0 ls8 ws1">的函数都定义在了构造函数中。要为原型属性定义getter和setter，语法相同，但要在构造函数外</div><div class="t m0 x0 h5 y11b ff161 fs2 fc0 sc0 ls8">部定义。 </div><div class="t m0 x0 h20 y4d7d ff162 fs3 fc0 sc0 ls283 ws34b">A.5.3 继承 </div><div class="t m0 x0 h5 y4d7e ff161 fs2 fc0 sc0 ls8 ws1">使用类语法而不是过去那种JavaScript语法，最大的好处是容易实现继承。有了类语法，只要使用</div><div class="t m0 x0 hc y4d7f ff161 fs2 fc0 sc0 ls8 ws1">与其他语言相同的extends关键字就能实现继承，而不必去考虑借用构造函数或者原型连缀。例如： </div><div class="t m0 x0 hb y4d80 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4d81 ff164 fs6 fc0 sc0 ls21 wsb">class Employee extends Person { </div><div class="t m0 x0 hb y4d82 ff164 fs6 fc0 sc0 ls21 wsb">    constructor(name, age){ </div><div class="t m0 x0 hb y4d83 ff164 fs6 fc0 sc0 ls21 wsb">        super(name,age); </div><div class="t m0 x0 hb y4d84 ff164 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y4d85 ff164 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 hb y4d86 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y4d87 ff161 fs2 fc0 sc0 ls8 ws1">以上代码创建了一个新类Employee，它继承了Person类。在简单的语法背后，已经自动实现了</div><div class="t m0 x0 h1e y4d88 ff161 fs2 fc0 sc0 ls8 ws1">原型连缀，而且通过使用super()函数，也正式支持了借用构造函数。从逻辑上看，上面的代码与下面</div><div class="t m0 x0 h5 y4d89 ff161 fs2 fc0 sc0 ls8 ws1">的代码是等价的： </div><div class="t m0 x0 hb y4d8a ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4d8b ff164 fs6 fc0 sc0 ls21 wsb">function Employee(name, age){ </div><div class="t m0 x0 hb y4d8c ff164 fs6 fc0 sc0 ls21 wsb">    Person.call(this, name, age); </div><div class="t m0 x0 hb y4d8d ff164 fs6 fc0 sc0 ls21 wsb">} </div></div></div>
<div id="pf2dd" class="pf w0 h0" data-page-no="2dd"><div class="pc pc2dd w0 h0"><div class="t m0 x4 h2 y1 ff15d fs0 fc0 sc0 ls8 ws256">附录A ECMAScript Harmony  715 </div><div class="t m0 x0 h3 y2 ff15e fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff15f fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff15f fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ff15f fs3 fc2 sc0 ls1d wsb">16 </div><div class="t m0 x3 h8 y20 ff15f fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff15f fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff15f fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff15f fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff15f fs3 fc2 sc0 ls1d wsb">20 </div><div class="t m0 x3 h8 y25 ff15f fs3 fc2 sc0 ls1d wsb">21 </div><div class="t m0 x3 h8 y26 ff15f fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff15f fs3 fc2 sc0 ls1d wsf">23 </div><div class="t m0 x3 h8 ya7a ff15f fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff15f fs3 fc2 sc0 ls1d wsf">25 </div><div class="t m0 x0 hb y79 ff164 fs6 fc0 sc0 ls21 wsb">Employee.prototype = new Person(); </div><div class="t m0 x0 h4 y4d16 ff161 fs2 fc0 sc0 ls8 ws1">除了这种风格的继承，类语法还允许直接将对象指定为其原型，方法就是用prototype关键字代</div><div class="t m0 x0 hc y4d17 ff161 fs2 fc0 sc0 ls2d8">替extends： </div><div class="t m0 x0 hb y4d8e ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4d8f ff164 fs6 fc0 sc0 ls21 wsb">var basePerson = { </div><div class="t m0 x0 hb y4d90 ff164 fs6 fc0 sc0 ls21 wsb">    sayName: function(){ </div><div class="t m0 x0 hb y4d91 ff164 fs6 fc0 sc0 ls21 wsb">        alert(this.name); </div><div class="t m0 x0 hb y4d92 ff164 fs6 fc0 sc0 ls21 wsb">    }, </div><div class="t m0 x0 hb y4d93 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4d94 ff164 fs6 fc0 sc0 ls21 wsb">    getOlder: function(years){ </div><div class="t m0 x0 hb y4d95 ff164 fs6 fc0 sc0 ls21 wsb">        this.age += years; </div><div class="t m0 x0 hb y4d96 ff164 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y4d97 ff164 fs6 fc0 sc0 ls21 wsb">}; </div><div class="t m0 x0 hb y4d98 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4d99 ff164 fs6 fc0 sc0 ls21 wsb">class Employee prototype basePerson { </div><div class="t m0 x0 hb y4d9a ff164 fs6 fc0 sc0 ls21 wsb">    constructor(name, age){ </div><div class="t m0 x0 hb y4d9b ff164 fs6 fc0 sc0 ls21 wsb">        public name = name; </div><div class="t m0 x0 hb y4d9c ff164 fs6 fc0 sc0 ls21 wsb">        public age = age; </div><div class="t m0 x0 hb y4d9d ff164 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y4d9e ff164 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y4d9f ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y4da0 ff161 fs2 fc0 sc0 ls6f ws54">这个例子将basePerson对象直接指定为 Employee.prototype，从而实现了与目前使用</div><div class="t m0 x0 h5 y4da1 ff164 fs1 fc0 sc0 ls9 ws2">Object.create()实现的一样的继承。 </div><div class="t m0 x0 hd y4da2 ff162 fs7 fc0 sc0 ls4d3 ws467">A.6 模块 </div><div class="t m0 x0 h5 y3a28 ff161 fs2 fc0 sc0 ls8 ws1">模块（或者“命名空间”、“包”）是组织JavaScript 应用代码的重要方法。每个模块都包含着独立于</div><div class="t m0 x0 h5 y1faf ff161 fs2 fc0 sc0 ls42 ws30">其他模式的特定、独一无二的功能。JavaScript开发中曾出现过一些临时性的模块格式，而ECMAScript 6</div><div class="t m0 x0 h5 y4da3 ff161 fs2 fc0 sc0 ls8 ws1">则对如何创建和管理模块给出了标准的定义。 </div><div class="t m0 x0 h4 y4da4 ff161 fs2 fc0 sc0 ls8 ws1">模块在其自己的顶级执行环境中运行，因而不会污染导入它的全局执行环境。默认情况下，模块中</div><div class="t m0 x0 h4 y4da5 ff161 fs2 fc0 sc0 ls8 ws1">声明的所有变量、函数、类等都是该模块私有的。对于应该向外部公开的成员，可以在前面加上export</div><div class="t m0 x0 h5 y4da6 ff161 fs2 fc0 sc0 ls8 ws1">关键字。例如： </div><div class="t m0 x0 hb y4da7 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4da8 ff164 fs6 fc0 sc0 ls21 wsb">module MyModule { </div><div class="t m0 x0 h16 y4da9 ff164 fs6 fc0 sc0 ls21 wsb">    //公开这些成员 </div><div class="t m0 x0 hb y4daa ff164 fs6 fc0 sc0 ls21 wsb">    export let myobject = {}; </div><div class="t m0 x0 hb y4dab ff164 fs6 fc0 sc0 ls21 wsb">    export function hello(){ alert(&quot;hello&quot;); }; </div><div class="t m0 x0 hb y4dac ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4dad ff164 fs6 fc0 sc0 ls21 wsb">    //隐藏这些成员 </div><div class="t m0 x0 hb y4dae ff164 fs6 fc0 sc0 ls21 wsb">    function goodbye(){ </div><div class="t m0 x0 hb y4daf ff164 fs6 fc0 sc0 ls21 wsb">        //... </div><div class="t m0 x0 hb y4db0 ff164 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y4db1 ff164 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h5 y4db2 ff15e fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y4db3 ff161 fs2 fc0 sc0 ls8 ws1">这个模块公开了一个名为myobject的对象和一个名为hello()的函数。可以在页面或其他模块</div><div class="t m0 x0 hc y4db4 ff161 fs2 fc0 sc0 ls8 ws1">中使用这个模块，也可以只导入模块中的一个成员或者两个成员。导入模块要使用import命令： </div><div class="t m0 x0 hb y4db5 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4db6 ff164 fs6 fc0 sc0 ls21">//只导入myobject </div><div class="t m0 x0 hb y4db7 ff164 fs6 fc0 sc0 ls21 wsb">import myobject from MyModule; </div><div class="t m0 x0 hb y4db8 ff164 fs6 fc0 sc0 ls21 wsb">console.log(myobject); </div><div class="t m0 x0 hb y4db9 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4dba ff164 fs6 fc0 sc0 ls21">//导入所有公开的成员 </div><div class="t m0 x0 hb y4dbb ff164 fs6 fc0 sc0 ls21 wsb">import * from MyModule; </div></div></div>
<div id="pf2de" class="pf w0 h0" data-page-no="2de"><div class="pc pc2de w0 h0"><div class="t m0 x0 h2 y1 ff15e fs0 fc0 sc0 ls7 ws0">716  附录A ECMAScript Harmony </div><div class="t m0 x0 h3 y2 ff15e fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y79 ff164 fs6 fc0 sc0 ls21 wsb">console.log(myobject); </div><div class="t m0 x0 hb y7a ff164 fs6 fc0 sc0 ls21 wsb">console.log(hello); </div><div class="t m0 x0 hb y7b ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y7c ff164 fs6 fc0 sc0 ls21">//列出要导入的成员名 </div><div class="t m0 x0 hb y7d ff164 fs6 fc0 sc0 ls21 wsb">import {myobject, hello} from MyModule; </div><div class="t m0 x0 hb y7e ff164 fs6 fc0 sc0 ls21 wsb">console.log(myobject); </div><div class="t m0 x0 hb y7f ff164 fs6 fc0 sc0 ls21 wsb">console.log(hello); </div><div class="t m0 x0 hb y80 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y81 ff164 fs6 fc0 sc0 ls21">//不导入，直接使用模块 </div><div class="t m0 x0 hb y82 ff164 fs6 fc0 sc0 ls21 wsb">console.log(MyModule.myobject); </div><div class="t m0 x0 hb y83 ff164 fs6 fc0 sc0 ls21 wsb">console.log(MyModule.hello); </div><div class="t m0 x0 hb y4dbc ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y233c ff161 fs2 fc0 sc0 ls8 ws1">在执行环境能够访问到模块的情况下，可以直接调用模块中对外公开的成员。导入操作只不过是把</div><div class="t m0 x0 h5 y3e1c ff161 fs2 fc0 sc0 ls8 ws1">模块中的个别成员拿到当前执行环境中，以便直接操作而不必引用模块。 </div><div class="t m0 x0 h20 y1454 ff163 fs3 fc0 sc0 ls8">外部模块 </div><div class="t m0 x0 h5 y4dbd ff161 fs2 fc0 sc0 ls8 ws1">通过提供模块所在外部文件的URL，也可以动态加载和导入模块。为此，首先要在模块声明后面加</div><div class="t m0 x0 h5 y4dbe ff161 fs2 fc0 sc0 ls8 ws1">上外部文件的URL，然后再导入模块成员： </div><div class="t m0 x0 hb y4dbf ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4dc0 ff164 fs6 fc0 sc0 ls21 wsb">module MyModule from &quot;mymodule.js&quot;; </div><div class="t m0 x0 hb y4dc1 ff164 fs6 fc0 sc0 ls21 wsb">import myobject from MyModule; </div><div class="t m0 x0 hb y4dc2 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y36c2 ff161 fs2 fc0 sc0 ls8 ws1">以上声明会通知JavaScript引擎下载mymodule.js文件，然后从中加载名为 MyModule的模块。</div><div class="t m0 x0 h5 y36c3 ff161 fs2 fc0 sc0 ls6 ws6">请读者注意，这个调用会阻塞进程。换句话说，JavaScript引擎在下载完外部文件并对其求值之前，不</div><div class="t m0 x0 h5 y4dc3 ff161 fs2 fc0 sc0 ls8 ws1">会处理后面的代码。 </div><div class="t m0 x0 h4 y4dc4 ff161 fs2 fc0 sc0 ls24 ws1e">如果你只想包含模块中对外公开的某些成员，不想把整个模块都加载进来，可以像下面这样使用</div><div class="t m0 x0 h5 y2430 ff164 fs1 fc0 sc0 ls9 ws2">import指令： </div><div class="t m0 x0 hb y3b2c ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4dc5 ff164 fs6 fc0 sc0 ls21 wsb">import myobject from &quot;mymodule.js&quot;; </div><div class="t m0 x0 hb y4dc6 ff164 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y4dc7 ff161 fs2 fc0 sc0 ls8 ws1">总之，模块就是一种组织相关功能的手段，而且能够保护全局作用域不受污染。 </div><div class="t m0 x0 h5 y4dc8 ff15e fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y4dc9 ff15e fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y4dca ff15e fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y4dcb ff15e fs2 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf2df" class="pf w0 h0" data-page-no="2df"><div class="pc pc2df w0 h0"><div class="t m0 x2 h178 y1 ff16b fs0 fc0 sc0 ls8 wsb">附录B 严格模式   717 </div><div class="t m0 x0 h3 y2 ff16c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff16d fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff16d fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ff16d fs3 fc2 sc0 ls1d wsb">16 </div><div class="t m0 x3 h8 y20 ff16d fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff16d fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff16d fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff16d fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff16d fs3 fc2 sc0 ls1d wsb">20 </div><div class="t m0 x3 h8 y25 ff16d fs3 fc2 sc0 ls1d wsb">21 </div><div class="t m0 x3 h8 y26 ff16d fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff16d fs3 fc2 sc0 ls1d wsf">23 </div><div class="t m0 x3 h8 ya7a ff16d fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff16d fs3 fc2 sc0 ls1d wsf">25 </div><div class="t m0 x0 h9 y2a ff16e fs5 fc0 sc0 ls12 wsb">严 格 模 式 </div><div class="t m0 x0 h5 y2e0 ff16c fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x5 h5 y4bdd ff16c fs2 fc0 sc0 ls5e ws472">CMAScript 5最早引入了“严格模式”（strict mode）的概念。通过严格模式，可以在函数内部</div><div class="t m0 x5 h4 y4bde ff16f fs2 fc0 sc0 ls8 ws1">选择进行较为严格的全局或局部的错误条件检测。使用严格模式的好处是可以提早知道代码中</div><div class="t m0 x0 h5 y4bdf ff16f fs2 fc0 sc0 ls8 ws1">存在的错误，及时捕获一些可能导致编程错误的ECMAScript行为。 </div><div class="t m0 x0 h5 y4be0 ff16f fs2 fc0 sc0 ls6 ws6">理解严格模式的规则非常重要，ECMAScript的下一个版本将以严格模式为基础制定。支持严格模</div><div class="t m0 x0 h5 y4be1 ff16f fs2 fc0 sc0 ls8 ws1">式的浏览器包括IE10+、Firefox 4+、Safari 5.1+和Chrome。 </div><div class="t m0 x0 hd y1ce8 ff170 fs7 fc0 sc0 ls4d3 ws467">B.1 选择使用 </div><div class="t m0 x0 h5 y4dcc ff16f fs2 fc0 sc0 ls6 ws6">要选择进入严格模式，可以使用严格模式的编译指示（pragma），实际上就是一个不会赋给任何变</div><div class="t m0 x0 h5 y4a9c ff16f fs2 fc0 sc0 ls8 ws1">量的字符串： </div><div class="t m0 x0 hb y388d ff172 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4dcd ff172 fs6 fc0 sc0 ls21 wsb">&quot;use strict&quot;; </div><div class="t m0 x0 hb y4dce ff172 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y4dcf ff16f fs2 fc0 sc0 ls8 ws1">这种语法（从ECMAScript 3开始支持）可以向后兼容那些不支持严格模式的JavaScript引擎。支持</div><div class="t m0 x0 h4 y4dd0 ff16f fs2 fc0 sc0 ls8 ws1">严格模式的引擎会启动这种模式，而不支持该模式的引擎就当遇到了一个未赋值的字符串字面量，会忽</div><div class="t m0 x0 h5 y4dd1 ff16f fs2 fc0 sc0 ls8 ws1">略这个编译指示。 </div><div class="t m0 x0 h4 y4dd2 ff16f fs2 fc0 sc0 ls8 ws1">如果是在全局作用域中（函数外部）给出这个编译指示，则整个脚本都将使用严格模式。换句话说，</div><div class="t m0 x0 h5 y4dd3 ff16f fs2 fc0 sc0 ls8 ws1">如果把带有这个编译指示的脚本放到其他文件中，则该文件中的JavaScript代码也将处于严格模式下。 </div><div class="t m0 x0 h5 y4dd4 ff16f fs2 fc0 sc0 ls8 ws1">也可以只在函数中打开严格模式，就像下面这样： </div><div class="t m0 x0 hb y1c84 ff172 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4dd5 ff172 fs6 fc0 sc0 ls21 wsb">function doSomething(){ </div><div class="t m0 x0 hb y4dd6 ff172 fs6 fc0 sc0 ls21 wsb">    &quot;use strict&quot;; </div><div class="t m0 x0 hb y4dd7 ff172 fs6 fc0 sc0 ls21 wsb">     </div><div class="t m0 x0 h16 y4dd8 ff172 fs6 fc0 sc0 ls21 wsb">    //其他代码 </div><div class="t m0 x0 hb y4dd9 ff172 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 h5 y4dda ff16c fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y25ea ff16f fs2 fc0 sc0 ls8 ws1">如果你没有控制页面中所有脚本的权力，建议只在需要测试的特定函数中开启严格模式。 </div><div class="t m0 x0 hd y2ba2 ff170 fs7 fc0 sc0 ls4d3 ws467">B.2 变量 </div><div class="t m0 x0 h4 y4ddb ff16f fs2 fc0 sc0 ls8 ws1">在严格模式下，什么时候创建变量以及怎么创建变量都是有限制的。首先，不允许意外创建全局变</div><div class="t m0 x0 h5 y4ddc ff16f fs2 fc0 sc0 ls8 ws1">量。在非严格模式下，可以像下面这样创建全局变量： </div><div class="t m0 x0 hb y4ddd ff172 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4dde ff172 fs6 fc0 sc0 ls21">//未声明变量 </div><div class="t m0 x0 h16 y4ddf ff172 fs6 fc0 sc0 ls21">//非严格模式：创建全局变量 </div><div class="t m0 x0 h16 y4de0 ff172 fs6 fc0 sc0 ls21">//严格模式：抛出ReferenceError </div><div class="t m0 x0 hb y4de1 ff172 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4de2 ff172 fs6 fc0 sc0 ls21 wsb">message = &quot;Hello world! &quot;; </div><div class="t m0 x0 h13e y4de3 ff170 fs1a fc0 sc0 ls424 wsb">E </div><div class="t m0 x0 h11 y4b ff174 fsa fc0 sc0 ls8">附录</div><div class="t m1 x5 h12 y4b ff175 fsb fc3 sc0 ls8">B</div><div class="t m0 x5 h9 y4b ff16e fs5 fc3 sc0 ls8 wsb"> </div></div></div>
<div id="pf2e0" class="pf w0 h0" data-page-no="2e0"><div class="pc pc2e0 w0 h0"><div class="t m0 x0 h2 y1 ff16c fs0 fc0 sc0 ls7 ws0">718  附录B 严格模式 </div><div class="t m0 x0 h3 y2 ff16c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y3 ff16f fs2 fc0 sc0 ls8 ws1">即使message前面没有var关键字，即使没有将它定义为某个全局对象的属性，也能将message</div><div class="t m0 x0 h4 y4 ff16f fs2 fc0 sc0 ls19">创建为全局变量。但在严格模式下，如果给一个没有声明的变量赋值，那代码在执行时就会抛出</div><div class="t m0 x0 h5 y4e ff172 fs1 fc0 sc0 ls9 ws2">ReferenceError。 </div><div class="t m0 x0 h4 yd9 ff16f fs2 fc0 sc0 ls8 ws1">其次，不能对变量调用delete操作符。非严格模式允许这样操作，但会静默失败（返回false）。</div><div class="t m0 x0 h5 y15d ff16f fs2 fc0 sc0 ls8 ws1">而在严格模式下，删除变量也会导致错误。 </div><div class="t m0 x0 hb y263 ff172 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y264 ff172 fs6 fc0 sc0 ls21">//删除变量  </div><div class="t m0 x0 h16 y265 ff172 fs6 fc0 sc0 ls21">//非严格模式：静默失败 </div><div class="t m0 x0 h16 y266 ff172 fs6 fc0 sc0 ls21">//严格模式：抛出ReferenceError </div><div class="t m0 x0 hb y267 ff172 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y268 ff172 fs6 fc0 sc0 ls21 wsb">var color = &quot;red&quot;; </div><div class="t m0 x0 hb y269 ff172 fs6 fc0 sc0 ls21 wsb">delete color; </div><div class="t m0 x0 hb y10db ff172 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y5a4 ff16f fs2 fc0 sc0 ls8 ws1">严格模式下对变量名也有限制。特别地，不能使用implements、interface、let、package、</div><div class="t m0 x0 h5 y19e1 ff172 fs1 fc0 sc0 ls9 ws2">private、protected、public、static和yield作为变量名。这些都是保留字，将来的ECMAScript</div><div class="t m0 x0 h5 y4de4 ff16f fs2 fc0 sc0 ls8 ws1">版本中可能会用到它们。在严格模式下，用以上标识符作为变量名会导致语法错误。 </div><div class="t m0 x0 hd y2ebd ff170 fs7 fc0 sc0 ls4d3 ws467">B.3 对象 </div><div class="t m0 x0 h4 y3ea2 ff16f fs2 fc0 sc0 ls8 ws1">在严格模式下操作对象比在非严格模式下更容易导致错误。一般来说，非严格模式下会静默失败的</div><div class="t m0 x0 h5 y1a72 ff16f fs2 fc0 sc0 ls8 ws1">情形，在严格模式下就会抛出错误。因此，在开发中使用严格模式会加大早发现错误的可能性。 </div><div class="t m0 x0 h5 y28d9 ff16f fs2 fc0 sc0 ls8 ws1">在下列情形下操作对象的属性会导致错误： </div><div class="t m0 x0 h5 y4de5 ff176 fs1 fc0 sc0 ls2"> 为只读属性赋值会抛出TypeError； </div><div class="t m0 x0 h5 y2dde ff176 fs1 fc0 sc0 ls2"> 对不可配置的（nonconfigurable）的属性使用delete操作符会抛出TypeError； </div><div class="t m0 x0 h5 y32da ff176 fs1 fc0 sc0 ls2"> 为不可扩展的（nonextensible）的对象添加属性会抛出TypeError。 </div><div class="t m0 x0 h4 y32db ff16f fs2 fc0 sc0 ls8 ws1">使用对象的另一个限制与通过对象字面量声明对象有关。在使用对象字面量时，属性名必须唯一。</div><div class="t m0 x0 h5 y4de6 ff16f fs2 fc0 sc0 ls8">例如： </div><div class="t m0 x0 hb y4de7 ff172 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4de8 ff172 fs6 fc0 sc0 ls21">//重名属性 </div><div class="t m0 x0 h16 y4de9 ff172 fs6 fc0 sc0 ls21">//非严格模式：没有错误，以第二个属性为准 </div><div class="t m0 x0 h16 y4dea ff172 fs6 fc0 sc0 ls21">//严格模式：抛出语法错误 </div><div class="t m0 x0 hb y4deb ff172 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4dec ff172 fs6 fc0 sc0 ls21 wsb">var person = {  </div><div class="t m0 x0 hb y4ded ff172 fs6 fc0 sc0 ls21 wsb">                name: &quot;Nicholas&quot;, </div><div class="t m0 x0 hb y4dee ff172 fs6 fc0 sc0 ls21 wsb">                name: &quot;Greg&quot; </div><div class="t m0 x0 hb y4def ff172 fs6 fc0 sc0 ls21 wsb">             }; </div><div class="t m0 x0 hb y4df0 ff172 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y4df1 ff16f fs2 fc0 sc0 ls8 ws1">这里的对象person有两个属性，都叫name。在非严格模式下，person对象的name 属性值是第</div><div class="t m0 x0 h5 y4df2 ff16f fs2 fc0 sc0 ls8 ws1">二个，而在严格模式下，这样的代码会导致语法错误。 </div><div class="t m0 x0 hd y1b71 ff170 fs7 fc0 sc0 ls4d3 ws467">B.4 函数 </div><div class="t m0 x0 h5 y4df3 ff16f fs2 fc0 sc0 ls8 ws1">首先，严格模式要求命名函数的参数必须唯一。以下面这个函数为例： </div><div class="t m0 x0 hb y4df4 ff172 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4df5 ff172 fs6 fc0 sc0 ls21">//重名参数 </div><div class="t m0 x0 h16 y4df6 ff172 fs6 fc0 sc0 ls21">//非严格模式：没有错误，只能访问第二个参数 </div><div class="t m0 x0 h16 y4df7 ff172 fs6 fc0 sc0 ls21">//严格模式：抛出语法错误 </div></div></div>
<div id="pf2e1" class="pf w0 h0" data-page-no="2e1"><div class="pc pc2e1 w0 h0"><div class="t m0 x2 h2 y1 ff16b fs0 fc0 sc0 ls8 ws256">附录B 严格模式   719 </div><div class="t m0 x0 h3 y2 ff16c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff16d fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff16d fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ff16d fs3 fc2 sc0 ls1d wsb">16 </div><div class="t m0 x3 h8 y20 ff16d fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff16d fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff16d fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff16d fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff16d fs3 fc2 sc0 ls1d wsb">20 </div><div class="t m0 x3 h8 y25 ff16d fs3 fc2 sc0 ls1d wsb">21 </div><div class="t m0 x3 h8 y26 ff16d fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff16d fs3 fc2 sc0 ls1d wsf">23 </div><div class="t m0 x3 h8 ya7a ff16d fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff16d fs3 fc2 sc0 ls1d wsf">25 </div><div class="t m0 x0 hb y79 ff172 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y7a ff172 fs6 fc0 sc0 ls21 wsb">function sum (num, num){ </div><div class="t m0 x0 hb y7b ff172 fs6 fc0 sc0 ls21 wsb">    //do something </div><div class="t m0 x0 hb y7c ff172 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 h5 y4df8 ff16c fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y4df9 ff16f fs2 fc0 sc0 ls8 ws1">在非严格模式下，这个函数声明不会抛出错误。通过参数名只能访问第二个参数，要访问第一个参</div><div class="t m0 x0 hcd y4dfa ff16f fs2 fc0 sc0 ls8 ws1">数必须通过arguments对象。 </div><div class="t m0 x0 h4 y423 ff16f fs2 fc0 sc0 ls6 ws6">在严格模式下，arguments对象的行为也有所不同。在非严格模式下，修改命名参数的值也会反</div><div class="t m0 x0 hc y4dfb ff16f fs2 fc0 sc0 ls8 ws1">映到arguments对象中，而严格模式下这两个值是完全独立的。例如： </div><div class="t m0 x0 hb y237e ff172 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4dfc ff172 fs6 fc0 sc0 ls21">//修改命名参数的值 </div><div class="t m0 x0 h16 y4dfd ff172 fs6 fc0 sc0 ls21">//非严格模式：修改会反映到arguments中 </div><div class="t m0 x0 h16 y4dfe ff172 fs6 fc0 sc0 ls21">//严格模式：修改不会反映到arguments中 </div><div class="t m0 x0 hb y4dff ff172 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4e00 ff172 fs6 fc0 sc0 ls21 wsb">function showValue(value){ </div><div class="t m0 x0 hb y4e01 ff172 fs6 fc0 sc0 ls21 wsb">    value = &quot;Foo&quot;;  </div><div class="t m0 x0 hb y4e02 ff172 fs6 fc0 sc0 ls21 wsb">    alert(value);        //&quot;Foo&quot; </div><div class="t m0 x0 h16 y4e03 ff172 fs6 fc0 sc0 ls21 wsb">    alert(arguments[0]); //非严格模式：&quot;Foo&quot; </div><div class="t m0 x0 h16 y4e04 ff172 fs6 fc0 sc0 ls21 wsb">                         //严格模式：&quot;Hi&quot; </div><div class="t m0 x0 hb y4e05 ff172 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y4e06 ff172 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4e07 ff172 fs6 fc0 sc0 ls21 wsb">showValue(&quot;Hi&quot;); </div><div class="t m0 x0 h5 y24da ff16c fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y4e08 ff16f fs2 fc0 sc0 ls8 ws1">以上代码中，函数showValue()只有一个命名参数value。调用这个函数时传入了一个参数&quot;Hi&quot;，</div><div class="t m0 x0 h4 y44b1 ff16f fs2 fc0 sc0 lsa ws53">这个值赋给了value。而在函数内部，value被改为&quot;Foo&quot;。在非严格模式下，这个修改也会改变</div><div class="t m0 x0 h5 y3c42 ff172 fs1 fc0 sc0 ls9 ws2">arguments[0]的值，但在严格模式下，arguments[0]的值仍然是传入的值。 </div><div class="t m0 x0 h1e y4e09 ff16f fs2 fc0 sc0 ls30 ws2a">另一个变化是淘汰了arguments.callee和arguments.caller。在非严格模式下，这两个属</div><div class="t m0 x0 h1e y4e0a ff16f fs2 fc0 sc0 ls30 ws2a">性一个引用函数本身，一个引用调用函数。而在严格模式下，访问哪个属性都会抛出TypeError。</div><div class="t m0 x0 h5 y4e0b ff16f fs2 fc0 sc0 ls24 ws1e">例如： </div><div class="t m0 x0 hb y3396 ff172 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4e0c ff172 fs6 fc0 sc0 ls21">//访问arguments.callee </div><div class="t m0 x0 h16 y4e0d ff172 fs6 fc0 sc0 ls21">//非严格模式：没有问题 </div><div class="t m0 x0 h16 y4e0e ff172 fs6 fc0 sc0 ls21">//严格模式：抛出TypeError </div><div class="t m0 x0 hb y4e0f ff172 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4e10 ff172 fs6 fc0 sc0 ls21 wsb">function factorial(num){ </div><div class="t m0 x0 hb y4e11 ff172 fs6 fc0 sc0 ls21 wsb">    if (num &lt;= 1) { </div><div class="t m0 x0 hb y4e12 ff172 fs6 fc0 sc0 ls21 wsb">        return 1; </div><div class="t m0 x0 hb y4e13 ff172 fs6 fc0 sc0 ls21 wsb">    } else { </div><div class="t m0 x0 hb y4e14 ff172 fs6 fc0 sc0 ls21 wsb">        return num * arguments.callee(num-1) </div><div class="t m0 x0 hb y4e15 ff172 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y4e16 ff172 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y4e17 ff172 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4e18 ff172 fs6 fc0 sc0 ls21 wsb">var result=factorial(5); </div><div class="t m0 x0 hb y4e19 ff172 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y2d73 ff16f fs2 fc0 sc0 ls8 ws1">类似地，尝试读写函数的caller属性，也会导致抛出TypeError。所以，对于上面的例子而言，</div><div class="t m0 x0 hc y4e1a ff16f fs2 fc0 sc0 ls8 ws1">访问factorial.caller也会抛出错误。 </div><div class="t m0 x0 h1e y4e1b ff16f fs2 fc0 sc0 ls8 ws1">与变量类似，严格模式对函数名也做出了限制，不允许用implements、interface、let、package、</div><div class="t m0 x0 h5 y4e1c ff172 fs1 fc0 sc0 ls9 ws2">private、protected、public、static和yield作为函数名。 </div><div class="t m0 x0 h4 y4e1d ff16f fs2 fc0 sc0 ls8 ws1">对函数的最后一点限制，就是只能在脚本的顶级和在函数内部声明函数。也就是说，在if语句中</div><div class="t m0 x0 h5 y4e1e ff16f fs2 fc0 sc0 ls8 ws1">声明函数会导致语法错误： </div></div></div>
<div id="pf2e2" class="pf w0 h0" data-page-no="2e2"><div class="pc pc2e2 w0 h0"><div class="t m0 x0 h2 y1 ff16c fs0 fc0 sc0 ls7 ws0">720  附录B 严格模式 </div><div class="t m0 x0 h3 y2 ff16c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y79 ff172 fs6 fc0 sc0 ls21">//在if语句中声明函数 </div><div class="t m0 x0 h16 y7a ff172 fs6 fc0 sc0 ls21">//非严格模式：将函数提升到if语句外部 </div><div class="t m0 x0 h16 y7b ff172 fs6 fc0 sc0 ls21">//严格模式：抛出语法错误 </div><div class="t m0 x0 hb y7c ff172 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y7d ff172 fs6 fc0 sc0 ls21 wsb">if (true){ </div><div class="t m0 x0 hb y7e ff172 fs6 fc0 sc0 ls21 wsb">    function doSomething(){ </div><div class="t m0 x0 hb y7f ff172 fs6 fc0 sc0 ls21 wsb">          //... </div><div class="t m0 x0 hb y80 ff172 fs6 fc0 sc0 ls21 wsb">    } </div><div class="t m0 x0 hb y81 ff172 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 h5 y1009 ff16c fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y4e1f ff16f fs2 fc0 sc0 ls8 ws1">在非严格模式下，以上代码能在所有浏览器中运行，但在严格模式下会导致语法错误。 </div><div class="t m0 x0 hd y4e20 ff170 fs7 fc0 sc0 ls4d3 ws467">B.5 eval() </div><div class="t m0 x0 h4 y4e21 ff16f fs2 fc0 sc0 ls8 ws1">饱受诟病的eval()函数在严格模式下也得到了提升。最大的变化就是它在包含上下文中不再创建</div><div class="t m0 x0 h5 y4e22 ff16f fs2 fc0 sc0 ls8 ws1">变量或函数。例如： </div><div class="t m0 x0 hb y1b19 ff172 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4e23 ff172 fs6 fc0 sc0 ls21">//使用eval()创建变量 </div><div class="t m0 x0 h16 y4e24 ff172 fs6 fc0 sc0 ls21">//非严格模式：弹出对话框显示10 </div><div class="t m0 x0 h16 y4e25 ff172 fs6 fc0 sc0 ls21">//严格模式：调用alert(x)时会抛出ReferenceError </div><div class="t m0 x0 hb y4e26 ff172 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4e27 ff172 fs6 fc0 sc0 ls21 wsb">function doSomething(){ </div><div class="t m0 x0 hb y4e28 ff172 fs6 fc0 sc0 ls21 wsb">    eval(&quot;var x=10&quot;); </div><div class="t m0 x0 hb y4e29 ff172 fs6 fc0 sc0 ls21 wsb">    alert(x); </div><div class="t m0 x0 hb y4e2a ff172 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 h5 y4e2b ff16c fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y4e2c ff16f fs2 fc0 sc0 ls8 ws1">如果是在非严格模式下，以上代码会在函数doSomething()中创建一个局部变量x，然后alert()</div><div class="t m0 x0 h4 y44b3 ff16f fs2 fc0 sc0 ls8 ws1">还会显示该变量的值。但在严格模式下，在doSomething()函数中调用eval()不会创建变量x，因此</div><div class="t m0 x0 hc y44b4 ff16f fs2 fc0 sc0 ls8 ws1">调用alert()会导致抛出ReferenceError，因为x没有定义。 </div><div class="t m0 x0 h1e y4e2d ff16f fs2 fc0 sc0 ls8 ws1">可以在eval()中声明变量和函数，但这些变量或函数只能在被求值的特殊作用域中有效，随后就</div><div class="t m0 x0 h5 y1ea1 ff16f fs2 fc0 sc0 ls8 ws1">将被销毁。因此，以下代码可以运行，没有问题： </div><div class="t m0 x0 hb y400a ff172 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4e2e ff172 fs6 fc0 sc0 ls21 wsb">&quot;use strict&quot;; </div><div class="t m0 x0 hb y4e2f ff172 fs6 fc0 sc0 ls21 wsb">var result = eval(&quot;var x=10, y=11; x+y&quot;); </div><div class="t m0 x0 hb y4e30 ff172 fs6 fc0 sc0 ls21 wsb">alert(result); //21 </div><div class="t m0 x0 hb y4e31 ff172 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 yc69 ff16f fs2 fc0 sc0 ls8 ws1">这里在eval()中声明了变量x和y，然后将它们加在一起，返回了它们的和。于是，result变</div><div class="t m0 x0 h5 y4e32 ff16f fs2 fc0 sc0 ls8 ws1">量的值是21，即x和y相加的结果。而在调用alert()时，尽管x和y已经不存在了，result 变量</div><div class="t m0 x0 h5 y4e33 ff16f fs2 fc0 sc0 ls8 ws1">的值仍然是有效的。 </div><div class="t m0 x0 hd y3a18 ff170 fs7 fc0 sc0 ls4d3 ws467">B.6 eval与arguments </div><div class="t m0 x0 h5 y1b4a ff16f fs2 fc0 sc0 ls8 ws1">严格模式已经明确禁止使用eval和arguments作为标识符，也不允许读写它们的值。例如： </div><div class="t m0 x0 hb y27ae ff172 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4e34 ff172 fs6 fc0 sc0 ls21">//把eval和arguments作为变量引用 </div><div class="t m0 x0 h16 y4e35 ff172 fs6 fc0 sc0 ls21">//非严格模式：没问题，不出错 </div><div class="t m0 x0 h16 y4e36 ff172 fs6 fc0 sc0 ls21">//严格模式：抛出语法错误 </div><div class="t m0 x0 hb y4e37 ff172 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4e38 ff172 fs6 fc0 sc0 ls21 wsb">var eval = 10; </div><div class="t m0 x0 hb y4e39 ff172 fs6 fc0 sc0 ls21 wsb">var arguments = &quot;Hello world!&quot;; </div></div></div>
<div id="pf2e3" class="pf w0 h0" data-page-no="2e3"><div class="pc pc2e3 w0 h0"><div class="t m0 x2 h2 y1 ff16b fs0 fc0 sc0 ls8 ws256">附录B 严格模式   721 </div><div class="t m0 x0 h3 y2 ff16c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff16d fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff16d fs3 fc2 sc0 ls1d wsb">15 </div><div class="t m0 x3 h8 y1f ff16d fs3 fc2 sc0 ls1d wsb">16 </div><div class="t m0 x3 h8 y20 ff16d fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff16d fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff16d fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff16d fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff16d fs3 fc2 sc0 ls1d wsb">20 </div><div class="t m0 x3 h8 y25 ff16d fs3 fc2 sc0 ls1d wsb">21 </div><div class="t m0 x3 h8 y26 ff16d fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff16d fs3 fc2 sc0 ls1d wsf">23 </div><div class="t m0 x3 h8 ya7a ff16d fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y1fce ff16d fs3 fc2 sc0 ls1d wsf">25 </div><div class="t m0 x0 h4 y3 ff16f fs2 fc0 sc0 ls8 ws1">在非严格模式下，可以重写eval，也可以给arguments赋值。但在严格模式下，这样做会导致语</div><div class="t m0 x0 h5 y4d ff16f fs2 fc0 sc0 ls8 ws1">法错误。不能将它们用作标识符，意味着以下几种使用方式都会抛出语法错误： </div><div class="t m0 x0 h5 y4e ff176 fs1 fc0 sc0 ls2"> 使用var声明； </div><div class="t m0 x0 h5 yd9 ff176 fs1 fc0 sc0 ls2"> 赋予另一个值； </div><div class="t m0 x0 h5 y219 ff176 fs1 fc0 sc0 ls2"> 尝试修改包含的值，如使用++； </div><div class="t m0 x0 h5 y8 ff176 fs1 fc0 sc0 ls2"> 用作函数名； </div><div class="t m0 x0 h5 y9 ff176 fs1 fc0 sc0 ls2"> 用作命名的函数参数； </div><div class="t m0 x0 h5 ya ff176 fs1 fc0 sc0 ls2"> 在try-catch语句中用作例外名。 </div><div class="t m0 x0 hd yc ff170 fs7 fc0 sc0 ls4d3 ws467">B.7 抑制this </div><div class="t m0 x0 h5 y8cc ff16c fs2 fc0 sc0 lsb ws5">JavaScript中一个最大的安全问题，也是最容易让人迷茫的地方，就是在某些情况下如何抑制this</div><div class="t m0 x0 h4 y8cd ff16f fs2 fc0 sc0 ls8 ws1">的值。在非严格模式下使用函数的apply()或call()方法时，null或undefined值会被转换为全局</div><div class="t m0 x0 hc y8ce ff16f fs2 fc0 sc0 ls8 ws1">对象。而在严格模式下，函数的this值始终是指定的值，无论指定的是什么值。例如： </div><div class="t m0 x0 hb y4e3a ff172 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4e3b ff172 fs6 fc0 sc0 ls21">//访问属性 </div><div class="t m0 x0 h16 y4e3c ff172 fs6 fc0 sc0 ls21">//非严格模式：访问全局属性 </div><div class="t m0 x0 h16 y4e3d ff172 fs6 fc0 sc0 ls21">//严格模式：抛出错误，因为this的值为null </div><div class="t m0 x0 hb y4e3e ff172 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4e3f ff172 fs6 fc0 sc0 ls21 wsb">var color = &quot;red&quot;; </div><div class="t m0 x0 hb y4e40 ff172 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4e41 ff172 fs6 fc0 sc0 ls21 wsb">function displayColor(){ </div><div class="t m0 x0 hb y4e42 ff172 fs6 fc0 sc0 ls21 wsb">    alert(this.color); </div><div class="t m0 x0 hb y4e43 ff172 fs6 fc0 sc0 ls21 wsb">}  </div><div class="t m0 x0 hb y4e44 ff172 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4e45 ff172 fs6 fc0 sc0 ls21 wsb">displayColor.call(null); </div><div class="t m0 x0 h5 y4e46 ff16c fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h4 y4e47 ff16f fs2 fc0 sc0 ls8 ws1">以上代码向displayColor.call()中传入了null，如果在是非严格模式下，这意味着函数的this</div><div class="t m0 x0 h4 ya4f ff16f fs2 fc0 sc0 ls8 ws1">值是全局对象。结果就是弹出对话框显示&quot;red&quot;。而在严格模式下，这个函数的this的值是null，因</div><div class="t m0 x0 hc y4e48 ff16f fs2 fc0 sc0 ls8 ws1">此在访问null的属性时就会抛出错误。 </div><div class="t m0 x0 hd y4e49 ff170 fs7 fc0 sc0 ls4d3 ws467">B.8 其他变化 </div><div class="t m0 x0 h4 y38c3 ff16f fs2 fc0 sc0 ls8 ws1">严格模式还有其他一些变化，希望读者也能留意。首先是抛弃了with语句。非严格模式下的with</div><div class="t m0 x0 h4 y4694 ff16f fs2 fc0 sc0 ls8 ws1">语句能够改变解析标识符的路径，但在严格模式下，with被简化掉了。因此，在严格模式下使用with</div><div class="t m0 x0 h5 y3a8c ff16f fs2 fc0 sc0 ls8 ws1">会导致语法错误。 </div><div class="t m0 x0 hb y2be6 ff172 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4e4a ff172 fs6 fc0 sc0 ls21 ws34">//with的语句用法 </div><div class="t m0 x0 h16 y4e4b ff172 fs6 fc0 sc0 ls21">//非严格模式：允许 </div><div class="t m0 x0 h16 y4e4c ff172 fs6 fc0 sc0 ls21">//严格模式：抛出语法错误 </div><div class="t m0 x0 hb y4e4d ff172 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4e4e ff172 fs6 fc0 sc0 ls21 wsb">with(location){ </div><div class="t m0 x0 hb y4e4f ff172 fs6 fc0 sc0 ls21 wsb">    alert(href); </div><div class="t m0 x0 hb y4e50 ff172 fs6 fc0 sc0 ls21 wsb">} </div><div class="t m0 x0 hb y4e51 ff172 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y2fc5 ff16f fs2 fc0 sc0 ls8 ws1">严格模式也去掉了JavaScript中的八进制字面量。以0开头的八进制字面量过去经常会导致很多错</div><div class="t m0 x0 h5 y4e52 ff16f fs2 fc0 sc0 ls8 ws1">误。在严格模式下，八进制字面量已经成为无效的语法了。 </div></div></div>
<div id="pf2e4" class="pf w0 h0" data-page-no="2e4"><div class="pc pc2e4 w0 h0"><div class="t m0 x0 h2 y1 ff16c fs0 fc0 sc0 ls7 ws0">722  附录B 严格模式 </div><div class="t m0 x0 h3 y2 ff16c fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y79 ff172 fs6 fc0 sc0 ls21">//使用八进制字面量 </div><div class="t m0 x0 h16 y7a ff172 fs6 fc0 sc0 ls21">//非严格模式：值为8 </div><div class="t m0 x0 h16 y7b ff172 fs6 fc0 sc0 ls21">//严格模式：抛出语法错误 </div><div class="t m0 x0 hb y7c ff172 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y7d ff172 fs6 fc0 sc0 ls21 wsb">var value = 010; </div><div class="t m0 x0 h5 y2bca ff16c fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y4e53 ff16f fs2 fc0 sc0 ls8 ws1">本书前面提到过，ECMAScript 5也修改了严格模式下parseInt()的行为。如今，八进制字面量在</div><div class="t m0 x0 h5 y4e54 ff16f fs2 fc0 sc0 ls8 ws1">严格模式下会被当作以0开头的十进制字面量。例如： </div><div class="t m0 x0 hb y4e55 ff172 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h16 y4e56 ff172 fs6 fc0 sc0 ls21">//使用parseInt()解析八进制字面量 </div><div class="t m0 x0 h16 y4e57 ff172 fs6 fc0 sc0 ls21">//非严格模式：值为8 </div><div class="t m0 x0 h16 y4e58 ff172 fs6 fc0 sc0 ls21">//严格模式：值为10 </div><div class="t m0 x0 hb y4e59 ff172 fs6 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 hb y4e5a ff172 fs6 fc0 sc0 ls21 wsb">var value = parseInt(&quot;010&quot;); </div><div class="t m0 x0 h5 y2d3d ff16c fs2 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf2e5" class="pf w0 h0" data-page-no="2e5"><div class="pc pc2e5 w0 h0"><div class="t m0 x2 h2 y1 ff178 fs0 fc0 sc0 ls8 ws256">附录C JavaScript库  723 </div><div class="t m0 x0 h3 y2 ff179 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff17a fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff17a fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff17a fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff17a fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff17a fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff17a fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff17a fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff17a fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff17a fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff17a fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff17a fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff17a fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff17a fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h9 y2a ff17b fs5 fc0 sc0 ls8 wsb">JavaScript库 </div><div class="t m0 x0 h5 y2e0 ff179 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x5 h5 y4bdd ff179 fs2 fc0 sc0 ls1b ws6e">avaScript库可以帮助我们跨越浏览器差异的鸿沟，并对复杂的浏览器功能提供更为简便的访问</div><div class="t m0 x5 h5 y4bde ff17c fs2 fc0 sc0 ls8 ws1">方式。程序库有两种形式：通用库和专用库。通用JavaScript库提供了对常见浏览器功能的访</div><div class="t m0 x0 h5 y4bdf ff17c fs2 fc0 sc0 ls8 ws1">问，可以作为网站或者Web应用的基础。专用库则只做特定的事，仅用于网站或者Web 应用的某些部</div><div class="t m0 x0 h5 y4be0 ff17c fs2 fc0 sc0 ls8 ws1">分。本附录给出了这些库与其功能的概况，并提供了相关网站作为你的参考资源。  </div><div class="t m0 x0 hd y26e ff17d fs7 fc0 sc0 ls8 ws3b6">C.1 通用库 </div><div class="t m0 x0 h5 y4e5b ff17c fs2 fc0 sc0 ls8 ws1">通用JavaScript库提供横跨几个主题的功能。所有的通用库都尝试通过使用新API包装常见功能来</div><div class="t m0 x0 h5 y4e5c ff17c fs2 fc0 sc0 ls8 ws1">统一浏览器的接口、减小实现差异。某些API看上去与原生功能很相似，而另一些则完全不同。通用库</div><div class="t m0 x0 h5 y4e5d ff17c fs2 fc0 sc0 ls8 ws1">一般提供与DOM交互的功能、支持Ajax、同时还有一些协助常见任务的工具方法。  </div><div class="t m0 x0 h20 y4e5e ff17d fs3 fc0 sc0 ls283 ws34b">C.1.1 YUI  </div><div class="t m0 x0 h5 y4e5f ff17c fs2 fc0 sc0 ls5 ws4">它是一个开源JavaScript与CSS库，以一种组件方式设计的。这个库不只有一个文件；它包含了</div><div class="t m0 x0 h5 y4e60 ff17c fs2 fc0 sc0 ls24">很多文件，提供各种不同的配置，让你可以按需载入。YUI（Yahoo!User Interface Library，雅虎用户</div><div class="t m0 x0 h5 y4e61 ff17c fs2 fc0 sc0 ls5 ws4">界面库）涵盖了JavaScript的所有方面，从基本的工具及帮助函数到完善的浏览器部件。在雅虎有一支</div><div class="t m0 x0 h5 y4e62 ff17c fs2 fc0 sc0 ls5 ws4">专门的软件工程师团队负责YUI，他们提供了优秀的文档和支持。 </div><div class="t m0 x0 h5 y4e63 ff17f fs1 fc0 sc0 ls2"> 协议：BSD许可证 </div><div class="t m0 x0 h5 y36ae ff17f fs1 fc0 sc0 ls2"> 网站：http://yuilibrary.com </div><div class="t m0 x0 h20 y1b86 ff17d fs3 fc0 sc0 ls283 ws34b">C.1.2 Prototype  </div><div class="t m0 x0 h5 y4e64 ff17c fs2 fc0 sc0 ls8 ws1">它是一个提供了常见任务API的开源库。最初是针对Ruby on Rails框架中的使用而开发的，Prototype</div><div class="t m0 x0 h5 y9c ff17c fs2 fc0 sc0 ls8 ws1">是类驱动的，旨在为JavaScript提供类定义和继承。因此，Prototype提供了很多类，用于将常见或复杂</div><div class="t m0 x0 h5 y2fc2 ff17c fs2 fc0 sc0 ls8 ws1">功能封装为简单的API调用。Prototype只有一个单独的文件，可以很容易地放入任意页面。它是由Sam </div><div class="t m0 x0 h5 y4e65 ff179 fs2 fc0 sc0 ls138 ws133">Stephenson撰写并维护的。 </div><div class="t m0 x0 h5 ycc2 ff17f fs1 fc0 sc0 ls2"> 协议：MIT许可证或者是Creative Commons Attribution-Share Alike 3.0 Unported </div><div class="t m0 x0 h5 y4e66 ff17f fs1 fc0 sc0 ls2"> 网站：http://www.prototypejs.org/ </div><div class="t m0 x0 h20 yfd6 ff17d fs3 fc0 sc0 ls283 ws34b">C.1.3 Dojo Toolkit  </div><div class="t m0 x0 h5 y340d ff179 fs2 fc0 sc0 ls25 ws61">Dojo Toolkit开源库基于一种包系统建模，一组功能组成一个包，可以按需载入。Dojo提供了范围</div><div class="t m0 x0 h5 y4e67 ff17c fs2 fc0 sc0 ls8 ws1">广泛的选项和配置，几乎涵盖了你要用JavaScript做的任何事情。Dojo Toolkit由Alex Russell创建，并</div><div class="t m0 x0 hf0 y4941 ff180 fs14 fc0 sc0 ls8">J</div><div class="t m0 x0 h11 y4b ff181 fsa fc0 sc0 ls8">附录</div><div class="t m1 x5 h12 y4b ff182 fsb fc3 sc0 ls8">C</div><div class="t m0 x5 h9 y4b ff17b fs5 fc3 sc0 ls8 wsb"> </div></div></div>
<div id="pf2e6" class="pf w0 h0" data-page-no="2e6"><div class="pc pc2e6 w0 h0"><div class="t m0 x0 h2 y1 ff179 fs0 fc0 sc0 ls7 ws0">724  附录C JavaScript库 </div><div class="t m0 x0 h3 y2 ff179 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff17c fs2 fc0 sc0 ls3b">由Dojo基金会的雇员和志愿者维护。 </div><div class="t m0 x0 h5 y4 ff17f fs1 fc0 sc0 ls2"> 协议：新BSD许可证或学术自由协议2.1版 </div><div class="t m0 x0 h5 y4e ff17f fs1 fc0 sc0 ls2"> 网站：http://www.dojotoolkit.org/  </div><div class="t m0 x0 h20 y4e68 ff17d fs3 fc0 sc0 ls283 ws34b">C.1.4 MooTools  </div><div class="t m0 x0 h5 y32ca ff179 fs2 fc0 sc0 lsd ws8">MooTools是一个为了精简和优化而设计的开源库，它为内置JavaScript对象添加了各种方法，以通</div><div class="t m0 x0 h5 y4e69 ff17c fs2 fc0 sc0 ls8 ws1">过接近的接口提供新功能，或者直接提供新的对象。MooTools的短小精悍受到一些Web开发者的青睐。 </div><div class="t m0 x0 h5 ya ff17f fs1 fc0 sc0 ls2"> 协议：MIT许可证 </div><div class="t m0 x0 h5 y4e6a ff17f fs1 fc0 sc0 ls2"> 网站：http://www.mootools.net/  </div><div class="t m0 x0 h20 yeb5 ff17d fs3 fc0 sc0 ls283 ws34b">C.1.5 jQuery  </div><div class="t m0 x0 h5 y4e6b ff179 fs2 fc0 sc0 ls1d7 ws184">jQuery是一个给JavaScript提供了函数式编程接口的开源库。它是一个完整的库，其核心是构建于</div><div class="t m0 x0 h5 y28d3 ff179 fs2 fc0 sc0 ls14d ws11a">CSS选择器上的，用来操作DOM元素。通过链式调用，jQuery代码看上去更像是对于应该发生什么的</div><div class="t m0 x0 h5 y4e6c ff17c fs2 fc0 sc0 ls8 ws1">描述而不是JavaScript代码。这种代码风格在设计师和原型制作人中非常流行。jQuery是由John Resig</div><div class="t m0 x0 h5 y4e6d ff17c fs2 fc0 sc0 ls8 ws1">撰写并维护的。 </div><div class="t m0 x0 h5 y4e6e ff17f fs1 fc0 sc0 ls2"> 协议：MIT许可证或通用公共许可证（GPL） </div><div class="t m0 x0 h5 y3ea2 ff17f fs1 fc0 sc0 ls2"> 网站：http://jquery.com/  </div><div class="t m0 x0 h20 y230a ff17d fs3 fc0 sc0 ls283 ws34b">C.1.6 MochiKit  </div><div class="t m0 x0 h5 y264c ff179 fs2 fc0 sc0 ls14d ws11a">MochKit是一个由一些小工具组成的开源库，它以完善的文档和完整的测试见长，拥有大量API及</div><div class="t m0 x0 h5 y32d9 ff17c fs2 fc0 sc0 ls8 ws1">相关范例文档以及数百个测试来确保质量。MochiKit是由Bob Ippolito撰写并维护的。 </div><div class="t m0 x0 h5 y4e6f ff17f fs1 fc0 sc0 ls2"> 协议：MIT许可者或学术自由许可证2.1版 </div><div class="t m0 x0 h5 y6fa ff17f fs1 fc0 sc0 ls2"> 网站：http://www.mochikit.com/  </div><div class="t m0 x0 h20 y1046 ff17d fs3 fc0 sc0 ls283 ws34b">C.1.7 Underscore.js </div><div class="t m0 x0 h5 yed9 ff17c fs2 fc0 sc0 ls8 ws1">虽然严格来讲Underscore.js并不是一个通用的库，但它的确为JavaScript中的功能性编程提供了很</div><div class="t m0 x0 h5 y4e70 ff17c fs2 fc0 sc0 ls8 ws1">多额外的功能。其文档称Underscore.js是对jQuery的补充，提供了操作对象、数组、函数和其他JavaScript</div><div class="t m0 x0 h5 y4e71 ff17c fs2 fc0 sc0 ls8 ws1">数据类型的更多的低级功能。Underscore.js由DcoumentCloud的Jeremy Ashkenas维护。 </div><div class="t m0 x0 h5 y4e72 ff17f fs1 fc0 sc0 ls2"> 协议：MIT许可证 </div><div class="t m0 x0 h5 y4e73 ff17f fs1 fc0 sc0 ls2"> 网站：http://documentcloud.github.com/underscore/  </div><div class="t m0 x0 hd y7cc ff17d fs7 fc0 sc0 ls8 ws3b6">C.2 互联网应用  </div><div class="t m0 x0 h5 y4506 ff17c fs2 fc0 sc0 ls8 ws1">互联网应用库是针对于简化完整的Web应用开发而设计的。它们并不提供应用问题的小块组件，</div><div class="t m0 x0 h4 y21b0 ff17c fs2 fc0 sc0 ls8 ws1">而是提供了快速应用开发的整个概念框架。虽然这些库也可能提供一些底层功能，但他们的目标是帮助</div><div class="t m0 x0 h5 y4e74 ff17c fs2 fc0 sc0 ls8 ws1">用户快速开发Web应用。  </div><div class="t m0 x0 h20 y4e75 ff17d fs3 fc0 sc0 ls283 ws34b">C.2.1 Backbone.js </div><div class="t m0 x0 h5 y340e ff179 fs2 fc0 sc0 ls25 wsb3">Backbone.js是构建于Underscore.js基础之上的一个迷你MVC开源库，它针对单页应用进行优化，</div></div></div>
<div id="pf2e7" class="pf w0 h0" data-page-no="2e7"><div class="pc pc2e7 w0 h0"><div class="t m0 x2 h2 y1 ff178 fs0 fc0 sc0 ls8 ws256">附录C JavaScript库  725 </div><div class="t m0 x0 h3 y2 ff179 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff17a fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff17a fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff17a fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff17a fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff17a fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff17a fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff17a fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff17a fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff17a fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff17a fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff17a fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff17a fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff17a fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h5 y3 ff17c fs2 fc0 sc0 ls57 wsa9">让你能够随着应用状态变化方便地更新页面的任意部分。Backbone.js由DcoumentCloud的Jeremy </div><div class="t m0 x0 h5 y4d ff179 fs2 fc0 sc0 ls14d ws11a">Ashkenas维护。 </div><div class="t m0 x0 h5 y4e ff17f fs1 fc0 sc0 ls2"> 协议：MIT许可证 </div><div class="t m0 x0 h5 yd9 ff17f fs1 fc0 sc0 ls2"> 网站：http://documentcloud.github.com/backbone/  </div><div class="t m0 x0 h20 y228f ff17d fs3 fc0 sc0 ls283 ws34b">C.2.2 Rico  </div><div class="t m0 x0 h5 y2290 ff179 fs2 fc0 sc0 lsfa wsc9">Rico是一个开源库，旨在让行为丰富的互联网应用的开发更加简单。它提供了Ajax、动画、样式</div><div class="t m0 x0 h5 y2291 ff17c fs2 fc0 sc0 ls8 ws1">以及部件的工具。这个库由一些志愿者组成的小团队维护，但是2008年起开发速度大大减慢了。 </div><div class="t m0 x0 h5 y2292 ff17f fs1 fc0 sc0 ls2"> 协议：Apache许可证2.0 </div><div class="t m0 x0 h5 y2293 ff17f fs1 fc0 sc0 ls2"> 网站：http://openrico.org/  </div><div class="t m0 x0 h20 y4e76 ff17d fs3 fc0 sc0 ls283 ws34b">C.2.3 qooxdoo  </div><div class="t m0 x0 h5 y4e77 ff17c fs2 fc0 sc0 ls8 ws1">它是一个旨在为整个互联网应用开发周期提供帮助的开源库。qooxdoo实现了它自己的类和接口，</div><div class="t m0 x0 h5 y1d44 ff17c fs2 fc0 sc0 ls8 ws1">用于创建类似于传统面向对象语言的编程模型。这个库包含了一个完整的GUI工具包以及用于简化前端</div><div class="t m0 x0 h5 y4e78 ff17c fs2 fc0 sc0 ls8 ws1">构建过程的编译器。qooxdoo起初是1&amp;1webhosting公司（www.1and1.com）的内部使用库，后来基于</div><div class="t m0 x0 h5 y4e79 ff17c fs2 fc0 sc0 ls8 ws1">开源协议发布了。1&amp;1骋用了一些全职开发者来维护和开发这个库。 </div><div class="t m0 x0 h5 y626 ff17f fs1 fc0 sc0 ls2"> 协议：GNU 较宽松公共许可证（LGPL）或者Eclipse公共许可证（EPL） </div><div class="t m0 x0 h5 y627 ff17f fs1 fc0 sc0 ls2"> 网站：http://www.qooxdoo.org/  </div><div class="t m0 x0 hd y5b0 ff17d fs7 fc0 sc0 ls8 ws3b6">C.3 动画和特效  </div><div class="t m0 x0 h5 y32da ff17c fs2 fc0 sc0 ls8 ws1">动画和其他视觉特效也成为了Web开发的重要部分。在网页上做出流畅的动画是一个很重要的任</div><div class="t m0 x0 h5 y32db ff17c fs2 fc0 sc0 ls8 ws1">务，一些开发者已经做出了易用的库，提供流畅的动画和特效。前面提到的很多通用JavaScript库也有</div><div class="t m0 x0 h5 y32dc ff17c fs2 fc0 sc0 ls8 ws1">动画功能。  </div><div class="t m0 x0 h20 y85b ff17d fs3 fc0 sc0 ls283 ws34b">C.3.1 script.aculo.us  </div><div class="t m0 x0 h5 y4e7a ff179 fs2 fc0 sc0 ls79 ws6c">script.aculo.us是Prototype的“同伴”，它提供了出色特效的简单使用方式，使用的东西不超过是CSS</div><div class="t m0 x0 h5 y24f7 ff17c fs2 fc0 sc0 ls3b">和DOM。Prototype必须在使用script.aculo.us之前载入。script.aculo.us是最流行的特效库之一，世界上</div><div class="t m0 x0 h5 y4e7b ff17c fs2 fc0 sc0 ls8 ws1">很多网站和Web应用都在使用它。它的作者Thomas Fuchs积极地维护着script.aculo.us。 </div><div class="t m0 x0 h5 y4e73 ff17f fs1 fc0 sc0 ls2"> 协议：MIT许可证 </div><div class="t m0 x0 h5 y4e7c ff17f fs1 fc0 sc0 ls2"> 网站：http://script.aculo.us/  </div><div class="t m0 x0 h20 ye53 ff17d fs3 fc0 sc0 ls283 ws34b">C.3.2 moo.fx  </div><div class="t m0 x0 h5 y1b4a ff179 fs2 fc0 sc0 ls45e ws3de">moo.fx开源动画库是设计在Prototype或者MooTools之上运行的。它的目标是尽可能小（最新的版</div><div class="t m0 x0 h5 y4e7d ff17c fs2 fc0 sc0 ls8 ws1">本是3KB)，并支持开发人员用尽可能少的代码创建动画。MooTools是默认包含moo.fx的，但也可以单</div><div class="t m0 x0 h5 y4e7e ff17c fs2 fc0 sc0 ls8 ws1">独下载用于Prototype中。 </div><div class="t m0 x0 h5 y4e7f ff17f fs1 fc0 sc0 ls2"> 协议：MIT许可证 </div><div class="t m0 x0 h5 y1bb2 ff17f fs1 fc0 sc0 ls2"> 网站：http://moofx.mad4milk.net/  </div></div></div>
<div id="pf2e8" class="pf w0 h0" data-page-no="2e8"><div class="pc pc2e8 w0 h0"><div class="t m0 x0 h2 y1 ff179 fs0 fc0 sc0 ls7 ws0">726  附录C JavaScript库 </div><div class="t m0 x0 h3 y2 ff179 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h20 y43c3 ff17d fs3 fc0 sc0 ls283 ws34b">C.3.3 Lightbox  </div><div class="t m0 x0 h5 y4e80 ff179 fs2 fc0 sc0 ls4e1 ws484">Lightbox是一个用于在任意页面上创建图像浮动层的JavaScript 库，依赖于Prototype和</div><div class="t m0 x0 h5 y4e81 ff179 fs2 fc0 sc0 lsf1 ws485">script.aculo.us来实现它的视觉特效。基本的理念是让用户在一个浮动层中浏览一个或者一系列图像，</div><div class="t m0 x0 h5 y4e82 ff17c fs2 fc0 sc0 lsa ws53">而不必离开当前页面。Lightbox浮动层无论是外观还是过渡效果都可以自定义。Lightbox由Lokesh </div><div class="t m0 x0 h5 y4e83 ff179 fs2 fc0 sc0 lsf1 ws485">Dhakar开发并维护。 </div><div class="t m0 x0 h5 y1707 ff17f fs1 fc0 sc0 ls2"> 协议：创作共用协议2.5 </div><div class="t m0 x0 h5 y4e84 ff17f fs1 fc0 sc0 ls2"> 网站：http://www.huddletotegher.com/projects/lightbox2/  </div><div class="t m0 x0 hd y428 ff17d fs7 fc0 sc0 ls8 ws3b6">C.4 加密  </div><div class="t m0 x0 h5 y4e85 ff17c fs2 fc0 sc0 ls8 ws1">随着Ajax应用的流行，对于浏览器端加密以确保通讯安全的需求也越来越多。幸好，一些人已经</div><div class="t m0 x0 h5 y4bfa ff17c fs2 fc0 sc0 ls3b">在JavaScript中实现了常用的安全算法。这些库大部分并没有其作者的正式支持，但还是被广泛应用着。  </div><div class="t m0 x0 h20 y10fa ff17d fs3 fc0 sc0 ls283 ws34b">C.4.1 JavaScript MD5  </div><div class="t m0 x0 h5 y3dd6 ff17c fs2 fc0 sc0 ls8 ws1">该开源库实现了MD4、MD5以及SHA-1安全散列函数。作者Paul Johnston和其他一些贡献者将每</div><div class="t m0 x0 h5 y4e86 ff17c fs2 fc0 sc0 ls8 ws1">个算法作为一个文件，创建了这个用于Web应用的丰富的库。主页上提供了散列算法的概述、对于其</div><div class="t m0 x0 h5 y4e87 ff17c fs2 fc0 sc0 ls8 ws1">弱点的讨论以及适当的使用方法。 </div><div class="t m0 x0 h5 y1dbe ff17f fs1 fc0 sc0 ls2"> 协议：BSD许可证 </div><div class="t m0 x0 h5 y4e88 ff17f fs1 fc0 sc0 ls2"> 网站：http://pajhome.org.uk/crypt/md5  </div><div class="t m0 x0 h20 y2430 ff17d fs3 fc0 sc0 ls283 ws34b">C.4.2 JavaScrypt  </div><div class="t m0 x0 h5 y4e89 ff17c fs2 fc0 sc0 ls98">该JavaScript库实现了MD5和AES（256位）加密算法。JavaScrypt的网站提供了很多关于密码学</div><div class="t m0 x0 h5 y4e8a ff17c fs2 fc0 sc0 ls8 ws1">历史及其在计算机中应用的信息。但是缺乏关于如何将该库集成到Web应用中的基本文档，JavaScrypt</div><div class="t m0 x0 h5 y4e8b ff17c fs2 fc0 sc0 ls8 ws1">的代码里面全都是深奥的数学处理和计算。 </div><div class="t m0 x0 h5 y4e8c ff17f fs1 fc0 sc0 ls2"> 协议：公共域 </div><div class="t m0 x0 h5 y2efc ff17f fs1 fc0 sc0 ls2"> 网站：http://www.fourmilab.ch/javascrypt/ </div><div class="t m0 x0 h5 y4e8d ff179 fs2 fc0 sc0 ls8 wsb"> </div></div></div>
<div id="pf2e9" class="pf w0 h0" data-page-no="2e9"><div class="pc pc2e9 w0 h0"><div class="t m0 x4 h2 y1 ff183 fs0 fc0 sc0 ls8 ws256">附录D JavaScript工具   727 </div><div class="t m0 x0 h3 y2 ff184 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff185 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff185 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff185 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff185 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff185 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff185 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff185 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff185 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff185 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff185 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff185 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff185 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff185 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h9 y2a ff186 fs5 fc0 sc0 ls8 wsb">JavaScript工具 </div><div class="t m0 x0 h5 y2e0 ff184 fs2 fc0 sc0 ls8 wsb"> </div><div class="t m0 x5 h5 y4bdd ff184 fs2 fc0 sc0 lsb ws5">JavaScript代码和用其他语言编写代码很像，使用工具能够提高工作效率。JavaScript开发人</div><div class="t m0 x5 h5 y4bde ff187 fs2 fc0 sc0 ls8 ws1">员可用的工具数量一度爆发性增长，使得查找问题、优化和部署基于JavaScript的解决方案更</div><div class="t m0 x0 h5 y4bdf ff187 fs2 fc0 sc0 ls8 ws1">为简单。其中一些工具是专为JavaScript设计使用的，而其他一些可以在浏览器之外运行。本附录对其</div><div class="t m0 x0 h5 y4be0 ff187 fs2 fc0 sc0 ls8 ws1">中一些工具给出了概述，并额外提供了信息资源。 </div><div class="t m0 x0 hd y26e ff188 fs7 fc0 sc0 ls8 ws3b6">D.1 校验器 </div><div class="t m0 x0 h5 y4e5b ff184 fs2 fc0 sc0 lsb ws5">JavaScript调试有一个问题，很多IDE并不能在输入的时候自动指出语法错误。大多数开发者写了</div><div class="t m0 x0 h5 y4e5c ff187 fs2 fc0 sc0 ls8 ws1">一部分代码之后要将其载入到浏览器中查找错误。你可以通过在部署之前校验JavaScript代码，以便显</div><div class="t m0 x0 h5 y4e5d ff187 fs2 fc0 sc0 ls8 ws1">著地减少此类错误。校验器提供了基本的语法检查，并给出某些风格的警告。  </div><div class="t m0 x0 h20 y4e5e ff188 fs3 fc0 sc0 ls283 ws34b">D.1.1 JSLint  </div><div class="t m0 x0 h5 y4e5f ff184 fs2 fc0 sc0 ls81 ws76">JSLint是一个由Douglas Crockford撰写的JavaScript校验器。它通过跨浏览器问题的最小共同点检</div><div class="t m0 x0 h4 y4e60 ff187 fs2 fc0 sc0 ls24 ws1e">查，能够从核心层次上检查语法错误。（它遵循最严格的规则来确保代码到处都能运行。）你可以启用</div><div class="t m0 x0 h5 y4e61 ff184 fs2 fc0 sc0 ls7a ws89">Crockford对于代码风格的警告，包括代码格式、未声明的全局变量的使用以及其他更多警告。尽管JSLint</div><div class="t m0 x0 h5 y4e62 ff187 fs2 fc0 sc0 ls8 ws1">是用JavaScript写的，但是通过基于Java的Rhino 解释器，它可以在命令行中运行，或者通过WScript</div><div class="t m0 x0 h5 y4e8e ff187 fs2 fc0 sc0 ls8 ws1">或者其他JavaScript解释器。网站上提供了针对各种命令行解释器的自定义版本。 </div><div class="t m0 x0 h5 y36ae ff18a fs1 fc0 sc0 ls2"> 价格：免费 </div><div class="t m0 x0 h5 y4e8f ff18a fs1 fc0 sc0 ls2"> 网站：http://www.jslint.com/  </div><div class="t m0 x0 h20 y4e90 ff188 fs3 fc0 sc0 ls283 ws34b">D.1.2 JSHint </div><div class="t m0 x0 h5 y9c ff184 fs2 fc0 sc0 lsd ws8">JSHint是JSLint的一个分支，为应用规则提供了更多的自定义功能。与JSLint类似，它首先检查语</div><div class="t m0 x0 h5 y2fc2 ff187 fs2 fc0 sc0 ls8 ws1">法错误，然后检查有问题的编码模式。JSLint的每一项检查JSHint都有，但开发人员可以更好地控制应</div><div class="t m0 x0 h5 y4e65 ff187 fs2 fc0 sc0 ls8 ws1">用什么规则。与JSLint一样，JSHint也能使用Rhino在命令行中运行。 </div><div class="t m0 x0 h5 ycc2 ff18a fs1 fc0 sc0 ls2"> 价格：免费 </div><div class="t m0 x0 h5 y4e66 ff18a fs1 fc0 sc0 ls2"> 网站：http://www.jshint.com/ </div><div class="t m0 x0 h20 yfd6 ff188 fs3 fc0 sc0 ls283 ws34b">D.1.3 JavaScript Lint  </div><div class="t m0 x0 h5 y340d ff187 fs2 fc0 sc0 ls8 ws1">它和JSLint完全不相干，JavaScript Lint是Matthias Miller写的一个基于C的JavaScript 校验器。它</div><div class="t m0 x0 h5 y4e67 ff187 fs2 fc0 sc0 ls8 ws1">使用了SpiderMonkey（即Firefox所用的JavaScript解释器）来分析代码并查找语法错误。这个工具包含</div><div class="t m0 x0 h6f yfbd ff189 fsf fc0 sc0 ls8 wsb">写 </div><div class="t m0 x0 h11 y4b ff18b fsa fc0 sc0 ls8">附录</div><div class="t m1 x5 h12 y4b ff18c fsb fc3 sc0 ls8">D</div><div class="t m0 x5 h9 y4b ff186 fs5 fc3 sc0 ls8 wsb"> </div></div></div>
<div id="pf2ea" class="pf w0 h0" data-page-no="2ea"><div class="pc pc2ea w0 h0"><div class="t m0 x0 h2 y1 ff184 fs0 fc0 sc0 ls7 ws0">728  附录D JavaScript工具 </div><div class="t m0 x0 h3 y2 ff184 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff187 fs2 fc0 sc0 ls8 ws1">大量选项，可以启用额外关于编码风格的警告，以及未声明的变量和不可到达的代码警告。Windows和</div><div class="t m0 x0 h5 y4d ff184 fs2 fc0 sc0 lsc7 wsa4">Macintosh上都有可用的JavaScript Lint，源代码也可以自由取得。 </div><div class="t m0 x0 h5 y4e ff18a fs1 fc0 sc0 ls2"> 价格：免费 </div><div class="t m0 x0 h5 yd9 ff18a fs1 fc0 sc0 ls2"> 网站：http://www.javascriptlint.com/  </div><div class="t m0 x0 hd y8 ff188 fs7 fc0 sc0 ls8 ws3b6">D.2 压缩器  </div><div class="t m0 x0 h5 y1f ff184 fs2 fc0 sc0 lsb ws5">JavaScript构建过程中很重要的一部分，是压缩输出并移除多余的字符。这样做可以确保传送到浏</div><div class="t m0 x0 h5 y8c9 ff187 fs2 fc0 sc0 ls8 ws1">览器的字节数最少，最终加速了用户体验。有几种压缩比率不同的工具可以选择。 </div><div class="t m0 x0 h20 y4e91 ff188 fs3 fc0 sc0 ls283 ws34b">D.2.1 JSMin  </div><div class="t m0 x0 h5 y1ad1 ff184 fs2 fc0 sc0 lsb5 ws93">JSMin是由Douglas Crockford写的一个基于C的压缩器，进行最基本的JavaScript 压缩。它主要是</div><div class="t m0 x0 h5 y4e92 ff187 fs2 fc0 sc0 ls8 ws1">移除空白和注释，确保最终的代码依然可以被顺利执行。JSMin有Windows执行程序，包括C版本代码，</div><div class="t m0 x0 h5 y4e93 ff187 fs2 fc0 sc0 ls8 ws1">还有其他语言的代码： </div><div class="t m0 x0 h5 y113 ff18a fs1 fc0 sc0 ls2"> 价格：免费 </div><div class="t m0 x0 h5 y4e94 ff18a fs1 fc0 sc0 ls2"> 网站：http://www.crockford.com/javascript/jsmin.html  </div><div class="t m0 x0 h20 y3240 ff188 fs3 fc0 sc0 ls283 ws34b">D.2.2 Dojo ShrinkSafe  </div><div class="t m0 x0 h5 y4e95 ff187 fs2 fc0 sc0 ls8 ws1">负责Dojo Toolkit的同一批人开发了一个叫做ShrinkSafe的工具，它使用了Rhino JavaScript 解释器</div><div class="t m0 x0 h5 y3ea4 ff187 fs2 fc0 sc0 ls8 ws1">首先将JavaScript代码解析为记号流，然后用它们来安全压缩代码。和JSMin 一样，ShrinkSafe移除多</div><div class="t m0 x0 h4 y4e96 ff187 fs2 fc0 sc0 ls8 ws1">余的空白符（不包括换行）和注释，但是还更进一步将局部变量替换为两个字符长的变量名。最后可以</div><div class="t m0 x0 h5 y4e97 ff187 fs2 fc0 sc0 ls3b">比JSMin产生更小输出，而没有引入语法错误的风险。 </div><div class="t m0 x0 h5 y6fa ff18a fs1 fc0 sc0 ls2"> 价格：免费 </div><div class="t m0 x0 h5 y38ed ff18a fs1 fc0 sc0 ls2"> 网站：http://shrinksafe.dojotoolkit.org/  </div><div class="t m0 x0 h20 y85b ff188 fs3 fc0 sc0 ls283 ws34b">D.2.3 YUI Compressor  </div><div class="t m0 x0 h5 y4e7a ff184 fs2 fc0 sc0 ls81 ws76">YUI小组有一个叫做YUI Compressor的压缩器。和ShrinkSafe类似，YUI Compressor利用了 Rhino</div><div class="t m0 x0 h5 y24f7 ff187 fs2 fc0 sc0 ls8 ws1">解释器将JavaScript代码解析为记号流，并移除注释和空白字符并替换变量名。与ShrinkSafe不同，YUI </div><div class="t m0 x0 h5 y4e7b ff184 fs2 fc0 sc0 ls90 ws6b">Compressor还移除换行并进行一些细微的优化进一步节省字节数。一般来说，YUI Compressor处理过的</div><div class="t m0 x0 h5 y4e98 ff187 fs2 fc0 sc0 ls8 ws1">文件要小于JSMin或者ShrinkSafe处理过的文件。 </div><div class="t m0 x0 h5 y4e7c ff18a fs1 fc0 sc0 ls2"> 价格：免费 </div><div class="t m0 x0 h5 y4e99 ff18a fs1 fc0 sc0 ls2"> 网站：http://yuilibrary.com /projects/yuicompressor </div><div class="t m0 x0 hd y4e9a ff188 fs7 fc0 sc0 ls8 ws3b6">D.3 单元测试  </div><div class="t m0 x0 h5 y4999 ff184 fs2 fc0 sc0 ls4e ws42">TDD（Test-driven development，测试驱动开发）是一种以单元测试为核心的软件开发过程。直到最</div><div class="t m0 x0 h5 y4e9b ff187 fs2 fc0 sc0 ls8 ws1">近，才出现了一些对JavaScript进行单元测试的工具。现在多数JavaScript库都在它们自己的代码中使用</div><div class="t m0 x0 h5 y4e9c ff187 fs2 fc0 sc0 ls8 ws1">了某种形式的单元测试，其中一些发布了单元测试框架让他人使用。  </div></div></div>
<div id="pf2eb" class="pf w0 h0" data-page-no="2eb"><div class="pc pc2eb w0 h0"><div class="t m0 x4 h2 y1 ff183 fs0 fc0 sc0 ls8 ws256">附录D JavaScript工具   729 </div><div class="t m0 x0 h3 y2 ff184 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x3 h8 y1d ff185 fs3 fc2 sc0 ls1d wsb">1 </div><div class="t m0 x3 h8 y1e ff185 fs3 fc2 sc0 ls1d wsb">2 </div><div class="t m0 x3 h8 y1f ff185 fs3 fc2 sc0 ls1d wsb">3 </div><div class="t m0 x3 h8 y20 ff185 fs3 fc2 sc0 ls8 wse">4 </div><div class="t m0 x3 h8 y21 ff185 fs3 fc2 sc0 ls1d wsb">5 </div><div class="t m0 x3 h8 y22 ff185 fs3 fc2 sc0 ls1d wsb">13 </div><div class="t m0 x3 h8 y23 ff185 fs3 fc2 sc0 ls8 wse">6 </div><div class="t m0 x3 h8 y24 ff185 fs3 fc2 sc0 ls1d wsb">7 </div><div class="t m0 x3 h8 y25 ff185 fs3 fc2 sc0 ls1d wsb">8 </div><div class="t m0 x3 h8 y26 ff185 fs3 fc2 sc0 ls1d wsb">9 </div><div class="t m0 x3 h8 y27 ff185 fs3 fc2 sc0 ls1d wsf">10 </div><div class="t m0 x3 h8 y28 ff185 fs3 fc2 sc0 ls1e wsb">11 </div><div class="t m0 x3 h8 y29 ff185 fs3 fc2 sc0 ls1d wsf">12 </div><div class="t m0 x0 h20 y43c3 ff188 fs3 fc0 sc0 ls283 ws34b">D.3.1 JsUnit  </div><div class="t m0 x0 h5 y4e80 ff187 fs2 fc0 sc0 ls8 ws1">最早的JavaScript单元测试框架，不绑定于任何特定的JavaScript库。JsUnit是Java 知名的JUnit测</div><div class="t m0 x0 h4 y4e81 ff187 fs2 fc0 sc0 ls8 ws1">试框架的移植。测试在页面中运行，并可以设置为自动测试并将结果提交到服务器。它的网站上包含了</div><div class="t m0 x0 h5 y4e82 ff187 fs2 fc0 sc0 ls8 ws1">例子和基本的文档： </div><div class="t m0 x0 h5 y86d ff18a fs1 fc0 sc0 ls2"> 价格：免费 </div><div class="t m0 x0 h5 y1707 ff18a fs1 fc0 sc0 ls2"> 网站：http://www.jsunit.net/  </div><div class="t m0 x0 h20 y4e9d ff188 fs3 fc0 sc0 ls283 ws34b">D.3.2 YUI Test  </div><div class="t m0 x0 h5 y66a ff187 fs2 fc0 sc0 ls8 ws1">作为YUI的一部分，YUI Test不仅可以用于测试使用YUI的代码，也 可以测试网站或者应用中的</div><div class="t m0 x0 h5 y4e9e ff187 fs2 fc0 sc0 ls8 ws1">任何代码。YUI Test包含了简单和复杂的断言，以及一种模拟简单的鼠标和键盘事件的方法。该框架在</div><div class="t m0 x0 h5 y4e9f ff184 fs2 fc0 sc0 ls79 wsdb">Yahoo! Developer Network上有完整的文档描述，包含了例子、API文档和更多内容。测试时在浏览器中</div><div class="t m0 x0 h5 y4ea0 ff187 fs2 fc0 sc0 ls8 ws1">运行，结果输出在页面上。YUI便使用YUI  Test来测试整个库。 </div><div class="t m0 x0 h5 y359a ff18a fs1 fc0 sc0 ls2"> 价格：免费 </div><div class="t m0 x0 h5 y4ea1 ff18a fs1 fc0 sc0 ls2"> 网站：http://yuilibrary.com/projects/yuitest/  </div><div class="t m0 x0 h20 y4ea2 ff188 fs3 fc0 sc0 ls283 ws34b">D.3.3 DOH  </div><div class="t m0 x0 h5 y4ea3 ff184 fs2 fc0 sc0 ls81 ws76">DOH（ Dojo Object Harness）在发布给大家使用之前，最初是作为Dojo内部的单元测试工具出现的。</div><div class="t m0 x0 h5 y4ea4 ff187 fs2 fc0 sc0 ls8 ws1">和其他框架一样，单元测试是在浏览器中运行的。 </div><div class="t m0 x0 h5 y4ea5 ff18a fs1 fc0 sc0 ls2"> 价格：免费  </div><div class="t m0 x0 h5 y4077 ff18a fs1 fc0 sc0 ls2"> 网站：http://www.dojotoolkit.org/  </div><div class="t m0 x0 h20 y4ea6 ff188 fs3 fc0 sc0 ls283 ws34b">D.3.4 qUnit </div><div class="t m0 x0 h5 y4ea7 ff184 fs2 fc0 sc0 ls8 ws20">qUnit是为测试jQuery而开发的一个单元测试框架。jQuery本身的确使用 qUnit进行各项测试。除</div><div class="t m0 x0 h5 y2a3f ff187 fs2 fc0 sc0 ls8 ws1">此之外，qUnit与jQuery并没有绑定关系，也可以用它来测试所有JavaScript代码。qUnit的特点是简单</div><div class="t m0 x0 h5 y2a40 ff187 fs2 fc0 sc0 ls8 ws1">易用，一般开发人员很容易上手。 </div><div class="t m0 x0 h5 y1a5f ff18a fs1 fc0 sc0 ls2"> 价格：免费  </div><div class="t m0 x0 h5 y1a60 ff18a fs1 fc0 sc0 ls2"> 网站：https://github.com/jquery/qunit </div><div class="t m0 x0 hd y2fc ff188 fs7 fc0 sc0 ls8 ws3b6">D.4 文档生成器  </div><div class="t m0 x0 h5 y38fd ff187 fs2 fc0 sc0 ls8 ws1">大多数IDE对于主流语言都包含了文档生成器。由于JavaScript并没有官方的 IDE，过去文档一般</div><div class="t m0 x0 h5 y4ea8 ff187 fs2 fc0 sc0 ls8 ws1">都是手工完成，或者是利用针对其他语言的文档生成器。然而，现在终于有一些专门针对JavaScript的</div><div class="t m0 x0 h5 y4ea9 ff187 fs2 fc0 sc0 ls8 ws1">文档生成器了。  </div><div class="t m0 x0 h20 y1c4b ff188 fs3 fc0 sc0 ls283 ws34b">D.4.1 JsDoc Toolkit  </div><div class="t m0 x0 h5 y4eaa ff184 fs2 fc0 sc0 lsfa ws1fe">JsDoc Toolkit是最早出现的JavaScript文档生成器之一。它要求你在代码中输入类似Javadoc的注释，</div><div class="t m0 x0 h5 y4eab ff187 fs2 fc0 sc0 ls8 ws1">然后处理这些注释并输出为HTML文件。你可以自定义HTML的格式，这需使用预定义的 JsDoc模板</div><div class="t m0 x0 h5 y4eac ff187 fs2 fc0 sc0 ls8 ws1">或者创建自己的模版。JsDoc Toolkit可以以Java包的形式获得。  </div></div></div>
<div id="pf2ec" class="pf w0 h0" data-page-no="2ec"><div class="pc pc2ec w0 h0"><div class="t m0 x0 h2 y1 ff184 fs0 fc0 sc0 ls7 ws0">730  附录D JavaScript工具 </div><div class="t m0 x0 h3 y2 ff184 fs1 fc0 sc0 ls8 wsb"> </div><div class="t m0 x0 h5 y3 ff18a fs1 fc0 sc0 ls2"> 价格：免费  </div><div class="t m0 x0 h5 y4 ff18a fs1 fc0 sc0 ls2"> 网站：http://code.google.com/p/jsdoc-toolkit/  </div><div class="t m0 x0 h20 y4ead ff188 fs3 fc0 sc0 ls283 ws34b">D.4.2 YUI Doc  </div><div class="t m0 x0 h5 y2777 ff184 fs2 fc0 sc0 ls25 ws493">YUI Doc是YUI的文档生成器。该生成器以Python书写，所以它要求安装有Python 运行时环境。</div><div class="t m0 x0 h5 y2888 ff184 fs2 fc0 sc0 ls25 ws61">YUI Doc可以输出集成了属性和方法搜索（用YUI的自动完成挂件实现的）的HTML 文件。和JsDoc</div><div class="t m0 x0 h5 y4eae ff187 fs2 fc0 sc0 ls8 ws1">一样，YUI Doc要求源代码中使用类似Javadoc的注释。默认的HTML可以通过修改默认的HTML 模板</div><div class="t m0 x0 h5 y4eaf ff187 fs2 fc0 sc0 ls8 ws1">文件和相关的样式表来更改。 </div><div class="t m0 x0 h5 y2292 ff18a fs1 fc0 sc0 ls2"> 价格：免费 </div><div class="t m0 x0 h5 y2293 ff18a fs1 fc0 sc0 ls2"> 网站：http://www.yuilibrary.com/projects/yuidoc/ </div><div class="t m0 x0 h20 y2871 ff188 fs3 fc0 sc0 ls283 ws34b">D.4.3 AjaxDoc  </div><div class="t m0 x0 h5 y25f9 ff184 fs2 fc0 sc0 lsd ws8">AjaxDoc的目标和前面提到的生成器有些差异。它不为JavaScript文档生成HTML文件，而是创建</div><div class="t m0 x0 h5 y1a8b ff187 fs2 fc0 sc0 ls8">与针对.NET语言（如C#和Visual Basic. NET）所创建文件相同格式的XML文件。这样做就可以由标准</div><div class="t m0 x0 h5 y2045 ff187 fs2 fc0 sc0 ls8">的.NET文档生成器创建HTML文件形式的文档。AjaxDoc使用类似于所有.NET语言用到的文档注释格</div><div class="t m0 x0 h5 y4eb0 ff187 fs2 fc0 sc0 ls8 ws1">式。创建AjaxDoc是针对ASP.NET的Ajax解决方案，但是它也可以用于单独的项目。 </div><div class="t m0 x0 h5 y4eb1 ff18a fs1 fc0 sc0 ls2"> 价格：免费 </div><div class="t m0 x0 h5 y2297 ff18a fs1 fc0 sc0 ls2"> 网站：http://www.codeplex.com/ajaxdoc  </div><div class="t m0 x0 hd y4e5e ff188 fs7 fc0 sc0 ls8 ws3b6">D.5 安全执行环境  </div><div class="t m0 x0 h5 y2456 ff187 fs2 fc0 sc0 ls8 ws1">随着mashup应用越来越流行，对于允许来自外界的JavaScript存在于同一个页面上并执行有着越来</div><div class="t m0 x0 h4 y4eb2 ff187 fs2 fc0 sc0 ls8 ws1">越多的需求。这导致了一些访问受限功能的安全问题。以下工具旨在创建安全的执行环境，其中不同来</div><div class="t m0 x0 h5 y40d7 ff187 fs2 fc0 sc0 ls8 ws1">源的JavaScript可以共存，而不会互相影响。  </div><div class="t m0 x0 h20 y14fb ff188 fs3 fc0 sc0 ls283 ws34b">D.5.1 ADsafe  </div><div class="t m0 x0 h5 y3290 ff187 fs2 fc0 sc0 ls3b">由Douglas Crockford创建，ADsafe是JavaScript的子集，这个子集被认为可以被第三方脚本安全访</div><div class="t m0 x0 h5 y4eb3 ff187 fs2 fc0 sc0 ls8 ws1">问。对于用ADsafe运行的代码，页面必须包含ADsafe JavaScript库并标记为ADsafe 挂件格式。因此，</div><div class="t m0 x0 h5 y4eb4 ff187 fs2 fc0 sc0 ls8 ws1">代码可以在任何页面上安全执行。 </div><div class="t m0 x0 h5 yc93 ff18a fs1 fc0 sc0 ls2"> 价格：免费 </div><div class="t m0 x0 h5 y1029 ff18a fs1 fc0 sc0 ls2"> 网站：http://www.adsafe.org/  </div><div class="t m0 x0 h20 y2be7 ff188 fs3 fc0 sc0 ls283 ws34b">D.5.2 Caja  </div><div class="t m0 x0 h5 y3a6c ff184 fs2 fc0 sc0 ls152 ws11e">Caja用一种独特的方式来确保JavaScript的安全执行。类似于ADsafe，Caja定义了 JavaScript的一</div><div class="t m0 x0 h5 y4bdb ff187 fs2 fc0 sc0 ls8 ws1">个可以用安全方式使用的子集。Caja继而可以清理JavaScript代码并验证它只按照预期的方式运行。作</div><div class="t m0 x0 h5 y4bdc ff187 fs2 fc0 sc0 ls8 ws1">为该项目的一部分，有一种叫做Cajita的语言，它是JavaScript功能的一种更小的子集。Caja 还处于幼</div><div class="t m0 x0 h5 y4eb5 ff187 fs2 fc0 sc0 ls8 ws1">年期，但是已经展示了很多前景，允许多个脚本在同一个页面执行而没有恶意活动的可能。 </div><div class="t m0 x0 h5 y28cb ff18a fs1 fc0 sc0 ls2"> 价格：免费 </div><div class="t m0 x0 h5 ybe0 ff18a fs1 fc0 sc0 ls2"> 网站：http://code.google.com/p/google-caja/ </div></div></div>
</div>
</body>
</html>
