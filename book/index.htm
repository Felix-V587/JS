<!-- - var ch_num = "0"--><!DOCTYPE html><html><head><meta charset="utf-8"><title>JavaScript 高级程序设计第三版</title><link rel="stylesheet" href="static/css/index.css"><link rel="stylesheet" href="undefinedstyles/monokai-sublime.css"><script src="undefinedhighlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><!--主体--><main><!-- - var ch_num = "0"--><div id="statement"><section><p class="h1">声明</p><p class="paragraph"><strong>本书《JavaScript 高级程序设计》（第三版）版权归原作者所有</strong></p><p class="paragraph important">本站仅以学习交流为目的，手动录入该书籍内容作为练习代码的用途，本站承诺绝不会将本书籍内容用作任何商业目的。如有侵权请联系删除！</p></section></div><div id="preface01"><section><p class="h1">序</p><p class="paragraph">20 多年的职业生涯，我也长出了白头发。回首往事，曾经对我的职业道路产生过重要影响的技术和人历历在目。如果让我只说一种技术，一种对我产生了最大正面影响的技术，那么就是 JavaScript。说实话，我也并非一直都是 JavaScript 的信徒。跟许多人一样，我以前也把它当作一门玩具语言，认为它只能用来做一些旋转的横幅广告，或者在页面中添加一些有意思的交互效果作为装饰。我原来是做服务器端开发的，我们都对这种玩具语言不感冒，该死的！可是，后来 Ajax 出现了。</p><p class="paragraph">永远也忘不了当时无孔不入的 Ajax，大家都认为它是一种非常酷、非常新，同时极具创造性的技术。我也开始了解它，阅读相关资料。知道这门曾被我嗤之以鼻的玩具语言如今被每一位专业 Web 开发人员津津乐道之后，我感到很震惊。突然，我的看法就转变了。随着探索 Ajax 的继续深入，我认识到JavaScript 的强大威力，急切地想了解它能提供的所有“法宝”。于是，我全身心地投入到学习 JavaScript之中，不仅努力学习这门语言，还加入了 jQuery 项目团队，专门从事客户端开发。我的日子过得很爽。</p><p class="paragraph">对 JavaScript 了解得越深，接触的开发人员就越多，其中不乏今天在我眼里依然是巨星和导师级的人物。尼古拉斯·泽卡斯（本书作者）就是这样一位开发人员。我一直记得在读本书第 2 版时心中油然而生的喜悦之情，虽然我也有多年的积累，但仍然从中学到了很多新东西。这本书实实在在、深入浅出，读来就好像尼古拉斯对不同层次的读者都了如指掌，所以他的风格才那么贴切自然。对于技术书来说，这是非常突出的一个特色。多数作者都想靠坚深的技术给人留下印象，但这本书不同。所以，它很快就成为了我案头必备的书，我也会向那些有志全面掌握 JavaScript 的开发人员推荐这本书。我希望每个人对这本书都能有跟我一样的体会，认识到它的价值所在。</p><p class="paragraph">后来，在一次jQuery大会上，我荣幸地见到了尼古拉斯本人。站在我面前的是一位世界顶级的JavaScript开发人员，而且正负责世界上最重要的一个 Web 站点（雅虎）。尼古拉斯是我见过的最随和的人之一。真的，见到他的时候我有一种追星族的幻觉。但他就是那么一个活生生的人，一个想帮助开发人员成就梦想的人。不仅他的书改变了我对 JavaScript 的认识，而且尼古拉斯这个人，也让我愿意接近，愿意了解。</p><p class="paragraph">听说尼古拉斯要请我作序，我激动得不知道说什么才好。在此，我代表大牛来为本书暖场。这个序也是他本人有多么令人景仰的一个明证。不过，更重要的是，这也给了我一个机会，让我能跟大家分享自己为什么觉得这本书如此重要。我看过很多 JavaScript 图书，的确也有很多令人叹服的佳作。但在我看来，这本书为读者成为全方位的 JavaScript 高手提供了“一揽子方案”。</p><p class="paragraph">这本书从介绍表达式和变量声明开始，平滑地过渡到了闭包、面向对象开发等高级主题。与那些把大量篇幅花在讲解背景知识上的书，以及那些让人感觉好像是要使用 JavaScript 开发导弹制导系统的书相比，这本书让人感觉细致周到、亲切自然。这是一本写给“普通人”的书，它能让你编写出引以为荣的代码，构建出令人叫绝的网站。</p><p class="paragraph"><strong>   雷·邦戈（Rey Bango）    微软公司高级布道师，jQuery 项目团队核心成员</strong></p></section></div><div id="preface02"><section><p class="paragraph">献给我的父母，是他们永远给我支持和鼓励。</p><p class="h1">前 言</p><p class="paragraph">从驱动全球商业、贸易及管理领域不计其数的复杂应用程序的角度来看，说 JavaScript 已经成为当今世界上最流行的编程语言一点儿都不为过。</p><p class="paragraph">JavaScript 是一种非常松散的面向对象语言，也是 Web 开发中极受欢迎的一门语言。JavaScript，尽 管它的语法和编程风格与 Java 都很相似，但它却不是 Java 的“轻量级”版本，甚至与 Java 没有任何关 系。JavaScript 是一种全新的动态语言，它植根于全球数亿网民都在使用的 Web 浏览器之中，致力于增 强网站和 Web 应用程序的交互性。</p><p class="paragraph">在本书中，我们将对 JavaScript 追根溯源，从它在最早的 Netscape 浏览器中诞生谈起，一直谈到今 天的它对 DOM 和 Ajax 的强大支持。读者将通过本书掌握如何运用和扩展这门语言，从而更好地满足自 己的需求，以及如何实现客户端与服务器的无缝通信，而又不必求助于 Java 或隐藏的网页框架（frame 元素）。一言以蔽之，本书将教会你在面对各种常见的 Web 开发问题时，如何拿出自己的 JavaScript 解决方案。</p></section><section><p class="h3">本书读者对象</p><p class="paragraph">本书将下列三类人员作为目标读者</p><ol><li>    熟悉面向对象编程、经验丰富而又打算学习 JavaScript 的开发人员，JavaScript 毕竟与 Java、C++等传统 OO 语言存在着诸多联系；</li><li>    有意提升自己网站和 Web 应用程序易用性的 Web 开发人员；</li><li>    希望全面深入地理解这门语言的初级 JavaScript 开发人员。</li></ol><p class="paragraph">此外，本书也适合熟悉下列相关技术的读者阅读：</p><ol><li>Java</li><li>PHP</li><li>ASP.NET</li><li>HTML</li><li>CSS</li><li>XML</li></ol><div class="notes">① 本书中文版《JavaScript 入门经典（第 3 版）》已经由清华大学出版社出版。——译者注（以下脚注如无特殊说明， 均为译者注）</div></section><section><p class="h3">本书内容</p><p class="paragraph">本书提供了 JavaScript 开发人员必须掌握的内容，全面涵盖了 JavaScript 的各种高级、有用的特性。</p><p class="paragraph">本书首先介绍了 JavaScript 的起源及其发展现状，随后讨论了构成 JavaScript 实现的各个组成部分， 重点讲解了 ECMAScript 和 DOM 标准。此外，还对不同 Web 浏览器的 JavaScript 实现之间存在的差异， 给出了相应的说明。</p><p class="paragraph">在此基础上，本书从讲解 JavaScript 的基本概念入手，探讨了 JavaScript 面向对象程序设计和继承的 方式，以及如何在 HTML 等标记语言中使用它。在深入剖析了事件和事件处理之后，又解释了各种浏 览器检测技术。本书还探讨了 HTML5、Selectors API 和 File API 等一系列新 API。</p><p class="paragraph">本书最后一部分专门讨论了高级主题，涉及性能和内存优化、最佳实践以及对 JavaScript 未来的 展望。</p></section><section><p class="h3">本书结构</p><p class="paragraph">本书共 25 章，各章简介如下。</p><p class="paragraph"><span class="strong">第1章“JavaScript 简介”：</span>讲述了 JavaScript 的起源：因何而生，如何发展，现状如何。涉及的  概念主要有 JavaScript 与 ECMAScript 之间的关系、DOM（Document Object Model，文档对象模型）、  BOM（Browser Object Model，浏览器对象模型）。此外，还将讨论 ECMA（European Computer  Manufacturer’s Association，欧洲计算机制造商协会）和 W3C（World Wide Web Consortium，万维网联  盟）制定的一些相关标准。</p><p class="paragraph"><span class="strong">第2章“在 HTML 中使用 JavaScript”：</span>介绍了如何在 HTML 中使用 JavaScript 创建动态网页。  这一章不仅展示了在网页中嵌入 JavaScript 的各种方式，还讨论了 JavaScript 内容类型（content-type）及  其与&lt;script&gt;元素的关系。</p><p class="paragraph"><span class="strong">第3章“基本概念”， 讨论了 JavaScript 语言的基本概念，包括语法和流控制语句。这一章也分析 了 JavaScript 与其他基于 C 的语言在语法上的相同和不同之处，还介绍了与内置操作符有关的类型转换 问题。</span></p><p class="paragraph"><span class="strong">第4章“变量、作用域和内存问题”，</span>探讨了 JavaScript 如何处理其松散类型的变量。这一章还讨 论了原始值和引用值之间的差别，以及与变量有关的执行环境的相应内容。最后，通过介绍 JavaScript 的垃圾收集机制，解释了变量在退出作用域时释放其内存的问题。</p><p class="paragraph"><span class="strong">第5章“引用类型”，</span>详尽介绍了 JavaScript 内置的所有引用类型，如 Object 和 Array。这一 章对 ECMA-262 规范中描述的每一种引用类型既做了理论上的阐释，又从浏览器实现的角度给出了 介绍。</p><p class="paragraph"><span class="strong">第6章“面向对象的程序设计”，</span>讲述了在 JavaScript 中如何实现面向对象的程序设计。由于 JavaScript 没有类的概念，因此这一章从对象创建和继承的层面上展示了一些流行的技术。此外，这一 章还讲解了函数原型的概念，并对函数原型与整个面向对象方法的关系进行了探讨。</p><p class="paragraph"><span class="strong">第7章“函数表达式”，</span>集中介绍了 JavaScript 中最为强大的一个特性——函数表达式。相关的内 容涉及闭包、this 对象的角色、模块模式和创建私有对象成员等。</p><p class="paragraph"><span class="strong">第 8 章“BOM”，</span>介绍 BOM（Browser Object Model，浏览器对象模型），即负责处理与浏览器自 身有关的交互操作的对象集合。这一章全面介绍了每一个 BOM 对象，包括 window、document、location、 navigator 和 screen。</p><p class="paragraph"><span class="strong">第 9 章“客户端检测”，</span>讨论了检测客户端机器及其支持特性的各种手段，包括特性检测及用户代 理字符串检测的不同技术。这一章还就每种手段的优缺点及适用情形给出了详细说明。</p><p class="paragraph"><span class="strong">第 10 章“DOM”，</span>介绍 DOM（Document Object Model，文档对象模型），即 DOM1 规定的 JavaScript 中的 DOM 对象。这一章也简要介绍了 XML 及其与 DOM 的关系，为深入探讨所有 DOM 规范及其定义 的操作网页的方式奠定了基础。</p><p class="paragraph"><span class="strong">第 11 章“DOM 扩展”，</span>介绍了其他 API 以及浏览器本身为 DOM 添加的各种功能。涉及内容包括 Selectors API、Element Traversal API 和 HTML5 扩展。</p><p class="paragraph"><span class="strong">第 12 章“DOM2 和 DOM3”，</span>在前两章的基础上继续探讨了 DOM2 和 DOM3 中新增的 DOM 属 性、方法和对象。这一章还讨论了 IE 与其他浏览器的兼容性问题。</p><p class="paragraph"><span class="strong">第 13 章“事件”，</span>解释了 JavaScript 中事件的本质，对遗留机制的支持，以及 DOM 对事件机制的 重新定义。这一章讨论了多种设备，包括 Wii 和 iPhone。</p><p class="paragraph"><span class="strong">第 14 章“表单脚本”，</span>讲述如何使用 JavaScript 增强表单的交互性，突破浏览器的局限性。这一 章的讨论主要围绕单个表单元素如文本框、选择框，以及围绕数据验证和操作展开。</p><p class="paragraph"><span class="strong">第 15 章“使用 Canvas 绘图”，</span>讨论了&lt;canvas&gt;标签以及如何通过它来动态绘图。不仅涵盖 2D 上下文，也将讨论 WebGL（3D）上下文，可以为创建动画和游戏夯实基础。</p><p class="paragraph"><span class="strong">第 16 章“HTML5 脚本编程”，</span>介绍了 HTML5 规定的 JavaScript API，涉及跨文档传递消息、拖 放 API 和以编程方式控制&lt;audio&gt;和&lt;video&gt;元素，以及管理历史状态。</p><p class="paragraph"><span class="strong">第 17 章“错误处理与调试”，</span>讨论浏览器如何处理 JavaScript 代码错误，并展示了一些处理错误的方式。这一章针对每种浏览器分别讨论了相应的调试工具和技术，还给出了简化调试工作的建议。</p><p class="paragraph"><span class="strong">第 18 章“JavaScript 与 XML”，</span>展示了 JavaScript 中用于读取和操作 XML（eXtensible Markup Language，可扩展标记语言）的特性。这一章分析了不同浏览器提供的 XML 支持和对象的差异，给出 了编写跨浏览器代码的简易方法。此外，这一章还介绍了用于在客户端转换XML数据的XSLT（eXtensible Stylesheet Language Transformations，可扩展样式表语言转换）技术。</p><p class="paragraph"><span class="strong">第 19 章“E4X”，</span>讨论了 E4X（ECMAScript for XML，ECMAScript 中的 XML 扩展）；设计 E4X 的 出发点是简化 XML 处理任务。这一章探讨了在处理 XML 时，使用 E4X 与使用 DOM 相比有哪些 优势。</p><p class="paragraph"><span class="strong">第 20 章“JSON”，</span>介绍了作为 XML 替代格式的 JSON，包含浏览器原生支持的 JSON 解析和序 列化，以及使用 JSON 时要注意的安全问题。</p><p class="paragraph"><span class="strong">第 21 章“Ajax 与 Comet”，</span>讲解了常用的 Ajax 技术，包括使用 XMLHttpRequest 对象及 CORS （Cross-Origin Resource Sharing，跨来源资源共享）API 实现跨域 Ajax 通信。这一章展示了浏览器在实 现与支持方面存在的差异，同时也给出了一些使用建议。</p><p class="paragraph"><span class="strong">第 22 章“高级技巧”，</span>深入讲解了一些 JavaScript 中较复杂的模式，包括函数柯里化（currying）、 部分函数应用和动态函数。这一章还讨论了如何创建自定义的事件框架和使用 ECMAScript 5 创建防篡 改对象。</p><p class="paragraph"><span class="strong">第 23 章“离线应用与客户端存储”，</span>讨论了如何检测应用离线以及在客户端机器中存储数据的各 种技术。先从受到最广泛支持的特性 cookie 谈起，继而介绍了新兴的客户端存储技术，如 Web Storage 和 IndexedDB。</p><p class="paragraph"><span class="strong">第 24 章“最佳实践”，</span>探讨了在企业级环境中使用 JavaScript 的各种方式。其中，着眼于提高可 维护性的内容包括编码技巧、格式化和通用编程实践。这一章还介绍了改善代码执行性能及速度优化的 一些技术。最后讨论了部署问题，包括如何创建构建过程。</p><p class="paragraph"><span class="strong">第 25 章“新兴的 API”，</span>介绍了为增强浏览器中的 JavaScript 而创建的新 API。虽然这些 API 还没 有得到完整或全面的支持，但它们已经崭露头角，有些浏览器也已经部分地实现了这些 API。这一章的 内容主要是 Web 计时和文件 API。</p></section><section><p class="h3">使用示例</p><p class="paragraph">要运行本书中的示例，需要安装下列软件：</p><p class="paragraph"> Windows XP、Windows 7 或 Mac OS X；</p><p class="paragraph"> Internet Explorer 6 及更高版本、Firefox 2 及更高版本、Opera 9 及更高的版本、Chrome、Safari 2及更高版本。</p><p class="notes">完整的示例源代码可以从 http://www.wrox.com/中下载（下载步骤见“源代码”一节）①。</p></section><section><p class="h3">排版约定</p><p class="paragraph">为了让读者更好地理解本书内容，同时把握住全书的重点，本书将采用以下排版约定。</p><div class="paragraph important">这种方框样式，表示与上下文相关的重要的、需要牢记的内容。</div><div class="paragraph tips">这种带方框样式，表示与上下文相关的说明、提示、技巧、窍门和背景知识。</div><p class="paragraph">正文中的样式说明如下。<ol><li>新术语及重要的词汇在首次出现时使用加粗字体以示强调；</li><li>表示键盘命令组合的方式是 Ctrl+A；</li><li>正文中的代码使用等宽字体，如 persistence.properties；</li><li>代码有两种样式：<div class="paragraph"><div>var obj = new Object(); // 大多数示例代码都没有加粗</div><div><strong>var obj = new Object(); // 加粗的代码表示在上下文中特别重要</strong></div></div></li></ol></p></section><section><p class="h3">源代码</p><p class="paragraph">在学习本书示例代码时，可以手工敲入所有代码，也可以使用随书的源代码文件。本书所有源代码都可以到 www.wrox.com 中下载。登录该站点后，先找到本书（通过搜索或者图书列表），打开本书页面后，单击其中的 Download Code 链接，就可以下载本书的源代码了①。对于包含在下载文件中的源代码，文中会添加源代码文件名称，点击文件名称即可打开对应的源代码文件。</p><p class="paragraph">本书代码示例旁边会附有文件名，从中可以找到对应的代码片段。文件名的格式如下：</p><p class="paragraph source-file">代码片段所在的文件名</p><div class="paragraph tips">由于很多书的书名看起来类似，所以更好的方式是通过书的 ISBN 来搜索它。本书原版的 ISBN 是 978-1-118-02669-4。</div></section><section><p class="h3">勘误信息②</p><p class="paragraph">我们尽最大努力确保正文和代码没有错误。可是，金无足赤，错误在所难免。如果读者发现我们书中的任何错误，例如错别字或代码片段无法运行等，希望您能及时给我们反馈。您提交的勘误不仅能让其他读者受益，而且也能帮助我们进一步提高图书质量。</p><p class="paragraph">本书原版的勘误页面位于 www.wrox.com 中，登录该站点后可以通过搜索或查询图书列表找到本书页面，然后单击页面中的 Errata（勘误）链接。然后可以看到其他读者已经提交并由 Wrox 的编辑发布的勘误信息。另外，在 www.wrox.com/misc-pages/booklist.shtml 页面中也可以找到本书及勘误页面的链接。</p><p class="paragraph">如果读者在本书勘误页面中没有发现“你的”错误，麻烦打开 www.wrox.com/contact/techsupport.shtml页面，填写其中的表单并将错误发送给我们。我们会认真核对您提交的错误，如果错误确实存在，我们将把它补充到本书勘误页面中。同时，也将根据您提供的信息对本书后续版本加以改正。</p></section><section><p class="h3">p2p.wrox.com</p><p class="paragraph">如果您想与本书作者或者其他读者沟通，请加入 P2P 论坛（p2p.wrox.com）。该论坛是基于 Web 的系统，您可以在其中发表与 Wrox 图书及相关技术有关的帖子，并同其他读者或者技术用户交流。论坛提供了一个订阅功能，您可以选择当发表您感兴趣的帖子时通过邮件通知您。Wrox 的作者、编辑、其他行业的专家以及与您正在读同一本书的读者都会出现在这个论坛中。</p><p class="paragraph">在 http://p2p.wrox.com 中，有很多论坛不仅对您理解本书有帮助，而且还会对开发应用程序有帮助。|要加入这个论坛，请按下面几个步骤进行：<ol><li>登录到 p2p.wrox.com，单击 Register（注册）链接；</li><li>阅读使用条款并单击 Agree（同意）；</li><li>完成必填信息和您愿意提供的可选信息，然后单击 Submit（提交）；</li><li>随后，您会收到一封电子邮件，其中包含如何验证账号和完成注册过程的信息。</li></ol><div class="tips">    如果不加入 P2P 论坛，虽然也可以阅读其中的帖子，但却不能发表帖子，只有注册后才能发表。</div></p><p class="paragraph">在加入论坛后，既可以发表新帖子也可以回复其他用户的帖子。可以在任何时间上网浏览论坛中的帖子。如果希望将某个论坛中的新帖子通过电子邮件发送给您，请在论坛列表中单击与论坛名相关的Subscribe to this Forum（订阅这个论坛）图标。</p><p class="paragraph">如果想了解有关如何使用 Wrox P2P 的更多信息，请阅读包含论坛规则、P2P 及 Wrox 图书常见问题的 P2P FAQ；要阅读 FAQ，可以在任何 P2P 页面中单击 FAQ 链接。</p></section><section><p class="h3">致谢</p><p class="paragraph">虽然作者的名字被印在了封面上，但一个人是不可能完成这本书的，我想感谢与出版本书有关的一些人。</p><p class="paragraph">首先，感谢 John Wiley & Sons 继续给我写作的机会。当时，出版本书第 1 版时，他们是唯一愿意承担风险的一家出版社。对此，我将永远铭记于心。</p><p class="paragraph">感谢 John Wiley & Sons 的编辑人员，特别是 Kevin Kent 和 John Peloquin，他们卓有成效的工作使我保持了坦诚直率的风格，也解决了我在写作期间不断变更内容的问题。</p><p class="paragraph">还要感谢对本书草稿给出反馈意见的所有人：Rob Friesel、Sergey Ilinsky、Dan Kielp、Peter-Paul Koch、Jeremy McPeak、Alex Petrescu、Dmitry Soshnikov 和 Juriy “Kangax” Zaytsev。你们的宝贵意见让我自己都为本书感到骄傲。</p><p class="paragraph">我想特别感谢 Brendan Eich，感谢他纠正了第 1 章中有关 JavaScript 历史的细节问题。</p><p class="paragraph">最后，当然也是非常重要的，感谢 Rey Bango 为本书作序。很高兴在与 Rey 通过网络认识几年之后，终于在 2010 年有缘相见。他是这个行业里真正出色的人，我非常荣幸能请到他为本书作序。</p></section><section><p class="h3">关于技术编辑</p><p class="paragraph">John Peloquin 是一位有十多年 JavaScript 经验的前端工程师，开发过各种规模的应用。John 拥有加州大学伯克利分校的数学学士学位，目前在一家致力于卫生保健的创业公司担任开发主管。在编辑本书之前，John 编辑过 Jeremy McPeak 的 JavaScript 24-Hour Trainer（Wiley，2010）。编写代码和收集勘误之余，John 经常沉迷于数学、哲学和魔术。</p></section></div><!--章节--><div id="ch1"><section><p class="h1">第 1 章JavaScript 简介</p><ul>本章内容<li>JavaScript 历史回顾</li><li>JavaScript 是什么</li><li>JavaScript 与 ECMAScript 的关系</li><li>JavaScript 的不同版本</li></ul><p class="paragraph">JavaScript 诞生于 1995 年。当时，它的主要目的是处理以前由服务器端语言（如 Perl）负责的一些输入验证操作。在 JavaScript 问世之前，必须把表单数据发送到服务器端才能确定用户是否没有填写某个必填域，是否输入了无效的值。Netscape Navigator 希望通过 JavaScript 来解决这个问题。在人们普遍使用电话拔号上网的年代，能够在客户端完成一些基本的验证任务绝对是令人兴奋的。毕竟，拨号上网的速度之慢，导致了与服务器的每一次数据交换事实上都成了对人们耐心的一次考验。</p><p class="paragraph">自此以后，JavaScript 逐渐成为市面上常见浏览器必备的一项特色功能。如今，JavaScript 的用途早已不再局限于简单的数据验证，而是具备了与浏览器窗口及其内容等几乎所有方面交互的能力。今天的JavaScript 已经成为一门功能全面的编程语言，能够处理复杂的计算和交互，拥有了闭包、匿名（lamda，拉姆达）函数，甚至元编程等特性。作为 Web 的一个重要组成部分，JavaScript 的重要性是不言而喻的，就连手机浏览器，甚至那些专为残障人士设计的浏览器等非常规浏览器都支持它。当然，微软的例子更为典型。虽然有自己的客户端脚本语言 VBScript，但微软仍然在 Internet Explorer 的早期版本中加入了自己的 JavaScript 实现①。</p><p class="paragraph">JavaScript 从一个简单的输入验证器发展成为一门强大的编程语言，完全出乎人们的意料。应该说，它既是一门非常简单的语言，又是一门非常复杂的语言。说它简单，是因为学会使用它只需片刻功夫；而说它复杂，是因为要真正掌握它则需要数年时间。要想全面理解和掌握 JavaScript，关键在于弄清楚它的本质、历史和局限性。</p></section></div><div id="ch1-1"><section><p class="h2">1.1 JavaScript 简史</p><p class="paragraph">在 Web 日益流行的同时，人们对客户端脚本语言的需求也越来越强烈。那个时候，绝大多数因 特网用户都使用速度仅为 28.8kbit/s 的“猫”（调制解调器）上网，但网页的大小和复杂性却不断增 加。为完成简单的表单验证而频繁地与服务器交换数据只会加重用户的负担。想象一下：用户填写 完一个表单，单击“提交”按钮，然后等待 30 秒钟，最终服务器返回消息说有一个必填字段没有填好…… 当时走在技术革新最前沿的 Netscape 公司，决定着手开发一种客户端语言，用来处理这种简单的验证。</p><p class="paragraph">当时就职于 Netscape 公司的布兰登·艾奇（Brendan Eich），开始着手为计划于 1995 年 2 月发布的 Netscape Navigator 2 开发一种名为 LiveScript 的脚本语言——该语言将同时在浏览器和服务器中使用 （它在服务器上的名字叫 LiveWire）。为了赶在发布日期前完成 LiveScript 的开发，Netscape 与 Sun 公司 建立了一个开发联盟。在 Netscape Navigator 2 正式发布前夕，Netscape 为了搭上媒体热炒 Java 的顺风车， 临时把 LiveScript 改名为 JavaScript。</p><p class="paragraph">由于 JavaScript 1.0 获得了巨大成功，Netscape 随即在 Netscape Navigator 3 中又发布了 JavaScript 1.1。Web 虽然羽翼未丰，但用户关注度却屡创新高。在这样的背景下，Netscape 把自己定位为市场领袖型公司。与此同时，微软决定向与 Navigator 竞争的自家产品 Internet Explorer 浏览器投入更多资源。NetscapeNavigator 3 发布后不久，微软就在其 Internet Explorer 3 中加入了名为 JScript 的 JavaScript 实现（命名为JScript 是为了避开与 Netscape 有关的授权问题）。以现在的眼光来看，微软 1996 年 8 月为进入 Web 浏览器领域而实施的这个重大举措，是导致 Netscape 日后蒙羞的一个标志性事件。然而，这个重大举措同时也标志着 JavaScript 作为一门语言，其开发向前迈进了一大步。</p><p class="paragraph">微软推出其 JavaScript 实现意味着有了两个不同的 JavaScript 版本：Netscape Navigator 中的JavaScript、Internet Explorer 中的 JScript。与 C 及其他编程语言不同，当时还没有标准规定 JavaScript 的语法和特性，两个不同版本并存的局面已经完全暴露了这个问题。随着业界担心的日益加剧，JavaScript的标准化问题被提上了议事日程。</p><p class="paragraph">1997 年，以 JavaScript 1.1 为蓝本的建议被提交给了欧洲计算机制造商协会（ECMA，EuropeanComputer Manufacturers Association）。该协会指定 39 号技术委员会（TC39，Technical Committee #39）负责“标准化一种通用、跨平台、供应商中立的脚本语言的语法和语义”（http://www.ecmainternational.org/memento/TC39.htm）。TC39 由来自 Netscape、Sun、微软、Borland 及其他关注脚本语言发展的公司的程序员组成，他们经过数月的努力完成了 ECMA-262——定义一种名为 ECMAScript（发音为“ek-ma-script”）的新脚本语言的标准。</p><p class="paragraph">第二年，ISO/IEC（International Organization for Standardization and International ElectrotechnicalCommission，国标标准化组织和国际电工委员会）也采用了 ECMAScript 作为标准（即 ISO/IEC-16262）。自此以后，浏览器开发商就开始致力于将 ECMAScript 作为各自 JavaScript 实现的基础，也在不同程度上取得了成功。</p></section></div><!-- - var ch_num = "0"--><div id="ch1-2"><section><p class="h2">1.2 JavaScript 实现</p><p class="paragraph">虽然 JavaScript 和 ECMAScript 通常都被人们用来表达相同的含义，但 JavaScript 的含义却比 ECMA-262 中规定的要多得多。没错，一个完整的 JavaScript 实现应该由下列三个不同的部分组成（见图 1-1）。</p><ul><li>核心（ECMAScript）</li><li>文档对象模型（DOM）</li><li>浏览器对象模型（BOM）</li></ul><div class="images"><img src="static/images/ch1/ch1-1.jpg" alt="图1-1"><div class="img-tips">图 1-1</div></div></section></div><!-- - var ch_num = "0"--><div id="ch1-2-1"><section><p class="h3">1.2.1 ECMAScript</p><p class="paragraph">由 ECMA-262 定义的 ECMAScript 与 Web 浏览器没有依赖关系。实际上，这门语言本身并不包含输入和输出定义。ECMA-262 定义的只是这门语言的基础，而在此基础之上可以构建更完善的脚本语言。我们常见的 Web 浏览器只是 ECMAScript 实现可能的宿主环境之一。宿主环境不仅提供基本的ECMAScript 实现，同时也会提供该语言的扩展，以便语言与环境之间对接交互。而这些扩展——如DOM，则利用 ECMAScript 的核心类型和语法提供更多更具体的功能，以便实现针对环境的操作。其他宿主环境包括 Node（一种服务端 JavaScript 平台）和 Adobe Flash。</p><p class="paragraph">既然 ECMA-262 标准没有参照 Web 浏览器，那它都规定了些什么内容呢？大致说来，它规定了这门语言的下列组成部分：</p><ul><li>语法</li><li>类型</li><li>语句</li><li>关键字</li><li>保留字</li><li>操作符</li><li>对象</li></ul><p class="paragraph">ECMAScript 就是对实现该标准规定的各个方面内容的语言的描述。JavaScript 实现了 ECMAScript，Adobe ActionScript 同样也实现了 ECMAScript。</p><p class="paragraph"><strong>1. ECMAScript 的版本</strong></p><p class="paragraph">ECMAScript 的不同版本又称为版次，以第 x 版表示（意即描述特定实现的 ECMA-262 规范的第 x个版本）。ECMA-262 的最近一版是第 5 版，发布于 2009 年。而 ECMA-262 的第 1 版本质上与 Netscape的 JavaScript 1.1 相同——只不过删除了所有针对浏览器的代码并作了一些较小的改动：ECMA-262 要求支持 Unicode 标准（从而支持多语言开发），而且对象也变成了平台无关的（Netscape JavaScript 1.1 的对象在不同平台中的实现不一样，例如 Date 对象）。这也是 JavaScript 1.1 和 1.2 与 ECMA-262 第 1 版不一致的主要原因。</p><p class="paragraph">ECMA-262 第 2 版主要是编辑加工的结果。这一版中内容的更新是为了与 ISO/IEC-16262 保持严格一致，没有作任何新增、修改或删节处理。因此，一般不使用第 2 版来衡量 ECMAScript 实现的兼容性。</p><p class="paragraph">ECMA-262 第 3 版才是对该标准第一次真正的修改。修改的内容涉及字符串处理、错误定义和数值输出。这一版还新增了对正则表达式、新控制语句、try-catch 异常处理的支持，并围绕标准的国际化做出了一些小的修改。从各方面综合来看，第 3 版标志着 ECMAScript 成为了一门真正的编程语言。</p><p class="paragraph">ECMA-262 第 4 版对这门语言进行了一次全面的检核修订。由于 JavaScript 在 Web 上日益流行，开发人员纷纷建议修订 ECMAScript，以使其能够满足不断增长的 Web 开发需求。作为回应，ECMA TC39重新召集相关人员共同谋划这门语言的未来。结果，出台后的标准几乎在第 3 版基础上完全定义了一门新语言。第 4 版不仅包含了强类型变量、新语句和新数据结构、真正的类和经典继承，还定义了与数据交互的新方式。</p><p class="paragraph">与此同时，TC39 下属的一个小组也提出了一个名为 ECMAScript 3.1 的替代性建议，该建议只对这门语言进行了较少的改进。这个小组认为第 4 版给这门语言带来的跨越太大了。因此，该小组建议对这门语言进行小幅修订，能够在现有 JavaScript 引擎基础上实现。最终，ES3.1 附属委员会获得的支持超过了 TC39，ECMA-262 第 4 版在正式发布前被放弃。</p><p class="paragraph">ECMAScript 3.1 成为 ECMA-262 第 5 版，并于 2009 年 12 月 3 日正式发布。第 5 版力求澄清第 3版中已知的歧义并增添了新的功能。新功能包括原生 JSON 对象（用于解析和序列化 JSON 数据）、继承的方法和高级属性定义，另外还包含一种严格模式，对 ECMAScript 引擎解释和执行代码进行了补充说明。</p><p class="paragraph"><strong>2. 什么是 ECMAScript 兼容</strong></p><p class="paragraph">ECMA-262 给出了 ECMAScript 兼容的定义。要想成为 ECMAScript 的实现，则该实现必须做到：</p><ul><li>支持 ECMA-262 描述的所有“类型、值、对象、属性、函数以及程序句法和语义”（ECMA-262第 1 页）</li><li>支持 Unicode 字符标准。</li></ul><p class="paragraph">此外，兼容的实现还可以进行下列扩展。</p><ul><li>添加 ECMA-262 没有描述的“更多类型、值、对象、属性和函数”。ECMA-262 所说的这些新增特性，主要是指该标准中没有规定的新对象和对象的新属性。</li><li>支持 ECMA-262 没有定义的“程序和正则表达式语法”。（也就是说，可以修改和扩展内置的正则表达式语法。）</li></ul><p class="paragraph">上述要求为兼容实现的开发人员基于 ECMAScript 开发一门新语言提供了广阔的空间和极大的灵活性，这也从另一个侧面说明了 ECMAScript 受开发人员欢迎的原因。</p><p class="paragraph"><strong>3. Web 浏览器对 ECMAScript 的支持</strong></p><p class="paragraph">1996 年，Netscape Navigator 3 捆绑发布了 JavaScript 1.1。而相同的 JavaScript 1.1 设计规范随后作为对新标准（ECMA-262）的建议被提交给 Ecma。伴随着 JavaScript 的迅速走红，Netscape 豪情满怀地着手开发 JavaScript 1.2。然而，问题是 Ecma 当时还没有接受 Netscape 的建议。</p><p class="paragraph">Netscape Navigator 3 发布后不久，微软也推出了 Internet Explorer 3。微软在 IE 的这一版中捆绑了JScript 1.0，很多人都认为 JScript 1.0 与 JavaScript 1.1 应该是一样的。但是，由于没有文档依据，加之不适当的特性模仿，JScript 1.0 还是很难与 JavaScript 1.1 相提并论。</p><p class="paragraph">1997 年，内置 JavaScript 1.2 的 Netscape Navigator 4 发布；而到这一年年底，ECMA-262 第 1 版也被接受并实现了标准化。结果，虽然 ECMAScript 被认为是基于 JavaScript 1.1 制定的，但 JavaScript 1.2与 ECMAScript 的第 1 版并不兼容。</p><p class="paragraph">JScript 的升级版是 Internet Explorer 4 中内置的 JScript 3.0（随同微软 IIS 3.0 发布的 JScript 2.0 从来也没有移植到浏览器中）。微软通过媒体大肆宣传 JScript 3.0 是世界上第一个 ECMA 兼容的脚本语言，但当时的 ECMA-262 尚未定稿。于是，JScript 3.0 与 JavaScript 1.2 都遭遇了相同的尴尬局面——谁都没有按照最终的 ECMAScript 标准来实现。</p><p class="paragraph">Netscape 决定更新其 JavaScript 实现，即在 Netscape Navigator 4.06 中发布 JavaScript 1.3，从而做到了与 ECMA-262 的第一个版本完全兼容。在 JavaScript 1.3 中，Netscape 增加了对 Unicode 标准的支持，并在保留 JavaScript 1.2 新增特性的同时实现了所有对象的平台中立化。</p><p class="paragraph">在 Netscape 以 Mozilla 项目的名义开放其源代码时，预期 JavaScript 1.4 将随同 Netscape Navigator 5一道发布。然而，一个激进的决定，彻底重新设计 Netscape 代码，打乱了原有计划。后来，JavaScript 1.4只发布了针对 Netscape Enterprise Server 的服务器版，而没有内置于 Web 浏览器中。</p><p class="paragraph">到了 2008 年，五大主流 Web 浏览器（IE、Firefox、Safari、Chrome 和 Opera）全部做到了与 ECMA-262兼容。IE8 是第一个着手实现 ECMA-262 第 5 版的浏览器，并在 IE9 中提供了完整的支持。Firefox 4 也紧随其后做到兼容。下表列出了 ECMAScript 受主流 Web 浏览器支持的情况。</p><table cellspacing="0"><tr><th>浏 览 器</th><th>ECMAScript兼容性</th><th>浏 览 器</th><th>ECMAScript兼容性</th></tr><tr><td>Netscape Navigator 2</td><td>—</td><td>Opera 6～7.1</td><td>第2版</td></tr><tr><td>Netscape Navigator 3</td><td>—</td><td>Opera 7.2+</td><td>第3版</td></tr><tr><td>Netscape Navigator 4～4.05</td><td>—</td><td>Safari 1～2.0.x</td><td>第3版*</td></tr><tr><td>Netscape Navigator 4.06～4.79</td><td>第1版</td><td>Safari 3.x</td><td>第3版</td></tr><tr><td>Netscape 6+（Mozilla 0.6.0+）</td><td>第3版</td><td>Safari 4.x～5.x</td><td>第5版*</td></tr><tr><td>IE3</td><td>—</td><td>Chrome 1+</td><td>第3版</td></tr><tr><td>IE4</td><td>—</td><td>Firefox 1～2</td><td>第3版</td></tr><tr><td>IE5</td><td>第1版</td><td>Firefox 3.0.x</td><td>第3版</td></tr><tr><td>IE5.5～IE7</td><td>第3版</td><td>Firefox 3.5～3.6</td><td>第5版*</td></tr><tr><td>IE8</td><td>第5版*</td><td>Firefox 4.0 +</td><td>第5版</td></tr><tr><td>IE9+</td><td>第5版</td></tr></table><div class="paragraph notes">* 不完全兼容的实现</div></section></div><!-- - var ch_num = "0"--><div id="ch1-2-2"><section><p class="h3">1.2.2 文档对象模型（DOM）</p><p class="paragraph">文档对象模型（DOM，Document Object Model）是针对 XML 但经过扩展用于 HTML 的应用程序编程接口（API，Application Programming Interface）。DOM 把整个页面映射为一个多层节点结构。HTML或 XML 页面中的每个组成部分都是某种类型的节点，这些节点又包含着不同类型的数据。看下面这个HTML 页面：</p><!--代码段，使用highlighter.js高亮--><pre><code>&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Sample Page&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;p&gt;Hello World!&lt;/p&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre><p class="paragraph">在 DOM 中，这个页面可以通过图 1-2 所示的分层节点图表示。</p><p class="paragraph">通过 DOM 创建的这个表示文档的树形图，开发人员获得了控制页面内容和结构的主动权。借助DOM 提供的 API，开发人员可以轻松自如地删除、添加、替换或修改任何节点。</p><p class="paragraph"><strong>1. 为什么要使用 DOM</strong></p><p class="paragraph">在 Internet Explorer 4 和 Netscape Navigator 4 分别支持的不同形式的 DHTML（Dynamic HTML）基础上，开发人员首次无需重新加载网页，就可以修改其外观和内容了。然而，DHTML 在给 Web 技术发展带来巨大进步的同时，也带来了巨大的问题。由于 Netscape 和微软在开发 DHTML 方面各持己见，过去那个只编写一个 HTML 页面就能够在任何浏览器中运行的时代结束了。</p><p class="paragraph">对开发人员而言，如果想继续保持 Web 跨平台的天性，就必须额外多做一些工作。而人们真正担心的是，如果不对 Netscape 和微软加以控制，Web 开发领域就会出现技术上两强割据，浏览器互不兼容的局面。此时，负责制定 Web 通信标准的 W3C（World Wide Web Consortium，万维网联盟）开始着手规划 DOM。</p><div class="images"><img src="undefinedch1/ch1-2.jpg" alt="图1-2"><div class="img-tips">图 1-2</div></div><p class="paragraph"><strong>2. DOM 级别</strong></p><p class="paragraph">DOM1 级（DOM Level 1）于 1998 年 10 月成为 W3C 的推荐标准。DOM1 级由两个模块组成：DOM核心（DOM Core）和 DOM HTML。其中，DOM 核心规定的是如何映射基于 XML 的文档结构，以便简化对文档中任意部分的访问和操作。DOM HTML 模块则在 DOM 核心的基础上加以扩展，添加了针对 HTML 的对象和方法。</p><p class="paragraph tips">请读者注意，DOM 并不只是针对 JavaScript 的，很多别的语言也都实现了 DOM。不过，在 Web 浏览器中，基于 ECMAScript 实现的 DOM 的确已经成为 JavaScript 这门语言的一个重要组成部分。</p><p class="paragraph">如果说 DOM1 级的目标主要是映射文档的结构，那么 DOM2 级的目标就要宽泛多了。DOM2 级在原来 DOM 的基础上又扩充了（DHTML 一直都支持的）鼠标和用户界面事件、范围、遍历（迭代 DOM文档的方法）等细分模块，而且通过对象接口增加了对 CSS（Cascading Style Sheets，层叠样式表）的支持。DOM1 级中的 DOM 核心模块也经过扩展开始支持 XML 命名空间。</p><p class="paragraph">DOM2 级引入了下列新模块，也给出了众多新类型和新接口的定义。</p><ul><li>DOM 视图（DOM Views）：定义了跟踪不同文档（例如，应用 CSS 之前和之后的文档）视图的接口；</li><li>DOM 事件（DOM Events）：定义了事件和事件处理的接口；</li><li>DOM 样式（DOM Style）：定义了基于 CSS 为元素应用样式的接口；</li><li>DOM 遍历和范围（DOM Traversal and Range）：定义了遍历和操作文档树的接口。</li></ul><p class="paragraph">DOM3 级则进一步扩展了 DOM，引入了以统一方式加载和保存文档的方法——在 DOM 加载和保存（DOM Load and Save）模块中定义；新增了验证文档的方法——在 DOM 验证（DOM Validation）模块中定义。DOM3 级也对 DOM 核心进行了扩展，开始支持 XML 1.0 规范，涉及 XML Infoset、XPath和 XML Base。</p><p class="paragraph tips">在阅读 DOM 标准的时候，读者可能会看到 DOM0 级（DOM Level 0）的字眼。实际上，DOM0 级标准是不存在的；所谓 DOM0 级只是 DOM 历史坐标中的一个参照点而已。具体说来，DOM0 级指的是 Internet Explorer 4.0 和 Netscape Navigator 4.0 最初支持的 DHTML。
</p><p class="paragraph"><strong>3. 其他 DOM 标准</strong></p><p class="paragraph">除了 DOM 核心和 DOM HTML 接口之外，另外几种语言还发布了只针对自己的 DOM 标准。下面列出的语言都是基于 XML 的，每种语言的 DOM 标准都添加了与特定语言相关的新方法和新接口：</p><ul><li>SVG（Scalable Vector Graphic，可伸缩矢量图）1.0；</li><li>MathML（Mathematical Markup Language，数学标记语言）1.0；</li><li>SMIL（Synchronized Multimedia Integration Language，同步多媒体集成语言）。</li></ul><p class="paragraph">还有一些语言也开发了自己的 DOM 实现，例如 Mozilla 的 XUL（XML User Interface Language，XML用户界面语言）。但是，只有上面列出的几种语言是 W3C 的推荐标准。</p><p class="paragraph"><strong>4. Web 浏览器对 DOM 的支持</strong></p><p class="paragraph">在 DOM 标准出现了一段时间之后，Web 浏览器才开始实现它。微软在 IE5 中首次尝试实现 DOM，但直到 IE5.5 才算是真正支持 DOM1 级。在随后的 IE6 和 IE7 中，微软都没有引入新的 DOM 功能，而到了 IE8 才对以前 DOM 实现中的 bug 进行了修复。</p><p class="paragraph">Netscape 直到 Netscape 6（Mozilla 0.6.0）才开始支持 DOM。在 Netscape 7 之后，Mozilla 把开发重心转向了 Firefox 浏览器。Firefox 3 完全支持 DOM1 级，几乎完全支持 DOM2 级，甚至还支持 DOM3 级的一部分。（Mozilla 开发团队的目标是构建与标准 100%兼容的浏览器，而他们的努力也得到了回报。）</p><p class="paragraph">目前，支持 DOM 已经成为浏览器开发商的首要目标，主流浏览器每次发布新版本都会改进对 DOM的支持。下表列出了主流浏览器对 DOM 标准的支持情况。</p><table><tr><th>浏 览 器</th><th>DOM兼容性</th></tr><tr><td>Netscape Navigator 1. ～ 4.x</td><td>—</td></tr><tr><td>Netscape 6+ （Mozilla 0.6.0+）</td><td>1级、2级（几乎全部）、3级（部分）</td></tr><tr><td>IE2～IE4.x</td><td>—</td></tr><tr><td>IE5</td><td>1级（最小限度）</td></tr><tr><td>IE5.5～IE8</td><td>1级（几乎全部）</td></tr><tr><td>IE9+</td><td>1级、2级、3级</td></tr><tr><td>Opera 1～6</td><td>—</td></tr><tr><td>Opera 7～8.x</td><td>1级（几乎全部）、2级（部分）</td></tr><tr><td>Opera 9～9.9</td><td>1级、2级（几乎全部）、3级（部分）</td></tr><tr><td>Opera 10+</td><td>1级、2级、3级（部分）</td></tr><tr><td>Safari 1.0.x</td><td>1级</td></tr><tr><td>Safari 2+</td><td>1级、2级（部分）</td></tr><tr><td>Chrome 1+</td><td>1级、2级（部分）</td></tr><tr><td>Firefox 1+</td><td>1级、2级（几乎全部）、3级（部分）</td></tr></table></section></div><!-- - var ch_num = "0"--><div id="ch1-2-3"><section><p class="h3">1.2.3 浏览器对象模型（BOM）</p><p class="paragraph">Internet Explorer 3 和 Netscape Navigator 3 有一个共同的特色，那就是支持可以访问和操作浏览器窗口的浏览器对象模型（BOM，Browser Object Model）。开发人员使用 BOM 可以控制浏览器显示的页面以外的部分。而 BOM 真正与众不同的地方（也是经常会导致问题的地方），还是它作为 JavaScript 实现的一部分但却没有相关的标准。这个问题在 HTML5 中得到了解决，HTML5 致力于把很多 BOM 功能写入正式规范。HTML5 发布后，很多关于 BOM 的困惑烟消云散。</p><p class="paragraph">从根本上讲，BOM 只处理浏览器窗口和框架；但人们习惯上也把所有针对浏览器的 JavaScript 扩展算作 BOM 的一部分。下面就是一些这样的扩展：</p><ul><li>弹出新浏览器窗口的功能；</li><li>移动、缩放和关闭浏览器窗口的功能；</li><li>提供浏览器详细信息的 navigator 对象；</li><li>提供浏览器所加载页面的详细信息的 location 对象；</li><li>提供用户显示器分辨率详细信息的 screen 对象；</li><li>对 cookies 的支持；</li><li>像 XMLHttpRequest 和 IE 的 ActiveXObject 这样的自定义对象。</li></ul><p class="paragraph">由于没有 BOM 标准可以遵循，因此每个浏览器都有自己的实现。虽然也存在一些事实标准，例如要有 window 对象和 navigator 对象等，但每个浏览器都会为这两个对象乃至其他对象定义自己的属性和方法。现在有了 HTML5，BOM 实现的细节有望朝着兼容性越来越高的方向发展。第 8 章将深入讨论 BOM。</p></section></div><!-- - var ch_num = "0"--><div id="ch1-3"><section><p class="h2">1.3 JavaScript 版本</p><div class="paragraph">作为 Netscape“继承人”的 Mozilla 公司，是目前唯一还在沿用最初的 JavaScript 版本编号序列的浏览器开发商。在 Netscape 将源代码提交给开源的 Mozilla 项目的时候，JavaScript 在浏览器中的最后一个版本号是 1.3。（如前所述，1.4 版是只针对服务器的实现。）后来，随着 Mozilla 基金会继续开发 JavaScript，添加新的特性、关键字和语法，JavaScript 的版本号继续递增。下表列出了 Netscape/Mozilla 浏览器中JavaScript 版本号的递增过程：</div><table><tr><th>浏 览 器</th><th>JavaScript版本</th><th>浏 览 器</th><th>JavaScript版本</th></tr><tr><td>Netscape Navigator 2</td><td>1.0</td><td>Firefox 1.5</td><td>1.6</td></tr><tr><td>Netscape Navigator 3</td><td>1.1</td><td>Firefox 2</td><td>1.7</td></tr><tr><td>Netscape Navigator 4</td><td>1.2</td><td>Firefox 3</td><td>1.8</td></tr><tr><td>Netscape Navigator 4.06</td><td>1.3</td><td>Firefox 3.5</td><td>1.8.1</td></tr><tr><td>Netscape 6+（Mozilla 0.6.0+）</td><td>1.5</td><td>Firefox 3.6</td><td>1.8.2</td></tr><tr><td>Firefox 1</td><td>1.5</td></tr></table><p class="paragraph">实际上，上表中的编号方案源自 Firefox 4 将内置 JavaScript 2.0 这一共识。因此，2.0 版之前每个递增的版本号，表示的是相应实现与 JavaScript 2.0 开发目标还有多大的距离。虽然原计划是这样，但JavaScript 的这种发展速度让这个计划不再可行。目前，JavaScript 2.0 还没有目标实现。</p><p class="paragraph tips">请注意，只有 Netscape/Mozilla 浏览器才遵循这种编号模式。例如，IE 的 JScript就采用了另一种版本命名方案。换句话说，JScript 的版本号与上表中 JavaScript 的版本号之间不存在任何对应关系。而且，大多数浏览器在提及对 JavaScript 的支持情况时，一般都以 ECMAScript 兼容性和对 DOM 的支持情况为准。</p></section></div><!-- - var ch_num = "0"--><div id="ch1-4"><section><p class="h2">1.4 小结</p><p class="paragraph">JavaScript 是一种专为与网页交互而设计的脚本语言，由下列三个不同的部分组成：</p><ul><li>ECMAScript，由 ECMA-262 定义，提供核心语言功能；</li><li>文档对象模型（DOM），提供访问和操作网页内容的方法和接口；</li><li>浏览器对象模型（BOM），提供与浏览器交互的方法和接口。</li></ul><p class="paragraph">JavaScript 的这三个组成部分，在当前五个主要浏览器（IE、Firefox、Chrome、Safari 和 Opera）中都得到了不同程度的支持。其中，所有浏览器对 ECMAScript 第 3 版的支持大体上都还不错，而对ECMAScript 5 的支持程度越来越高，但对 DOM 的支持则彼此相差比较多。对已经正式纳入 HTML5 标准的 BOM 来说，尽管各浏览器都实现了某些众所周知的共同特性，但其他特性还是会因浏览器而异。</p></section></div><!-- - var ch_num = "0"--><div id="ch2"><section><p class="h1">第 2 章 在HTML中使用 JavaScript</p><p class="paragraph">本章内容</p><ul><li>使用&lt;script&gt;元素</li><li>嵌入脚本与外部脚本</li><li>文档模式对 JavaScript 的影响</li><li>考虑禁用 JavaScript 的场景</li></ul><p class="paragraph">只要一提到把 JavaScript 放到网页中，就不得不涉及 Web 的核心语言——HTML。在当初开发JavaScript 的时候，Netscape 要解决的一个重要问题就是如何做到让 JavaScript 既能与 HTML页面共存，又不影响那些页面在其他浏览器中的呈现效果。经过尝试、纠错和争论，最终的决定就是为 Web 增加统一的脚本支持。而 Web 诞生早期的很多做法也都保留了下来，并被正式纳入 HTML 规范当中。</p></section></div><!-- - var ch_num = "0"--><div id="ch2-1"><section><p class="h2">2.1 &lt;script&gt;元素</p><p class="paragraph">向 HTML 页面中插入 JavaScript 的主要方法，就是使用&lt;script&gt;元素。这个元素由 Netscape 创造并在 Netscape Navigator 2 中首先实现。后来，这个元素被加入到正式的 HTML 规范中。HTML 4.01 为&lt;script&gt;定义了下列 6 个属性。</p><ul><li>async：可选。表示应该立即下载脚本，但不应妨碍页面中的其他操作，比如下载其他资源或等待加载其他脚本。只对外部脚本文件有效。</li><li>charset：可选。表示通过 src 属性指定的代码的字符集。由于大多数浏览器会忽略它的值，因此这个属性很少有人用。</li><li>defer：可选。表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。IE7 及更早版本对嵌入脚本也支持这个属性。</li><li>language：已废弃。原来用于表示编写代码使用的脚本语言（如 JavaScript、JavaScript1.2或 VBScript）。大多数浏览器会忽略这个属性，因此也没有必要再用了。</li><li>src：可选。表示包含要执行代码的外部文件。</li><li>type：可选。可以看成是 language 的替代属性；表示编写代码使用的脚本语言的内容类型（也称为 MIME 类型）。虽然 text/javascript 和 text/ecmascript 都已经不被推荐使用，但人们一直以来使用的都还是 text/javascript。实际上，服务器在传送 JavaScript 文件时使用的MIME 类型通常是 application/x–javascript，但在 type 中设置这个值却可能导致脚本被忽略。另外，在非IE浏览器中还可以使用以下值：application/javascript和application/ecmascript。考虑到约定俗成和最大限度的浏览器兼容性，目前 type 属性的值依旧还是text/javascript。不过，这个属性并不是必需的，如果没有指定这个属性，则其默认值仍为text/javascript。</li></ul><p class="paragraph">使用&lt;script&gt;元素的方式有两种：直接在页面中嵌入 JavaScript 代码和包含外部 JavaScript文件。</p><p class="paragraph">在使用&lt;script&gt;元素嵌入 JavaScript 代码时，只须为&lt;script&gt;指定 type 属性。然后，像下面这样把 JavaScript 代码直接放在元素内部即可：</p><pre><code>&lt;script type="text/javascript"&gt;
     function sayHi(){
        alert("Hi!");
     }
&lt;/script&gt;</code></pre><p class="paragraph">包含在&lt;script&gt;元素内部的 JavaScript 代码将被从上至下依次解释。就拿前面这个例子来说，解释器会解释一个函数的定义，然后将该定义保存在自己的环境当中。在解释器对&lt;script&gt;元素内部的所有代码求值完毕以前，页面中的其余内容都不会被浏览器加载或显示。</p><p class="paragraph">在使用&lt;script&gt;嵌入 JavaScript 代码时，记住不要在代码中的任何地方出现"&lt;/script&gt;"字符串。例如，浏览器在加载下面所示的代码时就会产生一个错误：</p><pre><code>&lt;script type="text/javascript"&gt;
     function sayScript(){
        alert("&lt;/script&gt;");
     }
&lt;/script&gt;</code></pre><p class="paragraph">因为按照解析嵌入式代码的规则，当浏览器遇到字符串"&lt;/script&gt;"时，就会认为那是结束的&lt;/script&gt;标签。而通过转义字符“/”可以解决这个问题，例如：</p><pre><code>&lt;script type="text/javascript"&gt;
     function sayScript(){
        alert("&lt;\/script&gt;");
     }
&lt;/script&gt;</code></pre><p class="paragraph">这样写代码浏览器可以接受，因而也就不会导致错误了。</p><p class="paragraph">如果要通过&lt;script&gt;元素来包含外部 JavaScript 文件，那么 src 属性就是必需的。这个属性的值是一个指向外部 JavaScript 文件的链接，例如：</p><pre><code>&lt;script type="text/javascript" src="example.js"&gt;&lt;/script&gt;</code></pre><p class="paragraph">在这个例子中，外部文件 example.js 将被加载到当前页面中。外部文件只须包含通常要放在开始的&lt;script&gt;和结束的&lt;/script&gt;之间的那些 JavaScript 代码即可。与解析嵌入式 JavaScript 代码一样，在解析外部 JavaScript 文件（包括下载该文件）时，页面的处理也会暂时停止。如果是在 XHTML 文档中，也可以省略前面示例代码中结束的&lt;/script&gt;标签，例如：</p><pre><code>&lt;script type="text/javascript" src="example.js" /&gt;</code></pre><p class="paragraph">但是，不能在 HTML 文档使用这种语法。原因是这种语法不符合 HTML 规范，而且也得不到某些浏览器（尤其是 IE）的正确解析。</p><p class="paragraph tips">按照惯例，外部 JavaScript 文件带有.js 扩展名。但这个扩展名不是必需的，因为浏览器不会检查包含 JavaScript 的文件的扩展名。这样一来，使用 JSP、PHP 或其他服务器端语言动态生成 JavaScript 代码也就成为了可能。但是，服务器通常还是需要看扩展名决定为响应应用哪种 MIME 类型。如果不使用.js 扩展名，请确保服务器能返回正确的 MIME 类型。
</p><p class="paragraph">需要注意的是，带有 src 属性的&lt;script&gt;元素不应该在其&lt;script&gt;和&lt;/script&gt;标签之间再包含额外的 JavaScript 代码。如果包含了嵌入的代码，则只会下载并执行外部脚本文件，嵌入的代码会被忽略。</p><p class="paragraph">另外，通过&lt;script&gt;元素的 src 属性还可以包含来自外部域的 JavaScript 文件。这一点既让&lt;script&gt;元素倍显强大，又让它备受争议。在这一点上，&lt;script&gt;与&lt;img&gt;元素非常相似，即它的 src属性可以是指向当前 HTML 页面所在域之外的某个域中的完整 URL，例如：</p><pre><code>&lt;script type="text/javascript" src="http://www.somewhere.com/afile.js"&gt;&lt;/script&gt;</code></pre><p class="paragraph">这样，位于外部域中的代码也会被加载和解析，就像这些代码位于加载它们的页面中一样。利用这一点就可以在必要时通过不同的域来提供 JavaScript 文件。不过，在访问自己不能控制的服务器上的JavaScript 文件时则要多加小心。如果不幸遇到了怀有恶意的程序员，那他们随时都可能替换该文件中的代码。因此，如果想包含来自不同域的代码，则要么你是那个域的所有者，要么那个域的所有者值得信赖。</p><p class="paragraph">无论如何包含代码，只要不存在 defer 和 async 属性，浏览器都会按照&lt;script&gt;元素在页面中出现的先后顺序对它们依次进行解析。换句话说，在第一个&lt;script&gt;元素包含的代码解析完成后，第二个&lt;script&gt;包含的代码才会被解析，然后才是第三个、第四个……</p></section></div><!-- - var ch_num = "0"--><div id="ch2-1-1"><section><p class="h3">2.1.1 标签的位置</p><p class="paragraph">按照传统的做法，所有&lt;script&gt;元素都应该放在页面的&lt;head&gt;元素中，例如：</p><pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Example HTML Page&lt;/title&gt;
        &lt;script type="text/javascript" src="example1.js"&gt;&lt;/script&gt;
        &lt;script type="text/javascript" src="example2.js"&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;!-- 这里放内容 --&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre><p class="paragraph">这种做法的目的就是把所有外部文件（包括 CSS 文件和 JavaScript 文件）的引用都放在相同的地方。可是，在文档的&lt;head&gt;元素中包含所有 JavaScript 文件，意味着必须等到全部 JavaScript 代码都被下载、解析和执行完成以后，才能开始呈现页面的内容（浏览器在遇到&lt;body&gt;标签时才开始呈现内容）。对于那些需要很多 JavaScript 代码的页面来说，这无疑会导致浏览器在呈现页面时出现明显的延迟，而延迟期间的浏览器窗口中将是一片空白。为了避免这个问题，现代 Web 应用程序一般都把全部 JavaScript 引用放在&lt;body&gt;元素中页面内容的后面，如下例所示：</p><pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Example HTML Page&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;!-- 这里放内容 --&gt;
        &lt;script type="text/javascript" src="example1.js"&gt;&lt;/script&gt;
        &lt;script type="text/javascript" src="example2.js"&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre><p class="paragraph">这样，在解析包含的 JavaScript 代码之前，页面的内容将完全呈现在浏览器中。而用户也会因为浏览器窗口显示空白页面的时间缩短而感到打开页面的速度加快了。</p></section></div><!-- - var ch_num = "0"--><div id="ch2-1-2"><section><p class="h3">2.1.2 延迟脚本</p><p class="paragraph">HTML 4.01 为&lt;script&gt;标签定义了 defer 属性。这个属性的用途是表明脚本在执行时不会影响页面的构造。也就是说，脚本会被延迟到整个页面都解析完毕后再运行。因此，在&lt;script&gt;元素中设置defer 属性，相当于告诉浏览器立即下载，但延迟执行。</p><pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Example HTML Page&lt;/title&gt;
        &lt;script type="text/javascript" defer="defer" src="example1.js"&gt;&lt;/script&gt;
        &lt;script type="text/javascript" defer="defer" src="example2.js"&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;!-- 这里放内容 --&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre><p class="paragraph">在这个例子中，虽然我们把&lt;script&gt;元素放在了文档的&lt;head&gt;元素中，但其中包含的脚本将延迟到浏览器遇到&lt;/html&gt;标签后再执行。HTML5 规范要求脚本按照它们出现的先后顺序执行，因此第一个延迟脚本会先于第二个延迟脚本执行，而这两个脚本会先于 DOMContentLoaded 事件（详见第 13 章）执行。在现实当中，延迟脚本并不一定会按照顺序执行，也不一定会在 DOMContentLoaded 事件触发前执行，因此最好只包含一个延迟脚本。</p><p class="paragraph">前面提到过，defer 属性只适用于外部脚本文件。这一点在 HTML5 中已经明确规定，因此支持HTML5 的实现会忽略给嵌入脚本设置的 defer 属性。IE4～IE7 还支持对嵌入脚本的 defer 属性，但IE8 及之后版本则完全支持 HTML5 规定的行为。</p><p class="paragraph">IE4、Firefox 3.5、Safari 5 和 Chrome 是最早支持 defer 属性的浏览器。其他浏览器会忽略这个属性，像平常一样处理脚本。为此，把延迟脚本放在页面底部仍然是最佳选择。</p><p class="paragraph tips">在 XHTML 文档中，要把 defer 属性设置为 defer="defer"。</p></section></div><!-- - var ch_num = "0"--><div id="ch2-1-3"><section><p class="h3">2.1.3 异步脚本</p><p class="paragraph">HTML5 为&lt;script&gt;元素定义了 async 属性。这个属性与 defer 属性类似，都用于改变处理脚本的行为。同样与 defer 类似，async 只适用于外部脚本文件，并告诉浏览器立即下载文件。但与 defer不同的是，标记为 async 的脚本并不保证按照指定它们的先后顺序执行。例如：</p><pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Example HTML Page&lt;/title&gt;
        &lt;script type="text/javascript" async src="example1.js"&gt;&lt;/script&gt;
        &lt;script type="text/javascript" async src="example2.js"&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;!-- 这里放内容 --&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre><p class="paragraph">在以上代码中，第二个脚本文件可能会在第一个脚本文件之前执行。因此，确保两者之间互不依赖非常重要。指定 async 属性的目的是不让页面等待两个脚本下载和执行，从而异步加载页面其他内容。为此，建议异步脚本不要在加载期间修改 DOM。</p><p class="paragraph">异步脚本一定会在页面的 load 事件前执行，但可能会在 DOMContentLoaded 事件触发之前或之后执行。支持异步脚本的浏览器有 Firefox 3.6、Safari 5 和 Chrome。</p><p class="paragraph tips">在 XHTML 文档中，要把 async 属性设置为 async="async"。</p></section></div><!-- - var ch_num = "0"--><div id="ch2-1-4"><section><p class="h3">2.1.4 在XHTML中的用法①</p><p class="paragraph">可扩展超文本标记语言，即 XHTML（Extensible HyperText Markup Language），是将 HTML 作为XML 的应用而重新定义的一个标准。编写 XHTML 代码的规则要比编写 HTML 严格得多，而且直接影响能否在嵌入 JavaScript 代码时使用&lt;script/>标签。以下面的代码块为例，虽然它们在 HTML 中是有效的，但在 XHTML 中则是无效的。</p><pre><code>&lt;script type="text/javascript">
    function compare(a, b) {
        if (a < b) {
            alert("A is less than B");
        } else if (a > b) {
            alert("A is greater than B");
        } else {
            alert("A is equal to B");
        }
    }
&lt;/script&gt;</code></pre><p class="paragraph">在 HTML 中，有特殊的规则用以确定&lt;script>元素中的哪些内容可以被解析，但这些特殊的规则在 XHTML 中不适用。这里比较语句 a < b 中的小于号（<）在 XHTML 中将被当作开始一个新标签来解析。但是作为标签来讲，小于号后面不能跟空格，因此就会导致语法错误。</p><p class="paragraph">避免在 XHTML 中出现类似语法错误的方法有两个。一是用相应的 HTML 实体（&lt;）替换代码中所有的小于号（<），替换后的代码类似如下所示：</p><pre><code>&lt;script type="text/javascript">
    function compare(a, b) {
        if (a &lt; b) {
            alert("A is less than B");
        } else if (a > b) {
            alert("A is greater than B");
        } else {
            alert("A is equal to B");
        }
    }
&lt;/script&gt;</code></pre><p class="paragraph">虽然这样可以让代码在 XHTML 中正常运行，但却导致代码不好理解了。为此，我们可以考虑采用另一个方法。</p><p class="paragraph">保证让相同代码在 XHTML 中正常运行的第二个方法，就是用一个 CData 片段来包含 JavaScript 代码。在 XHTML（XML）中，CData 片段是文档中的一个特殊区域，这个区域中可以包含不需要解析的任意格式的文本内容。因此，在 CData 片段中就可以使用任意字符——小于号当然也没有问题，而且不会导致语法错误。引入 CData 片段后的 JavaScript 代码块如下所示：</p><pre><code>&lt;script type="text/javascript"><![CDATA[
    function compare(a, b) {
    if (a < b) {
            alert("A is less than B");
        } else if (a > b) {
            alert("A is greater than B");
        } else {
            alert("A is equal to B");
        }
    }
]]>&lt;/script&gt;</code></pre><p class="paragraph">在兼容 XHTML 的浏览器中，这个方法可以解决问题。但实际上，还有不少浏览器不兼容 XHTML，因而不支持 CData 片段。怎么办呢？再使用 JavaScript 注释将 CData 标记注释掉就可以了：</p><p class="paragraph"></p><pre><code>&lt;script type="text/javascript">
//<![CDATA[
     function compare(a, b) {
         if (a < b) {
            alert("A is less than B");
         } else if (a > b) {
            alert("A is greater than B");
         } else {
            alert("A is equal to B");
         }
     }
//]]>
&lt;/script&gt;</code></pre><p class="paragraph">这种格式在所有现代浏览器中都可以正常使用。虽然有几分 hack 的味道，但它能通过 XHTML 验证，而且对 XHTML 之前的浏览器也会平稳退化。</p><p class="paragraph tips">在将页面的 MIME 类型指定为"application/xhtml+xml"的情况下会触发XHTML 模式。并不是所有浏览器都支持以这种方式提供 XHTML 文档。</p></section></div><!-- - var ch_num = "0"--><div id="ch2-1-5"><section><p class="h3">2.1.5 不推荐使用的语法</p><p class="paragraph">在最早引入&lt;script>元素的时候，该元素与传统 HTML 的解析规则是有冲突的。由于要对这个元素应用特殊的解析规则，因此在那些不支持 JavaScript 的浏览器（最典型的是 Mosaic）中就会导致问题。具体来说，不支持 JavaScript 的浏览器会把&lt;script>元素的内容直接输出到页面中，因而会破坏页面的布局和外观。</p><p class="paragraph">Netscape 与 Mosaic 协商并提出了一个解决方案，让不支持&lt;script>元素的浏览器能够隐藏嵌入的JavaScript 代码。这个方案就是把 JavaScript 代码包含在一个 HTML 注释中，像下面这样：</p><pre><code>&lt;script>&lt;!--
     function sayHi(){
        alert("Hi!");
     }
//--&gt;&lt;/script></code></pre><p class="paragraph">给脚本加上 HTML 注释后，Mosaic 等浏览器就会忽略&lt;script>标签中的内容；而那些支持JavaScript 的浏览器在遇到这种情况时，则必须进一步确认其中是否包含需要解析的 JavaScript 代码。</p><p class="paragraph">虽然这种注释 JavaScript 代码的格式得到了所有浏览器的认可，也能被正确解释，但由于所有浏览器都已经支持 JavaScript，因此也就没有必要再使用这种格式了。在 XHTML 模式下，因为脚本包含在XML 注释中，所以脚本会被忽略。</p></section></div><!-- - var ch_num = "0"--><div id="ch2-2"><section><p class="h2">2.2 嵌入代码与外部文件<p class="paragraph">在 HTML 中嵌入 JavaScript 代码虽然没有问题，但一般认为最好的做法还是尽可能使用外部文件来包含 JavaScript 代码。不过，并不存在必须使用外部文件的硬性规定，但支持使用外部文件的人多会强调如下优点。</p><ul><li>可维护性：遍及不同 HTML 页面的 JavaScript 会造成维护问题。但把所有 JavaScript 文件都放在一个文件夹中，维护起来就轻松多了。而且开发人员因此也能够在不触及 HTML 标记的情况下，集中精力编辑 JavaScript 代码。</li><li>可缓存：浏览器能够根据具体的设置缓存链接的所有外部 JavaScript 文件。也就是说，如果有两个页面都使用同一个文件，那么这个文件只需下载一次。因此，最终结果就是能够加快页面加载的速度。</li><li>适应未来：通过外部文件来包含 JavaScript 无须使用前面提到 XHTML 或注释 hack。HTML 和XHTML 包含外部文件的语法是相同的。</li></ul></p></section></div><!-- - var ch_num = "0"--><div id="ch2-3"><section><p class="h2">2.3 文档模式</p><p class="paragraph">IE5.5 引入了文档模式的概念，而这个概念是通过使用文档类型（doctype）切换实现的。最初的两种文档模式是：混杂模式（quirks mode）①和标准模式（standards mode）。混杂模式会让 IE 的行为与（包含非标准特性的）IE5 相同，而标准模式则让 IE 的行为更接近标准行为。虽然这两种模式主要影响 CSS内容的呈现，但在某些情况下也会影响到 JavaScript 的解释执行。本书将在必要时再讨论这些因文档模式而影响 JavaScript 执行的情况。</p><p class="paragraph">IE 引入文档模式的概念后，其他浏览器也纷纷效仿。在此之后，IE 又提出一种所谓的准标准模式（almost standards mode）。这种模式下的浏览器特性有很多都是符合标准的，但也不尽然。不标准的地方主要体现在处理图片间隙的时候（在表格中使用图片时问题最明显）。</p><p class="paragraph">如果在文档开始处没有发现文档类型声明，则所有浏览器都会默认开启混杂模式。但采用混杂模式不是什么值得推荐的做法，因为不同浏览器在这种模式下的行为差异非常大，如果不使用某些 hack 技术，跨浏览器的行为根本就没有一致性可言。</p><p class="paragraph">对于标准模式，可以通过使用下面任何一种文档类型来开启：</p><div class="paragraph">&lt;!-- HTML 4.01 严格型 --&gt;</div><div class="paragraph">&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"&gt;</div><div class="paragraph">&lt;!-- XHTML 1.0 严格型 --&gt;</div><div class="paragraph">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;</div><div class="paragraph">&lt;!-- HTML 5 --&gt;</div><div class="paragraph">&lt;!DOCTYPE html&gt;</div><p class="paragraph">而对于准标准模式，则可以通过使用过渡型（transitional）或框架集型（frameset）文档类型来触发，如下所示：</p><div class="paragraph">&lt;!-- HTML 4.01 过渡型 --&gt;</div><div class="paragraph">&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;</div><div class="paragraph">&lt;!-- HTML 4.01 框架集型 --&gt;</div><div class="paragraph">&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN" "http://www.w3.org/TR/html4/frameset.dtd"&gt;</div><div class="paragraph">&lt;!-- XHTML 1.0 过渡型 --&gt;</div><div class="paragraph">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;</div><div class="paragraph">&lt;!-- XHTML 1.0 框架集型 --&gt;</div><div class="paragraph">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd"&gt;</div><p class="paragraph">准标准模式与标准模式非常接近，它们的差异几乎可以忽略不计。因此，当有人提到“标准模式”时，有可能是指这两种模式中的任何一种。而且，检测文档模式（本书后面将会讨论）时也不会发现什么不同。本书后面提到标准模式时，指的是除混杂模式之外的其他模式。</p><p class="paragraph notes">① 这里 quirks mode 的译法源自 Firefox 3.5.5 中文版。</p></section></div><!-- - var ch_num = "0"--><div id="ch2-4"><section><p class="h2">2.4 &lt;noscript&gt;元素</p><p class="paragraph">早期浏览器都面临一个特殊的问题，即当浏览器不支持 JavaScript 时如何让页面平稳地退化。对这个问题的最终解决方案就是创造一个&lt;noscript&gt;元素，用以在不支持 JavaScript 的浏览器中显示替代的内容。这个元素可以包含能够出现在文档&lt;body&gt;中的任何 HTML 元素——&lt;script&gt;元素除外。包含在&lt;noscript&gt;元素中的内容只有在下列情况下才会显示出来：</p><ul><li>浏览器不支持脚本；</li><li>浏览器支持脚本，但脚本被禁用。</li></ul><p class="paragraph">符合上述任何一个条件，浏览器都会显示&lt;noscript&gt;中的内容。而在除此之外的其他情况下，浏览器不会呈现&lt;noscript&gt;中的内容。</p><p class="paragraph">请看下面这个简单的例子：</p><pre><code>&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Example HTML Page&lt;/title&gt;
        &lt;script type="text/javascript" defer="defer" src="example1.js"&gt;&lt;/script&gt;
        &lt;script type="text/javascript" defer="defer" src="example2.js"&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;noscript&gt;
            &lt;p&gt;本页面需要浏览器支持（启用）JavaScript。&lt;/p&gt;
        &lt;/noscript&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre><p class="paragraph">这个页面会在脚本无效的情况下向用户显示一条消息。而在启用了脚本的浏览器中，用户永远也不会看到它——尽管它是页面的一部分。</p></section></div><!-- - var ch_num = "0"--><div id="ch2-5"><section><p class="h2">2.5 小结</p><p class="paragraph">把 JavaScript 插入到 HTML 页面中要使用&lt;script&gt;元素。使用这个元素可以把 JavaScript 嵌入到HTML 页面中，让脚本与标记混合在一起；也可以包含外部的 JavaScript 文件。而我们需要注意的地方有：</p><ul><li>在包含外部 JavaScript 文件时，必须将 src 属性设置为指向相应文件的 URL。而这个文件既可以是与包含它的页面位于同一个服务器上的文件，也可以是其他任何域中的文件。</li><li>所有&lt;script&gt;元素都会按照它们在页面中出现的先后顺序依次被解析。在不使用 defer 和async 属性的情况下，只有在解析完前面&lt;script&gt;元素中的代码之后，才会开始解析后面&lt;script&gt;元素中的代码。</li><li>由于浏览器会先解析完不使用 defer 属性的&lt;script&gt;元素中的代码，然后再解析后面的内容，所以一般应该把&lt;script&gt;元素放在页面最后，即主要内容后面，&lt;/body&gt;标签前面。 使用 defer 属性可以让脚本在文档完全呈现之后再执行。延迟脚本总是按照指定它们的顺序执行。</li><li>使用 async 属性可以表示当前脚本不必等待其他脚本，也不必阻塞文档呈现。不能保证异步脚本按照它们在页面中出现的顺序执行。</li></ul><p class="paragraph">另外，使用&lt;noscript&gt;元素可以指定在不支持脚本的浏览器中显示的替代内容。但在启用了脚本的情况下，浏览器不会显示&lt;noscript&gt;元素中的任何内容。</p></section></div><!-- - var ch_num = "0"--><div id="ch3"><section><p class="h1">第 3 章 基本概念</p><p class="paragraph">本章内容</p><ul><li>语法</li><li>数据类型</li><li>流控制语句</li><li>函数</li></ul><p class="paragraph">任何语言的核心都必然会描述这门语言最基本的工作原理。而描述的内容通常都要涉及这门语言的语法、操作符、数据类型、内置功能等用于构建复杂解决方案的基本概念。如前所述，ECMA-262 通过叫做 ECMAScript 的“伪语言”为我们描述了 JavaScript 的所有这些基本概念。</p><p class="paragraph">目前，ECMA-262 第 3 版中定义的 ECMAScript 是各浏览器实现最多的一个版本。ECMA-262 第 5版是浏览器接下来实现的版本，但截止到 2011 年底，还没有浏览器完全实现了这个版本。为此，本章将主要按照第 3 版定义的 ECMAScript 介绍这门语言的基本概念，并就第 5 版的变化给出说明。</p></section></div><!-- - var ch_num = "0"--><div id="ch3-1"><section><p class="h2">3.1 语法</p><p class="paragraph">ECMAScript 的语法大量借鉴了 C 及其他类 C 语言（如 Java 和 Perl）的语法。因此，熟悉这些语言的开发人员在接受 ECMAScript 更加宽松的语法时，一定会有一种轻松自在的感觉。</p></section></div><!-- - var ch_num = "0"--><div id="ch3-1-1"><section><p class="h3">3.1.1 区分大小写</p><p class="paragraph">要理解的第一个概念就是 ECMAScript 中的一切（变量、函数名和操作符）都区分大小写。这也就意味着，变量名 test 和变量名 Test 分别表示两个不同的变量，而函数名不能使用 typeof，因为它是一个关键字（3.2 节介绍关键字），但 typeOf 则完全可以是一个有效的函数名。</p></section></div><!-- - var ch_num = "0"--><div id="ch3-1-2"><section><p class="h3">3.1.2 标识符</p><p class="paragraph">所谓标识符，就是指变量、函数、属性的名字，或者函数的参数。标识符可以是按照下列格式规则组合起来的一或多个字符：</p><ul><li>第一个字符必须是一个字母、下划线（_）或一个美元符号（$）；</li><li>其他字符可以是字母、下划线、美元符号或数字。</li></ul><p class="paragraph">标识符中的字母也可以包含扩展的 ASCII 或 Unicode 字母字符（如 À 和 Æ），但我们不推荐这样做。</p><p class="paragraph">按照惯例，ECMAScript 标识符采用驼峰大小写格式，也就是第一个字母小写，剩下的每个单词的首字母大写，例如：</p><div class="paragraph">firstSecond</div><div class="paragraph">myCar</div><div class="paragraph">doSomethingImportant</div><p class="paragraph">虽然没有谁强制要求必须采用这种格式，但为了与 ECMAScript 内置的函数和对象命名格式保持一致，可以将其当作一种最佳实践。</p><p class="paragraph tips">不能把关键字、保留字、true、false 和 null 用作标识符。3.2节将介绍更多相关内容。</p></section></div><!-- - var ch_num = "0"--><div id="ch3-1-3"><section><p class="h3">3.1.3 注释</p><p class="paragraph">ECMAScript 使用 C 风格的注释，包括单行注释和块级注释。单行注释以两个斜杠开头，如下所示：</p><pre><code>// 单行注释</code></pre><p class="paragraph">块级注释以一个斜杠和一个星号（/*）开头，以一个星号和一个斜杠（*/）结尾，如下所示：</p><pre><code>/*
* 这是一个多行
* （块级）注释
*/</code></pre><p class="paragraph">虽然上面注释中的第二和第三行都以一个星号开头，但这不是必需的。之所以添加那两个星号，纯粹是为了提高注释的可读性（这种格式在企业级应用中用得比较多）。</p></section></div><!-- - var ch_num = "0"--><div id="ch3-1-4"><section><p class="h3">3.1.4 严格模式</p><p class="paragraph">ECMAScript 5 引入了严格模式（strict mode）的概念。严格模式是为 JavaScript 定义了一种不同的解析与执行模型。在严格模式下，ECMAScript 3 中的一些不确定的行为将得到处理，而且对某些不安全的操作也会抛出错误。要在整个脚本中启用严格模式，可以在顶部添加如下代码：</p><pre><code>"use strict";</code></pre><p class="paragraph">这行代码看起来像是字符串，而且也没有赋值给任何变量，但其实它是一个编译指示（pragma），用于告诉支持的 JavaScript 引擎切换到严格模式。这是为不破坏 ECMAScript 3 语法而特意选定的语法。</p><p class="paragraph">在函数内部的上方包含这条编译指示，也可以指定函数在严格模式下执行：</p><pre><code>function doSomething(){
     "use strict";
     //函数体
}</code></pre><p class="paragraph">严格模式下，JavaScript 的执行结果会有很大不同，因此本书将会随时指出严格模式下的区别。支持严格模式的浏览器包括 IE10+、Firefox 4+、Safari 5.1+、Opera 12+和 Chrome。</p></section></div><!-- - var ch_num = "0"--><div id="ch3-1-5"><section><p class="h3">3.1.5 语句</p><p class="paragraph">ECMAScript 中的语句以一个分号结尾；如果省略分号，则由解析器确定语句的结尾，如下例所示：</p><div class="paragraph">var sum = a + b // 即使没有分号也是有效的语句——不推荐</div><div class="paragraph">var diff = a - b; // 有效的语句——推荐</div><p class="paragraph">虽然语句结尾的分号不是必需的，但我们建议任何时候都不要省略它。因为加上这个分号可以避免很多错误（例如不完整的输入），开发人员也可以放心地通过删除多余的空格来压缩 ECMAScript 代码（代码行结尾处没有分号会导致压缩错误）。另外，加上分号也会在某些情况下增进代码的性能，因为这样解析器就不必再花时间推测应该在哪里插入分号了。</p><p class="paragraph">可以使用 C 风格的语法把多条语句组合到一个代码块中，即代码块以左花括号（{）开头，以右花括号（}）结尾：</p><pre><code>if (test){
     test = false;
     alert(test);
}</code></pre><P class="paragraph">虽然条件控制语句（如 if 语句）只在执行多条语句的情况下才要求使用代码块，但最佳实践是始终在控制语句中使用代码块——即使代码块中只有一条语句，例如：</P><pre><code>if (test)
    alert(test); // 有效但容易出错，不要使用
if (test){ // 推荐使用
    alert(test);
}</code></pre><p class="paragraph">在控制语句中使用代码块可以让编码意图更加清晰，而且也能降低修改代码时出错的几率。</p></section></div><!-- - var ch_num = "0"--><div id="ch3-2"><section><p class="h2">3.2 关键字和保留字</p><p class="paragraph">ECMA-262 描述了一组具有特定用途的关键字，这些关键字可用于表示控制语句的开始或结束，或者用于执行特定操作等。按照规则，关键字也是语言保留的，不能用作标识符。以下就是 ECMAScript的全部关键字（带*号上标的是第 5 版新增的关键字）：</p><table><tr><td>break</td><td>do</td><td>instanceof</td><td>typeof</td><td>case</td><td>else</td></tr><tr><td>new</td><td>var</td><td>catch</td><td>finally</td><td>return</td><td>void</td></tr><tr><td>continue</td><td>for</td><td>switch</td><td>while</td><td>debugger*</td><td>function</td></tr><tr><td>this</td><td>with</td><td>default</td><td>if</td><td>throw</td><td>delete</td></tr><tr><td>in</td><td>try</td></tr></table><p class="paragraph">ECMA-262 还描述了另外一组不能用作标识符的保留字。尽管保留字在这门语言中还没有任何特定的用途，但它们有可能在将来被用作关键字。以下是 ECMA-262 第 3 版定义的全部保留字：</p><table><tr><td>enum</td><td>int</td><td>short</td><td>abstract</td><td>boolean</td><td>export</td></tr><tr><td>interface</td><td>static</td><td>byte</td><td>extends</td><td>long</td><td>super</td></tr><tr><td>char</td><td>final</td><td>native</td><td>synchronized</td><td>class</td><td>float</td></tr><tr><td>package</td><td>throws</td><td>const</td><td>goto</td><td>private</td><td>transient</td></tr><tr><td>debugger</td><td>implements</td><td>protected</td><td>volatile</td><td>double</td><td>import</td></tr><tr><td>public</td></tr></table><p class="paragraph">第 5 版把在非严格模式下运行时的保留字缩减为下列这些：</p><table><tr><td>class</td><td>enum</td><td>extends</td><td>super</td></tr><tr><td>const</td><td>export</td><td>import</td></tr></table><p class="paragraph">在严格模式下，第 5 版还对以下保留字施加了限制：</p><table><tr><td>implements</td><td>package</td><td>public</td></tr><tr><td>interface</td><td>private</td><td>static</td></tr><tr><td>let</td><td>protected</td><td>yield</td></tr></table><p class="paragraph">注意，let 和 yield 是第 5 版新增的保留字；其他保留字都是第 3 版定义的。为了最大程度地保证兼容性，建议读者将第 3 版定义的保留字外加 let 和 yield 作为编程时的参考。</p><p class="paragraph">在实现 ECMAScript 3 的 JavaScript 引擎中使用关键字作标识符，会导致“Identifier Expected”错误。而使用保留字作标识符可能会也可能不会导致相同的错误，具体取决于特定的引擎。</p><p class="paragraph">第 5 版对使用关键字和保留字的规则进行了少许修改。关键字和保留字虽然仍然不能作为标识符使用，但现在可以用作对象的属性名。一般来说，最好都不要使用关键字和保留字作为标识符和属性名，以便与将来的 ECMAScript 版本兼容。</p><p class="paragraph">除了上面列出的保留字和关键字，ECMA-262 第 5 版对 eval 和 arguments 还施加了限制。在严格模式下，这两个名字也不能作为标识符或属性名，否则会抛出错误。</p></section></div><!-- - var ch_num = "0"--><div id="ch3-3"><section><p class="h2">3.3 变量</p><p class="paragraph">ECMAScript 的变量是松散类型的，所谓松散类型就是可以用来保存任何类型的数据。换句话说，每个变量仅仅是一个用于保存值的占位符而已。定义变量时要使用 var 操作符（注意 var 是一个关键字），后跟变量名（即一个标识符），如下所示：</p><pre><code>var message;</code></pre><p class="paragraph">这行代码定义了一个名为 message 的变量，该变量可以用来保存任何值（像这样未经过初始化的变量，会保存一个特殊的值——undefined，相关内容将在 3.4 节讨论）。ECMAScript 也支持直接初始化变量，因此在定义变量的同时就可以设置变量的值，如下所示：</p><pre><code>var message = "hi";</code></pre><p class="paragraph">在此，变量 message 中保存了一个字符串值"hi"。像这样初始化变量并不会把它标记为字符串类型；初始化的过程就是给变量赋一个值那么简单。因此，可以在修改变量值的同时修改值的类型，如下所示：</p><pre><code>var message = "hi";
message = 100; // 有效，但不推荐</code></pre><p class="paragraph">在这个例子中，变量 message 一开始保存了一个字符串值"hi"，然后该值又被一个数字值 100 取代。虽然我们不建议修改变量所保存值的类型，但这种操作在 ECMAScript 中完全有效。</p><p class="paragraph">有一点必须注意，即用 var 操作符定义的变量将成为定义该变量的作用域中的局部变量。也就是说，如果在函数中使用 var 定义一个变量，那么这个变量在函数退出后就会被销毁，例如：</p><pre><code>function test(){
    var message = "hi"; // 局部变量
}
test();
alert(message); // 错误！</code></pre><p class="paragraph">这里，变量 message 是在函数中使用 var 定义的。当函数被调用时，就会创建该变量并为其赋值。而在此之后，这个变量又会立即被销毁，因此例子中的下一行代码就会导致错误。不过，可以像下面这样省略 var 操作符，从而创建一个全局变量：</p><pre><code>function test(){
    message = "hi"; // 全局变量
}
test();
alert(message); // "hi"</code></pre><p class="paragraph">这个例子省略了 var 操作符，因而 message 就成了全局变量。这样，只要调用过一次 test()函数，这个变量就有了定义，就可以在函数外部的任何地方被访问到。</p><p class="paragraph tips">虽然省略 var 操作符可以定义全局变量，但这也不是我们推荐的做法。因为在局部作用域中定义的全局变量很难维护，而且如果有意地忽略了 var 操作符，也会由于相应变量不会马上就有定义而导致不必要的混乱。给未经声明的变量赋值在严格模式下会导致抛出 ReferenceError 错误。</p><p class="paragraph">可以使用一条语句定义多个变量，只要像下面这样把每个变量（初始化或不初始化均可）用逗号分隔开即可：</p><pre><code>var message = "hi",
found = false,
age = 29;</code></pre><p class="paragraph">这个例子定义并初始化了 3 个变量。同样由于 ECMAScript 是松散类型的，因而使用不同类型初始化变量的操作可以放在一条语句中来完成。虽然代码里的换行和变量缩进不是必需的，但这样做可以提高可读性。</p><p class="paragraph">在严格模式下，不能定义名为 eval 或 arguments 的变量，否则会导致语法错误。</p></section></div><!-- - var ch_num = "0"--><div id="ch3-4"><section><p class="h2">3.4 数据类型</p><p class="paragraph">ECMAScript 中有 5 种简单数据类型（也称为基本数据类型）：Undefined、Null、Boolean、Number和 String。还有 1种复杂数据类型——Object，Object 本质上是由一组无序的名值对组成的。ECMAScript不支持任何创建自定义类型的机制，而所有值最终都将是上述 6 种数据类型之一。乍一看，好像只有 6种数据类型不足以表示所有数据；但是，由于 ECMAScript 数据类型具有动态性，因此的确没有再定义其他数据类型的必要了。</p></section></div><!-- - var ch_num = "0"--><div id="ch3-4-1"><section><p class="h3">3.4.1 typeof操作符</p><p class="paragraph">鉴于 ECMAScript 是松散类型的，因此需要有一种手段来检测给定变量的数据类型——typeof 就是负责提供这方面信息的操作符。对一个值使用 typeof 操作符可能返回下列某个字符串：</p><ul><li>"undefined"——如果这个值未定义；</li><li>"boolean"——如果这个值是布尔值；</li><li>"string"——如果这个值是字符串；</li><li>"number"——如果这个值是数值；</li><li>"object"——如果这个值是对象或 null；</li><li>"function"——如果这个值是函数。</li></ul><p class="paragraph">下面是几个使用 typeof 操作符的例子：</p><pre><code>var message = "some string";
alert(typeof message); // "string"
alert(typeof(message)); // "string"
alert(typeof 95); // "number"</code></pre><p class="paragraph source-file">TypeofExample01.htm</p><p class="paragraph">这几个例子说明，typeof 操作符的操作数可以是变量（message），也可以是数值字面量。注意，typeof 是一个操作符而不是函数，因此例子中的圆括号尽管可以使用，但不是必需的。</p><p class="paragraph">有些时候，typeof 操作符会返回一些令人迷惑但技术上却正确的值。比如，调用 typeof null会返回"object"，因为特殊值 null 被认为是一个空的对象引用。Safari 5 及之前版本、Chrome 7 及之前版本在对正则表达式调用 typeof 操作符时会返回"function"，而其他浏览器在这种情况下会返回"object"。</p><p class="paragraph tips">从技术角度讲，函数在 ECMAScript 中是对象，不是一种数据类型。然而，函数也确实有一些特殊的属性，因此通过 typeof 操作符来区分函数和其他对象是有必要的。</p></section></div><!-- - var ch_num = "0"--><div id="ch3-4-2"><section><p class="h3">3.4.2 Undefined类型</p><p class="paragraph">Undefined 类型只有一个值，即特殊的 undefined。在使用 var 声明变量但未对其加以初始化时，这个变量的值就是 undefined，例如：</p><pre><code>var message;
alert(message == undefined); //true</code></pre><p class="paragraph source-file">UndefinedExample01.htm</p><p class="paragraph">这个例子只声明了变量 message，但未对其进行初始化。比较这个变量与 undefined 字面量，结果表明它们是相等的。这个例子与下面的例子是等价的：</p><pre><code>var message = undefined;
alert(message == undefined); //true</code></pre><p class="paragraph source-file">UndefinedExample02.htm</p><p class="paragraph">这个例子使用 undefined 值显式初始化了变量 message。但我们没有必要这么做，因为未经初始化的值默认就会取得 undefined 值。</p><p class="paragraph tips">一般而言，不存在需要显式地把一个变量设置为 undefined 值的情况。字面值undefined 的主要目的是用于比较，而 ECMA-262 第 3 版之前的版本中并没有规定这个值。第 3 版引入这个值是为了正式区分空对象指针与未经初始化的变量。</p><p class="paragraph">不过，包含 undefined 值的变量与尚未定义的变量还是不一样的。看看下面这个例子：</p><pre><code>var message; // 这个变量声明之后默认取得了 undefined 值
// 下面这个变量并没有声明
// var age
alert(message); // "undefined"
alert(age); // 产生错误</code></pre><p class="paragraph source-file">UndefinedExample03.htm</p><p class="paragraph">运行以上代码，第一个警告框会显示变量 message 的值，即"undefined"。而第二个警告框——由于传递给 alert()函数的是尚未声明的变量 age——则会导致一个错误。对于尚未声明过的变量，只能执行一项操作，即使用 typeof 操作符检测其数据类型（对未经声明的变量调用 delete 不会导致错误，但这样做没什么实际意义，而且在严格模式下确实会导致错误）。</p><p class="paragraph">然而，令人困惑的是：对未初始化的变量执行 typeof 操作符会返回 undefined 值，而对未声明的变量执行 typeof 操作符同样也会返回 undefined 值。来看下面的例子：</p><pre><code>var message; // 这个变量声明之后默认取得了 undefined 值
// 下面这个变量并没有声明
// var age
alert(typeof message); // "undefined"
alert(typeof age); // "undefined"</code></pre><p class="paragraph source-file">UndefinedExample04.htm</p><p class="paragraph">结果表明，对未初始化和未声明的变量执行 typeof 操作符都返回了 undefined 值；这个结果有其逻辑上的合理性。因为虽然这两种变量从技术角度看有本质区别，但实际上无论对哪种变量也不可能执行真正的操作。</p><p class="paragraph tips">即便未初始化的变量会自动被赋予 undefined 值，但显式地初始化变量依然是明智的选择。如果能够做到这一点，那么当 typeof 操作符返回"undefined"值时，我们就知道被检测的变量还没有被声明，而不是尚未初始化。</p></section></div><!-- - var ch_num = "0"--><div id="ch3-4-3"><section><p class="h3">3.4.3 Null类型</p><p class="paragraph">Null 类型是第二个只有一个值的数据类型，这个特殊的值是 null。从逻辑角度来看，null 值表示一个空对象指针，而这也正是使用 typeof 操作符检测 null 值时会返回"object"的原因，如下面的例子所示：</p><pre><code>var car = null;
alert(typeof car); // "object"</code></pre><p class="paragraph source-file">NullExample01.htm</p><p class="paragraph">如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为 null 而不是其他值。这样一来，只要直接检查 null 值就可以知道相应的变量是否已经保存了一个对象的引用，如下面的例子所示：</p><pre><code>if (car != null){
    // 对 car 对象执行某些操作
}</code></pre><p class="paragraph">实际上，undefined 值是派生自 null 值的，因此 ECMA-262 规定对它们的相等性测试要返回 true：</p><pre><code>alert(null == undefined); //true</code></pre><p class="paragraph source-file">NullExample02.htm</p><p class="paragraph">这里，位于 null 和 undefined 之间的相等操作符（==）总是返回 true，不过要注意的是，这个操作符出于比较的目的会转换其操作数（本章后面将详细介绍相关内容）。</p><p class="paragraph">尽管 null 和 undefined 有这样的关系，但它们的用途完全不同。如前所述，无论在什么情况下都没有必要把一个变量的值显式地设置为 undefined，可是同样的规则对 null 却不适用。换句话说，只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存 null 值。这样做不仅可以体现 null 作为空对象指针的惯例，而且也有助于进一步区分 null 和 undefined。</p></section></div><!-- - var ch_num = "0"--><div id="ch3-4-4"><section><p class="h3">3.4.4 Boolean类型</p><p class="paragraph">Boolean 类型是 ECMAScript 中使用得最多的一种类型，该类型只有两个字面值：true 和 false。这两个值与数字值不是一回事，因此 true 不一定等于 1，而 false 也不一定等于 0。以下是为变量赋Boolean 类型值的例子：</p><pre><code>var found = true;
var lost = false;</code></pre><p class="paragraph">需要注意的是，Boolean 类型的字面值 true 和 false 是区分大小写的。也就是说，True 和 False（以及其他的混合大小写形式）都不是 Boolean 值，只是标识符。</p><p class="paragraph">虽然 Boolean 类型的字面值只有两个，但 ECMAScript 中所有类型的值都有与这两个 Boolean 值等价的值。要将一个值转换为其对应的 Boolean 值，可以调用转型函数 Boolean()，如下例所示：</p><pre><code>var message = "Hello world!";
var messageAsBoolean = Boolean(message);</code></pre><p class="paragraph source-file">BooleanExample01.htm</p><p class="paragraph">在这个例子中，字符串 message 被转换成了一个 Boolean 值，该值被保存在 messageAsBoolean变量中。可以对任何数据类型的值调用 Boolean()函数，而且总会返回一个 Boolean 值。至于返回的这个值是 true 还是 false，取决于要转换值的数据类型及其实际值。下表给出了各种数据类型及其对应的转换规则。</p><table><tr><th>数据类型</th><th>转换为true的值</th><th>转换为false的值</th></tr><tr><td>Boolean</td><td>true</td><td>false</td></tr><tr><td>String</td><td>任何非空字符串</td><td>""（空字符串）</td></tr><tr><td>Number</td><td>任何非零数字值（包括无穷大）</td><td>0和NaN（参见本章后面有关NaN的内容）</td></tr><tr><td>Object</td><td>任何对象</td><td>null</td></tr><tr><td>Undefined</td><td>n/a①</td><td>undefined</td></tr></table><p class="paragraph">这些转换规则对理解流控制语句（如 if 语句）自动执行相应的 Boolean 转换非常重要，请看下面的代码：</p><pre><code>var message = "Hello world!";
if (message){
    alert("Value is true");
}</code></pre><p class="paragraph source-file">BooleanExample02.htm</p><p class="paragraph">运行这个示例，就会显示一个警告框，因为字符串 message 被自动转换成了对应的 Boolean 值（true）。由于存在这种自动执行的 Boolean 转换，因此确切地知道在流控制语句中使用的是什么变量至关重要。错误地使用一个对象而不是一个 Boolean 值，就有可能彻底改变应用程序的流程。</p></section></div><!-- - var ch_num = "0"--><div id="ch3-4-5"><section><p class="h3">3.4.5 Number类型</p><p class="paragraph">Number 类型应该是 ECMAScript 中最令人关注的数据类型了，这种类型使用 IEEE754 格式来表示整数和浮点数值（浮点数值在某些语言中也被称为双精度数值）。为支持各种数值类型，ECMA-262 定义了不同的数值字面量格式。</p><p class="paragraph">最基本的数值字面量格式是十进制整数，十进制整数可以像下面这样直接在代码中输入：</p><pre><code>var intNum = 55;      // 整数</code></pre><p class="paragraph">除了以十进制表示外，整数还可以通过八进制（以 8 为基数）或十六进制（以 16 为基数）的字面值来表示。其中，八进制字面值的第一位必须是零（0），然后是八进制数字序列（0～7）。如果字面值中的数值超出了范围，那么前导零将被忽略，后面的数值将被当作十进制数值解析。请看下面的例子：</p><pre><code>var octalNum1 = 070; // 八进制的 56
var octalNum2 = 079; // 无效的八进制数值——解析为 79
var octalNum3 = 08; // 无效的八进制数值——解析为 8</code></pre><p class="paragraph">八进制字面量在严格模式下是无效的，会导致支持的 JavaScript 引擎抛出错误。</p><p class="paragraph">十六进制字面值的前两位必须是 0x，后跟任何十六进制数字（0～9 及 A～F）。其中，字母 A～F可以大写，也可以小写。如下面的例子所示：</p><pre><code>var hexNum1 = 0xA; // 十六进制的 10
var hexNum2 = 0x1f; // 十六进制的 31</code></pre><p class="paragraph">在进行算术计算时，所有以八进制和十六进制表示的数值最终都将被转换成十进制数值。</p><p class="paragraph notes">① n/a（或 N/A），是 not applicable 的缩写，意思是“不适用”。</p><p class="paragraph tips">鉴于 JavaScript 中保存数值的方式，可以保存正零（+0）和负零（-0）。正零和负零被认为相等，但为了读者更好地理解上下文，这里特别做此说明。</p><p class="paragraph strong">1. 浮点数值</p><p class="paragraph">所谓浮点数值，就是该数值中必须包含一个小数点，并且小数点后面必须至少有一位数字。虽然小数点前面可以没有整数，但我们不推荐这种写法。以下是浮点数值的几个例子：</p><pre><code>var floatNum1 = 1.1;
var floatNum2 = 0.1;
var floatNum3 = .1; // 有效，但不推荐</code></pre><p class="paragraph">由于保存浮点数值需要的内存空间是保存整数值的两倍，因此 ECMAScript 会不失时机地将浮点数值转换为整数值。显然，如果小数点后面没有跟任何数字，那么这个数值就可以作为整数值来保存。同样地，如果浮点数值本身表示的就是一个整数（如 1.0），那么该值也会被转换为整数，如下面的例子所示：</p><pre><code>var floatNum1 = 1.; // 小数点后面没有数字——解析为 1
var floatNum2 = 10.0; // 整数——解析为 10</code></pre><p class="paragraph">对于那些极大或极小的数值，可以用 e 表示法（即科学计数法）表示的浮点数值表示。用 e 表示法表示的数值等于 e 前面的数值乘以 10 的指数次幂。ECMAScript 中 e 表示法的格式也是如此，即前面是一个数值（可以是整数也可以是浮点数），中间是一个大写或小写的字母 E，后面是 10 的幂中的指数，该幂值将用来与前面的数相乘。下面是一个使用 e 表示法表示数值的例子：</p><pre><code>var floatNum = 3.125e7; // 等于 31250000</code></pre><p class="paragraph">在这个例子中，使用 e 表示法表示的变量 floatNum 的形式虽然简洁，但它的实际值则是 31250000。在此，e 表示法的实际含义就是“3.125 乘以 10<sup>7</sup>”。</p><p class="paragraph">也可以使用 e 表示法表示极小的数值，如 0.00000000000000003，这个数值可以使用更简洁的 3e-17表示。在默认情况下，ECMASctipt 会将那些小数点后面带有 6 个零以上的浮点数值转换为以 e 表示法表示的数值（例如，0.0000003 会被转换成 3e-7）。</p><p class="paragraph">浮点数值的最高精度是 17 位小数，但在进行算术计算时其精确度远远不如整数。例如，0.1 加 0.2的结果不是 0.3，而是 0.30000000000000004。这个小小的舍入误差会导致无法测试特定的浮点数值。例如：</p><pre><code>if (a + b == 0.3){ // 不要做这样的测试！
    alert("You got 0.3.");
}</code></pre><p class="paragraph">在这个例子中，我们测试的是两个数的和是不是等于 0.3。如果这两个数是 0.05 和 0.25，或者是 0.15和 0.15 都不会有问题。而如前所述，如果这两个数是 0.1 和 0.2，那么测试将无法通过。因此，永远不要测试某个特定的浮点数值。</p><p class="paragraph tips">关于浮点数值计算会产生舍入误差的问题，有一点需要明确：这是使用基于IEEE754 数值的浮点计算的通病，ECMAScript 并非独此一家；其他使用相同数值格式的语言也存在这个问题。</p><p class="paragraph strong">2. 数值范围</p><p class="paragraph">由于内存的限制，ECMAScript 并不能保存世界上所有的数值。ECMAScript 能够表示的最小数值保存在 Number.MIN_VALUE 中——在大多数浏览器中，这个值是 5e-324；能够表示的最大数值保存在Number.MAX_VALUE 中——在大多数浏览器中，这个值是 1.7976931348623157e+308。如果某次计算的结果得到了一个超出 JavaScript 数值范围的值，那么这个数值将被自动转换成特殊的 Infinity 值。具体来说，如果这个数值是负数，则会被转换成-Infinity（负无穷），如果这个数值是正数，则会被转换成 Infinity（正无穷）。</p><p class="paragraph">如上所述，如果某次计算返回了正或负的 Infinity 值，那么该值将无法继续参与下一次的计算，因为 Infinity 不是能够参与计算的数值。要想确定一个数值是不是有穷的（换句话说，是不是位于最小和最大的数值之间），可以使用 isFinite()函数。这个函数在参数位于最小与最大数值之间时会返回 true，如下面的例子所示：</p><pre><code>var result = Number.MAX_VALUE + Number.MAX_VALUE;
alert(isFinite(result)); //false</code></pre><p class="paragraph">尽管在计算中很少出现某些值超出表示范围的情况，但在执行极小或极大数值的计算时，检测监控这些值是可能的，也是必需的。</p><p class="paragraph tips">访问 Number.NEGATIVE_INFINITY 和 Number.POSITIVE_INFINITY 也可以得到负和正 Infinity 的值。可以想见，这两个属性中分别保存着-Infinity 和Infinity。</p><p class="paragraph strong">3. NaN</p><p class="paragraph">NaN，即非数值（Not a Number）是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。例如，在其他编程语言中，任何数值除以 0都会导致错误，从而停止代码执行。但在 ECMAScript中，任何数值除以 0会返回 NaN①，因此不会影响其他代码的执行。</p><p class="paragraph notes">① 原书如此，但实际上只有 0 除以 0 才会返回 NaN，正数除以 0 返回 Infinity，负数除以 0 返回-Infinity。</p><p class="paragraph">NaN 本身有两个非同寻常的特点。首先，任何涉及 NaN 的操作（例如 NaN/10）都会返回 NaN，这个特点在多步计算中有可能导致问题。其次，NaN 与任何值都不相等，包括 NaN 本身。例如，下面的代码会返回 false：</p><pre><code>alert(NaN == NaN); //false</code></pre><p class="paragraph">针对 NaN 的这两个特点，ECMAScript 定义了 isNaN()函数。这个函数接受一个参数，该参数可以是任何类型，而函数会帮我们确定这个参数是否“不是数值”。isNaN()在接收到一个值之后，会尝试将这个值转换为数值。某些不是数值的值会直接转换为数值，例如字符串"10"或 Boolean 值。而任何不能被转换为数值的值都会导致这个函数返回 true。请看下面的例子：</p><pre><code>alert(isNaN(NaN)); //true
alert(isNaN(10)); //false（10 是一个数值）
alert(isNaN("10")); //false（可以被转换成数值 10）
alert(isNaN("blue")); //true（不能转换成数值）
alert(isNaN(true)); //false（可以被转换成数值 1）</code></pre><p class="paragraph source-file">NumberExample03.htm</p><p class="paragraph">这个例子测试了 5 个不同的值。测试的第一个值是 NaN 本身，结果当然会返回 true。然后分别测试了数值 10 和字符串"10"，结果这两个测试都返回了 false，因为前者本身就是数值，而后者可以被转换成数值。但是，字符串"blue"不能被转换成数值，因此函数返回了 true。由于 Boolean 值 true可以转换成数值 1，因此函数返回 false。</p><p class="paragraph tips">尽管有点儿不可思议，但 isNaN()确实也适用于对象。在基于对象调用 isNaN()函数时，会首先调用对象的 valueOf()方法，然后确定该方法返回的值是否可以转换为数值。如果不能，则基于这个返回值再调用 toString()方法，再测试返回值。而这个过程也是 ECMAScript 中内置函数和操作符的一般执行流程，更详细的内容请参见 3.5 节。</p><p class="paragraph strong">4. 数值转换</p><p class="paragraph"> 3 个函数可以把非数值转换为数值：Number()、parseInt()和 parseFloat()。第一个函数，即转型函数 Number()可以用于任何数据类型，而另两个函数则专门用于把字符串转换成数值。这 3 个函数对于同样的输入会有返回不同的结果。</p><p class="paragraph">Number()函数的转换规则如下。</p><ul><li>如果是 Boolean 值，true 和 false 将分别被转换为 1 和 0。</li><li>如果是数字值，只是简单的传入和返回。</li><li>如果是 null 值，返回 0。</li><li>如果是 undefined，返回 NaN。</li><li>如果是字符串，遵循下列规则：<ul><li>如果字符串中只包含数字（包括前面带正号或负号的情况），则将其转换为十进制数值，即"1"会变成 1，"123"会变成 123，而"011"会变成 11（注意：前导的零被忽略了）；</li><li>如果字符串中包含有效的浮点格式，如"1.1"，则将其转换为对应的浮点数值（同样，也会忽略前导零）；</li><li>如果字符串中包含有效的十六进制格式，例如"0xf"，则将其转换为相同大小的十进制整数值；</li><li>如果字符串是空的（不包含任何字符），则将其转换为 0；</li><li>如果字符串中包含除上述格式之外的字符，则将其转换为 NaN。</li></ul></li><li>如果是对象，则调用对象的 valueOf()方法，然后依照前面的规则转换返回的值。如果转换的结果是 NaN，则调用对象的 toString()方法，然后再次依照前面的规则转换返回的字符串值。</li></ul><p class="paragraph">根据这么多的规则使用 Number()把各种数据类型转换为数值确实有点复杂。下面还是给出几个具体的例子吧。</p><pre><code>var num1 = Number("Hello world!"); //NaN
var num2 = Number(""); //0
var num3 = Number("000011"); //11
var num4 = Number(true); //1</code></pre><p class="paragraph source-file">NumberExample04.htm</p><p class="paragraph">首先，字符串"Hello world!"会被转换为 NaN，因为其中不包含任何有意义的数字值。空字符串会被转换为 0。字符串"000011"会被转换为 11，因为忽略了其前导的零。最后，true 值被转换为 1。</p><p class="paragraph tips">一元加操作符（3.5.1 节将介绍）的操作与 Number()函数相同。</p><p class="paragraph">由于 Number()函数在转换字符串时比较复杂而且不够合理，因此在处理整数的时候更常用的是parseInt()函数。parseInt()函数在转换字符串时，更多的是看其是否符合数值模式。它会忽略字符串前面的空格，直至找到第一个非空格字符。如果第一个字符不是数字字符或者负号，parseInt()就会返回 NaN；也就是说，用 parseInt()转换空字符串会返回 NaN（Number()对空字符返回 0）。如果第一个字符是数字字符，parseInt()会继续解析第二个字符，直到解析完所有后续字符或者遇到了一个非数字字符。例如，"1234blue"会被转换为 1234，因为"blue"会被完全忽略。类似地，"22.5"会被转换为 22，因为小数点并不是有效的数字字符。</p><p class="paragraph">如果字符串中的第一个字符是数字字符，parseInt()也能够识别出各种整数格式（即前面讨论的十进制、八进制和十六进制数）。也就是说，如果字符串以"0x"开头且后跟数字字符，就会将其当作一个十六进制整数；如果字符串以"0"开头且后跟数字字符，则会将其当作一个八进制数来解析。</p><p class="paragraph">为了更好地理解 parseInt()函数的转换规则，下面给出一些例子：</p><pre><code>var num1 = parseInt("1234blue"); // 1234
var num2 = parseInt(""); // NaN
var num3 = parseInt("0xA"); // 10（十六进制数）
var num4 = parseInt(22.5); // 22
var num5 = parseInt("070"); // 56（八进制数）
var num6 = parseInt("70"); // 70（十进制数）
var num7 = parseInt("0xf"); // 15（十六进制数）</code></pre><p class="paragraph source-file">NumberExample05.htm</p><p class="paragraph">在使用 parseInt()解析像八进制字面量的字符串时，ECMAScript 3 和 5 存在分歧。例如：</p><pre><code>//ECMAScript 3 认为是 56（八进制），ECMAScript 5 认为是 70（十进制）
var num = parseInt("070");</code></pre><p class="paragraph">在 ECMAScript 3 JavaScript 引擎中，"070"被当成八进制字面量，因此转换后的值是十进制的 56。而在 ECMAScript 5 JavaScript 引擎中，parseInt()已经不具有解析八进制值的能力，因此前导的零会被认为无效，从而将这个值当成"70"，结果就得到十进制的 70。在 ECMAScript 5 中，即使是在非严格模式下也会如此。</p><p class="paragraph">为了消除在使用 parseInt()函数时可能导致的上述困惑，可以为这个函数提供第二个参数：转换时使用的基数（即多少进制）。如果知道要解析的值是十六进制格式的字符串，那么指定基数 16 作为第二个参数，可以保证得到正确的结果，例如：</p><pre><code>var num = parseInt("0xAF", 16); //175</code></pre><p class="paragraph">实际上，如果指定了 16 作为第二个参数，字符串可以不带前面的"0x"，如下所示：</p><pre><code>var num1 = parseInt("AF", 16); //175
var num2 = parseInt("AF"); //NaN</code></pre><p class="paragraph">这个例子中的第一个转换成功了，而第二个则失败了。差别在于第一个转换传入了基数，明确告诉parseInt()要解析一个十六进制格式的字符串；而第二个转换发现第一个字符不是数字字符，因此就自动终止了。</p><p class="paragraph">指定基数会影响到转换的输出结果。例如：</p><pre><code>var num1 = parseInt("10", 2); //2 （按二进制解析）
var num2 = parseInt("10", 8); //8 （按八进制解析）
var num3 = parseInt("10", 10); //10 （按十进制解析）
var num4 = parseInt("10", 16); //16 （按十六进制解析）</code></pre><p class="paragraph source-file">NumberExample07.htm</p><p class="paragraph">不指定基数意味着让 parseInt()决定如何解析输入的字符串，因此为了避免错误的解析，我们建议无论在什么情况下都明确指定基数。</p><p class="paragraph tips">多数情况下，我们要解析的都是十进制数值，因此始终将 10 作为第二个参数是非常必要的。</p><p class="paragraph">与 parseInt()函数类似，parseFloat()也是从第一个字符（位置 0）开始解析每个字符。而且也是一直解析到字符串末尾，或者解析到遇见一个无效的浮点数字字符为止。也就是说，字符串中的第一个小数点是有效的，而第二个小数点就是无效的了，因此它后面的字符串将被忽略。举例来说，"22.34.5"将会被转换为 22.34。</p><p class="paragraph">除了第一个小数点有效之外，parseFloat()与 parseInt()的第二个区别在于它始终都会忽略前导的零。parseFloat()可以识别前面讨论过的所有浮点数值格式，也包括十进制整数格式。但十六进制格式的字符串则始终会被转换成 0。由于 parseFloat()只解析十进制值，因此它没有用第二个参数指定基数的用法。最后还要注意一点：如果字符串包含的是一个可解析为整数的数（没有小数点，或者小数点后都是零），parseFloat()会返回整数。以下是使用 parseFloat()转换数值的几个典型示例。</p><pre><code>var num1 = parseFloat("1234blue"); //1234 （整数）
var num2 = parseFloat("0xA"); //0
var num3 = parseFloat("22.5"); //22.5
var num4 = parseFloat("22.34.5"); //22.34
var num5 = parseFloat("0908.5"); //908.5
var num6 = parseFloat("3.125e7"); //31250000</code></pre><p class="paragraph source-file">NumberExample08.htm</p></section></div><!-- - var ch_num = "0"--><div id="ch3-4-6"><section><p class="h3">3.4.6 String类型</p><p class="paragraph">String 类型用于表示由零或多个 16 位 Unicode 字符组成的字符序列，即字符串。字符串可以由双引号（"）或单引号（'）表示，因此下面两种字符串的写法都是有效的：</p><pre><code>var firstName = "Nicholas";
var lastName = 'Zakas';</code></pre><p class="paragraph">与 PHP 中的双引号和单引号会影响对字符串的解释方式不同，ECMAScript 中的这两种语法形式没有什么区别。用双引号表示的字符串和用单引号表示的字符串完全相同。不过，以双引号开头的字符串也必须以双引号结尾，而以单引号开头的字符串必须以单引号结尾。例如，下面这种字符串表示法会导致语法错误：</p><pre><code>var firstName = 'Nicholas"; // 语法错误（左右引号必须匹配）</code></pre><p class="paragraph strong">1. 字符字面量</p><p class="paragraph">String 数据类型包含一些特殊的字符字面量，也叫转义序列，用于表示非打印字符，或者具有其他用途的字符。这些字符字面量如下表所示：</p><table><tr><th>字 面 量</th><th>含 义</th></tr><tr><td>\n</td><td>换行</td></tr><tr><td>\t</td><td>制表</td></tr><tr><td>\b</td><td>空格</td></tr><tr><td>\r</td><td>回车</td></tr><tr><td>\f</td><td>进纸</td></tr><tr><td>\\</td><td>斜杠</td></tr><tr><td>\'</td><td>单引号（'），在用单引号表示的字符串中使用。例如：'He said, \'hey.\''</td></tr><tr><td>\"</td><td>双引号（"），在用双引号表示的字符串中使用。例如："He said, \"hey.\""</td></tr><tr><td>\xnn</td><td>以十六进制代码nn表示的一个字符（其中n为0～F）。例如，\x41表示"A"</td></tr><tr><td>\unnnn</td><td>以十六进制代码nnnn表示的一个Unicode字符（其中n为0～F）。例如，\u03a3表示希腊字符Σ</td></tr></table><p class="paragraph">这些字符字面量可以出现在字符串中的任意位置，而且也将被作为一个字符来解析，如下面的例子所示：</p><pre><code>var text = "This is the letter sigma: \u03a3.";</code></pre><p class="paragraph">这个例子中的变量 text 有 28 个字符，其中 6 个字符长的转义序列表示 1 个字符。\</p><p class="paragraph">任何字符串的长度都可以通过访问其 length 属性取得，例如：</p><pre><code>alert(text.length); // 输出 28</code></pre><p class="paragraph">这个属性返回的字符数包括 16 位字符的数目。如果字符串中包含双字节字符，那么 length 属性可能不会精确地返回字符串中的字符数目。</p><p class="paragraph strong">2. 字符串的特点</p><p class="paragraph">ECMAScript 中的字符串是不可变的，也就是说，字符串一旦创建，它们的值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量，例如：</p><pre><code><var>lang = "Java";</var><lang>= lang + "Script";</lang></code></pre><p class="paragraph">以上示例中的变量 lang 开始时包含字符串"Java"。而第二行代码把 lang 的值重新定义为"Java"与"Script"的组合，即"JavaScript"。实现这个操作的过程如下：首先创建一个能容纳 10 个字符的新字符串，然后在这个字符串中填充"Java"和"Script"，最后一步是销毁原来的字符串"Java"和字符串"Script"，因为这两个字符串已经没用了。这个过程是在后台发生的，而这也是在某些旧版本的浏览器（例如版本低于 1.0 的 Firefox、IE6 等）中拼接字符串时速度很慢的原因所在。但这些览器后来的版本已经解决了这个低效率问题。</p><p class="paragraph strong">3. 转换为字符串</p><p class="paragraph">要把一个值转换为一个字符串有两种方式。第一种是使用几乎每个值都有的 toString()方法（第5 章将讨论这个方法的特点）。这个方法唯一要做的就是返回相应值的字符串表现。来看下面的例子：</p><pre><code>var age = 11;
var ageAsString = age.toString(); // 字符串"11"
var found = true;
var foundAsString = found.toString(); // 字符串"true"</code></pre><p class="paragraph source-file">StringExample01.htm</p><p class="paragraph">数值、布尔值、对象和字符串值（没错，每个字符串也都有一个 toString()方法，该方法返回字符串的一个副本）都有 toString()方法。但 null 和 undefined 值没有这个方法。</p><p class="paragraph">多数情况下，调用 toString()方法不必传递参数。但是，在调用数值的 toString()方法时，可以传递一个参数：输出数值的基数。默认情况下，toString()方法以十进制格式返回数值的字符串表示。而通过传递基数，toString()可以输出以二进制、八进制、十六进制，乃至其他任意有效进制格式表示的字符串值。下面给出几个例子：</p><pre><code>var num = 10;
alert(num.toString()); // "10"
alert(num.toString(2)); // "1010"
alert(num.toString(8)); // "12"
alert(num.toString(10)); // "10"
alert(num.toString(16)); // "a"</code></pre><p class="paragraph source-file">StringExample02.htm</p><p class="paragraph">通过这个例子可以看出，通过指定基数，toString()方法会改变输出的值。而数值 10 根据基数的不同，可以在输出时被转换为不同的数值格式。注意，默认的（没有参数的）输出值与指定基数 10 时的输出值相同。</p><p class="paragraph">在不知道要转换的值是不是 null 或 undefined 的情况下，还可以使用转型函数 String()，这个函数能够将任何类型的值转换为字符串。String()函数遵循下列转换规则：</p><ul><li>如果值有 toString()方法，则调用该方法（没有参数）并返回相应的结果；</li><li>如果值是 null，则返回"null"；</li><li>如果值是 undefined，则返回"undefined"。</li></ul><p class="paragraph">下面再看几个例子：</p><pre><code>var value1 = 10;
var value2 = true;
var value3 = null;
var value4;
alert(String(value1)); // "10"
alert(String(value2)); // "true"
alert(String(value3)); // "null"
alert(String(value4)); // "undefined"</code></pre><p class="paragraph source-file">StringExample03.htm</p><p class="paragraph">这里先后转换了 4 个值：数值、布尔值、null 和 undefined。数值和布尔值的转换结果与调用toString()方法得到的结果相同。因为 null 和 undefined 没有 toString()方法，所以 String()函数就返回了这两个值的字面量。</p><p class="paragraph tips">要把某个值转换为字符串，可以使用加号操作符（3.5 节讨论）把它与一个字符串（""）加在一起。</p></section></div><!-- - var ch_num = "0"--><div id="ch3-4-7"><section><p class="h3">3.4.7 Object类型</p><p class="paragraph">ECMAScript 中的对象其实就是一组数据和功能的集合。对象可以通过执行 new 操作符后跟要创建的对象类型的名称来创建。而创建 Object 类型的实例并为其添加属性和（或）方法，就可以创建自定义对象，如下所示：</p><pre><code>var o = new Object();</code></pre><p class="paragraph">这个语法与 Java 中创建对象的语法相似；但在 ECMAScript 中，如果不给构造函数传递参数，则可以省略后面的那一对圆括号。也就是说，在像前面这个示例一样不传递参数的情况下，完全可以省略那对圆括号（但这不是推荐的做法）：</p><pre><code>var o = new Object; // 有效，但不推荐省略圆括号</code></pre><p class="paragraph">仅仅创建 Object 的实例并没有什么用处，但关键是要理解一个重要的思想：即在 ECMAScript 中，（就像 Java 中的 java.lang.Object 对象一样）Object 类型是所有它的实例的基础。换句话说，Object 类型所具有的任何属性和方法也同样存在于更具体的对象中。</p><p class="paragraph">Object 的每个实例都具有下列属性和方法。</p><ul><li>constructor：保存着用于创建当前对象的函数。对于前面的例子而言，构造函数（constructor）就是 Object()。</li><li>hasOwnProperty(propertyName)：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名（propertyName）必须以字符串形式指定（例如：o.hasOwnProperty("name")）。</li><li>isPrototypeOf(object)：用于检查传入的对象是否是传入对象的原型（第 5 章将讨论原型）。</li><li>propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用 for-in 语句（本章后面将会讨论）来枚举。与 hasOwnProperty()方法一样，作为参数的属性名必须以字符串形式指定。</li><li>toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应。</li><li>toString()：返回对象的字符串表示。</li><li>valueOf()：返回对象的字符串、数值或布尔值表示。通常与 toString()方法的返回值相同。</li></ul><p class="paragraph">由于在 ECMAScript 中 Object 是所有对象的基础，因此所有对象都具有这些基本的属性和方法。第 5 章和第 6 章将详细介绍 Object 与其他对象的关系。</p><p class="paragraph tips">从技术角度讲，ECMA-262 中对象的行为不一定适用于 JavaScript 中的其他对象。浏览器环境中的对象，比如 BOM 和 DOM 中的对象，都属于宿主对象，因为它们是由宿主实现提供和定义的。ECMA-262 不负责定义宿主对象，因此宿主对象可能会也可能不会继承 Object。</p></section></div><!-- - var ch_num = "0"--><div id="ch3-5"><section><p class="h2">3.5 操作符</p><p class="paragraph">ECMA-262 描述了一组用于操作数据值的操作符，包括算术操作符（如加号和减号）、位操作符、关系操作符和相等操作符。ECMAScript 操作符的与众不同之处在于，它们能够适用于很多值，例如字符串、数字值、布尔值，甚至对象。不过，在应用于对象时，相应的操作符通常都会调用对象的 valueOf()和（或）toString()方法，以便取得可以操作的值。</p></section></div><!-- - var ch_num = "0"--><div id="ch3-5-1"><section><p class="h3">3.5.1 一元操作符</p><p class="paragraph">只能操作一个值的操作符叫做一元操作符。一元操作符是 ECMAScript 中最简单的操作符。</p><p class="paragraph strong">1. 递增和递减操作符</p><p class="paragraph">递增和递减操作符直接借鉴自 C，而且各有两个版本：前置型和后置型。顾名思义，前置型应该位于要操作的变量之前，而后置型则应该位于要操作的变量之后。因此，在使用前置递增操作符给一个数值加 1 时，要把两个加号（++）放在这个数值变量前面，如下所示：</p><pre><code>var age = 29;
++age;</code></pre><p class="paragraph">在这个例子中，前置递增操作符把 age 的值变成了 30（为 29 加上了 1）。实际上，执行这个前置递增操作与执行以下操作的效果相同：</p><pre><code>var age = 29;
age = age + 1;</code></pre><p class="paragraph">执行前置递减操作的方法也类似，结果会从一个数值中减去 1。使用前置递减操作符时，要把两个减号（--）放在相应变量的前面，如下所示：</p><pre><code>var age = 29;
--age;</code></pre><p class="paragraph">这样，age 变量的值就减少为 28（从 29 中减去了 1）。</p><p class="paragraph">执行前置递增和递减操作时，变量的值都是在语句被求值以前改变的。（在计算机科学领域，这种情况通常被称作副效应。）请看下面这个例子。</p><pre><code>var age = 29;
var anotherAge = --age + 2;
alert(age); // 输出 28
alert(anotherAge); // 输出 30</code></pre><p class="paragraph source-file">IncrementDecrementExample01.htm</p><p class="paragraph">这个例子中变量 anotherAge 的初始值等于变量 age 的值前置递减之后加 2。由于先执行了减法操作，age 的值变成了 28，所以再加上 2 的结果就是 30。</p><p class="paragraph">由于前置递增和递减操作与执行语句的优先级相等，因此整个语句会从左至右被求值。再看一个例子：</p><pre><code>var num1 = 2;
var num2 = 20;
var num3 = --num1 + num2; // 等于 21
var num4 = num1 + num2; // 等于 21</code></pre><p class="paragraph source-file">IncrementDecrementExample02.htm</p><p class="paragraph">在这里，num3 之所以等于 21 是因为 num1 先减去了 1 才与 num2 相加。而变量 num4 也等于 21 是因为相应的加法操作使用了 num1 减去 1 之后的值。</p><p class="paragraph">后置型递增和递减操作符的语法不变（仍然分别是++和--），只不过要放在变量的后面而不是前面。后置递增和递减与前置递增和递减有一个非常重要的区别，即递增和递减操作是在包含它们的语句被求值之后才执行的。这个区别在某些情况下不是什么问题，例如：</p><pre><code>var age = 29;
age++;</code></pre><p class="paragraph">把递增操作符放在变量后面并不会改变语句的结果，因为递增是这条语句的唯一操作。但是，当语句中还包含其他操作时，上述区别就会非常明显了。请看下面的例子：</p><pre><code>var num1 = 2;
var num2 = 20;
var num3 = num1-- + num2; // 等于 22
var num4 = num1 + num2; // 等于 21</code></pre><p class="paragraph source-file">IncrementDecrementExample03.htm</p><p class="paragraph">这里仅仅将前置递减改成了后置递减，就立即可以看到差别。在前面使用前置递减的例子中，num3和 num4 最后都等于 21。而在这个例子中，num3 等于 22，num4 等于 21。差别的根源在于，这里在计算 num3 时使用了 num1 的原始值（2）完成了加法计算，而 num4 则使用了递减后的值（1）。</p><p class="paragraph">所有这 4 个操作符对任何值都适用，也就是它们不仅适用于整数，还可以用于字符串、布尔值、浮点数值和对象。在应用于不同的值时，递增和递减操作符遵循下列规则。</p><ul><li>在应用于一个包含有效数字字符的字符串时，先将其转换为数字值，再执行加减 1 的操作。字符串变量变成数值变量。</li><li>在应用于一个不包含有效数字字符的字符串时，将变量的值设置为 NaN（第 4 章将详细讨论）。字符串变量变成数值变量。</li><li>在应用于布尔值 false 时，先将其转换为 0 再执行加减 1 的操作。布尔值变量变成数值变量。</li><li>在应用于布尔值 true 时，先将其转换为 1 再执行加减 1 的操作。布尔值变量变成数值变量。</li><li>在应用于浮点数值时，执行加减 1 的操作。</li><li>在应用于对象时，先调用对象的 valueOf()方法（第 5 章将详细讨论）以取得一个可供操作的值。然后对该值应用前述规则。如果结果是 NaN，则在调用 toString()方法后再应用前述规则。对象变量变成数值变量。</li></ul><p class="paragraph">以下示例展示了上面的一些规则：</p><pre><code>var s1 = "2";
var s2 = "z";
var b = false;
var f = 1.1;
var o = {
     valueOf: function() {
        return -1;
     }
};
s1++; // 值变成数值 3
s2++; // 值变成 NaN
b++; // 值变成数值 1
f--; // 值变成 0.10000000000000009（由于浮点舍入错误所致）
o--; // 值变成数值-2</code></pre><p class="paragraph source-file">IncrementDecrementExample04.htm</p><p class="paragraph">2. 一元加和减操作符</p><p class="paragraph">绝大多数开发人员对一元加和减操作符都不会陌生，而且这两个 ECMAScript 操作符的作用与数学书上讲的完全一样。一元加操作符以一个加号（+）表示，放在数值前面，对数值不会产生任何影响，如下面的例子所示：</p><pre><code>var num = 25;
num = +num; // 仍然是 25</code></pre><p class="paragraph">不过，在对非数值应用一元加操作符时，该操作符会像 Number()转型函数一样对这个值执行转换。换句话说，布尔值 false 和 true 将被转换为 0 和 1，字符串值会被按照一组特殊的规则进行解析，而对象是先调用它们的 valueOf()和（或）toString()方法，再转换得到的值。</p><p class="paragraph">下面的例子展示了对不同数据类型应用一元加操作符的结果：</p><pre><code>var s1 = "01";
var s2 = "1.1";
var s3 = "z";
var b = false;
var f = 1.1;
var o = {
     valueOf: function() {
        return -1;
     }
};
s1 = +s1; // 值变成数值 1
s2 = +s2; // 值变成数值 1.1
s3 = +s3; // 值变成 NaN
b = +b; // 值变成数值 0
f = +f; // 值未变，仍然是 1.1
o = +o; // 值变成数值-1</code></pre><p class="paragraph source-file">UnaryPlusMinusExample01.htm</p><p class="paragraph">一元减操作符主要用于表示负数，例如将 1 转换成-1。下面的例子演示了这个简单的转换过程：</p><pre><code>var num = 25;
num = -num; // 变成了-25</code></pre><p class="paragraph">在将一元减操作符应用于数值时，该值会变成负数（如上面的例子所示）。而当应用于非数值时，一元减操作符遵循与一元加操作符相同的规则，最后再将得到的数值转换为负数，如下面的例子所示：</p><pre><code>var s1 = "01";
var s2 = "1.1";
var s3 = "z";
var b = false;
var f = 1.1;
var o = {
     valueOf: function() {
        return -1;
     }
};
s1 = -s1; // 值变成了数值-1
s2 = -s2; // 值变成了数值-1.1
s3 = -s3; // 值变成了 NaN
b = -b; // 值变成了数值 0
f = -f; // 变成了-1.1
o = -o; // 值变成了数值 1
</code></pre><p class="paragraph source-file">UnaryPlusMinusExample02.htm</p><p class="paragraph">一元加和减操作符主要用于基本的算术运算，也可以像前面示例所展示的一样用于转换数据类型。</p></section></div><!-- - var ch_num = "0"--><div id="ch3-5-2"><section><p class="h3">3.5.2 位操作符</p><p class="paragraph">位操作符用于在最基本的层次上，即按内存中表示数值的位来操作数值。ECMAScript 中的所有数值都以 IEEE-754 64 位格式存储，但位操作符并不直接操作 64 位的值。而是先将 64 位的值转换成 32 位的整数，然后执行操作，最后再将结果转换回 64 位。对于开发人员来说，由于 64 位存储格式是透明的，因此整个过程就像是只存在 32 位的整数一样。</p><p class="paragraph">对于有符号的整数，32 位中的前 31 位用于表示整数的值。第 32 位用于表示数值的符号：0 表示正数，1 表示负数。这个表示符号的位叫做<strong>符号位</strong>，符号位的值决定了其他位数值的格式。其中，正数以纯二进制格式存储，31 位中的每一位都表示 2 的幂。第一位（叫做位 0）表示 2<sup>0</sup>，第二位表示 2<sup>1</sup>，以此类推。没有用到的位以 0 填充，即忽略不计。例如，数值 18 的二进制表示是00000000000000000000000000010010，或者更简洁的 10010。这是 5 个有效位，这 5 位本身就决定了实际的值（如图 3-1 所示）。<div class="images"><img src="static/images/ch3/3-1.png" alt="图 3-1"><div class="img-tips">图 3-1</div></div></p><p class="paragraph">负数同样以二进制码存储，但使用的格式是二进制补码。计算一个数值的二进制补码，需要经过下列 3 个步骤：<p class="paragraph">(1) 求这个数值绝对值的二进制码（例如，要求-18 的二进制补码，先求 18 的二进制码）；</p><p class="paragraph">(2) 求二进制反码，即将 0 替换为 1，将 1 替换为 0；</p><p class="paragraph">(3) 得到的二进制反码加 1。</p></p><p class="paragraph">要根据这 3 个步骤求得-18 的二进制码，首先就要求得 18 的二进制码，即：<p class="paragraph">0000 0000 0000 0000 0000 0000 0001 0010</p><p class="paragraph">然后，求其二进制反码，即 0 和 1 互换：</p><p class="paragraph">1111 1111 1111 1111 1111 1111 1110 1101</p><p class="paragraph">最后，二进制反码加 1：</p><p class="paragraph">1111 1111 1111 1111 1111 1111 1110 1101</p><p class="paragraph">1</p><p class="paragraph">---------------------------------------</p><p class="paragraph">1111 1111 1111 1111 1111 1111 1110 1110</p></p><p class="paragraph">这样，就求得了-18 的二进制表示，即 11111111111111111111111111101110。要注意的是，在处理有符号整数时，是不能访问位 31 的。</p><p class="paragraph">ECMAScript 会尽力向我们隐藏所有这些信息。换句话说，在以二进制字符串形式输出一个负数时，我们看到的只是这个负数绝对值的二进制码前面加上了一个负号。如下面的例子所示：</p><pre><code>var num = -18;
alert(num.toString(2)); // "-10010"</code></pre><p class="paragraph">要把数值-18 转换成二进制字符串时，得到的结果是"-10010"。这说明转换过程理解了二进制补码并将其以更合乎逻辑的形式展示了出来。</p><p class="paragraph tips">默认情况下，ECMAScript 中的所有整数都是有符号整数。不过，当然也存在无符号整数。对于无符号整数来说，第 32 位不再表示符号，因为无符号整数只能是正数。而且，无符号整数的值可以更大，因为多出的一位不再表示符号，可以用来表示数值。</p><p class="paragraph">在 ECMAScript 中，当对数值应用位操作符时，后台会发生如下转换过程：64 位的数值被转换成 32位数值，然后执行位操作，最后再将 32 位的结果转换回 64 位数值。这样，表面上看起来就好像是在操作 32 位数值，就跟在其他语言中以类似方式执行二进制操作一样。但这个转换过程也导致了一个严重的副效应，即在对特殊的 NaN 和 Infinity 值应用位操作时，这两个值都会被当成 0 来处理。</p><p class="paragraph">如果对非数值应用位操作符，会先使用 Number()函数将该值转换为一个数值（自动完成），然后再应用位操作。得到的结果将是一个数值。</p><p class="paragraph strong">1. 按位非（NOT）</p><p class="paragraph">按位非操作符由一个波浪线（~）表示，执行按位非的结果就是返回数值的反码。按位非是ECMAScript 操作符中少数几个与二进制计算有关的操作符之一。下面看一个例子：</p><pre><code>var num1 = 25; // 二进制 00000000000000000000000000011001
var num2 = ~num1; // 二进制 11111111111111111111111111100110
alert(num2); // -26</code></pre><p class="paragraph source-file">BitwiseNotExample01.htm</p><p class="paragraph">这里，对 25 执行按位非操作，结果得到了-26。这也验证了按位非操作的本质：操作数的负值减 1。因此，下面的代码也能得到相同的结果：</p><pre><code>var num1 = 25;
var num2 = -num1 - 1;
alert(num2); // "-26"</code></pre><p class="paragraph">虽然以上代码也能返回同样的结果，但由于按位非是在数值表示的最底层执行操作，因此速度更快。</p><p class="paragraph strong">2. 按位与（AND）</p><p class="paragraph">按位与操作符由一个和号字符（&）表示，它有两个操作符数。从本质上讲，按位与操作就是将两个数值的每一位对齐，然后根据下表中的规则，对相同位置上的两个数执行 AND 操作：</p><table><tr><th>第一个数值的位</th><th>第二个数值的位</th><th>结 果</th></tr><tr><td>1</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td></tr><tr><td>0</td><td>0</td><td>0</td></tr></table><p class="paragraph">简而言之，按位与操作只在两个数值的对应位都是 1 时才返回 1，任何一位是 0，结果都是 0。下面看一个对 25 和 3 执行按位与操作的例子：</p><pre><code>var result = 25 & 3;
alert(result); //1</code></pre><p class="paragraph source-file">BitwiseAndExample01.htm</p><p class="paragraph">可见，对 25 和 3 执行按位与操作的结果是 1。为什么呢？请看其底层操作：</p><pre><code>25 = 0000 0000 0000 0000 0000 0000 0001 1001
3 = 0000 0000 0000 0000 0000 0000 0000 0011
---------------------------------------------
AND = 0000 0000 0000 0000 0000 0000 0000 0001</code></pre><p class="paragraph">原来，25 和 3 的二进制码对应位上只有一位同时是 1，而其他位的结果自然都是 0，因此最终结果等于 1。</p><p class="paragraph strong">3. 按位或（OR）</p><p class="paragraph">按位或操作符由一个竖线符号（|）表示，同样也有两个操作数。按位或操作遵循下面这个真值表。</p><table><tr><th>第一个数值的位</th><th>第二个数值的位</th><th>结 果</th></tr><tr><td>1</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>0</td><td>0</td><td>0</td></tr></table><p class="paragraph">由此可见，按位或操作在有一个位是 1 的情况下就返回 1，而只有在两个位都是 0 的情况下才返回 0。如果在前面按位与的例子中对 25 和 3 执行按位或操作，则代码如下所示：</p><pre><code>var result = 25 | 3;
alert(result); //27</code></pre><p class="paragraph source-file">BitwiseOrExample01.htm</p><p class="paragraph">25 与 3 按位或的结果是 27：</p><pre><code>25 = 0000 0000 0000 0000 0000 0000 0001 1001
3 = 0000 0000 0000 0000 0000 0000 0000 0011
--------------------------------------------
OR = 0000 0000 0000 0000 0000 0000 0001 1011</code></pre><p class="paragraph">这两个数值的都包含 4 个 1，因此可以把每个 1 直接放到结果中。二进制码 11011 等于十进制值 27。</p><p class="paragraph strong">4. 按位异或（XOR）</p><p class="paragraph">按位异或操作符由一个插入符号（^）表示，也有两个操作数。以下是按位异或的真值表。</p><table><tr><th>第一个数值的位</th><th>第二个数值的位</th><th>结 果</th></tr><tr><td>1</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>0</td><td>0</td><td>0</td></tr></table><p class="paragraph">按位异或与按位或的不同之处在于，这个操作在两个数值对应位上只有一个 1 时才返回 1，如果对应的两位都是 1 或都是 0，则返回 0。</p><p class="paragraph">对 25 和 3 执行按位异或操作的代码如下所示：</p><pre><code>var result = 25 ^ 3;
alert(result); //26</code></pre><p class="paragraph source-file">BitwiseXorExample01.htm</p><p class="paragraph">25 与 3 按位异或的结果是 26，其底层操作如下所示：</p><pre><code>25 = 0000 0000 0000 0000 0000 0000 0001 1001
3 = 0000 0000 0000 0000 0000 0000 0000 0011
 ---------------------------------------------
 XOR = 0000 0000 0000 0000 0000 0000 0001 1010</code></pre><p class="paragraph">这两个数值都包含 4 个 1，但第一位上则都是 1，因此结果的第一位变成了 0。而其他位上的 1 在另一个数值中都没有对应的 1，可以直接放到结果中。二进制码 11010 等于十进制值 26（注意这个结果比执行按位或时小 1）。</p><p class="paragraph strong">5. 左移</p><p class="paragraph">左移操作符由两个小于号（<<）表示，这个操作符会将数值的所有位向左移动指定的位数。例如，如果将数值 2（二进制码为 10）向左移动 5 位，结果就是 64（二进制码为 1000000），代码如下所示：</p><pre><code>var oldValue = 2; // 等于二进制的 10
var newValue = oldValue << 5; // 等于二进制的 1000000，十进制的 64</code></pre><p class="paragraph source-file">LeftShiftExample01.htm</p><p class="paragraph">注意，在向左移位后，原数值的右侧多出了 5 个空位。左移操作会以 0 来填充这些空位，以便得到的结果是一个完整的 32 位二进制数（见图 3-2）。<div class="images"><img src="static/images/ch3/3-2.png" alt="图3-2.png"><div class="img-tips">图3-2.png</div></div></p><p class="paragraph">注意，左移不会影响操作数的符号位。换句话说，如果将-2 向左移动 5 位，结果将是-64，而非 64。</p><p class="paragraph strong">6. 有符号的右移</p><p class="paragraph">有符号的右移操作符由两个大于号（>>）表示，这个操作符会将数值向右移动，但保留符号位（即正负号标记）。有符号的右移操作与左移操作恰好相反，即如果将 64 向右移动 5 位，结果将变回 2：</p><pre><code>var oldValue = 64; // 等于二进制的 1000000
var newValue = oldValue >> 5; // 等于二进制的 10 ，即十进制的 2</code></pre><p class="paragraph source-file">SignedRightShiftExample01.htm</p><p class="paragraph">同样，在移位过程中，原数值中也会出现空位。只不过这次的空位出现在原数值的左侧、符号位的右侧（见图 3-3）。而此时 ECMAScript 会用符号位的值来填充所有空位，以便得到一个完整的值。<div class="images"><img src="static/images/ch3/3-3.png" alt="图3-3.png"><div class="img-tips">图  3-3.png</div></div></p><p class="paragraph strong">7. 无符号右移</p><p class="paragraph">无符号右移操作符由 3 个大于号（>>>）表示，这个操作符会将数值的所有 32 位都向右移动。对正数来说，无符号右移的结果与有符号右移相同。仍以前面有符号右移的代码为例，如果将 64 无符号右移 5 位，结果仍然还是 2：</p><pre><code>var oldValue = 64; // 等于二进制的 1000000
var newValue = oldValue >>> 5; // 等于二进制的 10 ，即十进制的 2</code></pre><p class="paragraph source-file">UnsignedRightShiftExample01.htm</p><p class="paragraph">但是对负数来说，情况就不一样了。首先，无符号右移是以 0 来填充空位，而不是像有符号右移那样以符号位的值来填充空位。所以，对正数的无符号右移与有符号右移结果相同，但对负数的结果就不一样了。其次，无符号右移操作符会把负数的二进制码当成正数的二进制码。而且，由于负数以其绝对值的二进制补码形式表示，因此就会导致无符号右移后的结果非常之大，如下面的例子所示：</p><pre><code>var oldValue = -64; // 等于二进制的 11111111111111111111111111000000
var newValue = oldValue >>> 5; // 等于十进制的 134217726</code></pre><p class="paragraph source-file">UnsignedRightShiftExample02.htm</p><p class="paragraph">这里，当对-64 执行无符号右移 5 位的操作后，得到的结果是 134217726。之所以结果如此之大，是因为-64 的二进制码为 11111111111111111111111111000000，而且无符号右移操作会把这个二进制码当成正数的二进制码，换算成十进制就是 4294967232。如果把这个值右移 5 位，结果就变成了00000111111111111111111111111110，即十进制的 134217726。</p></section></div><!-- - var ch_num = "0"--><div id="ch3-5-3"><section><p class="h3">3.5.3 布尔操作符</p><p class="paragraph">在一门编程语言中，布尔操作符的重要性堪比相等操作符。如果没有测试两个值关系的能力，那么诸如 if...else 和循环之类的语句就不会有用武之地了。布尔操作符一共有 3 个：非（NOT）、与（AND）和或（OR）。</p><p class="paragraph strong">1. 逻辑非</p><p class="paragraph">逻辑非操作符由一个叹号（！）表示，可以应用于 ECMAScript 中的任何值。无论这个值是什么数据类型，这个操作符都会返回一个布尔值。逻辑非操作符首先会将它的操作数转换为一个布尔值，然后再对其求反。也就是说，逻辑非操作符遵循下列规则：</p><ul><li>如果操作数是一个对象，返回 false；</li><li>如果操作数是一个空字符串，返回 true；</li><li>如果操作数是一个非空字符串，返回 false；</li><li>如果操作数是数值 0，返回 true；</li><li>如果操作数是任意非 0 数值（包括 Infinity），返回 false；</li><li>如果操作数是 null，返回 true；</li><li>如果操作数是 NaN，返回 true；</li><li>如果操作数是 undefined，返回 true。</li></ul><p class="paragraph">下面几个例子展示了应用上述规则的结果：</p><pre><code>alert(!false); // true
alert(!"blue"); // false
alert(!0); // true
alert(!NaN); // true
alert(!""); // true
alert(!12345); // false</code></pre><p class="paragraph source-file">LogicalNotExample01.htm</p><p class="paragraph">逻辑非操作符也可以用于将一个值转换为与其对应的布尔值。而同时使用两个逻辑非操作符，实际上就会模拟 Boolean()转型函数的行为。其中，第一个逻辑非操作会基于无论什么操作数返回一个布尔值，而第二个逻辑非操作则对该布尔值求反，于是就得到了这个值真正对应的布尔值。当然，最终结果与对这个值使用 Boolean()函数相同，如下面的例子所示：</p><pre><code>alert(!!"blue"); //true
alert(!!0); //false
alert(!!NaN); //false
alert(!!""); //false
alert(!!12345); //true</code></pre><p class="paragraph source-file">LogicalNotExample02.htm</p><p class="paragraph strong">2. 逻辑与</p><p class="paragraph">逻辑与操作符由两个和号（&&）表示，有两个操作数，如下面的例子所示：</p><pre><code>var result = true && false;</code></pre><p class="paragraph">逻辑与的真值表如下：</p><table><tr><th>第一个操作数</th><th>第二个操作数</th><th>结 果</th></tr><tr><td>true</td><td>true</td><td>true</td></tr><tr><td>true</td><td>false</td><td>false</td></tr><tr><td>false</td><td>true</td><td>false</td></tr><tr><td>false</td><td>false</td><td>false</td></tr></table><p class="paragraph">逻辑与操作可以应用于任何类型的操作数，而不仅仅是布尔值。在有一个操作数不是布尔值的情况下，逻辑与操作就不一定返回布尔值；此时，它遵循下列规则：</p><ul><li>如果第一个操作数是对象，则返回第二个操作数；</li><li>如果第二个操作数是对象，则只有在第一个操作数的求值结果为 true 的情况下才会返回该对象；</li><li>如果两个操作数都是对象，则返回第二个操作数；</li><li>如果有一个操作数是 null，则返回 null；</li><li>如果有一个操作数是 NaN，则返回 NaN；</li><li>如果有一个操作数是 undefined，则返回 undefined。</li></ul><p class="paragraph">逻辑与操作属于短路操作，即如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值。对于逻辑与操作而言，如果第一个操作数是 false，则无论第二个操作数是什么值，结果都不再可能是true 了。来看下面的例子：</p><pre><code>var found = true;
var result = (found && someUndefinedVariable); // 这里会发生错误
alert(result); // 这一行不会执行</code></pre><p class="paragraph source-file">LogicalAndExample01.htm</p><p class="paragraph">在上面的代码中，当执行逻辑与操作时会发生错误，因为变量 someUndefinedVariable 没有声明。由于变量 found 的值是 true，所以逻辑与操作符会继续对变量 someUndefinedVariable 求值。但 someUndefinedVariable 尚未定义，因此就会导致错误。这说明不能在逻辑与操作中使用未定义的值。如果像下面这个例中一样，将 found 的值设置为 false，就不会发生错误了：</p><pre><code>var found = false;
var result = (found && someUndefinedVariable); // 不会发生错误
alert(result); // 会执行（"false"）</code></pre><p class="paragraph source-file">LogicalAndExample02.htm</p><p class="paragraph">在这个例子中，警告框会显示出来。无论变量 someUndefinedVariable 有没有定义，也永远不会对它求值，因为第一个操作数的值是 false。而这也就意味着逻辑与操作的结果必定是 false，根本用不着再对&&右侧的操作数求值了。在使用逻辑与操作符时要始终铭记它是一个短路操作符。</p><p class="paragraph strong">3. 逻辑或</p><p class="paragraph">逻辑或操作符由两个竖线符号（||）表示，有两个操作数，如下面的例子所示：</p><pre><code>var result = true || false;</code></pre><p class="paragraph">逻辑或的真值表如下：</p><table><tr><th>第一个操作数</th><th>第二个操作数</th><th>结 果</th></tr><tr><td>True</td><td>true</td><td>true</td></tr><tr><td>True</td><td>false</td><td>true</td></tr><tr><td>false</td><td>true</td><td>true</td></tr><tr><td>false</td><td>false</td><td>false</td></tr></table><p class="paragraph">与逻辑与操作相似，如果有一个操作数不是布尔值，逻辑或也不一定返回布尔值；此时，它遵循下列规则：</p><ul><li>如果第一个操作数是对象，则返回第一个操作数；</li><li>如果第一个操作数的求值结果为 false，则返回第二个操作数；</li><li>如果两个操作数都是对象，则返回第一个操作数；</li><li>如果两个操作数都是 null，则返回 null；</li><li>如果两个操作数都是 NaN，则返回 NaN；</li><li>如果两个操作数都是 undefined，则返回 undefined。</li></ul><p class="paragraph">与逻辑与操作符相似，逻辑或操作符也是短路操作符。也就是说，如果第一个操作数的求值结果为true，就不会对第二个操作数求值了。下面看一个例子：</p><pre><code>var found = true;
var result = (found || someUndefinedVariable); // 不会发生错误
alert(result); // 会执行（"true"）</code></pre><p class="paragraph source-file">LogicalOrExample01.htm</p><p class="paragraph">这个例子跟前面的例子一样，变量 someUndefinedVariable 也没有定义。但是，由于变量 found的值是 true，而变量 someUndefinedVariable 永远不会被求值，因此结果就会输出"true"。如果像下面这个例子一样，把 found 的值改为 false，就会导致错误：</p><pre><code>var found = false;
var result = (found || someUndefinedVariable); // 这里会发生错误
alert(result); // 这一行不会执行</code></pre><p class="paragraph source-file">LogicalOrExample02.htm</p><p class="paragraph">我们可以利用逻辑或的这一行为来避免为变量赋 null 或 undefined 值。例如：</p><pre><code>var myObject = preferredObject || backupObject;</code></pre><p class="paragraph">在这个例子中，变量 myObject 将被赋予等号后面两个值中的一个。变量 preferredObject 中包含优先赋给变量 myObject 的值，变量 backupObject 负责在 preferredObject 中不包含有效值的情况下提供后备值。如果 preferredObject 的值不是 null，那么它的值将被赋给 myObject；如果是 null，则将 backupObject 的值赋给 myObject。ECMAScript 程序的赋值语句经常会使用这种模式，本书也将采用这种模式。</p></section></div><!-- - var ch_num = "0"--><div id="ch3-5-4"><section><p class="h3">3.5.4 乘性操作符</p><p class="paragraph">ECMAScript 定义了 3 个乘性操作符：乘法、除法和求模。这些操作符与 Java、C 或者 Perl 中的相应操作符用途类似，只不过在操作数为非数值的情况下会执行自动的类型转换。如果参与乘性计算的某个操作数不是数值，后台会先使用 Number()转型函数将其转换为数值。也就是说，空字符串将被当作0，布尔值 true 将被当作 1。</p><p class="paragraph strong">1. 乘法</p><p class="paragraph"> 乘法操作符由一个星号（*）表示，用于计算两个数值的乘积。其语法类似于 C，如下面的例子所示：</p><pre><code>var result = 34 * 56;</code></pre><p class="paragraph">在处理特殊值的情况下，乘法操作符遵循下列特殊的规则：</p><ul><li>如果操作数都是数值，执行常规的乘法计算，即两个正数或两个负数相乘的结果还是正数，而如果只有一个操作数有符号，那么结果就是负数。如果乘积超过了 ECMAScript 数值的表示范围，则返回 Infinity 或-Infinity；</li><li>如果有一个操作数是 NaN，则结果是 NaN；</li><li>如果是 Infinity 与 0 相乘，则结果是 NaN；</li><li>如果是 Infinity 与非 0 数值相乘，则结果是 Infinity 或-Infinity，取决于有符号操作数的符号；</li><li>如果是 Infinity 与 Infinity 相乘，则结果是 Infinity；</li><li>如果有一个操作数不是数值，则在后台调用 Number()将其转换为数值，然后再应用上面的规则。</li></ul><p class="paragraph strong">2. 除法</p><p class="paragraph">除法操作符由一个斜线符号（/）表示，执行第二个操作数除第一个操作数的计算，如下面的例子所示：</p><pre><code>var result = 66 / 11;</code></pre><p class="paragraph">与乘法操作符类似，除法操作符对特殊的值也有特殊的处理规则。这些规则如下：</p><ul><li>如果操作数都是数值，执行常规的除法计算，即两个正数或两个负数相除的结果还是正数，而如果只有一个操作数有符号，那么结果就是负数。如果商超过了 ECMAScript 数值的表示范围，则返回 Infinity 或-Infinity；</li><li>如果有一个操作数是 NaN，则结果是 NaN；</li><li>如果是 Infinity 被 Infinity 除，则结果是 NaN；</li><li>如果是零被零除，则结果是 NaN；</li><li>如果是非零的有限数被零除，则结果是 Infinity 或-Infinity，取决于有符号操作数的符号；</li><li>如果是 Infinity 被任何非零数值除，则结果是 Infinity 或-Infinity，取决于有符号操作数的符号；</li><li>如果有一个操作数不是数值，则在后台调用 Number()将其转换为数值，然后再应用上面的规则。</li></ul><p class="paragraph strong">3. 求模</p><p class="paragraph">求模（余数）操作符由一个百分号（%）表示，用法如下：</p><pre><code>var result = 26 % 5; // 等于 1</code></pre><p class="paragraph">与另外两个乘性操作符类似，求模操作符会遵循下列特殊规则来处理特殊的值：</p><ul><li>如果操作数都是数值，执行常规的除法计算，返回除得的余数；</li><li>如果被除数是无穷大值而除数是有限大的数值，则结果是 NaN；</li><li>如果被除数是有限大的数值而除数是零，则结果是 NaN；</li><li>如果是 Infinity 被 Infinity 除，则结果是 NaN；</li><li>如果被除数是有限大的数值而除数是无穷大的数值，则结果是被除数；</li><li>如果被除数是零，则结果是零；</li><li>如果有一个操作数不是数值，则在后台调用 Number()将其转换为数值，然后再应用上面的规则。</li></ul></section></div><!-- - var ch_num = "0"--><div id="ch3-5-5"><section><p class="h3">3.5.5 加性操作符</p><p class="paragraph">加法和减法这两个加性操作符应该说是编程语言中最简单的算术操作符了。但是在 ECMAScript 中，这两个操作符却都有一系列的特殊行为。与乘性操作符类似，加性操作符也会在后台转换不同的数据类型。然而，对于加性操作符而言，相应的转换规则还稍微有点复杂。</p><p class="paragraph strong">1. 加法</p><p class="paragraph">加法操作符（+）的用法如下所示：</p><pre><code>var result = 1 + 2;</code></pre><p class="paragraph">如果两个操作符都是数值，执行常规的加法计算，然后根据下列规则返回结果：</p><ul><li>如果有一个操作数是 NaN，则结果是 NaN；</li><li>如果是 Infinity 加 Infinity，则结果是 Infinity；</li><li>如果是-Infinity 加-Infinity，则结果是-Infinity；</li><li>如果是 Infinity 加-Infinity，则结果是 NaN；</li><li>如果是+0 加+0，则结果是+0；</li><li>如果是-0 加-0，则结果是-0；</li><li>如果是+0 加-0，则结果是+0。</li></ul><p class="paragraph">不过，如果有一个操作数是字符串，那么就要应用如下规则：</p><ul><li>如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来；</li><li>如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来。</li></ul><p class="paragraph">如果有一个操作数是对象、数值或布尔值，则调用它们的 toString()方法取得相应的字符串值，然后再应用前面关于字符串的规则。对于 undefined 和 null，则分别调用 String()函数并取得字符串"undefined"和"null"。</p><p class="paragraph">下面来举几个例子：</p><pre><code>var result1 = 5 + 5; // 两个数值相加
alert(result1); // 10
var result2 = 5 + "5"; // 一个数值和一个字符串相加
alert(result2); // "55"</code></pre><p class="paragraph source-file">AddExample01.htm</p><p class="paragraph">以上代码演示了加法操作符在两种模式下的差别。第一行代码演示了正常的情况，即 5+5 等于 10（数值）。但是，如果将一个操作数改为字符串"5"，结果就变成了"55"（字符串值），因为第一个操作数也被转换成了"5"。</p><p class="paragraph">忽视加法操作中的数据类型是 ECMAScript 编程中最常见的一个错误。再来看一个例子：</p><pre><code>var num1 = 5;
var num2 = 10;
var message = "The sum of 5 and 10 is " + num1 + num2;
alert(message); // "The sum of 5 and 10 is 510"</code></pre><p class="paragraph source-file">AddExample02.htm</p><p class="paragraph">在这个例子中，变量 message 的值是执行两个加法操作之后的结果。有人可能以为最后得到的字符串是"The sum of 5 and 10 is 15"，但实际的结果却是"The sum of 5 and 10 is 510"。之所以会这样，是因为每个加法操作是独立执行的。第一个加法操作将一个字符串和一个数值（5）拼接了起来，结果是一个字符串。而第二个加法操作又用这个字符串去加另一个数值（10），当然也会得到一个字符串。如果想先对数值执行算术计算，然后再将结果与字符串拼接起来，应该像下面这样使用圆括号：</p><pre><code>var num1 = 5;
var num2 = 10;
var message = "The sum of 5 and 10 is " + (num1 + num2);
alert(message); //"The sum of 5 and 10 is 15"</code></pre><p class="paragraph source-file">AddExample03.htm</p><p class="paragraph">在这个例子中，一对圆括号把两个数值变量括在了一起，这样就会告诉解析器先计算其结果，然后再将结果与字符串拼接起来。因此，就得到了结果"The sum of 5 and 10 is 15"。</p><p class="paragraph strong">2. 减法</p><p class="paragraph">减法操作符（-）是另一个极为常用的操作符，其用法如下所示：</p><pre><code>var result = 2 - 1;</code></pre><p class="paragraph">与加法操作符类似，ECMAScript 中的减法操作符在处理各种数据类型转换时，同样需要遵循一些特殊规则，如下所示：</p><ul><li>如果两个操作符都是数值，则执行常规的算术减法操作并返回结果；</li><li>如果有一个操作数是 NaN，则结果是 NaN；</li><li>如果是 Infinity 减 Infinity，则结果是 NaN；</li><li>如果是-Infinity 减-Infinity，则结果是 NaN；</li><li>如果是 Infinity 减-Infinity，则结果是 Infinity；</li><li>如果是-Infinity 减 Infinity，则结果是-Infinity；</li><li>如果是+0 减+0，则结果是+0；</li><li>如果是+0 减-0，则结果是-0；</li><li>如果是-0 减-0，则结果是+0；</li><li>如果有一个操作数是字符串、布尔值、null 或 undefined，则先在后台调用 Number()函数将其转换为数值，然后再根据前面的规则执行减法计算。如果转换的结果是 NaN，则减法的结果就是 NaN；</li><li>如果有一个操作数是对象，则调用对象的 valueOf()方法以取得表示该对象的数值。如果得到的值是 NaN，则减法的结果就是 NaN。如果对象没有 valueOf()方法，则调用其 toString()方法并将得到的字符串转换为数值。</li></ul><p class="paragraph">下面几个例子展示了上面的规则：</p><pre><code>var result1 = 5 - true; // 4，因为 true 被转换成了 1
var result2 = NaN - 1; // NaN
var result3 = 5 - 3; // 2
var result4 = 5 - ""; // 5，因为"" 被转换成了 0
var result5 = 5 - "2"; // 3，因为"2"被转换成了 2
var result6 = 5 - null; // 5，因为 null 被转换成了 0</code></pre><p class="paragraph source-file">SubtractExample01.htm</p></section></div><!-- - var ch_num = "0"--><div id="ch3-5-6"><section><p class="h3">3.5.6 关系操作符</p><p class="paragraph">小于（<）、大于（>）、小于等于（<=）和大于等于（>=）这几个关系操作符用于对两个值进行比较，比较的规则与我们在数学课上所学的一样。这几个操作符都返回一个布尔值，如下面的例子所示：</p><pre><code>var result1 = 5 > 3; //true
var result2 = 5 < 3; //false</code></pre><p class="paragraph source-file">RelationalOperatorsExample01.htm 中包含本节所有的代码片段</p><p class="paragraph">与 ECMAScript 中的其他操作符一样，当关系操作符的操作数使用了非数值时，也要进行数据转换或完成某些奇怪的操作。以下就是相应的规则。</p><ul><li>如果两个操作数都是数值，则执行数值比较。</li><li>如果两个操作数都是字符串，则比较两个字符串对应的字符编码值。</li><li>如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较。</li><li>如果一个操作数是对象，则调用这个对象的 valueOf()方法，用得到的结果按照前面的规则执行比较。如果对象没有 valueOf()方法，则调用 toString()方法，并用得到的结果根据前面的规则执行比较。</li><li>如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较。</li></ul><p class="paragraph">在使用关系操作符比较两个字符串时，会执行一种奇怪的操作。很多人都会认为，在比较字符串值时，小于的意思是“在字母表中的位置靠前”，而大于则意味着“在字母表中的位置靠后”，但实际上完全不是那么回事。在比较字符串时，实际比较的是两个字符串中对应位置的每个字符的字符编码值。经过这么一番比较之后，再返回一个布尔值。由于大写字母的字符编码全部小于小写字母的字符编码，因此我们就会看到如下所示的奇怪现象：</p><pre><code>var result = "Brick" < "alphabet"; //true</code></pre><p class="paragraph">在这个例子中，字符串"Brick"被认为小于字符串"alphabet"。原因是字母 B 的字符编码为 66，而字母 a 的字符编码是 97。如果要真正按字母表顺序比较字符串，就必须把两个操作数转换为相同的大小写形式（全部大写或全部小写），然后再执行比较，如下所示：</p><pre><code>var result = "Brick".toLowerCase() < "alphabet".toLowerCase(); //false</code></pre><p class="paragraph">通过将两个操作数都转换为小写形式，就可以得出"alphabet"按字母表顺序排在"Brick"之前的正确判断了。</p><p class="paragraph">另一种奇怪的现象发生在比较两个数字字符串的情况下，比如下面这个例子：</p><pre><code>var result = "23" < "3"; //true</code></pre><p class="paragraph">确实，当比较字符串"23"是否小于"3"时，结果居然是 true。这是因为两个操作数都是字符串，而字符串比较的是字符编码（"2"的字符编码是 50，而"3"的字符编码是 51）。不过，如果像下面例子中一样，将一个操作数改为数值，比较的结果就正常了：</p><pre><code>var result = "23" < 3; //false</code></pre><p class="paragraph">此时，字符串"23"会被转换成数值 23，然后再与 3 进行比较，因此就会得到合理的结果。在比较数值和字符串时，字符串都会被转换成数值，然后再以数值方式与另一个数值比较。当然，这个规则对前面的例子是适用的。可是，如果那个字符串不能被转换成一个合理的数值呢？比如：</p><pre><code>var result = "a" < 3; // false，因为"a"被转换成了 NaN</code></pre><p class="paragraph">由于字母"a"不能转换成合理的数值，因此就被转换成了 NaN。根据规则，任何操作数与 NaN 进行关系比较，结果都是 false。于是，就出现了下面这个有意思的现象：</p><pre><code>var result1 = NaN < 3; //false
var result2 = NaN >= 3; //false</code></pre><p class="paragraph">按照常理，如果一个值不小于另一个值，则一定是大于或等于那个值。然而，在与 NaN 进行比较时，这两个比较操作的结果都返回了 false。</p></section></div><!-- - var ch_num = "0"--><div id="ch3-5-7"><section><p class="h3">3.5.7 相等操作符</p><p class="paragraph">确定两个变量是否相等是编程中的一个非常重要的操作。在比较字符串、数值和布尔值的相等性时，问题还比较简单。但在涉及到对象的比较时，问题就变得复杂了。最早的 ECMAScript 中的相等和不等操作符会在执行比较之前，先将对象转换成相似的类型。后来，有人提出了这种转换到底是否合理的质疑。最后，ECMAScript 的解决方案就是提供两组操作符：相等和不相等——先转换再比较，全等和不全等——仅比较而不转换。</p><p class="paragraph strong">1. 相等和不相等</p><p class="paragraph">ECMAScript 中的相等操作符由两个等于号（==）表示，如果两个操作数相等，则返回 true。而不相等操作符由叹号后跟等于号（!=）表示，如果两个操作数不相等，则返回 true。这两个操作符都会先转换操作数（通常称为强制转型），然后再比较它们的相等性。</p><p class="paragraph">在转换不同的数据类型时，相等和不相等操作符遵循下列基本规则：</p><ul><li>如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false 转换为 0，而true 转换为 1；</li><li>如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值；</li><li>如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf()方法，用得到的基本类型值按照前面的规则进行比较；这两个操作符在进行比较时则要遵循下列规则。</li><li>null 和 undefined 是相等的。</li><li>要比较相等性之前，不能将 null 和 undefined 转换成其他任何值。</li><li>如果有一个操作数是 NaN，则相等操作符返回 false，而不相等操作符返回 true。重要提示：即使两个操作数都是 NaN，相等操作符也返回 false；因为按照规则，NaN 不等于 NaN。</li><li>如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true；否则，返回 false。</li></ul><p class="paragraph">下表列出了一些特殊情况及比较结果：</p><table><tr><th>表 达 式</th><th>值</th><th>表 达 式</th><th>值</th></tr><tr><td>null == undefined</td><td>true</td><td>true == 1</td><td>true</td></tr><tr><td>"NaN" == NaN</td><td>false</td><td>true == 2</td><td>false</td></tr><tr><td>5 == NaN</td><td>false</td><td>undefined == 0</td><td>false</td></tr><tr><td>NaN == NaN</td><td>false</td><td>null == 0</td><td>false</td></tr><tr><td>NaN != NaN</td><td>true</td><td>"5"==5</td><td>true</td></tr><tr><td>false == 0</td><td>true</td></tr></table><p class="paragraph">2. 全等和不全等</p><p class="paragraph">除了在比较之前不转换操作数之外，全等和不全等操作符与相等和不相等操作符没有什么区别。全等操作符由 3 个等于号（===）表示，它只在两个操作数未经转换就相等的情况下返回 true，如下面的例子所示：</p><pre><code>var result1 = ("55" == 55); //true，因为转换后相等
var result2 = ("55" === 55); //false，因为不同的数据类型不相等</code></pre><p class="paragraph source-file">EqualityOperatorsExample02.htm</p><p class="paragraph">在这个例子中，第一个比较使用的是相等操作符比较字符串"55"和数值 55，结果返回了 true。如前所述，这是因为字符串"55"先被转换成了数值 55，然后再与另一个数值 55 进行比较。第二个比较使用了全等操作符以不转换数值的方式比较同样的字符串和值。在不转换的情况下，字符串当然不等于数值，因此结果就是 false。</p><p class="paragraph">不全等操作符由一个叹号后跟两个等于号（!==）表示，它在两个操作数未经转换就不相等的情况下返回 true。例如：</p><pre><code>var result1 = ("55" != 55); //false，因为转换后相等
var result2 = ("55" !== 55); //true，因为不同的数据类型不相等</code></pre><p class="paragraph source-file">EqualityOperatorsExample03.htm</p><p class="paragraph">在这个例子中，第一个比较使用了不相等操作符，而该操作符会将字符串"55"转换成 55，结果就与第二个操作数（也是 55）相等了。而由于这两个操作数被认为相等，因此就返回了 false。第二个比较使用了不全等操作符。假如我们这样想：字符串 55 与数值 55 不相同吗？，那么答案一定是：是的（true）。</p><p class="paragraph">记住：null == undefined 会返回 true，因为它们是类似的值；但 null === undefined 会返回 false，因为它们是不同类型的值。</p><p class="paragraph tips">由于相等和不相等操作符存在类型转换问题，而为了保持代码中数据类型的完整性，我们推荐使用全等和不全等操作符。</p></section></div><!-- - var ch_num = "0"--><div id="ch3-5-8"><section><p class="h3">3.5.8 条件操作符</p><p class="paragraph">条件操作符应该算是 ECMAScript 中最灵活的一种操作符了，而且它遵循与 Java 中的条件操作符相同的语法形式，如下面的例子所示：</p><pre><code>variable = boolean_expression ? true_value : false_value;</code></pre><p class="paragraph">本质上，这行代码的含义就是基于对 boolean_expression 求值的结果，决定给变量 variable赋什么值。如果求值结果为 true，则给变量 variable 赋 true_value 值；如果求值结果为 false，则给变量 variable 赋 false_value 值。再看一个例子：</p><pre><code>var max = (num1 > num2) ? num1 : num2;</code></pre><p class="paragraph">在这个例子中，max 中将会保存一个最大的值。这个表达式的意思是：如果 num1 大于 num2（关系表达式返回 true），则将 num1 的值赋给 max；如果 num1 小于或等于 num2（关系表达式返回 false），则将 num2 的值赋给 max。</p></section></div><!-- - var ch_num = "0"--><div id="ch3-5-9"><section><p class="h3">3.5.9 赋值操作符</p><p class="paragraph">简单的赋值操作符由等于号（=）表示，其作用就是把右侧的值赋给左侧的变量，如下面的例子所示：</p><pre><code>var num = 10;</code></pre><p class="paragraph">如果在等于号（=）前面再添加乘性操作符、加性操作符或位操作符，就可以完成复合赋值操作。这种复合赋值操作相当于是对下面常规表达式的简写形式：</p><pre><code>var num = 10;
num = num + 10;</code></pre><p class="paragraph">其中的第二行代码可以用一个复合赋值来代替：</p><pre><code>var num = 10;
num += 10;</code></pre><p class="paragraph">每个主要算术操作符（以及个别的其他操作符）都有对应的复合赋值操作符。这些操作符如下所示：</p><ul><li>乘/赋值（*=）；</li><li>除/赋值（/=）；</li><li>模/赋值（%=）；</li><li>加/赋值（+=）；</li><li>减/赋值（-=）；</li><li>左移/赋值（<<=）；</li><li>有符号右移/赋值（>>=）；</li><li>无符号右移/赋值（>>>=）。</li></ul><p class="paragraph">设计这些操作符的主要目的就是简化赋值操作。使用它们不会带来任何性能的提升。</p></section></div><!-- - var ch_num = "0"--><div id="ch3-5-10"><section><p class="h3">3.5.10 逗号操作符</p><p class="paragraph">使用逗号操作符可以在一条语句中执行多个操作，如下面的例子所示：</p><pre><code>var num1=1, num2=2, num3=3;</code></pre><p class="paragraph">逗号操作符多用于声明多个变量；但除此之外，逗号操作符还可以用于赋值。在用于赋值时，逗号操作符总会返回表达式中的最后一项，如下面的例子所示：</p><pre><code>var num = (5, 1, 4, 8, 0); // num 的值为 0</code></pre><p class="paragraph">由于 0 是表达式中的最后一项，因此 num 的值就是 0。虽然逗号的这种使用方式并不常见，但这个例子可以帮我们理解逗号的这种行为。</p></section></div><!-- - var ch_num = "0"--><div id="ch3-6"><section><p class="h2">3.6 语句</p><p class="paragraph">ECMA-262 规定了一组语句（也称为流控制语句）。从本质上看，语句定义了 ECMAScript 中的主要语法，语句通常使用一或多个关键字来完成给定任务。语句可以很简单，例如通知函数退出；也可以比较复杂，例如指定重复执行某个命令的次数。</p></section></div><!-- - var ch_num = "0"--><div id="ch3-6-1"><section><p class="h3">3.6.1 if语句</p><p class="paragraph">大多数编程语言中最为常用的一个语句就是 if 语句。以下是 if 语句的语法：</p><pre><code>if (condition) statement1 else statement2</code></pre><p class="paragraph">其中的 condition（条件）可以是任意表达式；而且对这个表达式求值的结果不一定是布尔值。ECMAScript 会自动调用 Boolean()转换函数将这个表达式的结果转换为一个布尔值。如果对 condition求值的结果是 true，则执行 statement1（语句 1），如果对 condition求值的结果是 false，则执行 statement2（语句 2）。而且这两个语句既可以是一行代码，也可以是一个代码块（以一对花括号括起来的多行代码）。请看下面的例子。</p><pre><code>if (i > 25)
    alert("Greater than 25."); // 单行语句
else {
    alert("Less than or equal to 25."); // 代码块中的语句
}</code></pre><p class="paragraph source-file">IfStatementExample01.htm</p><p class="paragraph">不过，业界普遍推崇的最佳实践是始终使用代码块，即使要执行的只有一行代码。因为这样可以消除人们的误解，否则可能让人分不清在不同条件下要执行哪些语句。另外，也可以像下面这样把整个 if 语句写在一行代码中：</p><pre><code>if (condition1) statement1 else if (condition2) statement2 else statement3</code></pre><p class="paragraph">但我们推荐的做法则是像下面这样：</p><pre><code>if (i > 25) {
    alert("Greater than 25.");
} else if (i < 0) {
    alert("Less than 0.");
} else {
    alert("Between 0 and 25, inclusive.");
}</code></pre><p class="paragraph source-file">IfStatementExample02.htm</p></section></div><!-- - var ch_num = "0"--><div id="ch3-6-2"><section><p class="h3">3.6.2 do-while语句</p><p class="paragraph">do-while 语句是一种后测试循环语句，即只有在循环体中的代码执行之后，才会测试出口条件。换句话说，在对条件表达式求值之前，循环体内的代码至少会被执行一次。以下是 do-while 语句的语法：</p><pre><code>do {
    statement
} while (expression);
下面是一个示例：
var i = 0;
do {
    i += 2;
} while (i < 10);
alert(i);</code></pre><p class="paragraph source-file">DoWhileStatementExample01.htm</p><p class="paragraph">在这个例子中，只要变量 i 的值小于 10，循环就会一直继续下去。而且变量 i 的值最初为 0，每次循环都会递增 2。</p><p class="paragraph tips">像 do-while 这种后测试循环语句最常用于循环体中的代码至少要被执行一次的情形。</p></section></div><!-- - var ch_num = "0"--><div id="ch3-6-3"><section><p class="h3">3.6.3 while语句</p><p class="paragraph">while 语句属于前测试循环语句，也就是说，在循环体内的代码被执行之前，就会对出口条件求值。此，循环体内的代码有可能永远不会被执行。以下是 while 语句的语法：</p><pre><code>while(expression) statement</code></pre><p class="paragraph">下面是一个示例：</p><pre><code>var i = 0;
while (i < 10) {
    i += 2;
}</code></pre><p class="paragraph source-file">WhileStatementExample01.htm</p><p class="paragraph">在这个例子中，变量 i 开始时的值为 0，每次循环都会递增 2。而只要 i 的值小于 10，循环就会继续下去。</p></section></div><!-- - var ch_num = "0"--><div id="ch3-6-4"><section><p class="h3">3.6.4 for语句</p><p class="paragraph">for 语句也是一种前测试循环语句，但它具有在执行循环之前初始化变量和定义循环后要执行的代码的能力。以下是 for 语句的语法：</p><pre><code>for (initialization; expression; post-loop-expression) statement</code></pre><p class="paragraph">下面是一个示例：</p><pre><code>var count = 10;
for (var i = 0; i < count; i++){
    alert(i);
}</code></pre><p class="paragraph source-file">ForStatementExample01.htm</p><p class="paragraph">以上代码定义了变量 i 的初始值为 0。只有当条件表达式（i<count）返回 true 的情况下才会进入 for 循环，因此也有可能不会执行循环体中的代码。如果执行了循环体中的代码，则一定会对循环后的表达式（i++）求值，即递增 i 的值。这个 for 循环语句与下面的 while 语句的功能相同：</p><pre><code>var count = 10;
var i = 0;
while (i < count){
    alert(i);
    i++;
}</code></pre><p class="paragraph">使用 while 循环做不到的，使用 for 循环同样也做不到。也就是说，for 循环只是把与循环有关的代码集中在了一个位置。</p><p class="paragraph">有必要指出的是，在 for 循环的变量初始化表达式中，也可以不使用 var 关键字。该变量的初始化可以在外部执行，例如：</p><pre><code>var count = 10;
var i;
for (i = 0; i < count; i++){
    alert(i);
}</code></pre><p class="paragraph source-file">ForStatementExample02.htm</p><p class="paragraph">以上代码与在循环初始化表达式中声明变量的效果是一样的。由于 ECMAScript 中不存在块级作用域（第 4 章将进一步讨论这一点），因此在循环内部定义的变量也可以在外部访问到。例如：</p><pre><code>var count = 10;
for (var i = 0; i < count; i++){
    alert(i);
}
alert(i); //10</code></pre><p class="paragraph source-file">ForStatementExample03.htm</p><p class="paragraph">在这个例子中，会有一个警告框显示循环完成后变量 i 的值，这个值是 10。这是因为，即使 i 是在循环内部定义的一个变量，但在循环外部仍然可以访问到它。</p><p class="paragraph">此外，for 语句中的初始化表达式、控制表达式和循环后表达式都是可选的。将这三个表达式全部省略，就会创建一个无限循环，例如：</p><pre><code>for (;;) { // 无限循环
    doSomething();
}</code></pre><p class="paragraph">而只给出控制表达式实际上就把 for 循环转换成了 while 循环，例如：</p><pre><code>var count = 10;
var i = 0;
for (; i < count; ){
     alert(i);
     i++;
}</code></pre><p class="paragraph source-file">ForStatementExample04.htm</p><p class="paragraph">由于 for 语句存在极大的灵活性，因此它也是 ECMAScript 中最常用的一个语句。</p></section></div><!-- - var ch_num = "0"--><div id="ch3-6-5"><section><p class="h3">3.6.5 for-in语句</p><p class="paragraph">for-in 语句是一种精准的迭代语句，可以用来枚举对象的属性。以下是 for-in 语句的语法：</p><pre><code>for (property in expression) statement</code></pre><p class="paragraph">下面是一个示例：</p><pre><code>for (var propName in window) {
    document.write(propName);
}</code></pre><p class="paragraph source-file">ForInStatementExample01.htm</p><p class="paragraph">在这个例子中，我们使用 for-in 循环来显示了 BOM 中 window 对象的所有属性。每次执行循环时，都会将 window 对象中存在的一个属性名赋值给变量 propName。这个过程会一直持续到对象中的所有属性都被枚举一遍为止。与 for 语句类似，这里控制语句中的 var 操作符也不是必需的。但是，为了保证使用局部变量，我们推荐上面例子中的这种做法。</p><p class="paragraph">ECMAScript 对象的属性没有顺序。因此，通过 for-in 循环输出的属性名的顺序是不可预测的。具体来讲，所有属性都会被返回一次，但返回的先后次序可能会因浏览器而异。</p><p class="paragraph">但是，如果表示要迭代的对象的变量值为 null 或 undefined，for-in 语句会抛出错误。ECMAScript 5 更正了这一行为；对这种情况不再抛出错误，而只是不执行循环体。为了保证最大限度的兼容性，建议在使用 for-in 循环之前，先检测确认该对象的值不是 null 或 undefined。</p><p class="paragraph tips">Safari 3 以前版本的 for-in 语句中存在一个 bug，该 bug 会导致某些属性被返回两次。</p></section></div><!-- - var ch_num = "0"--><div id="ch3-6-6"><section><p class="h3">3.6.6 label语句</p><p class="paragraph">使用 label 语句可以在代码中添加标签，以便将来使用。以下是 label 语句的语法：</p><pre><code>label: statement</code></pre><p class="paragraph">下面是一个示例：</p><pre><code>start: for (var i=0; i < count; i++) {
    alert(i);
}</code></pre><p class="paragraph">这个例子中定义的 start 标签可以在将来由 break 或 continue 语句引用。加标签的语句一般都要与 for 语句等循环语句配合使用。</p></section></div><!-- - var ch_num = "0"--><div id="ch3-6-7"><section><p class="h3">3.6.7 break和continue语句</p><p class="paragraph">break 和 continue 语句用于在循环中精确地控制代码的执行。其中，break 语句会立即退出循环，强制继续执行循环后面的语句。而 continue 语句虽然也是立即退出循环，但退出循环后会从循环的顶部继续执行。请看下面的例子：</p><pre><code>var num = 0;
for (var i=1; i < 10; i++) {
     if (i % 5 == 0) {
        break;
     }
     num++;
}
alert(num); //4</code></pre><p class="paragraph source-file">BreakStatementExample01.htm</p><p class="paragraph">这个例子中的 for 循环会将变量 i 由 1 递增至 10。在循环体内，有一个 if 语句检查 i 的值是否可以被 5 整除（使用求模操作符）。如果是，则执行 break 语句退出循环。另一方面，变量 num 从 0 开始，用于记录循环执行的次数。在执行 break 语句之后，要执行的下一行代码是 alert()函数，结果显示 4。也就是说，在变量 i 等于 5 时，循环总共执行了 4 次；而 break 语句的执行，导致了循环在num 再次递增之前就退出了。如果在这里把 break 替换为 continue 的话，则可以看到另一种结果：</p><pre><code>var num = 0;
for (var i=1; i < 10; i++) {
     if (i % 5 == 0) {
        continue;
     }
     num++;
}
alert(num); //8</code></pre><p class="paragraph source-file">ContinueStatementExample01.htm</p><p class="paragraph">例子的结果显示 8，也就是循环总共执行了 8 次。当变量 i 等于 5 时，循环会在 num 再次递增之前退出，但接下来执行的是下一次循环，即 i 的值等于 6 的循环。于是，循环又继续执行，直到 i 等于10 时自然结束。而 num 的最终值之所以是 8，是因为 continue 语句导致它少递增了一次。</p><p class="paragraph">break 和 continue 语句都可以与 label 语句联合使用，从而返回代码中特定的位置。这种联合使用的情况多发生在循环嵌套的情况下，如下面的例子所示：</p><pre><code>var num = 0;
outermost:
for (var i=0; i < 10; i++) {
    for (var j=0; j < 10; j++) {
        if (i == 5 && j == 5) {
            break outermost;
        }
        num++;
    }
}
alert(num); //55</code></pre><p class="paragraph source-file">BreakStatementExample02.htm</p><p class="paragraph">在这个例子中，outermost 标签表示外部的 for 语句。如果每个循环正常执行 10 次，则 num++语句就会正常执行 100 次。换句话说，如果两个循环都自然结束，num 的值应该是 100。但内部循环中的 break 语句带了一个参数：要返回到的标签。添加这个标签的结果将导致 break 语句不仅会退出内部的 for 语句（即使用变量 j 的循环），而且也会退出外部的 for 语句（即使用变量 i 的循环）。为此，当变量 i 和 j 都等于 5 时，num 的值正好是 55。同样，continue 语句也可以像这样与 label 语句联用，如下面的例子所示：</p><pre><code>var num = 0;
outermost:
for (var i=0; i < 10; i++) {
    for (var j=0; j < 10; j++) {
        if (i == 5 && j == 5) {
            continue outermost;
        }
        num++;
    }
}
alert(num); //95</code></pre><p class="paragraph source-file">ContinueStatementExample02.htm</p><p class="paragraph">在这种情况下，continue 语句会强制继续执行循环——退出内部循环，执行外部循环。当 j 是 5时，continue 语句执行，而这也就意味着内部循环少执行了 5 次，因此 num 的结果是 95。</p><p class="paragraph">虽然联用 break、continue 和 label 语句能够执行复杂的操作，但如果使用过度，也会给调试带来麻烦。在此，我们建议如果使用 label 语句，一定要使用描述性的标签，同时不要嵌套过多的循环。</p></section></div><!-- - var ch_num = "0"--><div id="ch3-6-8"><section><p class="h3">3.6.8 with语句</p><p class="paragraph">with 语句的作用是将代码的作用域设置到一个特定的对象中。with 语句的语法如下：</p><pre><code>with (expression) statement;</code></pre><p class="paragraph">定义 with 语句的目的主要是为了简化多次编写同一个对象的工作，如下面的例子所示：</p><pre><code>var qs = location.search.substring(1);
var hostName = location.hostname;
var url = location.href;</code></pre><p class="paragraph">上面几行代码都包含 location 对象。如果使用 with 语句，可以把上面的代码改写成如下所示：</p><pre><code>with(location){
     var qs = search.substring(1);
     var hostName = hostname;
     var url = href;
}</code></pre><p class="paragraph source-file">WithStatementExample01.htm</p><p class="paragraph">在这个重写后的例子中，使用 with 语句关联了 location 对象。这意味着在 with 语句的代码块内部，每个变量首先被认为是一个局部变量，而如果在局部环境中找不到该变量的定义，就会查询location 对象中是否有同名的属性。如果发现了同名属性，则以 location 对象属性的值作为变量的值。</p><p class="paragraph">严格模式下不允许使用 with 语句，否则将视为语法错误。</p><p class="paragraph important">由于大量使用 with 语句会导致性能下降，同时也会给调试代码造成困难，因此在开发大型应用程序时，不建议使用 with 语句。</p></section></div><!-- - var ch_num = "0"--><div id="ch3-6-9"><section><p class="h3">3.6.9 switch语句</p><p class="paragraph">switch 语句与 if 语句的关系最为密切，而且也是在其他语言中普遍使用的一种流控制语句。ECMAScript 中 switch 语句的语法与其他基于 C 的语言非常接近，如下所示：</p><pre><code>switch (expression) {
 case value: statement
    break;
 case value: statement
    break;
 case value: statement
    break;
 case value: statement
    break;
default: statement
}</code></pre><p class="paragraph">switch 语句中的每一种情形（case）的含义是：“如果表达式等于这个值（value），则执行后面的语句（statement）”。而 break 关键字会导致代码执行流跳出 switch 语句。如果省略 break 关键字，就会导致执行完当前 case 后，继续执行下一个 case。最后的 default 关键字则用于在表达式不匹配前面任何一种情形的时候，执行机动代码（因此，也相当于一个 else 语句）。</p><p class="paragraph">从根本上讲，switch 语句就是为了让开发人员免于编写像下面这样的代码：</p><pre><code>if (i == 25){
    alert("25");
} else if (i == 35) {
    alert("35");
} else if (i == 45) {
     alert("45");
} else {
    alert("Other");
}</code></pre><p class="paragraph">而与此等价的 switch 语句如下所示：</p><pre><code>switch (i) {
 case 25:
     alert("25");
     break;
 case 35:
     alert("35");
     break;
 case 45:
     alert("45");
     break;
 default:
    alert("Other");
}</code></pre><p class="paragraph source-file">SwitchStatementExample01.htm</p><p class="paragraph">通过为每个 case 后面都添加一个 break 语句，就可以避免同时执行多个 case 代码的情况。假如确实需要混合几种情形，不要忘了在代码中添加注释，说明你是有意省略了 break 关键字，如下所示：</p><pre><code>switch (i) {
 case 25:
    /* 合并两种情形 */
 case 35:
    alert("25 or 35");
    break;
 case 45:
    alert("45");
    break;
 default:
    alert("Other");
}</code></pre><p class="paragraph source-file">SwitchStatementExample02.htm</p><p class="paragraph">虽然 ECMAScript 中的 switch 语句借鉴自其他语言，但这个语句也有自己的特色。首先，可以在switch 语句中使用任何数据类型（在很多其他语言中只能使用数值），无论是字符串，还是对象都没有问题。其次，每个 case 的值不一定是常量，可以是变量，甚至是表达式。请看下面这个例子：</p><pre><code>switch ("hello world") {
     case "hello" + " world":
         alert("Greeting was found.");
         break;
     case "goodbye":
         alert("Closing was found.");
         break;
     default:
        alert("Unexpected message was found.");
}</code></pre><p class="paragraph source-file">SwitchStatementExample03.htm</p><p class="paragraph">在这个例子中，switch 语句使用的就是字符串。其中，第一种情形实际上是一个对字符串拼接操作求值的表达式。由于这个字符串拼接表达式的结果与 switch 的参数相等，因此结果就会显示"Greeting was found."。而且，使用表达式作为 case 值还可以实现下列操作：</p><pre><code>var num = 25;
switch (true) {
     case num < 0:
         alert("Less than 0.");
         break;
     case num >= 0 && num <= 10:
         alert("Between 0 and 10.");
         break;
     case num > 10 && num <= 20:
         alert("Between 10 and 20.");
         break;
     default:
        alert("More than 20.");
}</code></pre><p class="paragraph source-file">SwitchStatementExample04.htm</p><p class="paragraph">这个例子首先在 switch 语句外面声明了变量 num。而之所以给 switch 语句传递表达式 true，是因为每个 case 值都可以返回一个布尔值。这样，每个 case 按照顺序被求值，直到找到匹配的值或者遇到 default 语句为止（这正是这个例子的最终结果）。</p><p class="paragraph tips">switch 语句在比较值时使用的是全等操作符，因此不会发生类型转换（例如，字符串"10"不等于数值 10）。</p></section></div><!-- - var ch_num = "0"--><div id="ch3-7"><section><p class="h2">3.7 函数</p><p class="paragraph">函数对任何语言来说都是一个核心的概念。通过函数可以封装任意多条语句，而且可以在任何地方、任何时候调用执行。ECMAScript 中的函数使用 function 关键字来声明，后跟一组参数以及函数体。函数的基本语法如下所示：</p><pre><code>function functionName(arg0, arg1,...,argN) {
    statements
}</code></pre><p class="paragraph">以下是一个函数示例：</p><pre><code>function sayHi(name, message) {
    alert("Hello " + name + "," + message);
}</code></pre><p class="paragraph source-file">FunctionExample01.htm</p><p class="paragraph">这个函数可以通过其函数名来调用，后面还要加上一对圆括号和参数（圆括号中的参数如果有多个，可以用逗号隔开）。调用 sayHi()函数的代码如下所示：</p><pre><code>sayHi("Nicholas", "how are you today?");</code></pre><p class="paragraph">这个函数的输出结果是"Hello Nicholas,how are you today?"。函数中定义中的命名参数 name和 message 被用作了字符串拼接的两个操作数，而结果最终通过警告框显示了出来。</p><p class="paragraph">ECMAScript 中的函数在定义时不必指定是否返回值。实际上，任何函数在任何时候都可以通过return 语句后跟要返回的值来实现返回值。请看下面的例子：</p><pre><code>function sum(num1, num2) {
    return num1 + num2;
}</code></pre><p class="paragraph source-file">FunctionExample02.htm</p><p class="paragraph">这个 sum()函数的作用是把两个值加起来返回一个结果。我们注意到，除了 return 语句之外，没有任何声明表示该函数会返回一个值。调用这个函数的示例代码如下：</p><pre><code>var result = sum(5, 10);</code></pre><p class="paragraph">这个函数会在执行完 return 语句之后停止并立即退出。因此，位于 return 语句之后的任何代码都永远不会执行。例如：</p><pre><code>function sum(num1, num2) {
    return num1 + num2;
    alert("Hello world"); // 永远不会执行
}</code></pre><p class="paragraph">在这个例子中，由于调用 alert()函数的语句位于 return 语句之后，因此永远不会显示警告框。当然，一个函数中也可以包含多个 return 语句，如下面这个例子中所示：</p><pre><code>function diff(num1, num2) {
    if (num1 < num2) {
        return num2 - num1;
    } else {
        return num1 - num2;
    }
}</code></pre><p class="paragraph source-file">FunctionExample03.htm</p><p class="paragraph">这个例子中定义的 diff()函数用于计算两个数值的差。如果第一个数比第二个小，则用第二个数减第一个数；否则，用第一个数减第二个数。代码中的两个分支都具有自己的 return 语句，分别用于执行正确的计算。</p><p class="paragraph">另外，return 语句也可以不带有任何返回值。在这种情况下，函数在停止执行后将返回 undefined值。这种用法一般用在需要提前停止函数执行而又不需要返回值的情况下。比如在下面这个例子中，就不会显示警告框：</p><pre><code>function sayHi(name, message) {
    return;
    alert("Hello " + name + "," + message); //永远不会调用
}</code></pre><p class="paragraph source-file">FunctionExample04.htm</p><p class="paragraph tips">推荐的做法是要么让函数始终都返回一个值，要么永远都不要返回值。否则，如果函数有时候返回值，有时候有不返回值，会给调试代码带来不便。</p><p class="paragraph">严格模式对函数有一些限制：</p><ul><li>不能把函数命名为 eval 或 arguments；</li><li>不能把参数命名为 eval 或 arguments；</li><li>不能出现两个命名参数同名的情况。</li></ul><p class="paragraph">如果发生以上情况，就会导致语法错误，代码无法执行。</p></section></div><!-- - var ch_num = "0"--><div id="ch3-7-1"><section><p class="h3">3.7.1 理解参数</p><p class="paragraph">ECMAScript 函数的参数与大多数其他语言中函数的参数有所不同。ECMAScript 函数不介意传递进来多少个参数，也不在乎传进来参数是什么数据类型。也就是说，即便你定义的函数只接收两个参数，在调用这个函数时也未必一定要传递两个参数。可以传递一个、三个甚至不传递参数，而解析器永远不会有什么怨言。之所以会这样，原因是 ECMAScript 中的参数在内部是用一个数组来表示的。函数接收到的始终都是这个数组，而不关心数组中包含哪些参数（如果有参数的话）。如果这个数组中不包含任何元素，无所谓；如果包含多个元素，也没有问题。实际上，在函数体内可以通过 arguments 对象来访问这个参数数组，从而获取传递给函数的每一个参数。</p><p class="paragraph">其实，arguments 对象只是与数组类似（它并不是 Array 的实例），因为可以使用方括号语法访问它的每一个元素（即第一个元素是 arguments[0]，第二个元素是 argumetns[1]，以此类推），使用 length 属性来确定传递进来多少个参数。在前面的例子中，sayHi()函数的第一个参数的名字叫name，而该参数的值也可以通过访问 arguments[0]来获取。因此，那个函数也可以像下面这样重写，即不显式地使用命名参数：</p><pre><code>function sayHi() {
    alert("Hello " + arguments[0] + "," + arguments[1]);
}</code></pre><p class="paragraph source-file">FunctionExample05.htm</p><p class="paragraph">这个重写后的函数中不包含命名的参数。虽然没有使用 name 和 message 标识符，但函数的功能依旧。这个事实说明了 ECMAScript 函数的一个重要特点：命名的参数只提供便利，但不是必需的。另外，在命名参数方面，其他语言可能需要事先创建一个函数签名，而将来的调用必须与该签名一致。但在 ECMAScript 中，没有这些条条框框，解析器不会验证命名参数。</p><p class="paragraph">通过访问 arguments 对象的 length 属性可以获知有多少个参数传递给了函数。下面这个函数会在每次被调用时，输出传入其中的参数个数：</p><pre><code>function howManyArgs() {
    alert(arguments.length);
}
howManyArgs("string", 45); //2
howManyArgs(); //0
howManyArgs(12); //1</code></pre><p class="paragraph source-file">FunctionExample06.htm</p><p class="paragraph">执行以上代码会依次出现 3 个警告框，分别显示 2、0 和 1。由此可见，开发人员可以利用这一点让函数能够接收任意个参数并分别实现适当的功能。请看下面的例子：</p><pre><code>function doAdd() {
     if(arguments.length == 1) {
        alert(arguments[0] + 10);
     } else if (arguments.length == 2) {
        alert(arguments[0] + arguments[1]);
     }
}
doAdd(10); //20
doAdd(30, 20); //50</code></pre><p class="paragraph source-file">FunctionExample07.htm</p><p class="paragraph">函数 doAdd()会在只有一个参数的情况下给该参数加上 10；如果是两个参数，则将那个参数简单相加并返回结果。因此，doAdd(10)会返回 20，而 doAdd(30,20)则返回 50。虽然这个特性算不上完美的重载，但也足够弥补 ECMAScript 的这一缺憾了。</p><p class="paragraph">另一个与参数相关的重要方面，就是 arguments 对象可以与命名参数一起使用，如下面的例子所示：</p><pre><code>function doAdd(num1, num2) {
     if(arguments.length == 1) {
        alert(num1 + 10);
     } else if (arguments.length == 2) {
        alert(arguments[0] + num2);
     }
}</code></pre><p class="paragraph source-file">FunctionExample08.htm</p><p class="paragraph">在重写后的这个 doAdd()函数中，两个命名参数都与 arguments 对象一起使用。由于 num1 的值与 arguments[0]的值相同，因此它们可以互换使用（当然，num2 和 arguments[1]也是如此）。</p><p class="paragraph">关于 arguments 的行为，还有一点比较有意思。那就是它的值永远与对应命名参数的值保持同步。例如：</p><pre><code>function doAdd(num1, num2) {
    arguments[1] = 10;
    alert(arguments[0] + num2);
}</code></pre><p class="paragraph source-file">FunctionExample09.htm</p><p class="paragraph">每次执行这个 doAdd()函数都会重写第二个参数，将第二个参数的值修改为 10。因为 arguments对象中的值会自动反映到对应的命名参数，所以修改 arguments[1]，也就修改了 num2，结果它们的值都会变成 10。不过，这并不是说读取这两个值会访问相同的内存空间；它们的内存空间是独立的，但它们的值会同步。另外还要记住，如果只传入了一个参数，那么为 arguments[1]设置的值不会反应到命名参数中。这是因为 arguments 对象的长度是由传入的参数个数决定的，不是由定义函数时的命名参数的个数决定的。</p><p class="paragraph">关于参数还要记住最后一点：没有传递值的命名参数将自动被赋予 undefined 值。这就跟定义了变量但又没有初始化一样。例如，如果只给 doAdd()函数传递了一个参数，则 num2 中就会保存undefined 值。</p><p class="paragraph">严格模式对如何使用 arguments 对象做出了一些限制。首先，像前面例子中那样的赋值会变得无效。也就是说，即使把 arguments[1]设置为 10，num2 的值仍然还是 undefined。其次，重写arguments 的值会导致语法错误（代码将不会执行）。</p><p class="paragraph tips">ECMAScript 中的所有参数传递的都是值，不可能通过引用传递参数。</p></section></div><!-- - var ch_num = "0"--><div id="ch3-7-2"><section><p class="h3">3.7.2 没有重载</p><p class="paragraph">ECMAScript 函数不能像传统意义上那样实现重载。而在其他语言（如 Java）中，可以为一个函数编写两个定义，只要这两个定义的签名（接受的参数的类型和数量）不同即可。如前所述，ECMAScirpt函数没有签名，因为其参数是由包含零或多个值的数组来表示的。而没有函数签名，真正的重载是不可能做到的。</p><p class="paragraph">如果在 ECMAScript 中定义了两个名字相同的函数，则该名字只属于后定义的函数。请看下面的例子：</p><pre><code>function addSomeNumber(num){
    return num + 100;
}
function addSomeNumber(num) {
    return num + 200;
}
var result = addSomeNumber(100); //300</code></pre><p class="paragraph source-file">FunctionExample10.htm</p><p class="paragraph">在此，函数 addSomeNumber()被定义了两次。第一个版本给参数加 100，而第二个版本给参数加200。由于后定义的函数覆盖了先定义的函数，因此当在最后一行代码中调用这个函数时，返回的结果就是 300。</p><p class="paragraph">如前所述，通过检查传入函数中参数的类型和数量并作出不同的反应，可以模仿方法的重载。</p></section></div><!-- - var ch_num = "0"--><div id="ch3-8"><section><p class="h2">3.8 小结</p><p class="paragraph">JavaScript 的核心语言特性在 ECMA-262 中是以名为 ECMAScript 的伪语言的形式来定义的。ECMAScript 中包含了所有基本的语法、操作符、数据类型以及完成基本的计算任务所必需的对象，但没有对取得输入和产生输出的机制作出规定。理解 ECMAScript 及其纷繁复杂的各种细节，是理解其在Web 浏览器中的实现——JavaScript 的关键。目前大多数实现所遵循的都是 ECMA-262 第 3 版，但很多也已经着手开始实现第 5 版了。以下简要总结了 ECMAScript 中基本的要素。</p><ul><li>ECMAScript 中的基本数据类型包括 Undefined、Null、Boolean、Number 和 String。</li><li>与其他语言不同，ECMScript 没有为整数和浮点数值分别定义不同的数据类型，Number 类型可用于表示所有数值。</li><li>ECMAScript 中也有一种复杂的数据类型，即 Object 类型，该类型是这门语言中所有对象的基础类型。</li><li>严格模式为这门语言中容易出错的地方施加了限制。</li><li>ECMAScript 提供了很多与 C 及其他类 C 语言中相同的基本操作符，包括算术操作符、布尔操作符、关系操作符、相等操作符及赋值操作符等。</li><li>ECMAScript 从其他语言中借鉴了很多流控制语句，例如 if 语句、for 语句和 switch 语句等。ECMAScript 中的函数与其他语言中的函数有诸多不同之处。</li><li>无须指定函数的返回值，因为任何 ECMAScript 函数都可以在任何时候返回任何值。</li><li>实际上，未指定返回值的函数返回的是一个特殊的 undefined 值。</li><li>ECMAScript 中也没有函数签名的概念，因为其函数参数是以一个包含零或多个值的数组的形式传递的。</li><li>可以向 ECMAScript 函数传递任意数量的参数，并且可以通过 arguments 对象来访问这些参数。</li><li>由于不存在函数签名的特性，ECMAScript 函数不能重载。</li></ul></section></div><!-- - var ch_num = "0"--><div id="ch4"><section><p class="h1">第 4 章 变量、作用域和内存问题</p><p class="paragraph strong">本章内容</p><ul><li>理解基本类型和引用类型的值</li><li>理解执行环境</li><li>理解垃圾收集</li></ul><p class="paragraph">按照 ECMA-262 的定义，JavaScript 的变量与其他语言的变量有很大区别。JavaScript 变量松散类型的本质，决定了它只是在特定时间用于保存特定值的一个名字而已。由于不存在定义某个变量必须要保存何种数据类型值的规则，变量的值及其数据类型可以在脚本的生命周期内改变。尽管从某种角度看，这可能是一个既有趣又强大，同时又容易出问题的特性，但 JavaScript 变量实际的复杂程度还远不止如此。</p></section></div><!-- - var ch_num = "0"--><div id="ch4-1"><section><p class="h2">4.1 基本类型和引用类型的值</p><p class="paragraph">ECMAScript 变量可能包含两种不同数据类型的值：基本类型值和引用类型值。基本类型值指的是简单的数据段，而引用类型值指那些可能由多个值构成的对象。</p><p class="paragraph">在将一个值赋给变量时，解析器必须确定这个值是基本类型值还是引用类型值。第 3 章讨论了 5 种基本数据类型：Undefined、Null、Boolean、Number 和 String。这 5 种基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值。</p><p class="paragraph">引用类型的值是保存在内存中的对象。与其他语言不同，JavaScript 不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。为此，引用类型的值是按引用访问的①。</p><p class="paragraph tips">在很多语言中，字符串以对象的形式来表示，因此被认为是引用类型的。ECMAScript 放弃了这一传统。</p><p class="paragraph notes">① 这种说法不严密，当复制保存着对象的某个变量时，操作的是对象的引用。但在为对象添加属性时，操作的是实际的对象。——图灵社区“壮壮的前端之路”注</p></section></div><!-- - var ch_num = "0"--><div id="ch4-1-1"><section><p class="h3">4.1.1 动态的属性</p><p class="paragraph">定义基本类型值和引用类型值的方式是类似的：创建一个变量并为该变量赋值。但是，当这个值保存到变量中以后，对不同类型值可以执行的操作则大相径庭。对于引用类型的值，我们可以为其添加属性和方法，也可以改变和删除其属性和方法。请看下面的例子：</p><pre><code>var person = new Object();
person.name = "Nicholas";
alert(person.name); //"Nicholas"</code></pre><p class="paragraph source-file">DynamicPropertiesExample01.htm</p><p class="paragraph">以上代码创建了一个对象并将其保存在了变量 person 中。然后，我们为该对象添加了一个名为name 的属性，并将字符串值"Nicholas"赋给了这个属性。紧接着，又通过 alert()函数访问了这个新属性。如果对象不被销毁或者这个属性不被删除，则这个属性将一直存在。</p><p class="paragraph">但是，我们不能给基本类型的值添加属性，尽管这样做不会导致任何错误。比如：</p><pre><code>var name = "Nicholas";
name.age = 27;
alert(name.age); //undefined</code></pre><p class="paragraph source-file">DynamicPropertiesExample02.htm</p><p class="paragraph">在这个例子中，我们为字符串 name 定义了一个名为 age 的属性，并为该属性赋值 27。但在下一行访问这个属性时，发现该属性不见了。这说明只能给引用类型值动态地添加属性，以便将来使用。</p></section></div><!-- - var ch_num = "0"--><div id="ch4-1-2"><section><p class="h3">4.1.2 复制变量值</p><p class="paragraph">除了保存的方式不同之外，在从一个变量向另一个变量复制基本类型值和引用类型值时，也存在不同。如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上。来看一个例子：</p><pre><code>var num1 = 5;
var num2 = num1;</code></pre><p class="paragraph">在此，num1 中保存的值是 5。当使用 num1 的值来初始化 num2 时，num2 中也保存了值 5。但 num2中的 5 与 num1 中的 5 是完全独立的，该值只是 num1 中 5 的一个副本。此后，这两个变量可以参与任何操作而不会相互影响。图 4-1 形象地展示了复制基本类型值的过程。</p><div class="images"><img src="static/images/ch4/4-1.jpg" alt="图 4-1"><div class="img-tips">图 4-1.jpg</div></div><p class="paragraph">当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。复制操作结束后，两个变量实际上将引用同一个对象。因此，改变其中一个变量，就会影响另一个变量，如下面的例子所示：</p><pre><code>var obj1 = new Object();
var obj2 = obj1;
obj1.name = "Nicholas";
alert(obj2.name); //"Nicholas"</code></pre><p class="paragraph">首先，变量 obj1 保存了一个对象的新实例。然后，这个值被复制到了 obj2 中；换句话说，obj1和 obj2 都指向同一个对象。这样，当为 obj1 添加 name 属性后，可以通过 obj2 来访问这个属性，因为这两个变量引用的都是同一个对象。图 4-2 展示了保存在变量对象中的变量和保存在堆中的对象之间的这种关系。</p><div class="images"><img src="static/images/ch4/4-2.jpg" alt="图 4-2"><div class="img-tips">图 4-2.jpg</div></div></section></div><!-- - var ch_num = "0"--><div id="ch4-1-3"><section><p class="h3">4.1.3 传递参数</p><p class="paragraph">ECMAScript 中所有函数的参数都是按值传递的。也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。基本类型值的传递如同基本类型变量的复制一样，而引用类型值的传递，则如同引用类型变量的复制一样。有不少开发人员在这一点上可能会感到困惑，因为访问变量有按值和按引用两种方式，而参数只能按值传递。</p><p class="paragraph">在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量（即命名参数，或者用ECMAScript 的概念来说，就是 arguments 对象中的一个元素）。在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。请看下面这个例子：</p><pre><code>function addTen(num) {
     num += 10;
     return num;
}
var count = 20;
var result = addTen(count);
alert(count); //20，没有变化
alert(result); //30</code></pre><p class="paragraph source-file">FunctionArgumentsExample01.htm</p><p class="paragraph">这里的函数 addTen()有一个参数 num，而参数实际上是函数的局部变量。在调用这个函数时，变量count作为参数被传递给函数，这个变量的值是20。于是，数值20被复制给参数num以便在addTen()中使用。在函数内部，参数 num 的值被加上了 10，但这一变化不会影响函数外部的 count 变量。参数num 与变量 count 互不相识，它们仅仅是具有相同的值。假如 num 是按引用传递的话，那么变量 count的值也将变成 30，从而反映函数内部的修改。当然，使用数值等基本类型值来说明按值传递参数比较简单，但如果使用对象，那问题就不怎么好理解了。再举一个例子：</p><pre><code>function setName(obj) {
    obj.name = "Nicholas";
}
var person = new Object();
setName(person);
alert(person.name); //"Nicholas"</code></pre><p class="paragraph source-file">FunctionArgumentsExample02.htm</p><p class="paragraph">以上代码中创建一个对象，并将其保存在了变量 person 中。然后，这个变量被传递到 setName()函数中之后就被复制给了 obj。在这个函数内部，obj 和 person 引用的是同一个对象。换句话说，即使这个变量是按值传递的，obj 也会按引用来访问同一个对象。于是，当在函数内部为 obj 添加 name属性后，函数外部的 person 也将有所反映；因为 person 指向的对象在堆内存中只有一个，而且是全局对象。有很多开发人员错误地认为：在局部作用域中修改的对象会在全局作用域中反映出来，就说明参数是按引用传递的。为了证明对象是按值传递的，我们再看一看下面这个经过修改的例子：</p><pre><code>function setName(obj) {
    obj.name = "Nicholas";
    obj = new Object();
    obj.name = "Greg";
}
var person = new Object();
setName(person);
alert(person.name); //"Nicholas"</code><p class="paragraph">这个例子与前一个例子的唯一区别，就是在 setName()函数中添加了两行代码：一行代码为 obj重新定义了一个对象，另一行代码为该对象定义了一个带有不同值的 name 属性。在把 person 传递给setName()后，其 name 属性被设置为"Nicholas"。然后，又将一个新对象赋给变量 obj，同时将其 name属性设置为"Greg"。如果 person 是按引用传递的，那么 person 就会自动被修改为指向其 name 属性值为"Greg"的新对象。但是，当接下来再访问 person.name 时，显示的值仍然是"Nicholas"。这说明即使在函数内部修改了参数的值，但原始的引用仍然保持未变。实际上，当在函数内部重写 obj 时，这个变量引用的就是一个局部对象了。而这个局部对象会在函数执行完毕后立即被销毁。</p><p class="paragraph tips">可以把 ECMAScript 函数的参数想象成局部变量。</p></pre></section></div><!-- - var ch_num = "0"--><div id="ch4-1-4"><section><p class="h3">4.1.4 检测类型</p><p class="paragraph">要检测一个变量是不是基本数据类型？第 3 章介绍的 typeof 操作符是最佳的工具。说得更具体一点，typeof 操作符是确定一个变量是字符串、数值、布尔值，还是 undefined 的最佳工具。如果变量的值是一个对象或 null，则 typeof 操作符会像下面例子中所示的那样返回"object"：</p><pre><code>var s = "Nicholas";
var b = true;
var i = 22;
var u;
var n = null;
var o = new Object();
alert(typeof s); //string
alert(typeof i); //number
alert(typeof b); //boolean
alert(typeof u); //undefined
alert(typeof n); //object
alert(typeof o); //object</code></pre><p class="paragraph source-file">DeterminingTypeExample01.htm</p><p class="paragraph">虽然在检测基本数据类型时 typeof 是非常得力的助手，但在检测引用类型的值时，这个操作符的用处不大。通常，我们并不是想知道某个值是对象，而是想知道它是什么类型的对象。为此，ECMAScript提供了 instanceof 操作符，其语法如下所示：</p><pre><code>result = variable instanceof constructor</code></pre><p class="paragraph">如果变量是给定引用类型（根据它的原型链来识别；第 6 章将介绍原型链）的实例，那么instanceof 操作符就会返回 true。请看下面的例子：</p><pre><code>alert(person instanceof Object); // 变量 person 是 Object 吗？
alert(colors instanceof Array); // 变量 colors 是 Array 吗？
alert(pattern instanceof RegExp); // 变量 pattern 是 RegExp 吗？</code></pre><p class="paragraph">根据规定，所有引用类型的值都是 Object 的实例。因此，在检测一个引用类型值和 Object 构造函数时，instanceof 操作符始终会返回 true。当然，如果使用 instanceof 操作符检测基本类型的值，则该操作符始终会返回 false，因为基本类型不是对象。</p><p class="paragraph tips">使用 typeof 操作符检测函数时，该操作符会返回"function"。在 Safari 5 及之前版本和 Chrome 7 及之前版本中使用 typeof 检测正则表达式时，由于规范的原因，这个操作符也返回"function"。ECMA-262 规定任何在内部实现[[Call]]方法的对象都应该在应用 typeof 操作符时返回"function"。由于上述浏览器中的正则表达式也实现了这个方法，因此对正则表达式应用 typeof 会返回"function"。在IE 和 Firefox 中，对正则表达式应用 typeof 会返回"object"。</p></section></div><!-- - var ch_num = "0"--><div id="ch4-2"><section><p class="h2">4.2 执行环境及作用域</p><p class="paragraph">执行环境（execution context，为简单起见，有时也称为“环境”）是 JavaScript 中最为重要的一个概念。执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象（variable object），环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。</p><p class="paragraph">全局执行环境是最外围的一个执行环境。根据 ECMAScript 实现所在的宿主环境不同，表示执行环境的对象也不一样。在 Web 浏览器中，全局执行环境被认为是 window 对象（第 7 章将详细讨论），因此所有全局变量和函数都是作为 window 对象的属性和方法创建的。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境直到应用程序退出——例如关闭网页或浏览器——时才会被销毁）。</p><p class="paragraph">每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。ECMAScript 程序中的执行流正是由这个方便的机制控制着。</p><p class="paragraph">当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象（activation object）作为变量对象。活动对象在最开始时只包含一个变量，即 arguments 对象（这个对象在全局环境中是不存在的）。作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。</p><p class="paragraph">标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符为止（如果找不到标识符，通常会导致错误发生）。</p><p class="paragraph">请看下面的示例代码：</p><pre><code>var color = "blue";
function changeColor(){
    if (color === "blue"){
        color = "red";
    } else {
        color = "blue";
    }
}
changeColor();
alert("Color is now " + color);</code></pre><p class="paragraph source-file">ExecutionContextExample01.htm</p><p class="paragraph">在这个简单的例子中，函数 changeColor()的作用域链包含两个对象：它自己的变量对象（其中定义着 arguments 对象）和全局环境的变量对象。可以在函数内部访问变量 color，就是因为可以在这个作用域链中找到它。</p><p class="paragraph">此外，在局部作用域中定义的变量可以在局部环境中与全局变量互换使用，如下面这个例子所示：</p><pre><code>var color = "blue";
function changeColor(){
    var anotherColor = "red";
    function swapColors(){
        var tempColor = anotherColor;
        anotherColor = color;
        color = tempColor;
        // 这里可以访问 color、anotherColor 和 tempColor
    }
    // 这里可以访问 color 和 anotherColor，但不能访问 tempColor
    swapColors();
}
// 这里只能访问 color
changeColor();</code></pre><p class="paragraph">以上代码共涉及 3 个执行环境：全局环境、changeColor()的局部环境和 swapColors()的局部环境。全局环境中有一个变量 color 和一个函数 changeColor()。changeColor()的局部环境中有一个名为 anotherColor 的变量和一个名为 swapColors()的函数，但它也可以访问全局环境中的变量 color。swapColors()的局部环境中有一个变量 tempColor，该变量只能在这个环境中访问到。无论全局环境还是 changeColor()的局部环境都无权访问 tempColor。然而，在 swapColors()内部则可以访问其他两个环境中的所有变量，因为那两个环境是它的父执行环境。图 4-3 形象地展示了前面这个例子的作用域链。</p><div class="images"><img src="static/images/ch4-2/4-3.jpg" alt="图 4-3"><div class="img-tips">图  4-3</div></div><p class="paragraph">图 4-3 中的矩形表示特定的执行环境。其中，内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。这些环境之间的联系是线性、有次序的。每个环境都可以向上搜索作用域链，以查询变量和函数名；但任何环境都不能通过向下搜索作用域链而进入另一个执行环境。对于这个例子中的 swapColors()而言，其作用域链中包含 3 个对象：swapColors()的变量对象、changeColor()的变量对象和全局变量对象。swapColors()的局部环境开始时会先在自己的变量对象中搜索变量和函数名，如果搜索不到则再搜索上一级作用域链。changeColor()的作用域链中只包含两个对象：它自己的变量对象和全局变量对象。这也就是说，它不能访问 swapColors()的环境。</p><p class="paragraph tips">函数参数也被当作变量来对待，因此其访问规则与执行环境中的其他变量相同。</p></section></div><!-- - var ch_num = "0"--><div id="ch4-2-1"><section><p class="h3">4.2.1 延长作用域链</p><p class="paragraph">虽然执行环境的类型总共只有两种——全局和局部（函数），但还是有其他办法来延长作用域链。这么说是因为有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除。在两种情况下会发生这种现象。具体来说，就是当执行流进入下列任何一个语句时，作用域链就会得到加长：</p><ul><li>try-catch 语句的 catch 块；</li><li>with 语句。</li></ul><p class="paragraph">这两个语句都会在作用域链的前端添加一个变量对象。对 with 语句来说，会将指定的对象添加到作用域链中。对 catch 语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。下面看一个例子。</p><pre><code>function buildUrl() {
    var qs = "?debug=true";
    with(location){
        var url = href + qs;
    }
    return url;
}</code></pre><p class="paragraph source-file">ExecutionContextExample03.htm</p><p class="paragraph">在此，with 语句接收的是 location 对象，因此其变量对象中就包含了 location 对象的所有属性和方法，而这个变量对象被添加到了作用域链的前端。buildUrl()函数中定义了一个变量 qs。当在with 语句中引用变量 href 时（实际引用的是 location.href），可以在当前执行环境的变量对象中找到。当引用变量 qs 时，引用的则是在 buildUrl()中定义的那个变量，而该变量位于函数环境的变量对象中。至于 with 语句内部，则定义了一个名为 url 的变量，因而 url 就成了函数执行环境的一部分，所以可以作为函数的值被返回。</p><p class="paragraph tips">在 IE8 及之前版本的 JavaScript 实现中，存在一个与标准不一致的地方，即在catch 语句中捕获的错误对象会被添加到执行环境的变量对象，而不是 catch 语句的变量对象中。换句话说，即使是在 catch 块的外部也可以访问到错误对象。IE9 修复了这个问题。</p></section></div><!-- - var ch_num = "0"--><div id="ch4-2-2"><section><p class="h3">4.2.2 没有块级作用域</p><p class="paragraph">JavaScript 没有块级作用域经常会导致理解上的困惑。在其他类 C 的语言中，由花括号封闭的代码块都有自己的作用域（如果用 ECMAScript 的话来讲，就是它们自己的执行环境），因而支持根据条件来定义变量。例如，下面的代码在 JavaScript 中并不会得到想象中的结果：</p><pre><code>if (true) {
    var color = "blue";
}
alert(color); //"blue"</code></pre><p class="paragraph">这里是在一个 if 语句中定义了变量 color。如果是在 C、C++或 Java 中，color 会在 if 语句执行完毕后被销毁。但在 JavaScript 中，if 语句中的变量声明会将变量添加到当前的执行环境（在这里是全局环境）中。在使用 for 语句时尤其要牢记这一差异，例如：</p><pre><code>for (var i=0; i < 10; i++){
    doSomething(i);
}
alert(i); //10</code></pre><p class="paragraph">对于有块级作用域的语言来说，for 语句初始化变量的表达式所定义的变量，只会存在于循环的环境之中。而对于 JavaScript 来说，由 for 语句创建的变量 i 即使在 for 循环执行结束后，也依旧会存在于循环外部的执行环境中。</p><p class="paragraph strong">1. 声明变量</p><p class="paragraph">使用 var 声明的变量会自动被添加到最接近的环境中。在函数内部，最接近的环境就是函数的局部环境；在 with 语句中，最接近的环境是函数环境。如果初始化变量时没有使用 var 声明，该变量会自动被添加到全局环境。如下所示：</p><pre><code>function add(num1, num2) {
    var sum = num1 + num2;
    return sum;
}
var result = add(10, 20); //30
alert(sum); //由于 sum 不是有效的变量，因此会导致错误</code></pre><p class="paragraph source-file">ExecutionContextExample04.htm</p><p class="paragraph">以上代码中的函数 add()定义了一个名为 sum 的局部变量，该变量包含加法操作的结果。虽然结果值从函数中返回了，但变量 sum 在函数外部是访问不到的。如果省略这个例子中的 var 关键字，那么当 add()执行完毕后，sum 也将可以访问到：</p><pre><code>function add(num1, num2) {
    sum = num1 + num2;
    return sum;
}
var result = add(10, 20); //30
alert(sum); //30</code></pre><p class="paragraph source-file">ExecutionContextExample05.htm</p><p class="paragraph">这个例子中的变量 sum 在被初始化赋值时没有使用 var 关键字。于是，当调用完 add()之后，添加到全局环境中的变量 sum 将继续存在；即使函数已经执行完毕，后面的代码依旧可以访问它。</p><p class="paragraph tips">在编写 JavaScript 代码的过程中，不声明而直接初始化变量是一个常见的错误做法，因为这样可能会导致意外。我们建议在初始化变量之前，一定要先声明，这样就可以避免类似问题。在严格模式下，初始化未经声明的变量会导致错误。</p><p class="paragraph strong">2. 查询标识符</p><p class="paragraph">当在某个环境中为了读取或写入而引用一个标识符时，必须通过搜索来确定该标识符实际代表什么。搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。如果在局部环境中找到了该标识符，搜索过程停止，变量就绪。如果在局部环境中没有找到该变量名，则继续沿作用域链向上搜索。搜索过程将一直追溯到全局环境的变量对象。如果在全局环境中也没有找到这个标识符，则意味着该变量尚未声明。</p><p class="paragraph">通过下面这个示例，可以理解查询标识符的过程：</p><pre><code>var color = "blue";
function getColor(){
    return color;
}
alert(getColor()); //"blue"</code></pre><p class="paragraph source-file">ExecutionContextExample06.htm</p><p class="paragraph">调用本例中的函数 getColor()时会引用变量 color。为了确定变量 color 的值，将开始一个两步的搜索过程。首先，搜索 getColor()的变量对象，查找其中是否包含一个名为 color 的标识符。在没有找到的情况下，搜索继续到下一个变量对象（全局环境的变量对象），然后在那里找到了名为color 的标识符。因为搜索到了定义这个变量的变量对象，搜索过程宣告结束。图 4-4 形象地展示了上述搜索过程。</p><div class="images"><img src="static/images/ch4-2-2/4-4.jpg" alt="图 4-4 "><div class="img-tips">图 4-4</div></div><p class="paragraph">在这个搜索过程中，如果存在一个局部的变量的定义，则搜索会自动停止，不再进入另一个变量对象。换句话说，如果局部环境中存在着同名标识符，就不会使用位于父环境中的标识符，如下面的例子所示：</p><pre><code>var color = "blue";
function getColor(){
    var color = "red";
    return color;
}
alert(getColor()); //"red"</code></pre><p class="paragraph source-file">ExecutionContextExample07.htm</p><p class="paragraph">修改后的代码在 getColor()函数中声明了一个名为 color 的局部变量。调用函数时，该变量就会被声明。而当函数中的第二行代码执行时，意味着必须找到并返回变量 color 的值。搜索过程首先从局部环境中开始，而且在这里发现了一个名为 color 的变量，其值为"red"。因为变量已经找到了，所以搜索即行停止，return 语句就使用这个局部变量，并为函数会返回"red"。也就是说，任何位于局部变量 color 的声明之后的代码，如果不使用 window.color 都无法访问全局 color变量。</p><p class="paragraph tips">变量查询也不是没有代价的。很明显，访问局部变量要比访问全局变量更快，因为不用向上搜索作用域链。JavaScript 引擎在优化标识符查询方面做得不错，因此这个差别在将来恐怕就可以忽略不计了。</p></section></div><!-- - var ch_num = "0"--><div id="ch4-3"><section><p class="h2">4.3 垃圾收集</p><p class="paragraph">JavaScript 具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。而在 C 和 C++之类的语言中，开发人员的一项基本任务就是手工跟踪内存的使用情况，这是造成许多问题的一个根源。在编写 JavaScript 程序时，开发人员不用再关心内存使用问题，所需内存的分配以及无用内存的回收完全实现了自动管理。这种垃圾收集机制的原理其实很简单：找出那些不再继续使用的变量，然后释放其占用的内存。为此，垃圾收集器会按照固定的时间间隔（或代码执行中预定的收集时间），周期性地执行这一操作。</p><p class="paragraph">下面我们来分析一下函数中局部变量的正常生命周期。局部变量只在函数执行的过程中存在。而在这个过程中，会为局部变量在栈（或堆）内存上分配相应的空间，以便存储它们的值。然后在函数中使用这些变量，直至函数执行结束。此时，局部变量就没有存在的必要了，因此可以释放它们的内存以供将来使用。在这种情况下，很容易判断变量是否还有存在的必要；但并非所有情况下都这么容易就能得出结论。垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存。用于标识无用变量的策略可能会因实现而异，但具体到浏览器中的实现，则通常有两个策略。</p></section></div><!-- - var ch_num = "0"--><div id="ch4-3-1"><section><p class="h3">4.3.1 标记清除</p><p class="paragraph">JavaScript 中最常用的垃圾收集方式是标记清除（mark-and-sweep）。当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。</p><p class="paragraph">可以使用任何方式来标记变量。比如，可以通过翻转某个特殊的位来记录一个变量何时进入环境，或者使用一个“进入环境的”变量列表及一个“离开环境的”变量列表来跟踪哪个变量发生了变化。说到底，如何标记变量其实并不重要，关键在于采取什么策略。</p><p class="paragraph">垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。</p><p class="paragraph">到 2008 年为止，IE、Firefox、Opera、Chrome 和 Safari 的 JavaScript 实现使用的都是标记清除式的垃圾收集策略（或类似的策略），只不过垃圾收集的时间间隔互有不同。</p></section></div><!-- - var ch_num = "0"--><div id="ch4-3-2"><section><p class="h3">4.3.2 引用计数</p><p class="paragraph">另一种不太常见的垃圾收集策略叫做引用计数（reference counting）。引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是 1。如果同一个值又被赋给另一个变量，则该值的引用次数加 1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减 1。当这个值的引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那些引用次数为零的值所占用的内存。</p><p class="paragraph">Netscape Navigator 3.0 是最早使用引用计数策略的浏览器，但很快它就遇到了一个严重的问题：循环引用。循环引用指的是对象 A 中包含一个指向对象 B 的指针，而对象 B 中也包含一个指向对象 A 的引用。请看下面这个例子：</p><pre><code>function problem(){
    var objectA = new Object();
    var objectB = new Object();

    objectA.someOtherObject = objectB;
    objectB.anotherObject = objectA;
}</code></pre><p class="paragraph">在这个例子中，objectA 和 objectB 通过各自的属性相互引用；也就是说，这两个对象的引用次数都是 2。在采用标记清除策略的实现中，由于函数执行之后，这两个对象都离开了作用域，因此这种相互引用不是个问题。但在采用引用计数策略的实现中，当函数执行完毕后，objectA 和 objectB 还将继续存在，因为它们的引用次数永远不会是 0。假如这个函数被重复多次调用，就会导致大量内存得不到回收。为此，Netscape 在 Navigator 4.0 中放弃了引用计数方式，转而采用标记清除来实现其垃圾收集机制。可是，引用计数导致的麻烦并未就此终结。</p><p class="paragraph">我们知道，IE 中有一部分对象并不是原生 JavaScript 对象。例如，其 BOM 和 DOM 中的对象就是使用 C++以 COM（Component Object Model，组件对象模型）对象的形式实现的，而 COM 对象的垃圾收集机制采用的就是引用计数策略。因此，即使 IE 的 JavaScript 引擎是使用标记清除策略来实现的，但JavaScript 访问的 COM 对象依然是基于引用计数策略的。换句话说，只要在 IE 中涉及 COM 对象，就会存在循环引用的问题。下面这个简单的例子，展示了使用 COM 对象导致的循环引用问题：</p><pre><code>var element = document.getElementById("some_element");
var myObject = new Object();
myObject.element = element;
element.someObject = myObject;</code></pre><p class="paragraph">这个例子在一个 DOM 元素（element）与一个原生 JavaScript 对象（myObject）之间创建了循环引用。其中，变量 myObject 有一个名为 element 的属性指向 element 对象；而变量 element 也有一个属性名叫 someObject 回指 myObject。由于存在这个循环引用，即使将例子中的 DOM 从页面中移除，它也永远不会被回收。</p><p class="paragraph">为了避免类似这样的循环引用问题，最好是在不使用它们的时候手工断开原生 JavaScript 对象与DOM 元素之间的连接。例如，可以使用下面的代码消除前面例子创建的循环引用：</p><pre><code>myObject.element = null;
element.someObject = null;</code></pre><p class="paragraph">将变量设置为 null 意味着切断变量与它此前引用的值之间的连接。当垃圾收集器下次运行时，就会删除这些值并回收它们占用的内存。</p><p class="paragraph">为了解决上述问题，IE9 把 BOM 和 DOM 对象都转换成了真正的 JavaScript 对象。这样，就避免了两种垃圾收集算法并存导致的问题，也消除了常见的内存泄漏现象。</p><p class="paragraph tips">导致循环引用的情况不止这些，其他一些情况将在本书中陆续介绍。</p></section></div><!-- - var ch_num = "0"--><div id="ch4-3-3"><section><p class="h3">4.3.3 性能问题</p><p class="paragraph">垃圾收集器是周期性运行的，而且如果为变量分配的内存数量很可观，那么回收工作量也是相当大的。在这种情况下，确定垃圾收集的时间间隔是一个非常重要的问题。说到垃圾收集器多长时间运行一次，不禁让人联想到 IE 因此而声名狼藉的性能问题。IE 的垃圾收集器是根据内存分配量运行的，具体一点说就是 256 个变量、4096 个对象（或数组）字面量和数组元素（slot）或者 64KB 的字符串。达到上述任何一个临界值，垃圾收集器就会运行。这种实现方式的问题在于，如果一个脚本中包含那么多变量，那么该脚本很可能会在其生命周期中一直保有那么多的变量。而这样一来，垃圾收集器就不得不频繁地运行。结果，由此引发的严重性能问题促使 IE7 重写了其垃圾收集例程。</p><p class="paragraph">随着 IE7 的发布，其 JavaScript 引擎的垃圾收集例程改变了工作方式：触发垃圾收集的变量分配、字面量和（或）数组元素的临界值被调整为动态修正。IE7 中的各项临界值在初始时与 IE6 相等。如果垃圾收集例程回收的内存分配量低于 15%，则变量、字面量和（或）数组元素的临界值就会加倍。如果例程回收了 85%的内存分配量，则将各种临界值重置回默认值。这一看似简单的调整，极大地提升了 IE在运行包含大量 JavaScript 的页面时的性能。</p><p class="paragraph tips">事实上，在有的浏览器中可以触发垃圾收集过程，但我们不建议读者这样做。在IE 中，调用 window.CollectGarbage()方法会立即执行垃圾收集。在 Opera 7 及更高版本中，调用 window.opera.collect()也会启动垃圾收集例程。</p></section></div><!-- - var ch_num = "0"--><div id="ch4-3-4"><section><p class="h3">4.3.4 管理内存</p><p class="paragraph">使用具备垃圾收集机制的语言编写程序，开发人员一般不必操心内存管理的问题。但是，JavaScript在进行内存管理及垃圾收集时面临的问题还是有点与众不同。其中最主要的一个问题，就是分配给 Web浏览器的可用内存数量通常要比分配给桌面应用程序的少。这样做的目的主要是出于安全方面的考虑，目的是防止运行 JavaScript 的网页耗尽全部系统内存而导致系统崩溃。内存限制问题不仅会影响给变量分配内存，同时还会影响调用栈以及在一个线程中能够同时执行的语句数量。</p><p class="paragraph">因此，确保占用最少的内存可以让页面获得更好的性能。而优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。一旦数据不再有用，最好通过将其值设置为 null 来释放其引用——这个做法叫做解除引用（dereferencing）。这一做法适用于大多数全局变量和全局对象的属性。局部变量会在它们离开执行环境时自动被解除引用，如下面这个例子所示：</p><pre><code>function createPerson(name){
    var localPerson = new Object();
    localPerson.name = name;
    return localPerson;
}
var globalPerson = createPerson("Nicholas");
// 手工解除 globalPerson 的引用
globalPerson = null;</code></pre><p class="paragraph">在这个例子中，变量 globalPerson 取得了 createPerson()函数返回的值。在 createPerson()函数内部，我们创建了一个对象并将其赋给局部变量 localPerson，然后又为该对象添加了一个名为name 的属性。最后，当调用这个函数时，localPerson 以函数值的形式返回并赋给全局变量globalPerson。由于 localPerson 在 createPerson()函数执行完毕后就离开了其执行环境，因此无需我们显式地去为它解除引用。但是对于全局变量 globalPerson 而言，则需要我们在不使用它的时候手工为它解除引用，这也正是上面例子中最后一行代码的目的。</p><p class="paragraph">不过，解除一个值的引用并不意味着自动回收该值所占用的内存。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。</p></section></div><!-- - var ch_num = "0"--><div id="ch4-4"><section><p class="h2">4.4 小结</p><p class="paragraph">JavaScript 变量可以用来保存两种类型的值：基本类型值和引用类型值。基本类型的值源自以下 5种基本数据类型：Undefined、Null、Boolean、Number 和 String。基本类型值和引用类型值具有以下特点：</p><ul><li>基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中；</li><li>从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本；</li><li>引用类型的值是对象，保存在堆内存中；</li><li>包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针；</li><li>从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象；</li><li>确定一个值是哪种基本类型可以使用 typeof 操作符，而确定一个值是哪种引用类型可以使用instanceof 操作符。所有变量（包括基本类型和引用类型）都存在于一个执行环境（也称为作用域）中，这个执行环境决定了变量的生命周期，以及哪一部分代码可以访问其中的变量。以下是关于执行环境的几点总结：</li><li>执行环境有全局执行环境（也称为全局环境）和函数执行环境之分；</li><li>每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链；</li><li>函数的局部环境不仅有权访问函数作用域中的变量，而且有权访问其包含（父）环境，乃至全局环境；</li><li>全局环境只能访问在全局环境中定义的变量和函数，而不能直接访问局部环境中的任何数据；</li><li>变量的执行环境有助于确定应该何时释放内存。JavaScript 是一门具有自动垃圾收集机制的编程语言，开发人员不必关心内存分配和回收问题。可以对 JavaScript 的垃圾收集例程作如下总结。</li><li>离开作用域的值将被自动标记为可以回收，因此将在垃圾收集期间被删除。</li><li>“标记清除”是目前主流的垃圾收集算法，这种算法的思想是给当前不使用的值加上标记，然后再回收其内存。</li><li>另一种垃圾收集算法是“引用计数”，这种算法的思想是跟踪记录所有值被引用的次数。JavaScript引擎目前都不再使用这种算法；但在 IE 中访问非原生 JavaScript 对象（如 DOM 元素）时，这种算法仍然可能会导致问题。</li><li>当代码中存在循环引用现象时，“引用计数”算法就会导致问题。</li><li>解除变量的引用不仅有助于消除循环引用现象，而且对垃圾收集也有好处。为了确保有效地回收内存，应该及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用。</li></ul></section></div></main><aside><div id="catalogue"><h1>目录</h1><ul class="list-root"><li class="list-first"><a class="list-link" href="#statement">声明</a></li><li class="list-first"><a class="list-link" href="#preface01">序</a></li><li class="list-first"><a class="list-link" href="#preface02">前言</a></li><li class="list-first"><a class="list-link" href="#ch1">第 1 章    JavaScript 简介</a><ul class="sub-list"><li class="sub-list-item"><a class="list-link" href="#ch1-1">1.1 JavaScript 简史</a></li><li class="sub-list-item"><a class="list-link" href="#ch1-2">1.2 JavaScript 实现</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch1-2-1">1.2.1 ECMAScript</a></li><li class="sub2-list-item"><a class="list-link" href="#ch1-2-2">1.2.2 文档对象模型（DOM）</a></li><li class="sub2-list-item"><a class="list-link" href="#ch1-2-3">1.2.3 浏览器对象模型（BOM）</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch1-3">1.3 JavaScript 版本</a></li><li class="sub-list-item"><a class="list-link" href="#ch1-4">1.4 小结</a></li></ul></li><li class="list-first"><a class="list-link" href="#ch2">第 2 章 在HTML中使用 JavaScript</a><ul class="sub-list"><li class="sub-list-item"><a class="list-link" href="#ch2-1">2.1 &lt;script&gt;元素</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch2-1-1">2.1.1 标签的位置</a></li><li class="sub2-list-item"><a class="list-link" href="#ch2-1-2">2.1.2 延迟脚本</a></li><li class="sub2-list-item"><a class="list-link" href="#ch2-1-3">2.1.3 异步脚本</a></li><li class="sub2-list-item"><a class="list-link" href="#ch2-1-4">2.1.4 在XHTML中的用法</a></li><li class="sub2-list-item"><a class="list-link" href="#ch2-1-5">2.1.5 不推荐使用的语法</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch2-2">2.2 嵌入代码与外部文件.</a></li><li class="sub-list-item"><a class="list-link" href="#ch2-3">2.3 文档模式</a></li><li class="sub-list-item"><a class="list-link" href="#ch2-4">2.4 &lt;noscript&gt;元素</a></li><li class="sub-list-item"><a class="list-link" href="#ch2-5">2.5 小结</a></li></ul></li><li class="list-first"><a class="list-link" href="#ch3">第 3 章 基本概念</a><ul class="sub-list"><li class="sub-list-item"><a class="list-link" href="#ch3-1">3.1 语法</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch3-1-1">3.1.1 区分大小写</a></li><li class="sub2-list-item"><a class="list-link" href="#ch3-1-2">3.1.2 标识符</a></li><li class="sub2-list-item"><a class="list-link" href="#ch3-1-3">3.1.3 注释</a></li><li class="sub2-list-item"><a class="list-link" href="#ch3-1-4">3.1.4 严格模式</a></li><li class="sub2-list-item"><a class="list-link" href="#ch3-1-5">3.1.5 语句</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch3-2">3.2 关键字和保留字</a></li><li class="sub-list-item"><a class="list-link" href="#ch3-3">3.3 变量</a></li><li class="sub-list-item"><a class="list-link" href="#ch3-4">3.4 数据类型</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch3-4-1">3.4.1 typeof 操作符</a></li><li class="sub2-list-item"><a class="list-link" href="#ch3-4-2">3.4.2 Undefined 类型</a></li><li class="sub2-list-item"><a class="list-link" href="#ch3-4-3">3.4.3 Null 类型</a></li><li class="sub2-list-item"><a class="list-link" href="#ch3-4-4">3.4.4 Boolean 类型</a></li><li class="sub2-list-item"><a class="list-link" href="#ch3-4-5">3.4.5 Number 类型</a></li><li class="sub2-list-item"><a class="list-link" href="#ch3-4-6">3.4.6 String 类型</a></li><li class="sub2-list-item"><a class="list-link" href="#ch3-4-7">3.4.7 Object 类型</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch3-5">3.5 操作符</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch3-5-1"> 3.5.1 一元操作符</a></li><li class="sub2-list-item"><a class="list-link" href="#ch3-5-2"> 3.5.2 位操作符</a></li><li class="sub2-list-item"><a class="list-link" href="#ch3-5-3"> 3.5.3 布尔操作符</a></li><li class="sub2-list-item"><a class="list-link" href="#ch3-5-4"> 3.5.4 乘性操作符</a></li><li class="sub2-list-item"><a class="list-link" href="#ch3-5-5"> 3.5.5 加性操作符</a></li><li class="sub2-list-item"><a class="list-link" href="#ch3-5-6"> 3.5.6 关系操作符</a></li><li class="sub2-list-item"><a class="list-link" href="#ch3-5-7"> 3.5.7 相等操作符</a></li><li class="sub2-list-item"><a class="list-link" href="#ch3-5-8"> 3.5.8 条件操作符</a></li><li class="sub2-list-item"><a class="list-link" href="#ch3-5-9"> 3.5.9 赋值操作符</a></li><li class="sub2-list-item"><a class="list-link" href="#ch3-5-10">3.5.10 逗号操作符</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch3-6">3.6 语句</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch3-6-1"> 3.6.1 if 语句</a></li><li class="sub2-list-item"><a class="list-link" href="#ch3-6-2"> 3.6.2 do-while 语句</a></li><li class="sub2-list-item"><a class="list-link" href="#ch3-6-3"> 3.6.3 while 语句</a></li><li class="sub2-list-item"><a class="list-link" href="#ch3-6-4"> 3.6.4 for 语句</a></li><li class="sub2-list-item"><a class="list-link" href="#ch3-6-5"> 3.6.5 for-in 语句</a></li><li class="sub2-list-item"><a class="list-link" href="#ch3-6-6"> 3.6.6 label 语句</a></li><li class="sub2-list-item"><a class="list-link" href="#ch3-6-7"> 3.6.7 break 和 continue 语句</a></li><li class="sub2-list-item"><a class="list-link" href="#ch3-6-8"> 3.6.8 with 语句</a></li><li class="sub2-list-item"><a class="list-link" href="#ch3-6-9"> 3.6.9 switch 语句</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch3-7">3.7 函数</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch3-7-1"> 3.7.1 理解参数</a></li><li class="sub2-list-item"><a class="list-link" href="#ch3-7-2"> 3.7.2 没有重载</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch3-8">3.8 小结</a></li></ul></li><li class="list-first"><a class="list-link" href="#ch4">第 4 章 变量、作用域和内存问题</a><ul class="sub-list"><li class="sub-list-item"><a class="list-link" href="#ch4-1">4.1 基本类型和引用类型的值</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch4-1-1">4.1.1 动态的属性</a></li><li class="sub2-list-item"><a class="list-link" href="#ch4-1-2">4.1.2 复制变量值</a></li><li class="sub2-list-item"><a class="list-link" href="#ch4-1-3">4.1.3 传递参数</a></li><li class="sub2-list-item"><a class="list-link" href="#ch4-1-4">4.1.4 检测类型</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch4-2">4.2 执行环境及作用域</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch4-2-1">4.2.1 延长作用域链</a></li><li class="sub2-list-item"><a class="list-link" href="#ch4-2-2">4.2.2 没有块级作用域</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch4-3">4.3 垃圾收集</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch4-3-1">4.3.1 标记清除</a></li><li class="sub2-list-item"><a class="list-link" href="#ch4-3-2">4.3.2 引用计数</a></li><li class="sub2-list-item"><a class="list-link" href="#ch4-3-3">4.3.3 性能问题</a></li><li class="sub2-list-item"><a class="list-link" href="#ch4-3-4">4.3.4 管理内存</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch4-4">4.4 小结</a></li></ul></li><li class="list-first"><a class="list-link" href="#ch5">第 5 章 引用类型</a><ul class="sub-list"><li class="sub-list-item"><a class="list-link" href="#ch5-1">5.1 Object 类型</a></li><li class="sub-list-item"><a class="list-link" href="#ch5-2">5.2 Array 类型</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch5-2-1">5.2.1 检测数组</a></li><li class="sub2-list-item"><a class="list-link" href="#ch5-2-2">5.2.2 转换方法</a></li><li class="sub2-list-item"><a class="list-link" href="#ch5-2-3">5.2.3 栈方法</a></li><li class="sub2-list-item"><a class="list-link" href="#ch5-2-4">5.2.4 队列方法</a></li><li class="sub2-list-item"><a class="list-link" href="#ch5-2-5">5.2.5 重排序方法</a></li><li class="sub2-list-item"><a class="list-link" href="#ch5-2-6">5.2.6 操作方法</a></li><li class="sub2-list-item"><a class="list-link" href="#ch5-2-7">5.2.7 位置方法</a></li><li class="sub2-list-item"><a class="list-link" href="#ch5-2-8">5.2.8 迭代方法</a></li><li class="sub2-list-item"><a class="list-link" href="#ch5-2-9">5.2.9 归并方法</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch5-3">5.3 Date 类型</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch5-3-1">5.3.1 继承的方法</a></li><li class="sub2-list-item"><a class="list-link" href="#ch5-3-2">5.3.2 日期格式化方法</a></li><li class="sub2-list-item"><a class="list-link" href="#ch5-3-3">5.3.3 日期/时间组件方法</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch5-4">5.4 RegExp 类型</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch5-4-1">5.4.1 RegExp 实例属性</a></li><li class="sub2-list-item"><a class="list-link" href="#ch5-4-2">5.4.2 RegExp 实例方法</a></li><li class="sub2-list-item"><a class="list-link" href="#ch5-4-3">5.4.3 RegExp 构造函数属性</a></li><li class="sub2-list-item"><a class="list-link" href="#ch5-4-4">5.4.4 模式的局限性</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch5-5">Function 类型</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch5-5-1">5.5.1 没有重载（深入理解）</a></li><li class="sub2-list-item"><a class="list-link" href="#ch5-5-2">5.5.2 函数声明与函数表达式</a></li><li class="sub2-list-item"><a class="list-link" href="#ch5-5-3">5.5.3 作为值的函数</a></li><li class="sub2-list-item"><a class="list-link" href="#ch5-5-4">5.5.4 函数内部属性</a></li><li class="sub2-list-item"><a class="list-link" href="#ch5-5-5">5.5.5 函数属性和方法</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch5-6">5.6 基本包装类型</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch5-5-1">5.6.1 Boolean 类型</a></li><li class="sub2-list-item"><a class="list-link" href="#ch5-5-2">5.6.2 Number 类型</a></li><li class="sub2-list-item"><a class="list-link" href="#ch5-5-3">5.6.3 String 类型</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch5-7">5.7 单体内置对象</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch5-7-1">5.7.1 Global 对象</a></li><li class="sub2-list-item"><a class="list-link" href="#ch5-7-2">5.7.2 Math 对象</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch5-8">5.8 小结</a></li></ul></li><li class="list-first"><a class="list-link" href="#ch6">第 6 章 面向对象的程序设计</a><ul class="sub-list"><li class="sub-list-item"><a class="list-link" href="#ch6-1">6.1 理解对象</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch6-1-1">6.1.1 属性类型</a></li><li class="sub2-list-item"><a class="list-link" href="#ch6-1-2">6.1.2 定义多个属性</a></li><li class="sub2-list-item"><a class="list-link" href="#ch6-1-3">6.1.3 读取属性的特性</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch6-2">6.2 创建对象</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch6-2-1">6.2.1 工厂模式</a></li><li class="sub2-list-item"><a class="list-link" href="#ch6-2-2">6.2.2 构造函数模式</a></li><li class="sub2-list-item"><a class="list-link" href="#ch6-2-3">6.2.3 原型模式</a></li><li class="sub2-list-item"><a class="list-link" href="#ch6-2-4">6.2.4 组合使用构造函数模式和原型模式</a></li><li class="sub2-list-item"><a class="list-link" href="#ch6-2-5">6.2.5 动态原型模式</a></li><li class="sub2-list-item"><a class="list-link" href="#ch6-2-6">6.2.6 寄生构造函数模式</a></li><li class="sub2-list-item"><a class="list-link" href="#ch6-2-7">6.2.7 稳妥构造函数模式</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch6-3">6.3 继承</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch6-3-1">6.3.1 原型链</a></li><li class="sub2-list-item"><a class="list-link" href="#ch6-3-2">6.3.2 借用构造函数</a></li><li class="sub2-list-item"><a class="list-link" href="#ch6-3-3">6.3.3 组合继承</a></li><li class="sub2-list-item"><a class="list-link" href="#ch6-3-4">6.3.4 原型式继承</a></li><li class="sub2-list-item"><a class="list-link" href="#ch6-3-5">6.3.5 寄生式继承</a></li><li class="sub2-list-item"><a class="list-link" href="#ch6-3-6">6.3.6 寄生组合式继承</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch6-4">6.4 小结</a></li></ul></li><li class="list-first"><a class="list-link" href="#ch7">第 7 章 函数表达式</a><ul class="sub-list"><li class="sub-list-item"><a class="list-link" href="#ch6-1">7.1 递归</a></li><li class="sub-list-item"><a class="list-link" href="#ch7-2">7.2 闭包</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch7-2-1">7.2.1 闭包与变量</a></li><li class="sub2-list-item"><a class="list-link" href="#ch7-2-2">7.2.2 关于 this 对象</a></li><li class="sub2-list-item"><a class="list-link" href="#ch7-2-3">7.2.3 内存泄漏</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch7-3">7.3 模仿块级作用域</a></li><li class="sub-list-item"><a class="list-link" href="#ch7-4">7.4 私有变量</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch7-4-1">7.4.1 静态私有变量</a></li><li class="sub2-list-item"><a class="list-link" href="#ch7-4-2">7.4.2 模块模式</a></li><li class="sub2-list-item"><a class="list-link" href="#ch7-4-3">7.4.3 增强的模块模式</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch7-5">7.5 小结</a></li></ul></li><li class="list-first"><a class="list-link" href="#ch8">第 8 章 BOM</a><ul class="sub-list"><li class="sub-list-item"><a class="list-link" href="#ch8-1">8.1 window 对象</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch8-1-1">8.1.1 全局作用域</a></li><li class="sub2-list-item"><a class="list-link" href="#ch8-1-2">8.1.2 窗口关系及框架</a></li><li class="sub2-list-item"><a class="list-link" href="#ch8-1-3">8.1.3 窗口位置</a></li><li class="sub2-list-item"><a class="list-link" href="#ch8-1-4">8.1.4 窗口大小</a></li><li class="sub2-list-item"><a class="list-link" href="#ch8-1-5">8.1.5 导航和打开窗口</a></li><li class="sub2-list-item"><a class="list-link" href="#ch8-1-6">8.1.6 间歇调用和超时调用</a></li><li class="sub2-list-item"><a class="list-link" href="#ch8-1-7">8.1.7 系统对话框</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch8-2">8.2 location 对象</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch8-2-1">8.2.1 查询字符串参数</a></li><li class="sub2-list-item"><a class="list-link" href="#ch8-2-2">8.2.2 位置操作</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch8-3"> 8.3 navigator 对象</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch8-3-1">8.3.1 检测插件</a></li><li class="sub2-list-item"><a class="list-link" href="#ch8-3-2">8.3.2 注册处理程序</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch8-4">8.4 screen 对象</a></li><li class="sub-list-item"><a class="list-link" href="#ch8-5">8.5 history 对象</a></li><li class="sub-list-item"><a class="list-link" href="#ch8-6">8.6 小结</a></li></ul></li><li class="list-first"><a class="list-link" href="#ch9">第 9 章 客户端检测</a><ul class="sub-list"><li class="sub-list-item"><a class="list-link" href="#ch9-1">9.1 能力检测</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch9-1-1">9.1.1 更可靠的能力检测</a></li><li class="sub2-list-item"><a class="list-link" href="#ch9-1-2">9.1.2 能力检测，不是浏览器检测</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch9-2">9.2 怪癖检测</a></li><li class="sub-list-item"><a class="list-link" href="#ch9-3"></a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch9-3-1">9.3.1 用户代理字符串的历史</a></li><li class="sub2-list-item"><a class="list-link" href="#ch9-3-2">9.3.2 用户代理字符串检测技术</a></li><li class="sub2-list-item"><a class="list-link" href="#ch9-3-3">9.3.3 完整的代码</a></li><li class="sub2-list-item"><a class="list-link" href="#ch9-3-4">9.3.4 使用方法</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch9-4">9.4 小结</a></li></ul></li><li class="list-first"><a class="list-link" href="#ch10">第 10 章 DOM</a><ul class="sub-list"><li class="sub-list-item"><a class="list-link" href="#ch10-1">10.1 节点层次</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch10-1-1">10.1.1 Node 类型</a></li><li class="sub2-list-item"><a class="list-link" href="#ch10-1-2">10.1.2 Document 类型</a></li><li class="sub2-list-item"><a class="list-link" href="#ch10-1-3">10.1.3 Element 类型</a></li><li class="sub2-list-item"><a class="list-link" href="#ch10-1-4">10.1.4 Text 类型</a></li><li class="sub2-list-item"><a class="list-link" href="#ch10-1-5">10.1.5 Comment 类型</a></li><li class="sub2-list-item"><a class="list-link" href="#ch10-1-6">10.1.6 CDATASection 类型</a></li><li class="sub2-list-item"><a class="list-link" href="#ch10-1-7">10.1.7 DocumentType 类型</a></li><li class="sub2-list-item"><a class="list-link" href="#ch10-1-8">10.1.8 DocumentFragment 类型</a></li><li class="sub2-list-item"><a class="list-link" href="#ch10-1-9">10.1.9 Attr 类型</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch10-2">10.2 DOM 操作技术</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch10-2-1">10.2.1 动态脚本</a></li><li class="sub2-list-item"><a class="list-link" href="#ch10-2-2">10.2.2 动态样式</a></li><li class="sub2-list-item"><a class="list-link" href="#ch10-2-3">10.2.3 操作表格</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch10-3">10.3 小结</a></li></ul></li><li class="list-first"><a class="list-link" href="#ch11">第 11 章 DOM 扩展</a><ul class="sub-list"><li class="sub-list-item"><a class="list-link" href="#ch11-1">11.1 选择符 API</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch11-1-1">11.1.1 querySelector()方法</a></li><li class="sub2-list-item"><a class="list-link" href="#ch11-1-2">11.1.2 querySelectorAll()方法</a></li><li class="sub2-list-item"><a class="list-link" href="#ch11-1-3">11.1.3 matchesSelector()方法</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch11-2">11.2 元素遍历</a></li><li class="sub-list-item"><a class="list-link" href="#ch11-3">11.3 HTML5</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch11-3-1">11.3.1 与类相关的扩充</a></li><li class="sub2-list-item"><a class="list-link" href="#ch11-3-2">11.3.2 焦点管理</a></li><li class="sub2-list-item"><a class="list-link" href="#ch11-3-3">11.3.3 HTMLDocument 的变化</a></li><li class="sub2-list-item"><a class="list-link" href="#ch11-3-4">11.3.4 字符集属性</a></li><li class="sub2-list-item"><a class="list-link" href="#ch11-3-5">11.3.5 自定义数据属性</a></li><li class="sub2-list-item"><a class="list-link" href="#ch11-3-6">11.3.6 插入标记</a></li><li class="sub2-list-item"><a class="list-link" href="#ch11-3-7">11.3.7 scrollIntoView()方法</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch11-4">11.4 专有扩展</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch11-1-1">11.4.1 文档模式</a></li><li class="sub2-list-item"><a class="list-link" href="#ch11-1-2">11.4.2 children 属性</a></li><li class="sub2-list-item"><a class="list-link" href="#ch11-1-3">11.4.3 contains()方法</a></li><li class="sub2-list-item"><a class="list-link" href="#ch11-1-4">11.4.4 插入文本</a></li><li class="sub2-list-item"><a class="list-link" href="#ch11-1-5">11.4.5 滚动</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch11-5">11.5 小结</a></li></ul></li><li class="list-first"><a class="list-link" href="#ch12">第 12 章 DOM2 和 DOM3</a><ul class="sub-list"><li class="sub-list-item"><a class="list-link" href="#ch12-1">12.1 DOM 变化</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch12-1-1">12.1.1 针对 XML 命名空间的变化</a></li><li class="sub2-list-item"><a class="list-link" href="#ch12-1-2">12.1.2 其他方面的变化</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch12-2">12.2 样式</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch12-2-1">12.2.1 访问元素的样式</a></li><li class="sub2-list-item"><a class="list-link" href="#ch12-2-2">12.2.2 操作样式表</a></li><li class="sub2-list-item"><a class="list-link" href="#ch12-2-3">12.2.3 元素大小</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch12-3">12.3 遍历</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch12-3-1">12.3.1 NodeIterator</a></li><li class="sub2-list-item"><a class="list-link" href="#ch12-3-2">12.3.2 TreeWalker</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch12-4">12.4 范围</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch12-4-1">12.4.1 DOM 中的范围</a></li><li class="sub2-list-item"><a class="list-link" href="#ch12-4-2">12.4.2 IE8 及更早版本中的范围</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch12-5">12.5 小结</a></li></ul></li><li class="list-first"><a class="list-link" href="#ch13">第 13 章 事件</a><ul class="sub-list"><li class="sub-list-item"><a class="list-link" href="#ch13-1">13.1 事件流</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch13-1-1">13.1.1 事件冒泡</a></li><li class="sub2-list-item"><a class="list-link" href="#ch13-1-2">13.1.2 事件捕获</a></li><li class="sub2-list-item"><a class="list-link" href="#ch13-1-3">13.1.3 DOM 事件流</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch13-2">13.2 事件处理程序</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch13-2-1">13.2.1 HTML 事件处理程序</a></li><li class="sub2-list-item"><a class="list-link" href="#ch13-2-2">13.2.2 DOM0 级事件处理程序</a></li><li class="sub2-list-item"><a class="list-link" href="#ch13-2-3">13.2.3 DOM2 级事件处理程序</a></li><li class="sub2-list-item"><a class="list-link" href="#ch13-2-4">13.2.4 IE 事件处理程序</a></li><li class="sub2-list-item"><a class="list-link" href="#ch13-2-5">13.2.5 跨浏览器的事件处理程序</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch13-3">13.3 事件对象</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch13-3-1">13.3.1 DOM 中的事件对象</a></li><li class="sub2-list-item"><a class="list-link" href="#ch13-3-2">13.3.2 IE 中的事件对象</a></li><li class="sub2-list-item"><a class="list-link" href="#ch13-3-3">13.3.3 跨浏览器的事件对象</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch13-4">13.4 事件类型</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch13-4-1">13.4.1 UI 事件</a></li><li class="sub2-list-item"><a class="list-link" href="#ch13-4-2">13.4.2 焦点事件</a></li><li class="sub2-list-item"><a class="list-link" href="#ch13-4-3">13.4.3 鼠标与滚轮事件</a></li><li class="sub2-list-item"><a class="list-link" href="#ch13-4-4">13.4.4 键盘与文本事件</a></li><li class="sub2-list-item"><a class="list-link" href="#ch13-4-5">13.4.5 复合事件</a></li><li class="sub2-list-item"><a class="list-link" href="#ch13-4-6">13.4.6 变动事件</a></li><li class="sub2-list-item"><a class="list-link" href="#ch13-4-7">13.4.7 HTML5 事件</a></li><li class="sub2-list-item"><a class="list-link" href="#ch13-4-8">13.4.8 设备事件</a></li><li class="sub2-list-item"><a class="list-link" href="#ch13-4-9">13.4.9 触摸与手势事件</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch13-5">13.5 内存和性能</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch13-5-1">13.5.1 事件委托</a></li><li class="sub2-list-item"><a class="list-link" href="#ch13-5-2">13.5.2 移除事件处理程序</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch13-6">13.6 模拟事件</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch13-6-1">13.6.1 DOM 中的事件模拟</a></li><li class="sub2-list-item"><a class="list-link" href="#ch13-6-2">13.6.2 IE 中的事件模拟</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch13-7">13.7 小结</a></li></ul></li><li class="list-first"><a class="list-link" href="#ch14">第 14 章 表单脚本</a><ul class="sub-list"><li class="sub-list-item"><a class="list-link" href="#ch14-1">14.1 表单的基础知识</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch14-1-1">14.1.1 提交表单</a></li><li class="sub2-list-item"><a class="list-link" href="#ch14-1-2">14.1.2 重置表单</a></li><li class="sub2-list-item"><a class="list-link" href="#ch14-1-3">14.1.3 表单字段</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch14-2">14.2 文本框脚本</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch14-2-1">14.2.1 选择文本</a></li><li class="sub2-list-item"><a class="list-link" href="#ch14-2-2">14.2.2 过滤输入</a></li><li class="sub2-list-item"><a class="list-link" href="#ch14-2-3">14.2.3 自动切换焦点</a></li><li class="sub2-list-item"><a class="list-link" href="#ch14-2-4">14.2.4 HTML5 约束验证 API</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch14-3">14.3 选择框脚本</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch14-3-1">14.3.1 选择选项</a></li><li class="sub2-list-item"><a class="list-link" href="#ch14-3-2">14.3.2 添加选项</a></li><li class="sub2-list-item"><a class="list-link" href="#ch14-3-3">14.3.3 移除选项</a></li><li class="sub2-list-item"><a class="list-link" href="#ch14-3-4">14.3.4 移动和重排选项</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch14-4">14.4 表单序列化</a></li><li class="sub-list-item"><a class="list-link" href="#ch14-5">14.5 富文本编辑</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch14-5-1">14.5.1 使用 contenteditable属性</a></li><li class="sub2-list-item"><a class="list-link" href="#ch14-5-2">14.5.2 操作富文本</a></li><li class="sub2-list-item"><a class="list-link" href="#ch14-5-3">14.5.3 富文本选区</a></li><li class="sub2-list-item"><a class="list-link" href="#ch14-5-4">14.5.4 表单与富文本</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch14-6">14.6 小结</a></li></ul></li><li class="list-first"><a class="list-link" href="#ch15">第 15 章 使用 Canvas 绘图</a><ul class="sub-list"><li class="sub-list-item"><a class="list-link" href="#ch15-1">15.1 基本用法</a></li><li class="sub-list-item"><a class="list-link" href="#ch15-2">15.2 2D 上下文</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch15-2-1">15.2.1 填充和描边</a></li><li class="sub2-list-item"><a class="list-link" href="#ch15-2-2">15.2.2 绘制矩形</a></li><li class="sub2-list-item"><a class="list-link" href="#ch15-2-3">15.2.3 绘制路径</a></li><li class="sub2-list-item"><a class="list-link" href="#ch15-2-4">15.2.4 绘制文本</a></li><li class="sub2-list-item"><a class="list-link" href="#ch15-2-5">15.2.5 变换</a></li><li class="sub2-list-item"><a class="list-link" href="#ch15-2-6">15.2.6 绘制图像</a></li><li class="sub2-list-item"><a class="list-link" href="#ch15-2-7">15.2.7 阴影</a></li><li class="sub2-list-item"><a class="list-link" href="#ch15-2-8">15.2.8 渐变</a></li><li class="sub2-list-item"><a class="list-link" href="#ch15-2-9">15.2.9 模式</a></li><li class="sub2-list-item"><a class="list-link" href="#ch15-2-10">15.2.10 使用图像数据</a></li><li class="sub2-list-item"><a class="list-link" href="#ch15-2-11">15.2.11 合成</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch15-3">15.3 WebGL</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch15-3-1">15.3.1 类型化数组</a></li><li class="sub2-list-item"><a class="list-link" href="#ch15-3-2">15.3.2 WebGL 上下文</a></li><li class="sub2-list-item"><a class="list-link" href="#ch15-3-3">15.3.3 支持</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch15-4">15.4 小结</a></li></ul></li><li class="list-first"><a class="list-link" href="#ch16">第 16 章 HTML5 脚本编程</a><ul class="sub-list"><li class="sub-list-item"><a class="list-link" href="#ch16-1">16.1 跨文档消息传递</a></li><li class="sub-list-item"><a class="list-link" href="#ch16-2">16.2 原生拖放</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch16-1-1">16.2.1 拖放事件</a></li><li class="sub2-list-item"><a class="list-link" href="#ch16-1-2">16.2.2 自定义放置目标</a></li><li class="sub2-list-item"><a class="list-link" href="#ch16-1-3">16.2.3 dataTransfer 对象</a></li><li class="sub2-list-item"><a class="list-link" href="#ch16-1-4">16.2.4 dropEffect 与effectAllowed</a></li><li class="sub2-list-item"><a class="list-link" href="#ch16-1-5">16.2.5 可拖动</a></li><li class="sub2-list-item"><a class="list-link" href="#ch16-1-6">16.2.6 其他成员</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch16-3"></a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch16-3-1">16.3.1 属性</a></li><li class="sub2-list-item"><a class="list-link" href="#ch16-3-2">16.3.2 事件</a></li><li class="sub2-list-item"><a class="list-link" href="#ch16-3-3">16.3.3 自定义媒体播放器</a></li><li class="sub2-list-item"><a class="list-link" href="#ch16-3-4">16.3.4 检测编解码器的支持情况</a></li><li class="sub2-list-item"><a class="list-link" href="#ch16-3-5">16.3.5 Audio 类型</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch16-4">16.4 历史状态管理</a></li><li class="sub-list-item"><a class="list-link" href="#ch16-5">16.5 小结</a></li></ul></li><li class="list-first"><a class="list-link" href="#ch17">第 17 章 错误处理与调试</a><ul class="sub-list"><li class="sub-list-item"><a class="list-link" href="#ch17-1">17.1 浏览器报告的错误</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch17-1-1">17.1.1 IE</a></li><li class="sub2-list-item"><a class="list-link" href="#ch17-1-2">17.1.2 Firefox</a></li><li class="sub2-list-item"><a class="list-link" href="#ch17-1-3">17.1.3 Safari</a></li><li class="sub2-list-item"><a class="list-link" href="#ch17-1-4">17.1.4 Opera</a></li><li class="sub2-list-item"><a class="list-link" href="#ch17-1-5">17.1.5 Chrome</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch17-2">17.2 错误处理</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch17-2-1">17.2.1 try-catch 语句</a></li><li class="sub2-list-item"><a class="list-link" href="#ch17-2-2">17.2.2 抛出错误</a></li><li class="sub2-list-item"><a class="list-link" href="#ch17-2-3">17.2.3 错误（error）事件</a></li><li class="sub2-list-item"><a class="list-link" href="#ch17-2-4">17.2.4 处理错误的策略</a></li><li class="sub2-list-item"><a class="list-link" href="#ch17-2-5">17.2.5 常见的错误类型</a></li><li class="sub2-list-item"><a class="list-link" href="#ch17-2-6">17.2.6 区分致命错误和非致命错误</a></li><li class="sub2-list-item"><a class="list-link" href="#ch17-2-7">17.2.7 把错误记录到服务器</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch17-3">17.3 调试技术</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch17-3-1">17.3.1 将消息记录到控制台</a></li><li class="sub2-list-item"><a class="list-link" href="#ch17-3-2">17.3.2 将消息记录到当前页面</a></li><li class="sub2-list-item"><a class="list-link" href="#ch17-3-3">17.3.3 抛出错误</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch17-4">17.4 常见的 IE 错误</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch17-4-1">17.4.1 操作终止</a></li><li class="sub2-list-item"><a class="list-link" href="#ch17-4-2">17.4.2 无效字符</a></li><li class="sub2-list-item"><a class="list-link" href="#ch17-4-3">17.4.3 未找到成员</a></li><li class="sub2-list-item"><a class="list-link" href="#ch17-4-4">17.4.4 未知运行时错误</a></li><li class="sub2-list-item"><a class="list-link" href="#ch17-4-5">17.4.5 语法错误</a></li><li class="sub2-list-item"><a class="list-link" href="#ch17-4-6">17.4.6 系统无法找到指定资源</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch17-5">17.5 小结</a></li></ul></li><li class="list-first"><a class="list-link" href="#ch18">第 18 章 JavaScript 与 XML</a><ul class="sub-list"><li class="sub-list-item"><a class="list-link" href="#ch18-1">18.1 浏览器对 XML DOM 的支持</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch18-1-1">18.1.1 DOM2 级核心</a></li><li class="sub2-list-item"><a class="list-link" href="#ch18-1-2">18.1.2 DOMParser 类型</a></li><li class="sub2-list-item"><a class="list-link" href="#ch18-1-3">18.1.3 XMLSerializer 类型</a></li><li class="sub2-list-item"><a class="list-link" href="#ch18-1-4">18.1.4 IE8 及之前版本中的 XML</a></li><li class="sub2-list-item"><a class="list-link" href="#ch18-1-5">18.1.5 跨浏览器处理 XML</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch18-2">18.2 浏览器对 XPath 的支持</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch18-2-1">18.2.1 DOM3 级 XPath</a></li><li class="sub2-list-item"><a class="list-link" href="#ch18-2-2">18.2.2 IE 中的 XPath</a></li><li class="sub2-list-item"><a class="list-link" href="#ch18-2-3">18.2.3 跨浏览器使用 XPath</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch18-3">18.3 浏览器对 XSLT 的支持</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch18-3-1">18.3.1 IE 中的 XSLT</a></li><li class="sub2-list-item"><a class="list-link" href="#ch18-3-2">18.3.2 XSLTProcessor 类型</a></li><li class="sub2-list-item"><a class="list-link" href="#ch18-3-3">18.3.3 跨浏览器使用 XSLT</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch18-4">18.4 小结</a></li></ul></li><li class="list-first"><a class="list-link" href="#ch19">第 19 章 E4X</a><ul class="sub-list"><li class="sub-list-item"><a class="list-link" href="#ch19-1">19.1 E4X 的类型</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch19-1-1">19.1.1 XML 类型</a></li><li class="sub2-list-item"><a class="list-link" href="#ch19-1-2">19.1.2 XMLList 类型</a></li><li class="sub2-list-item"><a class="list-link" href="#ch19-1-3">19.1.3 Namespace 类型</a></li><li class="sub2-list-item"><a class="list-link" href="#ch19-1-4">19.1.4 QName 类型</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch19-2">19.2 一般用法</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch19-2-1">19.2.1 访问特性</a></li><li class="sub2-list-item"><a class="list-link" href="#ch19-2-2">19.2.2 其他节点类型</a></li><li class="sub2-list-item"><a class="list-link" href="#ch19-2-3">19.2.3 查询</a></li><li class="sub2-list-item"><a class="list-link" href="#ch19-2-4">19.2.4 构建和操作 XML</a></li><li class="sub2-list-item"><a class="list-link" href="#ch19-2-5">19.2.5 解析和序列化</a></li><li class="sub2-list-item"><a class="list-link" href="#ch19-2-6">19.2.6 命名空间</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch19-3">19.3 其他变化</a></li><li class="sub-list-item"><a class="list-link" href="#ch19-4">19.4 全面启用 E4X</a></li><li class="sub-list-item"><a class="list-link" href="#ch19-5">19.5 小结</a></li></ul></li><li class="list-first"><a class="list-link" href="#ch20">第 20 章 JSON</a><ul class="sub-list"><li class="sub-list-item"><a class="list-link" href="#ch20-1">20.1 语法</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch20-1-1">20.1.1 简单值</a></li><li class="sub2-list-item"><a class="list-link" href="#ch20-1-2">20.1.2 对象</a></li><li class="sub2-list-item"><a class="list-link" href="#ch20-1-3">20.1.3 数组</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch20-2">20.2 解析与序列化</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch20-2-1">20.2.1 JSON 对象</a></li><li class="sub2-list-item"><a class="list-link" href="#ch20-2-2">20.2.2 序列化选项</a></li><li class="sub2-list-item"><a class="list-link" href="#ch20-2-3">20.2.3 解析选项</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch20-3">20.3 小结</a></li></ul></li><li class="list-first"><a class="list-link" href="#ch21">第 21 章 Ajax 与 Comet</a><ul class="sub-list"><li class="sub-list-item"><a class="list-link" href="#ch21-1">21.1 XMLHttpRequest 对象</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch21-1-1">21.1.1 XHR 的用法</a></li><li class="sub2-list-item"><a class="list-link" href="#ch21-1-2">21.1.2 HTTP 头部信息</a></li><li class="sub2-list-item"><a class="list-link" href="#ch21-1-3">21.1.3 GET 请求</a></li><li class="sub2-list-item"><a class="list-link" href="#ch21-1-4">21.1.4 POST 请求</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch21-2">21.2 XMLHttpRequest 2 级</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch21-2-1">21.2.1 FormData</a></li><li class="sub2-list-item"><a class="list-link" href="#ch21-2-2">21.2.2 超时设定</a></li><li class="sub2-list-item"><a class="list-link" href="#ch21-2-3">21.2.3 overrideMimeType()方法</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch21-3">21.3 进度事件</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch21-3-1">21.3.1 load 事件</a></li><li class="sub2-list-item"><a class="list-link" href="#ch21-3-2">21.3.2 progress 事件</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch21-4">21.4 跨源资源共享</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch21-4-1">21.4.1 IE 对 CORS 的实现</a></li><li class="sub2-list-item"><a class="list-link" href="#ch21-4-1">21.4.2 其他浏览器对 CORS 的实现</a></li><li class="sub2-list-item"><a class="list-link" href="#ch21-4-2">21.4.3 Preflighted Reqeusts</a></li><li class="sub2-list-item"><a class="list-link" href="#ch21-4-2">21.4.4 带凭据的请求</a></li><li class="sub2-list-item"><a class="list-link" href="#ch21-4-2">21.4.5 跨浏览器的 CORS</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch21-5">21.5 其他跨域技术</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch21-5-1">21.5.1 图像 Ping</a></li><li class="sub2-list-item"><a class="list-link" href="#ch21-5-2">21.5.2 JSONP</a></li><li class="sub2-list-item"><a class="list-link" href="#ch21-5-2">21.5.3 Comet</a></li><li class="sub2-list-item"><a class="list-link" href="#ch21-5-2">21.5.4 服务器发送事件</a></li><li class="sub2-list-item"><a class="list-link" href="#ch21-5-2">21.5.5 Web Sockets</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch21-6">21.6 安全</a></li><li class="sub-list-item"><a class="list-link" href="#ch21-7">21.7 小结</a></li></ul></li><li class="list-first"><a class="list-link" href="#ch22">第 22 章 高级技巧</a><ul class="sub-list"><li class="sub-list-item"><a class="list-link" href="#ch22-1">22.1 高级函数</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch22-1-1">22.1.1 安全的类型检测</a></li><li class="sub2-list-item"><a class="list-link" href="#ch22-1-2">22.1.2 作用域安全的构造函数</a></li><li class="sub2-list-item"><a class="list-link" href="#ch22-1-3">22.1.3 惰性载入函数</a></li><li class="sub2-list-item"><a class="list-link" href="#ch22-1-4">22.1.4 函数绑定</a></li><li class="sub2-list-item"><a class="list-link" href="#ch22-1-5">22.1.5 函数柯里化</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch22-2">22.2 防篡改对象</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch22-2-1">22.2.1 不可扩展对象</a></li><li class="sub2-list-item"><a class="list-link" href="#ch22-2-2">22.2.2 密封的对象</a></li><li class="sub2-list-item"><a class="list-link" href="#ch22-2-3">22.2.3 冻结的对象</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch22-3">22.3 高级定时器</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch22-3-1">22.3.1 重复的定时器</a></li><li class="sub2-list-item"><a class="list-link" href="#ch22-3-2">22.3.2 Yielding Processes</a></li><li class="sub2-list-item"><a class="list-link" href="#ch22-3-3">22.3.3 函数节流</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch22-4">22.4 自定义事件</a></li><li class="sub-list-item"><a class="list-link" href="#ch22-5">22.5 拖放</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch22-5-1">22.5.1 修缮拖动功能</a></li><li class="sub2-list-item"><a class="list-link" href="#ch22-5-2">22.5.2 添加自定义事件</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch22-6">22.6 小结</a></li></ul></li><li class="list-first"><a class="list-link" href="#ch23">第 23 章 离线应用与客户端存储</a><ul class="sub-list"><li class="sub-list-item"><a class="list-link" href="#ch23-1">23.1 离线检测</a></li><li class="sub-list-item"><a class="list-link" href="#ch23-2">23.2 应用缓存</a></li><li class="sub-list-item"><a class="list-link" href="#ch23-3">23.3 数据存储</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch23-3-1">23.3.1 Cookie</a></li><li class="sub2-list-item"><a class="list-link" href="#ch23-3-2">23.3.2 IE 用户数据</a></li><li class="sub2-list-item"><a class="list-link" href="#ch23-3-3">23.3.3 Web 存储机制</a></li><li class="sub2-list-item"><a class="list-link" href="#ch23-3-4">23.3.4 IndexedDB</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch23-4">23.4 小结</a></li></ul></li><li class="list-first"><a class="list-link" href="#ch24">第 24 章 最佳实践</a><ul class="sub-list"><li class="sub-list-item"><a class="list-link" href="#ch24-1">24.1 可维护性</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch24-1-1">24.1.1 什么是可维护的代码</a></li><li class="sub2-list-item"><a class="list-link" href="#ch24-1-2">24.1.2 代码约定</a></li><li class="sub2-list-item"><a class="list-link" href="#ch24-1-3">24.1.3 松散耦合</a></li><li class="sub2-list-item"><a class="list-link" href="#ch24-1-4">24.1.4 编程实践</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch24-2">24.2 性能</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch24-2-1">24.2.1 注意作用域</a></li><li class="sub2-list-item"><a class="list-link" href="#ch24-2-2">24.2.2 选择正确方法</a></li><li class="sub2-list-item"><a class="list-link" href="#ch24-2-3">24.2.3 最小化语句数</a></li><li class="sub2-list-item"><a class="list-link" href="#ch24-2-4">24.2.4 优化 DOM 交互</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch24-3">24.3 部署</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch24-1-1">24.3.1 构建过程</a></li><li class="sub2-list-item"><a class="list-link" href="#ch24-1-2">24.3.2 验证</a></li><li class="sub2-list-item"><a class="list-link" href="#ch24-1-3">24.3.3 压缩</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch24-4">24.4 小结</a></li></ul></li><li class="list-first"><a class="list-link" href="#ch25">第 25 章 新兴的 API</a><ul class="sub-list"><li class="sub-list-item"><a class="list-link" href="#ch25-1">25.1 requestAnimationFrame()</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch25-1-1">25.1.1 早期动画循环</a></li><li class="sub2-list-item"><a class="list-link" href="#ch25-1-2">25.1.2 循环间隔的问题</a></li><li class="sub2-list-item"><a class="list-link" href="#ch25-1-3">25.1.3 mozRequestAnimation-Frame</a></li><li class="sub2-list-item"><a class="list-link" href="#ch25-1-4">25.1.4 webkitRequestAnima-tionFrame 与 msRequest-AnimationFrame</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch25-2">25.2 Page Visibility API</a></li><li class="sub-list-item"><a class="list-link" href="#ch25-3">25.3 Geolocation API</a></li><li class="sub-list-item"><a class="list-link" href="#ch25-4">25.4 File API</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch25-1-1">25.4.1 FileReader 类型</a></li><li class="sub2-list-item"><a class="list-link" href="#ch25-1-2">25.4.2 读取部分内容</a></li><li class="sub2-list-item"><a class="list-link" href="#ch25-1-3">25.4.3 对象 URL</a></li><li class="sub2-list-item"><a class="list-link" href="#ch25-1-4">25.4.4 读取拖放的文件</a></li><li class="sub2-list-item"><a class="list-link" href="#ch25-1-5">25.4.5 使用 XHR 上传文件</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch25-5">25.5 Web 计时</a></li><li class="sub-list-item"><a class="list-link" href="#ch25-6">25.6 Web Workers</a><ul class="sub2-list"><li class="sub2-list-item"><a class="list-link" href="#ch25-1-1">25.6.1 使用 Worker</a></li><li class="sub2-list-item"><a class="list-link" href="#ch25-1-2">25.6.2 Worker 全局作用域</a></li><li class="sub2-list-item"><a class="list-link" href="#ch25-1-3">25.6.3 包含其他脚本</a></li><li class="sub2-list-item"><a class="list-link" href="#ch25-1-4">25.6.4 Web Workers 的未来</a></li></ul></li><li class="sub-list-item"><a class="list-link" href="#ch25-7">25.7 小结</a></li></ul></li><li class="list-first"><a class="list-link" href="#catalogue1">附录 A ECMAScript Harmony</a></li><li class="list-first"><a class="list-link" href="#catalogue2">附录 B 严格模式</a></li><li class="list-first"><a class="list-link" href="#catalogue3">附录 C JavaScript 库</a></li><li class="list-first"><a class="list-link" href="#catalogue4">附录 D JavaScript 工具</a></li></ul></div></aside></body></html>